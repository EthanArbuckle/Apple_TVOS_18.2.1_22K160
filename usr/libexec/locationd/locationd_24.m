void sub_100B9BE40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  uint64_t v42;
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9BEE8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    sub_100133F84((uint64_t)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ %@",  @"Rapport, rapport session activation error:",  a2));
    (*(void (**)(uint64_t))(*(void *)v2 + 248LL))(v2);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289026;
      int v5 = 0;
      __int16 v6 = 2082;
      v7 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Rapport, rapport session ready to listen for incoming devices}",  buf,  0x12u);
    }
  }

id sub_100B9C01C(uint64_t a1)
{
  return sub_100B9B698(a1 - 136);
}

std::string::size_type sub_100B9C024(std::string::size_type a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = sub_100B9C9B8(a1, "CLMicroLocationNotifier", a2);
  *(void *)(v8 + 136) = off_101874840;
  uint64_t v9 = v8 + 136;
  *(void *)(v8 + 144) = off_1018748E8;
  uint64_t v10 = v8 + 144;
  *(void *)uint64_t v8 = off_1018745C0;
  *(void *)(v8 + 112) = off_101874790;
  *(void *)(v8 + 120) = off_1018747E8;
  *(void *)(v8 + 128) = off_101874818;
  *(void *)(v8 + 160) = 0LL;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(void *)(v8 + 232) = 0LL;
  *(void *)(v8 + 240) = 0LL;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    uint64_t v32 = *(void *)(a3 + 16);
  }

  sub_1000243A4(a1 + 248, (__int128 *)__p, 2);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
  sub_100042DEC((void *)(a1 + 552), a1 + 248);
  sub_100123F78(a1 + 584, v9, a1 + 3208, a1 + 248, (uint64_t)objc_msgSend(objc_msgSend(a2, "silo"), "queue"));
  *(void *)(a1 + 3200) = 0LL;
  sub_1000C04C4(a1 + 3208, a1 + 584, a1 + 3200, a1 + 552);
  uint64_t v11 = *a4;
  *a4 = 0LL;
  *(void *)(a1 + 3416) = v11;
  sub_100121A18(a1 + 3424, v10, (uint64_t)objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "queue"));
  *(void *)(a1 + 3472) = 0LL;
  *(void *)(a1 + 3480) = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
  *(_OWORD *)(a1 + 3488) = 0u;
  *(_OWORD *)(a1 + 3504) = 0u;
  *(_OWORD *)(a1 + 3520) = 0u;
  *(void *)(a1 + 3536) = 0LL;
  *(void *)(a1 + 3544) = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  *(void *)(a1 + 3552) = objc_opt_new(&OBJC_CLASS___NSMutableSet);
  *(_OWORD *)(a1 + 3584) = 0u;
  *(_OWORD *)(a1 + 3560) = 0u;
  *(void *)(a1 + 3576) = a1 + 3584;
  *(_DWORD *)(a1 + 3608) = 0;
  uint64_t v12 = sub_1004F2598();
  if ((sub_1004FA4D0(v12) & 1) != 0)
  {
    sub_1004F2598();
    if (sub_1004F7694())
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      v13 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "MicroLocations not supported on Base System",  (uint8_t *)&buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        __int16 v28 = 0;
        LODWORD(v27) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "MicroLocations not supported on Base System",  &v28,  v27);
        v15 = (std::string *)v14;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationNotifier::CLMicroLocationNotifier(id<CLIntersiloUniverse>, std::string, std::unique_ptr<CLMicro LocationBackgroundActivities>)",  "%s\n",  v14);
LABEL_24:
        if (v15 != &buf) {
          free(v15);
        }
      }
    }

    else if (&wireless_diagnostics::google::protobuf::internal::VerifyVersion)
    {
      if (sub_1004F76B8() && (sub_1001B9A1C() & 1) == 0)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        v18 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "MicroLocations not supported on stationary Macs",  (uint8_t *)&buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_101874AF8);
          }
          __int16 v28 = 0;
          LODWORD(v27) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "MicroLocations not supported on stationary Macs",  &v28,  v27);
          v26 = (std::string *)v25;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationNotifier::CLMicroLocationNotifier(id<CLIntersiloUniverse>, std::string, std::unique_ptr<CLMic roLocationBackgroundActivities>)",  "%s\n",  v25);
          if (v26 != &buf) {
            free(v26);
          }
        }

        sub_10012B128(a1 + 584, 0);
      }

      *(void *)(a1 + 152) = objc_msgSend(objc_msgSend(a2, "silo"), "newTimer");
      *(void *)(a1 + 160) = 0x7FEFFFFFFFFFFFFFLL;
      *(void *)(a1 + 168) = objc_msgSend(objc_msgSend(a2, "silo"), "newTimer");
      *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
      [*(id *)(a1 + 3480) setDateFormat:@"yyyyMMdd_HH-mm-ss"];
      sub_100063930((uint64_t)&v28);
      sub_100B9B2D0(&buf);
      v30 |= 2u;
      v19 = v29;
      if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        v19 = (std::string *)operator new(0x18uLL);
        v19->__r_.__value_.__r.__words[0] = 0LL;
        v19->__r_.__value_.__l.__size_ = 0LL;
        v19->__r_.__value_.__l.__cap_ = 0LL;
        v29 = v19;
      }

      std::string::operator=(v19, &buf);
      HIDWORD(v27) = 0;
      sub_100018E34((int *)&v27 + 1);
      *(void *)&__int128 v33 = sub_100017338((ssize_t)&v27 + 4);
      *((void *)&v33 + 1) = v20;
      double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
      sub_100B9CA54(&v33, (uint64_t)&v28, (uint64_t)&buf, Current_1);
      sub_100042DF8((uint64_t *)(a1 + 552), (__int128 *)&buf);
      sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v35);
      sub_100019D7C((unsigned int *)&v27 + 1);
      sub_100B9CADC(a1);
      sub_10007DF10((wireless_diagnostics::google::protobuf::MessageLite *)&v28);
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "failed to dynamicly load protobuf lib symbol",  (uint8_t *)&buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        __int16 v28 = 0;
        LODWORD(v27) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  17LL,  "failed to dynamicly load protobuf lib symbol",  &v28,  v27);
        v15 = (std::string *)v24;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLMicroLocationNotifier::CLMicroLocationNotifier(id<CLIntersiloUniverse>, std::string, std::unique_ptr<CLMicro LocationBackgroundActivities>)",  "%s\n",  v24);
        goto LABEL_24;
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v16 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "MicroLocations not supported on this platform",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      __int16 v28 = 0;
      LODWORD(v27) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "MicroLocations not supported on this platform",  &v28,  v27);
      v15 = (std::string *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationNotifier::CLMicroLocationNotifier(id<CLIntersiloUniverse>, std::string, std::unique_ptr<CLMicroLo cationBackgroundActivities>)",  "%s\n",  v17);
      goto LABEL_24;
    }
  }

  return a1;
}

void sub_100B9C808( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  v38 = (void **)(v32 + 3488);
  v39 = *(void **)(v32 + 3512);
  if (v39)
  {
    *(void *)(v32 + 3520) = v39;
    operator delete(v39);
  }

  v40 = *v38;
  if (*v38)
  {
    *(void *)(v32 + 3496) = v40;
    operator delete(v40);
  }

  sub_100B9E9B8((uint64_t *)(v32 + 3416), 0LL);
  *(void *)(v32 + 3208) = &off_10181D848;
  if (*(_BYTE *)(v32 + 3288)) {
    sub_100078068(v32 + 3216);
  }
  sub_100124250(v35);
  sub_1000433C4(v34);
  sub_1000244B0(v33);
  uint64_t v41 = *(void *)(v32 + 216);
  *(void *)(v32 + 216) = 0LL;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
  }
  uint64_t v42 = *(void *)(v32 + 208);
  *(void *)(v32 + 208) = 0LL;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8LL))(v42);
  }
  uint64_t v43 = *(void *)(v32 + 200);
  *(void *)(v32 + 200) = 0LL;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  uint64_t v44 = *(void *)(v32 + 192);
  *(void *)(v32 + 192) = 0LL;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8LL))(v44);
  }
  uint64_t v45 = *(void *)(v32 + 184);
  *(void *)(v32 + 184) = 0LL;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8LL))(v45);
  }
  sub_100B9D2C8(v32);
  _Unwind_Resume(a1);
}

uint64_t sub_100B9C9B8(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101874E88;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100B9CA38(_Unwind_Exception *exception_object)
{
}

void sub_100B9CA54(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100B9CAC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B9CADC(std::string::size_type a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "MicroLocations startClients",  (uint8_t *)&buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    LOWORD(v44[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "MicroLocations startClients",  v44,  2);
    uint64_t v42 = (std::string *)v41;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationNotifier::startClients()", "%s\n", v41);
    if (v42 != &buf) {
      free(v42);
    }
  }

  id v3 =  -[CLMicroLocationLoiBridge initInUniverse:]( objc_alloc(&OBJC_CLASS___CLMicroLocationLoiBridge),  "initInUniverse:",  *(void *)(a1 + 32));
  *(void *)(a1 + 3192) = v3;
  sub_100124350(a1 + 584, v3);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101874F68;
  buf.__r_.__value_.__l.__size_ = a1;
  p_std::string buf = &buf;
  sub_100124328(a1 + 584, (uint64_t)&buf);
  v4 = p_buf;
  if (p_buf == &buf)
  {
    uint64_t v5 = 4LL;
    v4 = &buf;
  }

  else
  {
    if (!p_buf) {
      goto LABEL_11;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(v4->__r_.__value_.__r.__words[0] + 8 * v5))();
LABEL_11:
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101874FF8;
  buf.__r_.__value_.__l.__size_ = a1;
  p_std::string buf = &buf;
  sub_100124330(a1 + 584, (uint64_t)&buf);
  __int16 v6 = p_buf;
  if (p_buf == &buf)
  {
    uint64_t v7 = 4LL;
    __int16 v6 = &buf;
  }

  else
  {
    if (!p_buf) {
      goto LABEL_16;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(v6->__r_.__value_.__r.__words[0] + 8 * v7))();
LABEL_16:
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101875088;
  buf.__r_.__value_.__l.__size_ = a1;
  p_std::string buf = &buf;
  sub_100124338(a1 + 584, (uint64_t)&buf);
  uint64_t v8 = p_buf;
  if (p_buf == &buf)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = &buf;
  }

  else
  {
    if (!p_buf) {
      goto LABEL_21;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(v8->__r_.__value_.__r.__words[0] + 8 * v9))();
LABEL_21:
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101875118;
  buf.__r_.__value_.__l.__size_ = a1;
  p_std::string buf = &buf;
  sub_100124340(a1 + 584, (uint64_t)&buf);
  uint64_t v10 = p_buf;
  if (p_buf == &buf)
  {
    uint64_t v11 = 4LL;
    uint64_t v10 = &buf;
  }

  else
  {
    if (!p_buf) {
      goto LABEL_26;
    }
    uint64_t v11 = 5LL;
  }

  (*(void (**)(void))(v10->__r_.__value_.__r.__words[0] + 8 * v11))();
LABEL_26:
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1018751A8;
  buf.__r_.__value_.__l.__size_ = a1;
  p_std::string buf = &buf;
  sub_100124348(a1 + 584, (uint64_t)&buf);
  uint64_t v12 = p_buf;
  if (p_buf == &buf)
  {
    uint64_t v13 = 4LL;
    uint64_t v12 = &buf;
    goto LABEL_30;
  }

  if (p_buf)
  {
    uint64_t v13 = 5LL;
LABEL_30:
    (*(void (**)(void))(v12->__r_.__value_.__r.__words[0] + 8 * v13))();
  }

  sub_100055A0C((uint64_t *)(a1 + 3200));
  *(void *)(a1 + 240) = -[CLMicroLocationIntersiloDelegate initWithMicroLocationNotifier:]( objc_alloc(&OBJC_CLASS___CLMicroLocationIntersiloDelegate),  "initWithMicroLocationNotifier:",  a1);
  sub_100EE2800((uint64_t)sub_100B9D8A8, a1, *(void **)(a1 + 32), &buf);
  std::string::size_type v14 = buf.__r_.__value_.__r.__words[0];
  buf.__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v15 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = v14;
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    std::string::size_type v16 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = 0LL;
    if (v16) {
      (*(void (**)(std::string::size_type))(*(void *)v16 + 8LL))(v16);
    }
  }

  std::string::size_type v17 = a1 + 208;
  [*(id *)(*(void *)(a1 + 208) + 16) register:*(void *)(*(void *)(a1 + 208) + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)v17 + 16) register:*(void *)(*(void *)v17 + 8) forNotification:9 registrationInfo:0];
  [*(id *)(*(void *)v17 + 16) register:*(void *)(*(void *)v17 + 8) forNotification:12 registrationInfo:0];
  sub_100583844((uint64_t)sub_100B9DA78, a1, *(void **)(a1 + 32), &buf);
  std::string::size_type v18 = buf.__r_.__value_.__r.__words[0];
  buf.__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v19 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = v18;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    std::string::size_type v20 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = 0LL;
    if (v20) {
      (*(void (**)(std::string::size_type))(*(void *)v20 + 8LL))(v20);
    }
  }

  memset(&buf, 0, sizeof(buf));
  std::string::operator=(&buf, (const std::string *)&qword_10199AC88);
  [*(id *)(*(void *)(a1 + 192) + 16) register:*(void *)(*(void *)(a1 + 192) + 8) forNotification:0 registrationInfo:sub_10120E548((uint64_t)&buf)];
  [*(id *)(*(void *)(a1 + 192) + 16) register:*(void *)(*(void *)(a1 + 192) + 8) forNotification:4 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 192) + 16) register:*(void *)(*(void *)(a1 + 192) + 8) forNotification:2 registrationInfo:0];
  BOOL v21 = sub_1002958AC() == 1;
  sub_10012AF40(a1 + 584, v21);
  sub_100ACD980((uint64_t)sub_100B9DC50, a1, *(void **)(a1 + 32), &buf);
  std::string::size_type v22 = buf.__r_.__value_.__r.__words[0];
  buf.__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v23 = *(void *)(a1 + 200);
  *(void *)(a1 + 200) = v22;
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    std::string::size_type v24 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
  }

  [*(id *)(*(void *)(a1 + 200) + 16) register:*(void *)(*(void *)(a1 + 200) + 8) forNotification:0 registrationInfo:0];
  sub_1003CC884((uint64_t)sub_100B9DE28, a1, *(void **)(a1 + 32), &buf);
  std::string::size_type v25 = buf.__r_.__value_.__r.__words[0];
  buf.__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v26 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = v25;
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
    std::string::size_type v27 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = 0LL;
    if (v27) {
      (*(void (**)(std::string::size_type))(*(void *)v27 + 8LL))(v27);
    }
  }

  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:15 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:14 registrationInfo:0];
  sub_1002F0B04(&buf);
  CFStringRef v28 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsInitialDelayForFetchPlaceInference",  0x8000100u,  kCFAllocatorNull);
  int v29 = sub_1002A77CC((uint64_t)buf.__r_.__value_.__l.__data_, (uint64_t)v28, v44);
  CFRelease(v28);
  unsigned int v30 = v44[0];
  size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
  if (buf.__r_.__value_.__l.__size_)
  {
    uint64_t v32 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }

  if (v29) {
    int64_t v34 = 1000000000LL * v30;
  }
  else {
    int64_t v34 = 5000000000LL;
  }
  dispatch_time_t v35 = dispatch_time(0LL, v34);
  v36 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100B9E000;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_after(v35, v36, block);
  sub_1004F2598();
  if (sub_1004F8A40())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_100B9E010,  @"com.apple.locationd.MicroLocationAction-localize",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
    v38 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( v38,  (const void *)a1,  (CFNotificationCallback)sub_100B9E010,  @"com.apple.locationd.MicroLocationAction-purge",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

  id v39 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLDuetMonitor");
  *(void *)(a1 + 232) = v39;
  [v39 registerDelegate:*(void *)(a1 + 240) inSilo:*(void *)(a1 + 40)];
  [*(id *)(a1 + 232) setDelegateEntityName:"CLMicroLocationNotifier"];
  if (!*(void *)(a1 + 3416))
  {
    v40 = operator new(0x28uLL);
    sub_100D1E6F0(v40, a1 + 112, a1 + 248);
    sub_100B9E9B8((uint64_t *)(a1 + 3416), (uint64_t)v40);
  }

void sub_100B9D234( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25)
{
}

uint64_t sub_100B9D2C8(uint64_t a1)
{
  *(void *)a1 = off_101874E88;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100589F4C(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100B9D33C(uint64_t a1)
{
  *(void *)a1 = off_1018745C0;
  *(void *)(a1 + 112) = off_101874790;
  *(void *)(a1 + 120) = off_1018747E8;
  *(void *)(a1 + 128) = off_101874818;
  *(void *)(a1 + 136) = off_101874840;
  *(void *)(a1 + 144) = off_1018748E8;
  uint64_t v2 = *(void **)(a1 + 152);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 152) = 0LL;
  }

  id v3 = *(void **)(a1 + 168);
  if (v3)
  {
    [v3 invalidate];

    *(void *)(a1 + 168) = 0LL;
  }

  v4 = *(void **)(a1 + 3568);
  if (v4)
  {
    [v4 invalidate];

    *(void *)(a1 + 3568) = 0LL;
  }

  uint64_t v5 = *(void **)(a1 + 3560);
  if (v5)
  {
    [v5 invalidate];

    *(void *)(a1 + 3560) = 0LL;
  }

  *(void *)(a1 + 3480) = 0LL;
  *(void *)(a1 + 3544) = 0LL;

  *(void *)(a1 + 3552) = 0LL;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  sub_100008390(a1 + 3576, *(void **)(a1 + 3584));
  __int16 v6 = *(void **)(a1 + 3512);
  if (v6)
  {
    *(void *)(a1 + 3520) = v6;
    operator delete(v6);
  }

  uint64_t v7 = *(void **)(a1 + 3488);
  if (v7)
  {
    *(void *)(a1 + 3496) = v7;
    operator delete(v7);
  }

  sub_100B9E9B8((uint64_t *)(a1 + 3416), 0LL);
  *(void *)(a1 + 3208) = &off_10181D848;
  if (*(_BYTE *)(a1 + 3288)) {
    sub_100078068(a1 + 3216);
  }
  sub_100124250(a1 + 584);
  sub_1000433C4((uint64_t *)(a1 + 552));
  sub_1000244B0(a1 + 248);
  uint64_t v8 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 200);
  *(void *)(a1 + 200) = 0LL;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  uint64_t v11 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  uint64_t v12 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0LL;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  return sub_100B9D2C8(a1);
}

uint64_t sub_100B9D50C(uint64_t a1)
{
  return sub_100B9D33C(a1 - 112);
}

uint64_t sub_100B9D514(uint64_t a1)
{
  return sub_100B9D33C(a1 - 120);
}

uint64_t sub_100B9D51C(uint64_t a1)
{
  return sub_100B9D33C(a1 - 128);
}

uint64_t sub_100B9D524(uint64_t a1)
{
  return sub_100B9D33C(a1 - 136);
}

uint64_t sub_100B9D52C(uint64_t a1)
{
  return sub_100B9D33C(a1 - 144);
}

void sub_100B9D534(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1);
  operator delete(v1);
}

void sub_100B9D548(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1 - 112);
  operator delete(v1);
}

void sub_100B9D560(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1 - 120);
  operator delete(v1);
}

void sub_100B9D578(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1 - 128);
  operator delete(v1);
}

void sub_100B9D590(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1 - 136);
  operator delete(v1);
}

void sub_100B9D5A8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100B9D33C(a1 - 144);
  operator delete(v1);
}

void sub_100B9D5C0(id *a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "MicroLocation: shutdown", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "MicroLocation: shutdown",  v5,  2);
    v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLMicroLocationNotifier::shutdown()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_100B9D758(a1);
}

void sub_100B9D758(id *a1)
{
  uint64_t v2 = (id *)a1[26];
  if (v2)
  {
    [v2[2] unregister:v2[1] forNotification:0];
    [*((id *)a1[26] + 2) unregister:*((void *)a1[26] + 1) forNotification:9];
    id v3 = a1[26];
    a1[26] = 0LL;
    if (v3) {
      (*(void (**)(id))(*(void *)v3 + 8LL))(v3);
    }
  }

  v4 = (id *)a1[24];
  if (v4)
  {
    [v4[2] unregister:v4[1] forNotification:0];
    [*((id *)a1[24] + 2) unregister:*((void *)a1[24] + 1) forNotification:4];
    [*((id *)a1[24] + 2) unregister:*((void *)a1[24] + 1) forNotification:2];
    id v5 = a1[24];
    a1[24] = 0LL;
    if (v5) {
      (*(void (**)(id))(*(void *)v5 + 8LL))(v5);
    }
  }

  __int16 v6 = (id *)a1[23];
  if (v6)
  {
    [v6[2] unregister:v6[1] forNotification:15];
    [*((id *)a1[23] + 2) unregister:*((void *)a1[23] + 1) forNotification:14];
    id v7 = a1[23];
    a1[23] = 0LL;
    if (v7) {
      (*(void (**)(id))(*(void *)v7 + 8LL))(v7);
    }
  }

  (*((void (**)(id *))*a1 + 27))(a1);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  [a1[29] stopMonitoringForClient:a1[30]];

  a1[29] = 0LL;
  sub_100055A44(a1 + 400);

  a1[28] = 0LL;
  a1[30] = 0LL;
  [a1[434] invalidate];

  a1[434] = 0LL;
}

void sub_100B9D8A8(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    id v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onDarwinNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      std::string::size_type v14 = "";
      __int16 v15 = 2082;
      std::string::size_type v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onDarwinNotification, event:%{public, location:escape_only }s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  sub_100B9FAD8(a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9DA58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9DA78(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onClientManagerNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onClientManagerNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100B9F3C4(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9DC30( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9DC50(uint64_t a1, int *a2, _DWORD *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onDataProtectionManagerNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onDataProtectionManagerNotification, event:%{public, locat ion:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100BA1948(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9DE08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9DE28(uint64_t a1, int *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onDaemonStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onDaemonStatusNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100B9FD60(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9DFE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B9E000(uint64_t a1)
{
  return nullsub_10(*(void *)(a1 + 32) + 584LL);
}

void sub_100B9E010(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    char v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onNotificationCenterNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    char v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2082;
      BOOL v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onNotificationCenterNotification, event:%{public, location :escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_100BA68F0;
  v13[3] = &unk_10182D1B8;
  v13[4] = a2;
  v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9E210( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9E230(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsEnabled", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v2, (BOOL *)v19);
  CFRelease(v2);
  int v4 = v19[0];
  id v5 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v4) {
    int v8 = v3;
  }
  else {
    int v8 = 0;
  }
  if (v8 == 1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Registering for leeched location updates",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      *(_WORD *)uint64_t v19 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Registering for leeched location updates",  v19,  2);
      __int16 v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    uint64_t v10 = *(void *)(a1 + 216);
    if (!v10)
    {
      sub_10043AC3C((uint64_t)sub_100B9E614, a1, *(void **)(a1 + 32), buf);
      uint64_t v11 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      uint64_t v12 = *(void *)(a1 + 216);
      *(void *)(a1 + 216) = v11;
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
        uint64_t v13 = *(void *)buf;
        *(void *)std::string buf = 0LL;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
        }
      }

      uint64_t v10 = *(void *)(a1 + 216);
    }

    [*(id *)(v10 + 16) register:*(void *)(v10 + 8) forNotification:5 registrationInfo:0];
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    __int16 v14 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Disabled - not registering for leeched location updates",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      *(_WORD *)uint64_t v19 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Disabled - not registering for leeched location updates",  v19,  2);
      __int16 v18 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

void sub_100B9E5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100B9E614(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMicroLocationNotifier::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationNotifier::onLocationNotification, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100BA073C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100B9E7CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9E7EC(uint64_t a1)
{
}

void sub_100B9E7F4(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  CFStringRef v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Deregistering from leeched location updates",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Deregistering from leeched location updates",  v7,  2);
    uint64_t v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationNotifier::deregisterForLeechedLocationUpdates()",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v3 = *(void *)(a1 + 216);
  if (v3)
  {
    [*(id *)(v3 + 16) unregister:*(void *)(v3 + 8) forNotification:5];
    uint64_t v4 = *(void *)(a1 + 216);
    *(void *)(a1 + 216) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

void sub_100B9E9B0(uint64_t a1)
{
}

void sub_100B9E9B8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_100D1EEE8(v3);
    operator delete(v4);
  }

void sub_100B9E9E4(uint64_t *a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  CFStringRef v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "CLMicroLocationNotifier: startSpectating",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v12[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "CLMicroLocationNotifier: startSpectating",  v12,  2);
    int v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLMicroLocationNotifier::startSpectating()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  int v13 = 0;
  sub_100018E34(&v13);
  *(void *)&__int128 v14 = sub_100017338((ssize_t)&v13);
  *((void *)&v14 + 1) = v3;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_100063790((uint64_t)v12);
  sub_100B9EDAC(&v14, (uint64_t)v12, (uint64_t)buf, Current_1);
  sub_100042DF8(a1 + 69, (__int128 *)buf);
  sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
  sub_1000796B0((wireless_diagnostics::google::protobuf::MessageLite *)v12);
  sub_100019D7C((unsigned int *)&v13);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  id v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "CLMicroLocationNotifier: register Biome", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v12[0] = 0;
    LODWORD(v11) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "CLMicroLocationNotifier: register Biome",  v12,  v11);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLMicroLocationNotifier::startSpectating()", "%s\n", v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  sub_100121A30(a1 + 428);
  [*(id *)(a1[23] + 16) register:*(void *)(a1[23] + 8) forNotification:7 registrationInfo:0];
  [*(id *)(a1[23] + 16) register:*(void *)(a1[23] + 8) forNotification:10 registrationInfo:0];
  sub_1004F2598();
  if (sub_1004F8A40())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_100B9E010,  @"com.apple.locationd.MicroLocationAction-record",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

void sub_100B9ED6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, unsigned int a15)
{
}

void sub_100B9EDAC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100B9EE20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B9EE34(uint64_t a1)
{
}

id sub_100B9EE3C(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  CFStringRef v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLMicroLocationNotifier: stopSpectating", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    v9[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "CLMicroLocationNotifier: stopSpectating",  v9,  2);
    int v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLMicroLocationNotifier::stopSpectating()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  int v10 = 0;
  sub_100018E34(&v10);
  *(void *)&__int128 v11 = sub_100017338((ssize_t)&v10);
  *((void *)&v11 + 1) = v3;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_1000637B0((uint64_t)v9);
  sub_100B9F120(&v11, (uint64_t)v9, (uint64_t)buf, Current_1);
  sub_100042DF8((uint64_t *)(a1 + 552), (__int128 *)buf);
  sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v13);
  sub_100079A70((wireless_diagnostics::google::protobuf::MessageLite *)v9);
  sub_100019D7C((unsigned int *)&v10);
  sub_10004306C((uint64_t *)(a1 + 552));
  [*(id *)(a1 + 232) stopMonitoringNowPlayingForClient:*(void *)(a1 + 240)];
  sub_1004F2598();
  if (sub_1004FA678())
  {
    [*(id *)(a1 + 232) stopMonitoringHomeKitAccessoryForClient:*(void *)(a1 + 240)];
    [*(id *)(a1 + 232) stopMonitoringHomeKitSceneForClient:*(void *)(a1 + 240)];
  }

  sub_100122268((id *)(a1 + 3424));
  [*(id *)(*(void *)(a1 + 184) + 16) unregister:*(void *)(*(void *)(a1 + 184) + 8) forNotification:7];
  [*(id *)(*(void *)(a1 + 184) + 16) unregister:*(void *)(*(void *)(a1 + 184) + 8) forNotification:10];
  sub_1004F2598();
  if (sub_1004F8A40())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  (const void *)a1,  @"com.apple.locationd.MicroLocationAction-record",  0LL);
  }

  sub_1000C1C7C(a1 + 3208);
  id result = [*(id *)(a1 + 168) invalidate];
  *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
  return result;
}

void sub_100B9F0E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, unsigned int a15)
{
}

void sub_100B9F120(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100B9F194( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100B9F1A8(uint64_t a1)
{
  return sub_100B9EE3C(a1 - 136);
}

uint64_t sub_100B9F1B0()
{
  return 1LL;
}

uint64_t sub_100B9F1B8()
{
  return 1LL;
}

void *sub_100B9F1C0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "NotificationMicroLocation");
}

void sub_100B9F1D0(uint64_t a1, const void **a2, uint64_t a3)
{
  if (*a2)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    id v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:learning callback, calling SPI response block for learning request}",  buf,  0x12u);
    }

    if (a3)
    {
      uint64_t v6 = objc_alloc(&OBJC_CLASS___NSError);
      NSErrorUserInfoKey v8 = NSLocalizedDescriptionKey;
      uint64_t v9 = a3;
       -[NSError initWithDomain:code:userInfo:]( v6,  "initWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v9,  &v8,  1LL));
    }

    (*((void (**)(void))*a2 + 2))();
    _Block_release(*a2);
    *a2 = 0LL;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:No SPI responses cached for learning completion}",  buf,  0x12u);
    }
  }

void sub_100B9F3C4(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v5 = *a3;
  if (*a3 == 4)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v27 = 2082;
      *(void *)&v27[2] = "";
      __int16 v28 = 2082;
      int v29 = "ClientManager";
      __int16 v30 = 2082;
      v31 = "Location services toggled";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
    }

    BOOL v10 = sub_1002958AC() == 1;
    sub_10012AF40(a1 + 584, v10);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Updating Significant Locations from Location Services Toggle",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    LOWORD(v25[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Updating Significant Locations from Location Services Toggle",  v25,  2);
    uint64_t v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const C LClientManager_Type::NotificationData &)",  "%s\n",  v12);
    goto LABEL_55;
  }

  if (v5 == 2)
  {
    if (!*(_BYTE *)(a4 + 97)) {
      return;
    }
    else {
      sub_100FE3FB4(a4, (uint64_t)buf);
    }
    if (SBYTE3(v29) < 0)
    {
      __int16 v18 = *(void **)buf;
      if (*(void *)v27 != 73LL)
      {
        operator delete(*(void **)buf);
        return;
      }

      int v19 = memcmp( *(const void **)buf,  "com.apple.locationd.bundle-/System/Library/LocationBundles/Routine.bundle",  0x49uLL);
      operator delete(v18);
      if (v19) {
        return;
      }
    }

    else if (SBYTE3(v29) != 73 {
           || memcmp(buf, "com.apple.locationd.bundle-/System/Library/LocationBundles/Routine.bundle", 0x49uLL))
    }
    {
      return;
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    __int16 v20 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v27 = 2082;
      *(void *)&v27[2] = "";
      __int16 v28 = 2082;
      int v29 = "ClientManager";
      __int16 v30 = 2082;
      v31 = "Authorization";
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
    }

    BOOL v21 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Updating Significant Locations from Auth Changed Notification",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    LOWORD(v25[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Updating Significant Locations from Auth Changed Notification",  v25,  2);
    uint64_t v13 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const C LClientManager_Type::NotificationData &)",  "%s\n",  v22);
LABEL_55:
    if (v13 != buf) {
      free(v13);
    }
    return;
  }

  if (!v5)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v27 = 2082;
      *(void *)&v27[2] = "";
      __int16 v28 = 2082;
      int v29 = "ClientManager";
      __int16 v30 = 2082;
      v31 = "Privacy reset";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
    }

    sub_10012B308(a1 + 584);
    sub_100BA2A38(a1);
    id v7 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLClientManager");
    if (byte_10199AC9F >= 0) {
      NSErrorUserInfoKey v8 = &qword_10199AC88;
    }
    else {
      NSErrorUserInfoKey v8 = (uint64_t *)qword_10199AC88;
    }
    objc_msgSend( v7,  "resetNotificationConsumedForIdentifier:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v8));
    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v16 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    int v17 = *a3;
    *(_DWORD *)std::string buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Unhandled manager notification %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v23 = *a3;
    v25[0] = 67240192;
    v25[1] = v23;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Unhandled manager notification %{public}d",  v25,  8);
    uint64_t v13 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const C LClientManager_Type::NotificationData &)",  "%s\n",  v24);
    goto LABEL_55;
  }

void sub_100B9FAD8(uint64_t a1, uint64_t a2, int *a3)
{
  int v4 = *a3;
  if (*a3 == 12)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "LocationOfInterestDidClear";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  (uint8_t *)&v8,  0x26u);
    }

    sub_10012B308(a1 + 584);
    sub_100BA2A38(a1);
  }

  else if (v4 == 9)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    id v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "Sysdiagnose Notification";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  (uint8_t *)&v8,  0x26u);
    }

    sub_100124500(a1 + 584);
  }

  else if (!v4)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "Darwin";
      __int16 v14 = 2082;
      uint64_t v15 = "Daemon settings";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  (uint8_t *)&v8,  0x26u);
    }

    sub_100124358(a1 + 584);
  }

void sub_100B9FD60(uint64_t a1, uint64_t a2, int *a3, unsigned __int8 *a4)
{
  switch(*a3)
  {
    case 7:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      id v7 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v22 = 2082;
        int v23 = "Battery";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{pub lic, location:escape_only}s}",  buf,  0x26u);
      }

      *(_OWORD *)std::string buf = *(_OWORD *)a4;
      *(void *)&buf[16] = *((void *)a4 + 2);
      CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
      sub_1000C0B80(a1 + 3208, (uint64_t *)buf, &Current_1);
      break;
    case 10:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      uint64_t v13 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = *a4;
        *(_DWORD *)std::string buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v22 = 2082;
        int v23 = "Display";
        __int16 v24 = 1025;
        int v25 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{pub lic, location:escape_only}s, is on:%{private}hhd}",  buf,  0x2Cu);
      }

      uint64_t v15 = *a4;
      *(void *)std::string buf = j__CFAbsoluteTimeGetCurrent_1();
      sub_10012B5D0(a1 + 584, v15, buf);
      int v16 = *a4;
      *(void *)std::string buf = j__CFAbsoluteTimeGetCurrent_1();
      sub_1000C0D44(a1 + 3208, v16, (double *)buf);
      break;
    case 14:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      int v17 = (os_log_s *)qword_1019348D8;
      if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v18 = *a4;
      *(_DWORD *)std::string buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "Daemon status";
      __int16 v22 = 2082;
      int v23 = "Restricted power mode";
      __int16 v24 = 1025;
      int v25 = v18;
      int v19 = "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{p"
            "ublic, location:escape_only}s, is restricted:%{private}hhd}";
      goto LABEL_29;
    case 15:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      int v17 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *a4;
        *(_DWORD *)std::string buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = "Daemon status";
        __int16 v22 = 2082;
        int v23 = "Battery saver mode";
        __int16 v24 = 1025;
        int v25 = v20;
        int v19 = "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%"
              "{public, location:escape_only}s, is enabled:%{private}hhd}";
LABEL_29:
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v19, buf, 0x2Cu);
      }

void sub_100BA02B0(uint64_t a1, int a2, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-localize", 0LL))
  {
    if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-record", 0LL))
    {
      if (CFStringCompare(theString1, @"com.apple.locationd.MicroLocationAction-purge", 0LL))
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        int v5 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = CFStringGetCStringPtr(theString1, 0x8000100u);
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning Got a notification center notification that we weren't expecting: %s",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_101874AF8);
          }
          uint64_t v6 = qword_1019348D8;
          *(_DWORD *)__int16 v12 = 136315138;
          *(void *)&v12[4] = CFStringGetCStringPtr(theString1, 0x8000100u);
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  0LL,  "#Warning Got a notification center notification that we weren't expecting: %s",  v12);
          int v8 = (char *)v7;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onNotificationCenterNotification(CFNotificationCenterRef, CFStringRef, const v oid *, CFDictionaryRef)",  "%s\n",  v7);
          if (v8 != buf) {
            free(v8);
          }
        }
      }

      else
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        int v11 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          __int16 v14 = 2082;
          uint64_t v15 = "Notification center";
          __int16 v16 = 2082;
          int v17 = "Purge";
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{p ublic, location:escape_only}s}",  buf,  0x26u);
        }

        sub_10012B308(a1 + 584);
        sub_100BA2A38(a1);
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      int v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v14 = 2082;
        uint64_t v15 = "Notification center";
        __int16 v16 = 2082;
        int v17 = "Force record";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{pub lic, location:escape_only}s}",  buf,  0x26u);
      }

      *(void *)std::string buf = j__CFAbsoluteTimeGetCurrent_1();
      sub_1000C11DC(a1 + 3208, (double *)buf);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v14 = 2082;
      uint64_t v15 = "Notification center";
      __int16 v16 = 2082;
      int v17 = "Force localization";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
    }

    sub_1010DDBC0(buf, "NotificationCenter");
    *(void *)__int16 v12 = j__CFAbsoluteTimeGetCurrent_1();
    sub_1000C1574(a1 + 3208, (const std::string *)buf, (double *)v12);
    if (SBYTE3(v15) < 0) {
      operator delete(*(void **)buf);
    }
  }

void sub_100BA0718( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BA073C(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 5)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v25 = 2082;
      uint64_t v26 = "Location";
      __int16 v27 = 2082;
      __int16 v28 = "Location leech";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
    }

    uint64_t v7 = a1 + 584;
    if (sub_10012C220(v7))
    {
      double v8 = *(double *)(a4 + 20);
      sub_1002F0B04(buf);
      CFStringRef v9 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsLeechedLocationHorizontalAccuracyThreshold",  0x8000100u,  kCFAllocatorNull);
      int v10 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v9, v23);
      CFRelease(v9);
      double v11 = *(double *)v23;
      __int16 v12 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        uint64_t v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }

      double v15 = 65.0;
      if (v10) {
        double v15 = v11;
      }
      if (v8 <= v15)
      {
        sub_10012C180( v7,   -[CLLocation initWithLatitude:longitude:]( objc_alloc(&OBJC_CLASS___CLLocation),  "initWithLatitude:longitude:",  *(double *)(a4 + 4),  *(double *)(a4 + 12)));
        return;
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      __int16 v16 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(void *)(a4 + 20);
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Ignoring leeched location since horizontal accuracy (%.1f m) exceeds threshold",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        uint64_t v18 = *(void *)(a4 + 20);
        *(_DWORD *)int v23 = 134217984;
        *(void *)&v23[4] = v18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Ignoring leeched location since horizontal accuracy (%.1f m) exceeds threshold",  COERCE_DOUBLE(v23));
        int v20 = (char *)v19;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v19);
LABEL_31:
        if (v20 != buf) {
          free(v20);
        }
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    BOOL v21 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Received unhandled location notification",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      *(_WORD *)int v23 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Received unhandled location notification",  v23,  2);
      int v20 = (char *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const C LLocationProvider_Type::NotificationData &)",  "%s\n",  v22);
      goto LABEL_31;
    }
  }

void sub_100BA0BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100BA0BC0(void *a1@<X8>)
{
  CFStringRef v2 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsAppLaunchLocalizationAllowedList",  0x8000100u,  kCFAllocatorNull);
  BOOL v3 = sub_1002AA610(v8, v2, (CFTypeRef *)&v7);
  CFRelease(v2);
  if (v3)
  {
    sub_100BA6900(v7, (uint64_t)a1);
  }

  else
  {
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

  int v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_100BA0CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BA0CBC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(v4 + 32) silo];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768LL;
  v6[2] = sub_100BA0D6C;
  v6[3] = &unk_101874918;
  v6[4] = *(void *)(a1 + 32);
  v6[5] = v4;
  sub_100071244(v7, a2);
  [v5 async:v6];
  sub_100071248((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_100BA0D58(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA0D6C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40) + 3208LL;
  BOOL v3 = (_BYTE *)(a1 + 48);
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return sub_1000C09BC(v2, v1, v3, &Current_1);
}

uint64_t sub_100BA0DBC(uint64_t a1, uint64_t a2)
{
  return sub_100071244(a1 + 48, a2 + 48);
}

void sub_100BA0DC8(uint64_t a1)
{
}

void sub_100BA0DD0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(v4 + 32) silo];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768LL;
  v6[2] = sub_100BA0E80;
  v6[3] = &unk_101874918;
  v6[4] = *(void *)(a1 + 32);
  v6[5] = v4;
  sub_100071244(v7, a2);
  [v5 async:v6];
  sub_100071248((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_100BA0E6C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA0E80(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40) + 3208LL;
  BOOL v3 = (_BYTE *)(a1 + 48);
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return sub_1000C0510(v2, v1, v3, &Current_1);
}

uint64_t sub_100BA0ED0()
{
  uint64_t v0 = sub_1004F2598();
  return sub_1004FA4D0(v0);
}

id sub_100BA0EE4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100BA0F3C;
  v3[3] = &unk_10181D3D0;
  v3[4] = a1;
  return [v1 async:v3];
}

uint64_t sub_100BA0F3C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v6 = 0;
  sub_100018E34(&v6);
  *(void *)&__int128 v7 = sub_100017338((ssize_t)&v6);
  *((void *)&v7 + 1) = v2;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_100063730((uint64_t)v5);
  sub_100BA103C(&v7, (uint64_t)v5, (uint64_t)v8, Current_1);
  sub_100042DF8((uint64_t *)(v1 + 552), v8);
  sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
  sub_100078B70((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  return sub_100019D7C((unsigned int *)&v6);
}

void sub_100BA0FF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
}

void sub_100BA103C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA10B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100BA10C4(uint64_t a1)
{
  uint64_t v1 = a1 - 112;
  uint64_t v2 = *(void **)(a1 - 72);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100BA0F3C;
  v4[3] = &unk_10181D3D0;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t *sub_100BA111C(uint64_t *result, int a2, uint64_t a3)
{
  int v9 = a2;
  if (*(_BYTE *)(a3 + 280))
  {
    BOOL v3 = (uint64_t **)(result + 447);
    uint64_t v4 = result[448];
    if (!v4) {
      goto LABEL_12;
    }
    id v5 = result + 448;
    do
    {
      int v6 = *(_DWORD *)(v4 + 28);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        uint64_t v8 = (uint64_t *)v4;
      }
      else {
        uint64_t v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        id v5 = (uint64_t *)v4;
      }
      uint64_t v4 = *v8;
    }

    while (*v8);
    if (v5 == result + 448 || *((_DWORD *)v5 + 7) > a2)
    {
LABEL_12:
      int v10 = (unsigned int *)&v9;
      *((_DWORD *)sub_100228E48((uint64_t **)result + 447, &v9, (uint64_t)&unk_1012CF090, &v10) + 8) = 0;
    }

    int v10 = (unsigned int *)&v9;
    id result = sub_100228E48(v3, &v9, (uint64_t)&unk_1012CF090, &v10);
    ++*((_DWORD *)result + 8);
  }

  return result;
}

uint64_t *sub_100BA11E4(uint64_t a1, int a2, uint64_t a3)
{
  return sub_100BA111C((uint64_t *)(a1 - 112), a2, a3);
}

void *sub_100BA11EC(void *result, int a2)
{
  int v11 = a2;
  uint64_t v2 = result[448];
  if (v2)
  {
    BOOL v3 = result;
    result += 447;
    uint64_t v4 = v3 + 448;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      BOOL v6 = v5 < a2;
      if (v5 >= a2) {
        BOOL v7 = (uint64_t *)v2;
      }
      else {
        BOOL v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        uint64_t v4 = (void *)v2;
      }
      uint64_t v2 = *v7;
    }

    while (*v7);
    if (v4 != v3 + 448 && *((_DWORD *)v4 + 7) <= a2)
    {
      if (*((_DWORD *)v4 + 8))
      {
        __int16 v12 = (unsigned int *)&v11;
        *((_DWORD *)sub_100228E48((uint64_t **)result, &v11, (uint64_t)&unk_1012CF090, &v12) + 8) = 0;
        uint64_t v8 = (void *)v3[5];
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472LL;
        v9[2] = sub_100BA12C8;
        v9[3] = &unk_10182B540;
        v9[4] = v3;
        int v10 = v11;
        return [v8 async:v9];
      }
    }
  }

  return result;
}

void sub_100BA12C8()
{
}

void *sub_100BA12DC(uint64_t a1, int a2)
{
  return sub_100BA11EC((void *)(a1 - 112), a2);
}

id sub_100BA12E4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100BA133C;
  v3[3] = &unk_10181D3D0;
  v3[4] = a1;
  return [v1 async:v3];
}

void sub_100BA133C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v6 = 0;
  sub_100018E34(&v6);
  *(void *)&__int128 v7 = sub_100017338((ssize_t)&v6);
  *((void *)&v7 + 1) = v2;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_100063750((uint64_t)v5);
  sub_100BA1454(&v7, (uint64_t)v5, (uint64_t)v8, Current_1);
  sub_100042DF8((uint64_t *)(v1 + 552), v8);
  sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
  sub_100078F30((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  uint64_t v4 = sub_100019D7C((unsigned int *)&v6);
  sub_100B9F1D0(v4, (const void **)(v1 + 3536), 0LL);
  sub_10012BA2C(v1 + 584);
}

void sub_100BA1414( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14)
{
}

void sub_100BA1454(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA14C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100BA14DC(uint64_t a1)
{
  uint64_t v1 = a1 - 112;
  uint64_t v2 = *(void **)(a1 - 72);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100BA133C;
  v4[3] = &unk_10181D3D0;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t sub_100BA1534@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  return sub_10012CA40(a1 + 584, a2, a3, a4, a5);
}

uint64_t sub_100BA153C@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  return sub_10012CA40(a1 + 472, a2, a3, a4, a5);
}

void sub_100BA1544(uint64_t a1, void *a2, NSError *a3)
{
  if (*a2 == a2[1])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v15 = 0;
      __int16 v16 = 2082;
      uint64_t v17 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:No SPI responses cached for recording/localization completion}",  buf,  0x12u);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v15 = 0;
      __int16 v16 = 2082;
      uint64_t v17 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:calling SPI responses after recording/localization completion}",  buf,  0x12u);
    }

    if (a3)
    {
      int v6 = objc_alloc(&OBJC_CLASS___NSError);
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v13 = a3;
      __int128 v7 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v13,  &v12,  1LL);
      a3 =  -[NSError initWithDomain:code:userInfo:]( v6,  "initWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v7);
    }

    uint64_t v8 = (void *)*a2;
    uint64_t v9 = (void *)a2[1];
    if ((void *)*a2 != v9)
    {
      do
      {
        int v10 = (void *)*v8;
        (*(void (**)(void, NSError *))(*v8 + 16LL))(*v8, a3);

        ++v8;
      }

      while (v8 != v9);
      uint64_t v8 = (void *)*a2;
    }

    a2[1] = v8;
    sub_100BA1764((uint64_t)a2);
  }

void sub_100BA1764(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(char **)a1;
  int v5 = *(_BYTE **)(a1 + 8);
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 < (v3 - (uint64_t)v4) >> 3)
  {
    if (v5 == v4)
    {
      int v11 = 0LL;
      uint64_t v9 = 8 * v6;
    }

    else
    {
      __int128 v7 = (char *)sub_1000071BC(v2, v6);
      uint64_t v4 = *(char **)a1;
      uint64_t v8 = *(char **)(a1 + 8);
      uint64_t v9 = (uint64_t)&v7[8 * v6];
      int v11 = &v7[8 * v10];
      if (v8 != *(char **)a1)
      {
        uint64_t v12 = v9;
        do
        {
          uint64_t v13 = *((void *)v8 - 1);
          v8 -= 8;
          *(void *)(v12 - 8) = v13;
          v12 -= 8LL;
        }

        while (v8 != v4);
        uint64_t v4 = *(char **)a1;
        goto LABEL_9;
      }
    }

    uint64_t v12 = v9;
LABEL_9:
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v11;
    if (v4) {
      operator delete(v4);
    }
  }

void sub_100BA181C(uint64_t a1, NSError *a2)
{
  uint64_t v4 = sub_10004306C((uint64_t *)(a1 + 552));
  sub_100BA1544(v4, (void *)(a1 + 3488), a2);
}

void sub_100BA184C(uint64_t a1, NSError *a2)
{
  uint64_t v4 = sub_10004306C((uint64_t *)(a1 + 416));
  sub_100BA1544(v4, (void *)(a1 + 3352), a2);
}

id sub_100BA187C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100BA18D4;
  v3[3] = &unk_10181D3D0;
  v3[4] = a1;
  return [v1 async:v3];
}

uint64_t sub_100BA18D4(uint64_t a1)
{
  return sub_10012BBD4(*(void *)(a1 + 32) + 584LL);
}

id sub_100BA18E0(uint64_t a1)
{
  uint64_t v1 = a1 - 120;
  uint64_t v2 = *(void **)(a1 - 80);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100BA18D4;
  v4[3] = &unk_10181D3D0;
  v4[4] = v1;
  return [v2 async:v4];
}

uint64_t sub_100BA1938(uint64_t a1)
{
  return sub_10004306C((uint64_t *)(a1 + 552));
}

uint64_t sub_100BA1940(uint64_t a1)
{
  return sub_10004306C((uint64_t *)(a1 + 432));
}

double sub_100BA1948(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  if (*a3)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    int v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *a3;
      *(_DWORD *)std::string buf = 67240192;
      int v16 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Got a data protection notification we weren't registered for: %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      int v8 = *a3;
      v14[0] = 67240192;
      v14[1] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Got a data protection notification we weren't registered for: %{public}d",  v14,  8);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationNotifier::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notif ication &, const CLDataProtectionManager_Type::NotificationData &)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  else if (*a4 == 1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v16 = 0;
      __int16 v17 = 2082;
      uint64_t v18 = "";
      __int16 v19 = 2082;
      int v20 = "DataProtection";
      __int16 v21 = 2082;
      __int16 v22 = "Data available";
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received notification, source:%{public, location:escape_only}s, trigger:%{publi c, location:escape_only}s}",  buf,  0x26u);
    }

    BOOL v13 = sub_100031790(a1 + 248);
    sub_10012CA00(a1 + 584);
    sub_100BA1C08(a1, 1LL, 0LL);
    sub_1000C1C94(a1 + 3208);
    if (!v13 && sub_100031790(a1 + 248)) {
      *(void *)&double result = nullsub_10(a1 + 584).n128_u64[0];
    }
  }

  return result;
}

id sub_100BA1C08(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a2;
  uint64_t v18 = a2;
  int v6 = sub_100BA24B8(&v18);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  __int128 v7 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = objc_msgSend(objc_msgSend(a3, "UUIDString"), "UTF8String");
    uint64_t buf = 68289539LL;
    __int16 v21 = 2082;
    __int16 v22 = "";
    __int16 v23 = 2081;
    id v24 = v8;
    __int16 v25 = 1026;
    int v26 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Notifier about to send query milo connections status response, connectionToken:%{priv ate, location:escape_only}s, connectionState:%{public}d}",  (uint8_t *)&buf,  0x22u);
  }

  if (a3) {
    return objc_msgSend( objc_msgSend(*(id *)(a1 + 3544), "objectForKeyedSubscript:", a3),  "onMiLoConnectionStatusEventUpdate:",  v6);
  }
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  uint64_t v10 = *(void **)(a1 + 3544);
  id result = [v10 countByEnumeratingWithState:&v14 objects:v19 count:16];
  if (result)
  {
    id v11 = result;
    uint64_t v12 = *(void *)v15;
    do
    {
      BOOL v13 = 0LL;
      do
      {
        if (*(void *)v15 != v12) {
          objc_enumerationMutation(v10);
        }
        objc_msgSend( objc_msgSend( *(id *)(a1 + 3544),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v14 + 1) + 8 * (void)v13)),  "onMiLoConnectionStatusEventUpdate:",  v6);
        BOOL v13 = (char *)v13 + 1;
      }

      while (v11 != v13);
      id result = [v10 countByEnumeratingWithState:&v14 objects:v19 count:16];
      id v11 = result;
    }

    while (result);
  }

  return result;
}

CLCppContainer *sub_100BA1DE4(_OWORD *a1)
{
  uint64_t v2 = operator new(0x70uLL);
  __int128 v3 = a1[1];
  *(_OWORD *)uint64_t v2 = *a1;
  *((_OWORD *)v2 + 1) = v3;
  sub_100BA75B0((char *)v2 + 32, (uint64_t)(a1 + 2));
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100BA7578;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  112LL);
}

void sub_100BA1E70(_Unwind_Exception *a1)
{
}

void sub_100BA1E84(uint64_t a1, uint64_t a2, std::string *__str, uint64_t a4)
{
  v6[1] = -1LL;
  memset(&__p, 0, sizeof(__p));
  v6[0] = a2;
  std::string::operator=(&__p, __str);
  objc_msgSend( objc_msgSend( *(id *)(a1 + 3544),  "objectForKeyedSubscript:",  -[NSUUID initWithUUIDBytes:]([NSUUID alloc], "initWithUUIDBytes:", a4)),  "onMiLoGenericEvent:",  sub_100BA1F40((uint64_t)v6));
}

void sub_100BA1F1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CLCppContainer *sub_100BA1F40(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
  __int128 v3 = v2 + 16;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_1010DD48C(v3, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }

  else
  {
    *(_OWORD *)__int128 v3 = *(_OWORD *)(a1 + 16);
    *((void *)v2 + 4) = *(void *)(a1 + 32);
  }

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100BA76E8;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  40LL);
}

void sub_100BA1FEC(_Unwind_Exception *a1)
{
}

void sub_100BA2000(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4)
{
}

uint64_t sub_100BA2008(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __int128 v7 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", a4);
  memset(v11, 0, sizeof(v11));
  char v14 = 0;
  char v15 = 0;
  char v16 = 0;
  memset(v12, 0, sizeof(v12));
  char v13 = 0;
  __int128 __p = 0u;
  memset(v19, 0, 96);
  memset(v20, 0, sizeof(v20));
  uint64_t v10 = 10LL;
  __int128 v21 = *a3;
  uint64_t v17 = -1LL;
  v19[12] = a2;
  objc_msgSend( objc_msgSend(*(id *)(a1 + 3544), "objectForKeyedSubscript:", v7),  "onMiLoServiceEventUpdate:",  sub_100BA2184((uint64_t)v9));
  sub_100BA6BE0(v20);
  sub_100231C10(&v19[1]);
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

  sub_100210578(v12);
  return sub_100210578(v11);
}

void sub_100BA2170(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CLCppContainer *sub_100BA2184(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x190uLL);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
  sub_100BA7788((uint64_t)(v2 + 16), a1 + 16);
  *((void *)v2 + 41) = *(void *)(a1 + 328);
  *(_OWORD *)(v2 + 312) = *(_OWORD *)(a1 + 312);
  sub_100BA8F3C((uint64_t)(v2 + 336), (void *)(a1 + 336));
  *((_OWORD *)v2 + 24) = *(_OWORD *)(a1 + 384);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100BA7728;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  400LL);
}

void sub_100BA223C(_Unwind_Exception *a1)
{
  __int128 v3 = (void *)v1[25];
  if (v3)
  {
    v1[26] = v3;
    operator delete(v3);
  }

  sub_100210578(v1 + 12);
  sub_100210578(v1 + 3);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100BA2280(void *a1)
{
  uint64_t v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }

  sub_100210578(a1 + 12);
  sub_100210578(a1 + 3);
  return a1;
}

uint64_t sub_100BA22D0(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  return sub_100BA2008(a1 - 136, a2, a3, a4);
}

void sub_100BA22D8(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA234C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BA2360(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  char v10 = 0;
  char v11 = 0;
  char v12 = 0;
  memset(v8, 0, sizeof(v8));
  char v9 = 0;
  __int128 __p = 0u;
  memset(v15, 0, 96);
  memset(v16, 0, sizeof(v16));
  uint64_t v6 = 10LL;
  __int128 v17 = *a2;
  uint64_t v13 = -1LL;
  v15[12] = a3;
  objc_msgSend( objc_msgSend(*(id *)(a1 + 3544), "objectForKeyedSubscript:", a4),  "onMiLoServiceEventUpdate:",  sub_100BA2184((uint64_t)v5));
  sub_100BA6BE0(v16);
  sub_100231C10(&v15[1]);
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

  sub_100210578(v8);
  return sub_100210578(v7);
}

void sub_100BA24A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CLCppContainer *sub_100BA24B8(void *a1)
{
  uint64_t v2 = operator new(8uLL);
  *uint64_t v2 = *a1;
  int v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  uint64_t v6 = sub_100BA97E8;
  __int128 v7 = &unk_10181D3D0;
  id v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100BA2538(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1010DD48C(&__dst, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(_BYTE *)(a2 + 23);
  }

  else
  {
    __int128 __dst = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
  }

  int v4 = v20;
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)v20, v5 + 4);
  if (v21 < 0) {
    int v4 = (void *)v20[0];
  }
  if (v5)
  {
    else {
      uint64_t v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }

  strcpy((char *)v4 + v5, "-wal");
  __int128 v7 = v22;
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)v22, v8 + 4);
  if (v23 < 0) {
    __int128 v7 = (void *)v22[0];
  }
  if (v8)
  {
    else {
      char v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }

  strcpy((char *)v7 + v8, "-shm");
  char v14 = 0LL;
  char v15 = 0LL;
  v16[0] = 0LL;
  v16[1] = &v14;
  char v17 = 0;
  char v14 = (char *)operator new(0x48uLL);
  char v15 = v14;
  v16[0] = v14 + 72;
  char v10 = sub_100036E0C((uint64_t)v16, &__dst, &v24, v14);
  uint64_t v11 = 0LL;
  char v15 = v10;
  do
  {
    if (*(&v23 + v11 * 8) < 0) {
      operator delete((void *)v22[v11]);
    }
    v11 -= 3LL;
  }

  while (v11 != -9);
  char v12 = (uint64_t *)v14;
  uint64_t v13 = (uint64_t *)v15;
  while (v12 != v13)
  {
    sub_100BA280C((uint64_t)v10, v12);
    v12 += 3;
  }

  *(void *)&__int128 __dst = &v14;
  sub_1000129D4((void ***)&__dst);
}

void sub_100BA2730( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15)
{
}

uint64_t sub_100BA27BC(uint64_t a1)
{
  return a1;
}

void sub_100BA280C(uint64_t a1, uint64_t *a2)
{
  else {
    int v3 = (uint64_t *)*a2;
  }
  int v4 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3);
  if (-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  v4,  0LL))
  {
    uint64_t v9 = 0LL;
    if (!-[NSFileManager removeItemAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtPath:error:",  v4,  &v9))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      size_t v5 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v6 = *((char *)a2 + 23) >= 0 ? a2 : (uint64_t *)*a2;
        *(_DWORD *)uint64_t buf = 68289539;
        int v11 = 0;
        __int16 v12 = 2082;
        uint64_t v13 = "";
        __int16 v14 = 2081;
        char v15 = v6;
        __int16 v16 = 2113;
        uint64_t v17 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:failed to remove file, filepath:%{private, location:escape_only}s, error:%{pr ivate, location:escape_only}@}",  buf,  0x26u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
      }

      __int128 v7 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        else {
          size_t v8 = (uint64_t *)*a2;
        }
        *(_DWORD *)uint64_t buf = 68289539;
        int v11 = 0;
        __int16 v12 = 2082;
        uint64_t v13 = "";
        __int16 v14 = 2081;
        char v15 = v8;
        __int16 v16 = 2113;
        uint64_t v17 = v9;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to remove file",  "{msg%{public}.0s:failed to remove file, filepath:%{private, location:escape_only}s, error:%{pr ivate, location:escape_only}@}",  buf,  0x26u);
      }
    }
  }

uint64_t sub_100BA2A28(uint64_t a1)
{
  return sub_10012C218(a1 + 584);
}

uint64_t sub_100BA2A30(uint64_t a1)
{
  return sub_10012C218(a1 + 472);
}

void sub_100BA2A38(uint64_t a1)
{
  uint64_t v2 = -[NSString UTF8String]( -[NSString stringByAppendingPathComponent:]( -[NSString stringByAppendingPathComponent:]( NSTemporaryDirectory(),  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", "microLocationDB")),  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", "ExportedMiloDB.db")),  "UTF8String");
  sub_1010DDBC0(__p, v2);
  sub_100BA2538(a1, (uint64_t)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100BA2AD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BA2AF4(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2B68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2B7C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2BF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2C04(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2C78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2C8C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2D00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2D14(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2D88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2D9C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2E10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2E24(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2E98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BA2EAC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100BA2F20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BA2F34(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v23 = 0;
  LOBYTE(v24) = 0;
  char v25 = 0;
  memset(v21, 0, sizeof(v21));
  LOBYTE(v22) = 0;
  memset(__p, 0, 112);
  uint64_t v26 = -1LL;
  __p[14] = (void *)-1LL;
  memset(v29, 0, 48);
  uint64_t v6 = *a2;
  __int128 v7 = (void *)a2[1];
  uint64_t v17 = 7LL;
  uint64_t v18 = v6;
  size_t v8 = (void *)a2[2];
  while (v7 != v8)
    sub_100BA9C00(v19, v7++);
  unint64_t v9 = 0LL;
  v19[3] = *((_OWORD *)a2 + 2);
  uint64_t v20 = a2[6];
  do
  {
    if ((((unint64_t)a2[7] >> v9) & 1) != 0)
    {
      v15.n128_u64[0] = v9;
      sub_100BA31C0(v21, &v15);
    }

    ++v9;
  }

  while (v9 != 32);
  uint64_t v10 = a1;
  __int16 v12 = (__n128 *)a2[13];
  for (i = (__n128 *)a2[14]; v12 != i; ++v12)
  {
    __n128 v15 = *v12;
    sub_100BA3244(&__p[3], &v15);
  }

  uint64_t v27 = a2[9];
  if (*((_BYTE *)a2 + 152))
  {
    __int128 v22 = *(_OWORD *)(a2 + 17);
    if (!v23) {
      char v23 = 1;
    }
    uint64_t v24 = a2[16];
    char v25 = 1;
  }

  __int128 v13 = *((_OWORD *)a2 + 11);
  *(_OWORD *)&__p[9] = *((_OWORD *)a2 + 10);
  *(_OWORD *)&__p[11] = v13;
  __p[13] = (void *)a2[24];
  objc_msgSend( objc_msgSend( *(id *)(v10 + 3544),  "objectForKeyedSubscript:",  -[NSUUID initWithUUIDBytes:]([NSUUID alloc], "initWithUUIDBytes:", a3)),  "onMiLoServiceEventUpdate:",  sub_100BA2184((uint64_t)v16));
  sub_100BA6BE0(v29);
  sub_100231C10(&__p[3]);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  sub_100210578(v21);
  return sub_100210578(v19);
}

void sub_100BA3198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100BA31C0(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100BA9F98(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

__n128 sub_100BA3244(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BAA2AC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

uint64_t sub_100BA32CC(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return sub_100BA2F34(a1 - 136, a2, a3);
}

uint64_t sub_100BA32D4(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  return sub_100BA2360( a1,  a3,  a4,  (uint64_t)-[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", a5));
}

uint64_t sub_100BA332C(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  return sub_100BA32D4(a1 - 136, a2, a3, a4, a5);
}

uint64_t sub_100BA3334(uint64_t a1, uint64_t a2, __int128 *a3, int64x2_t *a4, uint64_t a5)
{
  return sub_100BA338C( a1,  a3,  a4,  (uint64_t)-[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", a5));
}

uint64_t sub_100BA338C(uint64_t a1, __int128 *a2, int64x2_t *a3, uint64_t a4)
{
  unint64_t v8 = (int64x2_t *)a3[1].i64[1];
  unint64_t v9 = a3 + 2;
  if (v8 != &a3[2])
  {
    do
    {
      uint64_t v10 = (v8[1].i32[3] - 1);
      else {
        uint64_t v11 = v10 + 2;
      }
      v20[0] = v11;
      sub_100BA45C0(v19, v20);
      __int16 v12 = (int64x2_t *)v8->i64[1];
      if (v12)
      {
        do
        {
          __int128 v13 = v12;
          __int16 v12 = (int64x2_t *)v12->i64[0];
        }

        while (v12);
      }

      else
      {
        do
        {
          __int128 v13 = (int64x2_t *)v8[1].i64[0];
          BOOL v14 = v13->i64[0] == (void)v8;
          unint64_t v8 = v13;
        }

        while (!v14);
      }

      unint64_t v8 = v13;
    }

    while (v13 != v9);
  }

  int32x2_t v22 = 0LL;
  int v23 = 0;
  memset(v24, 0, sizeof(v24));
  v20[0] = 13LL;
  __int128 v21 = *a2;
  memset(v18, 0, sizeof(v18));
  int32x2_t v16 = vmovn_s64(*a3);
  int v17 = a3[1].i64[0];
  sub_100BA4644(v18, v19);
  int32x2_t v22 = v16;
  int v23 = v17;
  sub_100BA4644(v24, v18);
  objc_msgSend( objc_msgSend(*(id *)(a1 + 3544), "objectForKeyedSubscript:", a4),  "onMiLoObservationMetaInfo:",  sub_100BA46D4((uint64_t)v20));
  sub_100210578(v18);
  sub_100210578(v24);
  return sub_100210578(v19);
}

void sub_100BA352C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100BA355C(uint64_t a1, uint64_t a2, __int128 *a3, int64x2_t *a4, uint64_t a5)
{
  return sub_100BA3334(a1 - 136, a2, a3, a4, a5);
}

uint64_t sub_100BA3564(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t *a4, uint64_t a5)
{
  __int128 v47 = 0u;
  __int128 v46 = 0u;
  int64x2_t v45 = 0u;
  memset(v44, 0, sizeof(v44));
  memset(v43, 0, sizeof(v43));
  uint64_t v48 = -1LL;
  memset(v50, 0, sizeof(v50));
  __int128 v51 = 0u;
  int v52 = 0;
  if (*((_BYTE *)a3 + 16)) {
    __int128 v49 = *a3;
  }
  unint64_t v9 = (unsigned int *)a4[18];
  uint64_t v10 = (unsigned int *)a4[19];
  while (v9 != v10)
  {
    *(void *)uint64_t buf = *v9;
    sub_100BAA5C0(&v50[1], buf);
    ++v9;
  }

  uint64_t v11 = *((int *)a4 + 34);
  if (v11 >= 4)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    __int128 v13 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:unknown protobuf confidence level, deprecated?}",  buf,  0x12u);
    }

    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v12 = qword_10134D8B0[v11];
  }

  v50[0] = v12;
  *((int32x2_t *)&v51 + 1) = vmovn_s64(*(int64x2_t *)(a4 + 3));
  int v52 = a4[5];
  uint64_t v14 = *(void *)(a2 + 16);
  uint64_t v39 = a1;
  if ((unint64_t)(v14 - 1) >= 3)
  {
    if (v14 == 4)
    {
      uint64_t v22 = *a4;
      uint64_t v21 = a4[1];
      if (*a4 != v21)
      {
        do
        {
          *(_OWORD *)uint64_t buf = *(_OWORD *)v22;
          *(void *)&buf[16] = *(void *)(v22 + 16);
          uint64_t v23 = *(int *)(v22 + 24);
          if (v23 >= 4)
          {
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_101874AF8);
            }
            char v25 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)__int128 __dst = 68289026LL;
              *(_WORD *)&__dst[8] = 2082;
              *(void *)&__dst[10] = "";
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:unknown protobuf confidence level, deprecated?}",  __dst,  0x12u);
            }

            uint64_t v24 = 0LL;
          }

          else
          {
            uint64_t v24 = qword_10134D8B0[v23];
          }

          *(void *)&buf[24] = v24;
          sub_100BAA958(v44, (uint64_t)buf);
          v22 += 32LL;
        }

        while (v22 != v21);
      }

      if (*((_BYTE *)a4 + 128))
      {
        v31 = (uint64_t *)a4[13];
        uint64_t v32 = (void *)(v45.i64[1] + 8 * ((unint64_t)v47 / 0x66));
        if ((void)v46 == v45.i64[1])
        {
          uint64_t v33 = 0LL;
          if (!v31) {
            goto LABEL_61;
          }
        }

        else
        {
          uint64_t v33 = *v32 + 40 * ((unint64_t)v47 % 0x66);
          if (!v31) {
            goto LABEL_61;
          }
        }

        do
        {
          if (*((char *)v31 + 39) < 0)
          {
            sub_1010DD48C(__dst, (void *)v31[2], v31[3]);
          }

          else
          {
            *(_OWORD *)__int128 __dst = *((_OWORD *)v31 + 1);
            *(void *)&__dst[16] = v31[4];
          }

          uint64_t v34 = v31[5];
          uint64_t v35 = v31[6];
          if ((__dst[23] & 0x80000000) != 0)
          {
            sub_1010DD48C(buf, *(void **)__dst, *(unint64_t *)&__dst[8]);
            *(void *)&buf[24] = v35;
            *(void *)&__int128 v41 = v34;
            if ((__dst[23] & 0x80000000) != 0) {
              operator delete(*(void **)__dst);
            }
          }

          else
          {
            *(_OWORD *)uint64_t buf = *(_OWORD *)__dst;
            *(void *)&buf[16] = *(void *)&__dst[16];
            *(void *)&buf[24] = v35;
            *(void *)&__int128 v41 = v34;
          }

          v36 = (void *)sub_100BAACF8(&v45, v32, v33, (__int128 *)buf);
          uint64_t v32 = v36;
          uint64_t v33 = v37 + 40;
          if (v37 + 40 - *v36 == 4080)
          {
            uint64_t v32 = v36 + 1;
            uint64_t v33 = v36[1];
          }

          v31 = (uint64_t *)*v31;
        }

        while (v31);
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_101874AF8);
      }
      uint64_t v26 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v27 = *(void *)(a2 + 16);
        *(_DWORD *)uint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "MiLo send prediction unknown service type: %lu",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_101874AF8);
        }
        uint64_t v28 = *(void *)(a2 + 16);
        *(_DWORD *)__int128 __dst = 134217984;
        *(void *)&__dst[4] = v28;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "MiLo send prediction unknown service type: %lu",  __dst);
        __int16 v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMicroLocationNotifier::onSendPredictionResultsToClient(const CLMiLoService::ServiceDescriptor & , const std::optional<boost::uuids::uuid> &, const CLMicroLocationResultToPublish &, const CLMiLoService::ConnectionUuid &)",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }
    }
  }

  else
  {
    uint64_t v42 = 0LL;
    __int128 v41 = 0u;
    memset(buf, 0, sizeof(buf));
    __n128 v15 = (void *)sub_100BA3CA8((uint64_t)v43, buf);
    sub_1000EAA04(buf);
    v15[6] = *(void *)(a2 + 16);
    uint64_t v16 = *a4;
    uint64_t v17 = a4[1];
    if (*a4 != v17)
    {
      do
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)v16;
        *(void *)&buf[16] = *(void *)(v16 + 16);
        uint64_t v18 = *(int *)(v16 + 24);
        if (v18 >= 4)
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_101874AF8);
          }
          uint64_t v20 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)__int128 __dst = 68289026LL;
            *(_WORD *)&__dst[8] = 2082;
            *(void *)&__dst[10] = "";
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:unknown protobuf confidence level, deprecated?}",  __dst,  0x12u);
          }

          uint64_t v19 = 0LL;
        }

        else
        {
          uint64_t v19 = qword_10134D8B0[v18];
        }

        *(void *)&buf[24] = v19;
        sub_100BAA958(v15, (uint64_t)buf);
        v16 += 32LL;
      }

      while (v16 != v17);
    }
  }

void sub_100BA3C3C(_Unwind_Exception *a1)
{
}

unint64_t sub_100BA3CA8(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100BABD0C((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x49));
  uint64_t v7 = *v6 + 56 * (v4 % 0x49);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4088LL;
  }
  *(void *)(v7 - 56) = *a2;
  *(void *)(v7 - memset(v19, 0, 48) = a2[1];
  *(void *)(v7 - 40) = a2[2];
  *(void *)(v7 - 32) = a2[3];
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *(void *)(v7 - 24) = a2[4];
  *(void *)(v7 - 16) = a2[5];
  a2[4] = 0LL;
  a2[5] = 0LL;
  *(void *)(v7 - 8) = a2[6];
  int64x2_t v8 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1012E2F20);
  *(int64x2_t *)(a1 + 32) = v8;
  uint64_t v9 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) == v9) {
    return 0LL;
  }
  else {
    return *(void *)(v9 + 8 * (v8.i64[0] / 0x49uLL)) + 56 * (v8.i64[0] % 0x49uLL);
  }
}

CLCppContainer *sub_100BA3DC4(uint64_t a1)
{
  uint64_t v2 = operator new(0xF0uLL);
  sub_100BAC070((uint64_t)v2, (void *)a1);
  sub_100BAC914((uint64_t)(v2 + 3), (void *)(a1 + 48));
  sub_100BAD0A8((uint64_t)(v2 + 6), (void *)(a1 + 96));
  __int128 v3 = *(_OWORD *)(a1 + 160);
  v2[9] = *(_OWORD *)(a1 + 144);
  v2[10] = v3;
  sub_100BAD944((uint64_t)(v2 + 11), (void *)(a1 + 176));
  *((void *)v2 + sub_100231C10(v1 + 28) = *(void *)(a1 + 224);
  *((_DWORD *)v2 + 58) = *(_DWORD *)(a1 + 232);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100BAC024;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  240LL);
}

void sub_100BA3E94(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA3ED8(void *a1)
{
  return sub_100BA6F58(a1);
}

uint64_t sub_100BA3F10(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t *a4, uint64_t a5)
{
  return sub_100BA3564(a1 - 136, a2, a3, a4, a5);
}

void sub_100BA3F18(uint64_t a1)
{
  uint64_t v2 = a1 + 248;
  sub_10009D6F4(v5, a1 + 112, a1 + 248);
  sub_1000B2B0C(v3, a1 + 120, v2);
  sub_1000A7674(v5);
  sub_1000B2B10(v3);
  uint64_t v7 = (void **)&v4;
  sub_10005771C(&v7);
  v3[0] = (void **)&v6;
  sub_10005771C(v3);
}

void sub_100BA3F98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  a10 = (void **)&a17;
  sub_10005771C(&a10);
  _Unwind_Resume(a1);
}

void sub_100BA3FD4(uint64_t a1)
{
}

id sub_100BA3FDC(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a1 + 160) != 1.79769313e308)
  {
    [*(id *)(a1 + 152) invalidate];
    *(void *)(a1 + 160) = 0x7FEFFFFFFFFFFFFFLL;
  }

  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  *(double *)(a1 + 160) = (Current_1 * 1000.0 + (double)a2) / 1000.0;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 160);
    *(_DWORD *)uint64_t buf = 68289794;
    int v10 = 0;
    __int16 v11 = 2082;
    uint64_t v12 = "";
    __int16 v13 = 2050;
    double v14 = Current_1;
    __int16 v15 = 2050;
    uint64_t v16 = a2;
    __int16 v17 = 2050;
    uint64_t v18 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CLMicroLocationNotifier, Starting periodic Trigger Event Timer, now:%{public}.3f, durationInMs:%{public}lld, expected end time:%{public}.3f}",  buf,  0x30u);
  }

  [*(id *)(a1 + 152) setNextFireTime:*(double *)(a1 + 160)];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  __int128 v8[2] = sub_100BA417C;
  _OWORD v8[3] = &unk_10181D3D0;
  v8[4] = a1;
  return [*(id *)(a1 + 152) setHandler:v8];
}

void sub_100BA417C(uint64_t a1)
{
}

void sub_100BA4184(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  __int128 v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 2050;
    CFAbsoluteTime v8 = Current_1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CLMicroLocationNotifier, periodic Trigger Event Timer stopped, now:%{public}.3f}",  (uint8_t *)v4,  0x1Cu);
  }

  [*(id *)(a1 + 152) invalidate];
  *(void *)(a1 + 160) = 0x7FEFFFFFFFFFFFFFLL;
  sub_10012848C((unsigned __int8 *)(a1 + 584));
}

id sub_100BA4298(uint64_t a1, uint64_t a2)
{
  return sub_100BA3FDC(a1 - 136, a2);
}

BOOL sub_100BA42A0(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a1 + 176);
  if (v4 == 1.79769313e308)
  {
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    *(double *)(a1 + 176) = (Current_1 * 1000.0 + (double)a2) / 1000.0;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_101874AF8);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 176);
      *(_DWORD *)uint64_t buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2050;
      double v15 = Current_1;
      __int16 v16 = 2050;
      uint64_t v17 = a2;
      __int16 v18 = 2050;
      uint64_t v19 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CLMicroLocationNotifier, Starting Rescheduled Localization Timer, now:%{public}.3 f, durationInMs:%{public}lld, expected end time:%{public}.3f}",  buf,  0x30u);
    }

    [*(id *)(a1 + 168) setNextFireTime:*(double *)(a1 + 176)];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100BA4444;
    v9[3] = &unk_10181D3D0;
    v9[4] = a1;
    [*(id *)(a1 + 168) setHandler:v9];
  }

  return v4 == 1.79769313e308;
}

void sub_100BA4444(uint64_t a1)
{
}

void sub_100BA444C(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  __int128 v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 2050;
    CFAbsoluteTime v8 = Current_1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationNotifier, Rescheduled Localization Timer stopped, now:%{public}.3f}",  (uint8_t *)v4,  0x1Cu);
  }

  [*(id *)(a1 + 168) invalidate];
  *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
  sub_100128664(a1 + 584);
}

BOOL sub_100BA4560(uint64_t a1, uint64_t a2)
{
  return sub_100BA42A0(a1 - 136, a2);
}

void sub_100BA4568(uint64_t a1, __int128 *a2)
{
}

void sub_100BA4570(uint64_t a1, __int128 *a2)
{
}

uint64_t sub_100BA4578(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_100BA4580(uint64_t a1)
{
  return *(void *)(a1 - 72);
}

uint64_t sub_100BA4588(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_100BA45A4(uint64_t a1)
{
  return 1LL;
}

void sub_100BA45C0(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100BAE0DC(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void *sub_100BA4644(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a2[4];
    uint64_t v5 = a2[1];
    uint64_t v6 = a2[2];
    uint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
    if (v6 == v5)
    {
      unint64_t v8 = 0LL;
      int v11 = 0LL;
      int v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
    }

    else
    {
      unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
      unint64_t v9 = a2[5] + v4;
      int v10 = (char *)(v5 + 8 * (v9 >> 9));
      int v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
    }

    sub_100BAE3F0(a1, v7, v8, v10, v11);
  }

  return a1;
}

CLCppContainer *sub_100BA46D4(uint64_t a1)
{
  uint64_t v2 = operator new(0x60uLL);
  __int128 v3 = *(_OWORD *)(a1 + 16);
  *uint64_t v2 = *(_OWORD *)a1;
  v2[1] = v3;
  *((void *)v2 + 4) = *(void *)(a1 + 32);
  *((_DWORD *)v2 + 10) = *(_DWORD *)(a1 + 40);
  sub_100BAEEBC((uint64_t)(v2 + 3), (void *)(a1 + 48));
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100BAEE84;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  96LL);
}

void sub_100BA4774(_Unwind_Exception *a1)
{
}

void sub_100BA4788()
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v0 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v1[0] = 68289026;
    v1[1] = 0;
    __int16 v2 = 2082;
    __int128 v3 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationNotifier::onNowPlayingEvent}",  (uint8_t *)v1,  0x12u);
  }

void sub_100BA4860()
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  uint64_t v0 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v1[0] = 68289026;
    v1[1] = 0;
    __int16 v2 = 2082;
    __int128 v3 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationNotifier::onAppLaunchEvent}",  (uint8_t *)v1,  0x12u);
  }

void sub_100BA4938(uint64_t a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_101874AF8);
  }
  __int128 v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 1026;
    int v8 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationNotifier::onNowPlayingQueryResult, Number of events:%{public}d}",  (uint8_t *)v4,  0x18u);
  }

void sub_100BA4A20(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  int v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLMicroLocationNotifier");
  sub_100BA4AE8((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *int v8 = off_101874980;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100BA4ABC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA4AE8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_101875238;
  *(void *)(a1 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    __int16 v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_100BA4BBC(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        unint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)uint64_t buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101874AD8);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        *(_DWORD *)uint64_t buf = 136446466;
        uint64_t v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101874AD8);
        }
        __int16 v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        id v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::Notification Data, char, CLMicroLocationNotifier_Type::RegInfo>::removeClient(int) [Notification_T = CLMicroLocationNotifie r_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100BA4E30(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_100BAEFF8(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96LL))(a1, a2, &v10, v7);
  }

  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88LL))(a1, a2, &v9);
  }

uint64_t sub_100BA4EB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_10198FB58);
  if ((v3 & 1) == 0)
  {
    uint64_t v9 = a1;
    uint64_t v8 = a3;
    unsigned int v7 = a2;
    int v5 = __cxa_guard_acquire(&qword_10198FB58);
    a2 = v7;
    a3 = v8;
    int v6 = v5;
    a1 = v9;
    if (v6)
    {
      qword_10198FB40 = 0LL;
      *(void *)algn_10198FB48 = 0LL;
      qword_10198FB50 = 0LL;
      __cxa_atexit((void (*)(void *))sub_100355650, &qword_10198FB40, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_10198FB58);
      a1 = v9;
      a2 = v7;
      a3 = v8;
    }
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &qword_10198FB40);
}

BOOL sub_100BA4F58(uint64_t a1, int a2, int *a3, const std::string *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v40 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          int v23 = (uint64_t *)v17;
        }
        else {
          int v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          uint64_t v28 = (uint64_t *)v24;
        }
        else {
          uint64_t v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)uint64_t v42 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        *(void *)uint64_t buf = &v41;
        uint64_t v34 = sub_1004C2E20((uint64_t **)(v25 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        std::string::operator=((std::string *)(v34 + 5), a4);
        *(void *)uint64_t buf = 0LL;
        *(_OWORD *)&buf[16] = 0u;
        *(void *)&uint8_t buf[8] = &buf[16];
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v35 = sub_100BAF244(buf);
          sub_100BAF2E4((_BYTE *)a1, (uint64_t)&v40, (uint64_t)v42, v35);
        }

        sub_1000C39FC((uint64_t)&buf[8], *(void **)&buf[16]);
        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)uint64_t v42 = a1 + 64;
        char v29 = byte_10198FB60;
        HIDWORD(v39) = v16;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v29;
        HIDWORD(v39) = *a3;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        __int16 v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        HIDWORD(v39) = *a3;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)uint64_t buf = &v41;
        uint64_t v32 = sub_1004C2E20(v31 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        std::string::operator=((std::string *)(v32 + 5), a4);
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)uint64_t buf = *a3;
        sub_10004A8FC((uint64_t **)(v40 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101874AD8);
  }
  id v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    v36 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&v42[4] = v36;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v42,
      v39);
    v38 = (char *)v37;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData , char, CLMicroLocationNotifier_Type::RegInfo>::registerForNotification(int, const Notification_T &, const Registr ationInfo_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationN otifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
    return 0LL;
  }

  return result;
}

void sub_100BA53E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
}

BOOL sub_100BA5408(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136446466;
      __int16 v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101874AD8);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      int v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      uint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationDa ta, char, CLMicroLocationNotifier_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationDat a, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100BA5688(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_10052A02C((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101874AD8);
              }
              int v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)uint64_t buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                uint64_t v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101874AD8);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                uint64_t v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                uint64_t v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::Noti ficationData, char, CLMicroLocationNotifier_Type::RegInfo>::unregisterForNotification(int, const Notif ication_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicr oLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocat ionNotifier_Type::RegInfo]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100BA5A10(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  *(void *)a3 = *(void *)v11;
  if (v11 != a3) {
    sub_100BAF9E0((uint64_t **)(a3 + 8), *(__int128 **)(v11 + 8), (__int128 *)(v11 + 16));
  }
  return 1LL;
}

uint64_t sub_100BA5A94(uint64_t a1, int *a2, void *a3)
{
  int v10 = *a2;
  BOOL v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  int v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    uint64_t v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_100BA5B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BA5B54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0LL;
  __int128 v6 = 0u;
  uint64_t v5 = &v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  &v4,  a3,  a4,  0LL);
  sub_1000C39FC((uint64_t)&v5, (void *)v6);
}

void sub_100BA5BB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
}

void sub_100BA5BCC(uint64_t a1, unsigned int *a2, void *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      id v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)v66 = 0;
      *(_WORD *)&v66[4] = 2082;
      *(void *)&v66[6] = "";
      *(_WORD *)&v66[14] = 2082;
      *(void *)&v66[16] = "activity";
      __int16 v67 = 2082;
      v68 = v12;
      __int16 v69 = 2050;
      v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    uint64_t v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      uint64_t v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)v71 = &v71[8];
      memset(&v71[8], 0, 24);
      v72 = 0LL;
      sub_100BB0A40((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_100528470((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100528854((uint64_t)&v66[4], *(char **)&v66[12]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100528854((uint64_t)v71, *(char **)&v71[8]);
    }

    if (a4)
    {
      sub_100BB04D0(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      __int16 v27 = *(std::__shared_weak_count **)&v66[4];
      if (*(void *)&v66[4])
      {
        int v28 = (unint64_t *)(*(void *)&v66[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_100BB05CC(a3);
    if (a5 == -1)
    {
      sub_100BB066C((void *)a1, (int *)a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          __int16 v36 = (uint64_t *)v32;
        }
        else {
          __int16 v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v63 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      int v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          uint64_t v42 = (unint64_t *)v37;
        }
        else {
          uint64_t v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          int v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        v62 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101874AD8);
        }
        __int16 v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          char v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            int64x2_t v45 = v71;
          }
          else {
            int64x2_t v45 = *(_BYTE **)v71;
          }
          *(_DWORD *)uint64_t buf = 136315650;
          *(void *)v66 = v44;
          *(_WORD *)&v66[8] = 1024;
          *(_DWORD *)&v66[10] = a5;
          *(_WORD *)&v66[14] = 2080;
          *(void *)&v66[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101874AD8);
          }
          __int128 v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v61 >= 0) {
            uint64_t v48 = __p;
          }
          else {
            uint64_t v48 = (void **)__p[0];
          }
          *(_DWORD *)v71 = 136315650;
          *(void *)&v71[4] = v46;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v48;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v59);
          v50 = v49;
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::Notificati onData, char, CLMicroLocationNotifier_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const No tificationData_T &, BOOL, int, BOOL) [Notification_T = CLMicroLocationNotifier_Type::Notification, Notificat ionData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v50);
        }

        goto LABEL_83;
      }

      v62 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v53 = v39[3].n128_i64[0];
      __int128 v51 = v39 + 3;
      int v52 = (__n128 *)v53;
      if (!v53) {
        goto LABEL_60;
      }
      int v54 = *(_DWORD *)(v33 + 32);
      v55 = v51;
      do
      {
        int v56 = v52[2].n128_i32[0];
        BOOL v57 = v56 < v54;
        if (v56 >= v54) {
          v58 = v52;
        }
        else {
          v58 = (__n128 *)&v52->n128_i8[8];
        }
        if (!v57) {
          v55 = v52;
        }
        int v52 = (__n128 *)v58->n128_u64[0];
      }

      while (v58->n128_u64[0]);
      sub_100BAF2E4((_BYTE *)a1, (uint64_t)&v63, (uint64_t)&v62, v30);
    }

void sub_100BA61E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100BA6234(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    __int16 v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136315138;
      unint64_t v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101874AD8);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      __int128 v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationDa ta, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type:: Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, Re gistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101874AD8);
    }
    uint64_t v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315394;
      unint64_t v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101874AD8);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationDa ta, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type:: Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, Re gistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    int v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      uint64_t v11 = (void *)(a1 + 8);
      do
      {
        BOOL v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101874AD8);
            }
            id v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)uint64_t buf = 136315650;
              unint64_t v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101874AD8);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::Notifi cationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocatio nNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, Notif icationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                BOOL v12 = v18;
              }

              while (!v19);
            }

            BOOL v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            int v10 = v26;
          }

          while (!v19);
        }

        int v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100BA67E0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100BAEF98(a1);
  operator delete(v1);
}

id sub_100BA67F4(uint64_t a1, int a2, void *a3)
{
  id result = sub_100BAF7C0(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100BA6840(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100BA686C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100BA6898(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 72))
  {
  }

  return a1;
}

void sub_100BA68F0(uint64_t a1, int a2)
{
}

void sub_100BA6900(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4 = 0uLL;
  uint64_t v5 = 0LL;
  v7.length = CFArrayGetCount(a1);
  v7.location = 0LL;
  CFArrayApplyFunction(a1, v7, (CFArrayApplierFunction)sub_100BA69A0, &v4);
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  uint64_t v5 = 0LL;
  __int128 v4 = 0uLL;
  int v6 = (void **)&v4;
  sub_1000129D4(&v6);
}

void sub_100BA6980( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1000129D4(&a12);
  _Unwind_Resume(a1);
}

void sub_100BA69A0(void *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  if (v3 >= a2[2])
  {
    uint64_t v5 = sub_10112142C(a2, (__int128 *)__p);
  }

  else
  {
    if (SHIBYTE(v7) < 0)
    {
      sub_1010DD48C((_BYTE *)a2[1], __p[0], (unint64_t)__p[1]);
    }

    else
    {
      __int128 v4 = *(_OWORD *)__p;
      *(void *)(v3 + 16) = v7;
      *(_OWORD *)unint64_t v3 = v4;
    }

    uint64_t v5 = v3 + 24;
    a2[1] = v3 + 24;
  }

  a2[1] = v5;
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100BA6A34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)(v15 + 8) = v16;
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100BA6A5C(uint64_t a1, __int128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *((unsigned __int8 *)a2 + 72))
  {
    if (*(_BYTE *)(a1 + 72))
    {
      __int128 v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((_BYTE *)a2 + 23) = 0;
      *(_BYTE *)a2 = 0;
      uint64_t v5 = (void **)(a1 + 24);
      __int128 v6 = *(__int128 *)((char *)a2 + 24);
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *(_OWORD *)uint64_t v5 = v6;
      *((_BYTE *)a2 + 47) = 0;
      *((_BYTE *)a2 + 24) = 0;
      uint64_t v7 = (void **)(a1 + 48);
      __n128 result = (__n128)a2[3];
      *(void *)(a1 + 64) = *((void *)a2 + 8);
      *(__n128 *)uint64_t v7 = result;
      *((_BYTE *)a2 + 71) = 0;
      *((_BYTE *)a2 + memset(v19, 0, 48) = 0;
    }
  }

  else if (*(_BYTE *)(a1 + 72))
  {
    sub_100BA6B88(a1);
  }

  else
  {
    __int128 v9 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v9;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v10 = *(__int128 *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v10;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    __n128 result = (__n128)a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(__n128 *)(a1 + memset(v19, 0, 48) = result;
    *((void *)a2 + 7) = 0LL;
    *((void *)a2 + 8) = 0LL;
    *((void *)a2 + 6) = 0LL;
    *(_BYTE *)(a1 + 72) = 1;
  }

  return result;
}

void sub_100BA6B88(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 72))
  {
    *(_BYTE *)(a1 + 72) = 0;
  }

uint64_t sub_100BA6BE0(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    __int128 v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }

  else
  {
    __int128 v4 = a1 + 5;
    unint64_t v5 = a1[4];
    __int128 v6 = &v2[v5 / 0x38];
    unint64_t v7 = (unint64_t)*v6 + 72 * (v5 % 0x38);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x38] + 72 * ((a1[5] + v5) % 0x38);
    if (v7 != v8)
    {
      do
      {
        sub_100210578((void *)(v7 + 24));
        v7 += 72LL;
        if (v7 - (void)*v6 == 4032)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }

      while (v7 != v8);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }

  void *v4 = 0LL;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 28LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 56LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    id v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

char *sub_100BA6D20(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  if (*((char *)a2 + 47) < 0)
  {
    sub_1010DD48C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v5 = *(__int128 *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }

  __int128 v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_1010DD48C(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }

  else
  {
    __int128 v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)__int128 v6 = v7;
  }

  __dst[72] = 1;
  return __dst;
}

void sub_100BA6DD8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100BA6E0C(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    __int128 v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }

  else
  {
    __int128 v4 = a1 + 5;
    unint64_t v5 = a1[4];
    __int128 v6 = &v2[v5 / 0x66];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 40 * (v5 % 0x66);
    unint64_t v9 = (unint64_t)v2[(a1[5] + v5) / 0x66] + 40 * ((a1[5] + v5) % 0x66);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }

        v8 += 40LL;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }

      while (v8 != v9);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }

  void *v4 = 0LL;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 51LL;
  }

  else
  {
    if (v12 != 2) {
      goto LABEL_18;
    }
    uint64_t v13 = 102LL;
  }

  a1[4] = v13;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v14 = *v2++;
    operator delete(v14);
  }

  return sub_1000EA11C((uint64_t)a1);
}

uint64_t sub_100BA6F58(void *a1)
{
  __int16 v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    __int128 v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }

  else
  {
    __int128 v4 = a1 + 5;
    unint64_t v5 = a1[4];
    __int128 v6 = &v2[v5 / 0x49];
    unint64_t v7 = (char *)*v6 + 56 * (v5 % 0x49);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x49] + 56 * ((a1[5] + v5) % 0x49);
    if (v7 != (char *)v8)
    {
      do
      {
        unint64_t v7 = (char *)(sub_1000EAA04(v7) + 56);
        if (v7 - (_BYTE *)*v6 == 4088)
        {
          unint64_t v9 = (char *)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }

      while (v7 != (char *)v8);
      __int16 v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }

  void *v4 = 0LL;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      __int16 v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 36LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 73LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void *sub_100BA7094(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_101874F68;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA70C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101874F68;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BA70E4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = operator new(0x110uLL);
  uint64_t result = sub_1001121BC((uint64_t)v6, *(void *)(v5 + 32), a2);
  *a3 = v6;
  return result;
}

void sub_100BA712C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA7140(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BA717C()
{
}

void *sub_100BA7190(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101874FF8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA71C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101874FF8;
  a2[1] = v2;
  return result;
}

void *sub_100BA71E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = operator new(0x30uLL);
  uint64_t result = sub_10010F9F8(v6, *(void **)(v5 + 32), a2 + 16);
  *a3 = v6;
  return result;
}

void sub_100BA7228(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA723C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BA7278()
{
}

void *sub_100BA728C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101875088;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA72C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101875088;
  a2[1] = v2;
  return result;
}

void *sub_100BA72DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = operator new(0x18uLL);
  uint64_t result = sub_10004CE00(v6, *(void *)(v5 + 32), a2 + 24);
  *a3 = v6;
  return result;
}

void sub_100BA7324(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA7338(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BA7374()
{
}

void *sub_100BA7388(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101875118;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA73BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101875118;
  a2[1] = v2;
  return result;
}

void *sub_100BA73D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = operator new(0x30uLL);
  uint64_t result = sub_10011E228(v6, *(void **)(v5 + 32), a2 + 32);
  *a3 = v6;
  return result;
}

void sub_100BA7420(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA7434(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BA7470()
{
}

void *sub_100BA7484(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1018751A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA74B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1018751A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BA74D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = operator new(0x90uLL);
  uint64_t result = sub_10011FFF0((uint64_t)v6, *(void **)(v5 + 32), a2 + 40);
  *a3 = v6;
  return result;
}

void sub_100BA751C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA7530(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BA756C()
{
}

void sub_100BA7578(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    sub_100BA6898((uint64_t)v1 + 32);
    operator delete(v1);
  }

char *sub_100BA75B0(char *__dst, uint64_t a2)
{
  *__int128 __dst = 0;
  __dst[72] = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    sub_100BA7604(__dst, (__int128 *)a2);
    __dst[72] = 1;
  }

  return __dst;
}

void sub_100BA75F0(_Unwind_Exception *a1)
{
}

char *sub_100BA7604(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  if (*((char *)a2 + 47) < 0)
  {
    sub_1010DD48C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v5 = *(__int128 *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }

  __int128 v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_1010DD48C(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }

  else
  {
    __int128 v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)__int128 v6 = v7;
  }

  return __dst;
}

void sub_100BA76B4(_Unwind_Exception *exception_object)
{
}

void sub_100BA76E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    operator delete((void *)v1);
  }

void sub_100BA7728(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    sub_100BA6BE0(v1 + 42);
    sub_100231C10(v1 + 28);
    uint64_t v2 = (void *)v1[25];
    if (v2)
    {
      v1[26] = v2;
      operator delete(v2);
    }

    sub_100210578(v1 + 12);
    sub_100210578(v1 + 3);
    operator delete(v1);
  }

uint64_t sub_100BA7788(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_100BA7884(a1 + 8, (void *)(a2 + 8));
  __int128 v4 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v4;
  sub_100BA801C(a1 + 80, (void *)(a2 + 80));
  __int128 v5 = *(_OWORD *)(a2 + 128);
  __int128 v6 = *(_OWORD *)(a2 + 144);
  __int128 v7 = *(_OWORD *)(a2 + 160);
  uint64_t v8 = *(void *)(a2 + 176);
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 176) = v8;
  *(_OWORD *)(a1 + 160) = v7;
  *(_OWORD *)(a1 + 144) = v6;
  *(_OWORD *)(a1 + 1sub_100231C10(v1 + 28) = v5;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 200) = 0LL;
  sub_100007590( (void *)(a1 + 184),  *(const void **)(a2 + 184),  *(void *)(a2 + 192),  (uint64_t)(*(void *)(a2 + 192) - *(void *)(a2 + 184)) >> 3);
  sub_100BA87B4(a1 + 208, (void *)(a2 + 208));
  __int128 v9 = *(_OWORD *)(a2 + 256);
  __int128 v10 = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(_OWORD *)(a1 + 256) = v9;
  *(_OWORD *)(a1 + 272) = v10;
  return a1;
}

void sub_100BA7848(_Unwind_Exception *a1)
{
  __int128 v6 = *v4;
  if (*v4)
  {
    *(void *)(v2 + 192) = v6;
    operator delete(v6);
  }

  sub_100210578(v3);
  sub_100210578(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA7884(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  __int128 v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    uint64_t v8 = 0LL;
    unint64_t v11 = 0LL;
    __int128 v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    uint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    __int128 v10 = (char *)(v5 + 8 * (v9 >> 9));
    unint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }

  sub_100BA792C((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BA7918(_Unwind_Exception *a1)
{
}

void *sub_100BA792C(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100BA7960(a1, a2, a3, v5);
}

void *sub_100BA7960(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BA7A94(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  uint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_1008232F8((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        BOOL v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            int v22 = a2[1];
            ++a2;
            BOOL v19 = v22;
            a3 = v22;
          }
        }

        while (v20 != (void *)v18);
      }

      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }

    while (v23 != v16);
    a1[5] = v17;
  }

  return result;
}

void sub_100BA7A94(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          int v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            BOOL v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)BOOL v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          unint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          int v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }

          __int16 v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        int v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              __int128 v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                int v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)int v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64x2_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          int v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      BOOL v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BA7FA8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA801C(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }

  sub_100BA80C4((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BA80B0(_Unwind_Exception *a1)
{
}

void *sub_100BA80C4(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100BA80F8(a1, a2, a3, v5);
}

void *sub_100BA80F8(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BA822C(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_1008232F8((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            BOOL v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }

        while (v20 != (void *)v18);
      }

      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }

    while (v23 != v16);
    a1[5] = v17;
  }

  return result;
}

void sub_100BA822C(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          int v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            BOOL v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)BOOL v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          unint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          int v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }

          __int16 v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        int v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              __int128 v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                int v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)int v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64x2_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          int v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      BOOL v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BA8740( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA87B4(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 8));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 8));
  }

  else
  {
    unint64_t v8 = (__int128 *)(*(void *)v7 + 16LL * v4);
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 8));
    uint64_t v11 = (__int128 *)(*(void *)v10 + 16LL * v9);
  }

  sub_100BA8854((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BA8840(_Unwind_Exception *a1)
{
}

void *sub_100BA8854(void *a1, char *a2, __int128 *a3, char *a4, __int128 *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 4) + 32 * (a4 - a2) - (((uint64_t)a3 - *(void *)a2) >> 4);
  }
  return sub_100BA8888(a1, a2, a3, v5);
}

void *sub_100BA8888(void *a1, void *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 32 * (v9 - v8) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BA89B4(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 8));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 16LL * v11;
  }
  v22[0] = v8 + 8 * (v11 >> 8);
  v22[1] = v14;
  uint64_t result = sub_10025C760((uint64_t)v22, a4);
  while (v14 != v16)
  {
    uint64_t v17 = (_OWORD *)(v13 == result ? v16 : *v13 + 4096LL);
    if ((_OWORD *)v14 == v17)
    {
      uint64_t v17 = (_OWORD *)v14;
    }

    else
    {
      uint64_t v18 = (_OWORD *)v14;
      do
      {
        __int128 v19 = *a3++;
        _OWORD *v18 = v19;
        if ((__int128 *)((char *)a3 - *a2) == (__int128 *)4096)
        {
          uint64_t v20 = (__int128 *)a2[1];
          ++a2;
          a3 = v20;
        }

        ++v18;
      }

      while (v18 != v17);
    }

    a1[5] += ((uint64_t)v17 - v14) >> 4;
    if (v13 == result) {
      break;
    }
    uint64_t v21 = v13[1];
    ++v13;
    uint64_t v14 = v21;
  }

  return result;
}

void sub_100BA89B4(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((_BYTE)v5) {
    unint64_t v6 = (v5 >> 8) + 1;
  }
  else {
    unint64_t v6 = v5 >> 8;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 8) {
    unint64_t v8 = v7 >> 8;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 8)
  {
    for (a1[4] = v7 - (v8 << 8); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          int v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            BOOL v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)BOOL v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          unint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          int v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }

          __int16 v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 255LL;
          }
          else {
            uint64_t v64 = 256LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 8);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        int v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              __int128 v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                int v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)int v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64x2_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          int v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      BOOL v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BA8EC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA8F3C(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    unint64_t v5 = 0LL;
    unint64_t v8 = 0LL;
    unint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x38));
  }

  else
  {
    unint64_t v5 = (__int128 *)(*(void *)(v4 + 8 * (v3 / 0x38)) + 72 * (v3 % 0x38));
    unint64_t v6 = a2[5] + v3;
    unint64_t v7 = (void *)(v4 + 8 * (v6 / 0x38));
    unint64_t v8 = (__int128 *)(*v7 + 72 * (v6 % 0x38));
  }

  sub_100BA9008((void *)a1, (void *)(v4 + 8 * (v3 / 0x38)), v5, v7, v8);
  return a1;
}

void sub_100BA8FF4(_Unwind_Exception *a1)
{
}

uint64_t sub_100BA9008(void *a1, void *a2, __int128 *a3, void *a4, __int128 *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = 56 * (a4 - a2)
  }
  return sub_100BA906C(a1, a2, a3, v5);
}

uint64_t sub_100BA906C(void *a1, void *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 56 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BA9234(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 / 0x38));
  if (v9 == v8) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *v13 + 72 * (v11 % 0x38);
  }
  uint64_t v24 = (void *)(v8 + 8 * (v11 / 0x38));
  unint64_t v25 = v14;
  uint64_t result = (uint64_t)sub_100368144(&v24, a4);
  uint64_t v16 = v25;
  if (v14 != v25)
  {
    uint64_t v17 = v24;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4032LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = 0LL;
        do
        {
          uint64_t v20 = v14 + v19;
          __int128 v21 = *a3;
          *(void *)(v20 + 16) = *((void *)a3 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t result = sub_100BA801C(v14 + v19 + 24, (void *)a3 + 3);
          a3 = (__int128 *)((char *)a3 + 72);
          if ((__int128 *)((char *)a3 - *a2) == (__int128 *)4032)
          {
            BOOL v22 = (__int128 *)a2[1];
            ++a2;
            a3 = v22;
          }

          v19 += 72LL;
        }

        while (v14 + v19 != v18);
      }

      a1[5] -= 0x71C71C71C71C71C7LL * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v23 = v13[1];
      ++v13;
      unint64_t v14 = v23;
    }

    while (v23 != v16);
  }

  return result;
}

void sub_100BA9210(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x71C71C71C71C71C7LL * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100BA9234(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x38) {
    unint64_t v6 = v5 / 0x38 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x38;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x38) {
    unint64_t v8 = v7 / 0x38;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x38)
  {
    for (a1[4] = v7 - 56 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          int v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            BOOL v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)BOOL v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          unint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          __int16 v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFC0uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0xFC0uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 55LL;
          }
          else {
            uint64_t v64 = 56LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - 56 * v8;
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = -56LL * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFC0uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        int v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              __int128 v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                int v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)int v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64x2_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          int v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      BOOL v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BA9774( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BA97E8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

double sub_100BA97F8(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 56 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BA98EC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x38)) + 72 * (v7 % 0x38);
  __int128 v9 = *a2;
  *(void *)(v8 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v8 = v9;
  *(void *)(v8 + 24) = *((void *)a2 + 3);
  *(void *)(v8 + 32) = *((void *)a2 + 4);
  *(void *)(v8 + 40) = *((void *)a2 + 5);
  *(void *)(v8 + memset(v19, 0, 48) = *((void *)a2 + 6);
  double result = 0.0;
  *(__int128 *)((char *)a2 + 40) = 0u;
  *(__int128 *)((char *)a2 + 24) = 0u;
  *(void *)(v8 + 56) = *((void *)a2 + 7);
  *(void *)(v8 + 64) = *((void *)a2 + 8);
  *((void *)a2 + 7) = 0LL;
  *((void *)a2 + 8) = 0LL;
  ++a1[5];
  return result;
}

void sub_100BA98EC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x38;
  unint64_t v4 = v2 - 56;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BA9BB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BA9C00(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100BA9C84(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_100BA9C84(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BA9F4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BA9F98(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAA260( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BAA2AC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAA574( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BAA5C0(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100BAA644(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_100BAA644(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAA90C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100BAA958(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BAA9E4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *unint64_t v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100BAA9E4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAACAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_100BAACF8(int64x2_t *a1, void *a2, uint64_t a3, __int128 *a4)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  __int128 v9 = (void *)(v7 + 8 * (v6 / 0x66));
  if (v8 == v7) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = *v9 + 40 * (v6 % 0x66);
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 102 * (a2 - v9)
  }
        - 0x3333333333333333LL * ((a3 - *a2) >> 3)
        + 0x3333333333333333LL * ((uint64_t)(v10 - *v9) >> 3);
  uint64_t v12 = a1[2].i64[1];
  unint64_t v13 = v12 - v11;
  if (v11 >= v12 - v11)
  {
    if (v8 == v7) {
      uint64_t v24 = 0LL;
    }
    else {
      uint64_t v24 = 102 * ((v8 - v7) >> 3) - 1;
    }
    if (v24 == v12 + v6)
    {
      sub_100BAB5CC(a1);
      uint64_t v12 = a1[2].i64[1];
      unint64_t v13 = v12 - v11;
    }

    if (v12 == v11)
    {
      unint64_t v25 = *(void *)(a1->i64[1] + 8 * ((a1[2].i64[0] + v11) / 0x66)) + 40 * ((a1[2].i64[0] + v11) % 0x66);
      __int128 v26 = *a4;
      *(void *)(v25 + 16) = *((void *)a4 + 2);
      *(_OWORD *)unint64_t v25 = v26;
      *((void *)a4 + 1) = 0LL;
      *((void *)a4 + 2) = 0LL;
      *(void *)a4 = 0LL;
      *(_OWORD *)(v25 + 24) = *(__int128 *)((char *)a4 + 24);
      ++a1[2].i64[1];
    }

    else
    {
      unint64_t v27 = a1[2].i64[0] + v12;
      uint64_t v28 = a1->i64[1];
      unint64_t v29 = (uint64_t *)(v28 + 8 * (v27 / 0x66));
      uint64_t v30 = *v29;
      unint64_t v31 = *v29 + 40 * (v27 % 0x66);
      if (a1[1].i64[0] == v28) {
        uint64_t v32 = 0LL;
      }
      else {
        uint64_t v32 = v31;
      }
      unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * ((v32 - v30) >> 3);
      if (v32 - v30 < 41)
      {
        unint64_t v45 = 102 - v33;
        BOOL v35 = &v29[-(v45 / 0x66)];
        uint64_t v36 = *v35 + 40 * (102 * (v45 / 0x66) - v45) + 4040;
      }

      else
      {
        unint64_t v34 = v33 - 1;
        BOOL v35 = &v29[v34 / 0x66];
        uint64_t v36 = *v35 + 40 * (v34 % 0x66);
      }

      __int128 v46 = *(_OWORD *)v36;
      *(void *)(v32 + 16) = *(void *)(v36 + 16);
      *(_OWORD *)uint64_t v32 = v46;
      *(void *)(v36 + 8) = 0LL;
      *(void *)(v36 + 16) = 0LL;
      *(void *)uint64_t v36 = 0LL;
      *(_OWORD *)(v32 + 24) = *(_OWORD *)(v36 + 24);
      ++a1[2].i64[1];
      if (v13 >= 2)
      {
        v57.n128_u64[0] = (unint64_t)v29;
        v57.n128_u64[1] = v32;
        sub_10025BF98(&v57, -(uint64_t)v13);
        sub_100BABACC((uint64_t *)v57.n128_u64[0], v57.n128_i64[1], v35, v36, v29, v32, &v57);
        unint64_t v29 = v58;
        uint64_t v32 = v59;
      }

      if (v32 == *v29) {
        uint64_t v32 = *(v29 - 1) + 4080;
      }
      uint64_t v47 = (void **)(v32 - 40);
      __int128 v48 = *a4;
      *(void *)(v32 - 24) = *((void *)a4 + 2);
      *(_OWORD *)uint64_t v47 = v48;
      *((_BYTE *)a4 + 23) = 0;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(v32 - 16) = *(__int128 *)((char *)a4 + 24);
    }
  }

  else
  {
    if (!v6) {
      sub_100BAB2B4((void **)a1);
    }
    unint64_t v14 = a1[2].u64[0];
    uint64_t v15 = a1->i64[1];
    uint64_t v16 = a1[1].i64[0];
    uint64_t v17 = (uint64_t *)(v15 + 8 * (v14 / 0x66));
    uint64_t v18 = *v17;
    if (v11)
    {
      unint64_t v19 = v18 + 40 * (v14 % 0x66);
      if (v16 == v15) {
        unint64_t v20 = 0LL;
      }
      else {
        unint64_t v20 = v19;
      }
      uint64_t v21 = v20 - v18;
      unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v18) >> 3);
      if (v21 < 41) {
        unint64_t v23 = v17[-((102 - v22) / 0x66)] + 40 * (102 * ((102 - v22) / 0x66) - (102 - v22)) + 4040;
      }
      else {
        unint64_t v23 = v17[(v22 - 1) / 0x66] + 40 * ((v22 - 1) % 0x66);
      }
      __int128 v39 = *(_OWORD *)v20;
      *(void *)(v23 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)unint64_t v23 = v39;
      *(void *)(v20 + 8) = 0LL;
      *(void *)(v20 + 16) = 0LL;
      *(void *)unint64_t v20 = 0LL;
      *(_OWORD *)(v23 + 24) = *(_OWORD *)(v20 + 24);
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
      if (v11 != 1)
      {
        uint64_t v40 = v20 - *v17;
        unint64_t v41 = 0xCCCCCCCCCCCCCCCDLL * (v40 >> 3);
        if (v40 < -39)
        {
          unint64_t v49 = 100 - v41;
          uint64_t v43 = (__int128 **)&v17[-(v49 / 0x66)];
          uint64_t v44 = (__int128 *)((char *)*v43 + 40 * (102 * (v49 / 0x66) - v49) + 4040);
        }

        else
        {
          unint64_t v42 = v41 + 1;
          uint64_t v43 = (__int128 **)&v17[v42 / 0x66];
          uint64_t v44 = (__int128 *)((char *)*v43 + 40 * (v42 % 0x66));
        }

        v57.n128_u64[0] = (unint64_t)v17;
        v57.n128_u64[1] = v20;
        sub_10025BF98(&v57, v11);
        __n128 v50 = v57;
        v57.n128_u64[0] = (unint64_t)v17;
        v57.n128_u64[1] = v20;
        sub_100BAB8E0(v43, v44, (__int128 **)v50.n128_u64[0], (__int128 *)v50.n128_u64[1], (uint64_t)&v57);
        unint64_t v20 = v57.n128_u64[1];
      }

      __int128 v51 = *a4;
      *(void *)(v20 + 16) = *((void *)a4 + 2);
      *(_OWORD *)unint64_t v20 = v51;
      *((_BYTE *)a4 + 23) = 0;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(v20 + 24) = *(__int128 *)((char *)a4 + 24);
    }

    else
    {
      uint64_t v37 = v18 + 40 * (v14 % 0x66);
      if (v16 == v15) {
        uint64_t v37 = 0LL;
      }
      if (v37 == v18) {
        uint64_t v37 = *(v17 - 1) + 4080;
      }
      __int128 v38 = *a4;
      *(void *)(v37 - 24) = *((void *)a4 + 2);
      *(_OWORD *)(v37 - 40) = v38;
      *((void *)a4 + 1) = 0LL;
      *((void *)a4 + 2) = 0LL;
      *(void *)a4 = 0LL;
      *(_OWORD *)(v37 - 16) = *(__int128 *)((char *)a4 + 24);
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
    }
  }

  unint64_t v52 = a1[2].u64[0];
  uint64_t v53 = a1->i64[1];
  __int128 v54 = (void *)(v53 + 8 * (v52 / 0x66));
  if (a1[1].i64[0] == v53) {
    unint64_t v55 = 0LL;
  }
  else {
    unint64_t v55 = *v54 + 40 * (v52 % 0x66);
  }
  v57.n128_u64[0] = (unint64_t)v54;
  v57.n128_u64[1] = v55;
  sub_10025BF98(&v57, v11);
  return v57.n128_u64[0];
}

void sub_100BAB2B4(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 102 * v4 - 1;
  }
  unint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x66)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    __int128 v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      __int128 v46 = a1 + 3;
      __int128 __p = sub_1000071BC(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      unint64_t v45 = (char *)__p + 8 * v12;
      unint64_t v41 = operator new(0xFF0uLL);
      sub_1000ECB90(&__p, &v41);
      unint64_t v13 = (char *)a1[1];
      unint64_t v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              __int128 v26 = v43;
              unint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                unint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                unint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              unint64_t v31 = __p;
              __int128 __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              unint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                unint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              unint64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                unint64_t v14 = v43;
              }

              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              unint64_t v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)unint64_t v14 = v32;
          unint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __int128 __p = v36;
      uint64_t v43 = v33;
      __int128 v38 = (char *)a1[3];
      __int128 v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      unint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 51LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 102;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        __int128 __p = operator new(0xFF0uLL);
        sub_1000EC960(a1, &__p);
        unint64_t v34 = a1[2];
        __int128 __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        __int128 __p = operator new(0xFF0uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 51LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 102;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 102;
    __int128 __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_100BAB580( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BAB5CC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000071BC(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      __int128 v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAB894( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

double sub_100BAB8E0(__int128 **a1, __int128 *a2, __int128 **a3, __int128 *a4, uint64_t a5)
{
  uint64_t v7 = *(uint64_t **)a5;
  uint64_t v8 = *(void *)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (uint64_t i = *a1 + 255; ; uint64_t i = v12 + 255)
    {
      sub_100BAB970(a2, i, v7, v8, &v14);
      uint64_t v8 = *((void *)&v15 + 1);
      uint64_t v7 = (uint64_t *)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      uint64_t v12 = *v10++;
      a2 = v12;
    }

    a2 = *a3;
  }

  sub_100BAB970(a2, a4, v7, v8, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void sub_100BAB970( __int128 *a1@<X1>, __int128 *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, __int128 **a5@<X8>)
{
  uint64_t v5 = a3;
  unint64_t v6 = a1;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }

  else
  {
    uint64_t v8 = a2;
    uint64_t v5 = a3 + 1;
    uint64_t v9 = *a3;
    while (1)
    {
      int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v9 - a4 + 4080) >> 3);
      uint64_t v11 = sub_100BABA4C((uint64_t)&v14, v6, (__int128 *)((char *)v6 + 40 * v10), a4);
      if (v11 == v8) {
        break;
      }
      unint64_t v6 = v11;
      uint64_t v13 = *v5++;
      uint64_t v9 = v13;
      a4 = v13;
    }

    a4 = v12;
    if (*(v5 - 1) + 4080 == v12) {
      a4 = *v5;
    }
    else {
      --v5;
    }
  }

  *a5 = v8;
  a5[1] = (__int128 *)v5;
  a5[2] = (__int128 *)a4;
}

__int128 *sub_100BABA4C(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      __int128 v7 = *v5;
      *(void *)(a4 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a4 = v7;
      *((_BYTE *)v5 + 23) = 0;
      *(_BYTE *)uint64_t v5 = 0;
      *(_OWORD *)(a4 + 24) = *(__int128 *)((char *)v5 + 24);
      a4 += 40LL;
      uint64_t v5 = (__int128 *)((char *)v5 + 40);
    }

    while (v5 != a3);
    return a3;
  }

  return v5;
}

__n128 sub_100BABACC@<Q0>( uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X5>, uint64_t a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    __int128 v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v14 = a4;
    __int128 v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_100BABB98(v12, v14, v15, v16, &v21);
      uint64_t v16 = v22.n128_i64[1];
      __int128 v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 4080;
    }

    uint64_t v18 = *a1 + 4080;
    uint64_t v19 = a2;
  }

  sub_100BABB98(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = a4;
  a7[1] = result;
  return result;
}

uint64_t sub_100BABB98@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a3;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }

  else
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a3;
    while (1)
    {
      int64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((a4 - v9) >> 3);
      uint64_t v11 = a2 - 40 * v10;
      uint64_t result = sub_100BABC70((uint64_t)&v16, v11, a2, a4);
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v5;
      uint64_t v9 = v14;
      a4 = v14 + 4080;
      a2 = v11;
    }

    a4 = v13;
    if (*v5 + 4080LL == v13)
    {
      uint64_t v15 = v5[1];
      ++v5;
      a4 = v15;
    }
  }

  *a5 = v8;
  a5[1] = (uint64_t)v5;
  a5[2] = a4;
  return result;
}

uint64_t sub_100BABC70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (void **)(a4 + v7 - 40);
      uint64_t v9 = (__int128 *)(a3 + v7 - 40);
      __int128 v10 = *v9;
      *(void *)(a4 + v7 - 24) = *(void *)(a3 + v7 - 24);
      *(_OWORD *)uint64_t v8 = v10;
      *(_BYTE *)(a3 + v7 - 17) = 0;
      *(_BYTE *)uint64_t v9 = 0;
      *(_OWORD *)(a4 + v7 - 16) = *(_OWORD *)(a3 + v7 - 16);
      v7 -= 40LL;
    }

    while (a3 + v7 != a2);
  }

  return a3;
}

void sub_100BABD0C(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 73 * v4 - 1;
  }
  unint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x49)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      __int128 __p = sub_1000071BC(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      unint64_t v41 = operator new(0xFF8uLL);
      sub_1000ECB90(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              uint64_t v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                unint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              __int128 v31 = __p;
              __int128 __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }

              __n128 v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __int128 __p = v36;
      uint64_t v43 = v33;
      __int128 v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 36LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 73;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        __int128 __p = operator new(0xFF8uLL);
        sub_1000EC960(a1, &__p);
        unint64_t v34 = a1[2];
        __int128 __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        __int128 __p = operator new(0xFF8uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 36LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 73;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 73;
    __int128 __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_100BABFD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BAC024(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    sub_100210578(v1 + 22);
    sub_100BA6E0C(v1 + 12);
    sub_1000EAA04(v1 + 6);
    unint64_t v2 = (void *)sub_100BA6F58(v1);
    operator delete(v2);
  }

uint64_t sub_100BAC070(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v7 = (void *)(v4
                  + (((unint64_t)(((a2[5] + v3) * (unsigned __int128)0x70381C0E070381C1uLL) >> 64) >> 2) & 0x1FFFFFFFFFFFFFF8LL));
  }

  else
  {
    uint64_t v5 = (void *)(*(void *)(v4 + 8 * (v3 / 0x49)) + 56 * (v3 % 0x49));
    unint64_t v6 = a2[5] + v3;
    uint64_t v7 = (void *)(v4 + 8 * (v6 / 0x49));
    uint64_t v8 = (void *)(*v7 + 56 * (v6 % 0x49));
  }

  sub_100BAC140((void *)a1, (void *)(v4 + 8 * (v3 / 0x49)), v5, v7, v8);
  return a1;
}

void sub_100BAC12C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BAC140(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = 73 * (a4 - a2)
  }
  return sub_100BAC1A4(a1, a2, a3, v5);
}

uint64_t sub_100BAC1A4(void *a1, void *a2, void *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 73 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BAC360(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  uint64_t v13 = (void *)(v8 + 8 * (v11 / 0x49));
  if (v9 == v8) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *v13 + 56 * (v11 % 0x49);
  }
  __n128 v22 = (void *)(v8 + 8 * (v11 / 0x49));
  unint64_t v23 = v14;
  uint64_t result = (uint64_t)sub_1005A9130(&v22, a4);
  uint64_t v16 = v23;
  if (v14 != v23)
  {
    BOOL v17 = v22;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4088LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = 0LL;
        do
        {
          uint64_t result = sub_100BAC914(v14 + v19, a3);
          *(void *)(result + memset(v19, 0, 48) = a3[6];
          a3 += 7;
          if ((void *)((char *)a3 - *a2) == (void *)4088)
          {
            int64_t v20 = (void *)a2[1];
            ++a2;
            a3 = v20;
          }

          v19 += 56LL;
        }

        while (v14 + v19 != v18);
      }

      a1[5] += 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v21 = v13[1];
      ++v13;
      unint64_t v14 = v21;
    }

    while (v21 != v16);
  }

  return result;
}

void sub_100BAC33C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) += 0x6DB6DB6DB6DB6DB7LL * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100BAC360(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x49) {
    unint64_t v6 = v5 / 0x49 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x49;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x49) {
    unint64_t v8 = v7 / 0x49;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x49)
  {
    for (a1[4] = v7 - 73 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF8uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0xFF8uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 72LL;
          }
          else {
            uint64_t v64 = 73LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - 73 * v8;
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0LL;
      }
      uint64_t v38 = -73LL * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFF8uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BAC8A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAC914(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 7));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 7));
  }

  else
  {
    unint64_t v8 = (__int128 *)(*(void *)v7 + 32 * (v4 & 0x7F));
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 7));
    uint64_t v11 = (__int128 *)(*(void *)v10 + 32 * (v9 & 0x7F));
  }

  sub_100BAC9BC((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BAC9A8(_Unwind_Exception *a1)
{
}

void *sub_100BAC9BC(void *a1, char *a2, __int128 *a3, char *a4, __int128 *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 5) + 16 * (a4 - a2) - (((uint64_t)a3 - *(void *)a2) >> 5);
  }
  return sub_100BAC9F0(a1, a2, a3, v5);
}

void *sub_100BAC9F0(void *a1, void *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 16 * (v9 - v8) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BACB20(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 7));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 32 * (v11 & 0x7F);
  }
  v23[0] = v8 + 8 * (v11 >> 7);
  v23[1] = v14;
  uint64_t result = sub_10079CCD8((uint64_t)v23, a4);
  while (v14 != v16)
  {
    BOOL v17 = (_OWORD *)(v13 == result ? v16 : *v13 + 4096LL);
    if ((_OWORD *)v14 == v17)
    {
      BOOL v17 = (_OWORD *)v14;
    }

    else
    {
      uint64_t v18 = (_OWORD *)v14;
      do
      {
        __int128 v19 = *a3;
        __int128 v20 = a3[1];
        a3 += 2;
        _OWORD *v18 = v19;
        v18[1] = v20;
        if ((__int128 *)((char *)a3 - *a2) == (__int128 *)4096)
        {
          uint64_t v21 = (__int128 *)a2[1];
          ++a2;
          a3 = v21;
        }

        v18 += 2;
      }

      while (v18 != v17);
    }

    a1[5] += ((uint64_t)v17 - v14) >> 5;
    if (v13 == result) {
      break;
    }
    uint64_t v22 = v13[1];
    ++v13;
    uint64_t v14 = v22;
  }

  return result;
}

void sub_100BACB20(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x7F) != 0) {
    unint64_t v6 = (v5 >> 7) + 1;
  }
  else {
    unint64_t v6 = v5 >> 7;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 7) {
    unint64_t v8 = v7 >> 7;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 7)
  {
    for (a1[4] = v7 - (v8 << 7); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 127LL;
          }
          else {
            uint64_t v64 = 128LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 7);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 7;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BAD034( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAD0A8(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    unint64_t v5 = 0LL;
    unint64_t v8 = 0LL;
    unint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x66));
  }

  else
  {
    unint64_t v5 = (__int128 *)(*(void *)(v4 + 8 * (v3 / 0x66)) + 40 * (v3 % 0x66));
    unint64_t v6 = a2[5] + v3;
    unint64_t v7 = (void *)(v4 + 8 * (v6 / 0x66));
    unint64_t v8 = (__int128 *)(*v7 + 40 * (v6 % 0x66));
  }

  sub_100BAD174((void *)a1, (void *)(v4 + 8 * (v3 / 0x66)), v5, v7, v8);
  return a1;
}

void sub_100BAD160(_Unwind_Exception *a1)
{
}

void *sub_100BAD174(void *a1, void *a2, __int128 *a3, void *a4, __int128 *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = 102 * (a4 - a2)
  }
  return sub_100BAD1C4(a1, a2, a3, v5);
}

void *sub_100BAD1C4(void *a1, void *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 102 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BAD390(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 / 0x66));
  if (v9 == v8) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *v13 + 40 * (v11 % 0x66);
  }
  uint64_t v23 = (void *)(v8 + 8 * (v11 / 0x66));
  unint64_t v24 = v14;
  uint64_t result = sub_10025BF98(&v23, a4);
  uint64_t v16 = v24;
  if (v14 != v24)
  {
    BOOL v17 = v23;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4080LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = 0LL;
        do
        {
          uint64_t result = (void *)(v14 + v19);
          if (*((char *)a3 + 23) < 0)
          {
            uint64_t result = sub_1010DD48C(result, *(void **)a3, *((void *)a3 + 1));
          }

          else
          {
            __int128 v20 = *a3;
            result[2] = *((void *)a3 + 2);
            *(_OWORD *)uint64_t result = v20;
          }

          *(_OWORD *)(v14 + v19 + 24) = *(__int128 *)((char *)a3 + 24);
          a3 = (__int128 *)((char *)a3 + 40);
          if ((__int128 *)((char *)a3 - *a2) == (__int128 *)4080)
          {
            uint64_t v21 = (__int128 *)a2[1];
            ++a2;
            a3 = v21;
          }

          v19 += 40LL;
        }

        while (v14 + v19 != v18);
      }

      a1[5] -= 0x3333333333333333LL * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v22 = v13[1];
      ++v13;
      unint64_t v14 = v22;
    }

    while (v22 != v16);
  }

  return result;
}

void sub_100BAD374(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x3333333333333333LL * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_100BAD390(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x66) {
    unint64_t v6 = v5 / 0x66 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x66;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x66) {
    unint64_t v8 = v7 / 0x66;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x66)
  {
    for (a1[4] = v7 - 102 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF0uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0xFF0uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 101LL;
          }
          else {
            uint64_t v64 = 102LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - 102 * v8;
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0LL;
      }
      uint64_t v38 = -102LL * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0xFF0uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BAD8D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAD944(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }

  sub_100BAD9EC((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BAD9D8(_Unwind_Exception *a1)
{
}

void *sub_100BAD9EC(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100BADA20(a1, a2, a3, v5);
}

void *sub_100BADA20(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BADB54(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  unint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_1008232F8((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = *a2;
        uint64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            BOOL v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }

        while (v20 != (void *)v18);
      }

      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }

    while (v23 != v16);
    a1[5] = v17;
  }

  return result;
}

void sub_100BADB54(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        int64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        int64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BAE068( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BAE0DC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BAE3A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100BAE3F0(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100BAE424(a1, a2, a3, v5);
}

void *sub_100BAE424(void *a1, char **a2, char *a3, unint64_t a4)
{
  int64_t v20 = a2;
  uint64_t v21 = a3;
  unint64_t v7 = a1[5];
  if (v7 >= a4)
  {
    uint64_t v14 = a1[1];
    uint64_t v15 = (char *)(v14 + 8LL * (a1[4] >> 9));
    if (a1[2] == v14) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *(void *)v15 + 8 * (a1[4] & 0x1FFLL);
    }
    v22[0] = a2;
    v22[1] = a3;
    uint64_t v18 = (char **)sub_1008232F8((uint64_t)v22, a4);
    uint64_t v23 = v15;
    uint64_t v24 = v16;
    sub_100BAE774(a2, a3, v18, v19, (uint64_t)&v23);
    return (void *)sub_100BAE67C((uint64_t)a1, v23, v24);
  }

  else
  {
    unint64_t v9 = (char **)sub_1008232F8((uint64_t)&v20, v7);
    uint64_t v10 = v8;
    uint64_t v11 = a1[1];
    if (a1[2] == v11) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = *(void *)(v11 + 8LL * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
    }
    uint64_t v23 = (char *)(v11 + 8LL * (a1[4] >> 9));
    uint64_t v24 = v12;
    sub_100BAE774(v20, v21, v9, v8, (uint64_t)&v23);
    return sub_100BAE548(a1, v9, v10, a4 - a1[5]);
  }

void *sub_100BAE548(void *a1, char **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100BAE8FC(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  uint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v24[0] = v8 + 8 * (v11 >> 9);
  v24[1] = v14;
  uint64_t result = sub_1008232F8((uint64_t)v24, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = *a2;
        int64_t v20 = (void *)v14;
        do
        {
          uint64_t v21 = *(void *)a3;
          a3 += 8;
          *v20++ = v21;
          if (a3 - v19 == 4096)
          {
            unint64_t v22 = a2[1];
            ++a2;
            uint64_t v19 = v22;
            a3 = v22;
          }
        }

        while (v20 != (void *)v18);
      }

      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v23 = v13[1];
      ++v13;
      uint64_t v14 = v23;
    }

    while (v23 != v16);
    a1[5] = v17;
  }

  return result;
}

uint64_t sub_100BAE67C(uint64_t result, char *a2, uint64_t a3)
{
  BOOL v3 = (void *)result;
  unint64_t v4 = *(void *)(result + 32);
  unint64_t v5 = v4 + *(void *)(result + 40);
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v8 = (char *)(v6 + 8 * (v5 >> 9));
  if (v7 == v6) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *(void *)v8 + 8 * (v5 & 0x1FF);
  }
  if (v9 != a3)
  {
    uint64_t v10 = ((v9 - *(void *)v8) >> 3) + ((v8 - a2) << 6);
    uint64_t v11 = a3 - *(void *)a2;
    uint64_t v12 = v10 - (v11 >> 3);
    if (v12 >= 1)
    {
      uint64_t v13 = (char *)(v6 + 8 * (v4 >> 9));
      if (v7 == v6) {
        uint64_t v14 = 0LL;
      }
      else {
        uint64_t v14 = *(void *)v13 + 8 * (*(void *)(result + 32) & 0x1FFLL);
      }
      v16[0] = v13;
      v16[1] = v14;
      if (v14 == a3) {
        uint64_t v15 = 0LL;
      }
      else {
        uint64_t v15 = (v11 >> 3) + ((a2 - v13) << 6) - ((v14 - *(void *)v13) >> 3);
      }
      sub_1008232F8((uint64_t)v16, v15);
      v3[5] -= v12;
      do
        uint64_t result = sub_100824250(v3, 1);
      while ((result & 1) != 0);
    }
  }

  return result;
}

double sub_100BAE774(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }

  else
  {
    uint64_t v8 = a1 + 1;
    sub_100BAE840(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      sub_100BAE840(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }

    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }

  sub_100BAE840(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_100BAE840@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  uint64_t v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    uint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __int128 __dst = v13;
    }

    __dst += 8 * v12;
    else {
      --v6;
    }
  }

  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

void sub_100BAE8FC(void *a1, unint64_t a2)
{
  BOOL v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          __int128 v32 = (uint64_t *)a1[1];
          BOOL v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            BOOL v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            uint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)uint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            BOOL v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            BOOL v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          BOOL v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)BOOL v3 = v18;
      BOOL v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          __int16 v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }

              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)v66 = v69;
          v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13) {
        __int128 v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        __int128 v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              __int128 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __n128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100BAEE10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BAEE84(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    sub_100210578(v1 + 6);
    operator delete(v1);
  }

uint64_t sub_100BAEEBC(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }

  sub_100BAEF64((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100BAEF50(_Unwind_Exception *a1)
{
}

void *sub_100BAEF64(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100BAE548(a1, a2, a3, v5);
}

uint64_t sub_100BAEF98(uint64_t a1)
{
  *(void *)a1 = &off_101875238;
  unint64_t v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *unint64_t v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

id sub_100BAEFF8(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100BAF044(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100BAF044(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101875250);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010134D7E9LL & 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101875250);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010134D7E9LL & 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  (uint8_t *)&v8,  0x20u);
  return 0LL;
}

void sub_100BAF218(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100BAF244(void *a1)
{
  id v2 = operator new(0x20uLL);
  *id v2 = *a1;
  sub_100BAF3FC(v2 + 1, (uint64_t)(a1 + 1));
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100BAF3C0;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  32LL);
}

void sub_100BAF2D0(_Unwind_Exception *a1)
{
}

_BYTE *sub_100BAF2E4(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100BAF7C0(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    uint64_t v11 = (uint64_t **)(*(void *)a3 + 40LL);
    unint64_t v14 = (int *)(*(void *)a2 + 32LL);
    __int16 v12 = sub_1004C2E20(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    double result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 5);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_100BAF3C0(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  if (v1)
  {
    sub_1000C39FC((uint64_t)(v1 + 1), v1[2]);
    operator delete(v1);
  }

uint64_t *sub_100BAF3FC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100BAF450(a1, *(__int128 **)a2, (__int128 *)(a2 + 8));
  return a1;
}

void sub_100BAF438(_Unwind_Exception *a1)
{
}

uint64_t *sub_100BAF450(uint64_t *result, __int128 *a2, __int128 *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    os_log_type_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      double result = sub_100BAF4D0(v5, v6, v4 + 2);
      uint64_t v7 = (__int128 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(__int128 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (__int128 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }

        while (!v9);
      }

      unint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100BAF4D0(uint64_t **a1, uint64_t a2, __int128 *a3)
{
  os_log_type_t v5 = (uint64_t **)sub_100BAF5C4(a1, a2, &v8, (const void **)v9[0] + 4);
  sub_1000085FC(a1, v8, v5, v9[0]);
  uint64_t v6 = v9[0];
  v9[0] = 0LL;
  sub_1000C3CCC((uint64_t)v9, 0LL);
  return v6;
}

void sub_100BAF544(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100BAF55C@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0xE0uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  double result = sub_100BAF6D0(v6 + 4, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_100BAF5AC(_Unwind_Exception *a1)
{
}

void *sub_100BAF5C4(void *a1, uint64_t a2, void *a3, const void **a4)
{
  uint64_t v6 = (void *)a2;
  if ((void *)*a1 == v6)
  {
    uint64_t v10 = v6;
  }

  else
  {
    BOOL v9 = (void *)*v6;
    if (*v6)
    {
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v11 = v6;
      do
      {
        uint64_t v10 = (void *)v11[2];
        BOOL v12 = *v10 == (void)v11;
        uint64_t v11 = v10;
      }

      while (v12);
    }
  }

  if (*v6)
  {
    *a3 = v10;
    return v10 + 1;
  }

  else
  {
    *a3 = v6;
  }

  return v6;
}

void *sub_100BAF6D0(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  sub_1000C38B0((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100BAF728(_Unwind_Exception *exception_object)
{
}

void *sub_100BAF744(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v5 = (void *)v4;
        uint64_t v4 = *v5;
        double result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }

      uint64_t v4 = v5[1];
    }

    while (v4);
    double result = v5 + 1;
  }

  else
  {
    double result = (void *)(a1 + 8);
  }

id sub_100BAF7C0(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100BAF80C(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100BAF80C(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101875250);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010134D812LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101875250);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010134D812LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  (uint8_t *)&v8,  0x20u);
  return 0LL;
}

uint64_t **sub_100BAF9E0(uint64_t **result, __int128 *a2, __int128 *a3)
{
  os_log_type_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *double result = (uint64_t *)(result + 1);
    v7[2] = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    __int128 v15 = result;
    uint64_t v16 = v8;
    uint64_t v17 = (const void **)v8;
    if (v8)
    {
      uint64_t v16 = sub_100115560((uint64_t)v8);
      if (a2 != a3)
      {
        id v9 = a2;
        do
        {
          v18[0] = (uint64_t)(v8 + 4);
          v18[1] = (uint64_t)(v8 + 7);
          sub_100BAFB6C((uint64_t)v18, (uint64_t)(v9 + 2));
          __int16 v10 = (uint64_t **)sub_1000C3B68((uint64_t)v5, v18, v17 + 4);
          sub_1000085FC(v5, v18[0], v10, (uint64_t *)v17);
          uint64_t v17 = (const void **)v16;
          if (v16) {
            uint64_t v16 = sub_100115560((uint64_t)v16);
          }
          uint64_t v11 = (__int128 *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              uint64_t v11 = *(__int128 **)v11;
            }

            while (v11);
          }

          else
          {
            do
            {
              a2 = (__int128 *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              id v9 = a2;
            }

            while (!v12);
          }

          int v8 = (uint64_t *)v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          id v9 = a2;
        }

        while (!v12);
      }
    }

    double result = (uint64_t **)sub_100BB0414((uint64_t)&v15);
  }

  if (a2 != a3)
  {
    do
    {
      double result = (uint64_t **)sub_100BB0468(v5, a2 + 2);
      unint64_t v13 = (__int128 *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          unint64_t v14 = v13;
          unint64_t v13 = *(__int128 **)v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          unint64_t v14 = (__int128 *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }

        while (!v12);
      }

      a2 = v14;
    }

    while (v14 != a3);
  }

  return result;
}

void sub_100BAFB58(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BAFB6C(uint64_t a1, uint64_t a2)
{
  std::string::operator=(*(std::string **)a1, (const std::string *)a2);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2 + 24) {
    sub_100BAFC10( *(char **)(a1 + 8),  *(char **)(a2 + 24),  *(void *)(a2 + 32),  (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5);
  }
  __int128 v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 33) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(v4 + 24) = v5;
  sub_1001588D0((std::string *)(v4 + 56), (const std::string *)(a2 + 80));
  sub_100BAFD20(v4 + 88, a2 + 112);
  *(_DWORD *)(v4 + 136) = *(_DWORD *)(a2 + 160);
  if (v4 != a2 + 24) {
    sub_10004C5F8( (char *)(v4 + 144),  *(char **)(a2 + 168),  *(void *)(a2 + 176),  (uint64_t)(*(void *)(a2 + 176) - *(void *)(a2 + 168)) >> 2);
  }
  return a1;
}

char *sub_100BAFC10(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  id v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 5)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      void *v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (a4 >> 59) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 4;
    if (v8 >> 4 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = sub_10004B974(v7, v11);
    unint64_t v13 = (char *)v7[1];
    BOOL v12 = (void **)(v7 + 1);
    id v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      uint64_t v19 = v9;
      uint64_t v20 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  BOOL v12 = (void **)(result + 8);
  unint64_t v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 5;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[32 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9 - 4);
    id v9 = (char *)*v12;
  }

  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    uint64_t v19 = v9;
    uint64_t v20 = v16;
LABEL_18:
    double result = (char *)memmove(v19, v20, v18);
  }

void sub_100BAFD20(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 40) == *(unsigned __int8 *)(a2 + 40))
  {
    if (a1 != a2)
    {
      if (*(_BYTE *)(a1 + 40))
      {
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
        sub_100BAFD80((void *)a1, *(uint64_t **)(a2 + 16), 0LL);
      }
    }
  }

  else if (*(_BYTE *)(a1 + 40))
  {
    *(_BYTE *)(sub_10004AD90(a1) + 40) = 0;
  }

  else
  {
    *(_BYTE *)(sub_10004AE0C(a1, a2) + 40) = 1;
  }

void sub_100BAFD80(void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = a1[1];
  if (v6)
  {
    for (uint64_t i = 0LL; i != v6; ++i)
      *(void *)(*a1 + 8 * i) = 0LL;
    uint64_t v8 = (void **)a1[2];
    a1[2] = 0LL;
    a1[3] = 0LL;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      uint64_t v10 = v8;
    }

    else
    {
      do
      {
        std::string::operator=((std::string *)(v8 + 2), (const std::string *)(v4 + 2));
        *(_OWORD *)(v8 + 5) = *(_OWORD *)(v4 + 5);
        uint64_t v10 = (void **)*v8;
        sub_100BAFE80(a1, v8);
        uint64_t v4 = (uint64_t *)*v4;
        if (v10) {
          BOOL v11 = v4 == a3;
        }
        else {
          BOOL v11 = 1;
        }
        uint64_t v8 = v10;
      }

      while (!v11);
    }

    sub_10004ADC8((int)a1, v10);
  }

  while (v4 != a3)
  {
    sub_100BB02F8(a1, (uint64_t)(v4 + 2));
    uint64_t v4 = (uint64_t *)*v4;
  }

void sub_100BAFE50(void *a1)
{
}

void sub_100BAFE6C(_Unwind_Exception *a1)
{
}

void *sub_100BAFE80(void *a1, void *a2)
{
  uint64_t v4 = (unsigned __int8 *)(a2 + 2);
  unint64_t v5 = sub_10004B1A4((uint64_t)(a1 + 3), (uint64_t)(a2 + 2));
  a2[1] = v5;
  uint64_t v6 = sub_100BAFEE0((uint64_t)a1, v5, v4);
  sub_100019674(a1, a2, v6);
  return a2;
}

unsigned __int8 *sub_100BAFEE0(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  uint64_t v6 = a1 + 32;
  float v7 = *(float *)(a1 + 32);
  unint64_t v8 = *(void *)(a1 + 8);
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  if (!v8 || (float)(v7 * (float)v8) < v9)
  {
    BOOL v10 = 1LL;
    if (v8 >= 3) {
      BOOL v10 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v11 = v10 | (2 * v8);
    unint64_t v12 = vcvtps_u32_f32(v9 / v7);
    if (v11 <= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    sub_100BB0050(a1, v13);
    unint64_t v8 = *(void *)(a1 + 8);
  }

  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
  v14.i16[0] = vaddlv_u8(v14);
  unint64_t v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v16 = a2;
    if (v8 <= a2) {
      unint64_t v16 = a2 % v8;
    }
  }

  else
  {
    unint64_t v16 = (v8 - 1) & a2;
  }

  uint64_t v17 = *(unsigned __int8 **)(*(void *)a1 + 8 * v16);
  if (v17)
  {
    size_t v18 = *(unsigned __int8 **)v17;
    if (*(void *)v17)
    {
      int v19 = 0;
      do
      {
        unint64_t v20 = *((void *)v18 + 1);
        if (v15 > 1)
        {
          unint64_t v21 = *((void *)v18 + 1);
          if (v20 >= v8) {
            unint64_t v21 = v20 % v8;
          }
        }

        else
        {
          unint64_t v21 = v20 & (v8 - 1);
        }

        if (v21 != v16) {
          break;
        }
        int v22 = v20 == a2 ? sub_100022A24(v6, v18 + 16, a3) : 0;
        if ((v19 & (v22 ^ 1) & 1) != 0) {
          break;
        }
        v19 |= v22;
        uint64_t v17 = *(unsigned __int8 **)v17;
        size_t v18 = *(unsigned __int8 **)v17;
      }

      while (*(void *)v17);
    }
  }

  return v17;
}

void sub_100BB0050(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }

    else
    {
      uint64_t v7 = 1LL << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }

    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4) {
LABEL_16:
    }
      sub_100BB012C(a1, prime);
  }

void sub_100BB012C(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1000070D4();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0LL;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0LL;
    while (a2 != v6);
    uint64_t v7 = *(unsigned __int8 ***)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = (unint64_t)v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      unint64_t v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }

      else
      {
        v8 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v12 = *v7;
      if (*v7)
      {
        unint64_t v18 = v9.u32[0];
        do
        {
          unint64_t v13 = *((void *)v12 + 1);
          if (v10 > 1)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }

          else
          {
            v13 &= a2 - 1;
          }

          if (v13 == v8)
          {
            uint64_t v7 = (unsigned __int8 **)v12;
          }

          else if (*(void *)(*(void *)a1 + 8 * v13))
          {
            uint8x8_t v14 = *(unsigned __int8 **)v12;
            if (*(void *)v12)
            {
              unint64_t v15 = v12;
              while (1)
              {
                int v16 = sub_100022A24(a1 + 32, v12 + 16, v14 + 16);
                uint64_t v17 = *(unsigned __int8 **)v15;
                if (!v16) {
                  break;
                }
                uint8x8_t v14 = *(unsigned __int8 **)v17;
                unint64_t v15 = *(unsigned __int8 **)v15;
                if (!*(void *)v17) {
                  goto LABEL_32;
                }
              }

              uint8x8_t v14 = *(unsigned __int8 **)v15;
              uint64_t v17 = v15;
LABEL_32:
              unint64_t v10 = v18;
            }

            else
            {
              uint64_t v17 = v12;
            }

            void *v7 = v14;
            *(void *)uint64_t v17 = **(void **)(*(void *)a1 + 8 * v13);
            **(void **)(*(void *)a1 + 8 * v13) = v12;
          }

          else
          {
            *(void *)(*(void *)a1 + 8 * v13) = v7;
            uint64_t v7 = (unsigned __int8 **)v12;
            unint64_t v8 = v13;
          }

          unint64_t v12 = *v7;
        }

        while (*v7);
      }
    }
  }

  else
  {
    unint64_t v11 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v11) {
      operator delete(v11);
    }
    *(void *)(a1 + 8) = 0LL;
  }

void *sub_100BB02F8(void *a1, uint64_t a2)
{
  return sub_100BAFE80(a1, v4);
}

void sub_100BB0330( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_10004B64C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100BB0354@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a1 + 16;
  uint64_t v7 = (char *)operator new(0x38uLL);
  unint64_t v8 = v7;
  *(void *)(a3 + 8) = v6;
  *(void *)a3 = v7;
  *(_BYTE *)(a3 + 16) = 0;
  uint8x8_t v9 = v7 + 16;
  *(void *)uint64_t v7 = 0LL;
  *((void *)v7 + 1) = 0LL;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1010DD48C(v7 + 16, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *uint8x8_t v9 = *(_OWORD *)a2;
    *((void *)v7 + 4) = *(void *)(a2 + 16);
  }

  *(_OWORD *)(v8 + 40) = *(_OWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
  unint64_t result = sub_10004B1A4(a1 + 24, (uint64_t)v9);
  *((void *)v8 + 1) = result;
  return result;
}

void sub_100BB03F8(_Unwind_Exception *a1)
{
  *id v2 = 0LL;
  sub_10004B64C(v3, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BB0414(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        id v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }

      while (v3);
      *(void *)(a1 + 8) = v2;
    }

    sub_1000C39FC(*(void *)a1, v2);
  }

  return a1;
}

uint64_t *sub_100BB0468(uint64_t **a1, __int128 *a2)
{
  uint64_t v3 = (uint64_t **)sub_1000C3B68((uint64_t)a1, &v6, (const void **)v7[0] + 4);
  sub_1000085FC(a1, v6, v3, v7[0]);
  int8x8_t v4 = v7[0];
  v7[0] = 0LL;
  sub_1000C3CCC((uint64_t)v7, 0LL);
  return v4;
}

void *sub_100BB04D0@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  int8x8_t v4 = operator new(0x38uLL);
  unint64_t result = sub_100BB0528(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100BB0514(_Unwind_Exception *a1)
{
}

void *sub_100BB0528(void *a1, void *a2)
{
  a1[2] = 0LL;
  *a1 = off_101875280;
  a1[1] = 0LL;
  a1[3] = *a2;
  sub_100BAF3FC(a1 + 4, (uint64_t)(a2 + 1));
  return a1;
}

void sub_100BB056C(_Unwind_Exception *a1)
{
}

void sub_100BB0580(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101875280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BB0594(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101875280;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100BB05B8(uint64_t a1)
{
}

CLCppContainer *sub_100BB05CC(void *a1)
{
  id v2 = operator new(0x20uLL);
  *id v2 = *a1;
  sub_100BAF3FC(v2 + 1, (uint64_t)(a1 + 1));
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100BB0AF0;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  32LL);
}

void sub_100BB0658(_Unwind_Exception *a1)
{
}

void sub_100BB066C(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    unint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint8x8_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          unint64_t v12 = (uint64_t *)v4;
        }
        else {
          unint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint8x8_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        __int128 v51 = v9;
        id v13 = sub_100BAF7C0(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        uint8x8_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          unint64_t v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 8);
            int v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                int v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100BAF2E4(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              unint64_t v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  __int128 v32 = (uint64_t *)v27;
                }
                else {
                  __int128 v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  unint64_t v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              __int128 v51 = v29;
              uint64_t v34 = v29[6];
              uint8x8_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 32);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 8))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 32);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint8x8_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  uint64_t v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint8x8_t v14 = v43;
                      uint64_t v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      uint8x8_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101874AD8);
              }
              uint64_t v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                unint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 8);
                *(_DWORD *)uint64_t buf = 136446466;
                __n128 v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101874AD8);
                }
                uint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 8);
                int v52 = 136446466;
                uint64_t v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                unint64_t v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::Notification Data, char, CLMicroLocationNotifier_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCp pContainer *) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMic roLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLoca tionNotifier_Type::RegInfo]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

uint64_t sub_100BB0A40(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_100BB0A9C((uint64_t *)(a1 + 8), a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 40) = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(_BYTE *)(a1 + memset(v19, 0, 48) = *(_BYTE *)(a3 + 40);
  return a1;
}

uint64_t *sub_100BB0A9C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_10052865C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100BB0AD8(_Unwind_Exception *a1)
{
}

void sub_100BB0AF0(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  if (v1)
  {
    sub_1000C39FC((uint64_t)(v1 + 1), v1[2]);
    operator delete(v1);
  }

void sub_100BB0B2C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      _DWORD v1[2] = xmmword_10134CD00;
      v1[3] = unk_10134CD10;
      v1[4] = xmmword_10134CD20;
      v1[0] = xmmword_10134CCE0;
      v1[1] = unk_10134CCF0;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100BB0C00(_Unwind_Exception *a1)
{
}

uint64_t sub_100BB0C18()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AC88, (void *)&_mh_execute_header);
}

uint64_t sub_100BB0C5C()
{
  if (qword_1019A1D38) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D38 + 8LL))(qword_1019A1D38);
  }
  if (qword_1019A1D40) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D40 + 8LL))(qword_1019A1D40);
  }
  if (qword_1019A1D48) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D48 + 8LL))(qword_1019A1D48);
  }
  if (qword_1019A1D50) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D50 + 8LL))(qword_1019A1D50);
  }
  if (qword_1019A1D58) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D58 + 8LL))(qword_1019A1D58);
  }
  if (qword_1019A1D60) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D60 + 8LL))(qword_1019A1D60);
  }
  if (qword_1019A1D68) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D68 + 8LL))(qword_1019A1D68);
  }
  if (qword_1019A1D70) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D70 + 8LL))(qword_1019A1D70);
  }
  if (qword_1019A1D78) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D78 + 8LL))(qword_1019A1D78);
  }
  if (qword_1019A1D80) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D80 + 8LL))(qword_1019A1D80);
  }
  if (qword_1019A1D88) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D88 + 8LL))(qword_1019A1D88);
  }
  if (qword_1019A1D90) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D90 + 8LL))(qword_1019A1D90);
  }
  if (qword_1019A1D98) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1D98 + 8LL))(qword_1019A1D98);
  }
  if (qword_1019A1DA0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DA0 + 8LL))(qword_1019A1DA0);
  }
  if (qword_1019A1DA8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DA8 + 8LL))(qword_1019A1DA8);
  }
  if (qword_1019A1DB0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DB0 + 8LL))(qword_1019A1DB0);
  }
  if (qword_1019A1DB8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DB8 + 8LL))(qword_1019A1DB8);
  }
  if (qword_1019A1DC0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DC0 + 8LL))(qword_1019A1DC0);
  }
  if (qword_1019A1DC8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DC8 + 8LL))(qword_1019A1DC8);
  }
  if (qword_1019A1DD0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DD0 + 8LL))(qword_1019A1DD0);
  }
  if (qword_1019A1DD8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DD8 + 8LL))(qword_1019A1DD8);
  }
  if (qword_1019A1DE0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DE0 + 8LL))(qword_1019A1DE0);
  }
  if (qword_1019A1DE8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DE8 + 8LL))(qword_1019A1DE8);
  }
  if (qword_1019A1DF0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DF0 + 8LL))(qword_1019A1DF0);
  }
  if (qword_1019A1DF8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1DF8 + 8LL))(qword_1019A1DF8);
  }
  if (qword_1019A1E00) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E00 + 8LL))(qword_1019A1E00);
  }
  if (qword_1019A1E08) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E08 + 8LL))(qword_1019A1E08);
  }
  if (qword_1019A1E10) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E10 + 8LL))(qword_1019A1E10);
  }
  if (qword_1019A1E18) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E18 + 8LL))(qword_1019A1E18);
  }
  if (qword_1019A1E20) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E20 + 8LL))(qword_1019A1E20);
  }
  if (qword_1019A1E28) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E28 + 8LL))(qword_1019A1E28);
  }
  if (qword_1019A1E30) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E30 + 8LL))(qword_1019A1E30);
  }
  if (qword_1019A1E38) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E38 + 8LL))(qword_1019A1E38);
  }
  if (qword_1019A1E40) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E40 + 8LL))(qword_1019A1E40);
  }
  if (qword_1019A1E48) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E48 + 8LL))(qword_1019A1E48);
  }
  if (qword_1019A1E50) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E50 + 8LL))(qword_1019A1E50);
  }
  if (qword_1019A1E58) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E58 + 8LL))(qword_1019A1E58);
  }
  if (qword_1019A1E60) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E60 + 8LL))(qword_1019A1E60);
  }
  if (qword_1019A1E68) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E68 + 8LL))(qword_1019A1E68);
  }
  if (qword_1019A1E70) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E70 + 8LL))(qword_1019A1E70);
  }
  if (qword_1019A1E78) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E78 + 8LL))(qword_1019A1E78);
  }
  if (qword_1019A1E80) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E80 + 8LL))(qword_1019A1E80);
  }
  if (qword_1019A1E88) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A1E88 + 8LL))(qword_1019A1E88);
  }
  uint64_t result = qword_1019A1E90;
  if (qword_1019A1E90) {
    return (*(uint64_t (**)(uint64_t))(*(void *)qword_1019A1E90 + 8LL))(qword_1019A1E90);
  }
  return result;
}

void sub_100BB1090(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_10199ACB8 & 1) == 0)
  {
    byte_10199ACB8 = 1;
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::VerifyVersion( (wireless_diagnostics::google::protobuf::internal *)0x1E9808,  2005000,  (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  a4);
    sub_100500DC8(v4, v5, v6, v7);
    sub_100612DD8(v8, v9, v10, v11);
    sub_100A3FD08(v12, v13, v14, v15);
    int v16 = (char *)operator new(0x198uLL);
    *(void *)int v16 = off_1018752D0;
    *((void *)v16 + 41) = 0LL;
    *((void *)v16 + 42) = 0LL;
    *((void *)v16 + 45) = 0LL;
    *((_DWORD *)v16 + 98) = 0;
    *(_OWORD *)(v16 + 8) = 0u;
    *(_OWORD *)(v16 + 24) = 0u;
    *(_OWORD *)(v16 + 40) = 0u;
    *(_OWORD *)(v16 + 56) = 0u;
    *(_OWORD *)(v16 + 72) = 0u;
    *(_OWORD *)(v16 + 88) = 0u;
    *(_OWORD *)(v16 + 104) = 0u;
    *(_OWORD *)(v16 + 120) = 0u;
    *(_OWORD *)(v16 + 136) = 0u;
    *(_OWORD *)(v16 + 152) = 0u;
    *(_OWORD *)(v16 + 168) = 0u;
    *(_OWORD *)(v16 + 184) = 0u;
    *(_OWORD *)(v16 + 200) = 0u;
    *(_OWORD *)(v16 + 216) = 0u;
    *(_OWORD *)(v16 + 232) = 0u;
    *((void *)v16 + 31) = 0LL;
    *((void *)v16 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    *((void *)v16 + 43) = 0LL;
    *((void *)v16 + 44) = 0LL;
    v16[368] = 0;
    *(void *)(v16 + 396) = 0LL;
    *(_OWORD *)(v16 + 264) = 0u;
    *(_OWORD *)(v16 + 280) = 0u;
    *(_OWORD *)(v16 + 296) = 0u;
    *(_OWORD *)(v16 + 312) = 0u;
    *((_DWORD *)v16 + 97) = 0;
    *(void *)(v16 + 372) = 0LL;
    *(void *)(v16 + 380) = 0LL;
    qword_1019A1D38 = (uint64_t)v16;
    uint64_t v17 = operator new(0x20uLL);
    void *v17 = off_101875348;
    v17[1] = 0LL;
    v17[2] = 0LL;
    v17[3] = 0LL;
    qword_1019A1D40 = (uint64_t)v17;
    int v18 = (char *)operator new(0xE8uLL);
    *(void *)int v18 = off_1018753C0;
    *(_OWORD *)(v18 + 8) = 0u;
    *(_OWORD *)(v18 + 24) = 0u;
    *(_OWORD *)(v18 + 40) = 0u;
    *(_OWORD *)(v18 + 56) = 0u;
    *(_OWORD *)(v18 + 72) = 0u;
    *(_OWORD *)(v18 + 88) = 0u;
    *(_OWORD *)(v18 + 104) = 0u;
    *(_OWORD *)(v18 + 120) = 0u;
    *((void *)v18 + 17) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    *(void *)(v18 + 220) = 0LL;
    *((_OWORD *)v18 + 9) = 0u;
    *((_OWORD *)v18 + 10) = 0u;
    *((_OWORD *)v18 + 11) = 0u;
    *((_OWORD *)v18 + 12) = 0u;
    *(_OWORD *)(v18 + 204) = 0u;
    qword_1019A1D48 = (uint64_t)v18;
    int v19 = (char *)operator new(0x28uLL);
    *(void *)(v19 + sub_100231C10(v1 + 28) = 0LL;
    *((void *)v19 + 1) = 0LL;
    *((void *)v19 + 2) = 0LL;
    *(void *)int v19 = off_101875438;
    *(_DWORD *)(v19 + 23) = 0;
    qword_1019A1D50 = (uint64_t)v19;
    int v20 = (char *)operator new(0x18uLL);
    *(void *)int v20 = off_1018754B0;
    v20[8] = 1;
    *((void *)v20 + 2) = 0LL;
    *(_DWORD *)(v20 + 9) = 0;
    v20[13] = 0;
    qword_1019A1D58 = (uint64_t)v20;
    BOOL v21 = operator new(0x20uLL);
    *BOOL v21 = off_101875528;
    v21[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v21[2] = 0LL;
    *((_DWORD *)v21 + 6) = 0;
    qword_1019A1D60 = (uint64_t)v21;
    int v22 = operator new(0x18uLL);
    void *v22 = off_1018755A0;
    v22[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    void v22[2] = 0LL;
    qword_1019A1D68 = (uint64_t)v22;
    int v23 = operator new(0x28uLL);
    v23[1] = 0LL;
    void v23[2] = 0LL;
    *int v23 = off_101875618;
    *((_DWORD *)v23 + 6) = 0;
    v23[4] = 0LL;
    qword_1019A1D70 = (uint64_t)v23;
    uint64_t v24 = operator new(0x28uLL);
    void *v24 = &off_101875690;
    v24[1] = 0LL;
    *((_DWORD *)v24 + 4) = 0;
    *((_BYTE *)v24 + 20) = 0;
    v24[3] = 0LL;
    v24[4] = 0LL;
    qword_1019A1D78 = (uint64_t)v24;
    unint64_t v25 = (char *)operator new(0x28uLL);
    *(void *)unint64_t v25 = off_101875708;
    *(_OWORD *)(v25 + 8) = 0u;
    *(_OWORD *)(v25 + 24) = 0u;
    qword_1019A1D80 = (uint64_t)v25;
    int v26 = operator new(0x18uLL);
    v26[1] = 0LL;
    v26[2] = 0LL;
    void *v26 = off_101875780;
    qword_1019A1D88 = (uint64_t)v26;
    uint64_t v27 = operator new(0x18uLL);
    v27[1] = 0LL;
    v27[2] = 0LL;
    *uint64_t v27 = off_1018757F8;
    qword_1019A1D90 = (uint64_t)v27;
    int v28 = operator new(0x28uLL);
    v28[1] = 0LL;
    v28[2] = 0LL;
    *int v28 = off_101875870;
    *((_DWORD *)v28 + 6) = 0;
    v28[4] = 0LL;
    qword_1019A1D98 = (uint64_t)v28;
    unint64_t v29 = operator new(0x28uLL);
    v29[1] = 0LL;
    v29[2] = 0LL;
    void *v29 = off_1018758E8;
    *((_DWORD *)v29 + 6) = 0;
    v29[4] = 0LL;
    qword_1019A1DA0 = (uint64_t)v29;
    int v30 = operator new(0x28uLL);
    v30[1] = 0LL;
    v30[2] = 0LL;
    *int v30 = off_101875960;
    *((_DWORD *)v30 + 6) = 0;
    v30[4] = 0LL;
    qword_1019A1DA8 = (uint64_t)v30;
    BOOL v31 = (char *)operator new(0x28uLL);
    *(void *)BOOL v31 = off_1018759D8;
    *(_OWORD *)(v31 + 8) = 0u;
    *(_OWORD *)(v31 + 24) = 0u;
    qword_1019A1DB0 = (uint64_t)v31;
    __int128 v32 = (char *)operator new(0x50uLL);
    *(void *)__int128 v32 = off_101875A50;
    *((void *)v32 + 9) = 0LL;
    *(_OWORD *)(v32 + 8) = 0u;
    *(_OWORD *)(v32 + 24) = 0u;
    *(_OWORD *)(v32 + 40) = 0u;
    *(_OWORD *)(v32 + 54) = 0u;
    qword_1019A1DB8 = (uint64_t)v32;
    uint64_t v33 = operator new(0x28uLL);
    *uint64_t v33 = off_101875AC8;
    v33[1] = 0LL;
    *((_OWORD *)v33 + 1) = xmmword_10134D8D0;
    *((_DWORD *)v33 + 8) = 0;
    qword_1019A1DC0 = (uint64_t)v33;
    uint64_t v34 = operator new(0x20uLL);
    void *v34 = off_101875B40;
    v34[1] = 0LL;
    v34[2] = 4LL;
    *((_DWORD *)v34 + 6) = 0;
    qword_1019A1DC8 = (uint64_t)v34;
    uint64_t v35 = operator new(0x18uLL);
    *uint64_t v35 = off_101875BB8;
    v35[1] = 15LL;
    *((_DWORD *)v35 + 4) = 0;
    qword_1019A1DD0 = (uint64_t)v35;
    uint64_t v36 = (char *)operator new(0x30uLL);
    *(void *)uint64_t v36 = off_101875C30;
    *(_OWORD *)(v36 + 8) = 0u;
    *(_OWORD *)(v36 + 24) = 0u;
    *((void *)v36 + 5) = 0LL;
    qword_1019A1DD8 = (uint64_t)v36;
    int v37 = (char *)operator new(0x28uLL);
    *(void *)int v37 = off_101875CA8;
    *(_OWORD *)(v37 + 8) = 0u;
    *(_OWORD *)(v37 + 24) = 0u;
    qword_1019A1DE0 = (uint64_t)v37;
    BOOL v38 = operator new(0x20uLL);
    v38[1] = 0LL;
    v38[2] = 0LL;
    void *v38 = off_101875D20;
    *((_DWORD *)v38 + 6) = 0;
    qword_1019A1DE8 = (uint64_t)v38;
    uint64_t v39 = (char *)operator new(0x18uLL);
    *(void *)uint64_t v39 = off_101875D98;
    v39[8] = 0;
    *(void *)(v39 + 12) = 0LL;
    *((_DWORD *)v39 + 5) = 0;
    qword_1019A1DF0 = (uint64_t)v39;
    int v40 = operator new(0x18uLL);
    v40[1] = 0LL;
    v40[2] = 0LL;
    void *v40 = off_101875E10;
    qword_1019A1DF8 = (uint64_t)v40;
    BOOL v41 = (char *)operator new(0x18uLL);
    *(void *)BOOL v41 = off_101875E88;
    *((_WORD *)v41 + 4) = 0;
    *(void *)(v41 + 12) = 0LL;
    qword_1019A1E00 = (uint64_t)v41;
    uint64_t v42 = (char *)operator new(0x18uLL);
    *(void *)uint64_t v42 = off_101875F00;
    v42[8] = 0;
    *(void *)(v42 + 12) = 0LL;
    qword_1019A1E08 = (uint64_t)v42;
    uint64_t v43 = operator new(0x18uLL);
    *uint64_t v43 = off_101875F78;
    v43[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v43[2] = 0LL;
    qword_1019A1E10 = (uint64_t)v43;
    BOOL v44 = operator new(0x18uLL);
    *BOOL v44 = off_101875FF0;
    v44[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v44[2] = 0LL;
    qword_1019A1E18 = (uint64_t)v44;
    uint64_t v45 = operator new(0x30uLL);
    v45[1] = 0LL;
    v45[2] = 0LL;
    *uint64_t v45 = off_101876158;
    *((_DWORD *)v45 + 6) = 0;
    v45[4] = 0LL;
    v45[5] = 0LL;
    qword_1019A1E20 = (uint64_t)v45;
    int v46 = (char *)operator new(0x18uLL);
    *(void *)int v46 = off_101876068;
    *((void *)v46 + 2) = 0LL;
    *((_DWORD *)v46 + 2) = 0;
    *(_DWORD *)(v46 + 11) = 0;
    qword_1019A1E28 = (uint64_t)v46;
    uint64_t v47 = operator new(0x28uLL);
    *uint64_t v47 = off_1018760E0;
    v47[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v47[3] = 0LL;
    v47[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    *((_DWORD *)v47 + 8) = 0;
    qword_1019A1E30 = (uint64_t)v47;
    unint64_t v48 = operator new(0x18uLL);
    *unint64_t v48 = off_1018761D0;
    v48[1] = 0LL;
    *((_DWORD *)v48 + 4) = 0;
    qword_1019A1E38 = (uint64_t)v48;
    uint64_t v49 = (char *)operator new(0x40uLL);
    *(void *)uint64_t v49 = off_101876428;
    v49[8] = 0;
    *(_OWORD *)(v49 + 12) = 0u;
    *(_OWORD *)(v49 + sub_100231C10(v1 + 28) = 0u;
    *(_OWORD *)(v49 + 44) = 0u;
    qword_1019A1E40 = (uint64_t)v49;
    uint64_t v50 = (char *)operator new(0x38uLL);
    *(void *)uint64_t v50 = &off_101876248;
    *(_OWORD *)(v50 + 8) = 0u;
    *(_OWORD *)(v50 + 24) = 0u;
    *(_OWORD *)(v50 + 40) = 0u;
    qword_1019A1E48 = (uint64_t)v50;
    __int128 v51 = (char *)operator new(0x28uLL);
    *(void *)__int128 v51 = &off_1018762C0;
    *(_OWORD *)(v51 + 8) = 0u;
    *(_OWORD *)(v51 + 24) = 0u;
    qword_1019A1E50 = (uint64_t)v51;
    int v52 = operator new(0x18uLL);
    v52[1] = 0LL;
    v52[2] = 0LL;
    *int v52 = off_101876338;
    qword_1019A1E58 = (uint64_t)v52;
    uint64_t v53 = operator new(0x40uLL);
    *uint64_t v53 = off_1018763B0;
    v53[1] = 0LL;
    v53[2] = 0LL;
    v53[3] = 0LL;
    *((_BYTE *)v53 + 32) = 0;
    *(void *)((char *)v53 + 36) = 0LL;
    *(void *)((char *)v53 + 52) = 0LL;
    *(void *)((char *)v53 + 44) = 0LL;
    qword_1019A1E60 = (uint64_t)v53;
    __int16 v54 = operator new(0x18uLL);
    *__int16 v54 = off_1018764A0;
    v54[1] = 0LL;
    *((_DWORD *)v54 + 4) = 0;
    qword_1019A1E68 = (uint64_t)v54;
    int v55 = (char *)operator new(0x18uLL);
    *(void *)int v55 = off_101876518;
    v55[8] = 0;
    *(void *)(v55 + 12) = 0LL;
    qword_1019A1E70 = (uint64_t)v55;
    int v56 = operator new(0x20uLL);
    v56[1] = 0LL;
    v56[2] = 0LL;
    *int v56 = off_101876590;
    *((_DWORD *)v56 + 6) = 0;
    qword_1019A1E78 = (uint64_t)v56;
    __n128 v57 = operator new(0x28uLL);
    *__n128 v57 = off_101876608;
    v57[1] = 0LL;
    v57[2] = 0LL;
    v57[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v57[4] = 0LL;
    qword_1019A1E80 = (uint64_t)v57;
    __int16 v58 = operator new(0x38uLL);
    void *v58 = off_101876680;
    v58[1] = 0LL;
    v58[6] = 0LL;
    v58[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v58[3] = 0LL;
    v58[4] = 0LL;
    v58[5] = 0LL;
    qword_1019A1E88 = (uint64_t)v58;
    int v59 = (char *)operator new(0x20uLL);
    *(void *)(v59 + 20) = 0LL;
    *(void *)int v59 = off_1018766F8;
    *((void *)v59 + 1) = 0LL;
    *(_DWORD *)(v59 + 15) = 0;
    qword_1019A1E90 = (uint64_t)v59;
    sub_100BB1968(qword_1019A1D38, v60, v61, v62);
    uint64_t v66 = sub_100BB1C7C((void *)qword_1019A1D48, v63, v64, v65);
    uint64_t v67 = qword_1019A1D78;
    *(void *)(v67 + 8) = sub_100501444(v66, v68, v69, v70);
    uint64_t v71 = qword_1019A1E20;
    uint64_t v72 = qword_1019A1E28;
    if (!qword_1019A1E28)
    {
      ((void (*)(void))sub_100BB1090)();
      uint64_t v72 = qword_1019A1E28;
    }

    *(void *)(v71 + 32) = v72;
    uint64_t v73 = sub_100BB1DA0(qword_1019A1E40);
    v75 = (void *)qword_1019A1E88;
    uint64_t v76 = qword_1019A1D38;
    if (!qword_1019A1D38)
    {
      uint64_t v73 = sub_100BB1090(v73);
      uint64_t v76 = qword_1019A1D38;
    }

    v75[3] = v76;
    uint64_t v77 = qword_1019A1D40;
    if (!qword_1019A1D40)
    {
      uint64_t v73 = sub_100BB1090(v73);
      uint64_t v77 = qword_1019A1D40;
    }

    v75[4] = v77;
    uint64_t v78 = qword_1019A1D48;
    if (!qword_1019A1D48)
    {
      sub_100BB1090(v73);
      uint64_t v78 = qword_1019A1D48;
    }

    v75[5] = v78;
    wireless_diagnostics::google::protobuf::internal::OnShutdown( (wireless_diagnostics::google::protobuf::internal *)sub_100BB0C5C,  v74);
  }

void *sub_100BB1944(void *result)
{
  *uint64_t result = off_101876680;
  result[1] = 0LL;
  result[5] = 0LL;
  result[6] = 0LL;
  result[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[3] = 0LL;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BB1968(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v4 = (void *)a1;
  uint64_t v5 = qword_1019A1D78;
  if (!qword_1019A1D78)
  {
    a1 = sub_100BB1090();
    uint64_t v5 = qword_1019A1D78;
  }

  v4[3] = v5;
  uint64_t v6 = qword_1019A1D80;
  if (!qword_1019A1D80)
  {
    a1 = sub_100BB1090();
    uint64_t v6 = qword_1019A1D80;
  }

  v4[4] = v6;
  uint64_t v7 = qword_1019A1D98;
  if (!qword_1019A1D98)
  {
    a1 = sub_100BB1090();
    uint64_t v7 = qword_1019A1D98;
  }

  void v4[5] = v7;
  uint64_t v8 = qword_1019A1DA0;
  if (!qword_1019A1DA0)
  {
    a1 = sub_100BB1090();
    uint64_t v8 = qword_1019A1DA0;
  }

  v4[6] = v8;
  uint64_t v9 = qword_1019A1DA8;
  if (!qword_1019A1DA8)
  {
    a1 = sub_100BB1090();
    uint64_t v9 = qword_1019A1DA8;
  }

  v4[7] = v9;
  uint64_t v10 = qword_1019A1DB0;
  if (!qword_1019A1DB0)
  {
    a1 = sub_100BB1090();
    uint64_t v10 = qword_1019A1DB0;
  }

  v4[8] = v10;
  uint64_t v11 = qword_1019A1DB8;
  if (!qword_1019A1DB8)
  {
    a1 = sub_100BB1090();
    uint64_t v11 = qword_1019A1DB8;
  }

  v4[9] = v11;
  uint64_t v12 = qword_1019A1DC0;
  if (!qword_1019A1DC0)
  {
    a1 = sub_100BB1090();
    uint64_t v12 = qword_1019A1DC0;
  }

  v4[10] = v12;
  uint64_t v13 = qword_1019A1DC8;
  if (!qword_1019A1DC8)
  {
    a1 = sub_100BB1090();
    uint64_t v13 = qword_1019A1DC8;
  }

  v4[11] = v13;
  uint64_t v14 = qword_1019A1DD0;
  if (!qword_1019A1DD0)
  {
    a1 = sub_100BB1090();
    uint64_t v14 = qword_1019A1DD0;
  }

  v4[12] = v14;
  uint64_t v15 = qword_1019A1DD8;
  if (!qword_1019A1DD8)
  {
    a1 = sub_100BB1090();
    uint64_t v15 = qword_1019A1DD8;
  }

  v4[13] = v15;
  uint64_t v16 = qword_1019A1DE0;
  if (!qword_1019A1DE0)
  {
    a1 = sub_100BB1090();
    uint64_t v16 = qword_1019A1DE0;
  }

  v4[14] = v16;
  uint64_t v17 = qword_1019A1D60;
  if (!qword_1019A1D60)
  {
    a1 = sub_100BB1090();
    uint64_t v17 = qword_1019A1D60;
  }

  v4[15] = v17;
  uint64_t v18 = qword_1019A1D68;
  if (!qword_1019A1D68)
  {
    a1 = sub_100BB1090();
    uint64_t v18 = qword_1019A1D68;
  }

  v4[16] = v18;
  uint64_t v19 = qword_1019A1D70;
  if (!qword_1019A1D70)
  {
    a1 = sub_100BB1090();
    uint64_t v19 = qword_1019A1D70;
  }

  v4[17] = v19;
  uint64_t v20 = qword_1019A1D88;
  if (!qword_1019A1D88)
  {
    a1 = sub_100BB1090();
    uint64_t v20 = qword_1019A1D88;
  }

  v4[18] = v20;
  uint64_t v21 = qword_1019A1D58;
  if (!qword_1019A1D58)
  {
    a1 = sub_100BB1090();
    uint64_t v21 = qword_1019A1D58;
  }

  v4[19] = v21;
  uint64_t v22 = qword_1019A1D90;
  if (!qword_1019A1D90)
  {
    a1 = sub_100BB1090();
    uint64_t v22 = qword_1019A1D90;
  }

  v4[20] = v22;
  uint64_t v23 = qword_1019A1DF0;
  if (!qword_1019A1DF0)
  {
    a1 = sub_100BB1090();
    uint64_t v23 = qword_1019A1DF0;
  }

  v4[21] = v23;
  uint64_t v24 = qword_1019A1DF8;
  if (!qword_1019A1DF8)
  {
    a1 = sub_100BB1090();
    uint64_t v24 = qword_1019A1DF8;
  }

  v4[22] = v24;
  uint64_t v25 = qword_1019A1E08;
  if (!qword_1019A1E08)
  {
    a1 = sub_100BB1090();
    uint64_t v25 = qword_1019A1E08;
  }

  v4[23] = v25;
  uint64_t v26 = qword_1019A1E10;
  if (!qword_1019A1E10)
  {
    a1 = sub_100BB1090();
    uint64_t v26 = qword_1019A1E10;
  }

  v4[24] = v26;
  uint64_t v27 = qword_1019A1E18;
  if (!qword_1019A1E18)
  {
    a1 = sub_100BB1090();
    uint64_t v27 = qword_1019A1E18;
  }

  v4[25] = v27;
  uint64_t v28 = qword_1019A1E40;
  if (!qword_1019A1E40)
  {
    a1 = sub_100BB1090();
    uint64_t v28 = qword_1019A1E40;
  }

  v4[26] = v28;
  uint64_t v29 = qword_1019A1E90;
  if (!qword_1019A1E90)
  {
    a1 = sub_100BB1090();
    uint64_t v29 = qword_1019A1E90;
  }

  v4[27] = v29;
  uint64_t v30 = qword_1019A1E68;
  if (!qword_1019A1E68)
  {
    a1 = sub_100BB1090();
    uint64_t v30 = qword_1019A1E68;
  }

  v4[28] = v30;
  uint64_t v31 = qword_1019A1DE8;
  if (!qword_1019A1DE8)
  {
    a1 = sub_100BB1090();
    uint64_t v31 = qword_1019A1DE8;
  }

  v4[29] = v31;
  uint64_t v32 = qword_1019A1E00;
  if (!qword_1019A1E00)
  {
    a1 = sub_100BB1090();
    uint64_t v32 = qword_1019A1E00;
  }

  v4[30] = v32;
  uint64_t v33 = sub_10064227C(a1, a2, a3, a4);
  v4[31] = v33;
  uint64_t v37 = sub_10062060C(v33, v34, v35, v36);
  v4[33] = v37;
  uint64_t v41 = sub_10063CE7C(v37, v38, v39, v40);
  v4[34] = v41;
  uint64_t v45 = sub_10063DB9C(v41, v42, v43, v44);
  v4[35] = v45;
  uint64_t v49 = sub_100640D78(v45, v46, v47, v48);
  v4[36] = v49;
  uint64_t v53 = sub_100643AC0(v49, v50, v51, v52);
  v4[37] = v53;
  uint64_t v57 = sub_100644A04(v53, v54, v55, v56);
  v4[39] = v57;
  uint64_t v61 = sub_1006419B0(v57, v58, v59, v60);
  v4[40] = v61;
  uint64_t v65 = sub_1006187D8(v61, v62, v63, v64);
  v4[43] = v65;
  uint64_t v69 = sub_10061CD80(v65, v66, v67, v68);
  v4[47] = v69;
  uint64_t result = sub_100619EC8(v69, v70, v71, v72);
  v4[48] = result;
  return result;
}

uint64_t sub_100BB1C7C(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v5 = sub_100502FF4((uint64_t)a1, a2, a3, a4);
  a1[3] = v5;
  uint64_t v9 = sub_100A59CF4(v5, v6, v7, v8);
  a1[4] = v9;
  uint64_t v13 = sub_100505BB0(v9, v10, v11, v12);
  a1[5] = v13;
  uint64_t v17 = qword_1019A1D50;
  if (!qword_1019A1D50)
  {
    uint64_t v13 = sub_100BB1090();
    uint64_t v17 = qword_1019A1D50;
  }

  a1[6] = v17;
  uint64_t v18 = sub_1005043F0(v13, v14, v15, v16);
  a1[7] = v18;
  uint64_t v22 = qword_1019A1E20;
  if (!qword_1019A1E20)
  {
    uint64_t v18 = sub_100BB1090();
    uint64_t v22 = qword_1019A1E20;
  }

  a1[8] = v22;
  uint64_t v23 = qword_1019A1E38;
  if (!qword_1019A1E38)
  {
    uint64_t v18 = sub_100BB1090();
    uint64_t v23 = qword_1019A1E38;
  }

  a1[9] = v23;
  uint64_t v24 = sub_1005065E0(v18, v19, v20, v21);
  a1[10] = v24;
  uint64_t v28 = sub_100506168(v24, v25, v26, v27);
  a1[11] = v28;
  uint64_t v32 = qword_1019A1E70;
  if (!qword_1019A1E70)
  {
    uint64_t v28 = sub_100BB1090();
    uint64_t v32 = qword_1019A1E70;
  }

  a1[13] = v32;
  uint64_t v33 = qword_1019A1E78;
  if (!qword_1019A1E78)
  {
    uint64_t v28 = sub_100BB1090();
    uint64_t v33 = qword_1019A1E78;
  }

  a1[14] = v33;
  uint64_t v34 = qword_1019A1E80;
  if (!qword_1019A1E80)
  {
    uint64_t v28 = sub_100BB1090();
    uint64_t v34 = qword_1019A1E80;
  }

  a1[15] = v34;
  uint64_t v35 = sub_1006151DC(v28, v29, v30, v31);
  a1[16] = v35;
  uint64_t v39 = sub_10062EE2C(v35, v36, v37, v38);
  a1[18] = v39;
  uint64_t v43 = sub_100633C94(v39, v40, v41, v42);
  a1[19] = v43;
  uint64_t v47 = sub_100639148(v43, v44, v45, v46);
  a1[20] = v47;
  uint64_t v51 = sub_100644610(v47, v48, v49, v50);
  a1[21] = v51;
  uint64_t v55 = sub_1006479E0(v51, v52, v53, v54);
  a1[22] = v55;
  uint64_t v59 = sub_10061DBE0(v55, v56, v57, v58);
  a1[23] = v59;
  uint64_t v63 = sub_10061C0A4(v59, v60, v61, v62);
  a1[24] = v63;
  uint64_t result = sub_100619214(v63, v64, v65, v66);
  a1[26] = result;
  return result;
}

uint64_t sub_100BB1DA0(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = qword_1019A1E60;
  if (!qword_1019A1E60)
  {
    uint64_t result = sub_100BB1090();
    uint64_t v2 = qword_1019A1E60;
  }

  _DWORD v1[2] = v2;
  uint64_t v3 = qword_1019A1E48;
  if (!qword_1019A1E48)
  {
    uint64_t result = sub_100BB1090();
    uint64_t v3 = qword_1019A1E48;
  }

  v1[3] = v3;
  uint64_t v4 = qword_1019A1E50;
  if (!qword_1019A1E50)
  {
    uint64_t result = sub_100BB1090();
    uint64_t v4 = qword_1019A1E50;
  }

  v1[4] = v4;
  uint64_t v5 = qword_1019A1E58;
  if (!qword_1019A1E58)
  {
    uint64_t result = sub_100BB1090();
    uint64_t v5 = qword_1019A1E58;
  }

  _OWORD v1[5] = v5;
  return result;
}

uint64_t sub_100BB1E1C(int a1)
{
  uint64_t result = 1LL;
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
      return result;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void sub_100BB1E54(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v97,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  2358LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v97,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v96, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v97);
  }

  int v5 = *(_DWORD *)(a2 + 336);
  if (v5)
  {
    sub_10004AAFC(a1 + 328, *(_DWORD *)(a1 + 336) + v5);
    memcpy( (void *)(*(void *)(a1 + 328) + 4LL * *(int *)(a1 + 336)),  *(const void **)(a2 + 328),  4LL * *(int *)(a2 + 336));
    *(_DWORD *)(a1 + 336) += *(_DWORD *)(a2 + 336);
  }

  int v6 = *(_DWORD *)(a2 + 360);
  if (v6)
  {
    sub_10004AAFC(a1 + 352, *(_DWORD *)(a1 + 360) + v6);
    memcpy( (void *)(*(void *)(a1 + 352) + 4LL * *(int *)(a1 + 360)),  *(const void **)(a2 + 352),  4LL * *(int *)(a2 + 360));
    *(_DWORD *)(a1 + 360) += *(_DWORD *)(a2 + 360);
  }

  unsigned int v7 = *(_DWORD *)(a2 + 396);
  if (!(_BYTE)v7) {
    goto LABEL_46;
  }
  if ((v7 & 1) != 0)
  {
    uint64_t v8 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 396) |= 1u;
    *(void *)(a1 + 8) = v8;
    unsigned int v7 = *(_DWORD *)(a2 + 396);
    if ((v7 & 2) == 0)
    {
LABEL_10:
      if ((v7 & 4) == 0) {
        goto LABEL_11;
      }
      goto LABEL_19;
    }
  }

  else if ((v7 & 2) == 0)
  {
    goto LABEL_10;
  }

  int v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 396) |= 2u;
  *(_DWORD *)(a1 + 16) = v9;
  unsigned int v7 = *(_DWORD *)(a2 + 396);
  if ((v7 & 4) == 0)
  {
LABEL_11:
    if ((v7 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_21;
  }

LABEL_181:
  *(_DWORD *)(a1 + 396) |= 0x20000000u;
  uint64_t v63 = *(void **)(a1 + 232);
  if (!v63)
  {
    uint64_t v63 = operator new(0x20uLL);
    v63[1] = 0LL;
    v63[2] = 0LL;
    *uint64_t v63 = off_101875D20;
    *((_DWORD *)v63 + 6) = 0;
    *(void *)(a1 + 232) = v63;
  }

  uint64_t v64 = *(void *)(a2 + 232);
  if (!v64) {
    uint64_t v64 = *(void *)(qword_1019A1D38 + 232);
  }
  sub_100BBA110((uint64_t)v63, v64);
  unsigned int v7 = *(_DWORD *)(a2 + 396);
  if ((v7 & 0x40000000) == 0)
  {
LABEL_154:
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_196;
    }
    goto LABEL_191;
  }

  *(_BYTE *)(a2 + 1) = 1;
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_101879FD0);
  }
  uint64_t v59 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v60 = *(void *)(a1 + 8);
    *(_DWORD *)uint64_t buf = 136315394;
    v192 = "alertCanceledBecauseActive";
    v193 = 2048;
    v194 = v60;
    _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "CLFallImpactMetrics: Setting %s for impact at %f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_101879FD0);
    }
    v153 = *(void *)(a1 + 8);
    v187 = 136315394;
    v188 = "alertCanceledBecauseActive";
    v189 = 2048;
    v190 = v153;
    LODWORD(v186) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFallImpactMetrics: Setting %s for impact at %f",  (const char *)&v187,  v186);
    v155 = (uint8_t *)v154;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallImpactMetrics::processImpactCancelReason(ImpactContext &, ImpactCandidateEvent &, AlertCandidateEvent & , SOSCandidateEvent &) const",  "%s\n",  v154);
    if (v155 != buf) {
      free(v155);
    }
  }

  a4[17] = 1;
  int v10 = *(void *)(a1 + 24);
  if ((v10 & 0x4000000000LL) == 0)
  {
LABEL_27:
    if ((v10 & 0x4000000000000LL) == 0) {
      goto LABEL_28;
    }
    goto LABEL_193;
  }

            PB::Reader::recallMark(this, v171);
          }

          else
          {
            v128 = *(char **)(a1 + 40);
            v127 = *(void *)(a1 + 48);
            if ((unint64_t)v128 >= v127)
            {
              v153 = (char *)*v10;
              v154 = (v128 - (_BYTE *)*v10) >> 2;
              v155 = v154 + 1;
              if ((unint64_t)(v154 + 1) >> 62) {
LABEL_264:
              }
                sub_100007008();
              v156 = v127 - (void)v153;
              if (v156 >> 1 > v155) {
                v155 = v156 >> 1;
              }
              else {
                v157 = v155;
              }
              if (v157)
              {
                v158 = (char *)sub_10000956C(v170, v157);
                v153 = *(char **)(a1 + 32);
                v128 = *(char **)(a1 + 40);
              }

              else
              {
                v158 = 0LL;
              }

              v165 = &v158[4 * v154];
              *(_DWORD *)v165 = 0;
              v126 = v165 + 4;
              while (v128 != v153)
              {
                v166 = *((_DWORD *)v128 - 1);
                v128 -= 4;
                *((_DWORD *)v165 - 1) = v166;
                v165 -= 4;
              }

              *(void *)(a1 + 32) = v165;
              *(void *)(a1 + 40) = v126;
              *(void *)(a1 + memset(v19, 0, 48) = &v158[4 * v157];
              if (v153) {
                operator delete(v153);
              }
            }

            else
            {
              *(_DWORD *)v128 = 0;
              v126 = v128 + 4;
            }

            *(void *)(a1 + 40) = v126;
LABEL_246:
            v167 = *((void *)this + 1);
            if (v167 <= 0xFFFFFFFFFFFFFFFBLL && v167 + 4 <= *((void *)this + 2))
            {
              *(v126 - 1) = *(_DWORD *)(*(void *)this + v167);
LABEL_250:
              v162 = *((void *)this + 1) + 4LL;
LABEL_251:
              *((void *)this + 1) = v162;
            }

            else
            {
LABEL_248:
              *((_BYTE *)this + 24) = 1;
            }
          }

  uint64_t result = *(float *)(a2 + 88);
  v5 |= 0x1000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(float *)(a1 + 88) = result;
  uint64_t v4 = *v3;
  unsigned int v7 = *(void *)(a2 + 364);
  if ((*v3 & 0x100000000000LL) == 0)
  {
LABEL_76:
    if ((v4 & 0x100000000000000LL) == 0) {
      goto LABEL_77;
    }
    goto LABEL_183;
  }

  PB::TextFormatter::format(this, "shouldDeescalateBecauseOfMAPFPCondition", *(_BYTE *)(a1 + 343));
  unsigned int v7 = *v5;
  int v6 = *(void *)(a1 + 364);
  if ((v6 & 0x200000000LL) == 0)
  {
LABEL_80:
    if ((v6 & 0x400000000LL) == 0) {
      goto LABEL_81;
    }
    goto LABEL_183;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 88), 0x25Bu);
  int v5 = *v4;
  int v6 = v4[1];
  if ((*v4 & 0x100000000000LL) == 0)
  {
LABEL_76:
    if ((v5 & 0x100000000000000LL) == 0) {
      goto LABEL_77;
    }
    goto LABEL_183;
  }

LABEL_196:
  int v69 = *(_DWORD *)(a2 + 400);
  if ((_BYTE)v69)
  {
    if ((v69 & 1) != 0)
    {
      uint64_t v70 = *(const std::string **)(a2 + 256);
      *(_DWORD *)(a1 + 400) |= 1u;
      uint64_t v71 = *(std::string **)(a1 + 256);
      if (v71 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        uint64_t v71 = (std::string *)operator new(0x18uLL);
        v71->__r_.__value_.__l.__size_ = 0LL;
        v71->__r_.__value_.__l.__cap_ = 0LL;
        v71->__r_.__value_.__r.__words[0] = 0LL;
        *(void *)(a1 + 256) = v71;
      }

      std::string::operator=(v71, v70);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 2) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 2u;
      uint64_t v72 = *(_DWORD **)(a1 + 264);
      if (!v72)
      {
        uint64_t v72 = operator new(0x58uLL);
        sub_100614600((uint64_t)v72);
        *(void *)(a1 + 264) = v72;
      }

      uint64_t v73 = *(_DWORD **)(a2 + 264);
      if (!v73) {
        uint64_t v73 = *(_DWORD **)(qword_1019A1D38 + 264);
      }
      sub_10062031C(v72, v73);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 4) != 0)
    {
      int v74 = *(_DWORD *)(a2 + 304);
      *(_DWORD *)(a1 + 400) |= 4u;
      *(_DWORD *)(a1 + 304) = v74;
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 8) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 8u;
      v75 = *(_DWORD **)(a1 + 272);
      if (!v75)
      {
        v75 = operator new(0x48uLL);
        sub_100614690((uint64_t)v75);
        *(void *)(a1 + 272) = v75;
      }

      uint64_t v76 = *(void *)(a2 + 272);
      if (!v76) {
        uint64_t v76 = *(void *)(qword_1019A1D38 + 272);
      }
      sub_10063CBBC(v75, v76);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 0x10) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x10u;
      uint64_t v77 = *(_DWORD **)(a1 + 280);
      if (!v77)
      {
        uint64_t v77 = operator new(0x48uLL);
        sub_1006146B8((uint64_t)v77);
        *(void *)(a1 + 280) = v77;
      }

      uint64_t v78 = *(_DWORD **)(a2 + 280);
      if (!v78) {
        uint64_t v78 = *(_DWORD **)(qword_1019A1D38 + 280);
      }
      sub_10063D900(v77, v78);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 0x20) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x20u;
      v79 = *(_DWORD **)(a1 + 288);
      if (!v79)
      {
        v79 = operator new(0x38uLL);
        sub_1006146DC((uint64_t)v79);
        *(void *)(a1 + 288) = v79;
      }

      uint64_t v80 = *(void *)(a2 + 288);
      if (!v80) {
        uint64_t v80 = *(void *)(qword_1019A1D38 + 288);
      }
      sub_100640B28(v79, v80);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x40u;
      v81 = *(void **)(a1 + 296);
      if (!v81)
      {
        v81 = operator new(0x48uLL);
        sub_100614734((uint64_t)v81);
        *(void *)(a1 + 296) = v81;
      }

      uint64_t v82 = *(void *)(a2 + 296);
      if (!v82) {
        uint64_t v82 = *(void *)(qword_1019A1D38 + 296);
      }
      sub_1006437B8((uint64_t)v81, v82);
      int v69 = *(_DWORD *)(a2 + 400);
    }

    if ((v69 & 0x80) != 0)
    {
      *(_DWORD *)(a1 + 400) |= 0x80u;
      uint64_t v83 = *(void **)(a1 + 312);
      if (!v83)
      {
        uint64_t v83 = operator new(0x20uLL);
        sub_100614770(v83);
        *(void *)(a1 + 312) = v83;
      }

      uint64_t v84 = *(void *)(a2 + 312);
      if (!v84) {
        uint64_t v84 = *(void *)(qword_1019A1D38 + 312);
      }
      sub_100644868((uint64_t)v83, v84);
      int v69 = *(_DWORD *)(a2 + 400);
    }
  }

  if ((v69 & 0xFF00) == 0) {
    goto LABEL_256;
  }
  if ((v69 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 400) |= 0x100u;
    v85 = *(void **)(a1 + 320);
    if (!v85)
    {
      v85 = operator new(0x20uLL);
      sub_1006146FC(v85);
      *(void *)(a1 + 320) = v85;
    }

    uint64_t v86 = *(void *)(a2 + 320);
    if (!v86) {
      uint64_t v86 = *(void *)(qword_1019A1D38 + 320);
    }
    sub_1006417C4((uint64_t)v85, v86);
    int v69 = *(_DWORD *)(a2 + 400);
  }

  if ((v69 & 0x400) != 0)
  {
    *(_DWORD *)(a1 + 400) |= 0x400u;
    v87 = *(_DWORD **)(a1 + 344);
    if (!v87)
    {
      v87 = operator new(0x60uLL);
      sub_100614520((uint64_t)v87);
      *(void *)(a1 + 344) = v87;
    }

    uint64_t v88 = *(void *)(a2 + 344);
    if (!v88) {
      uint64_t v88 = *(void *)(qword_1019A1D38 + 344);
    }
    sub_100618458(v87, v88);
    int v69 = *(_DWORD *)(a2 + 400);
  }

  if ((v69 & 0x800) != 0)
  {
    int v89 = *(_DWORD *)(a2 + 308);
    *(_DWORD *)(a1 + 400) |= 0x800u;
    *(_DWORD *)(a1 + 308) = v89;
    int v69 = *(_DWORD *)(a2 + 400);
    if ((v69 & 0x2000) == 0)
    {
LABEL_254:
      if ((v69 & 0x4000) == 0) {
        goto LABEL_255;
      }
      goto LABEL_260;
    }
  }

  else if ((v69 & 0x2000) == 0)
  {
    goto LABEL_254;
  }

  char v90 = *(_BYTE *)(a2 + 368);
  *(_DWORD *)(a1 + 400) |= 0x2000u;
  *(_BYTE *)(a1 + 368) = v90;
  int v69 = *(_DWORD *)(a2 + 400);
  if ((v69 & 0x4000) != 0)
  {
LABEL_260:
    int v91 = *(_DWORD *)(a2 + 372);
    *(_DWORD *)(a1 + 400) |= 0x4000u;
    *(_DWORD *)(a1 + 372) = v91;
    int v69 = *(_DWORD *)(a2 + 400);
    if ((v69 & 0x8000) != 0) {
      goto LABEL_261;
    }
LABEL_256:
    if ((v69 & 0x10000) == 0) {
      return;
    }
    goto LABEL_266;
  }

  v99 = *(void *)(a1 + 208);
  if (!v99) {
    v99 = *(void *)(qword_1019A1D38 + 208);
  }
  v100 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BC84E0(v99, a2);
  v101 = (int)v100;
  else {
    v102 = 1;
  }
  v4 += v101 + v102 + 2;
  uint64_t v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x8000000) == 0)
  {
LABEL_179:
    if ((v3 & 0x10000000) == 0) {
      goto LABEL_180;
    }
    goto LABEL_208;
  }

      dispatch_once(&qword_101934830, &stru_101879178);
      goto LABEL_132;
    }

    uint64_t v18 = (uint64_t)(v9 + 4);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    uint64_t v19 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "TileMgr, tileDecompressionCompleted, nullptr in fTilesDownload, #CloneMe",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101879158);
      }
      *(_WORD *)__int128 __p = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "TileMgr, tileDecompressionCompleted, nullptr in fTilesDownload, #CloneMe",  __p,  2);
      v107 = (char *)v106;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::tileDecompressionCompleted(CLFileDownload *, BOOL, void *, CFAbsoluteTime)",  "%s\n",  v106);
      if (v107 != buf) {
        free(v107);
      }
    }

    sub_1000087E8((uint64_t **)(a1 + 112), v10);
    sub_1006035CC(v18);
    operator delete(v10);
    uint64_t v20 = *(void **)(a1 + 40);
    v136[0] = _NSConcreteStackBlock;
    v136[1] = 3221225472LL;
    v136[2] = sub_100C2F5CC;
    v136[3] = &unk_101830538;
    v136[4] = a1;
    *(double *)&v136[5] = a4;
    [v20 async:v136];
  }

  v123 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    v124 = *(void *)(a1 + 576);
    if (v124) {
      v124 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v124 + 8) - *(void *)v124) >> 1);
    }
    v125 = *(void *)(a1 + 608);
    *(_DWORD *)uint64_t buf = 134218240;
    *(void *)&uint8_t buf[4] = v124;
    v182 = 2048;
    *(void *)v183 = v125;
    _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_DEBUG,  "TILE: traverseTileFile, finished traversing, file, index entries, %lu, apEntries, %lu",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    v135 = *(void *)(a1 + 576);
    if (v135) {
      v135 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v135 + 8) - *(void *)v135) >> 1);
    }
    v136 = *(void *)(a1 + 608);
    v172 = 134218240;
    v173 = v135;
    v174 = 2048;
    *(void *)v175 = v136;
    LODWORD(v153) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: traverseTileFile, finished traversing, file, index entries, %lu, apEntries, %lu",  &v172,  v153);
    v138 = (char *)v137;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLWifiTileFile::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v137);
    if (v138 != buf) {
      free(v138);
    }
  }

  uint64_t v76 = *(_BYTE *)(a2 + 347);
  v6 |= 0x1000000000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 347) = v76;
  uint64_t v4 = *v3;
  unsigned int v7 = *(void *)(a2 + 364);
  if ((*v3 & 0x80000000) == 0)
  {
LABEL_91:
    if ((v4 & 0x20000000) == 0) {
      goto LABEL_92;
    }
    goto LABEL_198;
  }

  PB::TextFormatter::format(this, "stationaryCountMissingAsNoOpThreshold", *(_DWORD *)(a1 + 260));
  unsigned int v7 = *v5;
  if ((*v5 & 0x100000000000000LL) == 0)
  {
LABEL_95:
    if ((v7 & 0x40) == 0) {
      goto LABEL_96;
    }
    goto LABEL_198;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 347), 0x44Fu);
  int v5 = *v4;
  int v6 = v4[1];
  if ((*v4 & 0x80000000) == 0)
  {
LABEL_91:
    if ((v5 & 0x20000000) == 0) {
      goto LABEL_92;
    }
    goto LABEL_198;
  }

          *(_DWORD *)(a1 + 80) = v80;
          goto LABEL_224;
        case 7u:
          *(_BYTE *)(a1 + 104) |= 0x10u;
          uint64_t v83 = *((void *)this + 1);
          uint64_t v84 = *((void *)this + 2);
          v85 = *(void *)this;
          if (v83 <= 0xFFFFFFFFFFFFFFF5LL && v83 + 10 <= v84)
          {
            uint64_t v86 = 0;
            v87 = 0;
            uint64_t v88 = 0LL;
            do
            {
              int v89 = v83 + 1;
              *((void *)this + 1) = v83 + 1;
              char v90 = *(_BYTE *)(v85 + v83);
              v88 |= (unint64_t)(v90 & 0x7F) << v86;
              if ((v90 & 0x80) == 0) {
                goto LABEL_199;
              }
              v86 += 7;
              uint64_t v83 = v89;
              uint64_t v21 = v87++ > 8;
            }

            while (!v21);
LABEL_149:
            LODWORD(v88) = 0;
            goto LABEL_199;
          }

          v124 = 0;
          v125 = 0;
          uint64_t v88 = 0LL;
          if (v84 <= v83) {
            uint64_t v84 = *((void *)this + 1);
          }
          while (2)
          {
            if (v84 == v83)
            {
              LODWORD(v88) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              v126 = v83 + 1;
              v127 = *(_BYTE *)(v85 + v83);
              *((void *)this + 1) = v126;
              v88 |= (unint64_t)(v127 & 0x7F) << v124;
              if (v127 < 0)
              {
                v124 += 7;
                uint64_t v83 = v126;
                uint64_t v21 = v125++ > 8;
                if (v21) {
                  goto LABEL_149;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v88) = 0;
              }
            }

            break;
          }

LABEL_255:
  if ((v69 & 0x8000) == 0) {
    goto LABEL_256;
  }
LABEL_261:
  *(_DWORD *)(a1 + 400) |= 0x8000u;
  v92 = *(void **)(a1 + 376);
  if (!v92)
  {
    v92 = operator new(0x38uLL);
    sub_1006145AC(v92);
    *(void *)(a1 + 376) = v92;
  }

  uint64_t v93 = *(void *)(a2 + 376);
  if (!v93) {
    uint64_t v93 = *(void *)(qword_1019A1D38 + 376);
  }
  sub_10061C9F0((uint64_t)v92, v93);
  if ((*(_DWORD *)(a2 + 400) & 0x10000) != 0)
  {
LABEL_266:
    *(_DWORD *)(a1 + 400) |= 0x10000u;
    v94 = *(_DWORD **)(a1 + 384);
    if (!v94)
    {
      v94 = operator new(0x30uLL);
      sub_10061456C((uint64_t)v94);
      *(void *)(a1 + 384) = v94;
    }

    uint64_t v95 = *(void *)(a2 + 384);
    if (!v95) {
      uint64_t v95 = *(void *)(qword_1019A1D38 + 384);
    }
    sub_100619CE8(v94, v95);
  }

          *(_DWORD *)(a1 + 1sub_100231C10(v1 + 28) = v50;
          goto LABEL_243;
        case 0xFu:
          *(void *)(a1 + 164) |= 0x4000000uLL;
          uint64_t v53 = *((void *)this + 1);
          if (v53 > 0xFFFFFFFFFFFFFFFBLL || v53 + 4 > *((void *)this + 2)) {
            goto LABEL_170;
          }
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)this + v53);
          goto LABEL_241;
        case 0x10u:
          *(void *)(a1 + 164) |= 0x20000000uLL;
          uint64_t v54 = *((void *)this + 1);
          if (v54 > 0xFFFFFFFFFFFFFFFBLL || v54 + 4 > *((void *)this + 2)) {
            goto LABEL_170;
          }
          *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(void *)this + v54);
          goto LABEL_241;
        case 0x11u:
          *(void *)(a1 + 164) |= 0x200uLL;
          uint64_t v55 = *((void *)this + 1);
          if (v55 > 0xFFFFFFFFFFFFFFFBLL || v55 + 4 > *((void *)this + 2)) {
            goto LABEL_170;
          }
          *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(void *)this + v55);
          goto LABEL_241;
        case 0x12u:
          *(void *)(a1 + 164) |= 0x1000000uLL;
          uint64_t v56 = *((void *)this + 1);
          if (v56 > 0xFFFFFFFFFFFFFFFBLL || v56 + 4 > *((void *)this + 2)) {
            goto LABEL_170;
          }
          *(_DWORD *)(a1 + 116) = *(_DWORD *)(*(void *)this + v56);
          goto LABEL_241;
        case 0x13u:
          *(void *)(a1 + 164) |= 0x2000uLL;
          uint64_t v57 = *((void *)this + 1);
          uint64_t v58 = *((void *)this + 2);
          uint64_t v59 = *(void *)this;
          if (v57 <= 0xFFFFFFFFFFFFFFF5LL && v57 + 10 <= v58)
          {
            uint64_t v60 = 0;
            uint64_t v61 = 0;
            uint64_t v62 = 0LL;
            do
            {
              uint64_t v63 = v57 + 1;
              *((void *)this + 1) = v57 + 1;
              uint64_t v64 = *(_BYTE *)(v59 + v57);
              v62 |= (unint64_t)(v64 & 0x7F) << v60;
              if ((v64 & 0x80) == 0) {
                goto LABEL_259;
              }
              v60 += 7;
              uint64_t v57 = v63;
              uint64_t v14 = v61++ > 8;
            }

            while (!v14);
LABEL_193:
            LODWORD(v62) = 0;
            goto LABEL_259;
          }

          v140 = 0;
          v141 = 0;
          uint64_t v62 = 0LL;
          if (v58 <= v57) {
            uint64_t v58 = *((void *)this + 1);
          }
          while (2)
          {
            if (v58 == v57)
            {
              LODWORD(v62) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              v142 = v57 + 1;
              v143 = *(_BYTE *)(v59 + v57);
              *((void *)this + 1) = v142;
              v62 |= (unint64_t)(v143 & 0x7F) << v140;
              if (v143 < 0)
              {
                v140 += 7;
                uint64_t v57 = v142;
                uint64_t v14 = v141++ > 8;
                if (v14) {
                  goto LABEL_193;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v62) = 0;
              }
            }

            break;
          }

          *(_DWORD *)(a1 + 160) = v92;
          goto LABEL_296;
        case 7u:
          uint64_t v95 = operator new(0x28uLL);
          sub_101151A08((uint64_t)v95);
          v98 = *(void *)(a1 + 104);
          *(void *)(a1 + 104) = v95;
          if (v98)
          {
            (*(void (**)(uint64_t))(*(void *)v98 + 8LL))(v98);
            uint64_t v95 = *(void **)(a1 + 104);
          }

          goto LABEL_130;
        case 8u:
          uint64_t v95 = operator new(0x28uLL);
          sub_101151A08((uint64_t)v95);
          v99 = *(void *)(a1 + 112);
          *(void *)(a1 + 112) = v95;
          if (v99)
          {
            (*(void (**)(uint64_t))(*(void *)v99 + 8LL))(v99);
            uint64_t v95 = *(void **)(a1 + 112);
          }

        *(_DWORD *)(a1 + 96) = v30;
        goto LABEL_304;
      case 5u:
        *(_DWORD *)(a1 + 152) |= 8u;
        uint64_t v33 = *((void *)this + 1);
        if (v33 > 0xFFFFFFFFFFFFFFF7LL || v33 + 8 > *((void *)this + 2)) {
          goto LABEL_69;
        }
        *(void *)(a1 + 40) = *(void *)(*(void *)this + v33);
        goto LABEL_251;
      case 6u:
        *(_DWORD *)(a1 + 152) |= 0x20u;
        uint64_t v34 = *((void *)this + 1);
        if (v34 > 0xFFFFFFFFFFFFFFF7LL || v34 + 8 > *((void *)this + 2)) {
          goto LABEL_69;
        }
        *(void *)(a1 + 64) = *(void *)(*(void *)this + v34);
        goto LABEL_251;
      case 7u:
        *(_DWORD *)(a1 + 152) |= 0x4000u;
        uint64_t v35 = *((void *)this + 1);
        uint64_t v36 = *((void *)this + 2);
        uint64_t v37 = *(void *)this;
        if (v35 <= 0xFFFFFFFFFFFFFFF5LL && v35 + 10 <= v36)
        {
          uint64_t v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0LL;
          do
          {
            uint64_t v41 = v35 + 1;
            *((void *)this + 1) = v35 + 1;
            uint64_t v42 = *(_BYTE *)(v37 + v35);
            v40 |= (unint64_t)(v42 & 0x7F) << v38;
            if ((v42 & 0x80) == 0) {
              goto LABEL_259;
            }
            v38 += 7;
            uint64_t v35 = v41;
            uint64_t v15 = v39++ > 8;
          }

          while (!v15);
LABEL_168:
          LODWORD(v40) = 0;
          goto LABEL_259;
        }

        v154 = 0;
        v155 = 0;
        uint64_t v40 = 0LL;
        if (v36 <= v35) {
          uint64_t v36 = *((void *)this + 1);
        }
        while (2)
        {
          if (v36 == v35)
          {
            LODWORD(v40) = 0;
            *((_BYTE *)this + 24) = 1;
          }

          else
          {
            v156 = v35 + 1;
            v157 = *(_BYTE *)(v37 + v35);
            *((void *)this + 1) = v156;
            v40 |= (unint64_t)(v157 & 0x7F) << v154;
            if (v157 < 0)
            {
              v154 += 7;
              uint64_t v35 = v156;
              uint64_t v15 = v155++ > 8;
              if (v15) {
                goto LABEL_168;
              }
              continue;
            }

            if (*((_BYTE *)this + 24)) {
              LODWORD(v40) = 0;
            }
          }

          break;
        }

          *(_DWORD *)(a1 + 64) = v34;
          goto LABEL_296;
        case 3u:
          *(_DWORD *)(a1 + 116) |= 0x20u;
          uint64_t v37 = *((void *)this + 1);
          uint64_t v38 = *((void *)this + 2);
          uint64_t v39 = *(void *)this;
          if (v37 <= 0xFFFFFFFFFFFFFFF5LL && v37 + 10 <= v38)
          {
            uint64_t v40 = 0;
            uint64_t v41 = 0;
            uint64_t v42 = 0LL;
            do
            {
              uint64_t v43 = v37 + 1;
              *((void *)this + 1) = v37 + 1;
              uint64_t v44 = *(_BYTE *)(v39 + v37);
              v42 |= (unint64_t)(v44 & 0x7F) << v40;
              if ((v44 & 0x80) == 0) {
                goto LABEL_259;
              }
              v40 += 7;
              uint64_t v37 = v43;
              uint64_t v14 = v41++ > 8;
            }

            while (!v14);
LABEL_167:
            LODWORD(v42) = 0;
            goto LABEL_259;
          }

          v162 = 0;
          v163 = 0;
          uint64_t v42 = 0LL;
          if (v38 <= v37) {
            uint64_t v38 = *((void *)this + 1);
          }
          while (2)
          {
            if (v38 == v37)
            {
              LODWORD(v42) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              v164 = v37 + 1;
              v165 = *(_BYTE *)(v39 + v37);
              *((void *)this + 1) = v164;
              v42 |= (unint64_t)(v165 & 0x7F) << v162;
              if (v165 < 0)
              {
                v162 += 7;
                uint64_t v37 = v164;
                uint64_t v14 = v163++ > 8;
                if (v14) {
                  goto LABEL_167;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v42) = 0;
              }
            }

            break;
          }

void sub_100BB2E14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100BB2E64(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018752D0;
  sub_100BB2EAC(a1);
  uint64_t v2 = (void *)*((void *)a1 + 44);
  if (v2) {
    operator delete[](v2);
  }
  uint64_t v3 = (void *)*((void *)a1 + 41);
  if (v3) {
    operator delete[](v3);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BB2EAC(void *a1)
{
  uint64_t v2 = a1[32];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    operator delete((void *)v2);
  }

  if ((void *)qword_1019A1D38 != a1)
  {
    uint64_t v4 = a1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = a1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    uint64_t v6 = a1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    uint64_t v7 = a1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    uint64_t v8 = a1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    uint64_t v9 = a1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
    uint64_t v10 = a1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
    uint64_t v11 = a1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
    uint64_t v12 = a1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    uint64_t v13 = a1[12];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
    uint64_t v14 = a1[13];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    }
    uint64_t v15 = a1[14];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    uint64_t v16 = a1[15];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    uint64_t v17 = a1[16];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    }
    uint64_t v18 = a1[17];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    uint64_t v19 = a1[18];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    }
    uint64_t v20 = a1[19];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    }
    uint64_t v21 = a1[20];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
    uint64_t v22 = a1[21];
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
    }
    uint64_t v23 = a1[22];
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    }
    uint64_t v24 = a1[23];
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
    uint64_t v25 = a1[24];
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
    }
    uint64_t v26 = a1[25];
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
    }
    uint64_t v27 = a1[26];
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
    }
    uint64_t v28 = a1[27];
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    uint64_t v29 = a1[28];
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
    }
    uint64_t v30 = a1[29];
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
    }
    uint64_t v31 = a1[30];
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8LL))(v31);
    }
    uint64_t v32 = a1[31];
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
    }
    uint64_t v33 = a1[33];
    if (v33) {
      (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
    }
    uint64_t v34 = a1[34];
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 8LL))(v34);
    }
    uint64_t v35 = a1[35];
    if (v35) {
      (*(void (**)(uint64_t))(*(void *)v35 + 8LL))(v35);
    }
    uint64_t v36 = a1[36];
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8LL))(v36);
    }
    uint64_t v37 = a1[37];
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8LL))(v37);
    }
    uint64_t v38 = a1[39];
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8LL))(v38);
    }
    uint64_t v39 = a1[40];
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
    }
    uint64_t v40 = a1[43];
    if (v40) {
      (*(void (**)(uint64_t))(*(void *)v40 + 8LL))(v40);
    }
    uint64_t v41 = a1[47];
    if (v41) {
      (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
    }
    uint64_t v42 = a1[48];
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8LL))(v42);
    }
  }

void sub_100BB3220(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100BB3234()
{
  unsigned __int8 v0 = (char *)operator new(0x198uLL);
  *(void *)unsigned __int8 v0 = off_1018752D0;
  *((void *)v0 + 41) = 0LL;
  *((void *)v0 + 42) = 0LL;
  *((void *)v0 + 45) = 0LL;
  *((_DWORD *)v0 + 98) = 0;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_OWORD *)(v0 + 136) = 0u;
  *(_OWORD *)(v0 + 152) = 0u;
  *(_OWORD *)(v0 + 168) = 0u;
  *(_OWORD *)(v0 + 184) = 0u;
  *(_OWORD *)(v0 + 200) = 0u;
  *(_OWORD *)(v0 + 216) = 0u;
  *(_OWORD *)(v0 + 232) = 0u;
  *((void *)v0 + 31) = 0LL;
  *((void *)v0 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *((void *)v0 + 43) = 0LL;
  *((void *)v0 + 44) = 0LL;
  v0[368] = 0;
  *(void *)(v0 + 396) = 0LL;
  *(_OWORD *)(v0 + 264) = 0u;
  *(_OWORD *)(v0 + 280) = 0u;
  *(_OWORD *)(v0 + 296) = 0u;
  *(_OWORD *)(v0 + 312) = 0u;
  *((_DWORD *)v0 + 97) = 0;
  *(void *)(v0 + 372) = 0LL;
  *(void *)(v0 + 380) = 0LL;
  return result;
}

uint64_t sub_100BB32E0(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = (unsigned int *)(result + 396);
  unsigned int v3 = *(_DWORD *)(result + 396);
  if ((_BYTE)v3)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    if ((v3 & 8) != 0)
    {
      double result = *(void *)(result + 24);
      if (result)
      {
        double result = sub_100BB3978(result);
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 32);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 36))
        {
          *(void *)(v4 + 8) = 0LL;
          *(void *)(v4 + 16) = 0LL;
          *(void *)(v4 + 24) = 0LL;
        }

        *(_DWORD *)(v4 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x20) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 40);
      if (v5)
      {
        if (*(int *)(v5 + 16) >= 1)
        {
          uint64_t v6 = 0LL;
          do
          {
            uint64_t v7 = *(void *)(*(void *)(v5 + 8) + 8 * v6);
            double result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32LL))(v7);
            ++v6;
          }

          while (v6 < *(int *)(v5 + 16));
        }

        *(_DWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x40) != 0)
    {
      uint64_t v8 = *(void *)(v1 + 48);
      if (v8)
      {
        if (*(int *)(v8 + 16) >= 1)
        {
          uint64_t v9 = 0LL;
          do
          {
            uint64_t v10 = *(void *)(*(void *)(v8 + 8) + 8 * v9);
            double result = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 32LL))(v10);
            ++v9;
          }

          while (v9 < *(int *)(v8 + 16));
        }

        *(_DWORD *)(v8 + 16) = 0;
        *(_DWORD *)(v8 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x80) != 0)
    {
      uint64_t v11 = *(void *)(v1 + 56);
      if (v11)
      {
        if (*(int *)(v11 + 16) >= 1)
        {
          uint64_t v12 = 0LL;
          do
          {
            uint64_t v13 = *(void *)(*(void *)(v11 + 8) + 8 * v12);
            double result = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 32LL))(v13);
            ++v12;
          }

          while (v12 < *(int *)(v11 + 16));
        }

        *(_DWORD *)(v11 + 16) = 0;
        *(_DWORD *)(v11 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }
  }

  if ((v3 & 0xFF00) != 0)
  {
    if ((v3 & 0x100) != 0)
    {
      uint64_t v14 = *(void *)(v1 + 64);
      if (v14)
      {
        if (*(_BYTE *)(v14 + 36))
        {
          *(void *)(v14 + 8) = 0LL;
          *(void *)(v14 + 16) = 0LL;
          *(void *)(v14 + 24) = 0LL;
        }

        *(_DWORD *)(v14 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x200) != 0)
    {
      uint64_t v15 = *(void *)(v1 + 72);
      if (v15)
      {
        int v16 = *(_DWORD *)(v15 + 76);
        if ((_BYTE)v16)
        {
          *(_OWORD *)(v15 + 49) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 8) = 0u;
        }

        if ((v16 & 0xFF00) != 0)
        {
          *(_BYTE *)(v15 + 69) = 0;
          *(_DWORD *)(v15 + 65) = 0;
        }

        *(_DWORD *)(v15 + 76) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x400) != 0)
    {
      uint64_t v17 = *(void *)(v1 + 80);
      if (v17)
      {
        if (*(_BYTE *)(v17 + 32))
        {
          *(void *)(v17 + 8) = 0LL;
          *(void *)(v17 + 16) = 0x400000000LL;
          *(_DWORD *)(v17 + 24) = 0;
        }

        *(_DWORD *)(v17 + 32) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x800) != 0)
    {
      uint64_t v18 = *(void *)(v1 + 88);
      if (v18)
      {
        if (*(_BYTE *)(v18 + 24))
        {
          *(void *)(v18 + 8) = 0LL;
          *(_DWORD *)(v18 + 16) = 4;
        }

        *(_DWORD *)(v18 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x1000) != 0)
    {
      uint64_t v19 = *(void *)(v1 + 96);
      if (v19)
      {
        if (*(_BYTE *)(v19 + 16)) {
          *(_DWORD *)(v19 + 8) = 15;
        }
        *(_DWORD *)(v19 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x2000) != 0)
    {
      uint64_t v20 = *(void *)(v1 + 104);
      if (v20)
      {
        if (*(_BYTE *)(v20 + 44))
        {
          *(_OWORD *)(v20 + 24) = 0u;
          *(_OWORD *)(v20 + 8) = 0u;
        }

        *(_DWORD *)(v20 + 44) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x4000) != 0)
    {
      uint64_t v21 = *(void *)(v1 + 112);
      if (v21)
      {
        if (*(_BYTE *)(v21 + 36))
        {
          *(void *)(v21 + 8) = 0LL;
          *(void *)(v21 + 16) = 0LL;
          *(void *)(v21 + 24) = 0LL;
        }

        *(_DWORD *)(v21 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x8000) != 0)
    {
      double result = *(void *)(v1 + 120);
      if (result)
      {
        double result = sub_100BB3BB8(result);
        unsigned int v3 = *v2;
      }
    }
  }

  if ((v3 & 0xFF0000) != 0)
  {
    if ((v3 & 0x10000) != 0)
    {
      uint64_t v22 = *(void *)(v1 + 128);
      if (v22)
      {
        if ((*(_BYTE *)(v22 + 20) & 1) != 0)
        {
          uint64_t v23 = *(void *)(v22 + 8);
          if ((_UNKNOWN *)v23 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v23 + 23) < 0)
            {
              **(_BYTE **)uint64_t v23 = 0;
              *(void *)(v23 + 8) = 0LL;
            }

            else
            {
              *(_BYTE *)uint64_t v23 = 0;
              *(_BYTE *)(v23 + 23) = 0;
            }
          }
        }

        *(_DWORD *)(v22 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x20000) != 0)
    {
      uint64_t v24 = *(void *)(v1 + 136);
      if (v24)
      {
        if (*(int *)(v24 + 16) >= 1)
        {
          uint64_t v25 = 0LL;
          do
          {
            uint64_t v26 = *(void *)(*(void *)(v24 + 8) + 8 * v25);
            double result = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 32LL))(v26);
            ++v25;
          }

          while (v25 < *(int *)(v24 + 16));
        }

        *(_DWORD *)(v24 + 16) = 0;
        *(_DWORD *)(v24 + 36) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x40000) != 0)
    {
      uint64_t v27 = *(void *)(v1 + 144);
      if (v27)
      {
        if (*(_BYTE *)(v27 + 20)) {
          *(void *)(v27 + 8) = 0LL;
        }
        *(_DWORD *)(v27 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x80000) != 0)
    {
      uint64_t v28 = *(void *)(v1 + 152);
      if (v28)
      {
        if (*(_BYTE *)(v28 + 20))
        {
          *(_BYTE *)(v28 + 8) = 1;
          *(_DWORD *)(v28 + 9) = 0;
          *(_BYTE *)(v28 + 13) = 0;
        }

        *(_DWORD *)(v28 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x100000) != 0)
    {
      uint64_t v29 = *(void *)(v1 + 160);
      if (v29)
      {
        if (*(_BYTE *)(v29 + 20)) {
          *(void *)(v29 + 8) = 0LL;
        }
        *(_DWORD *)(v29 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x200000) != 0)
    {
      uint64_t v30 = *(void *)(v1 + 168);
      if (v30)
      {
        if (*(_BYTE *)(v30 + 20))
        {
          *(_BYTE *)(v30 + 8) = 0;
          *(_DWORD *)(v30 + 12) = 0;
        }

        *(_DWORD *)(v30 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x400000) != 0)
    {
      uint64_t v31 = *(void *)(v1 + 176);
      if (v31)
      {
        if (*(_BYTE *)(v31 + 20)) {
          *(void *)(v31 + 8) = 0LL;
        }
        *(_DWORD *)(v31 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x800000) != 0)
    {
      uint64_t v32 = *(void *)(v1 + 184);
      if (v32)
      {
        if (*(_BYTE *)(v32 + 16)) {
          *(_BYTE *)(v32 + 8) = 0;
        }
        *(_DWORD *)(v32 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
  }

  if (HIBYTE(v3))
  {
    if ((v3 & 0x1000000) != 0)
    {
      uint64_t v33 = *(void *)(v1 + 192);
      if (v33)
      {
        if ((*(_BYTE *)(v33 + 20) & 1) != 0)
        {
          uint64_t v34 = *(void *)(v33 + 8);
          if ((_UNKNOWN *)v34 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v34 + 23) < 0)
            {
              **(_BYTE **)uint64_t v34 = 0;
              *(void *)(v34 + 8) = 0LL;
            }

            else
            {
              *(_BYTE *)uint64_t v34 = 0;
              *(_BYTE *)(v34 + 23) = 0;
            }
          }
        }

        *(_DWORD *)(v33 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x2000000) != 0)
    {
      uint64_t v35 = *(void *)(v1 + 200);
      if (v35)
      {
        if ((*(_BYTE *)(v35 + 20) & 1) != 0)
        {
          uint64_t v36 = *(void *)(v35 + 8);
          if ((_UNKNOWN *)v36 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            if (*(char *)(v36 + 23) < 0)
            {
              **(_BYTE **)uint64_t v36 = 0;
              *(void *)(v36 + 8) = 0LL;
            }

            else
            {
              *(_BYTE *)uint64_t v36 = 0;
              *(_BYTE *)(v36 + 23) = 0;
            }
          }
        }

        *(_DWORD *)(v35 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x4000000) != 0)
    {
      double result = *(void *)(v1 + 208);
      if (result)
      {
        double result = sub_100BB3DB0(result);
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x8000000) != 0)
    {
      uint64_t v37 = *(void *)(v1 + 216);
      if (v37)
      {
        if (*(_BYTE *)(v37 + 24))
        {
          *(_DWORD *)(v37 + 15) = 0;
          *(void *)(v37 + 8) = 0LL;
        }

        *(_DWORD *)(v37 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x10000000) != 0)
    {
      uint64_t v38 = *(void *)(v1 + 224);
      if (v38)
      {
        if (*(_BYTE *)(v38 + 16)) {
          *(_DWORD *)(v38 + 8) = 0;
        }
        *(_DWORD *)(v38 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x20000000) != 0)
    {
      uint64_t v39 = *(void *)(v1 + 232);
      if (v39)
      {
        if (*(_BYTE *)(v39 + 24))
        {
          *(void *)(v39 + 8) = 0LL;
          *(_DWORD *)(v39 + 16) = 0;
        }

        *(_DWORD *)(v39 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x40000000) != 0)
    {
      uint64_t v40 = *(void *)(v1 + 240);
      if (v40)
      {
        if (*(_BYTE *)(v40 + 16)) {
          *(_WORD *)(v40 + 8) = 0;
        }
        *(_DWORD *)(v40 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }

    if ((v3 & 0x80000000) != 0)
    {
      double result = *(void *)(v1 + 248);
      if (result) {
        double result = sub_1006422E0(result);
      }
    }
  }

  int v41 = *(_DWORD *)(v1 + 400);
  if ((_BYTE)v41)
  {
    if ((v41 & 1) != 0)
    {
      uint64_t v42 = *(void *)(v1 + 256);
      if ((_UNKNOWN *)v42 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v42 + 23) < 0)
        {
          **(_BYTE **)uint64_t v42 = 0;
          *(void *)(v42 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v42 = 0;
          *(_BYTE *)(v42 + 23) = 0;
        }
      }
    }

    int v41 = *(_DWORD *)(v1 + 400);
    if ((v41 & 2) != 0)
    {
      double result = *(void *)(v1 + 264);
      if (result)
      {
        double result = sub_100620674(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    *(_DWORD *)(v1 + 304) = 0;
    if ((v41 & 8) != 0)
    {
      double result = *(void *)(v1 + 272);
      if (result)
      {
        double result = sub_10063CEE4(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    if ((v41 & 0x10) != 0)
    {
      double result = *(void *)(v1 + 280);
      if (result)
      {
        double result = sub_10063DC00(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    if ((v41 & 0x20) != 0)
    {
      double result = *(void *)(v1 + 288);
      if (result)
      {
        double result = sub_100640DD8(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    if ((v41 & 0x40) != 0)
    {
      double result = *(void *)(v1 + 296);
      if (result)
      {
        double result = sub_100643B28(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    if ((v41 & 0x80) != 0)
    {
      double result = *(void *)(v1 + 312);
      if (result)
      {
        double result = sub_100644A58(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }
  }

  if ((v41 & 0xFF00) != 0)
  {
    if ((v41 & 0x100) != 0)
    {
      double result = *(void *)(v1 + 320);
      if (result)
      {
        double result = sub_100641A04(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    if ((v41 & 0x400) != 0)
    {
      double result = *(void *)(v1 + 344);
      if (result)
      {
        double result = sub_100618848(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }

    *(_DWORD *)(v1 + 308) = 0;
    *(_BYTE *)(v1 + 368) = 0;
    *(_DWORD *)(v1 + 372) = 0;
    if ((v41 & 0x8000) != 0)
    {
      double result = *(void *)(v1 + 376);
      if (result)
      {
        double result = sub_10061CDE4(result);
        int v41 = *(_DWORD *)(v1 + 400);
      }
    }
  }

  if ((v41 & 0x10000) != 0)
  {
    double result = *(void *)(v1 + 384);
    if (result) {
      double result = sub_100619F28(result);
    }
  }

  *(_DWORD *)(v1 + 336) = 0;
  *(_DWORD *)(v1 + 360) = 0;
  *(void *)uint64_t v2 = 0LL;
  return result;
}

uint64_t sub_100BB3978(uint64_t result)
{
  uint64_t v1 = result;
  if (*(_BYTE *)(result + 36))
  {
    if ((*(_BYTE *)(result + 36) & 1) != 0)
    {
      double result = *(void *)(result + 8);
      if (result) {
        double result = sub_1005014B0(result);
      }
    }

    *(_DWORD *)(v1 + 16) = 0;
    *(_BYTE *)(v1 + 20) = 0;
    *(void *)(v1 + 24) = 0LL;
  }

  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100BB39BC(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100BB39D4(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v2 = 0LL;
    do
    {
      uint64_t v3 = *(void *)(*(void *)(v1 + 8) + 8 * v2);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
      ++v2;
    }

    while (v2 < *(int *)(v1 + 16));
  }

  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100BB3A2C(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v2 = 0LL;
    do
    {
      uint64_t v3 = *(void *)(*(void *)(v1 + 8) + 8 * v2);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
      ++v2;
    }

    while (v2 < *(int *)(v1 + 16));
  }

  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100BB3A84(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v2 = 0LL;
    do
    {
      uint64_t v3 = *(void *)(*(void *)(v1 + 8) + 8 * v2);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
      ++v2;
    }

    while (v2 < *(int *)(v1 + 16));
  }

  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100BB3ADC(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100BB3AF4(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 76);
  if ((_BYTE)v1)
  {
    *(_OWORD *)(result + 49) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
  }

  if ((v1 & 0xFF00) != 0)
  {
    *(_BYTE *)(result + 69) = 0;
    *(_DWORD *)(result + 65) = 0;
  }

  *(_DWORD *)(result + 76) = 0;
  return result;
}

uint64_t sub_100BB3B2C(uint64_t result)
{
  if (*(_BYTE *)(result + 32))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0x400000000LL;
    *(_DWORD *)(result + 24) = 0;
  }

  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100BB3B50(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(void *)(result + 8) = 0LL;
    *(_DWORD *)(result + 16) = 4;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100BB3B6C(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_DWORD *)(result + 8) = 15;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BB3B84(uint64_t result)
{
  if (*(_BYTE *)(result + 44))
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
  }

  *(_DWORD *)(result + 44) = 0;
  return result;
}

uint64_t sub_100BB3BA0(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100BB3BB8(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    if ((*(_BYTE *)(result + 24) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(_BYTE **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v1 = 0;
          *(_BYTE *)(v1 + 23) = 0;
        }
      }
    }

    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100BB3C04(uint64_t result)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0)
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(_BYTE **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0LL;
      }

      else
      {
        *(_BYTE *)uint64_t v1 = 0;
        *(_BYTE *)(v1 + 23) = 0;
      }
    }
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3C48(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v2 = 0LL;
    do
    {
      uint64_t v3 = *(void *)(*(void *)(v1 + 8) + 8 * v2);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
      ++v2;
    }

    while (v2 < *(int *)(v1 + 16));
  }

  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100BB3CA0(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3CB4(uint64_t result)
{
  if (*(_BYTE *)(result + 20))
  {
    *(_BYTE *)(result + 8) = 1;
    *(_DWORD *)(result + 9) = 0;
    *(_BYTE *)(result + 13) = 0;
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3CD4(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3CE8(uint64_t result)
{
  if (*(_BYTE *)(result + 20))
  {
    *(_BYTE *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3D00(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3D14(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_BYTE *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BB3D28(uint64_t result)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0)
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(_BYTE **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0LL;
      }

      else
      {
        *(_BYTE *)uint64_t v1 = 0;
        *(_BYTE *)(v1 + 23) = 0;
      }
    }
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3D6C(uint64_t result)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0)
  {
    uint64_t v1 = *(void *)(result + 8);
    if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(_BYTE **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0LL;
      }

      else
      {
        *(_BYTE *)uint64_t v1 = 0;
        *(_BYTE *)(v1 + 23) = 0;
      }
    }
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BB3DB0(uint64_t result)
{
  LOBYTE(v1) = *(_BYTE *)(result + 56);
  if ((_BYTE)v1)
  {
    *(_BYTE *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + memset(v19, 0, 48) = 0;
    if ((v1 & 8) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if (v2)
      {
        int v3 = *(_DWORD *)(v2 + 56);
        if ((_BYTE)v3)
        {
          *(_DWORD *)(v2 + 36) = 0;
          *(void *)(v2 + 16) = 0LL;
          *(void *)(v2 + 24) = 0LL;
          *(void *)(v2 + 8) = 0LL;
          *(_BYTE *)(v2 + 32) = 0;
        }

        if ((v3 & 0xFF00) != 0)
        {
          *(void *)(v2 + 40) = 0LL;
          *(_DWORD *)(v2 + memset(v19, 0, 48) = 0;
        }

        *(_DWORD *)(v2 + 56) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }

    if ((v1 & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(result + 24);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 52)) {
          *(void *)(v4 + 8) = 0LL;
        }
        *(_DWORD *)(v4 + 24) = 0;
        *(_DWORD *)(v4 + 40) = 0;
        *(_DWORD *)(v4 + 52) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }

    if ((v1 & 0x20) != 0)
    {
      uint64_t v5 = *(void *)(result + 32);
      if (v5)
      {
        if ((*(_WORD *)(v5 + 36) & 0x1FE) != 0) {
          *(void *)(v5 + 24) = 0LL;
        }
        *(_DWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 36) = 0;
        int v1 = *(_DWORD *)(result + 56);
      }
    }

    if ((v1 & 0x40) != 0)
    {
      uint64_t v6 = *(void *)(result + 40);
      if (v6)
      {
        if (*(_BYTE *)(v6 + 20)) {
          *(void *)(v6 + 8) = 0LL;
        }
        *(_DWORD *)(v6 + 20) = 0;
      }
    }
  }

  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t sub_100BB3E78(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(_DWORD *)(result + 15) = 0;
    *(void *)(result + 8) = 0LL;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100BB3E90(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_DWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BB3EA4(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(void *)(result + 8) = 0LL;
    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100BB3EBC(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_WORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BB3ED0( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = (char **)((char *)this + 8);
  uint64_t v6 = a1 + 352;
  uint64_t v7 = a1 + 328;
  uint64_t v8 = (unsigned int *)(a1 + 16);
  v417 = (unsigned int *)(a1 + 304);
  uint64_t v9 = (unsigned int *)(a1 + 308);
  v415 = (unint64_t *)(a1 + 8);
  v416 = (unsigned int *)(a1 + 372);
LABEL_2:
  while (2)
  {
    uint64_t v10 = (char *)*((void *)this + 1);
    if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v10;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v10 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v12 = TagFallback & 7;
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v415);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v15 = (char *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          unint64_t *v415 = *v14;
          uint64_t v15 = v14 + 1;
          *uint64_t v5 = v15;
        }

        *(_DWORD *)(a1 + 396) |= 1u;
        if ((unint64_t)v15 < v13 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *uint64_t v5 = v16;
          goto LABEL_123;
        }

        continue;
      case 2u:
        int v12 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
LABEL_123:
        if ((unint64_t)v16 >= v13 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v8);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v30 = (char *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v8 = *v16;
          uint64_t v30 = v16 + 1;
          *uint64_t v5 = v30;
        }

        *(_DWORD *)(a1 + 396) |= 2u;
        uint64_t v17 = v30 + 1;
        *uint64_t v5 = v17;
LABEL_131:
        if ((unint64_t)v17 >= v13 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v420);
          if (!(_DWORD)result) {
            return result;
          }
          int v31 = v420[0];
        }

        else
        {
          int v31 = *v17;
          *uint64_t v5 = v17 + 1;
        }

        if (sub_100BB1E1C(v31))
        {
          *(_DWORD *)(a1 + 396) |= 4u;
          *(_DWORD *)(a1 + 20) = v31;
        }

        uint64_t v32 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v32 + 1;
LABEL_141:
        *(_DWORD *)(a1 + 396) |= 8u;
        uint64_t v33 = *(void **)(a1 + 24);
        if (!v33)
        {
          uint64_t v33 = operator new(0x28uLL);
          *uint64_t v33 = &off_101875690;
          v33[1] = 0LL;
          *((_DWORD *)v33 + 4) = 0;
          *((_BYTE *)v33 + 20) = 0;
          v33[3] = 0LL;
          v33[4] = 0LL;
          *(void *)(a1 + 24) = v33;
        }

        uint64_t v34 = (char *)*((void *)this + 1);
        if ((unint64_t)v34 >= *((void *)this + 2) || *v34 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v34;
          *uint64_t v5 = v34 + 1;
        }

        int v35 = *((_DWORD *)this + 14);
        int v36 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v35 + 1;
        if (v35 >= v36) {
          return 0LL;
        }
        int v37 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v37);
        int v39 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v39, 1);
        int v41 = v39 - 1;
        if (v41 < 0 == v40) {
          *((_DWORD *)this + 14) = v41;
        }
        uint64_t v42 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v42 + 1;
LABEL_155:
        *(_DWORD *)(a1 + 396) |= 0x10u;
        uint64_t v43 = *(char **)(a1 + 32);
        if (!v43)
        {
          uint64_t v43 = (char *)operator new(0x28uLL);
          *(void *)uint64_t v43 = off_101875708;
          *(_OWORD *)(v43 + 8) = 0u;
          *(_OWORD *)(v43 + 24) = 0u;
          *(void *)(a1 + 32) = v43;
        }

        uint64_t v44 = (char *)*((void *)this + 1);
        if ((unint64_t)v44 >= *((void *)this + 2) || *v44 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v44;
          *uint64_t v5 = v44 + 1;
        }

        int v45 = *((_DWORD *)this + 14);
        int v46 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v45 + 1;
        if (v45 >= v46) {
          return 0LL;
        }
        int v47 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v47);
        int v49 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v49, 1);
        int v50 = v49 - 1;
        if (v50 < 0 == v40) {
          *((_DWORD *)this + 14) = v50;
        }
        uint64_t v51 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v51 + 1;
LABEL_169:
        *(_DWORD *)(a1 + 396) |= 0x20u;
        uint64_t v52 = *(void **)(a1 + 40);
        if (!v52)
        {
          uint64_t v52 = operator new(0x28uLL);
          v52[1] = 0LL;
          v52[2] = 0LL;
          *uint64_t v52 = off_101875870;
          *((_DWORD *)v52 + 6) = 0;
          v52[4] = 0LL;
          *(void *)(a1 + 40) = v52;
        }

        uint64_t v53 = (char *)*((void *)this + 1);
        if ((unint64_t)v53 >= *((void *)this + 2) || *v53 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v53;
          *uint64_t v5 = v53 + 1;
        }

        int v54 = *((_DWORD *)this + 14);
        int v55 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v54 + 1;
        if (v54 >= v55) {
          return 0LL;
        }
        int v56 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v56);
        int v58 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v58, 1);
        int v59 = v58 - 1;
        if (v59 < 0 == v40) {
          *((_DWORD *)this + 14) = v59;
        }
        uint64_t v60 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v60 + 1;
LABEL_183:
        *(_DWORD *)(a1 + 396) |= 0x40u;
        uint64_t v61 = *(void **)(a1 + 48);
        if (!v61)
        {
          uint64_t v61 = operator new(0x28uLL);
          v61[1] = 0LL;
          v61[2] = 0LL;
          *uint64_t v61 = off_1018758E8;
          *((_DWORD *)v61 + 6) = 0;
          v61[4] = 0LL;
          *(void *)(a1 + memset(v19, 0, 48) = v61;
        }

        uint64_t v62 = (char *)*((void *)this + 1);
        if ((unint64_t)v62 >= *((void *)this + 2) || *v62 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v62;
          *uint64_t v5 = v62 + 1;
        }

        int v63 = *((_DWORD *)this + 14);
        int v64 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v63 + 1;
        if (v63 >= v64) {
          return 0LL;
        }
        int v65 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v65);
        int v67 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v67, 1);
        int v68 = v67 - 1;
        if (v68 < 0 == v40) {
          *((_DWORD *)this + 14) = v68;
        }
        int v69 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v69 + 1;
LABEL_197:
        *(_DWORD *)(a1 + 396) |= 0x80u;
        uint64_t v70 = *(void **)(a1 + 56);
        if (!v70)
        {
          uint64_t v70 = operator new(0x28uLL);
          v70[1] = 0LL;
          v70[2] = 0LL;
          void *v70 = off_101875960;
          *((_DWORD *)v70 + 6) = 0;
          v70[4] = 0LL;
          *(void *)(a1 + 56) = v70;
        }

        uint64_t v71 = (char *)*((void *)this + 1);
        if ((unint64_t)v71 >= *((void *)this + 2) || *v71 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v71;
          *uint64_t v5 = v71 + 1;
        }

        int v72 = *((_DWORD *)this + 14);
        int v73 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v72 + 1;
        if (v72 >= v73) {
          return 0LL;
        }
        int v74 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v74);
        int v76 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v76, 1);
        int v77 = v76 - 1;
        if (v77 < 0 == v40) {
          *((_DWORD *)this + 14) = v77;
        }
        uint64_t v78 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v78 + 1;
LABEL_211:
        *(_DWORD *)(a1 + 396) |= 0x100u;
        v79 = *(char **)(a1 + 64);
        if (!v79)
        {
          v79 = (char *)operator new(0x28uLL);
          *(void *)v79 = off_1018759D8;
          *(_OWORD *)(v79 + 8) = 0u;
          *(_OWORD *)(v79 + 24) = 0u;
          *(void *)(a1 + 64) = v79;
        }

        uint64_t v80 = (char *)*((void *)this + 1);
        if ((unint64_t)v80 >= *((void *)this + 2) || *v80 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v80;
          *uint64_t v5 = v80 + 1;
        }

        int v81 = *((_DWORD *)this + 14);
        int v82 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v81 + 1;
        if (v81 >= v82) {
          return 0LL;
        }
        int v83 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v83);
        int v85 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v85, 1);
        int v86 = v85 - 1;
        if (v86 < 0 == v40) {
          *((_DWORD *)this + 14) = v86;
        }
        v87 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v87 + 1;
LABEL_225:
        *(_DWORD *)(a1 + 396) |= 0x200u;
        uint64_t v88 = *(char **)(a1 + 72);
        if (!v88)
        {
          uint64_t v88 = (char *)operator new(0x50uLL);
          *(void *)uint64_t v88 = off_101875A50;
          *((void *)v88 + 9) = 0LL;
          *(_OWORD *)(v88 + 8) = 0u;
          *(_OWORD *)(v88 + 24) = 0u;
          *(_OWORD *)(v88 + 40) = 0u;
          *(_OWORD *)(v88 + 54) = 0u;
          *(void *)(a1 + 72) = v88;
        }

        int v89 = (char *)*((void *)this + 1);
        if ((unint64_t)v89 >= *((void *)this + 2) || *v89 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v89;
          *uint64_t v5 = v89 + 1;
        }

        int v90 = *((_DWORD *)this + 14);
        int v91 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v90 + 1;
        if (v90 >= v91) {
          return 0LL;
        }
        int v92 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v92);
        int v94 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v94, 1);
        int v95 = v94 - 1;
        if (v95 < 0 == v40) {
          *((_DWORD *)this + 14) = v95;
        }
        char v96 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v96 + 1;
LABEL_239:
        *(_DWORD *)(a1 + 396) |= 0x400u;
        v97 = *(void **)(a1 + 80);
        if (!v97)
        {
          v97 = operator new(0x28uLL);
          void *v97 = off_101875AC8;
          v97[1] = 0LL;
          *((_OWORD *)v97 + 1) = xmmword_10134D8D0;
          *((_DWORD *)v97 + 8) = 0;
          *(void *)(a1 + 80) = v97;
        }

        v98 = (char *)*((void *)this + 1);
        if ((unint64_t)v98 >= *((void *)this + 2) || *v98 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v98;
          *uint64_t v5 = v98 + 1;
        }

        int v99 = *((_DWORD *)this + 14);
        int v100 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v99 + 1;
        if (v99 >= v100) {
          return 0LL;
        }
        int v101 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v101);
        int v103 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v103, 1);
        int v104 = v103 - 1;
        if (v104 < 0 == v40) {
          *((_DWORD *)this + 14) = v104;
        }
        v105 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v105 + 1;
LABEL_253:
        *(_DWORD *)(a1 + 396) |= 0x800u;
        v106 = *(void **)(a1 + 88);
        if (!v106)
        {
          v106 = operator new(0x20uLL);
          void *v106 = off_101875B40;
          v106[1] = 0LL;
          v106[2] = 4LL;
          *((_DWORD *)v106 + 6) = 0;
          *(void *)(a1 + 88) = v106;
        }

        v107 = (char *)*((void *)this + 1);
        if ((unint64_t)v107 >= *((void *)this + 2) || *v107 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v107;
          *uint64_t v5 = v107 + 1;
        }

        int v108 = *((_DWORD *)this + 14);
        int v109 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v108 + 1;
        if (v108 >= v109) {
          return 0LL;
        }
        int v110 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v110);
        int v112 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v112, 1);
        int v113 = v112 - 1;
        if (v113 < 0 == v40) {
          *((_DWORD *)this + 14) = v113;
        }
        v114 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v114 + 1;
LABEL_267:
        *(_DWORD *)(a1 + 396) |= 0x1000u;
        v115 = *(void **)(a1 + 96);
        if (!v115)
        {
          v115 = operator new(0x18uLL);
          void *v115 = off_101875BB8;
          v115[1] = 15LL;
          *((_DWORD *)v115 + 4) = 0;
          *(void *)(a1 + 96) = v115;
        }

        v116 = (char *)*((void *)this + 1);
        if ((unint64_t)v116 >= *((void *)this + 2) || *v116 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v116;
          *uint64_t v5 = v116 + 1;
        }

        int v117 = *((_DWORD *)this + 14);
        int v118 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v117 + 1;
        if (v117 >= v118) {
          return 0LL;
        }
        int v119 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v119);
        int v121 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v121, 1);
        int v122 = v121 - 1;
        if (v122 < 0 == v40) {
          *((_DWORD *)this + 14) = v122;
        }
        v123 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v123 + 1;
LABEL_281:
        *(_DWORD *)(a1 + 396) |= 0x2000u;
        v124 = *(char **)(a1 + 104);
        if (!v124)
        {
          v124 = (char *)operator new(0x30uLL);
          *(void *)v124 = off_101875C30;
          *(_OWORD *)(v124 + 8) = 0u;
          *(_OWORD *)(v124 + 24) = 0u;
          *((void *)v124 + 5) = 0LL;
          *(void *)(a1 + 104) = v124;
        }

        v125 = (char *)*((void *)this + 1);
        if ((unint64_t)v125 >= *((void *)this + 2) || *v125 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v125;
          *uint64_t v5 = v125 + 1;
        }

        int v126 = *((_DWORD *)this + 14);
        int v127 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v126 + 1;
        if (v126 >= v127) {
          return 0LL;
        }
        int v128 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v128);
        int v130 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v130, 1);
        int v131 = v130 - 1;
        if (v131 < 0 == v40) {
          *((_DWORD *)this + 14) = v131;
        }
        v132 = (_BYTE *)*((void *)this + 1);
        *uint64_t v5 = v132 + 1;
LABEL_295:
        *(_DWORD *)(a1 + 396) |= 0x4000u;
        v133 = *(char **)(a1 + 112);
        if (!v133)
        {
          v133 = (char *)operator new(0x28uLL);
          *(void *)v133 = off_101875CA8;
          *(_OWORD *)(v133 + 8) = 0u;
          *(_OWORD *)(v133 + 24) = 0u;
          *(void *)(a1 + 112) = v133;
        }

        v134 = (char *)*((void *)this + 1);
        if ((unint64_t)v134 >= *((void *)this + 2) || *v134 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v134;
          *uint64_t v5 = v134 + 1;
        }

        int v135 = *((_DWORD *)this + 14);
        int v136 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v135 + 1;
        if (v135 >= v136) {
          return 0LL;
        }
        int v137 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v137);
        int v139 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v139, 1);
        int v140 = v139 - 1;
        if (v140 < 0 == v40) {
          *((_DWORD *)this + 14) = v140;
        }
        v141 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v141 + 2);
LABEL_310:
        *(_DWORD *)(a1 + 396) |= 0x8000u;
        v142 = *(void **)(a1 + 120);
        if (!v142)
        {
          v142 = operator new(0x20uLL);
          void *v142 = off_101875528;
          v142[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          v142[2] = 0LL;
          *((_DWORD *)v142 + 6) = 0;
          *(void *)(a1 + 120) = v142;
        }

        v143 = (char *)*((void *)this + 1);
        if ((unint64_t)v143 >= *((void *)this + 2) || *v143 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v143;
          *uint64_t v5 = v143 + 1;
        }

        int v144 = *((_DWORD *)this + 14);
        int v145 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v144 + 1;
        if (v144 >= v145) {
          return 0LL;
        }
        int v146 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v146);
        int v148 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v148, 1);
        int v149 = v148 - 1;
        if (v149 < 0 == v40) {
          *((_DWORD *)this + 14) = v149;
        }
        v150 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v150 + 2);
LABEL_325:
        *(_DWORD *)(a1 + 396) |= 0x10000u;
        v151 = *(void **)(a1 + 128);
        if (!v151)
        {
          v151 = operator new(0x18uLL);
          void *v151 = off_1018755A0;
          v151[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          v151[2] = 0LL;
          *(void *)(a1 + 1sub_100231C10(v1 + 28) = v151;
        }

        v152 = (char *)*((void *)this + 1);
        if ((unint64_t)v152 >= *((void *)this + 2) || *v152 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v152;
          *uint64_t v5 = v152 + 1;
        }

        int v153 = *((_DWORD *)this + 14);
        int v154 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v153 + 1;
        if (v153 >= v154) {
          return 0LL;
        }
        int v155 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v155);
        int v157 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v157, 1);
        int v158 = v157 - 1;
        if (v158 < 0 == v40) {
          *((_DWORD *)this + 14) = v158;
        }
        v159 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v159 + 2);
LABEL_340:
        *(_DWORD *)(a1 + 396) |= 0x20000u;
        v160 = *(void **)(a1 + 136);
        if (!v160)
        {
          v160 = operator new(0x28uLL);
          v160[1] = 0LL;
          v160[2] = 0LL;
          void *v160 = off_101875618;
          *((_DWORD *)v160 + 6) = 0;
          v160[4] = 0LL;
          *(void *)(a1 + 136) = v160;
        }

        v161 = (char *)*((void *)this + 1);
        if ((unint64_t)v161 >= *((void *)this + 2) || *v161 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v161;
          *uint64_t v5 = v161 + 1;
        }

        int v162 = *((_DWORD *)this + 14);
        int v163 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v162 + 1;
        if (v162 >= v163) {
          return 0LL;
        }
        int v164 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v164);
        int v166 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v166, 1);
        int v167 = v166 - 1;
        if (v167 < 0 == v40) {
          *((_DWORD *)this + 14) = v167;
        }
        v168 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v168 + 2);
LABEL_355:
        *(_DWORD *)(a1 + 396) |= 0x40000u;
        v169 = *(void **)(a1 + 144);
        if (!v169)
        {
          v169 = operator new(0x18uLL);
          v169[1] = 0LL;
          v169[2] = 0LL;
          void *v169 = off_101875780;
          *(void *)(a1 + 144) = v169;
        }

        v170 = (char *)*((void *)this + 1);
        if ((unint64_t)v170 >= *((void *)this + 2) || *v170 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v170;
          *uint64_t v5 = v170 + 1;
        }

        int v171 = *((_DWORD *)this + 14);
        int v172 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v171 + 1;
        if (v171 >= v172) {
          return 0LL;
        }
        int v173 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v173);
        int v175 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v175, 1);
        int v176 = v175 - 1;
        if (v176 < 0 == v40) {
          *((_DWORD *)this + 14) = v176;
        }
        v177 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v177 + 2);
LABEL_370:
        *(_DWORD *)(a1 + 396) |= 0x80000u;
        v178 = *(char **)(a1 + 152);
        if (!v178)
        {
          v178 = (char *)operator new(0x18uLL);
          *(void *)v178 = off_1018754B0;
          v178[8] = 1;
          *((void *)v178 + 2) = 0LL;
          *(_DWORD *)(v178 + 9) = 0;
          v178[13] = 0;
          *(void *)(a1 + 152) = v178;
        }

        v179 = (char *)*((void *)this + 1);
        if ((unint64_t)v179 >= *((void *)this + 2) || *v179 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v179;
          *uint64_t v5 = v179 + 1;
        }

        int v180 = *((_DWORD *)this + 14);
        int v181 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v180 + 1;
        if (v180 >= v181) {
          return 0LL;
        }
        int v182 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v182);
        int v184 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v184, 1);
        int v185 = v184 - 1;
        if (v185 < 0 == v40) {
          *((_DWORD *)this + 14) = v185;
        }
        v186 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v186 + 2);
LABEL_385:
        *(_DWORD *)(a1 + 396) |= 0x100000u;
        v187 = *(void **)(a1 + 160);
        if (!v187)
        {
          v187 = operator new(0x18uLL);
          v187[1] = 0LL;
          v187[2] = 0LL;
          void *v187 = off_1018757F8;
          *(void *)(a1 + 160) = v187;
        }

        v188 = (char *)*((void *)this + 1);
        if ((unint64_t)v188 >= *((void *)this + 2) || *v188 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v188;
          *uint64_t v5 = v188 + 1;
        }

        int v189 = *((_DWORD *)this + 14);
        int v190 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v189 + 1;
        if (v189 >= v190) {
          return 0LL;
        }
        int v191 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v191);
        int v193 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v193, 1);
        int v194 = v193 - 1;
        if (v194 < 0 == v40) {
          *((_DWORD *)this + 14) = v194;
        }
        v195 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v195 + 2);
LABEL_400:
        *(_DWORD *)(a1 + 396) |= 0x200000u;
        v196 = *(_BYTE **)(a1 + 168);
        if (!v196)
        {
          v196 = operator new(0x18uLL);
          *(void *)v196 = off_101875D98;
          v196[8] = 0;
          *((void *)v196 + 2) = 0LL;
          *((_DWORD *)v196 + 3) = 0;
          *(void *)(a1 + 168) = v196;
        }

        v197 = (char *)*((void *)this + 1);
        if ((unint64_t)v197 >= *((void *)this + 2) || *v197 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v197;
          *uint64_t v5 = v197 + 1;
        }

        int v198 = *((_DWORD *)this + 14);
        int v199 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v198 + 1;
        if (v198 >= v199) {
          return 0LL;
        }
        int v200 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v200);
        int v202 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v202, 1);
        int v203 = v202 - 1;
        if (v203 < 0 == v40) {
          *((_DWORD *)this + 14) = v203;
        }
        v204 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v204 + 2);
LABEL_415:
        *(_DWORD *)(a1 + 396) |= 0x400000u;
        v205 = *(unsigned int **)(a1 + 176);
        if (!v205)
        {
          v205 = (unsigned int *)operator new(0x18uLL);
          *((void *)v205 + 1) = 0LL;
          *((void *)v205 + 2) = 0LL;
          *(void *)v205 = off_101875E10;
          *(void *)(a1 + 176) = v205;
        }

        v206 = (char *)*((void *)this + 1);
        if ((unint64_t)v206 >= *((void *)this + 2) || *v206 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v206;
          *uint64_t v5 = v206 + 1;
        }

        int v207 = *((_DWORD *)this + 14);
        int v208 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v207 + 1;
        if (v207 >= v208) {
          return 0LL;
        }
        int v209 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v209);
        int v211 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v211, 1);
        int v212 = v211 - 1;
        if (v212 < 0 == v40) {
          *((_DWORD *)this + 14) = v212;
        }
        v213 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v213 + 2);
LABEL_430:
        *(_DWORD *)(a1 + 396) |= 0x800000u;
        v214 = *(_BYTE **)(a1 + 184);
        if (!v214)
        {
          v214 = operator new(0x18uLL);
          *(void *)v214 = off_101875F00;
          v214[8] = 0;
          *((_DWORD *)v214 + 3) = 0;
          *((_DWORD *)v214 + 4) = 0;
          *(void *)(a1 + 184) = v214;
        }

        v215 = (char *)*((void *)this + 1);
        if ((unint64_t)v215 >= *((void *)this + 2) || *v215 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v215;
          *uint64_t v5 = v215 + 1;
        }

        int v216 = *((_DWORD *)this + 14);
        int v217 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v216 + 1;
        if (v216 >= v217) {
          return 0LL;
        }
        int v218 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v218);
        int v220 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v220, 1);
        int v221 = v220 - 1;
        if (v221 < 0 == v40) {
          *((_DWORD *)this + 14) = v221;
        }
        v222 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v222 + 2);
LABEL_445:
        *(_DWORD *)(a1 + 396) |= 0x1000000u;
        v223 = *(void **)(a1 + 192);
        if (!v223)
        {
          v223 = operator new(0x18uLL);
          void *v223 = off_101875F78;
          v223[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          v223[2] = 0LL;
          *(void *)(a1 + 192) = v223;
        }

        v224 = (char *)*((void *)this + 1);
        if ((unint64_t)v224 >= *((void *)this + 2) || *v224 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v224;
          *uint64_t v5 = v224 + 1;
        }

        int v225 = *((_DWORD *)this + 14);
        int v226 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v225 + 1;
        if (v225 >= v226) {
          return 0LL;
        }
        int v227 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v227);
        int v229 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v229, 1);
        int v230 = v229 - 1;
        if (v230 < 0 == v40) {
          *((_DWORD *)this + 14) = v230;
        }
        v231 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v231 + 2);
LABEL_460:
        *(_DWORD *)(a1 + 396) |= 0x2000000u;
        v232 = *(void **)(a1 + 200);
        if (!v232)
        {
          v232 = operator new(0x18uLL);
          void *v232 = off_101875FF0;
          v232[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          v232[2] = 0LL;
          *(void *)(a1 + 200) = v232;
        }

        v233 = (char *)*((void *)this + 1);
        if ((unint64_t)v233 >= *((void *)this + 2) || *v233 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v233;
          *uint64_t v5 = v233 + 1;
        }

        int v234 = *((_DWORD *)this + 14);
        int v235 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v234 + 1;
        if (v234 >= v235) {
          return 0LL;
        }
        int v236 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v236);
        int v238 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v238, 1);
        int v239 = v238 - 1;
        if (v239 < 0 == v40) {
          *((_DWORD *)this + 14) = v239;
        }
        v240 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v240 + 2);
LABEL_475:
        *(_DWORD *)(a1 + 396) |= 0x4000000u;
        v241 = *(char **)(a1 + 208);
        if (!v241)
        {
          v241 = (char *)operator new(0x40uLL);
          *(void *)v241 = off_101876428;
          v241[8] = 0;
          *(_OWORD *)(v241 + 12) = 0u;
          *(_OWORD *)(v241 + sub_100231C10(v1 + 28) = 0u;
          *(_OWORD *)(v241 + 44) = 0u;
          *(void *)(a1 + 208) = v241;
        }

        v242 = (char *)*((void *)this + 1);
        if ((unint64_t)v242 >= *((void *)this + 2) || *v242 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v242;
          *uint64_t v5 = v242 + 1;
        }

        int v243 = *((_DWORD *)this + 14);
        int v244 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v243 + 1;
        if (v243 >= v244) {
          return 0LL;
        }
        int v245 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v245);
        int v247 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v247, 1);
        int v248 = v247 - 1;
        if (v248 < 0 == v40) {
          *((_DWORD *)this + 14) = v248;
        }
        v249 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v249 + 2);
LABEL_490:
        *(_DWORD *)(a1 + 396) |= 0x8000000u;
        v250 = *(_DWORD **)(a1 + 216);
        if (!v250)
        {
          v250 = operator new(0x20uLL);
          v250[5] = 0;
          v250[6] = 0;
          *(void *)v250 = off_1018766F8;
          *((void *)v250 + 1) = 0LL;
          *(_DWORD *)((char *)v250 + 15) = 0;
          *(void *)(a1 + 216) = v250;
        }

        v251 = (char *)*((void *)this + 1);
        if ((unint64_t)v251 >= *((void *)this + 2) || *v251 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v251;
          *uint64_t v5 = v251 + 1;
        }

        int v252 = *((_DWORD *)this + 14);
        int v253 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v252 + 1;
        if (v252 >= v253) {
          return 0LL;
        }
        int v254 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v254);
        int v256 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v256, 1);
        int v257 = v256 - 1;
        if (v257 < 0 == v40) {
          *((_DWORD *)this + 14) = v257;
        }
        v258 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v258 + 2);
LABEL_505:
        *(_DWORD *)(a1 + 396) |= 0x10000000u;
        v259 = *(void **)(a1 + 224);
        if (!v259)
        {
          v259 = operator new(0x18uLL);
          void *v259 = off_1018764A0;
          v259[1] = 0LL;
          *((_DWORD *)v259 + 4) = 0;
          *(void *)(a1 + 224) = v259;
        }

        v260 = (char *)*((void *)this + 1);
        if ((unint64_t)v260 >= *((void *)this + 2) || *v260 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v260;
          *uint64_t v5 = v260 + 1;
        }

        int v261 = *((_DWORD *)this + 14);
        int v262 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v261 + 1;
        if (v261 >= v262) {
          return 0LL;
        }
        int v263 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v263);
        int v265 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v265, 1);
        int v266 = v265 - 1;
        if (v266 < 0 == v40) {
          *((_DWORD *)this + 14) = v266;
        }
        v267 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v267 + 2);
LABEL_520:
        *(_DWORD *)(a1 + 396) |= 0x20000000u;
        v268 = *(void **)(a1 + 232);
        if (!v268)
        {
          v268 = operator new(0x20uLL);
          v268[1] = 0LL;
          v268[2] = 0LL;
          void *v268 = off_101875D20;
          *((_DWORD *)v268 + 6) = 0;
          *(void *)(a1 + 232) = v268;
        }

        v269 = (char *)*((void *)this + 1);
        if ((unint64_t)v269 >= *((void *)this + 2) || *v269 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v269;
          *uint64_t v5 = v269 + 1;
        }

        int v270 = *((_DWORD *)this + 14);
        int v271 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v270 + 1;
        if (v270 >= v271) {
          return 0LL;
        }
        int v272 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v272);
        int v274 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v274, 1);
        int v275 = v274 - 1;
        if (v275 < 0 == v40) {
          *((_DWORD *)this + 14) = v275;
        }
        v276 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v276 + 2);
LABEL_535:
        *(_DWORD *)(a1 + 396) |= 0x40000000u;
        v277 = *(_WORD **)(a1 + 240);
        if (!v277)
        {
          v277 = operator new(0x18uLL);
          *(void *)v277 = off_101875E88;
          v277[4] = 0;
          *((_DWORD *)v277 + 3) = 0;
          *((_DWORD *)v277 + 4) = 0;
          *(void *)(a1 + 240) = v277;
        }

        v278 = (char *)*((void *)this + 1);
        if ((unint64_t)v278 >= *((void *)this + 2) || *v278 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v278;
          *uint64_t v5 = v278 + 1;
        }

        int v279 = *((_DWORD *)this + 14);
        int v280 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v279 + 1;
        if (v279 >= v280) {
          return 0LL;
        }
        int v281 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v281);
        int v283 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v283, 1);
        int v284 = v283 - 1;
        if (v284 < 0 == v40) {
          *((_DWORD *)this + 14) = v284;
        }
        v285 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v285 + 2);
LABEL_550:
        *(_DWORD *)(a1 + 396) |= 0x80000000;
        v286 = *(void **)(a1 + 248);
        if (!v286)
        {
          v286 = operator new(0x30uLL);
          sub_100614710((uint64_t)v286);
          *(void *)(a1 + 2memset(v19, 0, 48) = v286;
        }

        v287 = (char *)*((void *)this + 1);
        if ((unint64_t)v287 >= *((void *)this + 2) || *v287 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v287;
          *uint64_t v5 = v287 + 1;
        }

        int v288 = *((_DWORD *)this + 14);
        int v289 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v288 + 1;
        if (v288 >= v289) {
          return 0LL;
        }
        int v290 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v290);
        int v292 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v292, 1);
        int v293 = v292 - 1;
        if (v293 < 0 == v40) {
          *((_DWORD *)this + 14) = v293;
        }
        v294 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v294 + 2);
LABEL_565:
        *(_DWORD *)(a1 + 400) |= 1u;
        v295 = *(void **)(a1 + 256);
        if (v295 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        {
          v295 = operator new(0x18uLL);
          v295[1] = 0LL;
          v295[2] = 0LL;
          void *v295 = 0LL;
          *(void *)(a1 + 256) = v295;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v295);
        if (!(_DWORD)result) {
          return result;
        }
        v296 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v296 + 2);
LABEL_572:
        *(_DWORD *)(a1 + 400) |= 2u;
        v297 = *(unsigned int **)(a1 + 264);
        if (!v297)
        {
          v297 = (unsigned int *)operator new(0x58uLL);
          sub_100614600((uint64_t)v297);
          *(void *)(a1 + 264) = v297;
        }

        v298 = (char *)*((void *)this + 1);
        if ((unint64_t)v298 >= *((void *)this + 2) || *v298 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v298;
          *uint64_t v5 = v298 + 1;
        }

        int v299 = *((_DWORD *)this + 14);
        int v300 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v299 + 1;
        if (v299 >= v300) {
          return 0LL;
        }
        int v301 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v301);
        int v303 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v303, 1);
        int v304 = v303 - 1;
        if (v304 < 0 == v40) {
          *((_DWORD *)this + 14) = v304;
        }
        v305 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v18 = *((void *)this + 2);
        uint64_t v19 = (char *)(v305 + 2);
        *uint64_t v5 = v19;
LABEL_587:
        if ((unint64_t)v19 >= v18 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v417);
          if (!(_DWORD)result) {
            return result;
          }
          v306 = (char *)*((void *)this + 1);
          unint64_t v18 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v417 = *v19;
          v306 = v19 + 1;
          *uint64_t v5 = v306;
        }

        int v27 = *(_DWORD *)(a1 + 400) | 4;
        *(_DWORD *)(a1 + 400) = v27;
        *uint64_t v5 = v306 + 2;
LABEL_596:
        *(_DWORD *)(a1 + 400) = v27 | 8;
        v307 = *(_DWORD **)(a1 + 272);
        if (!v307)
        {
          v307 = operator new(0x48uLL);
          sub_100614690((uint64_t)v307);
          *(void *)(a1 + 272) = v307;
        }

        v308 = (char *)*((void *)this + 1);
        if ((unint64_t)v308 >= *((void *)this + 2) || *v308 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v308;
          *uint64_t v5 = v308 + 1;
        }

        int v309 = *((_DWORD *)this + 14);
        int v310 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v309 + 1;
        if (v309 >= v310) {
          return 0LL;
        }
        int v311 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v311);
        int v313 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v313, 1);
        int v314 = v313 - 1;
        if (v314 < 0 == v40) {
          *((_DWORD *)this + 14) = v314;
        }
        v315 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v315 + 2);
LABEL_611:
        *(_DWORD *)(a1 + 400) |= 0x10u;
        v316 = *(unsigned int **)(a1 + 280);
        if (!v316)
        {
          v316 = (unsigned int *)operator new(0x48uLL);
          sub_1006146B8((uint64_t)v316);
          *(void *)(a1 + 280) = v316;
        }

        v317 = (char *)*((void *)this + 1);
        if ((unint64_t)v317 >= *((void *)this + 2) || *v317 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v317;
          *uint64_t v5 = v317 + 1;
        }

        int v318 = *((_DWORD *)this + 14);
        int v319 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v318 + 1;
        if (v318 >= v319) {
          return 0LL;
        }
        int v320 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v320);
        int v322 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v322, 1);
        int v323 = v322 - 1;
        if (v323 < 0 == v40) {
          *((_DWORD *)this + 14) = v323;
        }
        v324 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v324 + 2);
LABEL_626:
        *(_DWORD *)(a1 + 400) |= 0x20u;
        v325 = *(_DWORD **)(a1 + 288);
        if (!v325)
        {
          v325 = operator new(0x38uLL);
          sub_1006146DC((uint64_t)v325);
          *(void *)(a1 + 288) = v325;
        }

        v326 = (char *)*((void *)this + 1);
        if ((unint64_t)v326 >= *((void *)this + 2) || *v326 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v326;
          *uint64_t v5 = v326 + 1;
        }

        int v327 = *((_DWORD *)this + 14);
        int v328 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v327 + 1;
        if (v327 >= v328) {
          return 0LL;
        }
        int v329 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v329);
        int v331 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v331, 1);
        int v332 = v331 - 1;
        if (v332 < 0 == v40) {
          *((_DWORD *)this + 14) = v332;
        }
        v333 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v333 + 2);
LABEL_641:
        *(_DWORD *)(a1 + 400) |= 0x40u;
        v334 = *(void **)(a1 + 296);
        if (!v334)
        {
          v334 = operator new(0x48uLL);
          sub_100614734((uint64_t)v334);
          *(void *)(a1 + 296) = v334;
        }

        v335 = (char *)*((void *)this + 1);
        if ((unint64_t)v335 >= *((void *)this + 2) || *v335 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v335;
          *uint64_t v5 = v335 + 1;
        }

        int v336 = *((_DWORD *)this + 14);
        int v337 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v336 + 1;
        if (v336 >= v337) {
          return 0LL;
        }
        int v338 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v338);
        int v340 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v340, 1);
        int v341 = v340 - 1;
        if (v341 < 0 == v40) {
          *((_DWORD *)this + 14) = v341;
        }
        v342 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v342 + 2);
LABEL_656:
        *(_DWORD *)(a1 + 400) |= 0x80u;
        v343 = *(void **)(a1 + 312);
        if (!v343)
        {
          v343 = operator new(0x20uLL);
          sub_100614770(v343);
          *(void *)(a1 + 312) = v343;
        }

        v344 = (char *)*((void *)this + 1);
        if ((unint64_t)v344 >= *((void *)this + 2) || *v344 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v344;
          *uint64_t v5 = v344 + 1;
        }

        int v345 = *((_DWORD *)this + 14);
        int v346 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v345 + 1;
        if (v345 >= v346) {
          return 0LL;
        }
        int v347 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v347);
        int v349 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v349, 1);
        int v350 = v349 - 1;
        if (v350 < 0 == v40) {
          *((_DWORD *)this + 14) = v350;
        }
        v351 = (unsigned __int8 *)*((void *)this + 1);
        *uint64_t v5 = (char *)(v351 + 2);
LABEL_671:
        *(_DWORD *)(a1 + 400) |= 0x100u;
        v352 = *(void **)(a1 + 320);
        if (!v352)
        {
          v352 = operator new(0x20uLL);
          sub_1006146FC(v352);
          *(void *)(a1 + 320) = v352;
        }

        v353 = (char *)*((void *)this + 1);
        if ((unint64_t)v353 >= *((void *)this + 2) || *v353 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
            return 0LL;
          }
        }

        else
        {
          v420[0] = *v353;
          *uint64_t v5 = v353 + 1;
        }

        int v354 = *((_DWORD *)this + 14);
        int v355 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v354 + 1;
        if (v354 >= v355) {
          return 0LL;
        }
        int v356 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v356);
        int v358 = *((_DWORD *)this + 14);
        BOOL v40 = __OFSUB__(v358, 1);
        int v359 = v358 - 1;
        if (v359 < 0 == v40) {
          *((_DWORD *)this + 14) = v359;
        }
        v360 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        continue;
      case 3u:
        int v12 = TagFallback & 7;
        uint64_t v17 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_131;
      case 4u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_141;
        }
        goto LABEL_111;
      case 5u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_155;
        }
        goto LABEL_111;
      case 6u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_169;
        }
        goto LABEL_111;
      case 7u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_183;
        }
        goto LABEL_111;
      case 8u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_197;
        }
        goto LABEL_111;
      case 9u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_211;
        }
        goto LABEL_111;
      case 0xAu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_225;
        }
        goto LABEL_111;
      case 0xBu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_239;
        }
        goto LABEL_111;
      case 0xCu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_253;
        }
        goto LABEL_111;
      case 0xDu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_267;
        }
        goto LABEL_111;
      case 0xEu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_281;
        }
        goto LABEL_111;
      case 0xFu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_295;
        }
        goto LABEL_111;
      case 0x10u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_310;
        }
        goto LABEL_111;
      case 0x11u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_325;
        }
        goto LABEL_111;
      case 0x12u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_340;
        }
        goto LABEL_111;
      case 0x13u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_355;
        }
        goto LABEL_111;
      case 0x14u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_370;
        }
        goto LABEL_111;
      case 0x15u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_385;
        }
        goto LABEL_111;
      case 0x16u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_400;
        }
        goto LABEL_111;
      case 0x17u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_415;
        }
        goto LABEL_111;
      case 0x18u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_430;
        }
        goto LABEL_111;
      case 0x19u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_445;
        }
        goto LABEL_111;
      case 0x1Au:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_460;
        }
        goto LABEL_111;
      case 0x1Bu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_475;
        }
        goto LABEL_111;
      case 0x1Cu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_490;
        }
        goto LABEL_111;
      case 0x1Du:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_505;
        }
        goto LABEL_111;
      case 0x1Eu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_520;
        }
        goto LABEL_111;
      case 0x1Fu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_535;
        }
        goto LABEL_111;
      case 0x32u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_550;
        }
        goto LABEL_111;
      case 0x33u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_565;
        }
        goto LABEL_111;
      case 0x3Cu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_572;
        }
        goto LABEL_111;
      case 0x3Du:
        int v12 = TagFallback & 7;
        uint64_t v19 = (char *)*((void *)this + 1);
        unint64_t v18 = *((void *)this + 2);
        goto LABEL_587;
      case 0x3Eu:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_111;
        }
        int v27 = *(_DWORD *)(a1 + 400);
        goto LABEL_596;
      case 0x3Fu:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_611;
        }
        goto LABEL_111;
      case 0x40u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_626;
        }
        goto LABEL_111;
      case 0x41u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_641;
        }
        goto LABEL_111;
      case 0x42u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_656;
        }
        goto LABEL_111;
      case 0x43u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_671;
        }
        goto LABEL_111;
      case 0x46u:
        int v12 = TagFallback & 7;
        if (v12 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            uint64_t v21 = (char *)*((void *)this + 1);
            unint64_t v20 = *((void *)this + 2);
            goto LABEL_686;
          }

          goto LABEL_111;
        }

        uint64_t result = sub_10061B0E4(this, v7);
        if (!(_DWORD)result) {
          return result;
        }
        while (1)
        {
          v360 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
          int v372 = *v360;
          if (v372 == 186)
          {
            if (v360[1] != 4) {
              goto LABEL_2;
            }
            *uint64_t v5 = (char *)(v360 + 2);
LABEL_711:
            *(_DWORD *)(a1 + 400) |= 0x400u;
            v373 = *(int **)(a1 + 344);
            if (!v373)
            {
              v373 = (int *)operator new(0x60uLL);
              sub_100614520((uint64_t)v373);
              *(void *)(a1 + 344) = v373;
            }

            v374 = (char *)*((void *)this + 1);
            if ((unint64_t)v374 >= *((void *)this + 2) || *v374 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
                return 0LL;
              }
            }

            else
            {
              v420[0] = *v374;
              *uint64_t v5 = v374 + 1;
            }

            int v375 = *((_DWORD *)this + 14);
            int v376 = *((_DWORD *)this + 15);
            *((_DWORD *)this + 14) = v375 + 1;
            if (v375 >= v376) {
              return 0LL;
            }
            int v377 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v377);
            int v379 = *((_DWORD *)this + 14);
            BOOL v40 = __OFSUB__(v379, 1);
            int v380 = v379 - 1;
            if (v380 < 0 == v40) {
              *((_DWORD *)this + 14) = v380;
            }
            v381 = (unsigned __int8 *)*((void *)this + 1);
            unint64_t v22 = *((void *)this + 2);
            uint64_t v23 = (char *)(v381 + 2);
            *uint64_t v5 = v23;
LABEL_726:
            if ((unint64_t)v23 >= v22 || *v23 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v9);
              if (!(_DWORD)result) {
                return result;
              }
              v382 = (char *)*((void *)this + 1);
              unint64_t v22 = *((void *)this + 2);
            }

            else
            {
              *uint64_t v9 = *v23;
              v382 = v23 + 1;
              *uint64_t v5 = v382;
            }

            *(_DWORD *)(a1 + 400) |= 0x800u;
            goto LABEL_734;
          }

          if (v372 != 176 || v360[1] != 4) {
            goto LABEL_2;
          }
LABEL_685:
          uint64_t v21 = (char *)(v360 + 2);
          *uint64_t v5 = v21;
LABEL_686:
          if ((unint64_t)v21 >= v20 || *v21 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v418)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v418 = *v21;
            *uint64_t v5 = v21 + 1;
          }

          int v361 = *(_DWORD *)(a1 + 336);
          if (v361 == *(_DWORD *)(a1 + 340))
          {
            sub_10004AAFC(v7, v361 + 1);
            int v361 = *(_DWORD *)(a1 + 336);
          }

          unsigned int v362 = v418;
          uint64_t v363 = *(void *)(a1 + 328);
          *(_DWORD *)(a1 + 336) = v361 + 1;
          *(_DWORD *)(v363 + 4LL * v361) = v362;
          int v364 = *(_DWORD *)(a1 + 340) - *(_DWORD *)(a1 + 336);
          if (v364 >= 1)
          {
            int v365 = v364 + 1;
            do
            {
              v366 = (unsigned __int8 *)*((void *)this + 1);
              unint64_t v367 = *((void *)this + 2);
              *uint64_t v5 = (char *)(v366 + 2);
              if ((unint64_t)(v366 + 2) >= v367 || (char)v366[2] < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v418)) {
                  return 0LL;
                }
              }

              else
              {
                unsigned int v418 = v366[2];
                *uint64_t v5 = (char *)(v366 + 3);
              }

              int v368 = *(_DWORD *)(a1 + 336);
              if (v368 >= *(_DWORD *)(a1 + 340))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v420,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Contents /Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/include/go ogle/protobuf/repeated_field.h",  602LL);
                uint64_t v369 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v420,  "CHECK failed: (size()) < (Capacity()): ");
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v419, v369);
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v420);
                int v368 = *(_DWORD *)(a1 + 336);
              }

              unsigned int v370 = v418;
              uint64_t v371 = *(void *)(a1 + 328);
              *(_DWORD *)(a1 + 336) = v368 + 1;
              *(_DWORD *)(v371 + 4LL * v368) = v370;
              --v365;
            }

            while (v365 > 1);
          }
        }

      case 0x47u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_711;
        }
        goto LABEL_111;
      case 0x48u:
        int v12 = TagFallback & 7;
        uint64_t v23 = (char *)*((void *)this + 1);
        unint64_t v22 = *((void *)this + 2);
        goto LABEL_726;
      case 0x49u:
        int v12 = TagFallback & 7;
        if (v12 == 2)
        {
          uint64_t result = sub_10061B0E4(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          while (1)
          {
            v382 = (char *)*((void *)this + 1);
            unint64_t v22 = *((void *)this + 2);
            int v394 = *v382;
            if (v394 == 208)
            {
              if (v382[1] == 4)
              {
                uint64_t v25 = v382 + 2;
                *uint64_t v5 = v25;
LABEL_760:
                if ((unint64_t)v25 >= v22 || *v25 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420);
                  if (!(_DWORD)result) {
                    return result;
                  }
                  unsigned int v395 = v420[0];
                  v396 = (char *)*((void *)this + 1);
                  unint64_t v22 = *((void *)this + 2);
                }

                else
                {
                  unsigned int v395 = *v25;
                  v396 = v25 + 1;
                  *uint64_t v5 = v396;
                }

                *(_BYTE *)(a1 + 368) = v395 != 0;
                *(_DWORD *)(a1 + 400) |= 0x2000u;
                if ((int)v22 - (int)v396 >= 2 && *v396 == 216 && v396[1] == 4)
                {
                  uint64_t v26 = v396 + 2;
                  *uint64_t v5 = v26;
LABEL_769:
                  if ((unint64_t)v26 >= v22 || *v26 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v416);
                    if (!(_DWORD)result) {
                      return result;
                    }
                    v397 = (char *)*((void *)this + 1);
                    unint64_t v22 = *((void *)this + 2);
                  }

                  else
                  {
                    unsigned int *v416 = *v26;
                    v397 = v26 + 1;
                    *uint64_t v5 = v397;
                  }

                  int v28 = *(_DWORD *)(a1 + 400) | 0x4000;
                  *(_DWORD *)(a1 + 400) = v28;
                  if ((int)v22 - (int)v397 >= 2 && *v397 == 226 && v397[1] == 4)
                  {
                    *uint64_t v5 = v397 + 2;
LABEL_778:
                    *(_DWORD *)(a1 + 400) = v28 | 0x8000;
                    v398 = *(void **)(a1 + 376);
                    if (!v398)
                    {
                      v398 = operator new(0x38uLL);
                      sub_1006145AC(v398);
                      *(void *)(a1 + 376) = v398;
                    }

                    v399 = (char *)*((void *)this + 1);
                    if ((unint64_t)v399 >= *((void *)this + 2) || *v399 < 0)
                    {
                      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
                        return 0LL;
                      }
                    }

                    else
                    {
                      v420[0] = *v399;
                      *uint64_t v5 = v399 + 1;
                    }

                    int v400 = *((_DWORD *)this + 14);
                    int v401 = *((_DWORD *)this + 15);
                    *((_DWORD *)this + 14) = v400 + 1;
                    if (v400 >= v401) {
                      return 0LL;
                    }
                    int v402 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
                    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v402);
                    int v404 = *((_DWORD *)this + 14);
                    BOOL v40 = __OFSUB__(v404, 1);
                    int v405 = v404 - 1;
                    if (v405 < 0 == v40) {
                      *((_DWORD *)this + 14) = v405;
                    }
                    v406 = (unsigned __int8 *)*((void *)this + 1);
                    if (*((_DWORD *)this + 4) - (int)v406 > 1 && *v406 == 234 && v406[1] == 4)
                    {
                      *uint64_t v5 = (char *)(v406 + 2);
LABEL_793:
                      *(_DWORD *)(a1 + 400) |= 0x10000u;
                      v407 = *(int **)(a1 + 384);
                      if (!v407)
                      {
                        v407 = (int *)operator new(0x30uLL);
                        sub_10061456C((uint64_t)v407);
                        *(void *)(a1 + 384) = v407;
                      }

                      v408 = (char *)*((void *)this + 1);
                      if ((unint64_t)v408 >= *((void *)this + 2) || *v408 < 0)
                      {
                        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v420)) {
                          return 0LL;
                        }
                      }

                      else
                      {
                        v420[0] = *v408;
                        *uint64_t v5 = v408 + 1;
                      }

                      int v409 = *((_DWORD *)this + 14);
                      int v410 = *((_DWORD *)this + 15);
                      *((_DWORD *)this + 14) = v409 + 1;
                      if (v409 >= v410) {
                        return 0LL;
                      }
                      int v411 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v420[0]);
                      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v411);
                      int v413 = *((_DWORD *)this + 14);
                      BOOL v40 = __OFSUB__(v413, 1);
                      int v414 = v413 - 1;
                      if (v414 < 0 == v40) {
                        *((_DWORD *)this + 14) = v414;
                      }
                      if (*((void *)this + 1) == *((void *)this + 2)
                        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                      {
                        *((_DWORD *)this + 8) = 0;
                        uint64_t result = 1LL;
                        *((_BYTE *)this + 36) = 1;
                        return result;
                      }
                    }
                  }
                }
              }

              goto LABEL_2;
            }

            if (v394 != 200 || v382[1] != 4) {
              goto LABEL_2;
            }
LABEL_734:
            uint64_t v24 = v382 + 2;
            *uint64_t v5 = v24;
LABEL_735:
            if ((unint64_t)v24 >= v22 || *v24 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v418)) {
                return 0LL;
              }
            }

            else
            {
              unsigned int v418 = *v24;
              *uint64_t v5 = v24 + 1;
            }

            int v383 = *(_DWORD *)(a1 + 360);
            if (v383 == *(_DWORD *)(a1 + 364))
            {
              sub_10004AAFC(v6, v383 + 1);
              int v383 = *(_DWORD *)(a1 + 360);
            }

            unsigned int v384 = v418;
            uint64_t v385 = *(void *)(a1 + 352);
            *(_DWORD *)(a1 + 360) = v383 + 1;
            *(_DWORD *)(v385 + 4LL * v383) = v384;
            int v386 = *(_DWORD *)(a1 + 364) - *(_DWORD *)(a1 + 360);
            if (v386 >= 1)
            {
              int v387 = v386 + 1;
              do
              {
                v388 = (unsigned __int8 *)*((void *)this + 1);
                unint64_t v389 = *((void *)this + 2);
                *uint64_t v5 = (char *)(v388 + 2);
                if ((unint64_t)(v388 + 2) >= v389 || (char)v388[2] < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v418)) {
                    return 0LL;
                  }
                }

                else
                {
                  unsigned int v418 = v388[2];
                  *uint64_t v5 = (char *)(v388 + 3);
                }

                int v390 = *(_DWORD *)(a1 + 360);
                if (v390 >= *(_DWORD *)(a1 + 364))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v420,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Conten ts/Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/includ e/google/protobuf/repeated_field.h",  602LL);
                  uint64_t v391 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v420,  "CHECK failed: (size()) < (Capacity()): ");
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v419, v391);
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v420);
                  int v390 = *(_DWORD *)(a1 + 360);
                }

                unsigned int v392 = v418;
                uint64_t v393 = *(void *)(a1 + 352);
                *(_DWORD *)(a1 + 360) = v390 + 1;
                *(_DWORD *)(v393 + 4LL * v390) = v392;
                --v387;
              }

              while (v387 > 1);
            }
          }
        }

        if ((TagFallback & 7) == 0)
        {
          uint64_t v24 = (char *)*((void *)this + 1);
          unint64_t v22 = *((void *)this + 2);
          goto LABEL_735;
        }

void sub_100BB6F14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_100BB6F6C( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 396);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  (unint64_t)a2,  a4);
    int v6 = *(_DWORD *)(v5 + 396);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_36;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 396);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_37;
  }

uint64_t sub_100BB7790(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if (!(_BYTE)v3)
  {
    int v4 = 0;
    goto LABEL_54;
  }

  if ((v3 & 1) != 0)
  {
    int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
       + 1;
    unsigned int v3 = *(_DWORD *)(a1 + 396);
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }

  else
  {
    int v4 = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_11;
    }
  }

  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 396);
  }

  else
  {
    int v6 = 1;
  }

  v4 += v6 + 1;
LABEL_11:
  if ((v3 & 4) != 0)
  {
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }

    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = *(_DWORD *)(a1 + 396);
    }

    else
    {
      int v8 = 1;
    }

    v4 += v8 + 1;
    if ((v3 & 8) == 0)
    {
LABEL_13:
      if ((v3 & 0x10) == 0) {
        goto LABEL_14;
      }
      goto LABEL_30;
    }
  }

  else if ((v3 & 8) == 0)
  {
    goto LABEL_13;
  }

  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9) {
    uint64_t v9 = *(void *)(qword_1019A1D38 + 24);
  }
  uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BBFF64(v9, a2);
  int v11 = (int)v10;
  else {
    int v12 = 1;
  }
  v4 += v11 + v12 + 1;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x10) == 0)
  {
LABEL_14:
    if ((v3 & 0x20) == 0) {
      goto LABEL_15;
    }
    goto LABEL_36;
  }

LABEL_202:
  uint64_t v103 = *(void *)(a1 + 216);
  if (!v103) {
    uint64_t v103 = *(void *)(qword_1019A1D38 + 216);
  }
  int v104 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BCA47C(v103, a2);
  int v105 = (int)v104;
  else {
    int v106 = 1;
  }
  v4 += v105 + v106 + 2;
  unsigned int v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x10000000) == 0)
  {
LABEL_180:
    if ((v3 & 0x20000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_214;
  }

          *(void *)(a1 + 8) = v37;
          break;
        case 'f':
          *(_DWORD *)(a1 + 68) |= 0x100000u;
          uint64_t v2 = *((void *)this + 1);
          if (v2 >= *((void *)this + 2))
          {
            int v40 = 0;
            *((_BYTE *)this + 24) = 1;
          }

          else
          {
            int v39 = *(unsigned __int8 *)(*(void *)this + v2++);
            *((void *)this + 1) = v2;
            int v40 = v39 != 0;
          }

          *(_BYTE *)(a1 + 65) = v40;
          break;
        case 'g':
          *(_DWORD *)(a1 + 68) |= 0x80000u;
          uint64_t v2 = *((void *)this + 1);
          if (v2 >= *((void *)this + 2))
          {
            uint64_t v30 = 0;
            *((_BYTE *)this + 24) = 1;
          }

          else
          {
            uint64_t v29 = *(unsigned __int8 *)(*(void *)this + v2++);
            *((void *)this + 1) = v2;
            uint64_t v30 = v29 != 0;
          }

          *(_BYTE *)(a1 + 64) = v30;
          break;
        default:
LABEL_64:
          uint64_t result = PB::Reader::skip(this, v20, v11 & 7, 0);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v2 = *((void *)this + 1);
          break;
      }
    }

    else
    {
      switch((_DWORD)v20)
      {
        case 1:
          *(_DWORD *)(a1 + 68) |= 4u;
          uint64_t v2 = *((void *)this + 1);
          if (v2 <= 0xFFFFFFFFFFFFFFFBLL && v2 + 4 <= *((void *)this + 2))
          {
            *(_DWORD *)(a1 + 20) = *(_DWORD *)(*(void *)this + v2);
            goto LABEL_197;
          }

          break;
        case 2:
          *(_DWORD *)(a1 + 68) |= 2u;
          uint64_t v2 = *((void *)this + 1);
          if (v2 <= 0xFFFFFFFFFFFFFFFBLL && v2 + 4 <= *((void *)this + 2))
          {
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(*(void *)this + v2);
            goto LABEL_197;
          }

          break;
        case 3:
          *(_DWORD *)(a1 + 68) |= 8u;
          uint64_t v2 = *((void *)this + 1);
          if (v2 <= 0xFFFFFFFFFFFFFFFBLL && v2 + 4 <= *((void *)this + 2))
          {
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(*(void *)this + v2);
LABEL_197:
            uint64_t v2 = *((void *)this + 1) + 4LL;
            *((void *)this + 1) = v2;
            goto LABEL_238;
          }

          break;
        default:
          goto LABEL_64;
      }

      *((_BYTE *)this + 24) = 1;
    }

  uint64_t result = *(float *)(a2 + 100);
  v5 |= 0x8000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(float *)(a1 + 100) = result;
  int v4 = *v3;
  uint64_t v7 = *(void *)(a2 + 364);
  if ((*v3 & 0x40000000000LL) == 0)
  {
LABEL_97:
    if ((v4 & 0x10000000000LL) == 0) {
      goto LABEL_98;
    }
    goto LABEL_204;
  }

  PB::TextFormatter::format(this, "stepsCountThreshold", *(_DWORD *)(a1 + 280));
  uint64_t v7 = *v5;
  if ((*v5 & 0x2000000000000000LL) == 0)
  {
LABEL_101:
    if ((v7 & 0x4000000000000000LL) == 0) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 100), 0x515u);
  uint64_t v5 = *v4;
  int v6 = v4[1];
  if ((*v4 & 0x40000000000LL) == 0)
  {
LABEL_97:
    if ((v5 & 0x10000000000LL) == 0) {
      goto LABEL_98;
    }
    goto LABEL_204;
  }

          *(_DWORD *)(a1 + 84) = v96;
          goto LABEL_224;
        case 9u:
          *(_BYTE *)(a1 + 104) |= 0x20u;
          uint64_t v99 = *((void *)this + 1);
          int v100 = *((void *)this + 2);
          int v101 = *(void *)this;
          if (v99 <= 0xFFFFFFFFFFFFFFF5LL && v99 + 10 <= v100)
          {
            int v102 = 0;
            uint64_t v103 = 0;
            int v104 = 0LL;
            do
            {
              int v105 = v99 + 1;
              *((void *)this + 1) = v99 + 1;
              int v106 = *(_BYTE *)(v101 + v99);
              v104 |= (unint64_t)(v106 & 0x7F) << v102;
              if ((v106 & 0x80) == 0) {
                goto LABEL_205;
              }
              v102 += 7;
              uint64_t v99 = v105;
              uint64_t v21 = v103++ > 8;
            }

            while (!v21);
LABEL_163:
            LODWORD(v104) = 0;
            goto LABEL_205;
          }

          int v132 = 0;
          v133 = 0;
          int v104 = 0LL;
          if (v100 <= v99) {
            int v100 = *((void *)this + 1);
          }
          while (2)
          {
            if (v100 == v99)
            {
              LODWORD(v104) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              int v134 = v99 + 1;
              uint64_t v135 = *(_BYTE *)(v101 + v99);
              *((void *)this + 1) = v134;
              v104 |= (unint64_t)(v135 & 0x7F) << v132;
              if (v135 < 0)
              {
                v132 += 7;
                uint64_t v99 = v134;
                uint64_t v21 = v133++ > 8;
                if (v21) {
                  goto LABEL_163;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v104) = 0;
              }
            }

            break;
          }

        *(_DWORD *)(a1 + 208) = v106;
        goto LABEL_203;
      case 0x25u:
        *(_DWORD *)(a1 + 244) |= 0x20u;
        int v109 = *((void *)this + 1);
        if (v109 > 0xFFFFFFFFFFFFFFF7LL || v109 + 8 > *((void *)this + 2)) {
          goto LABEL_134;
        }
        *(void *)(a1 + memset(v19, 0, 48) = *(void *)(*(void *)this + v109);
        goto LABEL_185;
      case 0x26u:
        *(_DWORD *)(a1 + 244) |= 4u;
        int v110 = *((void *)this + 1);
        if (v110 <= 0xFFFFFFFFFFFFFFF7LL && v110 + 8 <= *((void *)this + 2))
        {
          *(void *)(a1 + 24) = *(void *)(*(void *)this + v110);
LABEL_185:
          int v84 = *((void *)this + 1) + 8LL;
LABEL_186:
          *((void *)this + 1) = v84;
        }

        else
        {
LABEL_134:
          *((_BYTE *)this + 24) = 1;
        }

        goto LABEL_203;
      case 0x27u:
        int v56 = operator new(0x38uLL);
        *(void *)int v56 = &off_10189DA68;
        v56[13] = 0;
        uint64_t v111 = *(void *)(a1 + 136);
        *(void *)(a1 + 136) = v56;
        if (v111)
        {
          (*(void (**)(uint64_t))(*(void *)v111 + 8LL))(v111);
          int v56 = *(_DWORD **)(a1 + 136);
        }

        goto LABEL_139;
      case 0x28u:
        int v56 = operator new(0x100uLL);
        *(void *)int v56 = &off_10189DA30;
        v56[62] = 0;
        int v112 = *(void *)(a1 + 128);
        *(void *)(a1 + 1sub_100231C10(v1 + 28) = v56;
        if (v112)
        {
          (*(void (**)(uint64_t))(*(void *)v112 + 8LL))(v112);
          int v56 = *(_DWORD **)(a1 + 128);
        }

LABEL_234:
  int v122 = *(_DWORD *)(a1 + 400);
  if (!(_BYTE)v122) {
    goto LABEL_293;
  }
  if ((v122 & 1) != 0)
  {
    uint64_t v123 = *(void *)(a1 + 256);
    int v124 = *(unsigned __int8 *)(v123 + 23);
    char v125 = v124;
    uint64_t v126 = *(void *)(v123 + 8);
    if ((v124 & 0x80u) == 0) {
      unint64_t v127 = *(unsigned __int8 *)(v123 + 23);
    }
    else {
      unint64_t v127 = v126;
    }
    if (v127 >= 0x80)
    {
      int v128 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v127,  a2);
      int v124 = *(unsigned __int8 *)(v123 + 23);
      uint64_t v126 = *(void *)(v123 + 8);
      int v122 = *(_DWORD *)(a1 + 400);
      char v125 = *(_BYTE *)(v123 + 23);
    }

    else
    {
      int v128 = 1;
    }

    if (v125 < 0) {
      int v124 = v126;
    }
    v4 += v128 + v124 + 2;
    if ((v122 & 2) == 0)
    {
LABEL_237:
      if ((v122 & 4) == 0) {
        goto LABEL_238;
      }
      goto LABEL_259;
    }
  }

  else if ((v122 & 2) == 0)
  {
    goto LABEL_237;
  }

  unsigned int v129 = *(unsigned int **)(a1 + 264);
  if (!v129) {
    unsigned int v129 = *(unsigned int **)(qword_1019A1D38 + 264);
  }
  int v130 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1006211B8(v129, a2);
  int v131 = (int)v130;
  else {
    int v132 = 1;
  }
  v4 += v131 + v132 + 2;
  int v122 = *(_DWORD *)(a1 + 400);
  if ((v122 & 4) == 0)
  {
LABEL_238:
    if ((v122 & 8) == 0) {
      goto LABEL_239;
    }
    goto LABEL_263;
  }

LABEL_328:
  if ((v122 & 0x10000) != 0)
  {
    uint64_t v171 = *(void *)(a1 + 384);
    if (!v171) {
      uint64_t v171 = *(void *)(qword_1019A1D38 + 384);
    }
    int v172 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10061A2AC(v171, a2);
    int v173 = (int)v172;
    else {
      int v174 = 1;
    }
    v4 += v173 + v174 + 2;
  }

  int v175 = *(_DWORD *)(a1 + 336);
  if (v175 < 1)
  {
    int v177 = 0;
  }

  else
  {
    uint64_t v176 = 0LL;
    int v177 = 0;
    do
    {
      if (v178 >= 0x80)
      {
        int v179 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v178, a2);
        int v175 = *(_DWORD *)(a1 + 336);
      }

      else
      {
        int v179 = 1;
      }

      v177 += v179;
      ++v176;
    }

    while (v176 < v175);
  }

  int v180 = *(_DWORD *)(a1 + 360);
  if (v180 < 1)
  {
    int v182 = 0;
  }

  else
  {
    uint64_t v181 = 0LL;
    int v182 = 0;
    do
    {
      if (v183 >= 0x80)
      {
        int v184 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v183, a2);
        int v180 = *(_DWORD *)(a1 + 360);
      }

      else
      {
        int v184 = 1;
      }

      v182 += v184;
      ++v181;
    }

    while (v181 < v180);
  }

  uint64_t result = (v177 + v4 + v182 + 2 * (v180 + v175));
  *(_DWORD *)(a1 + 392) = result;
  return result;
}

void sub_100BB85B8(uint64_t a1, void *lpsrc)
{
}

void sub_100BB8604(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v12,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  5698LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v12,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      *(_DWORD *)(a1 + 36) |= 1u;
      int v6 = *(void **)(a1 + 8);
      if (!v6)
      {
        int v6 = operator new(0x68uLL);
        sub_10050107C((uint64_t)v6);
        *(void *)(a1 + 8) = v6;
      }

      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_1019A1D78 + 8);
      }
      sub_1005011EC((uint64_t)v6, v7);
      int v5 = *(_DWORD *)(a2 + 36);
    }

    if ((v5 & 2) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 16);
      if (!sub_10006ED58(v8)) {
        sub_101264C18();
      }
      *(_DWORD *)(a1 + 36) |= 2u;
      *(_DWORD *)(a1 + 16) = v8;
      int v5 = *(_DWORD *)(a2 + 36);
    }

    if ((v5 & 4) != 0)
    {
      char v9 = *(_BYTE *)(a2 + 20);
      *(_DWORD *)(a1 + 36) |= 4u;
      *(_BYTE *)(a1 + 20) = v9;
      int v5 = *(_DWORD *)(a2 + 36);
    }

    if ((v5 & 8) != 0)
    {
      uint64_t v10 = *(void *)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 8u;
      *(void *)(a1 + 24) = v10;
    }
  }

void sub_100BB872C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100BB8754(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  5939LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v7;
      int v5 = *(_DWORD *)(a2 + 36);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    uint64_t v8 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(void *)(a1 + 16) = v8;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return;
    }
LABEL_7:
    uint64_t v6 = *(void *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(void *)(a1 + 24) = v6;
  }

void sub_100BB8824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB883C(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6445LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 8) + 8 * v5);
      int v7 = a1[5];
      uint64_t v8 = (int)a1[4];
      if ((int)v8 >= v7)
      {
        if (v7 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  v7 + 1);
          int v7 = a1[5];
        }

        a1[5] = v7 + 1;
        uint64_t v10 = sub_100BCA598();
        uint64_t v11 = *((void *)a1 + 1);
        uint64_t v12 = (int)a1[4];
        a1[4] = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *((void *)a1 + 1);
        a1[4] = v8 + 1;
        uint64_t v10 = *(void **)(v9 + 8 * v8);
      }

      sub_100504A5C((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 16));
  }

void sub_100BB8960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB8978(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6605LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 8) + 8 * v5);
      int v7 = a1[5];
      uint64_t v8 = (int)a1[4];
      if ((int)v8 >= v7)
      {
        if (v7 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  v7 + 1);
          int v7 = a1[5];
        }

        a1[5] = v7 + 1;
        uint64_t v10 = sub_100BCA5D8();
        uint64_t v11 = *((void *)a1 + 1);
        uint64_t v12 = (int)a1[4];
        a1[4] = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *((void *)a1 + 1);
        a1[4] = v8 + 1;
        uint64_t v10 = *(void **)(v9 + 8 * v8);
      }

      sub_100504E28((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 16));
  }

void sub_100BB8A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB8AB4(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6765LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 8) + 8 * v5);
      int v7 = a1[5];
      uint64_t v8 = (int)a1[4];
      if ((int)v8 >= v7)
      {
        if (v7 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  v7 + 1);
          int v7 = a1[5];
        }

        a1[5] = v7 + 1;
        uint64_t v10 = sub_100BCA5D8();
        uint64_t v11 = *((void *)a1 + 1);
        uint64_t v12 = (int)a1[4];
        a1[4] = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *((void *)a1 + 1);
        a1[4] = v8 + 1;
        uint64_t v10 = *(void **)(v9 + 8 * v8);
      }

      sub_100504E28((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 16));
  }

void sub_100BB8BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100BB8BF0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6986LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 36);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + 24) = result;
  }

  return result;
}

void sub_100BB8CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB8CD8(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v20,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  7513LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v20,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v19, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v20);
  }

  int v5 = *(_DWORD *)(a2 + 76);
  if (!(_BYTE)v5) {
    goto LABEL_13;
  }
  if ((v5 & 1) != 0)
  {
    uint64_t v8 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 76) |= 1u;
    *(void *)(a1 + 8) = v8;
    int v5 = *(_DWORD *)(a2 + 76);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_23;
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_6;
  }

  uint64_t v9 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 76) |= 2u;
  *(void *)(a1 + 16) = v9;
  int v5 = *(_DWORD *)(a2 + 76);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }

void sub_100BB8EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB8F0C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  7832LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 32);
    }

    if ((v5 & 2) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 16);
      if (!sub_100501188(v7)) {
        sub_101264C90();
      }
      *(_DWORD *)(a1 + 32) |= 2u;
      *(_DWORD *)(a1 + 16) = v7;
      int v5 = *(_DWORD *)(a2 + 32);
    }

    if ((v5 & 4) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 20);
      if (!sub_1001D2F54(v8)) {
        sub_101264C68();
      }
      *(_DWORD *)(a1 + 32) |= 4u;
      *(_DWORD *)(a1 + 20) = v8;
      int v5 = *(_DWORD *)(a2 + 32);
    }

    if ((v5 & 8) != 0)
    {
      unsigned int v9 = *(_DWORD *)(a2 + 24);
      if (!sub_100501194(v9)) {
        sub_101264C40();
      }
      *(_DWORD *)(a1 + 32) |= 8u;
      *(_DWORD *)(a1 + 24) = v9;
    }
  }

void sub_100BB9024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB903C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  8045LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 24);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 16);
      if (!sub_10006417C(v7)) {
        sub_101264CB8();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v7;
    }
  }

void sub_100BB90F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB910C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  8219LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if ((sub_1005011D4(v5) & 1) == 0) {
      sub_101264CE0();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
  }

void sub_100BB91A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100BB91BC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  8473LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 44);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 44) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 44) |= 1u;
      *(void *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 44);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }

    else if ((*(_BYTE *)(a2 + 44) & 2) == 0)
    {
      goto LABEL_6;
    }

    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 44) |= 2u;
    *(double *)(a1 + 16) = result;
    int v6 = *(_DWORD *)(a2 + 44);
    if ((v6 & 4) == 0)
    {
LABEL_7:
      if ((v6 & 8) == 0) {
        return result;
      }
      goto LABEL_8;
    }

void sub_100BB92AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100BB92C4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  8710LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 36);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + 24) = result;
  }

  return result;
}

void sub_100BB9394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB93AC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  5092LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      int v6 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      uint64_t v7 = *(std::string **)(a1 + 8);
      if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        uint64_t v7 = (std::string *)operator new(0x18uLL);
        v7->__r_.__value_.__l.__size_ = 0LL;
        v7->__r_.__value_.__l.__cap_ = 0LL;
        v7->__r_.__value_.__r.__words[0] = 0LL;
        *(void *)(a1 + 8) = v7;
      }

      std::string::operator=(v7, v6);
      int v5 = *(_DWORD *)(a2 + 24);
    }

    if ((v5 & 2) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 16);
      if (v8 >= 3) {
        sub_101264D08();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v8;
    }
  }

void sub_100BB9494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB94AC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  5269LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    int v5 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    int v6 = *(std::string **)(a1 + 8);
    if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v6 = (std::string *)operator new(0x18uLL);
      v6->__r_.__value_.__l.__size_ = 0LL;
      v6->__r_.__value_.__l.__cap_ = 0LL;
      v6->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a1 + 8) = v6;
    }

    std::string::operator=(v6, v5);
  }

void sub_100BB9560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9578(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  5433LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 8) + 8 * v5);
      int v7 = a1[5];
      uint64_t v8 = (int)a1[4];
      if ((int)v8 >= v7)
      {
        if (v7 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2),  v7 + 1);
          int v7 = a1[5];
        }

        a1[5] = v7 + 1;
        char v10 = sub_100BCA558();
        uint64_t v11 = *((void *)a1 + 1);
        uint64_t v12 = (int)a1[4];
        a1[4] = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *((void *)a1 + 1);
        a1[4] = v8 + 1;
        char v10 = *(_DWORD **)(v9 + 8 * v8);
      }

      sub_10050534C(v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 16));
  }

void sub_100BB969C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB96B4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6114LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    *(void *)(a1 + 8) = v5;
  }

void sub_100BB973C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9754(uint64_t a1, _BYTE *a2)
{
  if (a2 == (_BYTE *)a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v13,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  4865LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v13,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v12, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = a2[20];
  if ((_BYTE)v5)
  {
    if ((a2[20] & 1) != 0)
    {
      char v7 = a2[8];
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_BYTE *)(a1 + 8) = v7;
      int v5 = *((_DWORD *)a2 + 5);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }

    else if ((a2[20] & 2) == 0)
    {
      goto LABEL_6;
    }

    char v8 = a2[9];
    *(_DWORD *)(a1 + 20) |= 2u;
    *(_BYTE *)(a1 + 9) = v8;
    int v5 = *((_DWORD *)a2 + 5);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_15;
    }

void sub_100BB9884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB989C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  6281LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    *(void *)(a1 + 8) = v5;
  }

void sub_100BB9924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB993C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  9116LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      char v6 = *(_BYTE *)(a2 + 8);
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_BYTE *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 20);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(_DWORD *)(a1 + 12) = v7;
    }
  }

void sub_100BB99E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB99FC(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  9318LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[5] |= 1u;
      a1[2] = v6;
      int v5 = *(_DWORD *)(a2 + 20);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 12);
      a1[5] |= 2u;
      a1[3] = v7;
    }
  }

void sub_100BB9AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9ABC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  9685LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    char v5 = *(_BYTE *)(a2 + 8);
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_BYTE *)(a1 + 8) = v5;
  }

void sub_100BB9B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9B5C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  9858LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    char v5 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    char v6 = *(std::string **)(a1 + 8);
    if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      char v6 = (std::string *)operator new(0x18uLL);
      v6->__r_.__value_.__l.__size_ = 0LL;
      v6->__r_.__value_.__l.__cap_ = 0LL;
      v6->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a1 + 8) = v6;
    }

    std::string::operator=(v6, v5);
  }

void sub_100BB9C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9C28(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  10031LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    char v5 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    char v6 = *(std::string **)(a1 + 8);
    if (v6 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      char v6 = (std::string *)operator new(0x18uLL);
      v6->__r_.__value_.__l.__size_ = 0LL;
      v6->__r_.__value_.__l.__cap_ = 0LL;
      v6->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a1 + 8) = v6;
    }

    std::string::operator=(v6, v5);
  }

void sub_100BB9CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9CF4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v18,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  12565LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v18,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v17, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v18);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 56);
  if (!(_BYTE)v5) {
    return;
  }
  if ((*(_BYTE *)(a2 + 56) & 1) != 0)
  {
    char v6 = *(_BYTE *)(a2 + 8);
    *(_DWORD *)(a1 + 56) |= 1u;
    *(_BYTE *)(a1 + 8) = v6;
    int v5 = *(_DWORD *)(a2 + 56);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
  }

  else if ((*(_BYTE *)(a2 + 56) & 2) == 0)
  {
    goto LABEL_6;
  }

  int v7 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 56) |= 2u;
  *(_DWORD *)(a1 + 12) = v7;
  int v5 = *(_DWORD *)(a2 + 56);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }

void sub_100BB9F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BB9F5C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  13993LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      char v7 = *(_BYTE *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_BYTE *)(a1 + 16) = v7;
      int v5 = *(_DWORD *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }

    else if ((*(_BYTE *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }

    char v8 = *(_BYTE *)(a2 + 17);
    *(_DWORD *)(a1 + 24) |= 2u;
    *(_BYTE *)(a1 + 17) = v8;
    int v5 = *(_DWORD *)(a2 + 24);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }

void sub_100BBA04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBA064(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  12759LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v5 >= 7) {
      sub_101264D58();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
  }

void sub_100BBA0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBA110(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  8916LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 24);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v7;
    }
  }

void sub_100BBA1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBA1D0(uint64_t a1, _BYTE *a2)
{
  if (a2 == (_BYTE *)a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  9516LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = a2[16];
  if ((_BYTE)v5)
  {
    if ((a2[16] & 1) != 0)
    {
      char v6 = a2[8];
      *(_DWORD *)(a1 + 16) |= 1u;
      *(_BYTE *)(a1 + 8) = v6;
      int v5 = *((_DWORD *)a2 + 4);
    }

    if ((v5 & 2) != 0)
    {
      char v7 = a2[9];
      *(_DWORD *)(a1 + 16) |= 2u;
      *(_BYTE *)(a1 + 9) = v7;
    }
  }

void sub_100BBA278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100BBA290()
{
  return 1LL;
}

void *sub_100BBA298@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.Request");
}

void sub_100BBA2A8(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  2794LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 16);
      if ((sub_100BB1E1C(v6) & 1) == 0) {
        sub_101264DA8();
      }
      *(_DWORD *)(a1 + 28) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      int v5 = *(_DWORD *)(a2 + 28);
    }

    if ((v5 & 2) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 28) |= 2u;
      *(void *)(a1 + 8) = v7;
      int v5 = *(_DWORD *)(a2 + 28);
    }

    if ((v5 & 4) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 20);
      if (!sub_100501188(v8)) {
        sub_101264D80();
      }
      *(_DWORD *)(a1 + 28) |= 4u;
      *(_DWORD *)(a1 + 20) = v8;
    }
  }

void sub_100BBA394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBA3AC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875348;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBA3BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875348;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BBA3DC()
{
  double result = operator new(0x20uLL);
  *double result = off_101875348;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100BBA404(uint64_t result)
{
  if (*(_BYTE *)(result + 28))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + sub_100231C10(v1 + 28) = 0;
  return result;
}

uint64_t sub_100BBA418( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unint64_t *)(a1 + 2);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v6 = (char *)*((void *)this + 1);
        if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v6 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v8 = TagFallback >> 3;
        int v9 = TagFallback & 7;
        uint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v20);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = v20;
        }

        else
        {
          unsigned int v13 = *v12;
          *((void *)this + 1) = v12 + 1;
        }

        if (sub_100BB1E1C(v13))
        {
          a1[7] |= 1u;
          a1[4] = v13;
        }

        char v15 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v15 < v10 && *v15 == 16)
        {
          uint64_t v14 = v15 + 1;
          *((void *)this + 1) = v14;
          goto LABEL_29;
        }
      }

      if (v8 != 2) {
        break;
      }
      int v9 = TagFallback & 7;
      uint64_t v14 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
LABEL_29:
      if ((unint64_t)v14 >= v10 || *v14 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v16 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }

      else
      {
        *int v5 = *v14;
        uint64_t v16 = v14 + 1;
        *((void *)this + 1) = v16;
      }

      a1[7] |= 2u;
      if ((unint64_t)v16 < v10 && *v16 == 24)
      {
        char v11 = v16 + 1;
        *((void *)this + 1) = v11;
LABEL_37:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v19;
        }

        else
        {
          unsigned int v17 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        if (sub_100501188(v17))
        {
          if (!sub_100501188(v17)) {
            sub_101264D80();
          }
          a1[7] |= 4u;
          a1[5] = v17;
        }

        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v8 == 3)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        char v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_37;
      }
    }

    else
    {
      int v9 = TagFallback & 7;
    }

uint64_t sub_100BBA660( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 16),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 28);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(_DWORD *)(v5 + 20),  a2,  a4);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(v5 + 8),  a2,  a4);
  if ((*(_DWORD *)(v5 + 28) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(_DWORD *)(v5 + 20),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BBA6D8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_21;
  }

  if ((*(_BYTE *)(a1 + 28) & 1) == 0)
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 28) & 2) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v4 = 11LL;
    if ((v3 & 2) != 0) {
      goto LABEL_13;
    }
  }

  else
  {
    if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 28);
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }

    uint64_t v4 = 2LL;
    if ((v3 & 2) != 0)
    {
LABEL_13:
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 28);
    }
  }

void sub_100BBA798(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BBA7E4()
{
  return 1LL;
}

void *sub_100BBA7EC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.Response");
}

void sub_100BBA7FC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v60,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  4132LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v60,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v59, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v60);
  }

  unsigned int v5 = *(_DWORD *)(a2 + 224);
  if ((_BYTE)v5)
  {
    if ((v5 & 1) != 0)
    {
      unsigned int v6 = *(_DWORD *)(a2 + 8);
      if (v6 - 9 >= 0x13 && v6 >= 6) {
        sub_101264E70();
      }
      *(_DWORD *)(a1 + 224) |= 1u;
      *(_DWORD *)(a1 + 8) = v6;
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 2) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 12);
      if ((sub_100BB1E1C(v8) & 1) == 0) {
        sub_101264E48();
      }
      *(_DWORD *)(a1 + 224) |= 2u;
      *(_DWORD *)(a1 + 12) = v8;
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 4) != 0)
    {
      uint64_t v9 = *(void *)(a2 + 16);
      *(_DWORD *)(a1 + 224) |= 4u;
      *(void *)(a1 + 16) = v9;
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 8) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 8u;
      unint64_t v10 = *(void **)(a1 + 24);
      if (!v10)
      {
        unint64_t v10 = operator new(0x38uLL);
        sub_1005010A8((uint64_t)v10);
        *(void *)(a1 + 24) = v10;
      }

      uint64_t v11 = *(void *)(a2 + 24);
      if (!v11) {
        uint64_t v11 = *(void *)(qword_1019A1D48 + 24);
      }
      sub_100502D10((uint64_t)v10, v11);
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 0x10) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x10u;
      uint64_t v12 = *(void **)(a1 + 32);
      if (!v12)
      {
        uint64_t v12 = operator new(0x88uLL);
        sub_100A408F0((uint64_t)v12);
        *(void *)(a1 + 32) = v12;
      }

      uint64_t v13 = *(void *)(a2 + 32);
      if (!v13) {
        uint64_t v13 = *(void *)(qword_1019A1D48 + 32);
      }
      sub_100A59750((uint64_t)v12, v13);
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 0x20) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x20u;
      uint64_t v14 = *(void **)(a1 + 40);
      if (!v14)
      {
        uint64_t v14 = operator new(0x38uLL);
        sub_100501130((uint64_t)v14);
        *(void *)(a1 + 40) = v14;
      }

      uint64_t v15 = *(void *)(a2 + 40);
      if (!v15) {
        uint64_t v15 = *(void *)(qword_1019A1D48 + 40);
      }
      sub_100505A4C((uint64_t)v14, v15);
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x40u;
      uint64_t v16 = *(_DWORD **)(a1 + 48);
      if (!v16)
      {
        uint64_t v16 = operator new(0x28uLL);
        v16[7] = 0;
        _BYTE v16[8] = 0;
        *((void *)v16 + 1) = 0LL;
        *((void *)v16 + 2) = 0LL;
        *(void *)uint64_t v16 = off_101875438;
        *(_DWORD *)((char *)v16 + 23) = 0;
        *(void *)(a1 + memset(v19, 0, 48) = v16;
      }

      uint64_t v17 = *(void *)(a2 + 48);
      if (!v17) {
        uint64_t v17 = *(void *)(qword_1019A1D48 + 48);
      }
      sub_100BBDF9C((uint64_t)v16, v17);
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }

    if ((v5 & 0x80) != 0)
    {
      *(_DWORD *)(a1 + 224) |= 0x80u;
      char v18 = *(void **)(a1 + 56);
      if (!v18)
      {
        char v18 = operator new(0x38uLL);
        sub_1005010C8((uint64_t)v18);
        *(void *)(a1 + 56) = v18;
      }

      uint64_t v19 = *(void *)(a2 + 56);
      if (!v19) {
        uint64_t v19 = *(void *)(qword_1019A1D48 + 56);
      }
      sub_100504220((uint64_t)v18, v19);
      unsigned int v5 = *(_DWORD *)(a2 + 224);
    }
  }

  if ((v5 & 0xFF00) == 0) {
    goto LABEL_89;
  }
  if ((v5 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 224) |= 0x100u;
    unsigned int v20 = *(void **)(a1 + 64);
    if (!v20)
    {
      unsigned int v20 = operator new(0x30uLL);
      v20[1] = 0LL;
      void v20[2] = 0LL;
      *unsigned int v20 = off_101876158;
      *((_DWORD *)v20 + 6) = 0;
      v20[4] = 0LL;
      v20[5] = 0LL;
      *(void *)(a1 + 64) = v20;
    }

    uint64_t v21 = *(void *)(a2 + 64);
    if (!v21) {
      uint64_t v21 = *(void *)(qword_1019A1D48 + 64);
    }
    sub_100BBE0C4((uint64_t)v20, v21);
    unsigned int v5 = *(_DWORD *)(a2 + 224);
    if ((v5 & 0x200) == 0)
    {
LABEL_48:
      if ((v5 & 0x400) == 0) {
        goto LABEL_49;
      }
      goto LABEL_65;
    }
  }

  else if ((v5 & 0x200) == 0)
  {
    goto LABEL_48;
  }

  *(_DWORD *)(a1 + 224) |= 0x200u;
  uint64_t v22 = *(void **)(a1 + 72);
  if (!v22)
  {
    uint64_t v22 = operator new(0x18uLL);
    void *v22 = off_1018761D0;
    v22[1] = 0LL;
    *((_DWORD *)v22 + 4) = 0;
    *(void *)(a1 + 72) = v22;
  }

  uint64_t v23 = *(void *)(a2 + 72);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_1019A1D48 + 72);
  }
  sub_100BBE280((uint64_t)v22, v23);
  unsigned int v5 = *(_DWORD *)(a2 + 224);
  if ((v5 & 0x400) == 0)
  {
LABEL_49:
    if ((v5 & 0x800) == 0) {
      goto LABEL_50;
    }
    goto LABEL_70;
  }

void sub_100BBB0A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100BBB108(void *a1)
{
  uint64_t v2 = a1[17];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    operator delete((void *)v2);
  }

  if ((void *)qword_1019A1D48 != a1)
  {
    uint64_t v4 = a1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = a1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    uint64_t v6 = a1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    uint64_t v7 = a1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    uint64_t v8 = a1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    uint64_t v9 = a1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
    uint64_t v10 = a1[9];
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
    uint64_t v11 = a1[10];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
    uint64_t v12 = a1[11];
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    uint64_t v13 = a1[13];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
    uint64_t v14 = a1[14];
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    }
    uint64_t v15 = a1[15];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    uint64_t v16 = a1[16];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    uint64_t v17 = a1[18];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    }
    uint64_t v18 = a1[19];
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    uint64_t v19 = a1[20];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    }
    uint64_t v20 = a1[21];
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    }
    uint64_t v21 = a1[22];
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
    uint64_t v22 = a1[23];
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
    }
    uint64_t v23 = a1[24];
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    }
    uint64_t v24 = a1[26];
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
  }

void sub_100BBB310(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018753C0;
  sub_100BBB108(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBB340(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018753C0;
  sub_100BBB108(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

double sub_100BBB374()
{
  unsigned __int8 v0 = (char *)operator new(0xE8uLL);
  *(void *)unsigned __int8 v0 = off_1018753C0;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *((void *)v0 + 17) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *((_DWORD *)v0 + 55) = 0;
  *((_DWORD *)v0 + 56) = 0;
  *((_OWORD *)v0 + 9) = 0u;
  *((_OWORD *)v0 + 10) = 0u;
  *((_OWORD *)v0 + 11) = 0u;
  *((_OWORD *)v0 + 12) = 0u;
  *(_OWORD *)(v0 + 204) = 0u;
  return result;
}

uint64_t sub_100BBB3D8(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)(result + 224);
  if ((_BYTE)v2)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    if ((v2 & 8) != 0)
    {
      double result = *(void *)(result + 24);
      if (result)
      {
        double result = sub_100503054(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x10) != 0)
    {
      double result = *(void *)(v1 + 32);
      if (result)
      {
        double result = sub_100A59D70(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x20) != 0)
    {
      double result = *(void *)(v1 + 40);
      if (result)
      {
        double result = sub_100505C10(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x40) != 0)
    {
      uint64_t v3 = *(void *)(v1 + 48);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 32))
        {
          *(void *)(v3 + 8) = 0LL;
          *(void *)(v3 + 16) = 0LL;
          *(_DWORD *)(v3 + 23) = 0;
        }

        *(_DWORD *)(v3 + 32) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x80) != 0)
    {
      double result = *(void *)(v1 + 56);
      if (result)
      {
        double result = sub_100504450(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }

  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      double result = *(void *)(v1 + 64);
      if (result)
      {
        double result = sub_100BBB658(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x200) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 72);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 16)) {
          *(_DWORD *)(v4 + 8) = 0;
        }
        *(_DWORD *)(v4 + 16) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x400) != 0)
    {
      double result = *(void *)(v1 + 80);
      if (result)
      {
        double result = sub_100506640(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x800) != 0)
    {
      double result = *(void *)(v1 + 88);
      if (result)
      {
        double result = sub_1005061C0(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    *(void *)(v1 + 96) = 0LL;
    if ((v2 & 0x4000) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 104);
      if (v5)
      {
        if (*(_BYTE *)(v5 + 16)) {
          *(_BYTE *)(v5 + 8) = 0;
        }
        *(_DWORD *)(v5 + 16) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x8000) != 0)
    {
      uint64_t v6 = *(void *)(v1 + 112);
      if (v6)
      {
        if (*(_BYTE *)(v6 + 24))
        {
          *(void *)(v6 + 8) = 0LL;
          *(_DWORD *)(v6 + 16) = 0;
        }

        *(_DWORD *)(v6 + 24) = 0;
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }

  if ((v2 & 0xFF0000) != 0)
  {
    if ((v2 & 0x10000) != 0)
    {
      double result = *(void *)(v1 + 120);
      if (result)
      {
        double result = sub_100BBB714(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x20000) != 0)
    {
      double result = *(void *)(v1 + 128);
      if (result)
      {
        double result = sub_100615258(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x40000) != 0)
    {
      uint64_t v7 = *(void *)(v1 + 136);
      if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(_BYTE **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v7 = 0;
          *(_BYTE *)(v7 + 23) = 0;
        }
      }
    }

    unsigned int v2 = *(_DWORD *)(v1 + 224);
    if ((v2 & 0x80000) != 0)
    {
      double result = *(void *)(v1 + 144);
      if (result)
      {
        double result = sub_10062EE90(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x100000) != 0)
    {
      double result = *(void *)(v1 + 152);
      if (result)
      {
        double result = sub_100633CF8(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x200000) != 0)
    {
      double result = *(void *)(v1 + 160);
      if (result)
      {
        double result = sub_1006391A8(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x400000) != 0)
    {
      double result = *(void *)(v1 + 168);
      if (result)
      {
        double result = sub_100644664(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x800000) != 0)
    {
      double result = *(void *)(v1 + 176);
      if (result)
      {
        double result = sub_100647A44(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }
  }

  if (HIBYTE(v2))
  {
    if ((v2 & 0x1000000) != 0)
    {
      double result = *(void *)(v1 + 184);
      if (result)
      {
        double result = sub_10061DC50(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    if ((v2 & 0x2000000) != 0)
    {
      double result = *(void *)(v1 + 192);
      if (result)
      {
        double result = sub_10061C104(result);
        unsigned int v2 = *(_DWORD *)(v1 + 224);
      }
    }

    *(void *)(v1 + 200) = 0LL;
    *(_DWORD *)(v1 + 216) = 0;
    if ((v2 & 0x20000000) != 0)
    {
      double result = *(void *)(v1 + 208);
      if (result) {
        double result = sub_100619270(result);
      }
    }
  }

  *(_DWORD *)(v1 + 224) = 0;
  return result;
}

uint64_t sub_100BBB640(uint64_t result)
{
  if (*(_BYTE *)(result + 32))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(_DWORD *)(result + 23) = 0;
  }

  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100BBB658(uint64_t result)
{
  uint64_t v1 = result;
  if ((*(_BYTE *)(result + 44) & 2) != 0)
  {
    uint64_t v2 = *(void *)(result + 32);
    if (v2)
    {
      if (*(_BYTE *)(v2 + 20))
      {
        *(_DWORD *)(v2 + 11) = 0;
        *(_DWORD *)(v2 + 8) = 0;
      }

      *(_DWORD *)(v2 + 20) = 0;
    }
  }

  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 8) + 8 * v3);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(v4);
      ++v3;
    }

    while (v3 < *(int *)(v1 + 16));
  }

  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 44) = 0;
  return result;
}

uint64_t sub_100BBB6D4(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_DWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BBB6E8(uint64_t result)
{
  if (*(_BYTE *)(result + 16)) {
    *(_BYTE *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_100BBB6FC(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(void *)(result + 8) = 0LL;
    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100BBB714(uint64_t result)
{
  char v1 = *(_BYTE *)(result + 36);
  if (v1)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *(void *)(result + 24);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100BBB760( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 16);
  uint64_t v6 = (unsigned int *)(a1 + 200);
  uint64_t v7 = (unsigned int *)(a1 + 216);
  while (2)
  {
    uint64_t v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        uint64_t v11 = (char *)*((void *)this + 1);
        if ((unint64_t)v11 < *((void *)this + 2) && (*v11 & 0x80000000) == 0)
        {
          unsigned int v12 = *v11;
          *((void *)this + 1) = v11 + 1;
          goto LABEL_91;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v235);
        if ((_DWORD)result)
        {
          unsigned int v12 = v235;
LABEL_91:
          if (v12 - 9 < 0x13 || v12 <= 5)
          {
            if (v12 - 9 >= 0x13 && v12 >= 6) {
              sub_101264E70();
            }
            *(_DWORD *)(a1 + 224) |= 1u;
            *(_DWORD *)(a1 + 8) = v12;
          }

          int v40 = (_BYTE *)*((void *)this + 1);
          unint64_t v15 = *((void *)this + 2);
          if ((unint64_t)v40 < v15 && *v40 == 16)
          {
            uint64_t v16 = v40 + 1;
            *((void *)this + 1) = v16;
            goto LABEL_103;
          }

          continue;
        }

        break;
      case 2u:
        int v10 = TagFallback & 7;
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
LABEL_103:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v235);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v41 = v235;
        }

        else
        {
          unsigned int v41 = *v16;
          *((void *)this + 1) = v16 + 1;
        }

        if (sub_100BB1E1C(v41))
        {
          *(_DWORD *)(a1 + 224) |= 2u;
          *(_DWORD *)(a1 + 12) = v41;
        }

        uint64_t v42 = (_BYTE *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        uint64_t v18 = v42 + 1;
        *((void *)this + 1) = v18;
LABEL_113:
        if ((unint64_t)v18 >= v17 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v43 = (_BYTE *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v18;
          uint64_t v43 = v18 + 1;
          *((void *)this + 1) = v43;
        }

        int v24 = *(_DWORD *)(a1 + 224) | 4;
        *(_DWORD *)(a1 + 224) = v24;
        *((void *)this + 1) = v43 + 1;
LABEL_121:
        *(_DWORD *)(a1 + 224) = v24 | 8;
        int v44 = *(void **)(a1 + 24);
        if (!v44)
        {
          int v44 = operator new(0x38uLL);
          sub_1005010A8((uint64_t)v44);
          *(void *)(a1 + 24) = v44;
        }

        uint64_t v45 = (char *)*((void *)this + 1);
        if ((unint64_t)v45 >= *((void *)this + 2) || *v45 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v45;
          *((void *)this + 1) = v45 + 1;
        }

        int v46 = *((_DWORD *)this + 14);
        int v47 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v46 + 1;
        if (v46 >= v47) {
          return 0LL;
        }
        int v48 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v48);
        int v50 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v50, 1);
        int v51 = v50 - 1;
        if (v51 < 0 == v35) {
          *((_DWORD *)this + 14) = v51;
        }
        int v52 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v52 + 1;
LABEL_135:
        *(_DWORD *)(a1 + 224) |= 0x10u;
        uint64_t v53 = *(void **)(a1 + 32);
        if (!v53)
        {
          uint64_t v53 = operator new(0x88uLL);
          sub_100A408F0((uint64_t)v53);
          *(void *)(a1 + 32) = v53;
        }

        int v54 = (char *)*((void *)this + 1);
        if ((unint64_t)v54 >= *((void *)this + 2) || *v54 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v54;
          *((void *)this + 1) = v54 + 1;
        }

        int v55 = *((_DWORD *)this + 14);
        int v56 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v55 + 1;
        if (v55 >= v56) {
          return 0LL;
        }
        int v57 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v57);
        int v59 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v59, 1);
        int v60 = v59 - 1;
        if (v60 < 0 == v35) {
          *((_DWORD *)this + 14) = v60;
        }
        uint64_t v61 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v61 + 1;
LABEL_149:
        *(_DWORD *)(a1 + 224) |= 0x20u;
        uint64_t v62 = *(void **)(a1 + 40);
        if (!v62)
        {
          uint64_t v62 = operator new(0x38uLL);
          sub_100501130((uint64_t)v62);
          *(void *)(a1 + 40) = v62;
        }

        int v63 = (char *)*((void *)this + 1);
        if ((unint64_t)v63 >= *((void *)this + 2) || *v63 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v63;
          *((void *)this + 1) = v63 + 1;
        }

        int v64 = *((_DWORD *)this + 14);
        int v65 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v64 + 1;
        if (v64 >= v65) {
          return 0LL;
        }
        int v66 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v66);
        int v68 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v68, 1);
        int v69 = v68 - 1;
        if (v69 < 0 == v35) {
          *((_DWORD *)this + 14) = v69;
        }
        int v70 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v70 + 1;
LABEL_163:
        *(_DWORD *)(a1 + 224) |= 0x40u;
        int v71 = *(_DWORD **)(a1 + 48);
        if (!v71)
        {
          int v71 = operator new(0x28uLL);
          v71[7] = 0;
          v71[8] = 0;
          *((void *)v71 + 1) = 0LL;
          *((void *)v71 + 2) = 0LL;
          *(void *)int v71 = off_101875438;
          *(_DWORD *)((char *)v71 + 23) = 0;
          *(void *)(a1 + memset(v19, 0, 48) = v71;
        }

        int v72 = (char *)*((void *)this + 1);
        if ((unint64_t)v72 >= *((void *)this + 2) || *v72 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v72;
          *((void *)this + 1) = v72 + 1;
        }

        int v73 = *((_DWORD *)this + 14);
        int v74 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v73 + 1;
        if (v73 >= v74) {
          return 0LL;
        }
        int v75 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v75);
        int v77 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v77, 1);
        int v78 = v77 - 1;
        if (v78 < 0 == v35) {
          *((_DWORD *)this + 14) = v78;
        }
        int v79 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v79 + 1;
LABEL_177:
        *(_DWORD *)(a1 + 224) |= 0x80u;
        int v80 = *(void **)(a1 + 56);
        if (!v80)
        {
          int v80 = operator new(0x38uLL);
          sub_1005010C8((uint64_t)v80);
          *(void *)(a1 + 56) = v80;
        }

        int v81 = (char *)*((void *)this + 1);
        if ((unint64_t)v81 >= *((void *)this + 2) || *v81 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v81;
          *((void *)this + 1) = v81 + 1;
        }

        int v82 = *((_DWORD *)this + 14);
        int v83 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v82 + 1;
        if (v82 >= v83) {
          return 0LL;
        }
        int v84 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v84);
        int v86 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v86, 1);
        int v87 = v86 - 1;
        if (v87 < 0 == v35) {
          *((_DWORD *)this + 14) = v87;
        }
        int v88 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v88 + 2;
LABEL_192:
        *(_DWORD *)(a1 + 224) |= 0x100u;
        uint64_t v89 = *(void **)(a1 + 64);
        if (!v89)
        {
          uint64_t v89 = operator new(0x30uLL);
          v89[1] = 0LL;
          v89[2] = 0LL;
          *uint64_t v89 = off_101876158;
          *((_DWORD *)v89 + 6) = 0;
          v89[4] = 0LL;
          v89[5] = 0LL;
          *(void *)(a1 + 64) = v89;
        }

        int v90 = (char *)*((void *)this + 1);
        if ((unint64_t)v90 >= *((void *)this + 2) || *v90 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v90;
          *((void *)this + 1) = v90 + 1;
        }

        int v91 = *((_DWORD *)this + 14);
        int v92 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v91 + 1;
        if (v91 >= v92) {
          return 0LL;
        }
        int v93 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v93);
        int v95 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v95, 1);
        int v96 = v95 - 1;
        if (v96 < 0 == v35) {
          *((_DWORD *)this + 14) = v96;
        }
        int v97 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v97 + 2;
LABEL_207:
        *(_DWORD *)(a1 + 224) |= 0x200u;
        int v98 = *(void **)(a1 + 72);
        if (!v98)
        {
          int v98 = operator new(0x18uLL);
          void *v98 = off_1018761D0;
          v98[1] = 0LL;
          *((_DWORD *)v98 + 4) = 0;
          *(void *)(a1 + 72) = v98;
        }

        uint64_t v99 = (char *)*((void *)this + 1);
        if ((unint64_t)v99 >= *((void *)this + 2) || *v99 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v99;
          *((void *)this + 1) = v99 + 1;
        }

        int v100 = *((_DWORD *)this + 14);
        int v101 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v100 + 1;
        if (v100 >= v101) {
          return 0LL;
        }
        int v102 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v102);
        int v104 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v104, 1);
        int v105 = v104 - 1;
        if (v105 < 0 == v35) {
          *((_DWORD *)this + 14) = v105;
        }
        int v106 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v106 + 2;
LABEL_222:
        *(_DWORD *)(a1 + 224) |= 0x400u;
        uint64_t v107 = *(void **)(a1 + 80);
        if (!v107)
        {
          uint64_t v107 = operator new(0x28uLL);
          sub_100501168((uint64_t)v107);
          *(void *)(a1 + 80) = v107;
        }

        int v108 = (char *)*((void *)this + 1);
        if ((unint64_t)v108 >= *((void *)this + 2) || *v108 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v108;
          *((void *)this + 1) = v108 + 1;
        }

        int v109 = *((_DWORD *)this + 14);
        int v110 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v109 + 1;
        if (v109 >= v110) {
          return 0LL;
        }
        int v111 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v111);
        int v113 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v113, 1);
        int v114 = v113 - 1;
        if (v114 < 0 == v35) {
          *((_DWORD *)this + 14) = v114;
        }
        uint64_t v115 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v115 + 2;
LABEL_237:
        *(_DWORD *)(a1 + 224) |= 0x800u;
        int v116 = *(void **)(a1 + 88);
        if (!v116)
        {
          int v116 = operator new(0x20uLL);
          sub_100501150((uint64_t)v116);
          *(void *)(a1 + 88) = v116;
        }

        int v117 = (char *)*((void *)this + 1);
        if ((unint64_t)v117 >= *((void *)this + 2) || *v117 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v117;
          *((void *)this + 1) = v117 + 1;
        }

        int v118 = *((_DWORD *)this + 14);
        int v119 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v118 + 1;
        if (v118 >= v119) {
          return 0LL;
        }
        int v120 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v120);
        int v122 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v122, 1);
        int v123 = v122 - 1;
        if (v123 < 0 == v35) {
          *((_DWORD *)this + 14) = v123;
        }
        int v124 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        uint64_t v20 = (char *)(v124 + 2);
        *((void *)this + 1) = v20;
LABEL_252:
        if ((unint64_t)v20 >= v19 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v235);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v125 = v235;
        }

        else
        {
          unsigned int v125 = *v20;
          *((void *)this + 1) = v20 + 1;
        }

        if (sub_100501188(v125))
        {
          if (!sub_100501188(v125)) {
            sub_101264DF8();
          }
          *(_DWORD *)(a1 + 224) |= 0x2000u;
          *(_DWORD *)(a1 + 100) = v125;
        }

        uint64_t v126 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v126 + 2;
LABEL_264:
        *(_DWORD *)(a1 + 224) |= 0x4000u;
        unint64_t v127 = *(_BYTE **)(a1 + 104);
        if (!v127)
        {
          unint64_t v127 = operator new(0x18uLL);
          *(void *)unint64_t v127 = off_101876518;
          v127[8] = 0;
          *((_DWORD *)v127 + 3) = 0;
          *((_DWORD *)v127 + 4) = 0;
          *(void *)(a1 + 104) = v127;
        }

        int v128 = (char *)*((void *)this + 1);
        if ((unint64_t)v128 >= *((void *)this + 2) || *v128 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v128;
          *((void *)this + 1) = v128 + 1;
        }

        int v129 = *((_DWORD *)this + 14);
        int v130 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v129 + 1;
        if (v129 >= v130) {
          return 0LL;
        }
        int v131 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v131);
        int v133 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v133, 1);
        int v134 = v133 - 1;
        if (v134 < 0 == v35) {
          *((_DWORD *)this + 14) = v134;
        }
        uint64_t v135 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v25 = *((void *)this + 2);
        uint64_t v26 = (char *)(v135 + 2);
        *((void *)this + 1) = v26;
LABEL_279:
        if ((unint64_t)v26 >= v25 || *v26 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v235);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v136 = v235;
        }

        else
        {
          unsigned int v136 = *v26;
          *((void *)this + 1) = v26 + 1;
        }

        if (sub_100501188(v136))
        {
          if (!sub_100501188(v136)) {
            sub_101264E20();
          }
          *(_DWORD *)(a1 + 224) |= 0x1000u;
          *(_DWORD *)(a1 + 96) = v136;
        }

        int v137 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v137 + 2;
LABEL_291:
        *(_DWORD *)(a1 + 224) |= 0x8000u;
        int v138 = *(void **)(a1 + 112);
        if (!v138)
        {
          int v138 = operator new(0x20uLL);
          v138[1] = 0LL;
          v138[2] = 0LL;
          *int v138 = off_101876590;
          *((_DWORD *)v138 + 6) = 0;
          *(void *)(a1 + 112) = v138;
        }

        int v139 = (char *)*((void *)this + 1);
        if ((unint64_t)v139 >= *((void *)this + 2) || *v139 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v139;
          *((void *)this + 1) = v139 + 1;
        }

        int v140 = *((_DWORD *)this + 14);
        int v141 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v140 + 1;
        if (v140 >= v141) {
          return 0LL;
        }
        int v142 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v142);
        int v144 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v144, 1);
        int v145 = v144 - 1;
        if (v145 < 0 == v35) {
          *((_DWORD *)this + 14) = v145;
        }
        int v146 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v146 + 2;
LABEL_306:
        *(_DWORD *)(a1 + 224) |= 0x10000u;
        uint64_t v147 = *(void **)(a1 + 120);
        if (!v147)
        {
          uint64_t v147 = operator new(0x28uLL);
          *uint64_t v147 = off_101876608;
          v147[1] = 0LL;
          v147[2] = 0LL;
          v147[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          v147[4] = 0LL;
          *(void *)(a1 + 120) = v147;
        }

        int v148 = (char *)*((void *)this + 1);
        if ((unint64_t)v148 >= *((void *)this + 2) || *v148 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v148;
          *((void *)this + 1) = v148 + 1;
        }

        int v149 = *((_DWORD *)this + 14);
        int v150 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v149 + 1;
        if (v149 >= v150) {
          return 0LL;
        }
        int v151 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v151);
        int v153 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v153, 1);
        int v154 = v153 - 1;
        if (v154 < 0 == v35) {
          *((_DWORD *)this + 14) = v154;
        }
        uint64_t v155 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v155 + 2;
LABEL_321:
        *(_DWORD *)(a1 + 224) |= 0x20000u;
        unsigned int v156 = *(void **)(a1 + 128);
        if (!v156)
        {
          unsigned int v156 = operator new(0x80uLL);
          sub_1006144E4((uint64_t)v156);
          *(void *)(a1 + 1sub_100231C10(v1 + 28) = v156;
        }

        int v157 = (char *)*((void *)this + 1);
        if ((unint64_t)v157 >= *((void *)this + 2) || *v157 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v157;
          *((void *)this + 1) = v157 + 1;
        }

        int v158 = *((_DWORD *)this + 14);
        int v159 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v158 + 1;
        if (v158 >= v159) {
          return 0LL;
        }
        int v160 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v160);
        int v162 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v162, 1);
        int v163 = v162 - 1;
        if (v163 < 0 == v35) {
          *((_DWORD *)this + 14) = v163;
        }
        int v164 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v164 + 2;
LABEL_336:
        *(_DWORD *)(a1 + 224) |= 0x40000u;
        unsigned int v165 = *(void **)(a1 + 136);
        if (v165 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        {
          unsigned int v165 = operator new(0x18uLL);
          v165[1] = 0LL;
          v165[2] = 0LL;
          *unsigned int v165 = 0LL;
          *(void *)(a1 + 136) = v165;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v165);
        if (!(_DWORD)result) {
          return result;
        }
        int v166 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v166 + 2;
LABEL_343:
        *(_DWORD *)(a1 + 224) |= 0x80000u;
        uint64_t v167 = *(void **)(a1 + 144);
        if (!v167)
        {
          uint64_t v167 = operator new(0x48uLL);
          sub_100614628((uint64_t)v167);
          *(void *)(a1 + 144) = v167;
        }

        v168 = (char *)*((void *)this + 1);
        if ((unint64_t)v168 >= *((void *)this + 2) || *v168 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v168;
          *((void *)this + 1) = v168 + 1;
        }

        int v169 = *((_DWORD *)this + 14);
        int v170 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v169 + 1;
        if (v169 >= v170) {
          return 0LL;
        }
        int v171 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v171);
        int v173 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v173, 1);
        int v174 = v173 - 1;
        if (v174 < 0 == v35) {
          *((_DWORD *)this + 14) = v174;
        }
        int v175 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v175 + 2;
LABEL_358:
        *(_DWORD *)(a1 + 224) |= 0x100000u;
        uint64_t v176 = *(void **)(a1 + 152);
        if (!v176)
        {
          uint64_t v176 = operator new(0x38uLL);
          sub_10061464C((uint64_t)v176);
          *(void *)(a1 + 152) = v176;
        }

        int v177 = (char *)*((void *)this + 1);
        if ((unint64_t)v177 >= *((void *)this + 2) || *v177 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v177;
          *((void *)this + 1) = v177 + 1;
        }

        int v178 = *((_DWORD *)this + 14);
        int v179 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v178 + 1;
        if (v178 >= v179) {
          return 0LL;
        }
        int v180 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v180);
        int v182 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v182, 1);
        int v183 = v182 - 1;
        if (v183 < 0 == v35) {
          *((_DWORD *)this + 14) = v183;
        }
        int v184 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v184 + 2;
LABEL_373:
        *(_DWORD *)(a1 + 224) |= 0x200000u;
        int v185 = *(void **)(a1 + 160);
        if (!v185)
        {
          int v185 = operator new(0x30uLL);
          sub_100614670((uint64_t)v185);
          *(void *)(a1 + 160) = v185;
        }

        v186 = (char *)*((void *)this + 1);
        if ((unint64_t)v186 >= *((void *)this + 2) || *v186 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v186;
          *((void *)this + 1) = v186 + 1;
        }

        int v187 = *((_DWORD *)this + 14);
        int v188 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v187 + 1;
        if (v187 >= v188) {
          return 0LL;
        }
        int v189 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v189);
        int v191 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v191, 1);
        int v192 = v191 - 1;
        if (v192 < 0 == v35) {
          *((_DWORD *)this + 14) = v192;
        }
        int v193 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v193 + 2;
LABEL_388:
        *(_DWORD *)(a1 + 224) |= 0x400000u;
        int v194 = *(void **)(a1 + 168);
        if (!v194)
        {
          int v194 = operator new(0x18uLL);
          sub_10061475C((uint64_t)v194);
          *(void *)(a1 + 168) = v194;
        }

        v195 = (char *)*((void *)this + 1);
        if ((unint64_t)v195 >= *((void *)this + 2) || *v195 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v195;
          *((void *)this + 1) = v195 + 1;
        }

        int v196 = *((_DWORD *)this + 14);
        int v197 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v196 + 1;
        if (v196 >= v197) {
          return 0LL;
        }
        int v198 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v198);
        int v200 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v200, 1);
        int v201 = v200 - 1;
        if (v201 < 0 == v35) {
          *((_DWORD *)this + 14) = v201;
        }
        int v202 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v202 + 2;
LABEL_403:
        *(_DWORD *)(a1 + 224) |= 0x800000u;
        int v203 = *(void **)(a1 + 176);
        if (!v203)
        {
          int v203 = operator new(0x38uLL);
          sub_100614784((uint64_t)v203);
          *(void *)(a1 + 176) = v203;
        }

        v204 = (char *)*((void *)this + 1);
        if ((unint64_t)v204 >= *((void *)this + 2) || *v204 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v204;
          *((void *)this + 1) = v204 + 1;
        }

        int v205 = *((_DWORD *)this + 14);
        int v206 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v205 + 1;
        if (v205 >= v206) {
          return 0LL;
        }
        int v207 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v207);
        int v209 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v209, 1);
        int v210 = v209 - 1;
        if (v210 < 0 == v35) {
          *((_DWORD *)this + 14) = v210;
        }
        int v211 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v211 + 2;
LABEL_418:
        *(_DWORD *)(a1 + 224) |= 0x1000000u;
        int v212 = *(void **)(a1 + 184);
        if (!v212)
        {
          int v212 = operator new(0x70uLL);
          sub_1006145D0((uint64_t)v212);
          *(void *)(a1 + 184) = v212;
        }

        v213 = (char *)*((void *)this + 1);
        if ((unint64_t)v213 >= *((void *)this + 2) || *v213 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v213;
          *((void *)this + 1) = v213 + 1;
        }

        int v214 = *((_DWORD *)this + 14);
        int v215 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v214 + 1;
        if (v214 >= v215) {
          return 0LL;
        }
        int v216 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v216);
        int v218 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v218, 1);
        int v219 = v218 - 1;
        if (v219 < 0 == v35) {
          *((_DWORD *)this + 14) = v219;
        }
        int v220 = (unsigned __int8 *)*((void *)this + 1);
        *((void *)this + 1) = v220 + 2;
LABEL_433:
        *(_DWORD *)(a1 + 224) |= 0x2000000u;
        int v221 = *(void **)(a1 + 192);
        if (!v221)
        {
          int v221 = operator new(0x38uLL);
          sub_10061458C((uint64_t)v221);
          *(void *)(a1 + 192) = v221;
        }

        v222 = (char *)*((void *)this + 1);
        if ((unint64_t)v222 >= *((void *)this + 2) || *v222 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v222;
          *((void *)this + 1) = v222 + 1;
        }

        int v223 = *((_DWORD *)this + 14);
        int v224 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v223 + 1;
        if (v223 >= v224) {
          return 0LL;
        }
        int v225 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v225);
        int v227 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v227, 1);
        int v228 = v227 - 1;
        if (v228 < 0 == v35) {
          *((_DWORD *)this + 14) = v228;
        }
        int v229 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        unsigned int v28 = v229 + 2;
        *((void *)this + 1) = v28;
LABEL_448:
        if ((unint64_t)v28 >= v27 || (char)*v28 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          int v230 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v27 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v6 = *v28;
          int v230 = v28 + 1;
          *((void *)this + 1) = v230;
        }

        *(_DWORD *)(a1 + 224) |= 0x4000000u;
        unsigned int v29 = (char *)(v230 + 2);
        *((void *)this + 1) = v29;
LABEL_457:
        if ((unint64_t)v29 >= v27 || *v29 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v235);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v231 = v235;
        }

        else
        {
          unsigned int v231 = *v29;
          *((void *)this + 1) = v29 + 1;
        }

        if (v231 <= 4 && v231 != 3)
        {
          *(_DWORD *)(a1 + 224) |= 0x8000000u;
          *(_DWORD *)(a1 + 204) = v231;
        }

        v233 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        uint64_t v14 = v233 + 2;
        *((void *)this + 1) = v14;
LABEL_471:
        if ((unint64_t)v14 >= v13 || (char)*v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          int v234 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v7 = *v14;
          int v234 = v14 + 1;
          *((void *)this + 1) = v234;
        }

        int v21 = *(_DWORD *)(a1 + 224) | 0x10000000;
        *(_DWORD *)(a1 + 224) = v21;
        *((void *)this + 1) = v234 + 2;
LABEL_45:
        *(_DWORD *)(a1 + 224) = v21 | 0x20000000;
        uint64_t v22 = *(void **)(a1 + 208);
        if (!v22)
        {
          uint64_t v22 = operator new(0x18uLL);
          sub_100614550((uint64_t)v22);
          *(void *)(a1 + 208) = v22;
        }

        uint64_t v23 = (char *)*((void *)this + 1);
        if ((unint64_t)v23 >= *((void *)this + 2) || *v23 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v235)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v235 = *v23;
          *((void *)this + 1) = v23 + 1;
        }

        int v30 = *((_DWORD *)this + 14);
        int v31 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v30 + 1;
        if (v30 >= v31) {
          return 0LL;
        }
        int v32 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v235);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v32);
        int v34 = *((_DWORD *)this + 14);
        BOOL v35 = __OFSUB__(v34, 1);
        int v36 = v34 - 1;
        if (v36 < 0 == v35) {
          *((_DWORD *)this + 14) = v36;
        }
        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }

        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_113;
      case 4u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_75;
        }
        int v24 = *(_DWORD *)(a1 + 224);
        goto LABEL_121;
      case 5u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_135;
        }
        goto LABEL_75;
      case 6u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_149;
        }
        goto LABEL_75;
      case 9u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_163;
        }
        goto LABEL_75;
      case 0xAu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_177;
        }
        goto LABEL_75;
      case 0x10u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_192;
        }
        goto LABEL_75;
      case 0x11u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_207;
        }
        goto LABEL_75;
      case 0x12u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_222;
        }
        goto LABEL_75;
      case 0x13u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_237;
        }
        goto LABEL_75;
      case 0x14u:
        int v10 = TagFallback & 7;
        uint64_t v20 = (char *)*((void *)this + 1);
        unint64_t v19 = *((void *)this + 2);
        goto LABEL_252;
      case 0x15u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_264;
        }
        goto LABEL_75;
      case 0x16u:
        int v10 = TagFallback & 7;
        uint64_t v26 = (char *)*((void *)this + 1);
        unint64_t v25 = *((void *)this + 2);
        goto LABEL_279;
      case 0x17u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_291;
        }
        goto LABEL_75;
      case 0x19u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_306;
        }
        goto LABEL_75;
      case 0x1Eu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_321;
        }
        goto LABEL_75;
      case 0x1Fu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_336;
        }
        goto LABEL_75;
      case 0x28u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_343;
        }
        goto LABEL_75;
      case 0x29u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_358;
        }
        goto LABEL_75;
      case 0x2Au:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_373;
        }
        goto LABEL_75;
      case 0x2Bu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_388;
        }
        goto LABEL_75;
      case 0x2Cu:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_403;
        }
        goto LABEL_75;
      case 0x32u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_418;
        }
        goto LABEL_75;
      case 0x33u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_433;
        }
        goto LABEL_75;
      case 0x34u:
        int v10 = TagFallback & 7;
        unsigned int v28 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        goto LABEL_448;
      case 0x35u:
        int v10 = TagFallback & 7;
        unsigned int v29 = (char *)*((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        goto LABEL_457;
      case 0x36u:
        int v10 = TagFallback & 7;
        uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_471;
      case 0x37u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_75;
        }
        int v21 = *(_DWORD *)(a1 + 224);
        goto LABEL_45;
      default:
        int v10 = TagFallback & 7;
LABEL_75:
        if (v10 == 4) {
          return 1LL;
        }
        continue;
    }

    return result;
  }

void sub_100BBD1E0(_Unwind_Exception *a1)
{
}

uint64_t sub_100BBD22C( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 224);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  (int)a2,  a4);
    int v6 = *(_DWORD *)(v5 + 224);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_34;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_35;
  }

uint64_t sub_100BBD6E8(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 224);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_56;
  }

  if ((v3 & 1) == 0)
  {
    uint64_t v4 = 0LL;
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 10;
  }

  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = *(_DWORD *)(a1 + 224);
  }

  else
  {
    int v6 = 1;
  }

  uint64_t v4 = (v6 + 1);
  if ((v3 & 2) != 0)
  {
LABEL_12:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }

    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = *(_DWORD *)(a1 + 224);
    }

    else
    {
      int v8 = 1;
    }

    uint64_t v4 = (v4 + v8 + 1);
  }

void sub_100BBDF50(uint64_t a1, void *lpsrc)
{
}

void sub_100BBDF9C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v12,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  4539LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v12,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      *(void *)(a1 + 8) = v7;
      int v5 = *(_DWORD *)(a2 + 32);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_13;
      }
    }

    else if ((*(_BYTE *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }

    uint64_t v8 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(void *)(a1 + 16) = v8;
    int v5 = *(_DWORD *)(a2 + 32);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_14;
    }

void sub_100BBE0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBE0C4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v16,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  10753LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v16,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v15, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8),  *(_DWORD *)(a2 + 16) + *(_DWORD *)(a1 + 16));
  if (*(int *)(a2 + 16) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 8) + 8 * v5);
      int v7 = *(_DWORD *)(a1 + 20);
      uint64_t v8 = *(int *)(a1 + 16);
      if ((int)v8 >= v7)
      {
        if (v7 == *(_DWORD *)(a1 + 24))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8),  v7 + 1);
          int v7 = *(_DWORD *)(a1 + 20);
        }

        *(_DWORD *)(a1 + 20) = v7 + 1;
        char v10 = operator new(0x28uLL);
        *char v10 = off_1018760E0;
        v10[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        v10[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        v10[3] = 0LL;
        *((_DWORD *)v10 + 8) = 0;
        uint64_t v11 = *(void *)(a1 + 8);
        uint64_t v12 = *(int *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *(void *)(a1 + 8);
        *(_DWORD *)(a1 + 16) = v8 + 1;
        char v10 = *(void **)(v9 + 8 * v8);
      }

      sub_100BC4CD0((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 16));
  }

  if ((*(_BYTE *)(a2 + 44) & 2) != 0)
  {
    *(_DWORD *)(a1 + 44) |= 2u;
    uint64_t v13 = *(char **)(a1 + 32);
    if (!v13)
    {
      uint64_t v13 = (char *)operator new(0x18uLL);
      *(void *)uint64_t v13 = off_101876068;
      *((void *)v13 + 2) = 0LL;
      *((_DWORD *)v13 + 2) = 0;
      *(_DWORD *)(v13 + 11) = 0;
      *(void *)(a1 + 32) = v13;
    }

    uint64_t v14 = *(void *)(a2 + 32);
    if (!v14) {
      uint64_t v14 = *(void *)(qword_1019A1E20 + 32);
    }
    sub_100BC4718((uint64_t)v13, v14);
  }

void sub_100BBE268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBE280(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  10925LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v5 >= 5) {
      sub_101264E98();
    }
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
  }

void sub_100BBE314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBE32C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  12924LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    char v5 = *(_BYTE *)(a2 + 8);
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_BYTE *)(a1 + 8) = v5;
  }

void sub_100BBE3B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBE3CC(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  13153LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 8);
      a1[6] |= 1u;
      a1[2] = v7;
      int v5 = *(_DWORD *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }

    int v8 = *(_DWORD *)(a2 + 12);
    a1[6] |= 2u;
    a1[3] = v8;
    if ((*(_DWORD *)(a2 + 24) & 4) == 0) {
      return;
    }
LABEL_7:
    int v6 = *(_DWORD *)(a2 + 16);
    a1[6] |= 4u;
    a1[4] = v6;
  }

void sub_100BBE49C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BBE4B4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  13394LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(void *)(a1 + 8) = v6;
      int v5 = *(_DWORD *)(a2 + 36);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_10;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    uint64_t v7 = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(void *)(a1 + 16) = v7;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return;
    }
LABEL_10:
    int v8 = *(const std::string **)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    char v9 = *(std::string **)(a1 + 24);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      char v9 = (std::string *)operator new(0x18uLL);
      v9->__r_.__value_.__l.__size_ = 0LL;
      v9->__r_.__value_.__l.__cap_ = 0LL;
      v9->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a1 + 24) = v9;
    }

    std::string::operator=(v9, v8);
  }

void sub_100BBE5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100BBE5C8()
{
  return 1LL;
}

void *sub_100BBE5D0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.Indication");
}

void sub_100BBE5E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875438;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBE5F0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875438;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_DWORD *sub_100BBE610()
{
  uint64_t result = operator new(0x28uLL);
  result[7] = 0;
  result[8] = 0;
  *((void *)result + 1) = 0LL;
  *((void *)result + 2) = 0LL;
  *(void *)uint64_t result = off_101875438;
  *(_DWORD *)((char *)result + 23) = 0;
  return result;
}

uint64_t sub_100BBE640( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unint64_t *)(a1 + 8);
  uint64_t v6 = (unint64_t *)(a1 + 16);
  while (2)
  {
    uint64_t v7 = (char *)*((void *)this + 1);
    if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v7 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        uint64_t v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        if ((unint64_t)v11 < v10 && (*v11 & 0x80000000) == 0)
        {
          *int v5 = *v11;
          uint64_t v12 = v11 + 1;
          *((void *)this + 1) = v12;
LABEL_26:
          *(_DWORD *)(a1 + 32) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 16)
          {
            uint64_t v13 = v12 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_29;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if ((_DWORD)result)
        {
          uint64_t v12 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          goto LABEL_26;
        }

        break;
      case 2u:
        int v9 = TagFallback & 7;
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_29:
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v17 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v6 = *v13;
          uint64_t v17 = v13 + 1;
          *((void *)this + 1) = v17;
        }

        *(_DWORD *)(a1 + 32) |= 2u;
        uint64_t v14 = v17 + 1;
        *((void *)this + 1) = v14;
LABEL_37:
        if ((unint64_t)v14 >= v10 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v27);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v18 = v27;
          int v19 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v18 = *v14;
          int v19 = v14 + 1;
          *((void *)this + 1) = v19;
        }

        *(_BYTE *)(a1 + 24) = v18 != 0;
        *(_DWORD *)(a1 + 32) |= 4u;
        char v15 = v19 + 1;
        *((void *)this + 1) = v15;
LABEL_45:
        if ((unint64_t)v15 >= v10 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v26);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v20 = v26;
          uint64_t v21 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v20 = *v15;
          uint64_t v21 = v15 + 1;
          *((void *)this + 1) = v21;
        }

        *(_BYTE *)(a1 + 25) = v20 != 0;
        *(_DWORD *)(a1 + 32) |= 8u;
        int v16 = v21 + 1;
        *((void *)this + 1) = v16;
LABEL_53:
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v22 = v25;
          int v23 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v22 = *v16;
          int v23 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v23;
        }

        *(_BYTE *)(a1 + 26) = v22 != 0;
        *(_DWORD *)(a1 + 32) |= 0x10u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v9 = TagFallback & 7;
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_37;
      case 4u:
        int v9 = TagFallback & 7;
        char v15 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_45;
      case 5u:
        int v9 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_53;
      default:
        int v9 = TagFallback & 7;
LABEL_20:
        if (v9 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BBE978( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(v5 + 16),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }

uint64_t sub_100BBEA28(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_15;
  }

  if ((*(_BYTE *)(a1 + 32) & 1) == 0)
  {
    unsigned int v4 = 0;
    if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
     + 1;
  int v3 = *(_DWORD *)(a1 + 32);
  if ((v3 & 2) != 0)
  {
LABEL_7:
    v4 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16),  a2)
        + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }

void sub_100BBEAB4(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BBEB00()
{
  return 1LL;
}

void *sub_100BBEB08@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.Status");
}

void sub_100BBEB18(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018754B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBEB28(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018754B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

char *sub_100BBEB48()
{
  uint64_t result = (char *)operator new(0x18uLL);
  *(void *)uint64_t result = off_1018754B0;
  result[8] = 1;
  *((void *)result + 2) = 0LL;
  *(_DWORD *)(result + 9) = 0;
  result[13] = 0;
  return result;
}

uint64_t sub_100BBEB80( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 < v8 && (*v9 & 0x80000000) == 0)
        {
          unsigned int v10 = *v9;
          uint64_t v11 = v9 + 1;
          *((void *)this + 1) = v11;
LABEL_27:
          *(_BYTE *)(a1 + 8) = v10 != 0;
          *(_DWORD *)(a1 + 20) |= 1u;
          if ((unint64_t)v11 < v8 && *v11 == 16)
          {
            uint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_30;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
        if ((_DWORD)result)
        {
          unsigned int v10 = v28;
          uint64_t v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_27;
        }

        break;
      case 2u:
        int v7 = TagFallback & 7;
        uint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_30:
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v28;
          unsigned int v18 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v17 = *v12;
          unsigned int v18 = v12 + 1;
          *((void *)this + 1) = v18;
        }

        *(_BYTE *)(a1 + 9) = v17 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        uint64_t v13 = v18 + 1;
        *((void *)this + 1) = v13;
LABEL_38:
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v19 = v28;
          unsigned int v20 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v19 = *v13;
          unsigned int v20 = v13 + 1;
          *((void *)this + 1) = v20;
        }

        *(_BYTE *)(a1 + 10) = v19 != 0;
        *(_DWORD *)(a1 + 20) |= 4u;
        uint64_t v14 = v20 + 1;
        *((void *)this + 1) = v14;
LABEL_46:
        if ((unint64_t)v14 >= v8 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v21 = v28;
          unsigned int v22 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v21 = *v14;
          unsigned int v22 = v14 + 1;
          *((void *)this + 1) = v22;
        }

        *(_BYTE *)(a1 + 11) = v21 != 0;
        *(_DWORD *)(a1 + 20) |= 8u;
        char v15 = v22 + 1;
        *((void *)this + 1) = v15;
LABEL_54:
        if ((unint64_t)v15 >= v8 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v23 = v28;
          int v24 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v23 = *v15;
          int v24 = v15 + 1;
          *((void *)this + 1) = v24;
        }

        *(_BYTE *)(a1 + 12) = v23 != 0;
        *(_DWORD *)(a1 + 20) |= 0x10u;
        int v16 = v24 + 1;
        *((void *)this + 1) = v16;
LABEL_62:
        if ((unint64_t)v16 >= v8 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v25 = v28;
          unsigned int v26 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v25 = *v16;
          unsigned int v26 = (unsigned __int8 *)(v16 + 1);
          *((void *)this + 1) = v26;
        }

        *(_BYTE *)(a1 + 13) = v25 != 0;
        *(_DWORD *)(a1 + 20) |= 0x20u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_38;
      case 4u:
        int v7 = TagFallback & 7;
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_46;
      case 5u:
        int v7 = TagFallback & 7;
        char v15 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_54;
      case 6u:
        int v7 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_62;
      default:
        int v7 = TagFallback & 7;
LABEL_21:
        if (v7 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BBEF3C( uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(unsigned __int8 *)(v5 + 9),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }

uint64_t sub_100BBF008(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((_BYTE)v1)
  {
    unsigned int v2 = 2 * (v1 & 1);
    if ((v1 & 2) != 0) {
      v2 += 2;
    }
    if ((v1 & 4) != 0) {
      v2 += 2;
    }
    if ((v1 & 8) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x10) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x20) != 0) {
      uint64_t v3 = v2 + 2;
    }
    else {
      uint64_t v3 = v2;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  *(_DWORD *)(a1 + 16) = v3;
  return v3;
}

void sub_100BBF068(uint64_t a1, _BYTE *lpsrc)
{
}

uint64_t sub_100BBF0B4()
{
  return 1LL;
}

void *sub_100BBF0BC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetPvtmReport");
}

void sub_100BBF0CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875528;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBF0FC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875528;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BBF130()
{
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = off_101875528;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0LL;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100BBF164( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v7 = TagFallback & 7;
      if (v7 != 2) {
        goto LABEL_21;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      unsigned int v10 = *(void **)(a1 + 8);
      if (v10 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        unsigned int v10 = operator new(0x18uLL);
        v10[1] = 0LL;
        v10[2] = 0LL;
        *unsigned int v10 = 0LL;
        *(void *)(a1 + 8) = v10;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v10);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v12 = (_BYTE *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v12 < v8 && *v12 == 16)
      {
        int v9 = v12 + 1;
        *((void *)this + 1) = v9;
LABEL_17:
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v14);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = v14;
        }

        else
        {
          unsigned int v13 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        if (v13 <= 2)
        {
          *(_DWORD *)(a1 + 24) |= 2u;
          *(_DWORD *)(a1 + 16) = v13;
        }

        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_17;
      }
    }

    else
    {
      int v7 = TagFallback & 7;
    }

uint64_t sub_100BBF310( uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes( 1LL,  *(void *)(result + 8),  a2);
    int v6 = *(_DWORD *)(v5 + 24);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  v4,  a4);
  }
  return result;
}

uint64_t sub_100BBF368(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 24);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_21;
  }

  if ((*(_BYTE *)(a1 + 24) & 1) == 0)
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9,  a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v10 = v11 + 1;
    int v3 = *(_DWORD *)(a1 + 24);
    char v7 = *(_BYTE *)(v5 + 23);
  }

  else
  {
    int v10 = 2;
  }

  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    uint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v12 & 0x80000000) != 0)
    {
      int v13 = 11;
    }

    else if (v12 >= 0x80)
    {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 1;
    }

    else
    {
      int v13 = 2;
    }

    uint64_t v4 = (v13 + v4);
  }

void sub_100BBF42C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BBF478()
{
  return 1LL;
}

void *sub_100BBF480@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.InjectAssistanceFile");
}

void sub_100BBF490(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018755A0;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBF4C0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018755A0;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BBF4F4()
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = off_1018755A0;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0LL;
  return result;
}

uint64_t sub_100BBF524( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      char v7 = *(void **)(a1 + 8);
      if (v7 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        char v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        void *v7 = 0LL;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v7);
      if (!(_DWORD)result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BBF630(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes( 1LL,  *(void *)(result + 8),  a2);
  }
  return result;
}

uint64_t sub_100BBF64C(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 20) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8,  a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(_BYTE *)(v4 + 23);
    }

    else
    {
      int v9 = 2;
    }

    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100BBF6C8(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BBF714()
{
  return 1LL;
}

void *sub_100BBF71C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.InjectRtiFile");
}

void sub_100BBF72C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875618;
  sub_10008D0EC((uint64_t)a1 + 8);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BBF764(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BBF778()
{
  uint64_t result = operator new(0x28uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875618;
  *((_DWORD *)result + 6) = 0;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BBF7A8( int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    char v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
    }

    if ((_DWORD)TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }

          a1[5] = v8 + 1;
          int v11 = (unsigned int *)sub_100BCA558();
          uint64_t v12 = *((void *)a1 + 1);
          uint64_t v13 = a1[4];
          a1[4] = v13 + 1;
          *(void *)(v12 + 8 * v13) = v11;
        }

        else
        {
          uint64_t v10 = *((void *)a1 + 1);
          a1[4] = v9 + 1;
          int v11 = *(unsigned int **)(v10 + 8 * v9);
        }

        unsigned int v14 = (char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v25)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v25 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        int v15 = *((_DWORD *)this + 14);
        int v16 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0LL;
        }
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v25);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
        int v19 = *((_DWORD *)this + 14);
        BOOL v20 = __OFSUB__(v19, 1);
        int v21 = v19 - 1;
        if (v21 < 0 == v20) {
          *((_DWORD *)this + 14) = v21;
        }
        unsigned int v22 = (_BYTE *)*((void *)this + 1);
        unsigned int v23 = (_BYTE *)*((void *)this + 2);
        if (v22 >= v23 || *v22 != 10)
        {
          if (v22 == v23 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          goto LABEL_2;
        }

        *((void *)this + 1) = v22 + 1;
      }
    }
  }

uint64_t sub_100BBF994( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(*(void *)(v5 + 8) + 8 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  return result;
}

uint64_t sub_100BBF9F0(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1005058C4( *(void *)(*(void *)(a1 + 8) + 8 * v4),  a2);
      int v6 = (int)v5;
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }

    while (v4 < *(int *)(a1 + 16));
  }

  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100BBFA6C(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BBFAB8()
{
  return 1LL;
}

void *sub_100BBFAC0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.InjectSvidBlocklist");
}

void sub_100BBFAD0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101875690;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A1D78 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100BBFB24(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BBFB38()
{
  uint64_t result = operator new(0x28uLL);
  *uint64_t result = &off_101875690;
  result[1] = 0LL;
  *((_DWORD *)result + 4) = 0;
  *((_BYTE *)result + 20) = 0;
  result[3] = 0LL;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BBFB68( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 24);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        uint64_t v9 = *(void **)(a1 + 8);
        if (!v9)
        {
          uint64_t v9 = operator new(0x68uLL);
          sub_10050107C((uint64_t)v9);
          *(void *)(a1 + 8) = v9;
        }

        uint64_t v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v32)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v32 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        int v16 = *((_DWORD *)this + 14);
        int v17 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v16 + 1;
        if (v16 >= v17) {
          return 0LL;
        }
        int v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v32);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v18);
        int v20 = *((_DWORD *)this + 14);
        BOOL v21 = __OFSUB__(v20, 1);
        int v22 = v20 - 1;
        if (v22 < 0 == v21) {
          *((_DWORD *)this + 14) = v22;
        }
        unsigned int v23 = (_BYTE *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        unsigned int v14 = v23 + 1;
        *((void *)this + 1) = v14;
        goto LABEL_33;
      case 2u:
        int v8 = TagFallback & 7;
        unsigned int v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
LABEL_33:
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v30);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v24 = v30;
        }

        else
        {
          unsigned int v24 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        if (sub_10006ED58(v24))
        {
          if (!sub_10006ED58(v24)) {
            sub_101264C18();
          }
          *(_DWORD *)(a1 + 36) |= 2u;
          *(_DWORD *)(a1 + 16) = v24;
        }

        unsigned int v26 = (_BYTE *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        uint64_t v12 = v26 + 1;
        *((void *)this + 1) = v12;
LABEL_44:
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v31);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v27 = v31;
          unsigned int v28 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v27 = *v12;
          unsigned int v28 = v12 + 1;
          *((void *)this + 1) = v28;
        }

        *(_BYTE *)(a1 + 20) = v27 != 0;
        *(_DWORD *)(a1 + 36) |= 4u;
        int v15 = v28 + 1;
        *((void *)this + 1) = v15;
LABEL_52:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v29 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v15;
          uint64_t v29 = (unsigned __int8 *)(v15 + 1);
          *((void *)this + 1) = v29;
        }

        *(_DWORD *)(a1 + 36) |= 8u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        break;
      case 3u:
        int v8 = TagFallback & 7;
        uint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_44;
      case 0xAu:
        int v8 = TagFallback & 7;
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_52;
      default:
        int v8 = TagFallback & 7;
LABEL_20:
        if (v8 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

void sub_100BBFEAC(_Unwind_Exception *a1)
{
}

uint64_t sub_100BBFEC0( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A1D78 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA,  *(void *)(v5 + 24),  (unint64_t)a2,  a4);
  }

uint64_t sub_100BBFF64(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_23;
  }

  if ((*(_BYTE *)(a1 + 36) & 1) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (!v5) {
      uint64_t v5 = *(void *)(qword_1019A1D78 + 8);
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100501BBC(v5, a2);
    int v7 = (int)v6;
    else {
      int v8 = 1;
    }
    LODWORD(v4) = v7 + v8 + 1;
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  LODWORD(v4) = 0;
  if ((*(_BYTE *)(a1 + 36) & 2) != 0)
  {
LABEL_12:
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 11;
    }

    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }

    else
    {
      int v10 = 2;
    }

    LODWORD(v4) = v10 + v4;
  }

void sub_100BC003C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC0088()
{
  return 1LL;
}

void *sub_100BC0090@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.InjectAssistancePosition");
}

void sub_100BC00A0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875708;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC00B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875708;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC00D0()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = off_101875708;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100BC0100( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  int v6 = (unint64_t *)(a1 + 16);
  int v7 = (unint64_t *)(a1 + 24);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v10 = TagFallback >> 3;
        int v11 = TagFallback & 7;
        unsigned int v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v15 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v14;
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
        }

        *(_DWORD *)(a1 + 36) |= 1u;
        if ((unint64_t)v15 < v12 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *((void *)this + 1) = v16;
          goto LABEL_27;
        }
      }

      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      int v16 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_27:
      if ((unint64_t)v16 >= v12 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
        if (!(_DWORD)result) {
          return result;
        }
        int v17 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }

      else
      {
        *int v6 = *v16;
        int v17 = v16 + 1;
        *((void *)this + 1) = v17;
      }

      *(_DWORD *)(a1 + 36) |= 2u;
      if ((unint64_t)v17 < v12 && *v17 == 24)
      {
        unint64_t v13 = v17 + 1;
        *((void *)this + 1) = v13;
LABEL_35:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          int v18 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unint64_t *v7 = *v13;
          int v18 = (unsigned __int8 *)(v13 + 1);
          *((void *)this + 1) = v18;
        }

        *(_DWORD *)(a1 + 36) |= 4u;
        if (v18 == (unsigned __int8 *)v12
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_35;
      }
    }

    else
    {
      int v11 = TagFallback & 7;
    }

uint64_t sub_100BC0320( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(void *)(v5 + 24),  a2,  a4);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(v5 + 16),  a2,  a4);
  if ((*(_DWORD *)(v5 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(void *)(v5 + 24),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC0398(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_10;
  }

  if ((*(_BYTE *)(a1 + 36) & 1) != 0)
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
       + 1;
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  uint64_t v4 = 0LL;
  if ((*(_BYTE *)(a1 + 36) & 2) != 0)
  {
LABEL_7:
    uint64_t v4 = v4
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16),  a2)
       + 1;
    int v3 = *(_DWORD *)(a1 + 36);
  }

void sub_100BC0418(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC0464()
{
  return 1LL;
}

void *sub_100BC046C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.InjectAssistanceTime");
}

void sub_100BC047C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875780;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC048C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875780;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC04AC()
{
  uint64_t result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875780;
  return result;
}

uint64_t sub_100BC04D4( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      uint64_t v9 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }

      else
      {
        *uint64_t v5 = *v9;
        unsigned int v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)this + 1) = v10;
      }

      *(_DWORD *)(a1 + 20) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC05E4( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC0600(uint64_t a1, unint64_t a2)
{
  if ((*(_BYTE *)(a1 + 20) & 1) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
  }
           + 1;
  else {
    uint64_t result = 0LL;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100BC063C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC0688()
{
  return 1LL;
}

void *sub_100BC0690@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.DeleteGnssData");
}

void sub_100BC06A0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018757F8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC06B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018757F8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC06D0()
{
  uint64_t result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_1018757F8;
  return result;
}

uint64_t sub_100BC06F8( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      uint64_t v9 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v9 >= v8 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }

      else
      {
        *uint64_t v5 = *v9;
        unsigned int v10 = (unsigned __int8 *)(v9 + 1);
        *((void *)this + 1) = v10;
      }

      *(_DWORD *)(a1 + 20) |= 1u;
      if (v10 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC0808( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC0824(uint64_t a1, unint64_t a2)
{
  if ((*(_BYTE *)(a1 + 20) & 1) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
  }
           + 1;
  else {
    uint64_t result = 0LL;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100BC0860(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC08AC()
{
  return 1LL;
}

void *sub_100BC08B4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetNmeaHandler");
}

void sub_100BC08C4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875870;
  sub_10008D0EC((uint64_t)a1 + 8);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC08FC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BC0910()
{
  uint64_t result = operator new(0x28uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875870;
  *((_DWORD *)result + 6) = 0;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BC0940( int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
    }

    if ((_DWORD)TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }

          a1[5] = v8 + 1;
          int v11 = sub_100BCA598();
          uint64_t v12 = *((void *)a1 + 1);
          uint64_t v13 = a1[4];
          a1[4] = v13 + 1;
          *(void *)(v12 + 8 * v13) = v11;
        }

        else
        {
          uint64_t v10 = *((void *)a1 + 1);
          a1[4] = v9 + 1;
          int v11 = *(void **)(v10 + 8 * v9);
        }

        unsigned int v14 = (char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v25)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v25 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        int v15 = *((_DWORD *)this + 14);
        int v16 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0LL;
        }
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v25);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
        int v19 = *((_DWORD *)this + 14);
        BOOL v20 = __OFSUB__(v19, 1);
        int v21 = v19 - 1;
        if (v21 < 0 == v20) {
          *((_DWORD *)this + 14) = v21;
        }
        int v22 = (_BYTE *)*((void *)this + 1);
        unsigned int v23 = (_BYTE *)*((void *)this + 2);
        if (v22 >= v23 || *v22 != 10)
        {
          if (v22 == v23 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          goto LABEL_2;
        }

        *((void *)this + 1) = v22 + 1;
      }
    }
  }

uint64_t sub_100BC0B2C( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(*(void *)(v5 + 8) + 8 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  return result;
}

uint64_t sub_100BC0B88(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100504D6C( *(void *)(*(void *)(a1 + 8) + 8 * v4),  a2);
      int v6 = (int)v5;
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }

    while (v4 < *(int *)(a1 + 16));
  }

  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100BC0C04(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC0C50()
{
  return 1LL;
}

void *sub_100BC0C58@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistancePressure");
}

void sub_100BC0C68(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018758E8;
  sub_10008D0EC((uint64_t)a1 + 8);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC0CA0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BC0CB4()
{
  uint64_t result = operator new(0x28uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_1018758E8;
  *((_DWORD *)result + 6) = 0;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BC0CE4( int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
    }

    if ((_DWORD)TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }

          a1[5] = v8 + 1;
          int v11 = sub_100BCA5D8();
          uint64_t v12 = *((void *)a1 + 1);
          uint64_t v13 = a1[4];
          a1[4] = v13 + 1;
          *(void *)(v12 + 8 * v13) = v11;
        }

        else
        {
          uint64_t v10 = *((void *)a1 + 1);
          a1[4] = v9 + 1;
          int v11 = *(_DWORD **)(v10 + 8 * v9);
        }

        unsigned int v14 = (char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v25)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v25 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        int v15 = *((_DWORD *)this + 14);
        int v16 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0LL;
        }
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v25);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
        int v19 = *((_DWORD *)this + 14);
        BOOL v20 = __OFSUB__(v19, 1);
        int v21 = v19 - 1;
        if (v21 < 0 == v20) {
          *((_DWORD *)this + 14) = v21;
        }
        int v22 = (_BYTE *)*((void *)this + 1);
        unsigned int v23 = (_BYTE *)*((void *)this + 2);
        if (v22 >= v23 || *v22 != 10)
        {
          if (v22 == v23 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          goto LABEL_2;
        }

        *((void *)this + 1) = v22 + 1;
      }
    }
  }

uint64_t sub_100BC0ED0( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(*(void *)(v5 + 8) + 8 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  return result;
}

uint64_t sub_100BC0F2C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100505278( *(void *)(*(void *)(a1 + 8) + 8 * v4),  a2);
      int v6 = (int)v5;
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }

    while (v4 < *(int *)(a1 + 16));
  }

  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100BC0FA8(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC0FF4()
{
  return 1LL;
}

void *sub_100BC0FFC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceAccel");
}

void sub_100BC100C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875960;
  sub_10008D0EC((uint64_t)a1 + 8);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC1044(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BC1058()
{
  uint64_t result = operator new(0x28uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875960;
  *((_DWORD *)result + 6) = 0;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BC1088( int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
LABEL_2:
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
    }

    if ((_DWORD)TagFallback == 10)
    {
      while (1)
      {
        int v8 = a1[5];
        uint64_t v9 = a1[4];
        if ((int)v9 >= v8)
        {
          if (v8 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a1[5];
          }

          a1[5] = v8 + 1;
          int v11 = sub_100BCA5D8();
          uint64_t v12 = *((void *)a1 + 1);
          uint64_t v13 = a1[4];
          a1[4] = v13 + 1;
          *(void *)(v12 + 8 * v13) = v11;
        }

        else
        {
          uint64_t v10 = *((void *)a1 + 1);
          a1[4] = v9 + 1;
          int v11 = *(_DWORD **)(v10 + 8 * v9);
        }

        unsigned int v14 = (char *)*((void *)this + 1);
        if ((unint64_t)v14 >= *((void *)this + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v25)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v25 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        int v15 = *((_DWORD *)this + 14);
        int v16 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0LL;
        }
        int v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v25);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
        int v19 = *((_DWORD *)this + 14);
        BOOL v20 = __OFSUB__(v19, 1);
        int v21 = v19 - 1;
        if (v21 < 0 == v20) {
          *((_DWORD *)this + 14) = v21;
        }
        int v22 = (_BYTE *)*((void *)this + 1);
        unsigned int v23 = (_BYTE *)*((void *)this + 2);
        if (v22 >= v23 || *v22 != 10)
        {
          if (v22 == v23 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          goto LABEL_2;
        }

        *((void *)this + 1) = v22 + 1;
      }
    }
  }

uint64_t sub_100BC1274( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(*(void *)(v5 + 8) + 8 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  return result;
}

uint64_t sub_100BC12D0(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100505278( *(void *)(*(void *)(a1 + 8) + 8 * v4),  a2);
      int v6 = (int)v5;
      else {
        int v7 = 1;
      }
      uint64_t v3 = (v6 + v3 + v7);
      ++v4;
    }

    while (v4 < *(int *)(a1 + 16));
  }

  *(_DWORD *)(a1 + 32) = v3;
  return v3;
}

void sub_100BC134C(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC1398()
{
  return 1LL;
}

void *sub_100BC13A0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceGyro");
}

void sub_100BC13B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018759D8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC13C0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018759D8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC13E0()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = off_1018759D8;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100BC1410( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v6 = (char *)*((void *)this + 1);
          if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          else
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            *((void *)this + 1) = v6 + 1;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          unsigned int v8 = TagFallback >> 3;
          int v9 = TagFallback & 7;
          int v11 = (char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 >= v10 || *v11 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
            if (!(_DWORD)result) {
              return result;
            }
            uint64_t v12 = (_BYTE *)*((void *)this + 1);
            unint64_t v10 = *((void *)this + 2);
          }

          else
          {
            *uint64_t v5 = *v11;
            uint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
          }

          *(_DWORD *)(a1 + 36) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 17)
          {
            *((void *)this + 1) = v12 + 1;
            goto LABEL_27;
          }
        }

        if (v8 != 2) {
          break;
        }
        int v9 = TagFallback & 7;
        if (v9 != 1) {
          goto LABEL_19;
        }
LABEL_27:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) |= 2u;
        unsigned int v14 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v14 < *((void *)this + 2) && *v14 == 25)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_31;
        }
      }

      if (v8 != 3) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 1) {
        goto LABEL_19;
      }
LABEL_31:
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
        return 0LL;
      }
      *(void *)(a1 + 24) = v15;
      *(_DWORD *)(a1 + 36) |= 4u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v9 = TagFallback & 7;
LABEL_19:
    if (v9 == 4) {
      return 1LL;
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100BC15F0( uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v4,  *(double *)(v5 + 24),  a3);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v4,  *(double *)(v5 + 16),  a3);
  if ((*(_DWORD *)(v5 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v4,  *(double *)(v5 + 24),  a3);
  }
  return result;
}

uint64_t sub_100BC1668(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 36) & 1) != 0)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 32) = result;
  return result;
}

double sub_100BC16CC(uint64_t a1, void *lpsrc)
{
  return sub_100BB8BF0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100BC1718()
{
  return 1LL;
}

void *sub_100BC1720@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceDem");
}

void sub_100BC1730(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC1740(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC1760()
{
  unsigned __int8 v0 = (char *)operator new(0x50uLL);
  *(void *)unsigned __int8 v0 = off_101875A50;
  *((void *)v0 + 9) = 0LL;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 54) = 0u;
  return result;
}

uint64_t sub_100BC179C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        unint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v10;
          int v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }

        *(_DWORD *)(a1 + 76) |= 1u;
        if ((unint64_t)v11 < v9 && *v11 == 17)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_45;
        }

        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_36;
        }
LABEL_45:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = *(void *)v39;
        *(_DWORD *)(a1 + 76) |= 2u;
        int v21 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v21 + 1;
LABEL_49:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 24) = *(void *)v39;
        *(_DWORD *)(a1 + 76) |= 4u;
        int v22 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        uint64_t v13 = v22 + 1;
        *((void *)this + 1) = v13;
LABEL_53:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v23 = v39[0];
          unsigned int v24 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unsigned int v23 = *v13;
          unsigned int v24 = v13 + 1;
          *((void *)this + 1) = v24;
        }

        *(_BYTE *)(a1 + 64) = v23 != 0;
        *(_DWORD *)(a1 + 76) |= 8u;
        *((void *)this + 1) = v24 + 1;
LABEL_61:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 32) = *(void *)v39;
        *(_DWORD *)(a1 + 76) |= 0x10u;
        unsigned int v25 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v25 + 1;
LABEL_65:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 40) = *(void *)v39;
        *(_DWORD *)(a1 + 76) |= 0x20u;
        unsigned int v26 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v26 + 1;
LABEL_69:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + memset(v19, 0, 48) = *(void *)v39;
        *(_DWORD *)(a1 + 76) |= 0x40u;
        unsigned int v27 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v27 + 1;
LABEL_73:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v39) & 1) != 0)
        {
          *(void *)(a1 + 56) = *(void *)v39;
          *(_DWORD *)(a1 + 76) |= 0x80u;
          unsigned int v28 = (_BYTE *)*((void *)this + 1);
          unint64_t v14 = *((void *)this + 2);
          if ((unint64_t)v28 < v14 && *v28 == 72)
          {
            unint64_t v15 = v28 + 1;
            *((void *)this + 1) = v15;
LABEL_77:
            if ((unint64_t)v15 >= v14 || *v15 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
              if (!(_DWORD)result) {
                return result;
              }
              unsigned int v29 = v39[0];
              unsigned int v30 = (_BYTE *)*((void *)this + 1);
              unint64_t v14 = *((void *)this + 2);
            }

            else
            {
              unsigned int v29 = *v15;
              unsigned int v30 = v15 + 1;
              *((void *)this + 1) = v30;
            }

            *(_BYTE *)(a1 + 65) = v29 != 0;
            *(_DWORD *)(a1 + 76) |= 0x100u;
            if ((unint64_t)v30 < v14 && *v30 == 80)
            {
              int v16 = v30 + 1;
              *((void *)this + 1) = v16;
LABEL_85:
              if ((unint64_t)v16 >= v14 || *v16 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                if (!(_DWORD)result) {
                  return result;
                }
                unsigned int v31 = v39[0];
                unsigned int v32 = (_BYTE *)*((void *)this + 1);
                unint64_t v14 = *((void *)this + 2);
              }

              else
              {
                unsigned int v31 = *v16;
                unsigned int v32 = v16 + 1;
                *((void *)this + 1) = v32;
              }

              *(_BYTE *)(a1 + 66) = v31 != 0;
              *(_DWORD *)(a1 + 76) |= 0x200u;
              if ((unint64_t)v32 < v14 && *v32 == 88)
              {
                int v17 = v32 + 1;
                *((void *)this + 1) = v17;
LABEL_93:
                if ((unint64_t)v17 >= v14 || *v17 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v39);
                  if (!(_DWORD)result) {
                    return result;
                  }
                  unsigned int v33 = v39[0];
                  int v34 = (_BYTE *)*((void *)this + 1);
                  unint64_t v14 = *((void *)this + 2);
                }

                else
                {
                  unsigned int v33 = *v17;
                  int v34 = v17 + 1;
                  *((void *)this + 1) = v34;
                }

                *(_BYTE *)(a1 + 67) = v33 != 0;
                *(_DWORD *)(a1 + 76) |= 0x400u;
                if ((unint64_t)v34 < v14 && *v34 == 96)
                {
                  unsigned int v18 = v34 + 1;
                  *((void *)this + 1) = v18;
LABEL_101:
                  if ((unint64_t)v18 >= v14 || *v18 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v39);
                    if (!(_DWORD)result) {
                      return result;
                    }
                    unsigned int v35 = v39[0];
                    int v36 = (_BYTE *)*((void *)this + 1);
                    unint64_t v14 = *((void *)this + 2);
                  }

                  else
                  {
                    unsigned int v35 = *v18;
                    int v36 = v18 + 1;
                    *((void *)this + 1) = v36;
                  }

                  *(_BYTE *)(a1 + 68) = v35 != 0;
                  *(_DWORD *)(a1 + 76) |= 0x800u;
                  if ((unint64_t)v36 < v14 && *v36 == 104)
                  {
                    int v19 = v36 + 1;
                    *((void *)this + 1) = v19;
LABEL_109:
                    if ((unint64_t)v19 >= v14 || *v19 < 0)
                    {
                      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v39);
                      if (!(_DWORD)result) {
                        return result;
                      }
                      unsigned int v37 = v39[0];
                      uint64_t v38 = (unsigned __int8 *)*((void *)this + 1);
                      unint64_t v14 = *((void *)this + 2);
                    }

                    else
                    {
                      unsigned int v37 = *v19;
                      uint64_t v38 = (unsigned __int8 *)(v19 + 1);
                      *((void *)this + 1) = v38;
                    }

                    *(_BYTE *)(a1 + 69) = v37 != 0;
                    *(_DWORD *)(a1 + 76) |= 0x1000u;
                    if (v38 == (unsigned __int8 *)v14
                      && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                    {
                      *((_DWORD *)this + 8) = 0;
                      uint64_t result = 1LL;
                      *((_BYTE *)this + 36) = 1;
                      return result;
                    }
                  }
                }
              }
            }
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_49;
        }
        goto LABEL_36;
      case 4u:
        int v8 = TagFallback & 7;
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_53;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_61;
        }
        goto LABEL_36;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_65;
        }
        goto LABEL_36;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_69;
        }
        goto LABEL_36;
      case 8u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_73;
        }
        goto LABEL_36;
      case 9u:
        int v8 = TagFallback & 7;
        unint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_77;
      case 0xAu:
        int v8 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_85;
      case 0xBu:
        int v8 = TagFallback & 7;
        int v17 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_93;
      case 0xCu:
        int v8 = TagFallback & 7;
        unsigned int v18 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_101;
      case 0xDu:
        int v8 = TagFallback & 7;
        int v19 = (char *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        goto LABEL_109;
      default:
        int v8 = TagFallback & 7;
LABEL_36:
        if (v8 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100BC1DC4( uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 76);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 76);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v4,  *(double *)(v5 + 16),  a3);
  int v6 = *(_DWORD *)(v5 + 76);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }

uint64_t sub_100BC1F54(uint64_t a1, unint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 76);
  if ((_BYTE)v3)
  {
    if ((v3 & 1) != 0)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 76);
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if ((v3 & 8) != 0) {
      v4 += 2;
    }
    if ((v3 & 0x10) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x20) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x40) != 0) {
      v4 += 9;
    }
    if ((v3 & 0x80) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  if ((v3 & 0xFF00) != 0)
  {
    unsigned int v6 = result + 2;
    if ((v3 & 0x100) == 0) {
      unsigned int v6 = result;
    }
    if ((v3 & 0x200) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x400) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x800) != 0) {
      v6 += 2;
    }
    if ((v3 & 0x1000) != 0) {
      uint64_t result = v6 + 2;
    }
    else {
      uint64_t result = v6;
    }
  }

  *(_DWORD *)(a1 + 72) = result;
  return result;
}

void sub_100BC203C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC2088()
{
  return 1LL;
}

void *sub_100BC2090@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceMapVector");
}

void sub_100BC20A0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875AC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC20B0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875AC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC20D0()
{
  unsigned __int8 v0 = operator new(0x28uLL);
  *unsigned __int8 v0 = off_101875AC8;
  v0[1] = 0LL;
  *(void *)&double result = 0x400000000LL;
  *((_OWORD *)v0 + 1) = xmmword_10134D8D0;
  *((_DWORD *)v0 + 8) = 0;
  return result;
}

uint64_t sub_100BC2104( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 2);
  while (2)
  {
    unsigned int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        unint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 < v9 && (*v10 & 0x80000000) == 0)
        {
          *uint64_t v5 = *v10;
          int v11 = v10 + 1;
          *((void *)this + 1) = v11;
LABEL_24:
          a1[8] |= 1u;
          if ((unint64_t)v11 < v9 && *v11 == 16)
          {
            unint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_27;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if ((_DWORD)result)
        {
          int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
          goto LABEL_24;
        }

        break;
      case 2u:
        int v8 = TagFallback & 7;
        unint64_t v12 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v12 >= v9 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v25;
        }

        else
        {
          unsigned int v17 = *v12;
          *((void *)this + 1) = v12 + 1;
        }

        if (sub_100501188(v17))
        {
          if (!sub_100501188(v17)) {
            sub_101264C90();
          }
          a1[8] |= 2u;
          a1[4] = v17;
        }

        unsigned int v18 = (_BYTE *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        unint64_t v14 = v18 + 1;
        *((void *)this + 1) = v14;
LABEL_38:
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v19 = v24;
        }

        else
        {
          unsigned int v19 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        if (sub_1001D2F54(v19))
        {
          if (!sub_1001D2F54(v19)) {
            sub_101264C68();
          }
          a1[8] |= 4u;
          a1[5] = v19;
        }

        BOOL v20 = (_BYTE *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        int v16 = v20 + 1;
        *((void *)this + 1) = v16;
LABEL_49:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v21 = v23;
        }

        else
        {
          unsigned int v21 = *v16;
          *((void *)this + 1) = v16 + 1;
        }

        if (sub_100501194(v21))
        {
          if (!sub_100501194(v21)) {
            sub_101264C40();
          }
          a1[8] |= 8u;
          a1[6] = v21;
        }

        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }

        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_38;
      case 4u:
        int v8 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_49;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BC2404( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = (int *)result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = v5[8];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v5[4],  v4,  a4);
  int v6 = v5[8];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  v5[6],  v4,  a4);
  }

uint64_t sub_100BC2498(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_28;
  }

  if ((*(_BYTE *)(a1 + 32) & 1) != 0)
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
       + 1;
    int v3 = *(_DWORD *)(a1 + 32);
    if ((v3 & 2) == 0) {
      goto LABEL_13;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
      goto LABEL_13;
    }
  }

  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 11;
  }

  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }

  else
  {
    int v6 = 2;
  }

  uint64_t v4 = (v6 + v4);
LABEL_13:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0) {
      goto LABEL_28;
    }
    goto LABEL_22;
  }

  int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
  if ((v7 & 0x80000000) != 0)
  {
    int v8 = 11;
  }

  else if (v7 >= 0x80)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }

  else
  {
    int v8 = 2;
  }

  uint64_t v4 = (v8 + v4);
  if ((v3 & 8) != 0)
  {
LABEL_22:
    unint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 11;
    }

    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
    }

    else
    {
      int v10 = 2;
    }

    uint64_t v4 = (v10 + v4);
  }

void sub_100BC258C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC25D8()
{
  return 1LL;
}

void *sub_100BC25E0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceMotionActivityContext");
}

void sub_100BC25F0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875B40;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC2600(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875B40;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC2620()
{
  unsigned __int8 v0 = operator new(0x20uLL);
  *unsigned __int8 v0 = off_101875B40;
  v0[1] = 0LL;
  *(void *)&double result = 4LL;
  v0[2] = 4LL;
  *((_DWORD *)v0 + 6) = 0;
  return result;
}

uint64_t sub_100BC2654( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v8 = TagFallback & 7;
      int v11 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        unint64_t v12 = (_BYTE *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }

      else
      {
        *uint64_t v5 = *v11;
        unint64_t v12 = v11 + 1;
        *((void *)this + 1) = v12;
      }

      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v12 < v9 && *v12 == 16)
      {
        int v10 = v12 + 1;
        *((void *)this + 1) = v10;
LABEL_24:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v15);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = v15;
        }

        else
        {
          unsigned int v13 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        if (sub_10006417C(v13))
        {
          if (!sub_10006417C(v13)) {
            sub_101264CB8();
          }
          *(_DWORD *)(a1 + 24) |= 2u;
          *(_DWORD *)(a1 + 16) = v13;
        }

        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_24;
      }
    }

    else
    {
      int v8 = TagFallback & 7;
    }

uint64_t sub_100BC2814( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  v4,  a4);
  }
  return result;
}

uint64_t sub_100BC286C(uint64_t a1, unint64_t a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      if ((*(_DWORD *)(a1 + 24) & 2) == 0) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v3 = 0LL;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
        goto LABEL_13;
      }
    }

    int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v4 & 0x80000000) != 0)
    {
      int v5 = 11;
    }

    else if (v4 >= 0x80)
    {
      int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2) + 1;
    }

    else
    {
      int v5 = 2;
    }

    uint64_t v3 = (v5 + v3);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

void sub_100BC28F0(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC293C()
{
  return 1LL;
}

void *sub_100BC2944@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceMountState");
}

void sub_100BC2954(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC2964(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC2984()
{
  unsigned __int8 v0 = operator new(0x18uLL);
  *unsigned __int8 v0 = off_101875BB8;
  *(void *)&double result = 15LL;
  v0[1] = 15LL;
  *((_DWORD *)v0 + 4) = 0;
  return result;
}

uint64_t sub_100BC29B8( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v8 = v10;
      }

      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }

      if (sub_1005011D4(v8))
      {
        if ((sub_1005011D4(v8) & 1) == 0) {
          sub_101264CE0();
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }

      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC2AEC( uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC2B08(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11LL;
    }

    else if (v4 >= 0x80)
    {
    }

    else
    {
      uint64_t result = 2LL;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100BC2B60(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC2BAC()
{
  return 1LL;
}

void *sub_100BC2BB4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceSignalEnvironment");
}

void sub_100BC2BC4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875C30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC2BD4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875C30;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC2BF4()
{
  unsigned __int8 v0 = (char *)operator new(0x30uLL);
  *(void *)unsigned __int8 v0 = off_101875C30;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *((void *)v0 + 5) = 0LL;
  return result;
}

uint64_t sub_100BC2C28( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        unsigned int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v10;
          int v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }

        *(_DWORD *)(a1 + 44) |= 1u;
        if ((unint64_t)v11 < v9 && *v11 == 17)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_26;
        }

        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_18;
        }
LABEL_26:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 44) |= 2u;
        unsigned int v13 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v13 + 1;
LABEL_30:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 24) = v15;
        *(_DWORD *)(a1 + 44) |= 4u;
        unint64_t v14 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v14 + 1;
LABEL_34:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) != 0)
        {
          *(void *)(a1 + 32) = v15;
          *(_DWORD *)(a1 + 44) |= 8u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 1) {
          goto LABEL_30;
        }
        goto LABEL_18;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_18;
        }
        goto LABEL_34;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100BC2E68( uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 44);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v4,  *(double *)(v5 + 16),  a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  v4,  *(double *)(v5 + 32),  a3);
  }

uint64_t sub_100BC2EFC(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 44);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 44) & 1) != 0)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 44);
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if ((v3 & 8) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 40) = result;
  return result;
}

double sub_100BC2F6C(uint64_t a1, void *lpsrc)
{
  return sub_100BB91BC(a1, (uint64_t)lpsrc);
}

uint64_t sub_100BC2FB8()
{
  return 1LL;
}

void *sub_100BC2FC0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceSpeedConstraint");
}

void sub_100BC2FD0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875CA8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC2FE0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875CA8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100BC3000()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = off_101875CA8;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100BC3030( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v6 = (char *)*((void *)this + 1);
          if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          else
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            *((void *)this + 1) = v6 + 1;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          unsigned int v8 = TagFallback >> 3;
          int v9 = TagFallback & 7;
          int v11 = (char *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 >= v10 || *v11 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
            if (!(_DWORD)result) {
              return result;
            }
            unint64_t v12 = (_BYTE *)*((void *)this + 1);
            unint64_t v10 = *((void *)this + 2);
          }

          else
          {
            *uint64_t v5 = *v11;
            unint64_t v12 = v11 + 1;
            *((void *)this + 1) = v12;
          }

          *(_DWORD *)(a1 + 36) |= 1u;
          if ((unint64_t)v12 < v10 && *v12 == 17)
          {
            *((void *)this + 1) = v12 + 1;
            goto LABEL_27;
          }
        }

        if (v8 != 2) {
          break;
        }
        int v9 = TagFallback & 7;
        if (v9 != 1) {
          goto LABEL_19;
        }
LABEL_27:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) |= 2u;
        unint64_t v14 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v14 < *((void *)this + 2) && *v14 == 25)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_31;
        }
      }

      if (v8 != 3) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 1) {
        goto LABEL_19;
      }
LABEL_31:
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v15) & 1) == 0) {
        return 0LL;
      }
      *(void *)(a1 + 24) = v15;
      *(_DWORD *)(a1 + 36) |= 4u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v9 = TagFallback & 7;
LABEL_19:
    if (v9 == 4) {
      return 1LL;
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100BC3210( uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v4,  *(double *)(v5 + 24),  a3);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v4,  *(double *)(v5 + 16),  a3);
  if ((*(_DWORD *)(v5 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v4,  *(double *)(v5 + 24),  a3);
  }
  return result;
}

uint64_t sub_100BC3288(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 36) & 1) != 0)
    {
      unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      uint64_t result = v4 + 9;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 32) = result;
  return result;
}

double sub_100BC32EC(uint64_t a1, void *lpsrc)
{
  return sub_100BB92C4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100BC3338()
{
  return 1LL;
}

void *sub_100BC3340@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetAssistanceAlongTrackVelocity");
}

void sub_100BC3350(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875D20;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC3360(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875D20;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC3380()
{
  uint64_t result = operator new(0x20uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875D20;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100BC33AC( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  int v6 = (unsigned int *)(a1 + 16);
  while (1)
  {
    while (1)
    {
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v7 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v9 = TagFallback & 7;
      unint64_t v12 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v13 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }

      else
      {
        *uint64_t v5 = *v12;
        unsigned int v13 = v12 + 1;
        *((void *)this + 1) = v13;
      }

      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        int v11 = v13 + 1;
        *((void *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          *int v6 = *v11;
          unint64_t v14 = (unsigned __int8 *)(v11 + 1);
          *((void *)this + 1) = v14;
        }

        *(_DWORD *)(a1 + 24) |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_24;
      }
    }

    else
    {
      int v9 = TagFallback & 7;
    }

uint64_t sub_100BC3548( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  v4,  a4);
  }
  return result;
}

uint64_t sub_100BC35A0(uint64_t a1, unint64_t a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
         + 1;
      if ((*(_DWORD *)(a1 + 24) & 2) == 0) {
        goto LABEL_11;
      }
    }

    else
    {
      uint64_t v3 = 0LL;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
        goto LABEL_11;
      }
    }

    unsigned int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    else {
      int v5 = 2;
    }
    uint64_t v3 = (v5 + v3);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

void sub_100BC3618(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC3664()
{
  return 1LL;
}

void *sub_100BC366C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetThermalRiskState");
}

void sub_100BC367C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875D98;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC368C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875D98;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_BYTE *sub_100BC36AC()
{
  uint64_t result = operator new(0x18uLL);
  *(void *)uint64_t result = off_101875D98;
  result[8] = 0;
  *((void *)result + 2) = 0LL;
  *((_DWORD *)result + 3) = 0;
  return result;
}

uint64_t sub_100BC36DC( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v7 = TagFallback & 7;
      unint64_t v10 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v10 >= v8 || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v11 = v16;
        unint64_t v12 = (_BYTE *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }

      else
      {
        unsigned int v11 = *v10;
        unint64_t v12 = v10 + 1;
        *((void *)this + 1) = v12;
      }

      *(_BYTE *)(a1 + 8) = v11 != 0;
      *(_DWORD *)(a1 + 20) |= 1u;
      if ((unint64_t)v12 < v8 && *v12 == 16)
      {
        int v9 = v12 + 1;
        *((void *)this + 1) = v9;
LABEL_23:
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = v17;
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v13 = *v9;
          unint64_t v14 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v14;
        }

        *(_DWORD *)(a1 + 12) = v13;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v14 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_23;
      }
    }

    else
    {
      int v7 = TagFallback & 7;
    }

uint64_t sub_100BC3880( uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC38D8(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[5];
  if ((_BYTE)v3)
  {
    uint64_t v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[3];
      if ((v5 & 0x80000000) != 0)
      {
        int v6 = 11;
      }

      else if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      }

      else
      {
        int v6 = 2;
      }

      uint64_t v4 = (v6 + v4);
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  a1[4] = v4;
  return v4;
}

void sub_100BC3944(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC3990()
{
  return 1LL;
}

void *sub_100BC3998@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetConfigSimulatorMode");
}

void sub_100BC39A8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875E10;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC39B8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875E10;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC39D8()
{
  uint64_t result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101875E10;
  return result;
}

uint64_t sub_100BC3A00( unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = a1 + 2;
  int v6 = a1 + 3;
  while (1)
  {
    while (1)
    {
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v7 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v9 = TagFallback & 7;
      unint64_t v12 = (char *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v13 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
      }

      else
      {
        *uint64_t v5 = *v12;
        unsigned int v13 = v12 + 1;
        *((void *)this + 1) = v13;
      }

      a1[5] |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        unsigned int v11 = v13 + 1;
        *((void *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          *int v6 = *v11;
          unint64_t v14 = (unsigned __int8 *)(v11 + 1);
          *((void *)this + 1) = v14;
        }

        a1[5] |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_24;
      }
    }

    else
    {
      int v9 = TagFallback & 7;
    }

uint64_t sub_100BC3B9C( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC3BF4(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 20);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if (v5 >= 0x80)
      {
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_14;
        }
      }

      else
      {
        uint64_t v4 = 2LL;
        if ((v3 & 2) == 0) {
          goto LABEL_14;
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
      if ((*(_BYTE *)(a1 + 20) & 2) == 0) {
        goto LABEL_14;
      }
    }

    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    else {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

void sub_100BC3C80(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC3CCC()
{
  return 1LL;
}

void *sub_100BC3CD4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetConfigEnableGnssConstellations");
}

void sub_100BC3CE4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875E88;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC3CF4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875E88;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_WORD *sub_100BC3D14()
{
  uint64_t result = operator new(0x18uLL);
  *(void *)uint64_t result = off_101875E88;
  result[4] = 0;
  *((_DWORD *)result + 3) = 0;
  *((_DWORD *)result + 4) = 0;
  return result;
}

uint64_t sub_100BC3D40( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v7 = TagFallback & 7;
      unint64_t v10 = (char *)*((void *)this + 1);
      unint64_t v8 = *((void *)this + 2);
      if ((unint64_t)v10 >= v8 || *v10 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v11 = v17;
        unint64_t v12 = (_BYTE *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
      }

      else
      {
        unsigned int v11 = *v10;
        unint64_t v12 = v10 + 1;
        *((void *)this + 1) = v12;
      }

      *(_BYTE *)(a1 + 8) = v11 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if ((unint64_t)v12 < v8 && *v12 == 16)
      {
        int v9 = v12 + 1;
        *((void *)this + 1) = v9;
LABEL_23:
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = v16;
          unint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v13 = *v9;
          unint64_t v14 = (unsigned __int8 *)(v9 + 1);
          *((void *)this + 1) = v14;
        }

        *(_BYTE *)(a1 + 9) = v13 != 0;
        *(_DWORD *)(a1 + 16) |= 2u;
        if (v14 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_23;
      }
    }

    else
    {
      int v7 = TagFallback & 7;
    }

uint64_t sub_100BC3EEC( uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 16);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 16);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(unsigned __int8 *)(v5 + 9),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC3F44(uint64_t a1)
{
  unsigned int v1 = 2 * (*(_DWORD *)(a1 + 16) & 1);
  if ((*(_DWORD *)(a1 + 16) & 2) != 0) {
    v1 += 2;
  }
  else {
    uint64_t v2 = 0LL;
  }
  *(_DWORD *)(a1 + 12) = v2;
  return v2;
}

void sub_100BC3F6C(uint64_t a1, _BYTE *lpsrc)
{
}

uint64_t sub_100BC3FB8()
{
  return 1LL;
}

void *sub_100BC3FC0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetConfigRfBandEnable");
}

void sub_100BC3FD0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875F00;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC3FE0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875F00;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_BYTE *sub_100BC4000()
{
  uint64_t result = operator new(0x18uLL);
  *(void *)uint64_t result = off_101875F00;
  result[8] = 0;
  *((_DWORD *)result + 3) = 0;
  *((_DWORD *)result + 4) = 0;
  return result;
}

uint64_t sub_100BC402C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      unint64_t v8 = (char *)*((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      if ((unint64_t)v8 >= v7 || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v9 = v12;
        unint64_t v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v7 = *((void *)this + 2);
      }

      else
      {
        unsigned int v9 = *v8;
        unint64_t v10 = (unsigned __int8 *)(v8 + 1);
        *((void *)this + 1) = v10;
      }

      *(_BYTE *)(a1 + 8) = v9 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if (v10 == (unsigned __int8 *)v7 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC4144( uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC4160(uint64_t a1)
{
  else {
    uint64_t v1 = 0LL;
  }
  *(_DWORD *)(a1 + 12) = v1;
  return v1;
}

void sub_100BC417C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC41C8()
{
  return 1LL;
}

void *sub_100BC41D0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.SetConfigDutyCycling");
}

void sub_100BC41E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875F78;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC4210(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875F78;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BC4244()
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = off_101875F78;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0LL;
  return result;
}

uint64_t sub_100BC4274( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      unint64_t v7 = *(void **)(a1 + 8);
      if (v7 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        unint64_t v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        void *v7 = 0LL;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v7);
      if (!(_DWORD)result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC4380(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString( 1LL,  *(void *)(result + 8),  a2);
  }
  return result;
}

uint64_t sub_100BC439C(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 20) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8,  a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(_BYTE *)(v4 + 23);
    }

    else
    {
      int v9 = 2;
    }

    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100BC4418(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC4464()
{
  return 1LL;
}

void *sub_100BC446C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.TerminationImminent");
}

void sub_100BC447C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875FF0;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC44AC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101875FF0;
  sub_10006AF90((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BC44E0()
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = off_101875FF0;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = 0LL;
  return result;
}

uint64_t sub_100BC4510( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 10) {
        break;
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      uint64_t v7 = *(void **)(a1 + 8);
      if (v7 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        uint64_t v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        void *v7 = 0LL;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v7);
      if (!(_DWORD)result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC461C(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString( 1LL,  *(void *)(result + 8),  a2);
  }
  return result;
}

uint64_t sub_100BC4638(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 20) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v8 = v7;
    }
    if (v8 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8,  a2);
      int v5 = *(unsigned __int8 *)(v4 + 23);
      uint64_t v7 = *(void *)(v4 + 8);
      int v9 = v10 + 1;
      char v6 = *(_BYTE *)(v4 + 23);
    }

    else
    {
      int v9 = 2;
    }

    if (v6 < 0) {
      int v5 = v7;
    }
    uint64_t result = (v9 + v5);
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_100BC46B4(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC4700()
{
  return 1LL;
}

void *sub_100BC4708@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.ExitMessage");
}

void sub_100BC4718(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  10285LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      char v7 = *(_BYTE *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_BYTE *)(a1 + 12) = v7;
      int v5 = *(_DWORD *)(a2 + 20);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_12;
      }
    }

    else if ((*(_BYTE *)(a2 + 20) & 2) == 0)
    {
      goto LABEL_6;
    }

    int v8 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 2u;
    *(_DWORD *)(a1 + 8) = v8;
    int v5 = *(_DWORD *)(a2 + 20);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        return;
      }
      goto LABEL_8;
    }

void sub_100BC4808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC4820(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876068;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC4830(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876068;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

char *sub_100BC4850()
{
  uint64_t result = (char *)operator new(0x18uLL);
  *(void *)uint64_t result = off_101876068;
  *((void *)result + 2) = 0LL;
  *((_DWORD *)result + 2) = 0;
  *(_DWORD *)(result + 11) = 0;
  return result;
}

uint64_t sub_100BC4880(uint64_t result)
{
  if (*(_BYTE *)(result + 20))
  {
    *(_DWORD *)(result + 11) = 0;
    *(_DWORD *)(result + 8) = 0;
  }

  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BC4898( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    int v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        char v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 < v8 && (*v9 & 0x80000000) == 0)
        {
          unsigned int v10 = *v9;
          unsigned int v11 = v9 + 1;
          *((void *)this + 1) = v11;
LABEL_23:
          *(_BYTE *)(a1 + 12) = v10 != 0;
          *(_DWORD *)(a1 + 20) |= 1u;
          if ((unint64_t)v11 < v8 && *v11 == 16)
          {
            unsigned int v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_26;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
        if ((_DWORD)result)
        {
          unsigned int v10 = v22;
          unsigned int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_23;
        }

        break;
      case 2u:
        int v7 = TagFallback & 7;
        unsigned int v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_26:
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v15 = v22;
          unsigned int v16 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v15 = *v12;
          unsigned int v16 = v12 + 1;
          *((void *)this + 1) = v16;
        }

        *(_DWORD *)(a1 + 8) = v15;
        *(_DWORD *)(a1 + 20) |= 2u;
        unsigned int v13 = v16 + 1;
        *((void *)this + 1) = v13;
LABEL_34:
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v22;
          unsigned int v18 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v17 = *v13;
          unsigned int v18 = v13 + 1;
          *((void *)this + 1) = v18;
        }

        *(_BYTE *)(a1 + 13) = v17 != 0;
        *(_DWORD *)(a1 + 20) |= 4u;
        unint64_t v14 = v18 + 1;
        *((void *)this + 1) = v14;
LABEL_42:
        if ((unint64_t)v14 >= v8 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v19 = v22;
          BOOL v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v19 = *v14;
          BOOL v20 = (unsigned __int8 *)(v14 + 1);
          *((void *)this + 1) = v20;
        }

        *(_BYTE *)(a1 + 14) = v19 != 0;
        *(_DWORD *)(a1 + 20) |= 8u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_34;
      case 4u:
        int v7 = TagFallback & 7;
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_42;
      default:
        int v7 = TagFallback & 7;
LABEL_17:
        if (v7 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BC4B54( uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 12),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 8),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 20);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  *(unsigned __int8 *)(v5 + 14),  a2,  a4);
  }

uint64_t sub_100BC4BE8(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[5];
  if ((_BYTE)v3)
  {
    int v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[2];
      if ((v5 & 0x80000000) != 0)
      {
        int v6 = 11;
      }

      else if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
        unsigned int v3 = a1[5];
      }

      else
      {
        int v6 = 2;
      }

      v4 += v6;
    }

    unsigned int v8 = v4 + 2;
    if ((v3 & 4) == 0) {
      unsigned int v8 = v4;
    }
    if ((v3 & 8) != 0) {
      uint64_t result = v8 + 2;
    }
    else {
      uint64_t result = v8;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  a1[4] = result;
  return result;
}

void sub_100BC4C6C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC4CB8()
{
  return 1LL;
}

void *sub_100BC4CC0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.RecoveryStatistics.RecoveryStatus");
}

void sub_100BC4CD0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v12,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  10538LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v12,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      int v6 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 32) |= 1u;
      int v7 = *(std::string **)(a1 + 8);
      if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        int v7 = (std::string *)operator new(0x18uLL);
        v7->__r_.__value_.__l.__size_ = 0LL;
        v7->__r_.__value_.__l.__cap_ = 0LL;
        v7->__r_.__value_.__r.__words[0] = 0LL;
        *(void *)(a1 + 8) = v7;
      }

      std::string::operator=(v7, v6);
      int v5 = *(_DWORD *)(a2 + 32);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_12;
      }
    }

    else if ((*(_BYTE *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }

    int v8 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(_DWORD *)(a1 + 24) = v8;
    if ((*(_DWORD *)(a2 + 32) & 4) == 0) {
      return;
    }
LABEL_12:
    char v9 = *(const std::string **)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 4u;
    unsigned int v10 = *(std::string **)(a1 + 16);
    if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      unsigned int v10 = (std::string *)operator new(0x18uLL);
      v10->__r_.__value_.__l.__size_ = 0LL;
      v10->__r_.__value_.__l.__cap_ = 0LL;
      v10->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a1 + 16) = v10;
    }

    std::string::operator=(v10, v9);
  }

void sub_100BC4DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC4E10(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018760E0;
  sub_10007A578((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC4E40(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018760E0;
  sub_10007A578((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BC4E74()
{
  uint64_t result = operator new(0x28uLL);
  *uint64_t result = off_1018760E0;
  result[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[3] = 0LL;
  *((_DWORD *)result + 8) = 0;
  return result;
}

uint64_t sub_100BC4EA8(uint64_t result)
{
  if (*(_BYTE *)(result + 32))
  {
    if ((*(_BYTE *)(result + 32) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(_BYTE **)uint64_t v1 = 0;
          *(void *)(v1 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v1 = 0;
          *(_BYTE *)(v1 + 23) = 0;
        }
      }
    }

    *(_DWORD *)(result + 24) = 0;
    if ((*(_BYTE *)(result + 32) & 4) != 0)
    {
      uint64_t v2 = *(void *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }

  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100BC4F28( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v5 = (char *)*((void *)this + 1);
          if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          else
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            *((void *)this + 1) = v5 + 1;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          unsigned int v7 = TagFallback >> 3;
          int v8 = TagFallback & 7;
          if (v8 != 2) {
            goto LABEL_24;
          }
          *(_DWORD *)(a1 + 32) |= 1u;
          unsigned int v10 = *(void **)(a1 + 8);
          if (v10 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
          {
            unsigned int v10 = operator new(0x18uLL);
            v10[1] = 0LL;
            v10[2] = 0LL;
            *unsigned int v10 = 0LL;
            *(void *)(a1 + 8) = v10;
          }

          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v10);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v13 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
          if ((unint64_t)v13 < v12 && *v13 == 16)
          {
            unint64_t v14 = v13 + 1;
            *((void *)this + 1) = v14;
            goto LABEL_20;
          }
        }

        if (v7 != 2) {
          break;
        }
        int v8 = TagFallback & 7;
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
LABEL_20:
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v15 = v18;
          unsigned int v16 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unsigned int v15 = *v14;
          unsigned int v16 = v14 + 1;
          *((void *)this + 1) = v16;
        }

        *(_DWORD *)(a1 + 24) = v15;
        int v9 = *(_DWORD *)(a1 + 32) | 2;
        *(_DWORD *)(a1 + 32) = v9;
        if ((unint64_t)v16 < v12 && *v16 == 26)
        {
          *((void *)this + 1) = v16 + 1;
          goto LABEL_32;
        }
      }

      if (v7 != 3) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_24;
      }
      int v9 = *(_DWORD *)(a1 + 32);
LABEL_32:
      *(_DWORD *)(a1 + 32) = v9 | 4;
      unsigned int v17 = *(void **)(a1 + 16);
      if (v17 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        unsigned int v17 = operator new(0x18uLL);
        v17[1] = 0LL;
        v17[2] = 0LL;
        void *v17 = 0LL;
        *(void *)(a1 + 16) = v17;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v17);
      if (!(_DWORD)result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v8 = TagFallback & 7;
LABEL_24:
    if (v8 == 4) {
      return 1LL;
    }
  }

uint64_t sub_100BC5140( uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString( 1LL,  *(void *)(result + 8),  a2);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString( 3LL,  *(void *)(v5 + 16),  a2);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 24),  a2,  a4);
  if ((*(_DWORD *)(v5 + 32) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(3LL, *(void *)(v5 + 16), a2);
  }
  return result;
}

uint64_t sub_100BC51B8(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_31;
  }

  if ((*(_BYTE *)(a1 + 32) & 1) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9,  a2);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v10 = v11 + 1;
      int v3 = *(_DWORD *)(a1 + 32);
      char v7 = *(_BYTE *)(v5 + 23);
    }

    else
    {
      int v10 = 2;
    }

    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v4 = (v10 + v6);
    if ((v3 & 2) == 0) {
      goto LABEL_21;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
      goto LABEL_21;
    }
  }

  unint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if ((v12 & 0x80000000) != 0)
  {
    int v13 = 11;
  }

  else if (v12 >= 0x80)
  {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }

  else
  {
    int v13 = 2;
  }

  uint64_t v4 = (v13 + v4);
LABEL_21:
  if ((v3 & 4) != 0)
  {
    uint64_t v14 = *(void *)(a1 + 16);
    int v15 = *(unsigned __int8 *)(v14 + 23);
    char v16 = v15;
    uint64_t v17 = *(void *)(v14 + 8);
    if ((v15 & 0x80u) == 0) {
      unint64_t v18 = *(unsigned __int8 *)(v14 + 23);
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18 >= 0x80)
    {
      int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18,  a2);
      int v15 = *(unsigned __int8 *)(v14 + 23);
      uint64_t v17 = *(void *)(v14 + 8);
      char v16 = *(_BYTE *)(v14 + 23);
    }

    else
    {
      int v19 = 1;
    }

    if (v16 < 0) {
      int v15 = v17;
    }
    uint64_t v4 = (v4 + v19 + v15 + 1);
  }

void sub_100BC52DC(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC5328()
{
  return 1LL;
}

void *sub_100BC5330@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.RecoveryStatistics.RecoveryPoint");
}

void sub_100BC5340(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876158;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A1E20 != a1)
  {
    uint64_t v2 = *((void *)a1 + 4);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  sub_10008D0EC((uint64_t)a1 + 8);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC53A0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100BC53B4()
{
  uint64_t result = operator new(0x30uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101876158;
  *((_DWORD *)result + 6) = 0;
  result[4] = 0LL;
  result[5] = 0LL;
  return result;
}

uint64_t sub_100BC53E4( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 8);
  do
  {
    while (1)
    {
LABEL_2:
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v8 = TagFallback & 7;
      if (v8 == 2)
      {
        while (1)
        {
          int v11 = *(_DWORD *)(a1 + 20);
          uint64_t v12 = *(int *)(a1 + 16);
          if ((int)v12 >= v11)
          {
            if (v11 == *(_DWORD *)(a1 + 24))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v11 + 1);
              int v11 = *(_DWORD *)(a1 + 20);
            }

            *(_DWORD *)(a1 + 20) = v11 + 1;
            uint64_t v14 = operator new(0x28uLL);
            void *v14 = off_1018760E0;
            v14[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
            v14[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
            v14[3] = 0LL;
            *((_DWORD *)v14 + 8) = 0;
            uint64_t v15 = *(void *)(a1 + 8);
            uint64_t v16 = *(int *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v16 + 1;
            *(void *)(v15 + 8 * v16) = v14;
          }

          else
          {
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(a1 + 16) = v12 + 1;
            uint64_t v14 = *(void **)(v13 + 8 * v12);
          }

          uint64_t v17 = (char *)*((void *)this + 1);
          if ((unint64_t)v17 >= *((void *)this + 2) || *v17 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v34)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v34 = *v17;
            *((void *)this + 1) = v17 + 1;
          }

          int v18 = *((_DWORD *)this + 14);
          int v19 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v18 + 1;
          if (v18 >= v19) {
            return 0LL;
          }
          int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v34);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
          int v22 = *((_DWORD *)this + 14);
          BOOL v23 = __OFSUB__(v22, 1);
          int v24 = v22 - 1;
          if (v24 < 0 == v23) {
            *((_DWORD *)this + 14) = v24;
          }
          unsigned int v25 = (unsigned __int8 *)*((void *)this + 1);
          int v26 = *v25;
          if (v26 != 10)
          {
            if (v26 != 18) {
              goto LABEL_2;
            }
            *((void *)this + 1) = v25 + 1;
            goto LABEL_10;
          }

          *((void *)this + 1) = v25 + 1;
        }
      }

uint64_t sub_100BC570C( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(*(void *)(v5 + 8) + 8 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  if ((*(_BYTE *)(v5 + 44) & 2) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 32);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A1E20 + 32);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v7,  a2,  a4);
  }

  return result;
}

uint64_t sub_100BC579C(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 44) & 2) != 0)
  {
    uint64_t v4 = *(unsigned int **)(a1 + 32);
    if (!v4) {
      uint64_t v4 = *(unsigned int **)(qword_1019A1E20 + 32);
    }
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BC4BE8(v4, a2);
    int v6 = (int)v5;
    else {
      int v7 = 1;
    }
    int v3 = v6 + v7 + 1;
  }

  else
  {
    int v3 = 0;
  }

  int v8 = *(_DWORD *)(a1 + 16);
  uint64_t v9 = (v8 + v3);
  if (v8 >= 1)
  {
    uint64_t v10 = 0LL;
    do
    {
      int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BC51B8( *(void *)(*(void *)(a1 + 8) + 8 * v10),  a2);
      int v12 = (int)v11;
      else {
        int v13 = 1;
      }
      uint64_t v9 = (v12 + v9 + v13);
      ++v10;
    }

    while (v10 < *(int *)(a1 + 16));
  }

  *(_DWORD *)(a1 + 40) = v9;
  return v9;
}

void sub_100BC5868(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC58B4()
{
  return 1LL;
}

void *sub_100BC58BC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.RecoveryStatistics");
}

void sub_100BC58CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018761D0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC58DC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018761D0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC58FC()
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = off_1018761D0;
  result[1] = 0LL;
  *((_DWORD *)result + 4) = 0;
  return result;
}

uint64_t sub_100BC5924( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      int v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v8 = v10;
      }

      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }

      if (v8 <= 4)
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }

      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC5A3C( uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC5A58(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11LL;
    }

    else if (v4 >= 0x80)
    {
    }

    else
    {
      uint64_t result = 2LL;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100BC5AB0(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC5AFC()
{
  return 1LL;
}

void *sub_100BC5B04@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfoRequest");
}

void sub_100BC5B14(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  11203LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_10004AAFC(a1 + 16, *(_DWORD *)(a1 + 24) + v5);
    memcpy((void *)(*(void *)(a1 + 16) + 4LL * *(int *)(a1 + 24)), *(const void **)(a2 + 16), 4LL * *(int *)(a2 + 24));
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
  }

  int v6 = *(_DWORD *)(a2 + 40);
  if (v6)
  {
    sub_10004AAFC(a1 + 32, *(_DWORD *)(a1 + 40) + v6);
    memcpy((void *)(*(void *)(a1 + 32) + 4LL * *(int *)(a1 + 40)), *(const void **)(a2 + 32), 4LL * *(int *)(a2 + 40));
    *(_DWORD *)(a1 + 40) += *(_DWORD *)(a2 + 40);
  }

  LOBYTE(v7) = *(_BYTE *)(a2 + 52);
  if ((_BYTE)v7)
  {
    if ((*(_BYTE *)(a2 + 52) & 1) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 52) |= 1u;
      *(_DWORD *)(a1 + 8) = v8;
      int v7 = *(_DWORD *)(a2 + 52);
    }

    if ((v7 & 2) != 0)
    {
      int v9 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 52) |= 2u;
      *(_DWORD *)(a1 + 12) = v9;
    }
  }

void sub_100BC5C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC5C5C(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101876248;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2) {
    operator delete[](v2);
  }
  int v3 = (void *)*((void *)this + 2);
  if (v3) {
    operator delete[](v3);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100BC5CA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100BC5CB8()
{
  unsigned __int8 v0 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v0 = &off_101876248;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  return result;
}

uint64_t sub_100BC5CEC(uint64_t result)
{
  if (*(_BYTE *)(result + 52)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

uint64_t sub_100BC5D08( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 32;
  uint64_t v6 = a1 + 16;
  uint64_t v42 = (unsigned int *)(a1 + 8);
  int v7 = (unsigned int *)(a1 + 12);
LABEL_2:
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        int v12 = (char *)*((void *)this + 1);
        int v11 = (char *)*((void *)this + 2);
        if (v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v42);
          if (!(_DWORD)result) {
            return result;
          }
          int v13 = (char *)*((void *)this + 1);
          int v11 = (char *)*((void *)this + 2);
        }

        else
        {
          *uint64_t v42 = *v12;
          int v13 = v12 + 1;
          *((void *)this + 1) = v13;
        }

        *(_DWORD *)(a1 + 52) |= 1u;
        if (v13 < v11 && *v13 == 16)
        {
          uint64_t v14 = v13 + 1;
          *((void *)this + 1) = v14;
          goto LABEL_33;
        }

        continue;
      case 2u:
        int v10 = TagFallback & 7;
        uint64_t v14 = (char *)*((void *)this + 1);
        int v11 = (char *)*((void *)this + 2);
LABEL_33:
        if (v14 >= v11 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          int v18 = (char *)*((void *)this + 1);
          int v11 = (char *)*((void *)this + 2);
        }

        else
        {
          unsigned int *v7 = *v14;
          int v18 = v14 + 1;
          *((void *)this + 1) = v18;
        }

        *(_DWORD *)(a1 + 52) |= 2u;
        if (v18 >= v11) {
          continue;
        }
        int v19 = *v18;
        goto LABEL_61;
      case 3u:
        int v10 = TagFallback & 7;
        if (v10 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            uint64_t v15 = (char *)*((void *)this + 1);
            int v11 = (char *)*((void *)this + 2);
            goto LABEL_40;
          }

          goto LABEL_21;
        }

        uint64_t result = sub_10081A7F0(this, v6);
        if (!(_DWORD)result) {
          return result;
        }
        while (1)
        {
          int v18 = (char *)*((void *)this + 1);
          int v11 = (char *)*((void *)this + 2);
          if (v18 >= v11) {
            goto LABEL_2;
          }
          int v19 = *v18;
          if (v19 == 32) {
            goto LABEL_82;
          }
LABEL_61:
          if (v19 != 24) {
            goto LABEL_2;
          }
          uint64_t v15 = v18 + 1;
          *((void *)this + 1) = v15;
LABEL_40:
          if (v15 >= v11 || *v15 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v45);
            if (!(_DWORD)result) {
              return result;
            }
            unsigned int v20 = v45[0];
          }

          else
          {
            unsigned int v20 = *v15;
            *((void *)this + 1) = v15 + 1;
          }

          int v21 = *(_DWORD *)(a1 + 24);
          if (v21 == *(_DWORD *)(a1 + 28))
          {
            sub_10004AAFC(v6, v21 + 1);
            int v21 = *(_DWORD *)(a1 + 24);
          }

          uint64_t v22 = *(void *)(a1 + 16);
          *(_DWORD *)(a1 + 24) = v21 + 1;
          *(_DWORD *)(v22 + 4LL * v21) = v20;
          int v23 = *(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 24);
          if (v23 >= 1)
          {
            int v24 = v23 + 1;
            do
            {
              unsigned int v25 = (_BYTE *)*((void *)this + 1);
              unint64_t v26 = *((void *)this + 2);
              *((void *)this + 1) = v25 + 1;
              if ((unint64_t)(v25 + 1) >= v26 || (char)v25[1] < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v45);
                if (!(_DWORD)result) {
                  return result;
                }
                unsigned int v27 = v45[0];
              }

              else
              {
                unsigned int v27 = v25[1];
                *((void *)this + 1) = v25 + 2;
              }

              int v28 = *(_DWORD *)(a1 + 24);
              if (v28 >= *(_DWORD *)(a1 + 28))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v45,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Contents /Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/include/go ogle/protobuf/repeated_field.h",  602LL);
                uint64_t v29 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v45,  "CHECK failed: (size()) < (Capacity()): ");
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v43, v29);
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v45);
                int v28 = *(_DWORD *)(a1 + 24);
              }

              uint64_t v30 = *(void *)(a1 + 16);
              *(_DWORD *)(a1 + 24) = v28 + 1;
              *(_DWORD *)(v30 + 4LL * vsub_100231C10(v1 + 28) = v27;
              --v24;
            }

            while (v24 > 1);
          }
        }

      case 4u:
        int v10 = TagFallback & 7;
        if (v10 == 2)
        {
          uint64_t result = sub_10061B0E4(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          while (1)
          {
            int v18 = (char *)*((void *)this + 1);
            int v11 = (char *)*((void *)this + 2);
            if (v18 >= v11 || *v18 != 32) {
              break;
            }
LABEL_82:
            uint64_t v16 = v18 + 1;
            *((void *)this + 1) = v16;
LABEL_63:
            if (v16 >= v11 || *v16 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v43)) {
                return 0LL;
              }
            }

            else
            {
              unsigned int v43 = *v16;
              *((void *)this + 1) = v16 + 1;
            }

            int v31 = *(_DWORD *)(a1 + 40);
            if (v31 == *(_DWORD *)(a1 + 44))
            {
              sub_10004AAFC(v5, v31 + 1);
              int v31 = *(_DWORD *)(a1 + 40);
            }

            unsigned int v32 = v43;
            uint64_t v33 = *(void *)(a1 + 32);
            *(_DWORD *)(a1 + 40) = v31 + 1;
            *(_DWORD *)(v33 + 4LL * v31) = v32;
            int v34 = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 40);
            if (v34 >= 1)
            {
              int v35 = v34 + 1;
              do
              {
                int v36 = (_BYTE *)*((void *)this + 1);
                unint64_t v37 = *((void *)this + 2);
                *((void *)this + 1) = v36 + 1;
                if ((unint64_t)(v36 + 1) >= v37 || (char)v36[1] < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v43)) {
                    return 0LL;
                  }
                }

                else
                {
                  unsigned int v43 = v36[1];
                  *((void *)this + 1) = v36 + 2;
                }

                int v38 = *(_DWORD *)(a1 + 40);
                if (v38 >= *(_DWORD *)(a1 + 44))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v45,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Conten ts/Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/includ e/google/protobuf/repeated_field.h",  602LL);
                  uint64_t v39 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v45,  "CHECK failed: (size()) < (Capacity()): ");
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v44, v39);
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v45);
                  int v38 = *(_DWORD *)(a1 + 40);
                }

                unsigned int v40 = v43;
                uint64_t v41 = *(void *)(a1 + 32);
                *(_DWORD *)(a1 + 40) = v38 + 1;
                *(_DWORD *)(v41 + 4LL * v38) = v40;
                --v35;
              }

              while (v35 > 1);
            }
          }

          if (v18 == v11 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        if ((TagFallback & 7) == 0)
        {
          uint64_t v16 = (char *)*((void *)this + 1);
          int v11 = (char *)*((void *)this + 2);
          goto LABEL_63;
        }

void sub_100BC620C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100BC622C( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 52);
  }

  if ((v6 & 2) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  if (*(int *)(v5 + 24) >= 1)
  {
    uint64_t v7 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(_DWORD *)(*(void *)(v5 + 16) + 4 * v7++),  a2,  a4);
    while (v7 < *(int *)(v5 + 24));
  }

  if (*(int *)(v5 + 40) >= 1)
  {
    uint64_t v8 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  *(_DWORD *)(*(void *)(v5 + 32) + 4 * v8++),  a2,  a4);
    while (v8 < *(int *)(v5 + 40));
  }

  return result;
}

uint64_t sub_100BC62EC(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 52);
  if (!v3)
  {
    int v4 = 0;
    goto LABEL_14;
  }

  if ((*(_BYTE *)(a1 + 52) & 1) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 52) & 2) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 52) & 2) == 0) {
      goto LABEL_14;
    }
  }

  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 < 1)
  {
    int v10 = 0;
  }

  else
  {
    uint64_t v9 = 0LL;
    int v10 = 0;
    do
    {
      if ((v11 & 0x80000000) != 0)
      {
        int v12 = 10;
      }

      else if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 24);
      }

      else
      {
        int v12 = 1;
      }

      v10 += v12;
      ++v9;
    }

    while (v9 < v8);
  }

  int v13 = *(_DWORD *)(a1 + 40);
  if (v13 < 1)
  {
    int v15 = 0;
  }

  else
  {
    uint64_t v14 = 0LL;
    int v15 = 0;
    do
    {
      if (v16 >= 0x80)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, a2);
        int v13 = *(_DWORD *)(a1 + 40);
      }

      else
      {
        int v17 = 1;
      }

      v15 += v17;
      ++v14;
    }

    while (v14 < v13);
  }

  uint64_t result = (v10 + v4 + v13 + v8 + v15);
  *(_DWORD *)(a1 + memset(v19, 0, 48) = result;
  return result;
}

void sub_100BC6438(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC6484()
{
  return 1LL;
}

void *sub_100BC648C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfo.LtlLutParams");
}

void sub_100BC649C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  11450LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  int v5 = *(_DWORD *)(a2 + 16);
  if (v5)
  {
    sub_10004AAFC(a1 + 8, *(_DWORD *)(a1 + 16) + v5);
    memcpy((void *)(*(void *)(a1 + 8) + 4LL * *(int *)(a1 + 16)), *(const void **)(a2 + 8), 4LL * *(int *)(a2 + 16));
    *(_DWORD *)(a1 + 16) += *(_DWORD *)(a2 + 16);
  }

  int v6 = *(_DWORD *)(a2 + 36);
  if ((v6 & 0x1FE) != 0)
  {
    if ((v6 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 2u;
      *(_DWORD *)(a1 + 24) = v7;
      int v6 = *(_DWORD *)(a2 + 36);
    }

    if ((v6 & 4) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a1 + 36) |= 4u;
      *(_DWORD *)(a1 + sub_100231C10(v1 + 28) = v8;
    }
  }

void sub_100BC658C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC65A4(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_1018762C0;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2) {
    operator delete[](v2);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100BC65E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100BC65F4()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = &off_1018762C0;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100BC6624(uint64_t result)
{
  if ((*(_WORD *)(result + 36) & 0x1FE) != 0) {
    *(void *)(result + 24) = 0LL;
  }
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100BC6640( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 8;
  int v6 = (unsigned int *)(a1 + 24);
  int v7 = (unsigned int *)(a1 + 28);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_2:
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v10 = TagFallback >> 3;
        int v11 = TagFallback & 7;
        if (v11 != 2)
        {
          if ((TagFallback & 7) == 0)
          {
            uint64_t v14 = (char *)*((void *)this + 1);
            unint64_t v12 = *((void *)this + 2);
            goto LABEL_23;
          }

          goto LABEL_18;
        }

        uint64_t result = sub_10081A7F0(this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        while (1)
        {
          unsigned int v27 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
          int v28 = *v27;
          if (v28 == 16)
          {
            int v15 = (char *)(v27 + 1);
            *((void *)this + 1) = v15;
            goto LABEL_47;
          }

          if (v28 != 8) {
            goto LABEL_2;
          }
          uint64_t v14 = (char *)(v27 + 1);
          *((void *)this + 1) = v14;
LABEL_23:
          if ((unint64_t)v14 >= v12 || *v14 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v33);
            if (!(_DWORD)result) {
              return result;
            }
            unsigned int v16 = v33[0];
          }

          else
          {
            unsigned int v16 = *v14;
            *((void *)this + 1) = v14 + 1;
          }

          int v17 = *(_DWORD *)(a1 + 16);
          if (v17 == *(_DWORD *)(a1 + 20))
          {
            sub_10004AAFC(v5, v17 + 1);
            int v17 = *(_DWORD *)(a1 + 16);
          }

          uint64_t v18 = *(void *)(a1 + 8);
          *(_DWORD *)(a1 + 16) = v17 + 1;
          *(_DWORD *)(v18 + 4LL * v17) = v16;
          int v19 = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16);
          if (v19 >= 1)
          {
            int v20 = v19 + 1;
            do
            {
              int v21 = (_BYTE *)*((void *)this + 1);
              unint64_t v22 = *((void *)this + 2);
              *((void *)this + 1) = v21 + 1;
              if ((unint64_t)(v21 + 1) >= v22 || (char)v21[1] < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v33);
                if (!(_DWORD)result) {
                  return result;
                }
                unsigned int v23 = v33[0];
              }

              else
              {
                unsigned int v23 = v21[1];
                *((void *)this + 1) = v21 + 2;
              }

              int v24 = *(_DWORD *)(a1 + 16);
              if (v24 >= *(_DWORD *)(a1 + 20))
              {
                wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v33,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Contents /Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/include/go ogle/protobuf/repeated_field.h",  602LL);
                uint64_t v25 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v33,  "CHECK failed: (size()) < (Capacity()): ");
                wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v32, v25);
                wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v33);
                int v24 = *(_DWORD *)(a1 + 16);
              }

              uint64_t v26 = *(void *)(a1 + 8);
              *(_DWORD *)(a1 + 16) = v24 + 1;
              *(_DWORD *)(v26 + 4LL * v24) = v23;
              --v20;
            }

            while (v20 > 1);
          }
        }
      }

      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      int v15 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_47:
      if ((unint64_t)v15 >= v12 || *v15 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v29 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }

      else
      {
        *int v6 = *v15;
        uint64_t v29 = v15 + 1;
        *((void *)this + 1) = v29;
      }

      *(_DWORD *)(a1 + 36) |= 2u;
      if ((unint64_t)v29 < v12 && *v29 == 24)
      {
        int v13 = v29 + 1;
        *((void *)this + 1) = v13;
LABEL_55:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v30 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v7 = *v13;
          uint64_t v30 = (unsigned __int8 *)(v13 + 1);
          *((void *)this + 1) = v30;
        }

        *(_DWORD *)(a1 + 36) |= 4u;
        if (v30 == (unsigned __int8 *)v12
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_55;
      }
    }

    else
    {
      int v11 = TagFallback & 7;
    }

void sub_100BC69A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100BC69BC( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if (*(int *)(result + 16) >= 1)
  {
    uint64_t v6 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(*(void *)(v5 + 8) + 4 * v6++),  a2,  a4);
    while (v6 < *(int *)(v5 + 16));
  }

  int v7 = *(_DWORD *)(v5 + 36);
  if ((v7 & 2) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 24),  a2,  a4);
    int v7 = *(_DWORD *)(v5 + 36);
  }

  if ((v7 & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(_DWORD *)(v5 + 28),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC6A54(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 36);
  if ((v3 & 0x1FE) == 0)
  {
    int v4 = 0;
    goto LABEL_14;
  }

  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 36) & 4) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      int v4 = 2;
      if ((v3 & 4) == 0) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    int v4 = 0;
    if ((v3 & 4) == 0) {
      goto LABEL_14;
    }
  }

  uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 28);
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 16);
  if (v8 < 1)
  {
    int v10 = 0;
  }

  else
  {
    uint64_t v9 = 0LL;
    int v10 = 0;
    do
    {
      if ((v11 & 0x80000000) != 0)
      {
        int v12 = 10;
      }

      else if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 16);
      }

      else
      {
        int v12 = 1;
      }

      v10 += v12;
      ++v9;
    }

    while (v9 < v8);
  }

  uint64_t result = (v10 + v4 + v8);
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

void sub_100BC6B48(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC6B94()
{
  return 1LL;
}

void *sub_100BC6B9C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfo.LtlCurrentSrcCalibData");
}

void sub_100BC6BAC(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  11654LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 8);
      a1[5] |= 1u;
      a1[2] = v6;
      int v5 = *(_DWORD *)(a2 + 20);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 12);
      a1[5] |= 2u;
      a1[3] = v7;
    }
  }

void sub_100BC6C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC6C6C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876338;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC6C7C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876338;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC6C9C()
{
  uint64_t result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101876338;
  return result;
}

uint64_t sub_100BC6CC4(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100BC6CD8( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 3;
  while (1)
  {
    while (1)
    {
      int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v8 = TagFallback & 7;
      int v11 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v12 = v16;
        int v13 = (_BYTE *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }

      else
      {
        unsigned int v12 = *v11;
        int v13 = v11 + 1;
        *((void *)this + 1) = v13;
      }

      a1[2] = v12;
      a1[5] |= 1u;
      if ((unint64_t)v13 < v9 && *v13 == 16)
      {
        int v10 = v13 + 1;
        *((void *)this + 1) = v10;
LABEL_24:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *int v5 = *v10;
          uint64_t v14 = (unsigned __int8 *)(v10 + 1);
          *((void *)this + 1) = v14;
        }

        a1[5] |= 2u;
        if (v14 == (unsigned __int8 *)v9 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_24;
      }
    }

    else
    {
      int v8 = TagFallback & 7;
    }

uint64_t sub_100BC6E7C( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC6ED4(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 20);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v4 = 11LL;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }

      else if (v5 >= 0x80)
      {
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_17;
        }
      }

      else
      {
        uint64_t v4 = 2LL;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
      if ((*(_BYTE *)(a1 + 20) & 2) == 0) {
        goto LABEL_17;
      }
    }

    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    else {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

void sub_100BC6F70(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC6FBC()
{
  return 1LL;
}

void *sub_100BC6FC4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfo.LtlRacPmicAdcPreCalData");
}

void sub_100BC6FD4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v18,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  12137LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v18,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v17, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v18);
  }

  int v5 = *(_DWORD *)(a2 + 56);
  if (!(_BYTE)v5) {
    goto LABEL_13;
  }
  if ((v5 & 1) != 0)
  {
    int v8 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 56) |= 1u;
    *(_DWORD *)(a1 + 8) = v8;
    int v5 = *(_DWORD *)(a2 + 56);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_21;
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_6;
  }

  int v9 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 56) |= 2u;
  *(_DWORD *)(a1 + 12) = v9;
  int v5 = *(_DWORD *)(a2 + 56);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_22;
  }

void sub_100BC71B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC71C8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018763B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC71D8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018763B0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC71F8()
{
  uint64_t result = operator new(0x40uLL);
  *uint64_t result = off_1018763B0;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  *((_BYTE *)result + 32) = 0;
  *(void *)((char *)result + 36) = 0LL;
  *(void *)((char *)result + 52) = 0LL;
  *(void *)((char *)result + 44) = 0LL;
  return result;
}

uint64_t sub_100BC7230(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 56);
  if ((_BYTE)v1)
  {
    *(_DWORD *)(result + 36) = 0;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)(result + 8) = 0LL;
    *(_BYTE *)(result + 32) = 0;
  }

  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(result + 40) = 0LL;
    *(_DWORD *)(result + memset(v19, 0, 48) = 0;
  }

  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t sub_100BC7264( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = (unsigned int *)(a1 + 40);
  int v6 = (unsigned int *)(a1 + 44);
  int v7 = (unsigned int *)(a1 + 48);
  while (2)
  {
    int v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        int v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v12 < v11 && (*v12 & 0x80000000) == 0)
        {
          unsigned int v13 = *v12;
          char v14 = v12 + 1;
          *((void *)this + 1) = v14;
LABEL_38:
          *(_DWORD *)(a1 + 8) = v13;
          *(_DWORD *)(a1 + 56) |= 1u;
          if ((unint64_t)v14 < v11 && *v14 == 16)
          {
            int v15 = v14 + 1;
            *((void *)this + 1) = v15;
            goto LABEL_41;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
        if ((_DWORD)result)
        {
          unsigned int v13 = v43;
          char v14 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
          goto LABEL_38;
        }

        break;
      case 2u:
        int v10 = TagFallback & 7;
        int v15 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_41:
        if ((unint64_t)v15 >= v11 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v25 = v43;
          uint64_t v26 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v25 = *v15;
          uint64_t v26 = v15 + 1;
          *((void *)this + 1) = v26;
        }

        *(_DWORD *)(a1 + 12) = v25;
        *(_DWORD *)(a1 + 56) |= 2u;
        int v16 = v26 + 1;
        *((void *)this + 1) = v16;
LABEL_49:
        if ((unint64_t)v16 >= v11 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v27 = v43;
          int v28 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v27 = *v16;
          int v28 = v16 + 1;
          *((void *)this + 1) = v28;
        }

        *(_DWORD *)(a1 + 16) = v27;
        *(_DWORD *)(a1 + 56) |= 4u;
        char v17 = v28 + 1;
        *((void *)this + 1) = v17;
LABEL_57:
        if ((unint64_t)v17 >= v11 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v29 = v43;
          uint64_t v30 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v29 = *v17;
          uint64_t v30 = v17 + 1;
          *((void *)this + 1) = v30;
        }

        *(_DWORD *)(a1 + 20) = v29;
        *(_DWORD *)(a1 + 56) |= 8u;
        uint64_t v18 = v30 + 1;
        *((void *)this + 1) = v18;
LABEL_65:
        if ((unint64_t)v18 >= v11 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v31 = v43;
          char v32 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v31 = *v18;
          char v32 = v18 + 1;
          *((void *)this + 1) = v32;
        }

        *(_DWORD *)(a1 + 24) = v31;
        *(_DWORD *)(a1 + 56) |= 0x10u;
        int v19 = v32 + 1;
        *((void *)this + 1) = v19;
LABEL_73:
        if ((unint64_t)v19 >= v11 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v33 = v43;
          int v34 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v33 = *v19;
          int v34 = v19 + 1;
          *((void *)this + 1) = v34;
        }

        *(_DWORD *)(a1 + sub_100231C10(v1 + 28) = v33;
        *(_DWORD *)(a1 + 56) |= 0x20u;
        int v20 = v34 + 1;
        *((void *)this + 1) = v20;
LABEL_81:
        if ((unint64_t)v20 >= v11 || *v20 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v35 = v43;
          int v36 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v35 = *v20;
          int v36 = v20 + 1;
          *((void *)this + 1) = v36;
        }

        *(_BYTE *)(a1 + 32) = v35 != 0;
        *(_DWORD *)(a1 + 56) |= 0x40u;
        int v21 = v36 + 1;
        *((void *)this + 1) = v21;
LABEL_89:
        if ((unint64_t)v21 >= v11 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v43);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v37 = v43;
          int v38 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v37 = *v21;
          int v38 = v21 + 1;
          *((void *)this + 1) = v38;
        }

        *(_DWORD *)(a1 + 36) = v37;
        *(_DWORD *)(a1 + 56) |= 0x80u;
        unint64_t v22 = v38 + 1;
        *((void *)this + 1) = v22;
LABEL_97:
        if ((unint64_t)v22 >= v11 || *v22 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v39 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          *int v5 = *v22;
          uint64_t v39 = v22 + 1;
          *((void *)this + 1) = v39;
        }

        *(_DWORD *)(a1 + 56) |= 0x100u;
        unsigned int v23 = v39 + 1;
        *((void *)this + 1) = v23;
LABEL_105:
        if ((unint64_t)v23 >= v11 || *v23 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v40 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          *int v6 = *v23;
          unsigned int v40 = v23 + 1;
          *((void *)this + 1) = v40;
        }

        *(_DWORD *)(a1 + 56) |= 0x200u;
        int v24 = v40 + 1;
        *((void *)this + 1) = v24;
LABEL_113:
        if ((unint64_t)v24 >= v11 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v41 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v7 = *v24;
          uint64_t v41 = (unsigned __int8 *)(v24 + 1);
          *((void *)this + 1) = v41;
        }

        *(_DWORD *)(a1 + 56) |= 0x400u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v10 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_49;
      case 4u:
        int v10 = TagFallback & 7;
        char v17 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_57;
      case 5u:
        int v10 = TagFallback & 7;
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_65;
      case 6u:
        int v10 = TagFallback & 7;
        int v19 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_73;
      case 7u:
        int v10 = TagFallback & 7;
        int v20 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_81;
      case 8u:
        int v10 = TagFallback & 7;
        int v21 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_89;
      case 9u:
        int v10 = TagFallback & 7;
        unint64_t v22 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_97;
      case 0xAu:
        int v10 = TagFallback & 7;
        unsigned int v23 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_105;
      case 0xBu:
        int v10 = TagFallback & 7;
        int v24 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_113;
      default:
        int v10 = TagFallback & 7;
LABEL_32:
        if (v10 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BC7844( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 56);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 56);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_15;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_16;
  }

uint64_t sub_100BC799C(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[14];
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_57;
  }

  if ((v3 & 1) == 0)
  {
    LODWORD(v4) = 0;
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[2];
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 10;
  }

  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2);
    unsigned int v3 = a1[14];
  }

  else
  {
    int v6 = 1;
  }

  LODWORD(v4) = v6 + 1;
  if ((v3 & 2) != 0)
  {
LABEL_12:
    int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[3];
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 10;
    }

    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
      unsigned int v3 = a1[14];
    }

    else
    {
      int v8 = 1;
    }

    LODWORD(v4) = v4 + v8 + 1;
  }

void sub_100BC7BEC(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC7C38()
{
  return 1LL;
}

void *sub_100BC7C40@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfo.LtlInitialParams");
}

void *sub_100BC7C50(void *result)
{
  if ((void *)qword_1019A1E40 != result)
  {
    int v1 = result;
    uint64_t v2 = result[2];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t v3 = v1[3];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = v1[4];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t result = (void *)v1[5];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100BC7CD4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876428;
  sub_100BC7C50(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC7D04(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876428;
  sub_100BC7C50(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

double sub_100BC7D38()
{
  unsigned __int8 v0 = (char *)operator new(0x40uLL);
  *(void *)unsigned __int8 v0 = off_101876428;
  v0[8] = 0;
  double result = 0.0;
  *(_OWORD *)(v0 + 12) = 0u;
  *(_OWORD *)(v0 + sub_100231C10(v1 + 28) = 0u;
  *(_OWORD *)(v0 + 44) = 0u;
  return result;
}

uint64_t sub_100BC7D70( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 < *((void *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
      goto LABEL_6;
    }

    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback) {
      return 1LL;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        int v9 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v10 = v55;
          unint64_t v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v10 = *v9;
          unint64_t v11 = v9 + 1;
          *((void *)this + 1) = v11;
        }

        *(_BYTE *)(a1 + 8) = v10 != 0;
        *(_DWORD *)(a1 + 56) |= 1u;
        if ((unint64_t)v11 < v8 && *v11 == 16)
        {
          int v12 = v11 + 1;
          *((void *)this + 1) = v12;
          goto LABEL_31;
        }

        continue;
      case 2u:
        int v7 = TagFallback & 7;
        int v12 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
LABEL_31:
        if ((unint64_t)v12 >= v8 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v15 = v55;
          int v16 = (_BYTE *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
        }

        else
        {
          unsigned int v15 = *v12;
          int v16 = v12 + 1;
          *((void *)this + 1) = v16;
        }

        *(_DWORD *)(a1 + 12) = v15;
        *(_DWORD *)(a1 + 56) |= 2u;
        unsigned int v13 = v16 + 1;
        *((void *)this + 1) = v13;
LABEL_39:
        if ((unint64_t)v13 >= v8 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v55);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v55;
        }

        else
        {
          unsigned int v17 = *v13;
          *((void *)this + 1) = v13 + 1;
        }

        if (v17 <= 4)
        {
          *(_DWORD *)(a1 + 56) |= 4u;
          *(_DWORD *)(a1 + memset(v19, 0, 48) = v17;
        }

        int v18 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v18 + 1;
LABEL_49:
        *(_DWORD *)(a1 + 56) |= 8u;
        int v19 = *(void **)(a1 + 16);
        if (!v19)
        {
          int v19 = operator new(0x40uLL);
          void *v19 = off_1018763B0;
          v19[1] = 0LL;
          v19[2] = 0LL;
          _OWORD v19[3] = 0LL;
          *((_BYTE *)v19 + 32) = 0;
          *(void *)((char *)v19 + 36) = 0LL;
          *(void *)((char *)v19 + 52) = 0LL;
          *(void *)((char *)v19 + 44) = 0LL;
          *(void *)(a1 + 16) = v19;
        }

        int v20 = (char *)*((void *)this + 1);
        if ((unint64_t)v20 >= *((void *)this + 2) || *v20 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v55)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v55 = *v20;
          *((void *)this + 1) = v20 + 1;
        }

        int v21 = *((_DWORD *)this + 14);
        int v22 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v21 + 1;
        if (v21 >= v22) {
          return 0LL;
        }
        int v23 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v23);
        int v25 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v25, 1);
        int v27 = v25 - 1;
        if (v27 < 0 == v26) {
          *((_DWORD *)this + 14) = v27;
        }
        int v28 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v28 + 1;
LABEL_63:
        *(_DWORD *)(a1 + 56) |= 0x10u;
        unsigned int v29 = *(char **)(a1 + 24);
        if (!v29)
        {
          unsigned int v29 = (char *)operator new(0x38uLL);
          *(void *)unsigned int v29 = &off_101876248;
          *(_OWORD *)(v29 + 8) = 0u;
          *(_OWORD *)(v29 + 24) = 0u;
          *(_OWORD *)(v29 + 40) = 0u;
          *(void *)(a1 + 24) = v29;
        }

        uint64_t v30 = (char *)*((void *)this + 1);
        if ((unint64_t)v30 >= *((void *)this + 2) || *v30 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v55)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v55 = *v30;
          *((void *)this + 1) = v30 + 1;
        }

        int v31 = *((_DWORD *)this + 14);
        int v32 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v31 + 1;
        if (v31 >= v32) {
          return 0LL;
        }
        int v33 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v33);
        int v35 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v35, 1);
        int v36 = v35 - 1;
        if (v36 < 0 == v26) {
          *((_DWORD *)this + 14) = v36;
        }
        unsigned int v37 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v37 + 1;
LABEL_77:
        *(_DWORD *)(a1 + 56) |= 0x20u;
        int v38 = *(char **)(a1 + 32);
        if (!v38)
        {
          int v38 = (char *)operator new(0x28uLL);
          *(void *)int v38 = &off_1018762C0;
          *(_OWORD *)(v38 + 8) = 0u;
          *(_OWORD *)(v38 + 24) = 0u;
          *(void *)(a1 + 32) = v38;
        }

        uint64_t v39 = (char *)*((void *)this + 1);
        if ((unint64_t)v39 >= *((void *)this + 2) || *v39 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v55)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v55 = *v39;
          *((void *)this + 1) = v39 + 1;
        }

        int v40 = *((_DWORD *)this + 14);
        int v41 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v40 + 1;
        if (v40 >= v41) {
          return 0LL;
        }
        int v42 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v42);
        int v44 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v44, 1);
        int v45 = v44 - 1;
        if (v45 < 0 == v26) {
          *((_DWORD *)this + 14) = v45;
        }
        int v46 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v46 + 1;
LABEL_91:
        *(_DWORD *)(a1 + 56) |= 0x40u;
        int v47 = *(void **)(a1 + 40);
        if (!v47)
        {
          int v47 = operator new(0x18uLL);
          v47[1] = 0LL;
          v47[2] = 0LL;
          *int v47 = off_101876338;
          *(void *)(a1 + 40) = v47;
        }

        int v48 = (char *)*((void *)this + 1);
        if ((unint64_t)v48 >= *((void *)this + 2) || *v48 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v55)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v55 = *v48;
          *((void *)this + 1) = v48 + 1;
        }

        int v49 = *((_DWORD *)this + 14);
        int v50 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v49 + 1;
        if (v49 >= v50) {
          return 0LL;
        }
        int v51 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v55);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v51);
        int v53 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v53, 1);
        int v54 = v53 - 1;
        if (v54 < 0 == v26) {
          *((_DWORD *)this + 14) = v54;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }

        break;
      case 3u:
        int v7 = TagFallback & 7;
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v8 = *((void *)this + 2);
        goto LABEL_39;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_49;
        }
        goto LABEL_23;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_63;
        }
        goto LABEL_23;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_77;
        }
        goto LABEL_23;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_23;
        }
        goto LABEL_91;
      default:
        int v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100BC83B8( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 56);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  (BOOL)a2,  a4);
    int v6 = *(_DWORD *)(v5 + 56);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 56);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }

uint64_t sub_100BC84E0(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 56);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_46;
  }

  uint64_t v4 = 2 * (v3 & 1u);
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v5 & 0x80000000) != 0)
    {
      int v6 = 11;
    }

    else if (v5 >= 0x80)
    {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 56);
    }

    else
    {
      int v6 = 2;
    }

    uint64_t v4 = (v6 + v4);
    if ((v3 & 4) == 0)
    {
LABEL_4:
      if ((v3 & 8) == 0) {
        goto LABEL_5;
      }
      goto LABEL_22;
    }
  }

  else if ((v3 & 4) == 0)
  {
    goto LABEL_4;
  }

  uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 48);
  if ((v7 & 0x80000000) != 0)
  {
    int v8 = 11;
  }

  else if (v7 >= 0x80)
  {
    int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 56);
  }

  else
  {
    int v8 = 2;
  }

  uint64_t v4 = (v8 + v4);
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_28;
  }

void sub_100BC86C0(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC870C()
{
  return 1LL;
}

void *sub_100BC8714@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LtlInfo");
}

void sub_100BC8724(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018764A0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC8734(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018764A0;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC8754()
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = off_1018764A0;
  result[1] = 0LL;
  *((_DWORD *)result + 4) = 0;
  return result;
}

uint64_t sub_100BC877C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      uint64_t v7 = (char *)*((void *)this + 1);
      if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v10);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v8 = v10;
      }

      else
      {
        unsigned int v8 = *v7;
        *((void *)this + 1) = v7 + 1;
      }

      if (v8 <= 6)
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }

      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC8894( uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC88B0(uint64_t a1, unsigned int a2)
{
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t result = 11LL;
    }

    else if (v4 >= 0x80)
    {
    }

    else
    {
      uint64_t result = 2LL;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_100BC8908(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC8954()
{
  return 1LL;
}

void *sub_100BC895C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.CntinStatusMessage");
}

void sub_100BC896C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876518;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC897C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876518;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_BYTE *sub_100BC899C()
{
  uint64_t result = operator new(0x18uLL);
  *(void *)uint64_t result = off_101876518;
  result[8] = 0;
  *((_DWORD *)result + 3) = 0;
  *((_DWORD *)result + 4) = 0;
  return result;
}

uint64_t sub_100BC89C8( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 8) {
        break;
      }
      unsigned int v8 = (char *)*((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      if ((unint64_t)v8 >= v7 || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v9 = v12;
        unsigned int v10 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v7 = *((void *)this + 2);
      }

      else
      {
        unsigned int v9 = *v8;
        unsigned int v10 = (unsigned __int8 *)(v8 + 1);
        *((void *)this + 1) = v10;
      }

      *(_BYTE *)(a1 + 8) = v9 != 0;
      *(_DWORD *)(a1 + 16) |= 1u;
      if (v10 == (unsigned __int8 *)v7 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_100BC8AE0( uint64_t result, BOOL a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 8),  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC8AFC(uint64_t a1)
{
  else {
    uint64_t v1 = 0LL;
  }
  *(_DWORD *)(a1 + 12) = v1;
  return v1;
}

void sub_100BC8B18(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC8B64()
{
  return 1LL;
}

void *sub_100BC8B6C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.CntinClockControl");
}

void sub_100BC8B7C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876590;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC8B8C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876590;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100BC8BAC()
{
  uint64_t result = operator new(0x20uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = off_101876590;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100BC8BD8( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v7 = TagFallback >> 3;
        int v8 = TagFallback & 7;
        int v11 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v11 >= v9 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v12 = v22;
          uint64_t v13 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          unsigned int v12 = *v11;
          uint64_t v13 = v11 + 1;
          *((void *)this + 1) = v13;
        }

        a1[2] = v12;
        a1[6] |= 1u;
        if ((unint64_t)v13 < v9 && *v13 == 16)
        {
          int v14 = v13 + 1;
          *((void *)this + 1) = v14;
          goto LABEL_26;
        }
      }

      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      int v14 = (char *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
LABEL_26:
      if ((unint64_t)v14 >= v9 || *v14 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v21);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v15 = v21;
        int v16 = (_BYTE *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
      }

      else
      {
        unsigned int v15 = *v14;
        int v16 = v14 + 1;
        *((void *)this + 1) = v16;
      }

      a1[3] = v15;
      a1[6] |= 2u;
      if ((unint64_t)v16 < v9 && *v16 == 24)
      {
        unsigned int v10 = v16 + 1;
        *((void *)this + 1) = v10;
LABEL_34:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v20);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v17 = v20;
          int v18 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          unsigned int v17 = *v10;
          int v18 = (unsigned __int8 *)(v10 + 1);
          *((void *)this + 1) = v18;
        }

        a1[4] = v17;
        a1[6] |= 4u;
        if (v18 == (unsigned __int8 *)v9 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_34;
      }
    }

    else
    {
      int v8 = TagFallback & 7;
    }

int *sub_100BC8DF0( int *result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = result[6];
  if ((v6 & 1) != 0)
  {
    uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  result[2],  a2,  a4);
    int v6 = v5[6];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v5[4],  a2,  a4);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v5[3],  a2,  a4);
  if ((v5[6] & 4) != 0) {
    return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v5[4],  a2,  a4);
  }
  return result;
}

uint64_t sub_100BC8E68(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 24);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_26;
  }

  if ((*(_BYTE *)(a1 + 24) & 1) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v4 = 11LL;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }

    else if (v5 >= 0x80)
    {
      uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 24);
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v4 = 2LL;
      if ((v3 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
      goto LABEL_19;
    }
  }

  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 11;
  }

  else if (v6 >= 0x80)
  {
    int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 24);
  }

  else
  {
    int v7 = 2;
  }

  uint64_t v4 = (v7 + v4);
LABEL_19:
  if ((v3 & 4) != 0)
  {
    int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v8 & 0x80000000) != 0)
    {
      int v9 = 11;
    }

    else if (v8 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
    }

    else
    {
      int v9 = 2;
    }

    uint64_t v4 = (v9 + v4);
  }

void sub_100BC8F44(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100BC8F90()
{
  return 1LL;
}

void *sub_100BC8F98@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.Exception");
}

void sub_100BC8FA8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876608;
  sub_100066774((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC8FD8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876608;
  sub_100066774((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100BC900C()
{
  uint64_t result = operator new(0x28uLL);
  *uint64_t result = off_101876608;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BC9040( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v5 = (char *)*((void *)this + 1);
          if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          else
          {
            TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
            *((_DWORD *)this + 8) = (_DWORD)TagFallback;
            *((void *)this + 1) = v5 + 1;
            if (!(_DWORD)TagFallback) {
              return 1LL;
            }
          }

          unsigned int v7 = TagFallback >> 3;
          int v8 = TagFallback & 7;
          if (v8 != 1) {
            goto LABEL_22;
          }
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v17) & 1) == 0) {
            return 0LL;
          }
          *(void *)(a1 + 8) = v17;
          *(_DWORD *)(a1 + 36) |= 1u;
          int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
          if ((unint64_t)v11 < v10 && *v11 == 16)
          {
            unsigned int v12 = v11 + 1;
            *((void *)this + 1) = v12;
            goto LABEL_18;
          }
        }

        if (v7 != 2) {
          break;
        }
        int v8 = TagFallback & 7;
        unsigned int v12 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_18:
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, &v17);
          if (!(_DWORD)result) {
            return result;
          }
          unint64_t v13 = v17;
          int v14 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unint64_t v13 = *v12;
          int v14 = v12 + 1;
          *((void *)this + 1) = v14;
        }

        *(void *)(a1 + 16) = v13;
        int v9 = *(_DWORD *)(a1 + 36) | 2;
        *(_DWORD *)(a1 + 36) = v9;
        if ((unint64_t)v14 < v10 && *v14 == 26)
        {
          *((void *)this + 1) = v14 + 1;
          goto LABEL_30;
        }
      }

      if (v7 != 3) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_22;
      }
      int v9 = *(_DWORD *)(a1 + 36);
LABEL_30:
      *(_DWORD *)(a1 + 36) = v9 | 4;
      int v16 = *(void **)(a1 + 24);
      if (v16 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        int v16 = operator new(0x18uLL);
        v16[1] = 0LL;
        void v16[2] = 0LL;
        void *v16 = 0LL;
        *(void *)(a1 + 24) = v16;
      }

      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v16);
      if (!(_DWORD)result) {
        return result;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v8 = TagFallback & 7;
LABEL_22:
    if (v8 == 4) {
      return 1LL;
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100BC9240( uint64_t result, uint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  a2,  *(double *)(result + 8),  a3);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString( 3LL,  *(void *)(v5 + 24),  a2);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(v5 + 16),  a2,  a4);
  if ((*(_DWORD *)(v5 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(3LL, *(void *)(v5 + 24), a2);
  }
  return result;
}

uint64_t sub_100BC92B8(uint64_t a1, unint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 36);
  if (*(_BYTE *)(a1 + 36))
  {
    uint64_t v4 = (v3 << 31 >> 31) & 9;
    if ((v3 & 2) != 0)
    {
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 16),  a2)
         + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }

    if ((v3 & 4) != 0)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      char v7 = v6;
      uint64_t v8 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
      }
      else {
        unint64_t v9 = v8;
      }
      if (v9 >= 0x80)
      {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9,  a2);
        int v6 = *(unsigned __int8 *)(v5 + 23);
        uint64_t v8 = *(void *)(v5 + 8);
        char v7 = *(_BYTE *)(v5 + 23);
      }

      else
      {
        int v10 = 1;
      }

      if (v7 < 0) {
        int v6 = v8;
      }
      uint64_t v4 = (v4 + v10 + v6 + 1);
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *(_DWORD *)(a1 + 32) = v4;
  return v4;
}

void sub_100BC936C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BC93B8()
{
  return 1LL;
}

void *sub_100BC93C0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.AskBasebandReset");
}

void sub_100BC93D0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v16,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/GpsdProtocol.pb.cc",  13723LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v16,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v15, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 52);
  if (!(_BYTE)v5) {
    return;
  }
  if ((*(_BYTE *)(a2 + 52) & 1) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 52) |= 1u;
    *(void *)(a1 + 8) = v6;
    int v5 = *(_DWORD *)(a2 + 52);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
LABEL_14:
      *(_DWORD *)(a1 + 52) |= 4u;
      unint64_t v9 = *(char **)(a1 + 24);
      if (!v9)
      {
        unint64_t v9 = (char *)operator new(0x198uLL);
        *(void *)unint64_t v9 = off_1018752D0;
        *((void *)v9 + 41) = 0LL;
        *((void *)v9 + 42) = 0LL;
        *((void *)v9 + 45) = 0LL;
        *((_DWORD *)v9 + 98) = 0;
        *(_OWORD *)(v9 + 8) = 0u;
        *(_OWORD *)(v9 + 24) = 0u;
        *(_OWORD *)(v9 + 40) = 0u;
        *(_OWORD *)(v9 + 56) = 0u;
        *(_OWORD *)(v9 + 72) = 0u;
        *(_OWORD *)(v9 + 88) = 0u;
        *(_OWORD *)(v9 + 104) = 0u;
        *(_OWORD *)(v9 + 120) = 0u;
        *(_OWORD *)(v9 + 136) = 0u;
        *(_OWORD *)(v9 + 152) = 0u;
        *(_OWORD *)(v9 + 168) = 0u;
        *(_OWORD *)(v9 + 184) = 0u;
        *(_OWORD *)(v9 + 200) = 0u;
        *(_OWORD *)(v9 + 216) = 0u;
        *(_OWORD *)(v9 + 232) = 0u;
        *((void *)v9 + 31) = 0LL;
        *((void *)v9 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        *((void *)v9 + 43) = 0LL;
        *((void *)v9 + 44) = 0LL;
        v9[368] = 0;
        *(void *)(v9 + 396) = 0LL;
        *(_OWORD *)(v9 + 264) = 0u;
        *(_OWORD *)(v9 + 280) = 0u;
        *(_OWORD *)(v9 + 296) = 0u;
        *(_OWORD *)(v9 + 312) = 0u;
        *((_DWORD *)v9 + 97) = 0;
        *(void *)(v9 + 372) = 0LL;
        *(void *)(v9 + 380) = 0LL;
        *(void *)(a1 + 24) = v9;
      }

      uint64_t v10 = *(void *)(a2 + 24);
      if (!v10) {
        uint64_t v10 = *(void *)(qword_1019A1E88 + 24);
      }
      sub_100BB1E54((uint64_t)v9, v10);
      int v5 = *(_DWORD *)(a2 + 52);
      if ((v5 & 8) == 0)
      {
LABEL_8:
        if ((v5 & 0x10) == 0) {
          return;
        }
        goto LABEL_24;
      }

      goto LABEL_19;
    }
  }

  else if ((*(_BYTE *)(a2 + 52) & 2) == 0)
  {
    goto LABEL_6;
  }

  char v7 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 52) |= 2u;
  uint64_t v8 = *(std::string **)(a1 + 16);
  if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    uint64_t v8 = (std::string *)operator new(0x18uLL);
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    *(void *)(a1 + 16) = v8;
  }

  std::string::operator=(v8, v7);
  int v5 = *(_DWORD *)(a2 + 52);
  if ((v5 & 4) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((v5 & 8) == 0) {
    goto LABEL_8;
  }
LABEL_19:
  *(_DWORD *)(a1 + 52) |= 8u;
  int v11 = *(void **)(a1 + 32);
  if (!v11)
  {
    int v11 = operator new(0x20uLL);
    *int v11 = off_101875348;
    v11[1] = 0LL;
    v11[2] = 0LL;
    _OWORD v11[3] = 0LL;
    *(void *)(a1 + 32) = v11;
  }

  uint64_t v12 = *(void *)(a2 + 32);
  if (!v12) {
    uint64_t v12 = *(void *)(qword_1019A1E88 + 32);
  }
  sub_100BBA2A8((uint64_t)v11, v12);
  if ((*(_DWORD *)(a2 + 52) & 0x10) != 0)
  {
LABEL_24:
    *(_DWORD *)(a1 + 52) |= 0x10u;
    unint64_t v13 = *(char **)(a1 + 40);
    if (!v13)
    {
      unint64_t v13 = (char *)operator new(0xE8uLL);
      *(void *)unint64_t v13 = off_1018753C0;
      *(_OWORD *)(v13 + 8) = 0u;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(_OWORD *)(v13 + 56) = 0u;
      *(_OWORD *)(v13 + 72) = 0u;
      *(_OWORD *)(v13 + 88) = 0u;
      *(_OWORD *)(v13 + 104) = 0u;
      *(_OWORD *)(v13 + 120) = 0u;
      *((void *)v13 + 17) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
      *((_DWORD *)v13 + 55) = 0;
      *((_DWORD *)v13 + 56) = 0;
      *((_OWORD *)v13 + 9) = 0u;
      *((_OWORD *)v13 + 10) = 0u;
      *((_OWORD *)v13 + 11) = 0u;
      *((_OWORD *)v13 + 12) = 0u;
      *(_OWORD *)(v13 + 204) = 0u;
      *(void *)(a1 + 40) = v13;
    }

    uint64_t v14 = *(void *)(a2 + 40);
    if (!v14) {
      uint64_t v14 = *(void *)(qword_1019A1E88 + 40);
    }
    sub_100BBA7FC((uint64_t)v13, v14);
  }

void sub_100BC9670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BC9688(void *a1)
{
  uint64_t v2 = a1[2];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    operator delete((void *)v2);
  }

  if ((void *)qword_1019A1E88 != a1)
  {
    uint64_t v4 = a1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = a1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    uint64_t v6 = a1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

void sub_100BC9728(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876680;
  sub_100BC9688(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BC9758(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101876680;
  sub_100BC9688(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

uint64_t sub_100BC978C(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_1019A1E88;
  if (!qword_1019A1E88)
  {
    sub_100BB1090(0LL, a2, a3, a4);
    return qword_1019A1E88;
  }

  return result;
}

void *sub_100BC97B8()
{
  uint64_t result = operator new(0x38uLL);
  *uint64_t result = off_101876680;
  result[1] = 0LL;
  result[5] = 0LL;
  result[6] = 0LL;
  result[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[3] = 0LL;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100BC97F0(uint64_t result)
{
  uint64_t v1 = result;
  char v2 = *(_BYTE *)(result + 52);
  if (v2)
  {
    *(void *)(result + 8) = 0LL;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(result + 16);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }

    int v4 = *(_DWORD *)(result + 52);
    if ((v4 & 4) != 0)
    {
      uint64_t result = *(void *)(result + 24);
      if (result)
      {
        uint64_t result = sub_100BB32E0(result);
        int v4 = *(_DWORD *)(v1 + 52);
      }
    }

    if ((v4 & 8) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 32);
      if (v5)
      {
        if (*(_BYTE *)(v5 + 28))
        {
          *(void *)(v5 + 8) = 0LL;
          *(void *)(v5 + 16) = 0LL;
        }

        *(_DWORD *)(v5 + sub_100231C10(v1 + 28) = 0;
        int v4 = *(_DWORD *)(v1 + 52);
      }
    }

    if ((v4 & 0x10) != 0)
    {
      uint64_t result = *(void *)(v1 + 40);
      if (result) {
        uint64_t result = sub_100BBB3D8(result);
      }
    }
  }

  *(_DWORD *)(v1 + 52) = 0;
  return result;
}

uint64_t sub_100BC989C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (1)
  {
    uint64_t v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 < *((void *)this + 2) && (*v6 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
      goto LABEL_7;
    }

    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback) {
      return 1LL;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        uint64_t v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v10;
          int v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }

        int v12 = *(_DWORD *)(a1 + 52) | 1;
        *(_DWORD *)(a1 + 52) = v12;
        if ((unint64_t)v11 < v9 && *v11 == 18)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_28;
        }

        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        int v12 = *(_DWORD *)(a1 + 52);
LABEL_28:
        *(_DWORD *)(a1 + 52) = v12 | 2;
        uint64_t v14 = *(void **)(a1 + 16);
        if (v14 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        {
          uint64_t v14 = operator new(0x18uLL);
          v14[1] = 0LL;
          v14[2] = 0LL;
          void *v14 = 0LL;
          *(void *)(a1 + 16) = v14;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v14);
        if (!(_DWORD)result) {
          return result;
        }
        char v15 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v15 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 52) |= 4u;
        int v16 = *(char **)(a1 + 24);
        if (!v16)
        {
          int v16 = (char *)operator new(0x198uLL);
          *(void *)int v16 = off_1018752D0;
          *((void *)v16 + 41) = 0LL;
          *((void *)v16 + 42) = 0LL;
          *((void *)v16 + 45) = 0LL;
          *((_DWORD *)v16 + 98) = 0;
          *(_OWORD *)(v16 + 8) = 0u;
          *(_OWORD *)(v16 + 24) = 0u;
          *(_OWORD *)(v16 + 40) = 0u;
          *(_OWORD *)(v16 + 56) = 0u;
          *(_OWORD *)(v16 + 72) = 0u;
          *(_OWORD *)(v16 + 88) = 0u;
          *(_OWORD *)(v16 + 104) = 0u;
          *(_OWORD *)(v16 + 120) = 0u;
          *(_OWORD *)(v16 + 136) = 0u;
          *(_OWORD *)(v16 + 152) = 0u;
          *(_OWORD *)(v16 + 168) = 0u;
          *(_OWORD *)(v16 + 184) = 0u;
          *(_OWORD *)(v16 + 200) = 0u;
          *(_OWORD *)(v16 + 216) = 0u;
          *(_OWORD *)(v16 + 232) = 0u;
          *((void *)v16 + 31) = 0LL;
          *((void *)v16 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          *((void *)v16 + 43) = 0LL;
          *((void *)v16 + 44) = 0LL;
          v16[368] = 0;
          *(void *)(v16 + 396) = 0LL;
          *(_OWORD *)(v16 + 264) = 0u;
          *(_OWORD *)(v16 + 280) = 0u;
          *(_OWORD *)(v16 + 296) = 0u;
          *(_OWORD *)(v16 + 312) = 0u;
          *((_DWORD *)v16 + 97) = 0;
          *(void *)(v16 + 372) = 0LL;
          *(void *)(v16 + 380) = 0LL;
          *(void *)(a1 + 24) = v16;
        }

        unint64_t v17 = (char *)*((void *)this + 1);
        if ((unint64_t)v17 >= *((void *)this + 2) || *v17 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v43)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v43 = *v17;
          *((void *)this + 1) = v17 + 1;
        }

        int v18 = *((_DWORD *)this + 14);
        int v19 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v18 + 1;
        if (v18 >= v19) {
          return 0LL;
        }
        int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v43);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
        int v22 = *((_DWORD *)this + 14);
        BOOL v23 = __OFSUB__(v22, 1);
        int v24 = v22 - 1;
        if (v24 < 0 == v23) {
          *((_DWORD *)this + 14) = v24;
        }
        int v25 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v25 + 1;
LABEL_48:
        *(_DWORD *)(a1 + 52) |= 8u;
        BOOL v26 = *(void **)(a1 + 32);
        if (!v26)
        {
          BOOL v26 = operator new(0x20uLL);
          void *v26 = off_101875348;
          v26[1] = 0LL;
          v26[2] = 0LL;
          v26[3] = 0LL;
          *(void *)(a1 + 32) = v26;
        }

        int v27 = (char *)*((void *)this + 1);
        if ((unint64_t)v27 >= *((void *)this + 2) || *v27 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v44)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v44 = *v27;
          *((void *)this + 1) = v27 + 1;
        }

        int v28 = *((_DWORD *)this + 14);
        int v29 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v28 + 1;
        if (v28 >= v29) {
          return 0LL;
        }
        int v30 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v44);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v30);
        int v32 = *((_DWORD *)this + 14);
        BOOL v23 = __OFSUB__(v32, 1);
        int v33 = v32 - 1;
        if (v33 < 0 == v23) {
          *((_DWORD *)this + 14) = v33;
        }
        unsigned int v34 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v34 + 1;
LABEL_62:
        *(_DWORD *)(a1 + 52) |= 0x10u;
        int v35 = *(char **)(a1 + 40);
        if (!v35)
        {
          int v35 = (char *)operator new(0xE8uLL);
          *(void *)int v35 = off_1018753C0;
          *(_OWORD *)(v35 + 8) = 0u;
          *(_OWORD *)(v35 + 24) = 0u;
          *(_OWORD *)(v35 + 40) = 0u;
          *(_OWORD *)(v35 + 56) = 0u;
          *(_OWORD *)(v35 + 72) = 0u;
          *(_OWORD *)(v35 + 88) = 0u;
          *(_OWORD *)(v35 + 104) = 0u;
          *(_OWORD *)(v35 + 120) = 0u;
          *((void *)v35 + 17) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
          *((_DWORD *)v35 + 55) = 0;
          *((_DWORD *)v35 + 56) = 0;
          *((_OWORD *)v35 + 9) = 0u;
          *((_OWORD *)v35 + 10) = 0u;
          *((_OWORD *)v35 + 11) = 0u;
          *((_OWORD *)v35 + 12) = 0u;
          *(_OWORD *)(v35 + 204) = 0u;
          *(void *)(a1 + 40) = v35;
        }

        int v36 = (char *)*((void *)this + 1);
        if ((unint64_t)v36 >= *((void *)this + 2) || *v36 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v45)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v45 = *v36;
          *((void *)this + 1) = v36 + 1;
        }

        int v37 = *((_DWORD *)this + 14);
        int v38 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v37 + 1;
        if (v37 >= v38) {
          return 0LL;
        }
        int v39 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v45);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v39);
        int v41 = *((_DWORD *)this + 14);
        BOOL v23 = __OFSUB__(v41, 1);
        int v42 = v41 - 1;
        if (v42 < 0 == v23) {
          *((_DWORD *)this + 14) = v42;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }

        break;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_34;
        }
        goto LABEL_20;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_48;
        }
        goto LABEL_20;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        goto LABEL_62;
      default:
        int v8 = TagFallback & 7;
LABEL_20:
        if (v8 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100BC9DF8( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  (unint64_t)a2,  a4);
    int v6 = *(_DWORD *)(v5 + 52);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2LL, *(void *)(v5 + 16), a2);
  int v6 = *(_DWORD *)(v5 + 52);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }

uint64_t sub_100BC9ED8(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 52);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_38;
  }

  if ((*(_BYTE *)(a1 + 52) & 1) != 0)
  {
    uint64_t v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2)
       + 1;
    int v3 = *(_DWORD *)(a1 + 52);
    if ((v3 & 2) == 0) {
      goto LABEL_16;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    if ((*(_BYTE *)(a1 + 52) & 2) == 0) {
      goto LABEL_16;
    }
  }

  uint64_t v5 = *(void *)(a1 + 16);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9,  a2);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v3 = *(_DWORD *)(a1 + 52);
    char v7 = *(_BYTE *)(v5 + 23);
  }

  else
  {
    int v10 = 1;
  }

  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v4 = (v4 + v10 + v6 + 1);
LABEL_16:
  if ((v3 & 4) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 24);
    if (!v11) {
      uint64_t v11 = *(void *)(qword_1019A1E88 + 24);
    }
    int v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BB7790(v11, a2);
    int v13 = (int)v12;
    else {
      int v14 = 1;
    }
    uint64_t v4 = (v4 + v13 + v14 + 1);
    int v3 = *(_DWORD *)(a1 + 52);
    if ((v3 & 8) == 0)
    {
LABEL_18:
      if ((v3 & 0x10) == 0) {
        goto LABEL_38;
      }
      goto LABEL_32;
    }
  }

  else if ((v3 & 8) == 0)
  {
    goto LABEL_18;
  }

  uint64_t v15 = *(void *)(a1 + 32);
  if (!v15) {
    uint64_t v15 = *(void *)(qword_1019A1E88 + 32);
  }
  int v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BBA6D8(v15, a2);
  int v17 = (int)v16;
  else {
    int v18 = 1;
  }
  uint64_t v4 = (v4 + v17 + v18 + 1);
  if ((*(_DWORD *)(a1 + 52) & 0x10) != 0)
  {
LABEL_32:
    uint64_t v19 = *(void *)(a1 + 40);
    if (!v19) {
      uint64_t v19 = *(void *)(qword_1019A1E88 + 40);
    }
    int v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BBD6E8(v19, a2);
    int v22 = (int)v20;
    else {
      int v23 = 1;
    }
    uint64_t v4 = (v4 + v22 + v23 + 1);
  }

void sub_100BCA06C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BCA0B8()
{
  return 1LL;
}

void *sub_100BCA0C0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.LogEntry");
}

void sub_100BCA0D0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018766F8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100BCA0E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018766F8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

_DWORD *sub_100BCA100()
{
  uint64_t result = operator new(0x20uLL);
  result[5] = 0;
  result[6] = 0;
  *(void *)uint64_t result = off_1018766F8;
  *((void *)result + 1) = 0LL;
  *(_DWORD *)((char *)result + 15) = 0;
  return result;
}

uint64_t sub_100BCA12C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 8);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        int v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 < v9 && (*v10 & 0x80000000) == 0)
        {
          unsigned int v11 = *v10;
          int v12 = v10 + 1;
          *((void *)this + 1) = v12;
LABEL_24:
          *(_BYTE *)(a1 + 16) = v11 != 0;
          *(_DWORD *)(a1 + 24) |= 1u;
          if ((unint64_t)v12 < v9 && *v12 == 16)
          {
            int v13 = v12 + 1;
            *((void *)this + 1) = v13;
            goto LABEL_27;
          }

          continue;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
        if ((_DWORD)result)
        {
          unsigned int v11 = v24;
          int v12 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
          goto LABEL_24;
        }

        break;
      case 2u:
        int v8 = TagFallback & 7;
        int v13 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
LABEL_27:
        if ((unint64_t)v13 >= v9 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v23);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v16 = v23;
          int v17 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          unsigned int v16 = *v13;
          int v17 = v13 + 1;
          *((void *)this + 1) = v17;
        }

        *(_BYTE *)(a1 + 17) = v16 != 0;
        *(_DWORD *)(a1 + 24) |= 2u;
        int v14 = v17 + 1;
        *((void *)this + 1) = v14;
LABEL_35:
        if ((unint64_t)v14 >= v9 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v18 = v22;
          uint64_t v19 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          unsigned int v18 = *v14;
          uint64_t v19 = v14 + 1;
          *((void *)this + 1) = v19;
        }

        *(_BYTE *)(a1 + 18) = v18 != 0;
        *(_DWORD *)(a1 + 24) |= 4u;
        uint64_t v15 = v19 + 1;
        *((void *)this + 1) = v15;
LABEL_43:
        if ((unint64_t)v15 >= v9 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v20 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v15;
          int v20 = (unsigned __int8 *)(v15 + 1);
          *((void *)this + 1) = v20;
        }

        *(_DWORD *)(a1 + 24) |= 8u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        int v14 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_35;
      case 4u:
        int v8 = TagFallback & 7;
        uint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_43;
      default:
        int v8 = TagFallback & 7;
LABEL_18:
        if (v8 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100BCA3E8( uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(unsigned __int8 *)(result + 16),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 24);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(unsigned __int8 *)(v5 + 17),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  *(void *)(v5 + 8),  a2,  a4);
  }

uint64_t sub_100BCA47C(uint64_t a1, unint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  if ((_BYTE)v3)
  {
    unsigned int v4 = 2 * (v3 & 1);
    if ((v3 & 2) != 0) {
      v4 += 2;
    }
    if ((v3 & 4) != 0) {
      uint64_t v5 = v4 + 2;
    }
    else {
      uint64_t v5 = v4;
    }
    if ((v3 & 8) != 0) {
      uint64_t v5 = (v5 | 1)
    }
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8),  a2);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  *(_DWORD *)(a1 + 20) = v5;
  return v5;
}

void sub_100BCA4E4(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100BCA530()
{
  return 1LL;
}

void *sub_100BCA538@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "proto.gpsd.StartContext");
}

uint64_t sub_100BCA548(uint64_t a1)
{
  return *(unsigned int *)(a1 + 392);
}

uint64_t sub_100BCA550(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

void *sub_100BCA558()
{
  unsigned __int8 v0 = operator new(0x28uLL);
  sub_100501118((uint64_t)v0);
  return v0;
}

void sub_100BCA584(_Unwind_Exception *a1)
{
}

void *sub_100BCA598()
{
  unsigned __int8 v0 = operator new(0x20uLL);
  sub_1005010E8((uint64_t)v0);
  return v0;
}

void sub_100BCA5C4(_Unwind_Exception *a1)
{
}

void *sub_100BCA5D8()
{
  unsigned __int8 v0 = operator new(0x28uLL);
  sub_100501100((uint64_t)v0);
  return v0;
}

void sub_100BCA604(_Unwind_Exception *a1)
{
}

void sub_100BCA8F0(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

double sub_100BCA91C(uint64_t a1)
{
  *(void *)a1 = off_101876BB0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  return result;
}

void *sub_100BCA948(void *a1)
{
  *a1 = off_101876BB0;
  sub_100231C10(a1 + 6);
  return a1;
}

void sub_100BCA978(void *a1)
{
  *a1 = off_101876BB0;
  sub_100231C10(a1 + 6);
  operator delete(a1);
}

void sub_100BCA9A8(int64x2_t *a1, __int32 a2, double a3, float a4)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101876BD8);
  }
  int v8 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134284033;
    *(double *)&uint8_t buf[4] = a3;
    *(_WORD *)&_BYTE buf[12] = 2049;
    *(double *)&buf[14] = a4;
    *(_WORD *)&buf[22] = 1025;
    *(_DWORD *)&buf[24] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] aggregateWRMets - time: %{private}f, mets: %{private}f, activity: %{private}d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    int v76 = 134284033;
    *(double *)uint64_t v77 = a3;
    *(_WORD *)&v77[8] = 2049;
    *(double *)&v77[10] = a4;
    *(_WORD *)&v77[18] = 1025;
    *(_DWORD *)&v77[20] = a2;
    uint64_t v59 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] aggregateWRMets - time: %{private}f, mets: %{private}f, activity: %{private}d",  &v76,  28);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v59);
    if (v59 != buf) {
      free(v59);
    }
  }

  if (*(double *)&a1[1].i64[1] > a3)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    unint64_t v9 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = a1[1].i64[0];
      uint64_t v10 = a1[1].i64[1];
      __int32 v12 = a1[2].i32[2];
      uint64_t v13 = a1->i64[1];
      *(_DWORD *)uint64_t buf = 134350081;
      *(double *)&uint8_t buf[4] = a3;
      *(_WORD *)&_BYTE buf[12] = 2050;
      *(void *)&buf[14] = v10;
      *(_WORD *)&buf[22] = 1025;
      *(_DWORD *)&buf[24] = v12;
      *(_WORD *)&_BYTE buf[28] = 2049;
      *(void *)&buf[30] = v13;
      *(_WORD *)&buf[38] = 2049;
      *(void *)&buf[40] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "[PhysicalEffort] Time went backwards (time=%{public}f,lastTime=%{public}f,type=%{private}d,sampleStart=%{private }f,sampleStop=%{private}f)",  buf,  0x30u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101876BD8);
      }
      uint64_t v61 = a1[1].i64[0];
      uint64_t v60 = a1[1].i64[1];
      __int32 v62 = a1[2].i32[2];
      uint64_t v63 = a1->i64[1];
      int v76 = 134350081;
      *(double *)uint64_t v77 = a3;
      *(_WORD *)&v77[8] = 2050;
      *(void *)&v77[10] = v60;
      *(_WORD *)&v77[18] = 1025;
      *(_DWORD *)&v77[20] = v62;
      __int16 v78 = 2049;
      uint64_t v79 = v63;
      __int16 v80 = 2049;
      uint64_t v81 = v61;
      LODWORD(v75) = 48;
      int v64 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "[PhysicalEffort] Time went backwards (time=%{public}f,lastTime=%{public}f,type=%{private}d,sampleS tart=%{private}f,sampleStop=%{private}f)",  &v76,  v75);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v64);
      if (v64 != buf) {
        free(v64);
      }
    }
  }

  if (a4 <= 0.0 || a4 > 20.0)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    int v20 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      *(double *)&uint8_t buf[4] = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Invalid value for METs received: %{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101876BD8);
      }
      int v76 = 134349056;
      *(double *)uint64_t v77 = a4;
      LODWORD(v75) = 12;
      unsigned int v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Invalid value for METs received: %{public}f",  &v76,  v75);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v21);
      if (v21 != buf) {
        free(v21);
      }
    }
  }

  else
  {
    float v14 = fmaxf(a4, 1.0);
    double v15 = *(double *)&a1->i64[1];
    if (v15 <= 0.0)
    {
LABEL_40:
      *(double *)&a1[1].i64[1] = a3;
LABEL_41:
      *(double *)&a1->i64[1] = a3 + -2.56;
      *(double *)a1[1].i64 = a3;
      *(float *)a1[2].i32 = v14;
      *(float *)&a1[2].i32[1] = v14;
      a1[2].i32[2] = a2;
      a1[2].i32[3] = 0;
      return;
    }

    double v16 = *(double *)&a1[1].i64[1];
    if (v16 > 0.0)
    {
      if (vabdd_f64(a3, v16) > 11.52)
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101876BD8);
        }
        int v17 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
        {
          uint64_t v18 = a1[1].i64[1];
          *(_DWORD *)uint64_t buf = 134349312;
          *(double *)&uint8_t buf[4] = a3;
          *(_WORD *)&_BYTE buf[12] = 2050;
          *(void *)&buf[14] = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "[PhysicalEffort] Unexpected jump in time between mets. Current time: %{public}f, last update time: %{public} f, ending sample",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101876BD8);
          }
          uint64_t v65 = a1[1].i64[1];
          int v76 = 134349312;
          *(double *)uint64_t v77 = a3;
          *(_WORD *)&v77[8] = 2050;
          *(void *)&v77[10] = v65;
          LODWORD(v75) = 22;
          uint64_t v66 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "[PhysicalEffort] Unexpected jump in time between mets. Current time: %{public}f, last update t ime: %{public}f, ending sample",  &v76,  v75);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v66);
          if (v66 != buf) {
            free(v66);
          }
        }

        int v19 = 1;
LABEL_39:
        a1[2].i32[3] = v19;
        sub_100BCB824((uint64_t)a1);
        (*(void (**)(int64x2_t *, void, double, double, float))(a1->i64[0] + 16))( a1,  a1[2].u32[2],  *(double *)&a1->i64[1],  *(double *)a1[1].i64,  (float)(int)(float)((float)(*(float *)a1[2].i32 * 10.0) + 0.5) / 10.0);
        a1->i64[1] = 0LL;
        a1[1].i64[0] = 0LL;
        a1[2].i64[0] = 0LL;
        a1[2].i64[1] = 0LL;
        a1[6].i64[0] = 0LL;
        goto LABEL_40;
      }

      if (v15 + dbl_10134E020[*(float *)a1[2].i32 > 2.4] < a3)
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101876BD8);
        }
        unsigned int v22 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
        {
          __int32 v23 = a1[2].i32[2];
          double v24 = *(double *)&a1->i64[1];
          double v25 = *(double *)a1[1].i64 - v24;
          *(_DWORD *)uint64_t buf = 67175169;
          *(_DWORD *)&uint8_t buf[4] = v23;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v25;
          *(_WORD *)&_BYTE buf[18] = 2049;
          *(double *)&buf[20] = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] max duration reached, ending sample with type %{private}d, length %{private}f (start: %{private}f)",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101876BD8);
          }
          __int32 v71 = a1[2].i32[2];
          double v72 = *(double *)&a1->i64[1];
          double v73 = *(double *)a1[1].i64 - v72;
          int v76 = 67175169;
          *(_DWORD *)uint64_t v77 = v71;
          *(_WORD *)&v77[4] = 2049;
          *(double *)&v77[6] = v73;
          *(_WORD *)&v77[14] = 2049;
          *(double *)&v77[16] = v72;
          LODWORD(v75) = 28;
          int v74 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] max duration reached, ending sample with type %{private}d, length %{private}f (start: %{private}f)",  &v76,  v75);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v74);
          if (v74 != buf) {
            free(v74);
          }
        }

        int v19 = 2;
        goto LABEL_39;
      }
    }

    *(double *)&a1[1].i64[1] = a3;
    if (v15 <= 0.0) {
      goto LABEL_41;
    }
    BOOL v26 = (float *)&a1[2].i32[1];
    if (a1[2].i32[2] != a2) {
      goto LABEL_54;
    }
    BOOL v27 = 0;
    float v28 = *v26;
    float v29 = vabds_f32(*v26, v14);
    BOOL v30 = v14 < 2.4;
    if (*v26 >= 2.4) {
      BOOL v30 = 0;
    }
    if (v28 < 6.5 && a2 == 1 && v28 >= 2.4)
    {
      BOOL v27 = v14 >= 2.4;
      if (v14 >= 6.5) {
        BOOL v27 = 0;
      }
    }

    if (v29 < 0.2 || v30 || v27)
    {
      __int32 v56 = a1[6].i32[0];
      BOOL v57 = __OFSUB__(v56, 1);
      int v58 = v56 - 1;
      if (v58 < 0 != v57
        || (a1[6].i32[0] = v58, a1[6].i32[1] = 1, !v58) && (sub_100BCB824((uint64_t)a1), a1[6].i32[0] < 1))
      {
        sub_100BCBB54((uint64_t)a1, 0, a3, v14);
        a1[6].i64[0] = 0LL;
      }

      else
      {
        *(double *)uint64_t buf = a3;
        *(void *)&uint8_t buf[8] = __PAIR64__(a2, LODWORD(v14));
        sub_100BCBACC((int64x2_t *)a1[3].i64, (__n128 *)buf);
      }
    }

    else
    {
LABEL_54:
      uint64_t v31 = a1[5].i64[1];
      if (!v31) {
        goto LABEL_71;
      }
      unint64_t v32 = v31 + a1[5].i64[0] - 1;
      uint64_t v33 = *(void *)(a1[3].i64[1] + ((v32 >> 5) & 0x7FFFFFFFFFFFFF8LL));
      BOOL v34 = 0;
      float v35 = *(float *)(v33 + 16LL * v32 + 8);
      float v36 = vabds_f32(v35, v14);
      BOOL v37 = v14 < 2.4;
      if (v35 >= 2.4) {
        BOOL v37 = 0;
      }
      if (v35 < 6.5 && a2 == 1 && v35 >= 2.4)
      {
        BOOL v34 = v14 >= 2.4;
        if (v14 >= 6.5) {
          BOOL v34 = 0;
        }
      }

      int v39 = v37 || v34;
      if (v36 < 0.2 || v39 != 0) {
        int v41 = a1[6].i32[1] + 1;
      }
      else {
LABEL_71:
      }
        int v41 = 1;
      a1[6].i32[1] = v41;
      ++a1[6].i32[0];
      *(double *)uint64_t buf = a3;
      *(void *)&uint8_t buf[8] = __PAIR64__(a2, LODWORD(v14));
      sub_100BCBACC((int64x2_t *)a1[3].i64, (__n128 *)buf);
      if (a1[6].i32[0] > 3 || a1[6].i32[1] >= 3)
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101876BD8);
        }
        int v42 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
        {
          __int32 v43 = a1[2].i32[2];
          double v44 = *(double *)&a1->i64[1];
          double v45 = *(double *)a1[1].i64 - v44;
          *(_DWORD *)uint64_t buf = 67175169;
          *(_DWORD *)&uint8_t buf[4] = v43;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v45;
          *(_WORD *)&_BYTE buf[18] = 2049;
          *(double *)&buf[20] = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] outliers flagged. ending sample with type %{private}d, length %{private}f (start: %{private}f)",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101876BD8);
          }
          __int32 v67 = a1[2].i32[2];
          double v68 = *(double *)&a1->i64[1];
          double v69 = *(double *)a1[1].i64 - v68;
          int v76 = 67175169;
          *(_DWORD *)uint64_t v77 = v67;
          *(_WORD *)&v77[4] = 2049;
          *(double *)&v77[6] = v69;
          *(_WORD *)&v77[14] = 2049;
          *(double *)&v77[16] = v68;
          LODWORD(v75) = 28;
          int v70 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] outliers flagged. ending sample with type %{private}d, length %{private}f (st art: %{private}f)",  &v76,  v75);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::aggregateWRMets(CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v70);
          if (v70 != buf) {
            free(v70);
          }
        }

        unint64_t v46 = a1[6].u32[1];
        for (; a1[5].i64[1] > v46; unint64_t v46 = a1[6].i32[1])
        {
          sub_100BCBB54((uint64_t)a1, 0, *(double *)v47, *(float *)(v47 + 8));
          a1[5] = vaddq_s64(a1[5], (int64x2_t)xmmword_1012CE4D0);
          sub_100232D40((uint64_t)a1[3].i64, 1);
        }

        if ((int)v46 <= 2) {
LABEL_84:
        }
          int v48 = 4;
        else {
          int v48 = 3;
        }
        a1[2].i32[3] = v48;
        (*(void (**)(int64x2_t *, void, double, double, float))(a1->i64[0] + 16))( a1,  a1[2].u32[2],  *(double *)&a1->i64[1],  *(double *)a1[1].i64,  (float)(int)(float)((float)(*(float *)a1[2].i32 * 10.0) + 0.5) / 10.0);
        uint64_t v49 = a1[3].i64[1];
        unint64_t v50 = a1[5].u64[0];
        uint64_t v51 = a1[5].i64[1];
        double v52 = *(double *)(*(void *)(v49 + ((v50 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v50);
        LODWORD(v49) = *(_DWORD *)(*(void *)(v49 + (((v50 + v51 - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
        double v53 = v52 + -2.56;
        *(double *)&a1->i64[1] = v53;
        *(double *)a1[1].i64 = v53;
        a1[2].i64[0] = 0LL;
        a1[2].i32[2] = v49;
        a1[2].i32[3] = 0;
        *(void *)uint64_t buf = off_10183B0F0;
        *(_DWORD *)&uint8_t buf[8] = v51;
        memset(&buf[16], 0, 48);
        v84[0] = 0LL;
        v84[1] = 0LL;
        int v83 = v84;
        while (a1[5].i64[1])
        {
          unint64_t v54 = a1[5].u64[0];
          uint64_t v55 = *(void *)(a1[3].i64[1] + ((v54 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v54;
          sub_100BCBB54((uint64_t)a1, 0, *(double *)v55, *(float *)(v55 + 8));
          sub_100476A68((uint64_t)buf, (float *)(v55 + 8));
          a1[5] = vaddq_s64(a1[5], (int64x2_t)xmmword_1012CE4D0);
          sub_100232D40((uint64_t)a1[3].i64, 1);
        }

        sub_10074DE7C(buf, 2, &a1[2].i32[1]);
        a1[6].i64[0] = 0LL;
        *(void *)uint64_t buf = off_10183B0F0;
        sub_100008390((uint64_t)&v83, v84[0]);
        sub_100210578(&buf[16]);
      }
    }
  }

void sub_100BCB804( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100BCB824(uint64_t a1)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101876BD8);
  }
  char v2 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 88);
    *(_DWORD *)uint64_t buf = 134283521;
    uint64_t v17 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] appending pending buffer of size %{private}lu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    uint64_t v12 = *(void *)(a1 + 88);
    int v14 = 134283521;
    uint64_t v15 = v12;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] appending pending buffer of size %{private}lu",  &v14,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLPhysicalEffortAggregator::appendPendingBuffer()", "%s\n", v13);
  }

  while (*(void *)(a1 + 88))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 56) + ((*(void *)(a1 + 80) >> 5) & 0x7FFFFFFFFFFFFF8LL))
       + 16LL * *(void *)(a1 + 80);
    float v5 = *(float *)(v4 + 8);
    int v6 = *(_DWORD *)(a1 + 40);
    if (v6 == *(_DWORD *)(v4 + 12))
    {
      BOOL v7 = 0;
      float v8 = *(float *)(a1 + 36);
      BOOL v9 = v5 < 2.4;
      if (v8 >= 2.4) {
        BOOL v9 = 0;
      }
      if (v8 < 6.5 && v6 == 1 && v8 >= 2.4)
      {
        BOOL v7 = v5 >= 2.4;
        if (v5 >= 6.5) {
          BOOL v7 = 0;
        }
      }

      char v11 = vabds_f32(v8, v5) < 0.2 || v9 || v7;
    }

    else
    {
      char v11 = 0;
    }

    sub_100BCBB54(a1, v11 ^ 1, *(double *)v4, v5);
    *(int64x2_t *)(a1 + 80) = vaddq_s64(*(int64x2_t *)(a1 + 80), (int64x2_t)xmmword_1012CE4D0);
    sub_100232D40(a1 + 48, 1);
  }

__n128 sub_100BCBACC(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BCC160(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100BCBB54(uint64_t a1, char a2, double a3, float a4)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101876BD8);
  }
  float v8 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134283777;
    double v30 = a3;
    __int16 v31 = 2049;
    double v32 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] adding sample {time=%{private}f,mets=%{private}f}",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    int v23 = 134283777;
    double v24 = a3;
    __int16 v25 = 2049;
    double v26 = a4;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] adding sample {time=%{private}f,mets=%{private}f}",  &v23,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::addToSample(CFAbsoluteTime, float, BOOL)",  "%s\n",  v18);
  }

  double v9 = *(double *)(a1 + 8);
  double v10 = *(double *)(a1 + 16);
  double v11 = fmax(v10 - v9, 0.0) + 2.56;
  float v12 = (float)(a4 - *(float *)(a1 + 32)) * 2.56 / v11 + *(float *)(a1 + 32);
  *(float *)(a1 + 32) = v12;
  if ((a2 & 1) == 0)
  {
    float v13 = (float)(a4 - *(float *)(a1 + 36)) * 2.56 / v11 + *(float *)(a1 + 36);
    *(float *)(a1 + 36) = v13;
  }

  double v14 = fmax(v10, a3);
  *(double *)(a1 + 16) = v14;
  if (v14 <= v9)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    uint64_t v15 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
    {
      double v16 = *(double *)(a1 + 8);
      double v17 = *(double *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 134284033;
      double v30 = v16;
      __int16 v31 = 2049;
      double v32 = v17;
      __int16 v33 = 2050;
      double v34 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "[PhysicalEffort] Invalid sample: sampleStart=%{private}f, sampleStop=%{private}f at %{public}f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101876BD8);
      }
      double v19 = *(double *)(a1 + 8);
      double v20 = *(double *)(a1 + 16);
      int v23 = 134284033;
      double v24 = v19;
      __int16 v25 = 2049;
      double v26 = v20;
      __int16 v27 = 2050;
      double v28 = a3;
      LODWORD(v22) = 32;
      unsigned int v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "[PhysicalEffort] Invalid sample: sampleStart=%{private}f, sampleStop=%{private}f at %{public}f",  &v23,  v22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPhysicalEffortAggregator::addToSample(CFAbsoluteTime, float, BOOL)",  "%s\n",  v21);
    }
  }

void sub_100BCBF28(double a1, double a2, float a3, uint64_t a4, int a5)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101876BD8);
  }
  double v9 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134284289;
    double v21 = a1;
    __int16 v22 = 2049;
    double v23 = a2;
    __int16 v24 = 2049;
    double v25 = a3;
    __int16 v26 = 1025;
    int v27 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "[PhysicalEffort] sending sample: start=%{private}f, end=%{private}f, mets=%{private}f, type=%{private}d",  buf,  0x26u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876BD8);
    }
    int v12 = 134284289;
    double v13 = a1;
    __int16 v14 = 2049;
    double v15 = a2;
    __int16 v16 = 2049;
    double v17 = a3;
    __int16 v18 = 1025;
    int v19 = a5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "[PhysicalEffort] sending sample: start=%{private}f, end=%{private}f, mets=%{private}f, type=%{private}d",  &v12,  38);
    double v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLPhysicalEffortAggregator::sendSampleToHealthKit(CFAbsoluteTime, CFAbsoluteTime, float, CLMetsType)",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

void sub_100BCC134(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_100BCC160(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    float v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)float v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      float v35 = &v34[8 * (v33 >> 2)];
      BOOL v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      float v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        float v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BCC428( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100BCC474(void *result, void *a2)
{
  if (a2)
  {
    BOOL v3 = result;
    __n128 result = (void *)sub_100B83D5C((uint64_t)result);
    if ((_DWORD)result)
    {
      unint64_t v4 = (uint64_t *)a2[2];
      if (v4)
      {
        while (1)
        {
          uint64_t v7 = v4[2];
          uint64_t v6 = *(void *)nullsub_10(v3);
          if (sub_1007EC0B0(&v7, &v6)) {
            break;
          }
          unint64_t v4 = (uint64_t *)*v4;
          if (!v4) {
            goto LABEL_8;
          }
        }

        sub_100A68C98(a2, v4);
      }

uint64_t sub_100BCC510@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1002DC708((uint64_t)(a2 + 754), a1 + 3016);
}

void sub_100BCC55C(_Unwind_Exception *a1)
{
}

_DWORD *sub_100BCC570(_DWORD *a1, uint64_t a2)
{
  unint64_t v4 = sub_1002E0454(a1);
  sub_1002DCA80((uint64_t)v4, a2);
  sub_1002DC4C4((uint64_t)(a1 + 202), a2 + 808);
  sub_1002DC708((uint64_t)(a1 + 754), a2 + 3016);
  return a1;
}

void sub_100BCC5B8(_Unwind_Exception *a1)
{
}

_DWORD *sub_100BCC5CC(_DWORD *a1, uint64_t a2)
{
  unint64_t v4 = sub_1002E0454(a1);
  sub_1002DCA80((uint64_t)v4, a2);
  sub_1002DC4C4((uint64_t)(a1 + 202), a2 + 808);
  sub_1002DC708((uint64_t)(a1 + 754), a2 + 3016);
  return a1;
}

void sub_100BCC614(_Unwind_Exception *a1)
{
}

void sub_100BCC628(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  if (*(_BYTE *)(a1 + 6376))
  {
    if (*(_BYTE *)(a1 + 808))
    {
      sub_100BCC73C(a1, a1, v4);
      sub_1002DCA80((uint64_t)a2, (uint64_t)v4);
      sub_1002DC4C4((uint64_t)(a2 + 202), (uint64_t)v5);
      sub_1002DC708((uint64_t)(a2 + 754), (uint64_t)v6);
      sub_1002E1244((uint64_t)v6);
      sub_1002E1094((uint64_t)v5);
      sub_1002DDAD8((uint64_t)v4);
    }
  }

void sub_100BCC718(_Unwind_Exception *a1)
{
}

uint64_t sub_100BCC73C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  double v6 = sub_100BCCE44(a2);
  sub_100BCCC70(*(void *)(a1 + 3160), (uint64_t)v21, *(double *)(a1 + 6384), v6);
  sub_100BCC474((void *)(a1 + 3208), v21);
  uint64_t v7 = v22;
  uint64_t v8 = v23;
  if (v22)
  {
    uint64_t v9 = 0LL;
    do
    {
      v9 += sub_10099EDC8(*((_DWORD *)v7 + 14));
      uint64_t v7 = (void *)*v7;
    }

    while (v7);
    uint64_t v10 = v22;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v9 = 0LL;
  }

  memset(v19, 0, sizeof(v19));
  int v20 = 1065353216;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  for (LODWORD(v18) = 1065353216; v10; uint64_t v10 = (void *)*v10)
  {
    *(void *)uint64_t buf = v10[2];
    sub_1002DFB20((uint64_t)&v16, buf, buf);
    *(void *)uint64_t buf = v10[2];
    sub_100BCD0E0((uint64_t)v19, buf, buf, (uint64_t)(v10 + 2));
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_101876BF8);
  }
  uint64_t v11 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 3160) + 24LL);
    *(_DWORD *)uint64_t buf = 134350080;
    *(void *)&uint8_t buf[4] = v12;
    __int16 v35 = 2050;
    uint64_t v36 = v8;
    __int16 v37 = 2050;
    uint64_t v38 = v9;
    __int16 v39 = 2050;
    uint64_t v40 = v8 - v9;
    __int16 v41 = 2050;
    unint64_t v42 = (unint64_t)v6;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "@WifiFlow, aps, history, %{public}lu, fresh, %{public}llu, 2ghz, %{public}llu, 5ghz, %{public}llu, agethresh, %{public}llu,",  buf,  0x34u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_101876BF8);
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 3160) + 24LL);
    int v24 = 134350080;
    uint64_t v25 = v14;
    __int16 v26 = 2050;
    uint64_t v27 = v8;
    __int16 v28 = 2050;
    uint64_t v29 = v9;
    __int16 v30 = 2050;
    uint64_t v31 = v8 - v9;
    __int16 v32 = 2050;
    unint64_t v33 = (unint64_t)v6;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@WifiFlow, aps, history, %{public}lu, fresh, %{public}llu, 2ghz, %{public}llu, 5ghz, %{public}llu, a gethresh, %{public}llu,",  &v24,  52,  v16,  v17,  v18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "Output CL::Wifi1::Policies::FilterScanHistory::HandleEvent::selectApsForLocationComputation(const Input &) const",  "%s\n",  v15);
    if (v15 != buf) {
      free(v15);
    }
  }

  sub_10001CDA0((uint64_t)(a3 + 276), (uint64_t *)&v16);
  sub_100BCD464((uint64_t)(a3 + 286), (uint64_t *)v19);
  sub_100019CEC((uint64_t)&v16);
  sub_1002E0644((uint64_t)v19);
  return sub_1002DDBC0((uint64_t)v21);
}

void sub_100BCCA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  sub_100019CEC((uint64_t)va);
  sub_1002E0644((uint64_t)va1);
  sub_1002DDBC0((uint64_t)va2);
  sub_1002D9D34(v3);
  _Unwind_Resume(a1);
}

_DWORD *sub_100BCCAAC@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  else {
    return sub_100BCC570(a2, a1);
  }
}

void sub_100BCCAF0(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  if (*(_BYTE *)(a1 + 6376) && *(_BYTE *)(a1 + 6379)) {
    sub_100BCC73C(a1, a1, a2);
  }
  else {
    sub_1002E1330((uint64_t)a2, (uint64_t)v4);
  }
  sub_1002E1244((uint64_t)&v6);
  sub_1002E1094((uint64_t)&v5);
  sub_1002DDAD8((uint64_t)v4);
}

void sub_100BCCBC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BCCBE0@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t result = (uint64_t)sub_100BCC570(a2, a1);
  if (*(_BYTE *)(a1 + 6376))
  {
    uint64_t v5 = a1 + 3208;
    uint64_t result = sub_100B83D5C(v5);
    if ((result & 1) != 0)
    {
      uint64_t v6 = (uint64_t *)nullsub_10(v5);
      uint64_t v7 = *v6;
      return (uint64_t)sub_100BCD0E0((uint64_t)(a2 + 286), &v7, &v7, (uint64_t)v6);
    }
  }

  return result;
}

void sub_100BCCC54(_Unwind_Exception *a1)
{
}

void sub_100BCCC70(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  for (uint64_t i = *(double **)(a1 + 16); i; uint64_t i = *(double **)i)
  {
    double v8 = vabdd_f64(a3, i[9]);
    if (a4 >= v8)
    {
      sub_1002DDF18(a2, (void *)i + 2, (uint64_t)(i + 2));
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_101876BF8);
      }
      uint64_t v9 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEBUG))
      {
        sub_1007EC454(&__p);
        p_p = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t buf = 68289539;
        int v13 = 0;
        __int16 v14 = 2082;
        uint64_t v15 = "";
        __int16 v16 = 2081;
        uint64_t v17 = p_p;
        __int16 v18 = 2050;
        double v19 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:filtering out access point from calculation based on scan timestamp, mac:%{privat e, location:escape_only}s, age_seconds_s:%{public}.09f}",  buf,  0x26u);
      }
    }
  }

void sub_100BCCE2C(_Unwind_Exception *a1)
{
}

double sub_100BCCE44(uint64_t a1)
{
  double v2 = 1.0;
  if (!sub_100495E54((_DWORD *)(a1 + 5968)))
  {
    uint64_t v3 = *(void *)(a1 + 3192);
    uint64_t v7 = *(void *)(a1 + 6384);
    if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v3 + 16LL))(v3, &v7))
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_101876BF8);
      }
      unint64_t v4 = (os_log_s *)qword_101934868;
      double v2 = 30.0;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = 68289282LL;
        __int16 v8 = 2082;
        uint64_t v9 = "";
        __int16 v10 = 2050;
        uint64_t v11 = 0x403E000000000000LL;
        uint64_t v5 = "{msg%{public}.0s:elevation is steady, max_ap_age_s:%{public}.09f}";
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, v5, (uint8_t *)&v7, 0x1Cu);
      }
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_101876BF8);
      }
      unint64_t v4 = (os_log_s *)qword_101934868;
      double v2 = 5.0;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = 68289282LL;
        __int16 v8 = 2082;
        uint64_t v9 = "";
        __int16 v10 = 2050;
        uint64_t v11 = 0x4014000000000000LL;
        uint64_t v5 = "{msg%{public}.0s:elevation is not steady, max_ap_age_s:%{public}.09f}";
        goto LABEL_11;
      }
    }
  }

  return v2;
}

void sub_100BCCFF0(int *a1@<X1>, _DWORD *a2@<X8>)
{
}

void sub_100BCD098( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BCD0B4(id a1)
{
  qword_101934868 = (uint64_t)os_log_create("com.apple.locationd.Position", "WifiPosition");
}

void *sub_100BCD0E0(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  unint64_t v9 = sub_1005B46E8((uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    __int16 v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v10)
          {
            if (sub_1007EC0B0(v15 + 2, a2)) {
              return v15;
            }
          }

          else
          {
            if (v13 > 1)
            {
              if (v16 >= v11) {
                v16 %= v11;
              }
            }

            else
            {
              v16 &= v11 - 1;
            }

            if (v16 != v4) {
              break;
            }
          }

          uint64_t v15 = (void *)*v15;
        }

        while (v15);
      }
    }
  }

  sub_100BCD350(a1, v10, a3, a4, (uint64_t)&v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100019E10(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    void *v26 = *v23;
    *uint64_t v23 = v26;
  }

  else
  {
    void *v26 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26;
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*v26)
    {
      unint64_t v24 = *(void *)(*v26 + 8LL);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }

      else
      {
        v24 &= v11 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v24) = v26;
    }
  }

  uint64_t v15 = v26;
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_100BCD32C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_100022988((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCD350@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  unint64_t v10 = operator new(0x70uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *unint64_t v10 = 0LL;
  v10[1] = a2;
  uint64_t result = sub_100BCD3E8((uint64_t)(v10 + 2), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_100BCD3CC(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_100022988(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100BCD3E8(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = *(void *)a3;
  uint64_t v5 = a1 + 16;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a3 + 8);
    *(void *)(v5 + 16) = *(void *)(a3 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }

  __int128 v7 = *(_OWORD *)(a3 + 32);
  __int128 v8 = *(_OWORD *)(a3 + 48);
  __int128 v9 = *(_OWORD *)(a3 + 64);
  *(void *)(a1 + 88) = *(void *)(a3 + 80);
  *(_OWORD *)(a1 + 72) = v9;
  *(_OWORD *)(a1 + 56) = v8;
  *(_OWORD *)(a1 + 40) = v7;
  return a1;
}

void sub_100BCD464(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  __int128 v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0LL;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }

    else
    {
      v11 &= v12 - 1;
    }

    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    void *v7 = 0LL;
    v7[1] = 0LL;
  }

void sub_100BCD504(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1002DF1A0(a1, *(void ***)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

void sub_100BCD558(int *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  switch(*a1 ^ (*a1 >> 31))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
      sub_100BCC570(a3, a2);
      break;
    case 7:
      sub_100BCC628(a2, a3);
      break;
    case 9:
      sub_100BCCBE0(a2, a3);
      break;
    case 0x14:
      sub_100BCCAAC(a2, a3);
      break;
    case 0x18:
      sub_100BCCAF0(a2, a3);
      break;
    default:
      sub_1002DDAB0();
  }

void sub_100BCD5C8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      _DWORD v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100BCD664(_Unwind_Exception *a1)
{
}

void sub_100BCD67C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100BCD708(_Unwind_Exception *a1)
{
}

void sub_100BCD720(double *a1, double *a2, uint64_t a3)
{
  if (rand() % 100 <= 0)
  {
    sub_100BCD80C(a1, a2);
    sub_1010DDBC0(__p, "WifiHarvest");
    sub_100BCDB6C(a1, a3, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    sub_1010DDBC0(__p, "GpsHarvest");
    sub_100BCDB6C(a2, a3, (uint64_t *)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100BCD7EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCD80C(double *a1, double *a2)
{
  id v4 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  BOOL v5 = 0LL;
  double v6 = *a1;
  if (*a1 >= -90.0 && v6 <= 90.0)
  {
    double v6 = a1[1];
    BOOL v5 = v6 <= 180.0 && v6 >= -180.0;
  }

  objc_msgSend( v4,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v5, v6),  @"isWifiHarvestCentroidValid");
  BOOL v7 = 0LL;
  double v8 = *a2;
  if (*a2 >= -90.0 && v8 <= 90.0)
  {
    double v8 = a2[1];
    BOOL v7 = v8 <= 180.0 && v8 >= -180.0;
  }

  objc_msgSend( v4,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v7, v8),  @"isGpsHarvestCentroidValid");
  double v9 = *a1;
  if (*a1 >= -90.0 && v9 <= 90.0)
  {
    double v10 = a1[1];
    if (v10 <= 180.0 && v10 >= -180.0)
    {
      double v11 = *a2;
      if (*a2 >= -90.0 && v11 <= 90.0)
      {
        double v12 = a2[1];
        if (v12 <= 180.0 && v12 >= -180.0) {
          objc_msgSend( v4,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", sub_100D2EC74(v9, v10, v11, v12)),  @"wifiHarvestCentroidAndGpsHarvestCentroidDistance");
        }
      }
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101876C18);
  }
  unint64_t v13 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 138543362;
    id v20 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Submitting CoreAnalytics event for associated AP harvest centroid comparisons, %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101876C18);
    }
    int v17 = 138543362;
    id v18 = v4;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "Submitting CoreAnalytics event for associated AP harvest centroid comparisons, %{public}@",  &v17,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLWifiAssociatedApHarvestComparator::submitHarvestCentroidComparisonMetrics(const CLWifiAccessPoint &, const CLWifiAccessPoint &)",  "%s\n",  v15);
  }

  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  void v16[2] = sub_100BCDE8C;
  v16[3] = &unk_1018486D8;
  v16[4] = v4;
  return AnalyticsSendEventLazy(@"com.apple.clx.associatedap.harvestcomparison", v16);
}

double *sub_100BCDB6C(double *result, uint64_t a2, uint64_t *a3)
{
  if (*result >= -90.0 && *result <= 90.0)
  {
    uint64_t v3 = (uint64_t)result;
    double v4 = result[1];
    if (v4 <= 180.0 && v4 >= -180.0)
    {
      uint64_t result = (double *)sub_100869780(a2);
      if ((_DWORD)result)
      {
        sub_100B7B730(v3, (uint64_t)buf);
        sub_100C3A384((uint64_t)buf, (uint64_t)v14);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        sub_100E02C88((uint64_t)v13, a2);
        uint64_t result = (double *)sub_100E02CBC((uint64_t)v13, (uint64_t)v14);
        if ((_DWORD)result)
        {
          id v7 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
          sub_100E02D40((uint64_t)v13, (uint64_t)v14);
          objc_msgSend( v7,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"),  @"horizontalError");
          *(void *)&double v8 = sub_100E02D54((uint64_t)v13, buf).n128_u64[0];
          objc_msgSend( v7,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v19, v8),  @"referenceLocationType");
          else {
            double v9 = (uint64_t *)*a3;
          }
          objc_msgSend( v7,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9),  @"harvestType");
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101876C18);
          }
          double v10 = (os_log_s *)qword_101934858;
          if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t buf = 138543362;
            *(void *)&uint8_t buf[4] = v7;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Submitting CoreAnalytics event for associated AP harvest centroid error, %{public}@",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934850 != -1) {
              dispatch_once(&qword_101934850, &stru_101876C18);
            }
            int v16 = 138543362;
            id v17 = v7;
            double v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "Submitting CoreAnalytics event for associated AP harvest centroid error, %{public}@",  &v16,  12);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLWifiAssociatedApHarvestComparator::submitHarvestCentroidHorizontalErrorMetrics(const CLWifiA ccessPoint &, const CLDaemonLocation &, const std::string &)",  "%s\n",  v11);
          }

          v12[0] = _NSConcreteStackBlock;
          v12[1] = 3221225472LL;
          v12[2] = sub_100BCDE94;
          _OWORD v12[3] = &unk_1018486D8;
          v12[4] = v7;
          return (double *)AnalyticsSendEventLazy(@"com.apple.clx.associatedap.harvestcomparison", v12);
        }
      }
    }
  }

  return result;
}

uint64_t sub_100BCDE8C(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_100BCDE94(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_100BCDE9C(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

NSMutableData *sub_100BCDEC8(void *a1, unsigned int a2, NSMutableData **a3)
{
  if (!a1 || !a3)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    double v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedDataAndKey,data and/or key pointer are nil",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LOWORD(v24[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedDataAndKey,data and/or key pointer are nil",  v24,  2,  v24[0]);
LABEL_50:
    unint64_t v21 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)",  "%s\n",  v12);
    if (v21 != buf) {
      free(v21);
    }
    return 0LL;
  }

  if (a2 != 16 && a2 != 32)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    unint64_t v13 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v26 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedDataAndKey,unsupported AES key length,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LODWORD(v24[0]) = 67240192;
    HIDWORD(v24[0]) = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedDataAndKey,unsupported AES key length,%{public}d",  v24,  8,  v24[0]);
    goto LABEL_50;
  }

  size_t v6 = a2;
  id v7 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", a2);
  int v8 = SecRandomCopyBytes(kSecRandomDefault, v6, -[NSMutableData mutableBytes](v7, "mutableBytes"));
  if (v8)
  {
    int v9 = v8;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    double v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v26 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedDataAndKey,failed to generate AES key,error,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_11;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LODWORD(v24[0]) = 67240192;
    HIDWORD(v24[0]) = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedDataAndKey,failed to generate AES key,error,%{public}d",  v24,  8,  v24[0]);
LABEL_45:
    id v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
LABEL_11:

    return 0LL;
  }

  int v16 = sub_100BCE520(a1, v7);
  if (!v16)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    id v18 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedDataAndKey,failed to create AES encrypted data",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_11;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LOWORD(v24[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedDataAndKey,failed to create AES encrypted data",  v24,  2,  v24[0]);
    goto LABEL_45;
  }

  __int16 v14 = v16;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101876C38);
  }
  id v17 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#CLEU,createAESEncryptedDataAndKey,successfully created AES key and encrypted data",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LOWORD(v24[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#CLEU,createAESEncryptedDataAndKey,successfully created AES key and encrypted data",  v24,  2);
    uint64_t v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSData *CLEmergencyUtilities::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **)",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

  *a3 = v7;
  return v14;
}

NSMutableData *sub_100BCE520(void *a1, void *a2)
{
  if (!a1 || !a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    double v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedData,data and/or key pointer are nil",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LOWORD(v25) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedData,data and/or key pointer are nil",  &v25,  2);
LABEL_48:
    size_t v22 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)",  "%s\n",  v11);
    if (v22 != buf) {
      free(v22);
    }
    return 0LL;
  }

  if ([a2 length] != (id)16 && objc_msgSend(a2, "length") != (id)32)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    int v16 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v28 = [a2 length];
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedData,unsupported AES key length,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    uint64_t v21 = qword_101934898;
    int v25 = 67240192;
    unsigned int v26 = [a2 length];
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  16LL,  "#CLEU,createAESEncryptedData,unsupported AES key length,%{public}d",  &v25,  8);
    goto LABEL_48;
  }

  id v4 = [a1 length];
  BOOL v5 = -[NSMutableData initWithLength:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithLength:",  (((void)v4 << 32) + 0x2000000000LL) >> 32);
  int v6 = SecRandomCopyBytes(kSecRandomDefault, 0x10uLL, -[NSMutableData mutableBytes](v5, "mutableBytes"));
  if (v6)
  {
    unsigned int v7 = v6;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    int v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v28 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedData,failed to generate AES IV,error,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_28;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    int v25 = 67240192;
    unsigned int v26 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedData,failed to generate AES IV,error,%{public}d",  &v25,  8);
LABEL_53:
    uint64_t v23 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)",  "%s\n",  v9);
    if (v23 != buf) {
      free(v23);
    }
LABEL_28:

    return 0LL;
  }

  double v12 = (char *)-[NSMutableData mutableBytes](v5, "mutableBytes") + 16;
  unsigned int v13 = CCCryptorGCMOneshotEncrypt( 0,  [a2 bytes],  objc_msgSend(a2, "length"),  -[NSMutableData mutableBytes](v5, "mutableBytes"),  16,  0,  0,  objc_msgSend(a1, "bytes"),  (int)v4,  v12,  &v12[(int)v4],  16);
  if (v13)
  {
    unsigned int v14 = v13;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    uint64_t v15 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      unsigned int v28 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#CLEU,createAESEncryptedData,failed to encrypt data,error,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_28;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    int v25 = 67240192;
    unsigned int v26 = v14;
    LODWORD(v24) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createAESEncryptedData,failed to encrypt data,error,%{public}d",  &v25,  v24);
    goto LABEL_53;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101876C38);
  }
  id v18 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#CLEU,createAESEncryptedData,successfully encrypted data",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101876C38);
    }
    LOWORD(v25) = 0;
    LODWORD(v24) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#CLEU,createAESEncryptedData,successfully encrypted data",  &v25,  v24);
    id v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSData *CLEmergencyUtilities::createAESEncryptedData(NSData *, NSData *)",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  return v5;
}

NSMutableArray *sub_100BCEC3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v70 = a2;
  if (a3 && a4)
  {
    unsigned int v7 = +[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 40LL);
    -[NSMutableData appendData:](v7, "appendData:", a3);
    -[NSMutableData appendData:]( v7,  "appendData:",  +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v70, 8LL));
    int v64 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(a1 + 24));
    int v8 = *(uint64_t **)(a1 + 16);
    if (v8)
    {
      while (1)
      {
        if (*((char *)v8 + 39) < 0)
        {
          sub_1010DD48C(__dst, (void *)v8[2], v8[3]);
        }

        else
        {
          *(_OWORD *)__int128 __dst = *((_OWORD *)v8 + 1);
          uint64_t v69 = v8[4];
        }

        if (*((char *)v8 + 63) < 0)
        {
          sub_1010DD48C(__p, (void *)v8[5], v8[6]);
        }

        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v8 + 5);
          uint64_t v67 = v8[7];
        }

        int v9 = sub_1007536D4((uint64_t *)__p);
        double v10 = v9;
        if (!v9) {
          break;
        }
        SecKeyRef v11 = SecCertificateCopyKey(v9);
        CFRelease(v10);
        if (!v11)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101876C38);
          }
          uint64_t v29 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            __int16 v30 = __dst;
            if (v69 < 0) {
              __int16 v30 = (void **)__dst[0];
            }
            *(_DWORD *)uint64_t buf = 136446210;
            int v84 = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "#CLEU,createWrappedKeyArray,couldn't extract partner key from cert so not creating wrapping key,partner,%{public}s",  buf,  0xCu);
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_75;
          }
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101876C38);
          }
          uint64_t v31 = __dst;
          if (v69 < 0) {
            uint64_t v31 = (void **)__dst[0];
          }
          int v73 = 136446210;
          int v74 = v31;
          LODWORD(v63) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#CLEU,createWrappedKeyArray,couldn't extract partner key from cert so not creating wrapping key,partner,%{public}s",  &v73,  v63);
          unsigned int v28 = (uint8_t *)v32;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)",  "%s\n",  v32);
          goto LABEL_69;
        }

        double v12 = -[NSMutableData length](v7, "length");
        unint64_t v13 = HIBYTE(v69);
        if (v69 < 0) {
          unint64_t v13 = (unint64_t)__dst[1];
        }
        unsigned int v14 = +[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", &v12[v13]);
        -[NSMutableData appendData:](v14, "appendData:", v7);
        if (v69 >= 0) {
          uint64_t v15 = __dst;
        }
        else {
          uint64_t v15 = (void **)__dst[0];
        }
        if (v69 >= 0) {
          int v16 = (void *)HIBYTE(v69);
        }
        else {
          int v16 = __dst[1];
        }
        -[NSMutableData appendData:]( v14,  "appendData:",  +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v15, v16));
        CFErrorRef error = 0LL;
        SecKeyKeyExchangeParameter v81 = kSecKeyKeyExchangeParameterSharedInfo;
        int v82 = v14;
        id v17 = (void *)SecKeyCreateEncryptedDataWithParameters( v11,  kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA256AESGCM,  a4,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v82,  &v81,  1LL),  &error);
        id v18 = v17;
        if (error)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101876C38);
          }
          unsigned int v19 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            if (v69 >= 0) {
              id v20 = __dst;
            }
            else {
              id v20 = (void **)__dst[0];
            }
            unsigned int v21 = -[__CFError code](error, "code");
            id v22 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
            id v23 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
            *(_DWORD *)uint64_t buf = 136446978;
            int v84 = v20;
            __int16 v85 = 1026;
            unsigned int v86 = v21;
            __int16 v87 = 2082;
            id v88 = v22;
            __int16 v89 = 2082;
            id v90 = v23;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "#CLEU,createWrappedKeyArray,failed to encrypt key for partner,%{public}s,error code,%{public}d,domain,%{pu blic}s,reason,%{public}s",  buf,  0x26u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101876C38);
            }
            uint64_t v52 = qword_101934898;
            if (v69 >= 0) {
              double v53 = __dst;
            }
            else {
              double v53 = (void **)__dst[0];
            }
            unsigned int v54 = -[__CFError code](error, "code");
            id v55 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
            id v56 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
            int v73 = 136446978;
            int v74 = v53;
            __int16 v75 = 1026;
            unsigned int v76 = v54;
            __int16 v77 = 2082;
            id v78 = v55;
            __int16 v79 = 2082;
            id v80 = v56;
            LODWORD(v63) = 38;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v52,  16LL,  "#CLEU,createWrappedKeyArray,failed to encrypt key for partner,%{public}s,error code,%{public}d,domain,%{pu blic}s,reason,%{public}s",  &v73,  v63);
            int v58 = (uint8_t *)v57;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)",  "%s\n",  v57);
            if (v58 != buf) {
              free(v58);
            }
          }

          CFRelease(v11);
        }

        else
        {
          CFDataRef v33 = SecKeyCopyExternalRepresentation(v11, &error);
          if (error)
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101876C38);
            }
            double v34 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
            {
              if (v69 >= 0) {
                __int16 v35 = __dst;
              }
              else {
                __int16 v35 = (void **)__dst[0];
              }
              unsigned int v36 = -[__CFError code](error, "code");
              id v37 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
              id v38 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
              *(_DWORD *)uint64_t buf = 136446978;
              int v84 = v35;
              __int16 v85 = 1026;
              unsigned int v86 = v36;
              __int16 v87 = 2082;
              id v88 = v37;
              __int16 v89 = 2082;
              id v90 = v38;
              _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "#CLEU,createWrappedKeyArray,failed to create DER data for partner public key,partner,%{public}s,error co de,%{public}d,domain,%{public}s,reason,%{public}s",  buf,  0x26u);
            }

            if (!sub_1002921D0(115, 0)) {
              goto LABEL_75;
            }
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101876C38);
            }
            uint64_t v39 = qword_101934898;
            if (v69 >= 0) {
              uint64_t v40 = __dst;
            }
            else {
              uint64_t v40 = (void **)__dst[0];
            }
            unsigned int v41 = -[__CFError code](error, "code");
            id v42 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
            id v43 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
            int v73 = 136446978;
            int v74 = v40;
            __int16 v75 = 1026;
            unsigned int v76 = v41;
            __int16 v77 = 2082;
            id v78 = v42;
            __int16 v79 = 2082;
            id v80 = v43;
            LODWORD(v63) = 38;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v39,  16LL,  "#CLEU,createWrappedKeyArray,failed to create DER data for partner public key,partner,%{public}s,error code ,%{public}d,domain,%{public}s,reason,%{public}s",  &v73,  v63);
            unsigned int v28 = (uint8_t *)v44;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSArray *CLEmergencyUtilities::createWrappedKeyArray(const PartnerCertMap &, uint64_t, NSData *, NSData *)",  "%s\n",  v44);
            goto LABEL_69;
          }

          CFDataRef v45 = v33;
          unint64_t v46 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", 32LL);
          CC_SHA256( -[__CFData bytes](v45, "bytes"),  (CC_LONG)-[__CFData length](v45, "length"),  (unsigned __int8 *)-[NSMutableData mutableBytes](v46, "mutableBytes"));
          id v47 = -[NSMutableData subdataWithRange:](v46, "subdataWithRange:", 0LL, 2LL);
          CFRelease(v11);

          int v48 = +[NSMutableData dataWithCapacity:]( NSMutableData,  "dataWithCapacity:",  (char *)[v17 length] + 2);
          -[NSMutableData appendData:](v48, "appendData:", v47);
          -[NSMutableData appendData:](v48, "appendData:", v17);
          id v49 = -[NSMutableData base64EncodedStringWithOptions:](v48, "base64EncodedStringWithOptions:", 0LL);
          v71[0] = @"partner_ID";
          if (v69 >= 0) {
            uint64_t v50 = __dst;
          }
          else {
            uint64_t v50 = (void **)__dst[0];
          }
          uint64_t v51 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v50);
          v71[1] = @"wrapped_key";
          v72[0] = v51;
          v72[1] = v49;
          -[NSMutableArray addObject:]( v64,  "addObject:",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v72,  v71,  2LL));
        }

void sub_100BCF7F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCF87C(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

uint64_t sub_100BD0408(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    switch((v6 >> 3))
    {
      case 0x15u:
        unint64_t v13 = objc_alloc_init(&OBJC_CLASS___ALSCdmaCellTower);
        [a1 addCdmaCellTower:v13];

        return 0LL;
      case 0x16u:
        uint64_t v15 = objc_alloc_init(&OBJC_CLASS___ALSCdmaEvdoTower);
        [a1 addCdmaEvdoTower:v15];

        goto LABEL_40;
      case 0x17u:
        int v16 = objc_alloc_init(&OBJC_CLASS___ALSLteCellTower);
        [a1 addLteCellTower:v16];

        goto LABEL_40;
      case 0x18u:
        id v17 = objc_alloc_init(&OBJC_CLASS___ALSScdmaCellTower);
        [a1 addScdmaCellTower:v17];

        goto LABEL_40;
      case 0x19u:
        id v18 = objc_alloc_init(&OBJC_CLASS___ALSNr5GCellTower);
        [a1 addNr5GCellTower:v18];

        goto LABEL_40;
      default:
        if ((_DWORD)v12 != 2)
        {
          if ((_DWORD)v12 == 1)
          {
            unsigned int v14 = objc_alloc_init(&OBJC_CLASS___ALSCellTower);
            [a1 addCellTower:v14];

            goto LABEL_40;
          }

          uint64_t result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result) {
            return result;
          }
LABEL_41:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        unsigned int v19 = objc_alloc_init(&OBJC_CLASS___ALSWirelessAP);
        [a1 addWirelessAP:v19];

        if (PBReaderPlaceMark(a2, v21) && (sub_100BD1ED0((uint64_t)v19, a2) & 1) != 0)
        {
LABEL_40:
          PBReaderRecallMark(a2, v21);
          goto LABEL_41;
        }

        return 0LL;
    }
  }

void sub_100BD1B30(_Unwind_Exception *a1)
{
  for (uint64_t i = 432LL; i != -48; i -= 48LL)
    sub_10049108C((void *)(v1 + i));
  _Unwind_Resume(a1);
}

void sub_100BD1B64()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100BD1BC8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100BD1C3C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BD1ED0(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) > 20)
    {
      if ((_DWORD)v12 == 21)
      {
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v16 = 0LL;
        *(_BYTE *)(a1 + 36) |= 1u;
        while (1)
        {
          unint64_t v22 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v22 == -1LL || v22 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v23 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v22);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v22 + 1;
          v16 |= (unint64_t)(v23 & 0x7F) << v20;
          if ((v23 & 0x80) == 0) {
            goto LABEL_47;
          }
          v20 += 7;
          BOOL v9 = v21++ >= 9;
          if (v9)
          {
            LODWORD(v16) = 0;
            goto LABEL_49;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_47:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_49:
        uint64_t v25 = 8LL;
      }

      else
      {
        if ((_DWORD)v12 != 22)
        {
LABEL_40:
          uint64_t result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result) {
            return result;
          }
          continue;
        }

        char v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = 0LL;
        *(_BYTE *)(a1 + 36) |= 2u;
        while (1)
        {
          unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v17 == -1LL || v17 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v18 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 1;
          v16 |= (unint64_t)(v18 & 0x7F) << v14;
          if ((v18 & 0x80) == 0) {
            goto LABEL_43;
          }
          v14 += 7;
          BOOL v9 = v15++ >= 9;
          if (v9)
          {
            LODWORD(v16) = 0;
            goto LABEL_45;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_43:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_45:
        uint64_t v25 = 32LL;
      }

      *(_DWORD *)(a1 + v25) = v16;
    }

    else if ((_DWORD)v12 == 1)
    {
      String = (void *)PBReaderReadString(a2);

      *(void *)(a1 + 24) = String;
    }

    else
    {
      if ((_DWORD)v12 != 2) {
        goto LABEL_40;
      }
      unint64_t v13 = objc_alloc_init(&OBJC_CLASS___ALSLocation);

      *(void *)(a1 + 16) = v13;
      PBReaderRecallMark(a2, v26);
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void *sub_100BD26E8(void *a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = sub_100D54F8C((uint64_t)a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = off_101876C68;
  *(_BYTE *)(v8 + 200) = 0;
  BOOL v9 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLDaemonFullAccuracySession(ctor) #clfas",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v9, &state);

  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101876CF0);
  }
  int v10 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = a1[2];
    *(_DWORD *)uint64_t buf = 68289794;
    int v17 = 0;
    __int16 v18 = 2082;
    unsigned int v19 = "";
    __int16 v20 = 2082;
    unsigned int v21 = "activity";
    __int16 v22 = 2114;
    uint64_t v23 = v11;
    __int16 v24 = 2050;
    uint64_t v25 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLDaemonFullAccuracySession(ctor) #clfas, event:%{public, location:escape_only}s, C lientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x30u);
  }

  uint64_t v12 = a1[3];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_100BD28BC;
  v14[3] = &unk_101836E00;
  _DWORD v14[4] = a1;
  sub_100558E24(v12, (uint64_t)v14);
  a1[23] = [a4 objectForKeyedSubscript:@"kCLConnectionMessagePurposeKey"];
  sub_100BD2B1C((uint64_t)a1);
  os_activity_scope_leave(&state);
  return a1;
}

void sub_100BD28A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

uint64_t sub_100BD28BC(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned int v4 = [*(id *)(v3 + 16) isEqual:sub_100019240((uint64_t)a2)];
                       + 23));
  if (!v4 || v5 == 0) {
    return 0LL;
  }
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101876D10);
  }
  uint64_t v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24LL))(a2);
    uint64_t v10 = *(void *)(v3 + 16);
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    int v17 = "";
    __int16 v18 = 1026;
    int v19 = v9;
    __int16 v20 = 2114;
    uint64_t v21 = v10;
    __int16 v22 = 2050;
    uint64_t v23 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#clfas consumeMatchingButterfly, dicType:%{public}d, ClientKeyPath:%{public, loca tion:escape_only}@, this:%{public}p}",  (uint8_t *)&v14,  0x2Cu);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876D10);
    }
  }

  uint64_t v11 = (os_log_s *)qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    int v12 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24LL))(a2);
    uint64_t v13 = *(void *)(v3 + 16);
    int v14 = 68289794;
    int v15 = 0;
    __int16 v16 = 2082;
    int v17 = "";
    __int16 v18 = 1026;
    int v19 = v12;
    __int16 v20 = 2114;
    uint64_t v21 = v13;
    __int16 v22 = 2050;
    uint64_t v23 = v3;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#clfas consumeMatchingButterfly",  "{msg%{public}.0s:#clfas consumeMatchingButterfly, dicType:%{public}d, ClientKeyPath:%{public, loca tion:escape_only}@, this:%{public}p}",  (uint8_t *)&v14,  0x2Cu);
  }

  return 1LL;
}

void sub_100BD2B1C(uint64_t a1)
{
  if (sub_100D57C18(a1))
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101876CF0);
    }
    uint64_t v2 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v3;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#clfas trying WIU #AutoPrompt-ing, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
    }

    sub_100D57D74(a1);
  }

  sub_100D57E58((id *)a1);
  unint64_t v4 = (unint64_t)[*(id *)(a1 + 40) diagnosticMask];
  BOOL v5 = [*(id *)(a1 + 40) transientAwareRegistrationResult] != 1
    && [*(id *)(a1 + 40) registrationResult] != 8
    && [*(id *)(a1 + 40) registrationResult] != 0;
  unsigned int v6 = [*(id *)(a1 + 40) isAuthorizedForServiceType:12];
  uint64_t v7 = (v4 >> 11) & 1;
  if (!(((sub_100D55504(a1) || v5) | v6) & 1 | (v4 >> 11) & 1))
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101876CF0);
    }
    uint64_t v8 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v9;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#clfas trying FullAccuracy Prompt, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
    }

    *(_BYTE *)(a1 + 200) = 1;
    if (!sub_100D57238(a1, 9))
    {
      uint64_t v10 = *(void **)(a1 + 184);
      if (v10) {
        sub_1010DDBC0(buf, (char *)[v10 UTF8String]);
      }
      else {
        sub_1010DDBC0(buf, "");
      }
      id v11 = [*(id *)(a1 + 32) silo];
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3321888768LL;
      v12[2] = sub_100BD33B4;
      _OWORD v12[3] = &unk_10181FBD8;
      v12[4] = a1;
      if ((buf[23] & 0x80000000) != 0)
      {
        sub_1010DD48C(&__p, *(void **)buf, *(unint64_t *)&buf[8]);
      }

      else
      {
        __int128 __p = *(_OWORD *)buf;
        uint64_t v14 = *(void *)&buf[16];
      }

      [v11 async:v12];
      if (SHIBYTE(v14) < 0) {
        operator delete((void *)__p);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }

  sub_100D57F8C(a1);
}

void sub_100BD2E44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD2E84(void *a1)
{
  *a1 = off_101876C68;
  sub_100D56EF4((uint64_t)a1, 5);
  return sub_100D555B4((uint64_t)a1);
}

void sub_100BD2EC0(void *a1)
{
  uint64_t v1 = (void *)sub_100BD2E84(a1);
  operator delete(v1);
}

void sub_100BD2ED4(uint64_t a1, CLConnectionMessage **a2)
{
  unint64_t v4 = (void *)CLConnectionMessage::name(*a2);
  int v5 = *((char *)v4 + 23);
  if (v5 < 0)
  {
    if (v4[1] != 44LL) {
      goto LABEL_7;
    }
    unint64_t v4 = (void *)*v4;
  }

  else if (v5 != 44)
  {
    goto LABEL_7;
  }

  if (!memcmp(v4, "kCLConnectionMessageDestroyUponDisconnection", 0x2CuLL))
  {
    *(_BYTE *)(a1 + memset(v19, 0, 48) = 1;
    return;
  }

uint64_t sub_100BD3118()
{
  return 5LL;
}

uint64_t sub_100BD3120()
{
  return 14359LL;
}

void sub_100BD3128(uint64_t a1)
{
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101876CF0);
  }
  uint64_t v2 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    int v6 = 68289538;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2114;
    uint64_t v11 = v3;
    __int16 v12 = 2050;
    uint64_t v13 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#clfas authContext has changed, ClientKeyPath:%{public, location:escape_only}@, thi s:%{public}p}",  (uint8_t *)&v6,  0x26u);
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101876CF0);
    }
  }

  unint64_t v4 = (os_log_s *)qword_101934978;
  if (os_signpost_enabled((os_log_t)qword_101934978))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    int v6 = 68289538;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2114;
    uint64_t v11 = v5;
    __int16 v12 = 2050;
    uint64_t v13 = a1;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#clfas authContext has changed",  "{msg%{public}.0s:#clfas authContext has changed, ClientKeyPath:%{public, location:escape_only}@, thi s:%{public}p}",  (uint8_t *)&v6,  0x26u);
  }

  sub_100BD2B1C(a1);
}

uint64_t sub_100BD32D4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

NSDictionary *sub_100BD32DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  v3[1] = @"SDKAtLeast2024";
  v4[0] = v1;
  v3[0] = @"kCLConnectionMessagePurposeKey";
  v4[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  2LL);
}

BOOL sub_100BD336C(uint64_t a1)
{
  return ([*(id *)(a1 + 40) diagnosticMask] & 0x800) != 0
      || [*(id *)(a1 + 40) registrationResult] == 2;
}

uint64_t sub_100BD33AC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

void sub_100BD33B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 16);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 56);
  }

  sub_1005857F0((uint64_t)v5, 9, v2, 0LL, (__int128 *)__p);
  sub_100D575DC(v1, v5, 0LL);
  sub_1005858A0((uint64_t)v5);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100BD3448( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BD3474(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_100BD34A0(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_100BD34CC(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = (void *)(a1 + 672);
  if (a2) {
    BOOL v5 = sub_1005D3EB0(v4, a3);
  }
  else {
    BOOL v5 = sub_1005D4090((uint64_t)v4, a3);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  if (v6)
  {
    BOOL v8 = v5;
    (*(void (**)(uint64_t, BOOL *))(*(void *)v6 + 48LL))(v6, &v8);
  }

  return 1LL;
}

double sub_100BD3530(void *a1, int a2, __n128 *a3)
{
  switch(a2)
  {
    case 0:
      *(void *)&double result = sub_100BD3588(a1 + 7, a3).n128_u64[0];
      break;
    case 1:
      *(void *)&double result = sub_100BD3948(a1 + 47, (uint64_t)a3).n128_u64[0];
      break;
    case 2:
      *(void *)&double result = sub_100BD3CE8(a1 + 27, a3).n128_u64[0];
      break;
    case 3:
      *(void *)&double result = sub_100BD4084(a1 + 67, a3).n128_u64[0];
      break;
    default:
      return result;
  }

  return result;
}

__n128 sub_100BD3588(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BD3634(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  BOOL v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *BOOL v8 = result;
  ++a1[5];
  return result;
}

void sub_100BD3634(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      id v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unsigned int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unsigned int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BD38FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100BD3948(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BD39D4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  BOOL v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *BOOL v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100BD39D4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      id v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unsigned int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unsigned int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BD3C9C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100BD3CE8(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BD3D70(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100BD3D70(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      id v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unsigned int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unsigned int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BD4038( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100BD4084(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100BD4130(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  BOOL v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *BOOL v8 = result;
  ++a1[5];
  return result;
}

void sub_100BD4130(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      id v37 = &v34[8 * v36];
      id v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unsigned int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unsigned int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BD43F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BD4444(uint64_t result, char a2, double a3, double a4)
{
  *(double *)__n128 result = a3;
  *(double *)(result + 8) = a4;
  *(_BYTE *)(result + 16) = a2;
  return result;
}

uint64_t sub_100BD4450(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

__n128 sub_100BD4458(uint64_t a1, _OWORD *a2, __n128 *a3)
{
  *(_OWORD *)a1 = *a2;
  __n128 result = *a3;
  *(__n128 *)(a1 + 16) = *a3;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  return result;
}

void sub_100BD4474(void *a1, __int128 *a2)
{
  unint64_t v6 = a1[6];
  uint64_t v4 = (uint64_t)(a1 + 6);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (void **)(v4 - 16);
    uint64_t v11 = *(void *)(v4 - 16);
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v11) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - v11) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555LL) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      uint64_t v16 = (char *)sub_10000701C(v4, v15);
    }
    else {
      uint64_t v16 = 0LL;
    }
    uint64_t v17 = &v16[24 * v12];
    uint64_t v18 = &v16[24 * v15];
    __int128 v19 = *a2;
    *((void *)v17 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v17 = v19;
    uint64_t v9 = v17 + 24;
    uint64_t v21 = (char *)a1[4];
    int64_t v20 = (char *)a1[5];
    if (v20 != v21)
    {
      do
      {
        __int128 v22 = *(_OWORD *)(v20 - 24);
        *(v17 - 8) = *(v20 - 8);
        *(_OWORD *)(v17 - 24) = v22;
        v17 -= 24;
        v20 -= 24;
      }

      while (v20 != v21);
      int64_t v20 = (char *)*v10;
    }

    a1[4] = v17;
    a1[5] = v9;
    a1[6] = v18;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    uint64_t v9 = (char *)(v7 + 24);
  }

  a1[5] = v9;
}

BOOL sub_100BD459C(double *a1, uint64_t a2)
{
  double v2 = *(double *)(a2 + 4);
  else {
    return 0LL;
  }
}

uint64_t sub_100BD45E0(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_100BD45E8@<X0>(double *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v15, (uint64_t)", nwLat, ", 9LL);
  uint64_t v5 = *v4;
  *(uint64_t *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 13LL;
  *(uint64_t *)((char *)v4 + *(void *)(v5 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) = *(_DWORD *)((_BYTE *)v4 + *(void *)(v5 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*a1);
  unint64_t v6 = sub_10000CF44(&v15, (uint64_t)", nwLon, ", 9LL);
  uint64_t v7 = *v6;
  *(uint64_t *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 13LL;
  *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v6 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((_BYTE *)v6 + *(void *)(v7 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(a1[1]);
  __int128 v8 = sub_10000CF44(&v15, (uint64_t)", seLat, ", 9LL);
  uint64_t v9 = *v8;
  *(uint64_t *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 13LL;
  *(uint64_t *)((char *)v8 + *(void *)(v9 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v8 + *(void *)(v9 - 24) + 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(v9 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(a1[2]);
  uint64_t v10 = sub_10000CF44(&v15, (uint64_t)", seLon, ", 9LL);
  uint64_t v11 = *v10;
  *(uint64_t *)((char *)v10 + *(void *)(*v10 - 24) + 24) = 13LL;
  *(uint64_t *)((char *)v10 + *(void *)(v11 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v10 + *(void *)(v11 - 24) + 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(v11 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(a1[3]);
  std::stringbuf::str(a2, &v16);
  *(void *)((char *)v14
  uint64_t v15 = v12;
  std::streambuf::~streambuf(&v16);
  return std::ios::~ios(&v17);
}

void sub_100BD480C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100BD4830(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_BYTE *)(a2 + 352))
  {
    int v5 = *(_DWORD *)(a2 + 152);
    if (v5 == 8 || v5 == 12150) {
      int v7 = 12150;
    }
    else {
      int v7 = 17150;
    }
    float v8 = sub_100E02DAC(v7);
    uint64_t v9 = *(void *)(a2 + 336);
    if (v9 != 2 && (v9 == 1 || *(float *)(a3 + 20) < v8))
    {
      *(float *)(a3 + 20) = v8;
      *(_DWORD *)(a3 + 24) = 3;
    }

    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101876D88);
    }
    uint64_t v10 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      double v11 = *(float *)(a3 + 20);
      int v12 = *(_DWORD *)(a3 + 24);
      *(_DWORD *)uint64_t buf = 134218752;
      double v26 = v11;
      __int16 v27 = 1024;
      int v28 = v12;
      __int16 v29 = 1024;
      int v30 = v9;
      __int16 v31 = 2048;
      double v32 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Pedestrian, mets, %.2f, metsSrc, %d, locationType, %d, fixedMets, %.2f",  buf,  0x22u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101876D88);
      }
      double v13 = *(float *)(a3 + 20);
      int v14 = *(_DWORD *)(a3 + 24);
      int v17 = 134218752;
      double v18 = v13;
      __int16 v19 = 1024;
      int v20 = v14;
      __int16 v21 = 1024;
      int v22 = v9;
      __int16 v23 = 2048;
      double v24 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Pedestrian, mets, %.2f, metsSrc, %d, locationType, %d, fixedMets, %.2f",  COERCE_DOUBLE(&v17),  34);
      std::stringbuf v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLCaloriePedestrianModelPhone::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

BOOL sub_100BD4AA0(uint64_t a1, uint64_t a2)
{
  return sub_100AF8F04(*(double *)(a2 + 448), *(float *)(a2 + 1360));
}

void *sub_100BD4AB0(void *a1)
{
  *a1 = off_10186F460;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10000AE14((uint64_t)(a1 + 3));
  sub_10000AE14(v2);
  return a1;
}

void sub_100BD4AF4(void *a1)
{
  *a1 = off_10186F460;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10000AE14((uint64_t)(a1 + 3));
  sub_10000AE14(v2);
  operator delete(a1);
}

void sub_100BD4B38(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100BD4B64(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v13 = sub_100D54F8C(a1, a2, a3, a5, a4, a6);
  *(void *)uint64_t v13 = off_101876DB8;
  *(_BYTE *)(v13 + 184) = 0;
  *(_OWORD *)(v13 + 192) = 0u;
  uint64_t v36 = v13 + 192;
  *(_OWORD *)(v13 + 240) = 0u;
  int v14 = (void **)(v13 + 240);
  uint64_t v35 = v13 + 216;
  *(_OWORD *)(v13 + 208) = 0u;
  *(_OWORD *)(v13 + 224) = 0u;
  uint64_t v15 = _os_activity_create( (void *)&_mh_execute_header,  "CL: #monitor(ctor)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v15, &state);

  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101876EB8);
  }
  unsigned int v34 = a7;
  std::stringbuf v16 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(const char **)(a1 + 16);
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2082;
    *(void *)&buf[20] = "activity";
    __int16 v44 = 2114;
    uint64_t v45 = v17;
    __int16 v46 = 2050;
    uint64_t v47 = (const char *)a1;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor(ctor), event:%{public, location:escape_only}s, ClientKeyPath:%{public, l ocation:escape_only}@, this:%{public}p}",  buf,  0x30u);
  }

  id v18 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  id v19 = [a5 objectForKeyedSubscript:@"kCLConnectionMessageMonitorNameKey"];
  id v20 = [a5 objectForKeyedSubscript:@"kCLConnectionMessageMonitorProcessNameKey"];
  if (!v19)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    int v30 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      id v31 = [0 UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v31;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "ledgerName";
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#monitor missing ledger name, LedgerName:%{public, location:escape_only}s, event :%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
    }

    double v32 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v33 = [0 UTF8String];
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v33;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "ledgerName";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v32,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#monitor missing ledger name",  "{msg%{public}.0s:#monitor missing ledger name, LedgerName:%{public, location:escape_only}s, event :%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
    }

    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO)) {
      sub_101264EE8((uint64_t)[0 UTF8String], (uint64_t)buf);
    }
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/DaemonIdentifiableClients/CLDaemonMonitor.mm",  39,  "CLDaemonMonitor");
    goto LABEL_36;
  }

  __int16 v21 = v20;
  uint64_t v38 = 0LL;
  uint64_t v39 = &v38;
  uint64_t v40 = 0x2020000000LL;
  char v41 = 1;
  sub_1010DDBC0(buf, (char *)[v19 UTF8String]);
  *(_OWORD *)uint64_t v36 = *(_OWORD *)buf;
  *(void *)(v36 + 16) = *(void *)&buf[16];
  sub_1010DDBC0(buf, (char *)[v21 UTF8String]);
  *(_OWORD *)uint64_t v35 = *(_OWORD *)buf;
  *(void *)(v35 + 16) = *(void *)&buf[16];
  uint64_t v22 = *(void *)(a1 + 24);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472LL;
  v37[2] = sub_100BD53AC;
  v37[3] = &unk_101876E30;
  v37[4] = &v38;
  v37[5] = a1;
  sub_100558E24(v22, (uint64_t)v37);
  id v23 = sub_100BD5838(a1);
  if (*((_BYTE *)v39 + 24))
  {
    [v18 setObject:v19 forKeyedSubscript:@"kCLMonitorLedgerNameKey"];
    [v18 setObject:v21 forKeyedSubscript:@"kCLMonitorLedgerProcessNameKey"];
    id v24 = sub_100564E24(a4, (uint64_t)a2);
    if (v24)
    {
      [v18 setObject:v24 forKeyedSubscript:@"kCLMonitorLedgerAccessKey"];
      sub_1005DCA84( v14,   -[CLDaemonConditionLedger initWithConfiguration:clientKeyPath:authorizationContext:universe:hasClassCAccess:callbackHandler:]( objc_alloc(&OBJC_CLASS___CLDaemonConditionLedger),  "initWithConfiguration:clientKeyPath:authorizationContext:universe:hasClassCAccess:callbackHandler:",  v18,  a2,  *(void *)(a1 + 40),  a6,  v34,  v23));
      goto LABEL_13;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    double v26 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      id v27 = objc_msgSend(objc_msgSend(a2, "clientKey"), "UTF8String");
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v27;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "clientStorageToken";
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#monitor client doesn't have the storage token, clientKey:%{public, location:escape _only}s, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
    }

    int v28 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v29 = objc_msgSend(objc_msgSend(a2, "clientKey"), "UTF8String");
      *(_DWORD *)uint64_t buf = 68289795;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v29;
      __int16 v44 = 2082;
      uint64_t v45 = "assert";
      __int16 v46 = 2081;
      uint64_t v47 = "clientStorageToken";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#monitor client doesn't have the storage token",  "{msg%{public}.0s:#monitor client doesn't have the storage token, clientKey:%{public, location:escape _only}s, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
    }

    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO)) {
      sub_101264F48((uint64_t)objc_msgSend(objc_msgSend(a2, "clientKey"), "UTF8String"), (uint64_t)buf);
    }
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/DaemonIdentifiableClients/CLDaemonMonitor.mm",  71,  "CLDaemonMonitor");
LABEL_36:
    __break(1u);
  }

void sub_100BD5308( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, os_activity_scope_state_s state)
{
}

uint64_t sub_100BD53AC(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = sub_100BD557C(v4, a2);
  if ((_DWORD)v5)
  {
    if (a2) {
    else
    }
      unint64_t v6 = 0LL;
    sub_100BD57C0((uint64_t)v6, &v11);
    sub_1005DCA84((void **)(v4 + 240), v11);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(v4 + 240) == 0LL;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    int v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      int v8 = (*(uint64_t (**)(const void *))(*(void *)a2 + 24LL))(a2);
      uint64_t v9 = *(void *)(v4 + 16);
      *(_DWORD *)uint64_t buf = 68289794;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 1026;
      int v17 = v8;
      __int16 v18 = 2114;
      uint64_t v19 = v9;
      __int16 v20 = 2050;
      uint64_t v21 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor consumeMatchingButterfly, dicType:%{public}d, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x2Cu);
    }
  }

  return v5;
}

void sub_100BD5548( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t sub_100BD557C(uint64_t a1, const void *a2)
{
  unsigned int v4 = [*(id *)(a1 + 16) isEqual:sub_100019240((uint64_t)a2)];
  if ((*(unsigned int (**)(const void *))(*(void *)a2 + 24LL))(a2) != 4)
  {
    BOOL v7 = 0;
    return v4 & v7;
  }

  unint64_t v6 = v5;
  if (v5[215] < 0)
  {
    sub_1010DD48C(__p, *((void **)v5 + 24), *((void *)v5 + 25));
  }

  else
  {
    *(_OWORD *)__int128 __p = *((_OWORD *)v5 + 12);
    uint64_t v31 = *((void *)v5 + 26);
  }

  uint64_t v8 = *(unsigned __int8 *)(a1 + 215);
  if ((v8 & 0x80u) == 0LL) {
    uint64_t v9 = (void *)*(unsigned __int8 *)(a1 + 215);
  }
  else {
    uint64_t v9 = *(void **)(a1 + 200);
  }
  uint64_t v10 = (void *)HIBYTE(v31);
  char v11 = HIBYTE(v31);
  if (v31 < 0) {
    uint64_t v10 = __p[1];
  }
  if (v9 == v10)
  {
    int v12 = (const void **)(a1 + 192);
    if (v31 >= 0) {
      int v13 = __p;
    }
    else {
      int v13 = (void **)__p[0];
    }
    if ((v8 & 0x80) != 0)
    {
      if (memcmp(*v12, v13, *(void *)(a1 + 200))) {
        goto LABEL_21;
      }
    }

    else if (*(_BYTE *)(a1 + 215))
    {
      while (*(unsigned __int8 *)v12 == *(unsigned __int8 *)v13)
      {
        int v12 = (const void **)((char *)v12 + 1);
        int v13 = (void **)((char *)v13 + 1);
        if (!--v8) {
          goto LABEL_24;
        }
      }

      goto LABEL_21;
    }

void sub_100BD57A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100BD57C0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0LL;
  *a2 = *(id *)(a1 + 240);
  double v3 = *(void **)(a1 + 240);
  *(void *)(a1 + 240) = 0LL;

  return [*(id *)(a1 + 248) setNextFireDelay:1.79769313e308];
}

void sub_100BD5810(_Unwind_Exception *a1)
{
}

id sub_100BD5838(uint64_t a1)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768LL;
  void v6[2] = sub_100BD7F18;
  v6[3] = &unk_101876E68;
  v6[4] = a1;
  v6[5] = v8;
  BOOL v7 = v9;
  if (v9)
  {
    p_shared_weak_owners = &v9->__shared_weak_owners_;
    do
      unint64_t v3 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v3 + 1, (unint64_t *)p_shared_weak_owners));
  }

  id v4 = [v6 copy];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  return v4;
}

void sub_100BD58E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  int v18 = *(std::__shared_weak_count **)(v16 - 24);
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  _Unwind_Resume(exception_object);
}

id sub_100BD5908(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 240);
  [v2 updateAuthorizationContext:*(void *)(a1 + 40)];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101876ED8);
  }
  unint64_t v3 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 16);
    [*(id *)(a1 + 40) registrationResult];
    unsigned int v5 = [*(id *)(a1 + 40) registrationResult];
    *(_DWORD *)uint64_t buf = 68289794;
    int v11 = 0;
    __int16 v12 = 2082;
    int v13 = "";
    __int16 v14 = 2114;
    uint64_t v15 = v4;
    __int16 v16 = 2050;
    uint64_t v17 = a1;
    __int16 v18 = 2050;
    uint64_t v19 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor managing monitored conditions, ClientKeyPath:%{public, location:escape_only} @, this:%{public}p, RegistrationResult:%{public, location:CLClientRegistrationResult}lld}",  buf,  0x30u);
  }

  if (objc_msgSend(objc_msgSend(v2, "allMonitoringRecordsByIdentifier"), "count") && sub_100D57C18(a1))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    unint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      int v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v7;
      __int16 v16 = 2050;
      uint64_t v17 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor manageMonitoredConditions trying #AutoPrompt, ClientKeyPath:%{public, loca tion:escape_only}@, this:%{public}p}",  buf,  0x26u);
    }

    sub_100D57D74(a1);
  }

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  v9[2] = sub_100BD7F38;
  v9[3] = &unk_101876E98;
  v9[4] = a1;
  return objc_msgSend(objc_msgSend(v2, "allMonitoringRecordsByIdentifier"), "enumerateKeysAndObjectsUsingBlock:", v9);
}

id sub_100BD5B3C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 240) allMonitoringRecordsByIdentifier];
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id result = [v2 countByEnumeratingWithState:&v17 objects:v29 count:16];
  id v5 = result;
  if (result)
  {
    uint64_t v6 = *(void *)v18;
    *(void *)&__int128 v4 = 68289538LL;
    __int128 v15 = v4;
    do
    {
      uint64_t v7 = 0LL;
      do
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v2);
        }
        uint64_t v8 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)v7);
        id v9 = objc_msgSend(v2, "objectForKey:", v8, v15);
        if ([v9 daemonState])
        {
          id v10 = [v9 daemonState];
          if (v10 != [v9 clientState])
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_101876ED8);
            }
            int v11 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v12 = a1 + 192;
              id v13 = [v8 UTF8String];
              *(_DWORD *)uint64_t buf = v15;
              int v22 = 0;
              __int16 v23 = 2082;
              int v24 = "";
              __int16 v25 = 2082;
              uint64_t v26 = v12;
              __int16 v27 = 2082;
              id v28 = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor needs to send a pending event to client, monitor:%{public, locatio n:escape_only}s, identifier:%{public, location:escape_only}s}",  buf,  0x26u);
            }

            id v14 = [v9 getMonitoringRecordToNotifyClient];
            id v16 = 0LL;
            id v16 = v14;
            sub_100BD6D94(a1, &v16, (uint64_t)[v9 serviceTypeMask]);
          }
        }

        uint64_t v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id result = [v2 countByEnumeratingWithState:&v17 objects:v29 count:16];
      id v5 = result;
    }

    while (result);
  }

  return result;
}

void sub_100BD5D6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD5DB4(uint64_t a1)
{
  *(void *)a1 = off_101876DB8;
  id v2 = _os_activity_create( (void *)&_mh_execute_header,  "CL: #monitor(dtor)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &v8);

  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101876EB8);
  }
  unint64_t v3 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 16);
    *(_DWORD *)uint64_t buf = 68289794;
    int v10 = 0;
    __int16 v11 = 2082;
    uint64_t v12 = "";
    __int16 v13 = 2082;
    id v14 = "activity";
    __int16 v15 = 2114;
    uint64_t v16 = v4;
    __int16 v17 = 2050;
    uint64_t v18 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor(dtor), event:%{public, location:escape_only}s, ClientKeyPath:%{public, l ocation:escape_only}@, this:%{public}p}",  buf,  0x30u);
  }

  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  sub_100D56EF4(a1, v5);
  [*(id *)(a1 + 248) invalidate];

  *(void *)(a1 + 2memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  uint64_t v6 = *(void **)(a1 + 240);
  *(void *)(a1 + 240) = 0LL;

  os_activity_scope_leave(&v8);
  sub_100D555B4(a1);
  return a1;
}

void sub_100BD5F7C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BD5F98(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100BD5DB4(a1);
  operator delete(v1);
}

NSDictionary *sub_100BD5FAC(uint64_t a1)
{
  v5[0] = @"kCLConnectionMessageMonitorNameKey";
  id v2 = (void *)(a1 + 192);
  v6[0] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v2);
  v5[1] = @"kCLConnectionMessageMonitorProcessNameKey";
  unint64_t v3 = (void *)(a1 + 216);
  v6[1] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3);
  void v5[2] = @"SDKAtLeast2024";
  void v6[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL);
}

void sub_100BD6088(uint64_t a1, CLConnectionMessage **a2)
{
  unint64_t v3 = objc_alloc(&OBJC_CLASS___NSSet);
  objc_opt_class(&OBJC_CLASS___CLMonitoringRecord);
  uint64_t v5 = v4;
  objc_opt_class(&OBJC_CLASS___CLMonitoringEvent);
  uint64_t v7 = v6;
  objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v9 = v8;
  objc_opt_class(&OBJC_CLASS___NSString);
  uint64_t v11 = v10;
  objc_opt_class(&OBJC_CLASS___NSDate);
  uint64_t v13 = v12;
  objc_opt_class(&OBJC_CLASS___CLCircularGeographicCondition);
  uint64_t v15 = v14;
  objc_opt_class(&OBJC_CLASS___CLBeaconIdentityCondition);
  uint64_t v17 = v16;
  objc_opt_class(&OBJC_CLASS___CLMinimumAltitudeCondition);
  uint64_t v19 = v18;
  *(void *)&double v20 = objc_opt_class(&OBJC_CLASS___CLCondition).n128_u64[0];
  uint64_t v52 = v19;
  uint64_t v21 = a1;
  __int16 v23 = -[NSSet initWithObjects:](v3, "initWithObjects:", v5, v20, v7, v9, v11, v13, v15, v17, v52, v22, 0LL);
  int v24 = *(void **)(a1 + 240);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v23);
  if (DictionaryOfClasses)
  {
    uint64_t v26 = DictionaryOfClasses;
    __int16 v27 = (void *)CLConnectionMessage::name(*a2);
    int v28 = *((char *)v27 + 23);
    if (v28 < 0)
    {
      if (v27[1] != 38LL) {
        goto LABEL_21;
      }
      __int16 v27 = (void *)*v27;
    }

    else if (v28 != 38)
    {
      goto LABEL_21;
    }

    if (!memcmp(v27, "Monitor/kCLConnectionMessageMonitorAdd", 0x26uLL))
    {
      if (sub_100D57C18(a1))
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101876ED8);
        }
        uint64_t v45 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v46 = *(uint64_t **)(v21 + 16);
          *(_DWORD *)uint64_t buf = 68289538;
          int v55 = 0;
          __int16 v56 = 2082;
          BOOL v57 = "";
          __int16 v58 = 2114;
          uint64_t v59 = v46;
          __int16 v60 = 2050;
          uint64_t v61 = v21;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor add-record trying #AutoPrompt, ClientKeyPath:%{public, location:escape _only}@, this:%{public}p}",  buf,  0x26u);
        }

        sub_100D57D74(v21);
      }

      id v47 = [v26 objectForKeyedSubscript:@"kCLConnectionMessageMonitorMonitoringRecordKey"];
      objc_msgSend(v24, "addMonitoringRecord:forIdentifier:", v47, objc_msgSend(v47, "identifier"));
      id v48 = objc_msgSend( objc_msgSend(v24, "allMonitoringRecordsByIdentifier"),  "objectForKey:",  objc_msgSend(v47, "identifier"));
      sub_100BD67B8(v21, v48);
      if (([v48 conditionLimitExceeded] & 1) != 0
        || ([v48 conditionUnsupported] & 1) != 0
        || [v48 persistenceUnavailable])
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101876EB8);
        }
        uint64_t v49 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v50 = *(uint64_t **)(v21 + 16);
          *(_DWORD *)uint64_t buf = 68289795;
          int v55 = 0;
          __int16 v56 = 2082;
          BOOL v57 = "";
          __int16 v58 = 2114;
          uint64_t v59 = v50;
          __int16 v60 = 2050;
          uint64_t v61 = v21;
          __int16 v62 = 2113;
          id v63 = v48;
          _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:error while adding #monitor record, ClientKeyPath:%{public, location:escape_onl y}@, this:%{public}p, record:%{private, location:escape_only}@}",  buf,  0x30u);
        }

        objc_msgSend(v24, "removeRecordFromMonitoringWithIdentifier:", objc_msgSend(v47, "identifier"));
      }

      goto LABEL_62;
    }

void sub_100BD67B8(uint64_t a1, void *a2)
{
  if (!sub_100D55504(a1))
  {
    id v4 = (id)sub_100BD7900(a1, a2);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    uint64_t v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t buf = 68289794;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2114;
      uint64_t v16 = v6;
      __int16 v17 = 2050;
      uint64_t v18 = a1;
      __int16 v19 = 1026;
      int v20 = (int)v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor updating diagnosticMask, ClientKeyPath:%{public, location:escape_only}@,  this:%{public}p, diagnosticMask:%{public}d}",  buf,  0x2Cu);
    }

    if (![a2 daemonEvent]) {
      objc_msgSend( a2,  "updateDaemonEvent:",   -[CLMonitoringEvent initWithIdentifier:refinement:state:date:diagnostics:]( [CLMonitoringEvent alloc],  "initWithIdentifier:refinement:state:date:diagnostics:",  objc_msgSend(objc_msgSend(a2, "clientEvent"), "identifier"),  0,  0,  +[NSDate now](NSDate, "now"),  0));
    }
    if (objc_msgSend(objc_msgSend(a2, "daemonEvent"), "diagnosticMask") == v4)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
      uint64_t v7 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 16);
        *(_DWORD *)uint64_t buf = 68289794;
        int v12 = 0;
        __int16 v13 = 2082;
        uint64_t v14 = "";
        __int16 v15 = 2114;
        uint64_t v16 = v8;
        __int16 v17 = 2050;
        uint64_t v18 = a1;
        __int16 v19 = 1026;
        int v20 = (int)v4;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor skip update - existing mask is same as new mask, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p, diagnosticMask:%{public}d}",  buf,  0x2Cu);
      }
    }

    else
    {
      objc_msgSend(objc_msgSend(a2, "daemonEvent"), "updateDiagnosticMask:", v4);
      if (([a2 conditionLimitExceeded] & 1) != 0
        || ([a2 persistenceUnavailable] & 1) != 0
        || [a2 conditionUnsupported])
      {
        objc_msgSend(objc_msgSend(a2, "daemonEvent"), "updateMonitoringState:", 3);
      }

      id v9 = [a2 getMonitoringRecordToNotifyClient];
      id v10 = v9;
      sub_100BD6D94(a1, &v10, 0LL);
    }
  }

void sub_100BD6A8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BD6AD0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    id v2 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = *(unsigned __int8 *)(a1 + 48);
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 1026;
      unsigned int v13 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor eligibleForDestructionUponDisconnection, destroyUponDisconnection:%{public}hhd}",  (uint8_t *)&v8,  0x18u);
    }

    return *(_BYTE *)(a1 + 48) != 0;
  }

  else
  {
    unsigned int v5 = [*(id *)(a1 + 240) isMonitoring];
    uint64_t v4 = v5 ^ 1;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    uint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 1026;
      unsigned int v13 = v5;
      __int16 v14 = 1026;
      int v15 = v5 ^ 1;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor eligibleForDestructionUponDisconnection, isMonitoring:%{public}hhd, isEl ibleForDestruction:%{public}hhd}",  (uint8_t *)&v8,  0x1Eu);
    }
  }

  return v4;
}

uint64_t sub_100BD6C88()
{
  return 4LL;
}

uint64_t sub_100BD6C90()
{
  return 13271LL;
}

id sub_100BD6C98(uint64_t a1)
{
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101876EB8);
  }
  id v2 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    v5[0] = 68289538;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    __int16 v8 = 2114;
    uint64_t v9 = v3;
    __int16 v10 = 2050;
    uint64_t v11 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor authContext has changed, ClientKeyPath:%{public, location:escape_only}@, t his:%{public}p}",  (uint8_t *)v5,  0x26u);
  }

  return sub_100BD5908(a1);
}

void sub_100BD6D94(uint64_t a1, void **a2, uint64_t a3)
{
  if (sub_100D55504(a1))
  {
    if (!*(_BYTE *)(a1 + 184))
    {
      id v6 = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLApplicationLifecycleManager");
      id v7 = [*(id *)(a1 + 16) legacyClientKey];
      [v6 launchApplication:v7 requiringAuthForServiceMask:a3 | 0x80000];
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
      __int16 v8 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 215) < 0)
        {
          sub_1010DD48C(__p, *(void **)(a1 + 192), *(void *)(a1 + 200));
        }

        else
        {
          *(_OWORD *)__int128 __p = *(_OWORD *)(a1 + 192);
          uint64_t v16 = *(void *)(a1 + 208);
        }

        if (v16 >= 0) {
          uint64_t v9 = __p;
        }
        else {
          uint64_t v9 = (void **)__p[0];
        }
        id v10 = [v7 UTF8String];
        BOOL v11 = sub_100D55504(a1);
        int v12 = *(unsigned __int8 *)(a1 + 184);
        uint64_t buf = 68290050LL;
        *(_WORD *)uint64_t v18 = 2082;
        *(void *)&uint64_t v18[2] = "";
        __int16 v19 = 2082;
        int v20 = v9;
        __int16 v21 = 2082;
        id v22 = v10;
        __int16 v23 = 1026;
        BOOL v24 = v11;
        __int16 v25 = 1026;
        int v26 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor launch app, monitor:%{public, location:escape_only}s, clientKey:%{pu blic, location:escape_only}s, IsDisconnected:%{public}hhd, wasPreviouslyLaunched:%{public}hhd}",  (uint8_t *)&buf,  0x32u);
        if (SHIBYTE(v16) < 0) {
          operator delete(__p[0]);
        }
      }

      *(void *)(a1 + 2memset(v19, 0, 48) = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "newTimer");
      sub_1002B68E8(a1 + 56, &buf);
      unsigned int v13 = *(void **)(a1 + 248);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      void v14[2] = sub_100BD7B08;
      v14[3] = &unk_10181D3D0;
      _DWORD v14[4] = a1;
      [v13 setHandler:v14];
      [*(id *)(a1 + 248) setNextFireDelay:600.0];
      *(_BYTE *)(a1 + 184) = 1;
      if (*(void *)v18) {
        std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)v18);
      }
    }
  }

  else
  {
    sub_100BD7B44(a1, *a2, a3);

    *a2 = 0LL;
  }

void sub_100BD6FEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, std::__shared_weak_count *a23)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BD7024(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  if (a4)
  {
    if (a2)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
      id v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        BOOL v11 = (void *)(a1 + 192);
        int v16 = 68290051;
        int v17 = 0;
        __int16 v18 = 2082;
        __int16 v19 = "";
        __int16 v20 = 2082;
        __int16 v21 = v11;
        __int16 v22 = 2082;
        id v23 = [a2 UTF8String];
        __int16 v24 = 2049;
        __int16 v25 = a4;
        __int16 v26 = 2113;
        __int16 v27 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor onConditionUpdate, monitor:%{public, location:escape_only}s, identifie r:%{public, location:escape_only}s, newDaemonState:%{private, location:CLMonitoringState}lld, conditio n:%{private, location:escape_only}@}",  (uint8_t *)&v16,  0x3Au);
      }

      sub_100BD72DC(a1, a2, a3, a4, a5);
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
      int v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        unsigned int v13 = (void *)(a1 + 192);
        int v16 = 68289539;
        int v17 = 0;
        __int16 v18 = 2082;
        __int16 v19 = "";
        __int16 v20 = 2082;
        __int16 v21 = v13;
        __int16 v22 = 2049;
        id v23 = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#monitor identifier nil onConditionUpdate, monitor:%{public, location:escape_only }s, newDaemonState:%{private, location:CLMonitoringState}lld}",  (uint8_t *)&v16,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101876ED8);
        }
      }

      __int16 v14 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        int v15 = (void *)(a1 + 192);
        int v16 = 68289539;
        int v17 = 0;
        __int16 v18 = 2082;
        __int16 v19 = "";
        __int16 v20 = 2082;
        __int16 v21 = v15;
        __int16 v22 = 2049;
        id v23 = a4;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#monitor identifier nil onConditionUpdate",  "{msg%{public}.0s:#monitor identifier nil onConditionUpdate, monitor:%{public, location:escape_only }s, newDaemonState:%{private, location:CLMonitoringState}lld}",  (uint8_t *)&v16,  0x26u);
      }
    }
  }

void sub_100BD72DC(uint64_t a1, void *a2, void *a3, id a4, uint64_t a5)
{
  id v10 = *(void **)(a1 + 240);
  id v11 = objc_msgSend(objc_msgSend(v10, "allMonitoringRecordsByIdentifier"), "objectForKey:", a2);
  if (v11) {
    uint64_t v12 = sub_100BD7900(a1, v11);
  }
  else {
    uint64_t v12 = 0LL;
  }
  unsigned int v13 =  -[CLMonitoringEvent initWithIdentifier:refinement:state:date:diagnostics:]( objc_alloc(&OBJC_CLASS___CLMonitoringEvent),  "initWithIdentifier:refinement:state:date:diagnostics:",  a2,  a5,  a4,  +[NSDate now](&OBJC_CLASS___NSDate, "now"),  v12);
  if (!v11)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    id v23 = (os_log_s *)qword_101934988;
    BOOL v24 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
    if (v24)
    {
      __int16 v25 = (void *)(a1 + 192);
      *(_DWORD *)uint64_t buf = 68289795;
      int v41 = 0;
      __int16 v42 = 2082;
      id v43 = "";
      __int16 v44 = 2082;
      uint64_t v45 = v25;
      __int16 v46 = 2082;
      id v47 = [a2 UTF8String];
      __int16 v48 = 2049;
      id v49 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor no daemon monitoring record found, monitor:%{public, location:escape_only} s, identifier:%{public, location:escape_only}s, newDaemonState:%{private, location:CLMonitoringState}lld}",  buf,  0x30u);
    }

    id v22 = sub_100BD79AC(v24, a3, (uint64_t)v13);
    goto LABEL_30;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101876ED8);
  }
  __int16 v14 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int v38 = v13;
    int v15 = (void *)(a1 + 192);
    id v16 = [a2 UTF8String];
    [v11 clientState];
    id v17 = [v11 clientState];
    [v11 daemonState];
    *(_DWORD *)uint64_t buf = 68290307;
    int v41 = 0;
    __int16 v42 = 2082;
    id v43 = "";
    __int16 v44 = 2082;
    uint64_t v45 = v15;
    __int16 v46 = 2082;
    id v47 = v16;
    __int16 v48 = 2049;
    id v49 = v17;
    __int16 v50 = 2049;
    id v51 = [v11 daemonState];
    __int16 v52 = 2049;
    id v53 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#monitor update record to send to client, monitor:%{public, location:escape_only}s,  identifier:%{public, location:escape_only}s, clientState:%{private, location:CLMonitoringState}lld, daemon State:%{private, location:CLMonitoringState}lld, newDaemonState:%{private, location:CLMonitoringState}lld}",  buf,  0x44u);
    unsigned int v13 = v38;
  }

  if (a4
    && objc_msgSend(objc_msgSend(v11, "condition"), "isEqual:", a3)
    && [v11 daemonState] != a4)
  {
    [v10 updateDaemonEvent:v13 forIdentifier:a2];
  }

  id v18 = [v11 daemonState];
  if (v18 != [v11 clientState])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    __int16 v19 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      __int16 v20 = (void *)(a1 + 192);
      id v21 = [a2 UTF8String];
      *(_DWORD *)uint64_t buf = 68289538;
      int v41 = 0;
      __int16 v42 = 2082;
      id v43 = "";
      __int16 v44 = 2082;
      uint64_t v45 = v20;
      __int16 v46 = 2082;
      id v47 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor condition update to client, monitor:%{public, location:escape_only}s, id entifier:%{public, location:escape_only}s}",  buf,  0x26u);
    }

    id v22 = [v11 getMonitoringRecordToNotifyClient];
LABEL_30:
    __int16 v26 = v22;
    id v27 = v22;
    if (objc_msgSend(objc_msgSend(v26, "lastEvent"), "state"))
    {
      id v39 = v27;
      sub_100BD6D94(a1, &v39, (unint64_t)[v11 serviceTypeMask] | 0x80000);
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101876ED8);
      }
      int v28 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        uint64_t v29 = (void *)(a1 + 192);
        uint64_t v30 = *(void **)(a1 + 16);
        id v31 = [a2 UTF8String];
        [v11 daemonState];
        id v32 = [v11 daemonState];
        *(_DWORD *)uint64_t buf = 68290051;
        int v41 = 0;
        __int16 v42 = 2082;
        id v43 = "";
        __int16 v44 = 2114;
        uint64_t v45 = v30;
        __int16 v46 = 2082;
        id v47 = v29;
        __int16 v48 = 2082;
        id v49 = v31;
        __int16 v50 = 2049;
        id v51 = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this cond ition update to the client, ClientKeyPath:%{public, location:escape_only}@, monitor:%{public, locati on:escape_only}s, identifier:%{public, location:escape_only}s, daemonState:%{private, location:CLMonitoringState}lld}",  buf,  0x3Au);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101876ED8);
        }
      }

      id v33 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        unsigned int v34 = (void *)(a1 + 192);
        uint64_t v35 = *(void **)(a1 + 16);
        id v36 = [a2 UTF8String];
        [v11 daemonState];
        id v37 = [v11 daemonState];
        *(_DWORD *)uint64_t buf = 68290051;
        int v41 = 0;
        __int16 v42 = 2082;
        id v43 = "";
        __int16 v44 = 2114;
        uint64_t v45 = v35;
        __int16 v46 = 2082;
        id v47 = v34;
        __int16 v48 = 2082;
        id v49 = v36;
        __int16 v50 = 2049;
        id v51 = v37;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v33,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client",  "{msg%{public}.0s:#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this cond ition update to the client, ClientKeyPath:%{public, location:escape_only}@, monitor:%{public, locati on:escape_only}s, identifier:%{public, location:escape_only}s, daemonState:%{private, location:CLMonitoringState}lld}",  buf,  0x3Au);
      }
    }
  }

void sub_100BD78B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100BD7900(uint64_t a1, void *a2)
{
  unint64_t v4 = (unint64_t)[*(id *)(a1 + 40) diagnosticMask];
  if (*(_BYTE *)(a1 + 136)) {
    v4 |= sub_100D57238(a1, 2) | 0x2000;
  }
  unint64_t v5 = v4 | (unint64_t)[a2 diagnosticMaskIfMonitoringIsNonFunctional];
  return v5 & (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1);
}

id sub_100BD79AC(uint64_t a1, void *a2, uint64_t a3)
{
  if ((objc_opt_isKindOfClass(a2, v5) & 1) != 0)
  {
    id v6 = objc_alloc(&OBJC_CLASS___CLCircularGeographicCondition);
    [a2 center];
    double v8 = v7;
    double v10 = v9;
    [a2 radius];
    uint64_t v12 = -[CLCircularGeographicCondition initWithCenter:radius:](v6, "initWithCenter:radius:", v8, v10, v11);
  }

  else
  {
    objc_opt_class(&OBJC_CLASS___CLBeaconIdentityCondition);
    if ((objc_opt_isKindOfClass(a2, v13) & 1) != 0)
    {
      uint64_t v12 = (CLCircularGeographicCondition *)-[CLBeaconIdentityCondition _initWithUUID:major:minor:]( [CLBeaconIdentityCondition alloc],  "_initWithUUID:major:minor:",  [a2 UUID],  objc_msgSend(a2, "major"),  objc_msgSend(a2, "minor"));
    }

    else
    {
      objc_opt_class(&OBJC_CLASS___CLMinimumAltitudeCondition);
      if ((objc_opt_isKindOfClass(a2, v14) & 1) == 0)
      {
        id v16 = 0LL;
        goto LABEL_8;
      }

      int v15 = objc_alloc(&OBJC_CLASS___CLMinimumAltitudeCondition);
      [a2 altitude];
      uint64_t v12 = -[CLMinimumAltitudeCondition initWithAltitude:](v15, "initWithAltitude:");
    }
  }

  id v16 = v12;
LABEL_8:
  id v17 = -[CLMonitoringRecord initRecordWithCondition:options:event:]( objc_alloc(&OBJC_CLASS___CLMonitoringRecord),  "initRecordWithCondition:options:event:",  v16,  0LL,  a3);

  return v17;
}

void sub_100BD7B08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(void **)(v1 + 240);
  if (v2)
  {
    [v2 stopMonitoringAllConditions];
    sub_100D55940(v1, 5.0);
  }

void sub_100BD7B44(uint64_t a1, void *a2, uint64_t a3)
{
  if (sub_100D55504(a1))
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101876EB8);
    }
    id v6 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v25 = 2082;
      *(void *)&v25[2] = "";
      __int16 v26 = 2113;
      id v27 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#monitor connection not valid, record:%{private, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101876EB8);
      }
    }

    double v7 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)uint64_t buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v25 = 2082;
      *(void *)&v25[2] = "";
      __int16 v26 = 2113;
      id v27 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#monitor connection not valid",  "{msg%{public}.0s:#monitor connection not valid, record:%{private, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  else
  {
    if ([*(id *)(a1 + 16) bundlePath] == @"/System/Library/LocationBundles/NanoCompassAlerts.bundle")
    {
      sub_1010DDBC0(buf, "ShowAlert");
      sub_1010DDBC0(__p, "locationd.fence.elevatedPriority");
    }

    else
    {
      sub_1010DDBC0(buf, "FenceEvent");
      sub_1010DDBC0(__p, "locationd.fence");
    }

    sub_100D55A48(a1, (uint64_t *)buf, (uint64_t *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE3(v27) < 0) {
      operator delete(*(void **)buf);
    }
    id v8 = -[CLMonitoringRecord initRecordWithMonitoringRecord:]( objc_alloc(&OBJC_CLASS___CLMonitoringRecord),  "initRecordWithMonitoringRecord:",  a2);
    id v22 = @"kCLConnectionMessageMonitorMonitoringRecordKey";
    id v23 = v8;
    __p[0] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1LL);
    sub_100BD8180("Monitor/kCLConnectionMessageMonitorUpdateEvent", __p, buf);
    if (a3) {
      char v9 = objc_msgSend(objc_msgSend(a2, "lastEvent"), "state") != (id)1
    }
        && objc_msgSend(objc_msgSend(a2, "lastEvent"), "state") != (id)2;
    else {
      char v9 = 1;
    }
    id v18 = *(void **)buf;
    __int16 v19 = *(std::__shared_weak_count **)v25;
    if (*(void *)v25)
    {
      double v10 = (unint64_t *)(*(void *)v25 + 8LL);
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    sub_100D55D8C(a1, (uint64_t)&v18, a3, v9, 0.0);
    uint64_t v12 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    int v15 = *(std::__shared_weak_count **)v25;
    if (*(void *)v25)
    {
      id v16 = (unint64_t *)(*(void *)v25 + 8LL);
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }

void sub_100BD7EB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BD7F18(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (*(void *)(v5 + 8) != -1LL) {
      sub_100BD7024(v6, a2, a3, a4, a5);
    }
  }

void sub_100BD7F38(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = [a3 daemonCondition];
  [v5 setAuthorizationContext:*(void *)(v4 + 40)];
  if ([v5 isAuthorized])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    uint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(v4 + 16);
      int v10 = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v7;
      __int16 v16 = 2050;
      uint64_t v17 = v4;
      __int16 v18 = 2113;
      __int16 v19 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor trying to jump start condition due to auth context change, ClientKeyPath:% {public, location:escape_only}@, this:%{public}p, record:%{private, location:escape_only}@}",  (uint8_t *)&v10,  0x30u);
    }

    [v5 startMonitoring];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101876ED8);
    }
    id v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(v4 + 16);
      int v10 = 68289795;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v9;
      __int16 v16 = 2050;
      uint64_t v17 = v4;
      __int16 v18 = 2113;
      __int16 v19 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#monitor trying to force stop condition due to auth context change, ClientKeyPath:% {public, location:escape_only}@, this:%{public}p, record:%{private, location:escape_only}@}",  (uint8_t *)&v10,  0x30u);
    }

    [v5 stopMonitoring];
  }

  sub_100BD67B8(v4, a3);
}

void sub_100BD8128(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_100BD8154(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void *sub_100BD8180@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  id result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100BD81CC(_Unwind_Exception *a1)
{
}

void sub_100BD81E0(float a1, uint64_t a2, uint64_t a3)
{
  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 0;
  *(_WORD *)(a3 + 8) = 2082;
}

uint64_t sub_100BD81F4@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, __int16 a3@<W8>)
{
  *(void *)(a2 + 10) = v3;
  *(_WORD *)(a2 + 18) = a3;
  *(void *)(a2 + 20) = result;
  *(_WORD *)(a2 + sub_100231C10(v1 + 28) = a3;
  return result;
}

void *sub_100BD82E0(void *result, uint64_t a2)
{
  *id result = a2;
  result[1] = 0xBFF0000000000000LL;
  result[2] = 0LL;
  return result;
}

BOOL sub_100BD82F0(uint64_t a1, double a2, double a3)
{
  double v6 = *(double *)(a1 + 8);
  BOOL result = 1LL;
  if (v6 != -1.0 && a2 - v6 < 900.0) {
    return v6
  }
         + a3
         + (double)(unint64_t)(*(void *)(a1 + 16) - 1LL)
  return result;
}

id sub_100BD8374(uint64_t a1)
{
  id result = [*(id *)a1 assertInside];
  *(void *)(a1 + 8) = 0xBFF0000000000000LL;
  *(void *)(a1 + 16) = 0LL;
  return result;
}

void sub_100BD83A0(uint64_t a1, double a2)
{
  *(double *)(a1 + 8) = a2;
  ++*(void *)(a1 + 16);
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101876EF8);
  }
  uint64_t v4 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v5 = *(void *)(a1 + 16);
    *(_DWORD *)uint64_t buf = 67240448;
    int v15 = v5;
    __int16 v16 = 2050;
    uint64_t v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "TileDl, backoff, count, %{public}d, time, %{public}0.1f",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101876EF8);
    }
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 16);
    v11[0] = 67240448;
    v11[1] = v7;
    __int16 v12 = 2050;
    uint64_t v13 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "TileDl, backoff, count, %{public}d, time, %{public}0.1f",  v11,  18);
    int v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileDownloadPolicy::receivedDownloadFailedAt(CFAbsoluteTime)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

void sub_100BD858C(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

uint64_t sub_100BD85B8(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_100BD8610;
  v3[3] = &unk_101820718;
  v3[4] = a2;
  return AnalyticsSendEventLazy(@"com.apple.CoreMotion.MagnetometerStatistics", v3);
}

NSDictionary *sub_100BD8610(uint64_t a1)
{
  v12[0] = @"timestamp";
  v13[0] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(a1 + 32) + 1LL));
  v12[1] = @"isSaturated";
  v13[1] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 9LL));
  v12[2] = @"isFaulted";
  v13[2] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 10LL));
  _OWORD v12[3] = @"maxAbsBx";
  LODWORD(sub_10004ADC8(v1, v2) = *(_DWORD *)(*(void *)(a1 + 32) + 11LL);
  v13[3] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v2);
  v12[4] = @"maxAbsBy";
  LODWORD(v3) = *(_DWORD *)(*(void *)(a1 + 32) + 15LL);
  v13[4] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
  void v12[5] = @"maxAbsBz";
  LODWORD(v4) = *(_DWORD *)(*(void *)(a1 + 32) + 19LL);
  v13[5] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v4);
  v12[6] = @"meanAbsBx";
  LODWORD(sub_1012279C0(0LL, v4, v5) = *(_DWORD *)(*(void *)(a1 + 32) + 23LL);
  v13[6] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v5);
  v12[7] = @"meanAbsBy";
  LODWORD(v6) = *(_DWORD *)(*(void *)(a1 + 32) + 27LL);
  v13[7] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v6);
  v12[8] = @"meanAbsBz";
  LODWORD(v7) = *(_DWORD *)(*(void *)(a1 + 32) + 31LL);
  v13[8] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v7);
  v12[9] = @"varBx";
  LODWORD(v8) = *(_DWORD *)(*(void *)(a1 + 32) + 35LL);
  void v13[9] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v8);
  v12[10] = @"varBy";
  LODWORD(v9) = *(_DWORD *)(*(void *)(a1 + 32) + 39LL);
  v13[10] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v9);
  v12[11] = @"varBz";
  LODWORD(v10) = *(_DWORD *)(*(void *)(a1 + 32) + 43LL);
  v13[11] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v10);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v13,  v12,  12LL);
}

_OWORD *sub_100BD87FC(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  sub_10001A504((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  sub_10001A504((uint64_t)(a1 + 3), (uint64_t)(a2 + 3));
  a1[5] = 0u;
  a1[6] = 0u;
  return a1;
}

void sub_100BD8850(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  double v5 = *(void **)(v3 + 40);
  if (v5 == v1)
  {
    uint64_t v6 = 4LL;
  }

  else
  {
    if (!v5) {
      goto LABEL_6;
    }
    uint64_t v6 = 5LL;
    uint64_t v1 = v5;
  }

  (*(void (**)(void *))(*v1 + 8 * v6))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *sub_100BD8890(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }

  double v4 = (void *)a1[9];
  if (v4 == a1 + 6)
  {
    uint64_t v5 = 4LL;
    double v4 = a1 + 6;
  }

  else
  {
    if (!v4) {
      goto LABEL_10;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  uint64_t v6 = (void *)a1[5];
  if (v6 == a1 + 2)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 2;
    goto LABEL_14;
  }

  if (v6)
  {
    uint64_t v7 = 5LL;
LABEL_14:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }

  return a1;
}

void sub_100BD8930(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = (void **)(a1 + 80);
  uint64_t v6 = a2 + 1;
  uint64_t v8 = *a2;
  uint64_t v7 = a2 + 5;
  uint64_t v9 = v8;
  if ((*(_DWORD *)a1 & 0xFFFFFFFC) == 4) {
    uint64_t v6 = v7;
  }
  uint64_t v10 = *v6;
  int v11 = *(char **)(a1 + 88);
  uint64_t v12 = a1 + 96;
  unint64_t v13 = *(void *)(a1 + 96);
  if ((unint64_t)v11 >= v13)
  {
    int v15 = (char *)*v5;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v11 - (_BYTE *)*v5) >> 3);
    unint64_t v17 = v16 + 1;
    if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x555555555555555LL) {
      unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      __int16 v20 = (char *)sub_10000701C(v12, v19);
      int v15 = *(char **)(a1 + 80);
      int v11 = *(char **)(a1 + 88);
    }

    else
    {
      __int16 v20 = 0LL;
    }

    char v21 = &v20[24 * v16];
    id v22 = &v20[24 * v19];
    *(void *)char v21 = v9;
    *((void *)v21 + 1) = v9;
    *((void *)v21 + 2) = v10;
    __int16 v14 = v21 + 24;
    if (v11 != v15)
    {
      do
      {
        __int128 v23 = *(_OWORD *)(v11 - 24);
        *((void *)v21 - 1) = *((void *)v11 - 1);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 24;
        v11 -= 24;
      }

      while (v11 != v15);
      int v15 = (char *)*v5;
    }

    *(void *)(a1 + 80) = v21;
    *(void *)(a1 + 88) = v14;
    *(void *)(a1 + 96) = v22;
    if (v15) {
      operator delete(v15);
    }
  }

  else
  {
    *(void *)int v11 = v9;
    *((void *)v11 + 1) = v9;
    __int16 v14 = v11 + 24;
    *((void *)v11 + 2) = v10;
  }

  *(void *)(a1 + 88) = v14;
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_101876F18);
  }
  BOOL v24 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
  {
    id v25 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    uint64_t v26 = *(void *)(a1 + 88);
    double v27 = *(double *)(v26 - 24);
    uint64_t v28 = *(void *)(v26 - 8);
    *(_DWORD *)uint64_t buf = 136315650;
    id v91 = v25;
    __int16 v92 = 2048;
    double v93 = v27;
    __int16 v94 = 2048;
    uint64_t v95 = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "[workout distance] aggregator %s, adding odometer sample %f, %f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    uint64_t v62 = qword_101934688;
    id v63 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    uint64_t v64 = *(void *)(a1 + 88);
    double v65 = *(double *)(v64 - 24);
    uint64_t v66 = *(void *)(v64 - 8);
    int v82 = 136315650;
    id v83 = v63;
    __int16 v84 = 2048;
    double v85 = v65;
    __int16 v86 = 2048;
    uint64_t v87 = v66;
    LODWORD(v76) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v62,  2LL,  "[workout distance] aggregator %s, adding odometer sample %f, %f",  (const char *)&v82,  v76,  *(double *)&v77);
    double v68 = (uint8_t *)v67;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)",  "%s\n",  v67);
    if (v68 != buf) {
      free(v68);
    }
  }

  uint64_t v30 = *(double **)(a1 + 80);
  uint64_t v29 = *(void *)(a1 + 88);
  if (0xAAAAAAAAAAAAAAABLL * ((v29 - (uint64_t)v30) >> 3) <= 1
    || (v31 = *(double *)(v29 - 24) - *v30, double v32 = *(double *)(a1 + 8), v31 < v32 + 1.0 + -0.5))
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 24) = 0;
    return;
  }

  if (v31 > v32 + 10.0)
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    id v33 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
    {
      id v34 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315394;
      id v91 = v34;
      __int16 v92 = 2048;
      double v93 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "[workout distance] aggregator %s, interval exceeds expected interval, %f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101876F18);
      }
      uint64_t v69 = qword_101934688;
      id v70 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      int v82 = 136315394;
      id v83 = v70;
      __int16 v84 = 2048;
      double v85 = v31;
      LODWORD(v76) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v69,  16LL,  "[workout distance] aggregator %s, interval exceeds expected interval, %f",  (const char *)&v82,  v76);
      double v72 = (uint8_t *)v71;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)",  "%s\n",  v71);
      if (v72 != buf) {
        free(v72);
      }
    }
  }

  double v35 = *(double *)(a1 + 8);
  id v36 = *(const void **)(a1 + 80);
  else {
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 88) - (void)v36) >> 3) - 1;
  }
  __int16 v79 = 0LL;
  id v80 = 0LL;
  uint64_t v81 = 0LL;
  sub_100021A84(&v79, v36, (uint64_t)v36 + 24 * v37, v37);
  if (v80 != (_BYTE *)v79)
  {
    unint64_t v38 = (v80 - (_BYTE *)v79) / 24;
    uint64_t v39 = *(void *)(a1 + 80);
    unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 88) - v39) >> 3);
    if (v40 <= 1) {
      unint64_t v40 = 1LL;
    }
    unint64_t v41 = v40 - 1;
    if (v38 <= 1) {
      unint64_t v38 = 1LL;
    }
    __int16 v42 = v79 + 1;
    id v43 = (uint64_t *)(v39 + 24);
    do
    {
      if (!v41) {
        sub_100092C20();
      }
      uint64_t v44 = *v43;
      v43 += 3;
      *__int16 v42 = v44;
      v42 += 3;
      --v41;
      --v38;
    }

    while (v38);
  }

  uint64_t v45 = *(void *)(a1 + 40);
  if (!v45) {
    sub_100008BDC();
  }
  *(void *)&__int128 v77 = (*(double (**)(uint64_t, void **))(*(void *)v45 + 48LL))(v45, &v79);
  *((void *)&v77 + 1) = v46;
  uint64_t v78 = v47;
  uint64_t v48 = *(void *)(a1 + 72);
  if (!v48) {
    sub_100008BDC();
  }
  if ((*(unsigned int (**)(uint64_t, __int128 *))(*(void *)v48 + 48LL))(v48, &v77))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    id v49 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      id v50 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315906;
      id v91 = v50;
      __int16 v92 = 2048;
      double v93 = *(double *)&v77;
      __int16 v94 = 2048;
      uint64_t v95 = *((void *)&v77 + 1);
      __int16 v96 = 2048;
      uint64_t v97 = v78;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "[workout distance] aggregator %s, writing entry <startTime=%f, endTime=%f, metric=%f>",  buf,  0x2Au);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_61;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    uint64_t v51 = qword_101934688;
    id v52 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    int v82 = 136315906;
    id v83 = v52;
    __int16 v84 = 2048;
    double v85 = *(double *)&v77;
    __int16 v86 = 2048;
    uint64_t v87 = *((void *)&v77 + 1);
    __int16 v88 = 2048;
    uint64_t v89 = v78;
    LODWORD(v76) = 42;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v51,  2LL,  "[workout distance] aggregator %s, writing entry <startTime=%f, endTime=%f, metric=%f>",  (const char *)&v82,  v76,  *(double *)&v77,  *((double *)&v77 + 1));
    __int128 v54 = (uint8_t *)v53;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)",  "%s\n",  v53);
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    int v55 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      id v56 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315906;
      id v91 = v56;
      __int16 v92 = 2048;
      double v93 = *(double *)&v77;
      __int16 v94 = 2048;
      uint64_t v95 = *((void *)&v77 + 1);
      __int16 v96 = 2048;
      uint64_t v97 = v78;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "[workout distance] aggregator %s, suppressing entry <startTime=%f, endTime=%f, metric=%f>",  buf,  0x2Au);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_61;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    uint64_t v73 = qword_101934688;
    id v74 = [*(id *)(a1 + 104) cStringUsingEncoding:4];
    int v82 = 136315906;
    id v83 = v74;
    __int16 v84 = 2048;
    double v85 = *(double *)&v77;
    __int16 v86 = 2048;
    uint64_t v87 = *((void *)&v77 + 1);
    __int16 v88 = 2048;
    uint64_t v89 = v78;
    LODWORD(v76) = 42;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v73,  0LL,  "[workout distance] aggregator %s, suppressing entry <startTime=%f, endTime=%f, metric=%f>",  (const char *)&v82,  v76,  *(double *)&v77,  *((double *)&v77 + 1));
    __int128 v54 = (uint8_t *)v75;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<AggregationEntry> CLWorkoutDistanceDataCollector::Aggregator::feedOdometer(const CLOdometerEntry &)",  "%s\n",  v75);
  }

  if (v54 != buf) {
    free(v54);
  }
LABEL_61:
  if (v37)
  {
    BOOL v57 = (char *)*v5;
    __int16 v58 = &v57[24 * v37];
    uint64_t v59 = *(_BYTE **)(a1 + 88);
    uint64_t v60 = v59 - v58;
    if (v59 != v58) {
      memmove(v57, v58, v59 - v58);
    }
    *(void *)(a1 + 88) = &v57[v60];
  }

  *(_OWORD *)a3 = v77;
  uint64_t v61 = v79;
  *(void *)(a3 + 16) = v78;
  *(_BYTE *)(a3 + 24) = 1;
  if (v61)
  {
    id v80 = v61;
    operator delete(v61);
  }

void sub_100BD92D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100BD931C(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t sub_100BD932C(void *a1)
{
  uint64_t v2 = a1[1];
  if (a1[2] != v2)
  {
    unint64_t v3 = a1[4];
    double v4 = (void *)(v2 + 8 * (v3 >> 9));
    uint64_t v5 = (void **)(*v4 + 8 * (v3 & 0x1FF));
    uint64_t v6 = *(void *)(v2 + (((a1[5] + v3) >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * ((a1[5] + v3) & 0x1FF);
    while (v5 != (void **)v6)
    {
      sub_100BD93C0(v5++, 0LL);
      if ((void **)((char *)v5 - *v4) == (void **)4096)
      {
        uint64_t v7 = (void **)v4[1];
        ++v4;
        uint64_t v5 = v7;
      }
    }
  }

  return sub_100BD9D88(a1);
}

void sub_100BD93C0(void **a1, void *a2)
{
  unint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    double v4 = sub_100BD8890(v3);
    operator delete(v4);
  }

void sub_100BD93F0(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1];
  if (a1[2] != v2)
  {
    unint64_t v3 = a1[4];
    double v4 = (void *)(v2 + 8 * (v3 >> 9));
    uint64_t v5 = (uint64_t *)(*v4 + 8 * (v3 & 0x1FF));
    uint64_t v6 = *(void *)(v2 + (((a1[5] + v3) >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * ((a1[5] + v3) & 0x1FF);
    while (v5 != (uint64_t *)v6)
    {
      uint64_t v8 = *v5++;
      sub_100BD8930(v8, a2, (uint64_t)&v10);
      if ((uint64_t *)((char *)v5 - *v4) == (uint64_t *)4096)
      {
        uint64_t v9 = (uint64_t *)v4[1];
        ++v4;
        uint64_t v5 = v9;
      }
    }
  }

void sub_100BD948C(void *a1, int *a2)
{
  if (!*((void *)a2 + 5) || (*((void *)a2 + 9) ? (BOOL v3 = *a2 == 7) : (BOOL v3 = 1), v3 || *((double *)a2 + 1) <= 0.0))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    unint64_t v17 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
    {
      int v18 = *a2;
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "[workout distance] not adding aggregator for type %d because settings are nonsensical",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101876F18);
      }
      int v24 = *a2;
      int v31 = 67109120;
      int v32 = v24;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "[workout distance] not adding aggregator for type %d because settings are nonsensical",  &v31);
      __int128 v23 = (uint8_t *)v25;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)",  "%s\n",  v25);
      goto LABEL_37;
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    uint64_t v5 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *a2;
      uint64_t v7 = *((void *)a2 + 1);
      *(_DWORD *)uint64_t buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v6;
      __int16 v36 = 2048;
      uint64_t v37 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[workout distance] adding aggregator of type %d with interval %f",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101876F18);
      }
      int v26 = *a2;
      uint64_t v27 = *((void *)a2 + 1);
      int v31 = 67109376;
      int v32 = v26;
      __int16 v33 = 2048;
      uint64_t v34 = v27;
      LODWORD(v30) = 18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "[workout distance] adding aggregator of type %d with interval %f",  &v31,  v30);
      uint64_t v29 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)",  "%s\n",  v28);
      if (v29 != buf) {
        free(v29);
      }
    }

    uint64_t v8 = a1[1];
    if (a1[2] == v8
      || (unint64_t v9 = a1[4],
          uint64_t v10 = (void *)(v8 + 8 * (v9 >> 9)),
          int v11 = (_DWORD **)(*v10 + 8 * (v9 & 0x1FF)),
          uint64_t v12 = *(void *)(v8 + (((a1[5] + v9) >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * ((a1[5] + v9) & 0x1FF),
          v11 == (_DWORD **)v12))
    {
LABEL_18:
      __int16 v14 = operator new(0x70uLL);
      sub_100BD87FC(v14, a2);
      *(void *)uint64_t buf = v14;
      sub_100BD9A00(a1, (uint64_t *)buf);
      int v15 = *(void **)buf;
      *(void *)uint64_t buf = 0LL;
      if (v15)
      {
        unint64_t v16 = sub_100BD8890(v15);
        operator delete(v16);
      }

      return;
    }

    while (**v11 != *a2)
    {
      if ((_DWORD **)((char *)++v11 - *v10) == (_DWORD **)4096)
      {
        unint64_t v13 = (_DWORD **)v10[1];
        ++v10;
        int v11 = v13;
      }

      if (v11 == (_DWORD **)v12) {
        goto LABEL_18;
      }
    }

    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101876F18);
    }
    unint64_t v19 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *a2;
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "[workout distance] already have an aggregator of that type %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101876F18);
      }
      int v21 = *a2;
      int v31 = 67109120;
      int v32 = v21;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "[workout distance] already have an aggregator of that type %d",  &v31);
      __int128 v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutDistanceDataCollector::Collector::addAggregator(const Aggregator::Settings &)",  "%s\n",  v22);
LABEL_37:
      if (v23 != buf) {
        free(v23);
      }
    }
  }

void sub_100BD99CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  if (a15)
  {
    unint64_t v16 = sub_100BD8890(a15);
    operator delete(v16);
  }

  _Unwind_Resume(exception_object);
}

void sub_100BD9A00(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100BD9EB0(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  uint64_t v9 = *(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL));
  uint64_t v10 = *a2;
  *a2 = 0LL;
  *(void *)(v9 + 8 * (v8 & 0x1FF)) = v10;
  a1[5] = v7 + 1;
}

void sub_100BD9A88(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void *sub_100BD9ABC()
{
  double result = operator new(0x10uLL);
  *double result = &off_101876F48;
  return result;
}

void sub_100BD9AE0(uint64_t a1, void *a2)
{
  *a2 = &off_101876F48;
}

double sub_100BD9AF8(uint64_t a1, double **a2)
{
  uint64_t v2 = *a2;
  double result = **a2;
  double v4 = 0.0;
  while (v2 != a2[1])
  {
    double v4 = v4 + v2[2];
    v2 += 3;
  }

  return result;
}

uint64_t sub_100BD9B24(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BD9B60()
{
}

void *sub_100BD9B74()
{
  double result = operator new(0x10uLL);
  *double result = &off_101876FC8;
  return result;
}

void sub_100BD9B98(uint64_t a1, void *a2)
{
  *a2 = &off_101876FC8;
}

double sub_100BD9BB0(uint64_t a1, double **a2)
{
  uint64_t v2 = a2[1];
  double result = **a2;
  double v4 = 0.0;
  if (*a2 != v2)
  {
    uint64_t v5 = *a2;
    do
    {
      double v4 = v4 + v5[2];
      v5 += 3;
    }

    while (v5 != v2);
  }

  return result;
}

uint64_t sub_100BD9C00(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BD9C3C()
{
}

void *sub_100BD9C50()
{
  double result = operator new(0x10uLL);
  *double result = &off_101877048;
  return result;
}

void sub_100BD9C74(uint64_t a1, void *a2)
{
  *a2 = &off_101877048;
}

BOOL sub_100BD9C8C(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) >= 0.0;
}

uint64_t sub_100BD9C9C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BD9CD8()
{
}

void *sub_100BD9CEC()
{
  double result = operator new(0x10uLL);
  *double result = &off_1018770C8;
  return result;
}

void sub_100BD9D10(uint64_t a1, void *a2)
{
  *a2 = &off_1018770C8;
}

BOOL sub_100BD9D28(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) > 2.22044605e-16;
}

uint64_t sub_100BD9D40(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100BD9D7C()
{
}

uint64_t sub_100BD9D88(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    double v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }

  else
  {
    double v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (char *)*v6 + 8 * (v5 & 0x1FF);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_100BD93C0((void **)v7, 0LL);
        v7 += 8;
        if (v7 - (_BYTE *)*v6 == 4096)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }

      while (v7 != (char *)v8);
      uint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }

  void *v4 = 0LL;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 512LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    unint64_t v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_100BD9EB0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100BDA178( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BDA1C4()
{
  qword_10199ACC0 = (uint64_t)&off_101876F48;
  qword_10199ACD8 = (uint64_t)&qword_10199ACC0;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_10199ACC0, (void *)&_mh_execute_header);
  qword_10199ACE0 = (uint64_t)&off_101876FC8;
  qword_10199ACF8 = (uint64_t)&qword_10199ACE0;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_10199ACE0, (void *)&_mh_execute_header);
  qword_10199AD00 = (uint64_t)&off_101877048;
  qword_10199AD18 = (uint64_t)&qword_10199AD00;
  __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_10199AD00, (void *)&_mh_execute_header);
  qword_10199AD20 = (uint64_t)&off_1018770C8;
  qword_10199AD38 = (uint64_t)&qword_10199AD20;
  return __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_10199AD20, (void *)&_mh_execute_header);
}

uint64_t sub_100BDA280(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 1;
  unint64_t v4 = *(_OWORD **)a2;
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    *(_OWORD *)a1 = *v4;
    *(_BYTE *)(a1 + 16) = a3;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  else
  {
    *(_OWORD *)a1 = *v4;
    *(_BYTE *)(a1 + 16) = a3;
  }

  return a1;
}

__n128 sub_100BDA310(__n128 *a1, __n128 **a2, unsigned __int8 a3)
{
  __n128 result = **a2;
  *a1 = result;
  a1[1].n128_u8[0] = a3;
  return result;
}

BOOL sub_100BDA328(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
}

BOOL sub_100BDA364(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return *(void *)a1 < *(void *)a2;
  }
  int v2 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a1 + 16)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    return *(void *)(a1 + 8) < *(void *)(a2 + 8);
  }
  return *(_BYTE *)(a1 + 16) && v2 == 0;
}

BOOL sub_100BDA3B4(unsigned __int8 *a1, uint64_t *a2, void *a3, int a4, double a5)
{
  *a2 = 0xBFF0000000000000LL;
  if (!*a1
    || (uint64_t v6 = *((void *)a1 + 8)) == 0
    || !*(_BYTE *)(v6 + 18)
    || (double v10 = *((double *)a1 + 22), v10 > 0.0) && vabdd_f64(a5, v10) <= 0.9)
  {
    if (!a4) {
      return 0LL;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v15 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v16 = *((void *)a1 + 8);
      if (v16) {
        int v17 = *(unsigned __int8 *)(v16 + 18);
      }
      else {
        int v17 = -1;
      }
      int v46 = *a1;
      uint64_t v47 = *((void *)a1 + 22);
      *(_DWORD *)uint64_t buf = 67240704;
      *(_DWORD *)unsigned int v136 = v17;
      *(_WORD *)&v136[4] = 1026;
      *(_DWORD *)&v136[6] = v46;
      *(_WORD *)int v137 = 2050;
      *(void *)&v137[2] = v47;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "CLMM,no TEPA,isTunnel,%{public}d,isSnapUsable,%{public}d,lastAssistanceTime,%{public}.1lf",  buf,  0x18u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v79 = *((void *)a1 + 8);
    if (v79) {
      int v80 = *(unsigned __int8 *)(v79 + 18);
    }
    else {
      int v80 = -1;
    }
    int v81 = *a1;
    uint64_t v82 = *((void *)a1 + 22);
    *(_DWORD *)int v111 = 67240704;
    *(_DWORD *)&v111[4] = v80;
    *(_WORD *)&v111[8] = 1026;
    *(_DWORD *)&v111[10] = v81;
    *(_WORD *)&v111[14] = 2050;
    *(void *)&v111[16] = v82;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,no TEPA,isTunnel,%{public}d,isSnapUsable,%{public}d,lastAssistanceTime,%{public}.1lf",  v111,  24);
    BOOL v14 = (uint8_t *)v83;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPosi tionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v83);
    goto LABEL_135;
  }

  if (+[GEOLocationShifter isLocationShiftRequiredForCoordinate:]( &OBJC_CLASS___GEOLocationShifter,  "isLocationShiftRequiredForCoordinate:",  *((double *)a1 + 12),  *((double *)a1 + 13)))
  {
    if (!a4) {
      return 0LL;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v12 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      *(double *)unsigned int v136 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,no TEPA, shifted coordinates",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    *(_DWORD *)int v111 = 134349056;
    *(double *)&v111[4] = a5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,no TEPA, shifted coordinates",  v111,  12);
    BOOL v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPosi tionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v13);
LABEL_135:
    if (v14 != buf) {
      free(v14);
    }
    return 0LL;
  }

  uint64_t v18 = *((void *)a1 + 8);
  unint64_t v19 = (std::__shared_weak_count *)*((void *)a1 + 9);
  int v107 = (double *)v18;
  int v108 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
  }

  int v101 = a3;
  int v22 = *(unsigned __int8 *)(v18 + 18);
  double v23 = *((double *)a1 + 14);
  *((_BYTE *)a2 + 72) = 0;
  int v24 = 0;
  if (!v22)
  {
    double v25 = 0.0;
    goto LABEL_81;
  }

  double v25 = 0.0;
  __asm { FMOV            V0.2D, #-1.0 }

  __n128 v99 = _Q0;
  while (1)
  {
    __int128 v30 = v107;
    if (!v107) {
      goto LABEL_81;
    }
    if (v24 == 200) {
      break;
    }
    sub_1001AC068(v107);
    double v31 = v30[5];
    *(double *)a2 = a5;
    __int128 v32 = (uint64_t *)v107;
    uint64_t v33 = *((void *)v107 + 18);
    if (v33 == *((void *)v107 + 17))
    {
      a2[1] = 0LL;
      uint64_t v34 = 0LL;
    }

    else
    {
      a2[1] = *(void *)(v33 - 16);
      uint64_t v34 = *(void *)(v33 - 8);
    }

    a2[2] = v34;
    *((double *)a2 + 4) = sub_1001ACB08(v32);
    double v35 = (uint64_t *)v107;
    a2[8] = *((void *)v107 + 12);
    double v36 = fmod(*((float *)a1 + 22) - *((double *)a2 + 4), 360.0);
    if (v36 < 0.0) {
      double v36 = v36 + 360.0;
    }
    if (v36 > 180.0) {
      double v36 = v36 + -360.0;
    }
    if (fabs(v36) > 7.5) {
      *((_BYTE *)a2 + 72) = 1;
    }
    uint64_t v37 = v107;
    sub_1001AC068(v107);
    double v38 = 1.0 - v23;
    double v39 = v37[5];
    uint64_t v105 = 0LL;
    double v106 = 0.0;
    uint64_t v103 = (uint64_t)&v103;
    int v104 = &v103;
    *(void *)int v111 = 0LL;
    *(__n128 *)&v111[16] = v99;
    *(_OWORD *)unsigned int v112 = 0uLL;
    *(void *)&v112[16] = 0xBFF0000000000000LL;
    uint64_t v124 = 0LL;
    int v125 = 0;
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    __int16 v123 = 0;
    __int128 v126 = 0u;
    __int128 v127 = 0u;
    __int128 v128 = 0u;
    memset(v129, 0, sizeof(v129));
    __int128 v130 = 0u;
    __int128 v131 = 0u;
    __int128 v132 = 0u;
    __int128 v119 = 0u;
    memset(v120, 0, sizeof(v120));
    __int128 v117 = 0u;
    __int128 v118 = 0u;
    __int128 v115 = 0u;
    __int128 v116 = 0u;
    __int128 v114 = 0u;
    *(_OWORD *)&v112[24] = 0u;
    memset(v113, 0, sizeof(v113));
    unint64_t v134 = 0xBFF0000000000000LL;
    uint64_t v133 = 0LL;
    *(double *)&v111[8] = a5;
    if (!(*(unsigned int (**)(void, _BYTE *, uint64_t *, void, uint64_t, double **, uint64_t, double *, double, double))(*(void *)*a3 + 80LL))( *a3,  v111,  &v103,  0LL,  1LL,  &v107,  1LL,  &v106,  v23,  v39 * (1.0 - v23) + 1.0)) {
      goto LABEL_52;
    }
    if (v105 != 1 || v106 < 0.0)
    {
      if (a4)
      {
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_101877138);
        }
        id v43 = (os_log_s *)qword_1019348B8;
        if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 67240192;
          *(_DWORD *)unsigned int v136 = v105;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "CLMM,no TEPA,multi-outbound,%{public}d",  buf,  8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348B0 != -1) {
            dispatch_once(&qword_1019348B0, &stru_101877138);
          }
          int v109 = 67240192;
          int v110 = v105;
          LODWORD(v98) = 8;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,no TEPA,multi-outbound,%{public}d",  &v109,  v98);
          uint64_t v45 = (uint8_t *)v44;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelE ndPositionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v44);
          if (v45 != buf) {
            free(v45);
          }
        }
      }

      BOOL v42 = 0;
      *a2 = 0xBFF0000000000000LL;
      goto LABEL_60;
    }

    sub_1000F2F30(&v107, v104 + 2);
    double v40 = sub_1001ACB28((uint64_t)v107, 0, 1);
    if (v40 < 0.0) {
      goto LABEL_49;
    }
    double v41 = fmod(v40 - *((double *)a2 + 4), 360.0);
    if (v41 < 0.0) {
      double v41 = v41 + 360.0;
    }
    if (v41 > 180.0) {
      double v41 = v41 + -360.0;
    }
    if (fabs(v41) > 7.5) {
LABEL_49:
    }
      *((_BYTE *)a2 + 72) = 1;
    double v23 = 0.0;
    if (v107) {
      BOOL v42 = *((_BYTE *)v107 + 18) != 0;
    }
    else {
LABEL_52:
    }
      BOOL v42 = 0;
LABEL_60:
    if (SHIBYTE(v116) < 0) {
      operator delete(*((void **)&v115 + 1));
    }
    double v25 = v25 + v31 * v38;
    sub_100890314(&v103);
    ++v24;
    if (!v42) {
      goto LABEL_81;
    }
  }

  *a2 = 0xBFF0000000000000LL;
  if (a4)
  {
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v50 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)unsigned int v136 = 201;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "CLMM,TEPA,outgoing reached max iterations,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_101877138);
      }
      *(void *)int v111 = 0xC904020100LL;
      LODWORD(v98) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,TEPA,outgoing reached max iterations,%{public}d",  v111,  v98);
      uint64_t v95 = (uint8_t *)v94;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPo sitionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v94);
      if (v95 != buf) {
        free(v95);
      }
    }

    int v24 = 201;
LABEL_81:
    uint64_t v51 = *a2;
    if (*(double *)a2 > 0.0)
    {
      *((double *)a2 + 14) = v25;
      a2[3] = 0x4039000000000000LL;
      *(_OWORD *)(a2 + 5) = xmmword_10134E520;
      a2[7] = 0xBFF0000000000000LL;
      double v52 = *((double *)a1 + 4);
      if (v52 > 0.0)
      {
        a2[6] = *((void *)a1 + 5);
        *((double *)a2 + 7) = v52;
      }

      *((void *)a1 + 22) = v51;
      a2[11] = 0LL;
      a2[12] = 0LL;
      id v53 = a2 + 11;
      *((double *)a2 + 13) = v25;
      sub_1000F2F30(&v107, (uint64_t *)a1 + 8);
      if (*((_BYTE *)v107 + 18))
      {
        int v54 = 0;
        double v55 = *((double *)a1 + 14);
        __asm { FMOV            V0.2D, #-1.0 }

        __int128 v100 = _Q0;
        while (1)
        {
          BOOL v57 = v107;
          if (!v107) {
            goto LABEL_119;
          }
          if (v54 == 200)
          {
            a2[13] = 0xBFF0000000000000LL;
            *id v53 = 0LL;
            a2[12] = 0LL;
            if (a4)
            {
              if (qword_1019348B0 != -1) {
                dispatch_once(&qword_1019348B0, &stru_101877138);
              }
              uint64_t v66 = (os_log_s *)qword_1019348B8;
              if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)uint64_t buf = 67240192;
                *(_DWORD *)unsigned int v136 = 201;
                _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEBUG,  "CLMM,TEPA,incoming reached max iterations,%{public}d",  buf,  8u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019348B0 != -1) {
                  dispatch_once(&qword_1019348B0, &stru_101877138);
                }
                *(void *)int v111 = 0xC904020100LL;
                LODWORD(v98) = 8;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,TEPA,incoming reached max iterations,%{public}d",  v111,  v98);
                uint64_t v97 = (uint8_t *)v96;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::T unnelEndPositionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v96);
                if (v97 != buf) {
                  free(v97);
                }
              }
            }

            int v54 = 201;
            goto LABEL_119;
          }

          sub_1001AC068(v107);
          *((double *)a2 + 13) = *((double *)a2 + 13) + v57[5] * v55;
          __int16 v58 = v107;
          uint64_t v59 = (__int128 *)*((void *)v107 + 17);
          else {
            __int128 v60 = *v59;
          }
          *(_OWORD *)id v53 = v60;
          sub_1001AC068(v58);
          double v61 = v58[5];
          uint64_t v105 = 0LL;
          double v106 = 0.0;
          uint64_t v103 = (uint64_t)&v103;
          int v104 = &v103;
          *(void *)int v111 = 0LL;
          *(_OWORD *)&v111[16] = v100;
          *(_OWORD *)unsigned int v112 = 0uLL;
          *(void *)&v112[16] = 0xBFF0000000000000LL;
          uint64_t v124 = 0LL;
          int v125 = 0;
          __int128 v121 = 0u;
          __int128 v122 = 0u;
          __int16 v123 = 0;
          __int128 v126 = 0u;
          __int128 v127 = 0u;
          __int128 v128 = 0u;
          memset(v129, 0, sizeof(v129));
          __int128 v130 = 0u;
          __int128 v131 = 0u;
          __int128 v132 = 0u;
          __int128 v119 = 0u;
          memset(v120, 0, sizeof(v120));
          __int128 v117 = 0u;
          __int128 v118 = 0u;
          __int128 v115 = 0u;
          __int128 v116 = 0u;
          __int128 v114 = 0u;
          *(_OWORD *)&v112[24] = 0u;
          memset(v113, 0, sizeof(v113));
          unint64_t v134 = 0xBFF0000000000000LL;
          uint64_t v133 = 0LL;
          *(double *)&v111[8] = a5;
          if (!(*(unsigned int (**)(void, _BYTE *, void, uint64_t *, void, double **, uint64_t, double *, double, double))(*(void *)*v101 + 80LL))( *v101,  v111,  0LL,  &v103,  0LL,  &v107,  1LL,  &v106,  v55,  v61 * v55 + 1.0)) {
            goto LABEL_102;
          }
          if (v105 != 1 || v106 < 0.0) {
            break;
          }
          sub_1000F2F30(&v107, v104 + 2);
          double v55 = 1.0;
          if (!v107) {
            goto LABEL_102;
          }
          BOOL v62 = *((_BYTE *)v107 + 18) != 0;
LABEL_103:
          if (SHIBYTE(v116) < 0) {
            operator delete(*((void **)&v115 + 1));
          }
          sub_100890314(&v103);
          ++v54;
          if (!v62) {
            goto LABEL_119;
          }
        }

        a2[13] = 0xBFF0000000000000LL;
        *id v53 = 0LL;
        a2[12] = 0LL;
        if (a4)
        {
          if (qword_1019348B0 != -1) {
            dispatch_once(&qword_1019348B0, &stru_101877138);
          }
          id v63 = (os_log_s *)qword_1019348B8;
          if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t buf = 67240192;
            *(_DWORD *)unsigned int v136 = v105;
            _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEBUG,  "CLMM,no TEPA,multi-inbound,%{public}d",  buf,  8u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019348B0 != -1) {
              dispatch_once(&qword_1019348B0, &stru_101877138);
            }
            int v109 = 67240192;
            int v110 = v105;
            LODWORD(v98) = 8;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,no TEPA,multi-inbound,%{public}d",  &v109,  v98);
            double v65 = (uint8_t *)v64;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::Tunne lEndPositionAssistance &, CLMapGeometryPtr, BOOL)",  "%s\n",  v64);
            if (v65 != buf) {
              free(v65);
            }
          }
        }

void sub_100BDB4AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *__p, uint64_t a44, int a45, __int16 a46, char a47, char a48)
{
}

uint64_t sub_100BDB518(double *a1, uint64_t a2, void *a3, int a4)
{
  int v8 = *(_DWORD *)(a2 + 96);
  double v9 = *(double *)(a2 + 76);
  double v10 = *(double *)(a2 + 44);
  if (v10 >= 0.0)
  {
    a1[6] = v9;
    a1[1] = v10;
  }

  if (!*(_BYTE *)a1
    || (uint64_t v11 = *((void *)a1 + 8)) == 0
    || ((double v12 = a1[7], v13 = v9 - v12, v12 > 0.0) ? (v14 = v13 > 5.0) : (v14 = 1),
        v14
     || !*(_BYTE *)(v11 + 18)
     || (v8 == 3 || a1[2] <= 0.0) && ((v15 = a1[6], v15 <= 0.0) || (double v13 = a1[1], v13 < 0.0) || v9 - v15 > 15.0)))
  {
    if (!a4) {
      return 0LL;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    unint64_t v21 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v22 = *(void *)(a2 + 76);
      uint64_t v23 = *((void *)a1 + 8);
      if (v23) {
        int v24 = *(unsigned __int8 *)(v23 + 18);
      }
      else {
        int v24 = -1;
      }
      int v25 = *(unsigned __int8 *)a1;
      uint64_t v27 = *((void *)a1 + 6);
      uint64_t v26 = *((void *)a1 + 7);
      uint64_t v28 = *((void *)a1 + 1);
      uint64_t v29 = *((void *)a1 + 2);
      *(_DWORD *)uint64_t buf = 134351104;
      unint64_t v137 = v22;
      __int16 v138 = 1026;
      *(_DWORD *)__int16 v139 = v24;
      *(_WORD *)&v139[4] = 1026;
      *(_DWORD *)&v139[6] = v25;
      *(_WORD *)uint64_t v140 = 2050;
      *(void *)&v140[2] = v26;
      *(_WORD *)__int16 v141 = 2050;
      *(void *)&v141[2] = 0x4014000000000000LL;
      *(_WORD *)uint64_t v142 = 2050;
      *(void *)&v142[2] = v28;
      *(_WORD *)__int16 v143 = 2050;
      *(void *)&v143[2] = v27;
      __int16 v144 = 2050;
      uint64_t v145 = 0x402E000000000000LL;
      __int16 v146 = 2050;
      uint64_t v147 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,NotPropagating,isTunnel,%{public}d,isSnapUsable,%{public}d,particleTime,%{public}.2lf,particl eTimeOut,%{public}.1lf,speed,%{public}.2lf,speedTime,%{public}.2lf,speedTimeOut,%{public}.1lf,speedLimit,%{public}.1lf",  buf,  0x54u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v76 = *(void *)(a2 + 76);
    uint64_t v77 = *((void *)a1 + 8);
    if (v77) {
      int v78 = *(unsigned __int8 *)(v77 + 18);
    }
    else {
      int v78 = -1;
    }
    int v79 = *(unsigned __int8 *)a1;
    uint64_t v81 = *((void *)a1 + 6);
    uint64_t v80 = *((void *)a1 + 7);
    uint64_t v82 = *((void *)a1 + 1);
    uint64_t v83 = *((void *)a1 + 2);
    *(_DWORD *)__int128 v118 = 134351104;
    *(void *)&v118[4] = v76;
    *(_WORD *)&v118[12] = 1026;
    *(_DWORD *)&v118[14] = v78;
    *(_WORD *)&v118[18] = 1026;
    *(_DWORD *)&v118[20] = v79;
    *(_WORD *)&v118[24] = 2050;
    *(void *)&v118[26] = v80;
    *(_WORD *)&v118[34] = 2050;
    *(void *)&v118[36] = 0x4014000000000000LL;
    *(_WORD *)&v118[44] = 2050;
    *(void *)&v118[46] = v82;
    *(_WORD *)&v118[54] = 2050;
    *(void *)&v118[56] = v81;
    *(_WORD *)&v118[64] = 2050;
    *(void *)&v118[66] = 0x402E000000000000LL;
    *(_WORD *)&v118[74] = 2050;
    *(void *)&v118[76] = v83;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,NotPropagating,isTunnel,%{public}d,isSnapUsable,%{public}d,particleTime,%{public}.2lf,particleT imeOut,%{public}.1lf,speed,%{public}.2lf,speedTime,%{public}.2lf,speedTimeOut,%{public}.1lf,speedLimit,%{public}.1lf",  v118,  84);
    int64_t v20 = (uint8_t *)v84;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v84);
    goto LABEL_141;
  }

  if (+[GEOLocationShifter isLocationShiftRequiredForCoordinate:]( &OBJC_CLASS___GEOLocationShifter,  "isLocationShiftRequiredForCoordinate:",  a1[12],  a1[13],  v13)
    && *(_DWORD *)(a2 + 132) != 2)
  {
    if (!a4) {
      return 0LL;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v16 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v17 = *(void *)(a2 + 76);
      *(_DWORD *)uint64_t buf = 134349056;
      unint64_t v137 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,NotPropagating, shifting is required but accessory is outputting  unshifted coordinates",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v18 = *(void *)(a2 + 76);
    *(_DWORD *)__int128 v118 = 134349056;
    *(void *)&v118[4] = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,NotPropagating, shifting is required but accessory is outputting  unshifted coordinates",  v118,  12);
    int64_t v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v19);
LABEL_141:
    if (v20 != buf) {
      free(v20);
    }
    return 0LL;
  }

  double v32 = *(double *)(a2 + 76) - a1[7];
  if (v32 < 0.0)
  {
    if (!a4) {
      return 0LL;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v33 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v34 = *(void *)(a2 + 76);
      uint64_t v35 = *((void *)a1 + 7);
      *(_DWORD *)uint64_t buf = 134349312;
      unint64_t v137 = v34;
      __int16 v138 = 2050;
      *(void *)__int16 v139 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,NotPropagating,time lower than particleTime, %{public}.2lf",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v36 = *(void *)(a2 + 76);
    uint64_t v37 = *((void *)a1 + 7);
    *(_DWORD *)__int128 v118 = 134349312;
    *(void *)&v118[4] = v36;
    *(_WORD *)&v118[12] = 2050;
    *(void *)&v118[14] = v37;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,NotPropagating,time lower than particleTime, %{public}.2lf",  v118,  22);
    int64_t v20 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v38);
    goto LABEL_141;
  }

  if (v8 == 3 || (double v39 = a1[2], v39 <= 0.0))
  {
    double v39 = a1[1];
  }

  else if (a1[1] >= v39)
  {
    double v39 = a1[1];
  }

  double v40 = v32 * v39;
  if (v32 * v39 <= 225.0) {
    double v41 = v32 * v39;
  }
  else {
    double v41 = 225.0;
  }
  if (v32 * v39 > 225.0 && a4 != 0)
  {
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    id v43 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v44 = *(void *)(a2 + 76);
      *(_DWORD *)uint64_t buf = 134349568;
      unint64_t v137 = v44;
      __int16 v138 = 2050;
      *(double *)__int16 v139 = v40;
      *(_WORD *)&v139[8] = 2050;
      *(void *)uint64_t v140 = 0x406C200000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,limit distance to propagate,orig,%{public}.1lf,new,%{public}.1lf",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_101877138);
      }
      uint64_t v85 = *(void *)(a2 + 76);
      *(_DWORD *)__int128 v118 = 134349568;
      *(void *)&v118[4] = v85;
      *(_WORD *)&v118[12] = 2050;
      *(double *)&v118[14] = v40;
      *(_WORD *)&v118[22] = 2050;
      *(void *)&v118[24] = 0x406C200000000000LL;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,limit distance to propagate,orig,%{public}.1lf,new,%{public}.1lf",  v118,  32);
      uint64_t v87 = (uint8_t *)v86;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v86);
      if (v87 != buf) {
        free(v87);
      }
    }

    double v41 = 225.0;
  }

  *(void *)__int128 v118 = 0LL;
  *(void *)&v118[8] = 0LL;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v96 = _Q0;
  *(_OWORD *)&v118[16] = _Q0;
  *(void *)&v118[32] = 0LL;
  *(void *)&v118[40] = 0LL;
  *(void *)&v118[48] = 0xBFF0000000000000LL;
  uint64_t v128 = 0LL;
  int v129 = 0;
  memset(&v126[32], 0, 32);
  __int16 v127 = 0;
  __int128 v130 = 0u;
  __int128 v131 = 0u;
  __int128 v132 = 0u;
  memset(v133, 0, 27);
  memset(&v133[32], 0, 48);
  memset(v126, 0, 30);
  __int128 v125 = 0u;
  __int128 v124 = 0u;
  __int128 v123 = 0u;
  __int128 v122 = 0u;
  __int128 v121 = 0u;
  __int128 v120 = 0u;
  __int128 v119 = 0u;
  memset(&v118[56], 0, 32);
  unint64_t v135 = 0xBFF0000000000000LL;
  uint64_t v134 = 0LL;
  v99[0] = (uint64_t)v99;
  v99[1] = (uint64_t)v99;
  unint64_t v100 = 0LL;
  uint64_t v98 = 0LL;
  if (((*(uint64_t (**)(void, _BYTE *, uint64_t *, void, uint64_t, unsigned __int8 *, void, uint64_t *, double, double))(*(void *)*a3 + 80LL))( *a3,  v118,  v99,  0LL,  1LL,  (unsigned __int8 *)a1 + 64,  *((unsigned __int8 *)a1 + 84),  &v98,  a1[14],  v41) & 1) == 0)
  {
    if (!a4) {
      goto LABEL_83;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    double v52 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEBUG,  "CLMM,NotPropagating,roadsAtIntersection returned false",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_83;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    *(_WORD *)int v113 = 0;
    LODWORD(v95) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,NotPropagating,roadsAtIntersection returned false",  v113,  v95);
    uint64_t v51 = (uint8_t *)v88;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v88);
    goto LABEL_150;
  }

  if (v100 >= 2)
  {
    if (!a4) {
      goto LABEL_83;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v49 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      unint64_t v137 = v100;
      __int16 v138 = 2050;
      *(double *)__int16 v139 = v41;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "CLMM,NotPropagating,multi-outbound,%{public}lu,intersection within the distance,%{public}.2lf, needed to be travelled returned",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_83;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    *(_DWORD *)int v113 = 134349312;
    *(void *)&v113[4] = v100;
    __int16 v114 = 2050;
    double v115 = v41;
    LODWORD(v95) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,NotPropagating,multi-outbound,%{public}lu,intersection within the distance,%{public}.2lf, needed to be travelled returned",  v113,  v95);
    uint64_t v51 = (uint8_t *)v50;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v50);
LABEL_150:
    if (v51 != buf) {
      free(v51);
    }
LABEL_83:
    uint64_t v30 = 0LL;
    goto LABEL_125;
  }

  sub_100BDC7E0((uint64_t)v113, (uint64_t)(a1 + 8));
  v97[0] = v97;
  v97[1] = v97;
  v97[2] = 0LL;
  if (((*(uint64_t (**)(void, _BYTE *, void *, double))(*(void *)*a3 + 88LL))(*a3, v113, v97, v41) & 1) == 0)
  {
    if (!a4) {
      goto LABEL_123;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v64 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEBUG,  "CLMM,NotPropagating,moveOnRoad returned false",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_123;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    LOWORD(v101) = 0;
    LODWORD(v95) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,NotPropagating,moveOnRoad returned false",  &v101,  v95);
    uint64_t v66 = (uint8_t *)v65;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v65);
    goto LABEL_159;
  }

  if (!*(void *)v113)
  {
    if (!a4) {
      goto LABEL_123;
    }
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v67 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_FAULT, "CLMM,NotPropagating,NULL road", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_123;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    LOWORD(v101) = 0;
    LODWORD(v95) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  17LL,  "CLMM,NotPropagating,NULL road",  &v101,  v95);
    uint64_t v66 = (uint8_t *)v68;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v68);
    goto LABEL_159;
  }

  if (*(_BYTE *)(*(void *)v113 + 18LL))
  {
    if (a4)
    {
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_101877138);
      }
      id v53 = (os_log_s *)qword_1019348B8;
      if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v54 = *(void *)(a2 + 76);
        uint64_t v55 = *((void *)a1 + 1);
        uint64_t v56 = *((void *)a1 + 2);
        *(_DWORD *)uint64_t buf = 134350337;
        unint64_t v137 = v54;
        __int16 v138 = 2049;
        *(void *)__int16 v139 = v117;
        *(_WORD *)&v139[8] = 2049;
        *(void *)uint64_t v140 = *((void *)&v117 + 1);
        *(_WORD *)&v140[8] = 2050;
        *(double *)__int16 v141 = v116;
        *(_WORD *)&v141[8] = 2050;
        *(void *)uint64_t v142 = v55;
        *(_WORD *)&v142[8] = 2050;
        *(void *)__int16 v143 = v56;
        _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEBUG,  "CLMM,%{public}.1lf,Propagating,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,speed,%{public}.1lf, speedLimit,%{public}.1lf",  buf,  0x3Eu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_101877138);
        }
        uint64_t v89 = *(void *)(a2 + 76);
        uint64_t v90 = *((void *)a1 + 1);
        uint64_t v91 = *((void *)a1 + 2);
        int v101 = 134350337;
        uint64_t v102 = v89;
        __int16 v103 = 2049;
        uint64_t v104 = v117;
        __int16 v105 = 2049;
        uint64_t v106 = *((void *)&v117 + 1);
        __int16 v107 = 2050;
        double v108 = v116;
        __int16 v109 = 2050;
        uint64_t v110 = v90;
        __int16 v111 = 2050;
        uint64_t v112 = v91;
        LODWORD(v95) = 62;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,%{public}.1lf,Propagating,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,speed,%{public}.1lf, speedLimit,%{public}.1lf",  &v101,  v95);
        double v93 = (uint8_t *)v92;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v92);
        if (v93 != buf) {
          free(v93);
        }
      }
    }

    double v57 = *(double *)(a2 + 76);
    a1[6] = v57;
    *(_OWORD *)(a2 + 4) = v117;
    *(double *)(a2 + 60) = v116;
    *(void *)(a2 + 52) = 0x3FC999999999999ALL;
    *(void *)(a2 + 68) = 0x4008000000000000LL;
    *(_OWORD *)(a2 + sub_100231C10(v1 + 28) = xmmword_1012EA5D0;
    int v58 = *(_DWORD *)(a2 + 96);
    if (v58 != 3) {
      *(_OWORD *)(a2 + 44) = v96;
    }
    double v59 = a1[4];
    if (v59 <= 0.0)
    {
      double v61 = 0.0;
      double v63 = -1.0;
    }

    else
    {
      __int128 v60 = (double *)(a2 + 36);
      double v61 = a1[5];
      *(double *)(a2 + sub_100231C10(v1 + 28) = v61;
      double v62 = v59 + v32 * 0.15;
      *(double *)(a2 + 36) = v62;
      if (v62 > 200.0) {
        __int128 v60 = (double *)&unk_10134E530;
      }
      double v63 = *v60;
      *(double *)(a2 + 36) = *v60;
    }

    *(void *)(a2 + 20) = 0x4024000000000000LL;
    uint64_t v70 = (double *)(a2 + 20);
    double v71 = 10.0;
    if ((v58 & 0xFFFFFFF7) == 1)
    {
      double v72 = a1[3] + v32 * 0.5;
      double *v70 = v72;
      uint64_t v73 = (double *)&unk_10134E538;
      if (v72 >= 10.0) {
        uint64_t v73 = v70;
      }
      double v74 = *v73;
      double *v70 = *v73;
      uint64_t v75 = (double *)&unk_10134E540;
      if (v74 <= 149.0) {
        uint64_t v75 = v70;
      }
      double v71 = *v75;
      double *v70 = *v75;
    }

    uint64_t v30 = 1LL;
    sub_100BDC888((uint64_t)a1, (uint64_t)v113, 1, v57, v71, v61, v63);
    goto LABEL_124;
  }

  if (a4)
  {
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v69 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "CLMM,NotPropagating,solution moved away from tunnel",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_101877138);
      }
      LOWORD(v101) = 0;
      LODWORD(v95) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM,NotPropagating,solution moved away from tunnel",  &v101,  v95);
      uint64_t v66 = (uint8_t *)v94;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, BOOL)",  "%s\n",  v94);
LABEL_159:
      if (v66 != buf) {
        free(v66);
      }
    }
  }

void sub_100BDC780( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a64 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BDC7E0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3)
  {
    unint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  __int128 v6 = *(_OWORD *)(a2 + 16);
  __int128 v7 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + memset(v19, 0, 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v6;
  *(_OWORD *)(a1 + 32) = v7;
  __int128 v8 = *(_OWORD *)(a2 + 56);
  __int128 v9 = *(_OWORD *)(a2 + 65);
  *(void *)(a1 + 88) = 0LL;
  *(_OWORD *)(a1 + 65) = v9;
  *(_OWORD *)(a1 + 56) = v8;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  sub_100BDD080( (void *)(a1 + 88),  *(const void **)(a2 + 88),  *(void *)(a2 + 96),  0x8E38E38E38E38E39LL * ((uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3));
  return a1;
}

void sub_100BDC874(_Unwind_Exception *a1)
{
}

void *sub_100BDC888(uint64_t a1, uint64_t a2, char a3, double a4, double a5, double a6, double a7)
{
  *(double *)(a1 + 56) = a4;
  uint64_t v13 = a1 + 64;
  __n128 result = sub_1000F2F30((void *)(a1 + 64), (uint64_t *)a2);
  uint64_t v15 = *(void *)(a2 + 48);
  __int128 v16 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 96) = v16;
  *(void *)(a1 + 112) = v15;
  __int128 v17 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 129) = *(_OWORD *)(a2 + 65);
  *(_OWORD *)(a1 + 120) = v17;
  if (v13 != a2) {
    __n128 result = sub_100BDD0F8( (char *)(a1 + 152),  *(char **)(a2 + 88),  *(void *)(a2 + 96),  0x8E38E38E38E38E39LL * ((uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3));
  }
  *(_BYTE *)a1 = a3;
  *(double *)(a1 + 32) = a7;
  *(double *)(a1 + 40) = a6;
  *(double *)(a1 + 24) = a5;
  uint64_t v18 = *(void *)(a1 + 64);
  if (v18)
  {
    double v19 = *(double *)(v18 + 32);
    if (v19 <= 0.0) {
      double v19 = -1.0;
    }
    *(double *)(a1 + 16) = v19;
  }

  return result;
}

uint64_t sub_100BDC958(uint64_t a1)
{
  int v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }

  return sub_10000AE14(a1);
}

void sub_100BDC988(uint64_t a1, __int128 *a2)
{
  double v3 = *((double *)a2 + 1);
  *(double *)a1 = v3;
  if (*((_BYTE *)a2 + 264))
  {
    double v26 = 0.0;
    double v27 = 0.0;
    double v24 = 0.0;
    double v25 = 0.0;
    *(_BYTE *)(a1 + 56) = 0;
    if (!*(_DWORD *)(a1 + 8))
    {
      int v7 = 1;
      double v8 = 0.0;
      double v9 = 0.0;
      double v10 = 0.0;
      double v11 = 0.0;
LABEL_10:
      double v12 = *(double *)(a1 + 16);
      double v13 = *(double *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = v7;
      *(double *)(a1 + 16) = v11 + v12;
      *(double *)(a1 + 24) = v10 + v13;
      double v14 = v8 + *(double *)(a1 + 40);
      *(double *)(a1 + 32) = v9 + *(double *)(a1 + 32);
      *(double *)(a1 + 40) = v14;
      __int128 v15 = *a2;
      __int128 v16 = a2[1];
      __int128 v17 = a2[3];
      *(_OWORD *)(a1 + 96) = a2[2];
      *(_OWORD *)(a1 + 112) = v17;
      *(_OWORD *)(a1 + 64) = v15;
      *(_OWORD *)(a1 + 80) = v16;
      __int128 v18 = a2[4];
      __int128 v19 = a2[5];
      __int128 v20 = a2[7];
      *(_OWORD *)(a1 + 160) = a2[6];
      *(_OWORD *)(a1 + 176) = v20;
      *(_OWORD *)(a1 + 1sub_100231C10(v1 + 28) = v18;
      *(_OWORD *)(a1 + 144) = v19;
      std::string::operator=((std::string *)(a1 + 192), (const std::string *)(a2 + 8));
      memcpy((void *)(a1 + 216), (char *)a2 + 152, 0x118uLL);
      return;
    }

    double v5 = v3 - *(double *)(a1 + 72);
    if (v5 >= 0.0 && v5 <= 2.2)
    {
      if (!sub_100D2DA44( (double *)(a1 + 496),  &v25,  &v24,  &v28,  *((double *)a2 + 36),  *((double *)a2 + 37),  *((double *)a2 + 9),  *(double *)(a1 + 352),  *(double *)(a1 + 360),  *(double *)(a1 + 136))
        || sqrt(v24 * v24 + v25 * v25) / v5 > 3.8
        || !*((_BYTE *)a2 + 228)
        && *((double *)a2 + 12) > 2.2
        && !sub_100D2DA44( (double *)(a1 + 496),  &v27,  &v26,  &v28,  *((double *)a2 + 7),  *((double *)a2 + 8),  *((double *)a2 + 9),  *(double *)(a1 + 120),  *(double *)(a1 + 128),  *(double *)(a1 + 136)))
      {
        *(void *)a1 = 0LL;
        *(_DWORD *)(a1 + 8) = 0;
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_OWORD *)(a1 + 41) = 0u;
        sub_100BDD258(a1 + 64);
        return;
      }

      double v22 = 0.0;
      uint64_t v23 = 0LL;
      sub_100D2E36C( (double *)(a1 + 496),  (double *)&v23,  &v22,  *((double *)a2 + 36),  *((double *)a2 + 37),  *((double *)a2 + 9),  *((double *)a2 + 21),  *((double *)a2 + 7),  *((double *)a2 + 8));
      double v21 = v22;
      *(double *)(a1 + memset(v19, 0, 48) = v21;
      double v10 = v26;
      double v11 = v27;
      double v8 = v24;
      double v9 = v25;
      int v7 = *(_DWORD *)(a1 + 8) + 1;
      goto LABEL_10;
    }

    *(void *)a1 = 0LL;
    *(_DWORD *)(a1 + 8) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
    uint64_t v6 = a1 + 64;
  }

  else
  {
    *(void *)a1 = 0LL;
    *(_DWORD *)(a1 + 8) = 0;
    uint64_t v6 = a1 + 64;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
  }

  sub_100BDD258(v6);
}

BOOL sub_100BDCBC8(uint64_t *a1, int a2)
{
  if (*((_DWORD *)a1 + 2) < 4u) {
    return 0LL;
  }
  double v3 = sqrt(*((double *)a1 + 3) * *((double *)a1 + 3) + *((double *)a1 + 2) * *((double *)a1 + 2));
  double v4 = sqrt(*((double *)a1 + 5) * *((double *)a1 + 5) + *((double *)a1 + 4) * *((double *)a1 + 4));
  if (*((_BYTE *)a1 + 56))
  {
    double v5 = v3 - v4;
    if (*((double *)a1 + 6) > 15.0 && v5 > 29.0)
    {
      if (a2)
      {
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_101877138);
        }
        uint64_t v6 = (os_log_s *)qword_1019348B8;
        if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_INFO))
        {
          uint64_t v7 = *a1;
          uint64_t v8 = a1[6];
          *(_DWORD *)uint64_t buf = 134350080;
          uint64_t v27 = v7;
          __int16 v28 = 2050;
          *(void *)uint64_t v29 = v8;
          *(_WORD *)&void v29[8] = 2050;
          *(double *)&v29[10] = v3;
          *(_WORD *)&v29[18] = 2050;
          *(double *)&v29[20] = v4;
          *(_WORD *)&v29[28] = 2050;
          *(void *)&v29[30] = 0x403D000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "CLMM,%{public}.1lf,detected stuck,alongTrackRawToSnap,%{public}.1lf,deltaPosChange,%{public}.1lf,deltaSnapCh ange,%{public}.1lf,thresholdDiff,%{public}.1lf",  buf,  0x34u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348B0 != -1) {
            dispatch_once(&qword_1019348B0, &stru_101877138);
          }
          uint64_t v18 = *a1;
          uint64_t v19 = a1[6];
          int v22 = 134350080;
          uint64_t v23 = v18;
          __int16 v24 = 2050;
          *(void *)double v25 = v19;
          *(_WORD *)&v25[8] = 2050;
          *(double *)&_BYTE v25[10] = v3;
          *(_WORD *)&v25[18] = 2050;
          *(double *)&v25[20] = v4;
          *(_WORD *)&v25[28] = 2050;
          *(void *)&v25[30] = 0x403D000000000000LL;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  1LL,  "CLMM,%{public}.1lf,detected stuck,alongTrackRawToSnap,%{public}.1lf,deltaPosChange,%{public}.1lf,deltaSnapCh ange,%{public}.1lf,thresholdDiff,%{public}.1lf",  &v22,  52);
          double v21 = (uint8_t *)v20;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::StuckAtEndOfRoad::isStuckAtEndOfRoad(const BOOL)",  "%s\n",  v20);
          if (v21 != buf) {
            free(v21);
          }
        }
      }

      return 1LL;
    }
  }

  else
  {
    double v5 = v3 - v4;
  }

  if (v5 <= 5.0 || a2 == 0) {
    return 0LL;
  }
  if (qword_1019348B0 != -1) {
    dispatch_once(&qword_1019348B0, &stru_101877138);
  }
  double v11 = (os_log_s *)qword_1019348B8;
  if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v12 = *a1;
    int v13 = *((unsigned __int8 *)a1 + 56);
    *(_DWORD *)uint64_t buf = 134350080;
    uint64_t v27 = v12;
    __int16 v28 = 1026;
    *(_DWORD *)uint64_t v29 = v13;
    *(_WORD *)&v29[4] = 2050;
    *(double *)&v29[6] = v3;
    *(_WORD *)&v29[14] = 2050;
    *(double *)&v29[16] = v4;
    *(_WORD *)&v29[24] = 2050;
    *(void *)&v29[26] = 0x403D000000000000LL;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "CLMM, %{public}.1lf,isMovingAway,%{public}d,deltaPosChange,%{public}.1lf,deltaSnapChange,%{public}.1lf,thresholdDi ff,%{public}.1lf",  buf,  0x30u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101877138);
    }
    uint64_t v14 = *a1;
    int v15 = *((unsigned __int8 *)a1 + 56);
    int v22 = 134350080;
    uint64_t v23 = v14;
    __int16 v24 = 1026;
    *(_DWORD *)double v25 = v15;
    *(_WORD *)&_DWORD v25[4] = 2050;
    *(double *)&v25[6] = v3;
    *(_WORD *)&v25[14] = 2050;
    *(double *)&v25[16] = v4;
    *(_WORD *)&v25[24] = 2050;
    *(void *)&v25[26] = 0x403D000000000000LL;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMM, %{public}.1lf,isMovingAway,%{public}d,deltaPosChange,%{public}.1lf,deltaSnapChange,%{public}.1lf,thresholdDi ff,%{public}.1lf",  &v22,  48);
    __int128 v17 = (uint8_t *)v16;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMapMatcherCommon::StuckAtEndOfRoad::isStuckAtEndOfRoad(const BOOL)",  "%s\n",  v16);
    if (v17 != buf) {
      free(v17);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_100BDD004(double *a1, double a2, double a3)
{
  return vabdd_f64(a2, *a1) >= a3;
}

double *sub_100BDD018(double *result, double a2)
{
  if (*result >= 0.0)
  {
    int v2 = result + 1;
    if (vabdd_f64(result[1], a2) > 6.0) {
      *BOOL result = a2;
    }
  }

  else
  {
    *result++ = a2;
    int v2 = result;
  }

  *int v2 = a2;
  return result;
}

void sub_100BDD054(id a1)
{
  qword_1019348B8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MapMatcher");
}

void *sub_100BDD080(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = sub_100ABF03C(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100BDD0DC(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_100BDD0F8(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  double v9 = *(char **)result;
  if (0x8E38E38E38E38E39LL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      void *v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (a4 > 0x38E38E38E38E38ELL) {
      sub_100007008();
    }
    unint64_t v10 = 0x8E38E38E38E38E39LL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x1C71C71C71C71C7LL) {
      unint64_t v12 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v12 = v11;
    }
    BOOL result = sub_100ABF03C(v7, v12);
    uint64_t v14 = (char *)v7[1];
    int v13 = (void **)(v7 + 1);
    double v9 = v14;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      uint64_t v19 = v9;
      __int128 v20 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  int v13 = (void **)(result + 8);
  int v15 = (_BYTE *)*((void *)result + 1);
  if (0x8E38E38E38E38E39LL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  __int128 v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    double v9 = (char *)*v13;
  }

  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    uint64_t v19 = v9;
    __int128 v20 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v19, v20, v18);
  }

void sub_100BDD258(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }

  *(void *)uint64_t v7 = 0xBFF0000000000000LL;
  *(void *)&v9[120] = 0LL;
  *(_DWORD *)&v9[128] = 0;
  memset(&v9[80], 0, 34);
  memset(&v9[136], 0, 75);
  memset(&v9[216], 0, 56);
  memset(&v7[8], 0, 80);
  memset(v9, 0, 78);
  __int128 v8 = 0u;
  *(void *)&v9[272] = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + memset(v19, 0, 48) = *(_OWORD *)v7;
  *(_OWORD *)a1 = 0uLL;
  *(_OWORD *)(a1 + 16) = _Q0;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v7[48];
  *(_OWORD *)(a1 + 112) = *(_OWORD *)&v7[64];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v7[16];
  *(_OWORD *)(a1 + 80) = *(_OWORD *)&v7[32];
  std::string::operator=((std::string *)(a1 + 128), (const std::string *)&v7[80]);
  memcpy((void *)(a1 + 152), v9, 0x118uLL);
  if (SHIBYTE(v8) < 0) {
    operator delete(*(void **)&v7[80]);
  }
}

void sub_100BDD34C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BDD928( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BDDBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100BDDC94(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100BDDCC0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      _DWORD v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100BDDD5C(_Unwind_Exception *a1)
{
}

void sub_100BDDD74()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100BDDE00(_Unwind_Exception *a1)
{
}

uint64_t sub_100BDDE18(uint64_t a1, uint64_t a2)
{
  return sub_100BDDE24(a1, a2, (const char **)&off_101877178);
}

uint64_t sub_100BDDE24(uint64_t a1, uint64_t a2, const char **a3)
{
  uint64_t v5 = sub_1003B35F4(a1, a2);
  if (sub_1003C1048(v5))
  {
    sub_1003B59A0(a1, "Vertices", a3, 0LL, 0);
  }

  else
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    uint64_t v6 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Fence: No access to vertices DB", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101877238);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: No access to vertices DB",  v10,  2);
      double v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLFenceVertexDatabase::CLFenceVertexDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  return a1;
}

void sub_100BDDFE8(_Unwind_Exception *a1)
{
}

uint64_t sub_100BDE000(uint64_t a1, double **a2, int a3)
{
  if (qword_101934870 != -1) {
    dispatch_once(&qword_101934870, &stru_101877238);
  }
  uint64_t v6 = (os_log_s *)qword_101934878;
  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = ((char *)a2[1] - (char *)*a2) >> 4;
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240448;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a3;
    LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2050;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Fence: addVertices, key, %{public}d, num %{public}lu",  (uint8_t *)buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    uint64_t v32 = ((char *)a2[1] - (char *)*a2) >> 4;
    LODWORD(v41) = 67240448;
    HIDWORD(v41) = a3;
    __int16 v42 = 2050;
    *(void *)id v43 = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: addVertices, key, %{public}d, num %{public}lu",  &v41,  18);
    unint64_t v34 = (std::stringbuf::string_type *)v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)",  "%s\n",  v33);
    if (v34 != buf) {
      free(v34);
    }
  }

  if (a3 == -1)
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    __int128 v8 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Fence: attempting to add vertices to db without a key",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101877238);
      }
      LOWORD(v41) = 0;
      LODWORD(v39) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: attempting to add vertices to db without a key",  &v41,  v39);
      uint64_t v36 = (std::stringbuf::string_type *)v35;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)",  "%s\n",  v35);
      if (v36 != buf) {
        free(v36);
      }
    }

    return 0LL;
  }

  sub_10000CE18((uint64_t)&v41);
  unint64_t v10 = sub_10000CF44(&v43[6], (uint64_t)"INSERT INTO ", 12LL);
  uint64_t v11 = sub_10000CF44(v10, (uint64_t)"Vertices", 8LL);
  unint64_t v12 = sub_10000CF44(v11, (uint64_t)" (", 2LL);
  int v13 = sub_10000CF44(v12, (uint64_t)"Latitude", 8LL);
  uint64_t v14 = sub_10000CF44(v13, (uint64_t)", ", 2LL);
  int v15 = sub_10000CF44(v14, (uint64_t)"Longitude", 9LL);
  __int128 v16 = sub_10000CF44(v15, (uint64_t)", ", 2LL);
  uint64_t v17 = sub_10000CF44(v16, (uint64_t)"FenceForeignKey", 15LL);
  sub_10000CF44(v17, (uint64_t)") VALUES (?, ?, ?)", 18LL);
  std::stringbuf::str(buf, &v44);
  if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t v18 = buf;
  }
  else {
    size_t v18 = (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(a1, (char *)v18, v40);
  uint64_t v19 = v40[0];
  v40[0] = 0LL;
  double v21 = *a2;
  __int128 v20 = a2[1];
  while (1)
  {
    if (v21 == v20)
    {
      uint64_t v9 = 1LL;
      if (!v19) {
        goto LABEL_26;
      }
      goto LABEL_25;
    }

    double v23 = *v21;
    double v22 = v21[1];
    __int16 v24 = (sqlite3_stmt *)sub_100019240(v19);
    if (!sub_1003B7480(v24, 1, v23)) {
      break;
    }
    double v25 = (sqlite3_stmt *)sub_100019240(v19);
    if (!sub_1003B7480(v25, 2, v22)) {
      break;
    }
    double v26 = (sqlite3_stmt *)sub_100019240(v19);
    if (!sub_1003C28BC(v26, 3, a3)) {
      break;
    }
    uint64_t v27 = (sqlite3_stmt *)sub_100019240(v19);
    sub_1003BB2BC(a1, v27);
    v21 += 2;
  }

  if (qword_101934870 != -1) {
    dispatch_once(&qword_101934870, &stru_101877238);
  }
  uint64_t v30 = (os_log_s *)qword_101934878;
  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240192;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "#Warning Fence: Couldn't bind statement for adding vertices (key %{public}d",  (uint8_t *)buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    LODWORD(v40[0]) = 67240192;
    HIDWORD(v40[0]) = a3;
    LODWORD(v39) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "#Warning Fence: Couldn't bind statement for adding vertices (key %{public}d",  v40,  v39);
    double v38 = (std::stringbuf::string_type *)v37;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
  }

  double v31 = (sqlite3_stmt *)sub_100019240(v19);
  sqlite3_reset(v31);
  uint64_t v9 = 0LL;
  if (v19) {
LABEL_25:
  }
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
LABEL_26:
  *(uint64_t *)((char *)&v41
  *(void *)&v43[6] = v28;
  std::streambuf::~streambuf(&v44);
  std::ios::~ios(&v45);
  return v9;
}

void sub_100BDE670( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *__p, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8LL))(v54);
  }
  sub_1011F8850((uint64_t)&a13);
  _Unwind_Resume(a1);
}

BOOL sub_100BDE6CC(uint64_t a1, int a2)
{
  if (qword_101934870 != -1) {
    dispatch_once(&qword_101934870, &stru_101877238);
  }
  double v4 = (os_log_s *)qword_101934878;
  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240192;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Fence: Removing vertices, key, %{public}d",  (uint8_t *)buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    LODWORD(v25[0]) = 67240192;
    HIDWORD(v25[0]) = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: Removing vertices, key, %{public}d",  v25,  8);
    __int128 v20 = (std::stringbuf::string_type *)v19;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLFenceVertexDatabase::removeVertices(int)", "%s\n", v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  sub_10000CE18((uint64_t)v25);
  uint64_t v5 = sub_10000CF44(&v26, (uint64_t)"DELETE FROM ", 12LL);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)"Vertices", 8LL);
  uint64_t v7 = sub_10000CF44(v6, (uint64_t)" WHERE ", 7LL);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)"FenceForeignKey", 15LL);
  sub_10000CF44(v8, (uint64_t)"=?", 2LL);
  std::stringbuf::str(buf, &v27);
  if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v9 = buf;
  }
  else {
    uint64_t v9 = (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(a1, (char *)v9, v24);
  uint64_t v10 = v24[0];
  v24[0] = 0LL;
  uint64_t v11 = (sqlite3_stmt *)sub_100019240(v10);
  BOOL v12 = sub_1003C28BC(v11, 1, a2);
  if (v12)
  {
    int v13 = (sqlite3_stmt *)sub_100019240(v10);
    sub_1003BB2BC(a1, v13);
    else {
      uint64_t v14 = *(void *)(a1 + 88);
    }
    sub_1003C1EC0(a1, v14);
  }

  else
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    int v15 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#Warning Fence: Couldn't bind statement for deleting vertices (key %{public}d",  (uint8_t *)buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101877238);
      }
      LODWORD(v24[0]) = 67240192;
      HIDWORD(v24[0]) = a2;
      LODWORD(v23) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "#Warning Fence: Couldn't bind statement for deleting vertices (key %{public}d",  v24,  v23);
      double v22 = (std::stringbuf::string_type *)v21;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLFenceVertexDatabase::removeVertices(int)", "%s\n", v21);
      if (v22 != buf) {
        free(v22);
      }
    }

    __int128 v16 = (sqlite3_stmt *)sub_100019240(v10);
    sqlite3_reset(v16);
  }

  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  *(void *)((char *)v25
  uint64_t v26 = v17;
  std::streambuf::~streambuf(&v27);
  std::ios::~ios(&v28);
  return v12;
}

void sub_100BDEB38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *__p, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8LL))(v54);
  }
  sub_1011F8850((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100BDEB90(uint64_t a1, int a2, double **a3)
{
  a3[1] = *a3;
  sub_10000CE18((uint64_t)v49);
  uint64_t v6 = sub_10000CF44(&v50, (uint64_t)"SELECT ", 7LL);
  uint64_t v7 = sub_10000CF44(v6, (uint64_t)"Latitude", 8LL);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", ", 2LL);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)"Longitude", 9LL);
  uint64_t v10 = sub_10000CF44(v9, (uint64_t)" FROM ", 6LL);
  uint64_t v11 = sub_10000CF44(v10, (uint64_t)"Vertices", 8LL);
  BOOL v12 = sub_10000CF44(v11, (uint64_t)" WHERE ", 7LL);
  int v13 = sub_10000CF44(v12, (uint64_t)"FenceForeignKey", 15LL);
  sub_10000CF44(v13, (uint64_t)"=?", 2LL);
  std::stringbuf::str(&v53, &v51);
  if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v14 = &v53;
  }
  else {
    uint64_t v14 = (std::stringbuf::string_type *)v53.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(a1, (char *)v14, &v54);
  uint64_t v15 = v54;
  uint64_t v54 = 0LL;
  __int128 v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (!sub_1003C28BC(v16, 1, a2))
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    __int128 v20 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v53.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(v53.__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Fence: Couldn't bind foreignKey %{public}d",  (uint8_t *)&v53,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_19;
    }
    bzero(&v53, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    LODWORD(v54) = 67240192;
    HIDWORD(v54) = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: Couldn't bind foreignKey %{public}d",  &v54,  8);
    uint64_t v47 = (std::stringbuf::string_type *)v46;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLFenceVertexDatabase::getVertices(int, std::vector<CLClientLocationCoordinate> &)",  "%s\n",  v46);
    if (v47 == &v53) {
      goto LABEL_19;
    }
LABEL_58:
    free(v47);
LABEL_19:
    double v21 = (sqlite3_stmt *)sub_100019240(v15);
    sqlite3_reset(v21);
    sub_100BDF338((uint64_t)a3);
    goto LABEL_20;
  }

  uint64_t v17 = (sqlite3_stmt *)sub_100019240(v15);
  int v18 = sqlite3_step(v17);
  if ((v18 - 102) < 0xFFFFFFFE)
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    uint64_t v19 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v53.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_FAULT,  "Fence: Couldn't get vertices from database",  (uint8_t *)&v53,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_19;
    }
    bzero(&v53, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    LOWORD(v54) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: Couldn't get vertices from database",  &v54,  2);
    uint64_t v47 = (std::stringbuf::string_type *)v48;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLFenceVertexDatabase::getVertices(int, std::vector<CLClientLocationCoordinate> &)",  "%s\n",  v48);
    if (v47 == &v53) {
      goto LABEL_19;
    }
    goto LABEL_58;
  }

  while (v18 == 100)
  {
    double v25 = (sqlite3_stmt *)sub_100019240(v15);
    double v26 = sqlite3_column_double(v25, 0);
    std::stringbuf v27 = (sqlite3_stmt *)sub_100019240(v15);
    double v28 = sqlite3_column_double(v27, 1);
    double v29 = v28;
    double v31 = a3[1];
    unint64_t v30 = (unint64_t)a3[2];
    if ((unint64_t)v31 >= v30)
    {
      uint64_t v33 = *a3;
      uint64_t v34 = ((char *)v31 - (char *)*a3) >> 4;
      unint64_t v35 = v34 + 1;
      uint64_t v36 = v30 - (void)v33;
      if (v36 >> 3 > v35) {
        unint64_t v35 = v36 >> 3;
      }
      else {
        unint64_t v37 = v35;
      }
      if (v37)
      {
        double v38 = (char *)sub_100037038((uint64_t)(a3 + 2), v37);
        uint64_t v33 = *a3;
        double v31 = a3[1];
      }

      else
      {
        double v38 = 0LL;
      }

      uint64_t v39 = (double *)&v38[16 * v34];
      double *v39 = v26;
      v39[1] = v29;
      double v40 = v39;
      if (v31 != v33)
      {
        do
        {
          *((_OWORD *)v40 - 1) = *((_OWORD *)v31 - 1);
          v40 -= 2;
          v31 -= 2;
        }

        while (v31 != v33);
        uint64_t v33 = *a3;
      }

      uint64_t v32 = v39 + 2;
      *a3 = v40;
      a3[1] = v39 + 2;
      a3[2] = (double *)&v38[16 * v37];
      if (v33) {
        operator delete(v33);
      }
    }

    else
    {
      double *v31 = v26;
      v31[1] = v28;
      uint64_t v32 = v31 + 2;
    }

    a3[1] = v32;
    uint64_t v41 = (sqlite3_stmt *)sub_100019240(v15);
    int v18 = sqlite3_step(v41);
  }

  __int16 v42 = (sqlite3_stmt *)sub_100019240(v15);
  sqlite3_reset(v42);
  sub_100BDF338((uint64_t)a3);
  if (v18 != 101)
  {
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101877238);
    }
    id v43 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v53.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(v53.__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Fence: Error in retrieving vertices from database for foreignKey %{public}d",  (uint8_t *)&v53,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&v53, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101877238);
      }
      LODWORD(v54) = 67240192;
      HIDWORD(v54) = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: Error in retrieving vertices from database for foreignKey %{public}d",  &v54,  8);
      uint64_t v45 = (std::stringbuf::string_type *)v44;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLFenceVertexDatabase::getVertices(int, std::vector<CLClientLocationCoordinate> &)",  "%s\n",  v44);
      if (v45 != &v53) {
        free(v45);
      }
    }

void sub_100BDF2CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *__p, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
  }
  sub_1011F8850((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_100BDF338(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 16);
  double v4 = *(char **)a1;
  uint64_t v5 = *(_BYTE **)(a1 + 8);
  unint64_t v6 = (v5 - v4) >> 4;
  if (v6 < (v3 - (uint64_t)v4) >> 4)
  {
    if (v5 == v4)
    {
      uint64_t v11 = 0LL;
      uint64_t v9 = 16 * v6;
    }

    else
    {
      uint64_t v7 = (char *)sub_100037038(v2, v6);
      double v4 = *(char **)a1;
      __int128 v8 = *(char **)(a1 + 8);
      uint64_t v9 = (uint64_t)&v7[16 * v6];
      uint64_t v11 = &v7[16 * v10];
      if (v8 != *(char **)a1)
      {
        uint64_t v12 = v9;
        do
        {
          *(_OWORD *)(v12 - 16) = *((_OWORD *)v8 - 1);
          v12 -= 16LL;
          v8 -= 16;
        }

        while (v8 != v4);
        double v4 = *(char **)a1;
        goto LABEL_9;
      }
    }

    uint64_t v12 = v9;
LABEL_9:
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v11;
    if (v4) {
      operator delete(v4);
    }
  }

void sub_100BDF3FC(id a1)
{
  qword_101934878 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeoFencing");
}

void sub_100BDF678(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100BDF6FC(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  BOOL result = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *BOOL result = &off_101877268;
  return result;
}

void sub_100BDF720(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100C6AB50(a1);
  operator delete(v1);
}

void *sub_100BDF734@<X0>(uint64_t a1@<X8>)
{
  v15[0] = &off_101877308;
  v15[1] = sub_100BDFA4C;
  v15[2] = 0LL;
  __int128 v16 = v15;
  sub_1010DDBC0(v17, "kCLConnectionMessageKappaStatsAvailable");
  sub_10089D164((uint64_t)&v18, (uint64_t)v15);
  v13[0] = &off_101877308;
  v13[1] = sub_100BDFBA4;
  v13[2] = 0LL;
  uint64_t v14 = v13;
  sub_1010DDBC0(v19, "kCLConnectionMessageKappaSendAPCommand");
  sub_10089D164((uint64_t)&v20, (uint64_t)v13);
  v11[0] = &off_101877308;
  v11[1] = sub_100BE01BC;
  _DWORD v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v21, "kCLConnectionMessageSafetyAnomalyNotify");
  sub_10089D164((uint64_t)v22, (uint64_t)v11);
  sub_100BE0AA0(a1, (unsigned __int8 *)v17, 3LL);
  for (uint64_t i = 0LL; i != -21; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v22[i * 8 + 24];
    if (&v22[i * 8] == v3)
    {
      uint64_t v3 = &v22[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v21[i + 2]) < 0) {
      operator delete((void *)v21[i]);
    }
  }

  uint64_t v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v11;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v12)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v14;
  if (v14 == v13)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v13;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v14)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  BOOL result = v16;
  if (v16 == v15)
  {
    uint64_t v10 = 4LL;
    BOOL result = v15;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  else if (v16)
  {
    uint64_t v10 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  return result;
}

void sub_100BDF940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, char *a20, char a21)
{
  for (uint64_t i = 112LL; i != -56; i -= 56LL)
    sub_10026E430((uint64_t)(&a21 + i));
  uint64_t v23 = a12;
  if (a12 == &a9)
  {
    uint64_t v24 = 4LL;
    uint64_t v23 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_8;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_8:
  double v25 = a16;
  if (a16 == &a13)
  {
    uint64_t v26 = 4LL;
    double v25 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_13;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*(void *)v25 + 8 * v26))();
LABEL_13:
  std::stringbuf v27 = a20;
  if (a20 == &a17)
  {
    uint64_t v28 = 4LL;
    std::stringbuf v27 = &a17;
  }

  else
  {
    if (!a20) {
      goto LABEL_18;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*(void *)v27 + 8 * v28))();
LABEL_18:
  _Unwind_Resume(a1);
}

void sub_100BDFA4C(uint64_t a1, void *a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  v12[0] = *a2;
  v12[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  int v8 = sub_100BE04B0(a1, v12);
  int v9 = v8;
  if (v5)
  {
    uint64_t v10 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if (!v9) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }

  if (v8)
  {
LABEL_9:
    uint64_t v13 = CMAvailable;
    uint64_t v14 = &__kCFBooleanTrue;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v14,  &v13,  1LL);
    CLConnectionMessage::sendReply(*a2);
  }

void sub_100BDFB6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_100006BB8(exception_object);
}

void sub_100BDFBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  std::stringbuf v27 = *(CLConnectionMessage **)a2;
  uint64_t v28 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  char v8 = sub_100BE04B0(a1, (uint64_t *)&v27);
  char v9 = v8;
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v10 = (unint64_t *)&v5->__shared_owners_;
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if ((v9 & 1) == 0) {
      goto LABEL_40;
    }
  }

  else
  {
LABEL_8:
    if ((v8 & 1) == 0) {
      goto LABEL_40;
    }
  }

  Dictionary = (void *)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2);
  id v13 = [Dictionary objectForKeyedSubscript:CMKappaCmdKey];
  id v14 = [Dictionary objectForKeyedSubscript:CMKappaArgKey];
  unsigned int v15 = [v13 intValue];
  id v16 = [v14 intValue];
  if (qword_1019345E0 != -1) {
    dispatch_once(&qword_1019345E0, &stru_1018772B8);
  }
  uint64_t v17 = (os_log_s *)qword_1019345E8;
  if (os_log_type_enabled((os_log_t)qword_1019345E8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t buf = 67109376;
    unsigned int v37 = v15;
    __int16 v38 = 1024;
    int v39 = (int)v16;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "received AP command %d arg %d", buf, 0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345E0 != -1) {
      dispatch_once(&qword_1019345E0, &stru_1018772B8);
    }
    v33[0] = 67109376;
    v33[1] = v15;
    __int16 v34 = 1024;
    int v35 = (int)v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345E8,  1LL,  "received AP command %d arg %d",  v33,  14);
    uint64_t v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSafetyAnomalySubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

  id v18 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLKappaNotifier");
  uint64_t v19 = 2LL;
  switch(v15)
  {
    case 0u:
      [v18 startDem];
      goto LABEL_38;
    case 1u:
      [v18 stopDem];
      goto LABEL_38;
    case 2u:
      [v18 forceCompanionHeartbeat];
      goto LABEL_38;
    case 3u:
      [v18 remoteTimeout];
      goto LABEL_38;
    case 4u:
      [v18 collect:65793 isLocal:1];
      goto LABEL_38;
    case 5u:
      [v18 dontcollect:257 isLocal:1];
      goto LABEL_38;
    case 6u:
      objc_msgSend(v18, "simulateTriggerWithDelay:", v16, 2);
      goto LABEL_38;
    case 7u:
      goto LABEL_36;
    case 8u:
      uint64_t v19 = 4LL;
LABEL_36:
      [v18 simulateTriggerWithDelay:v16 forMode:v19];
      goto LABEL_38;
    case 9u:
      [v18 collect:0x101000001 isLocal:1];
      goto LABEL_38;
    case 0xAu:
      [v18 dontcollect:16777217 isLocal:1];
      goto LABEL_38;
    case 0xBu:
      [v18 collect:0x1010000000001 isLocal:1];
      goto LABEL_38;
    case 0xCu:
      [v18 dontcollect:0x10000000001 isLocal:1];
      goto LABEL_38;
    case 0xDu:
      [v18 collect:0x100000101000001 isLocal:1];
      goto LABEL_38;
    case 0xEu:
      [v18 dontcollect:0x100000001000001 isLocal:1];
LABEL_38:
      double v21 = *(CLConnectionMessage **)a2;
      uint64_t v29 = CMReturnCode;
      unint64_t v30 = &__kCFBooleanTrue;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL);
      break;
    default:
      if (qword_1019345E0 != -1) {
        dispatch_once(&qword_1019345E0, &stru_1018772B8);
      }
      uint64_t v20 = (os_log_s *)qword_1019345E8;
      if (os_log_type_enabled((os_log_t)qword_1019345E8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "invalid AP command", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345E0 != -1) {
          dispatch_once(&qword_1019345E0, &stru_1018772B8);
        }
        LOWORD(v33[0]) = 0;
        LODWORD(v26) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345E8,  1LL,  "invalid AP command",  v33,  v26,  v27,  v28);
        double v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSafetyAnomalySubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      double v21 = *(CLConnectionMessage **)a2;
      uint64_t v31 = CMReturnCode;
      uint64_t v32 = &__kCFBooleanFalse;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v32,  &v31,  1LL);
      break;
  }

  CLConnectionMessage::sendReply(v21);
LABEL_40:
}

void sub_100BE010C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BE01BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  v19[0] = *(void *)a2;
  v19[1] = (uint64_t)v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  char v7 = sub_100BE04B0(a1, v19);
  char v8 = v7;
  if (!v4) {
    goto LABEL_8;
  }
  char v9 = (unint64_t *)&v4->__shared_owners_;
  do
    unint64_t v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if ((v8 & 1) == 0) {
      return;
    }
  }

  else
  {
LABEL_8:
    if ((v7 & 1) == 0) {
      return;
    }
  }

  id v11 = objc_msgSend( objc_msgSend( (id)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2),  "objectForKeyedSubscript:",  CMSafetyAnomalyPropertiesKey),  "objectForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Guid"));
  if (qword_1019347D0 != -1) {
    dispatch_once(&qword_1019347D0, &stru_1018772D8);
  }
  uint64_t v12 = (os_log_s *)qword_1019347D8;
  if (os_log_type_enabled((os_log_t)qword_1019347D8, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = [v11 UTF8String];
    *(_DWORD *)uint64_t buf = 136315138;
    id v25 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "handleMessageSafetyAnomalyNotification, retrieved guid %s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347D0 != -1) {
      dispatch_once(&qword_1019347D0, &stru_1018772D8);
    }
    uint64_t v15 = qword_1019347D8;
    id v16 = [v11 UTF8String];
    int v22 = 136315138;
    id v23 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  0LL,  "handleMessageSafetyAnomalyNotification, retrieved guid %s",  (const char *)&v22);
    id v18 = (uint8_t *)v17;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSafetyAnomalySubscription::handleMessageSafetyAnomalyNotification(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v17);
    if (v18 != buf) {
      free(v18);
    }
  }

  objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLKappaNotifier"),  "forceTriggerIgneous:",  v11);
  id v14 = *(CLConnectionMessage **)a2;
  uint64_t v20 = CMReturnCode;
  double v21 = &__kCFBooleanTrue;
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v21,  &v20,  1LL);
  CLConnectionMessage::sendReply(v14);
}

void sub_100BE0494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100BE04B0(uint64_t a1, uint64_t *a2)
{
  char v4 = sub_100C6AC9C(a1);
  char v5 = v4;
  if (v26 < 0)
  {
    operator delete(*(void **)__p);
    if ((v5 & 1) != 0) {
      goto LABEL_3;
    }
LABEL_6:
    if (qword_1019345E0 != -1) {
      dispatch_once(&qword_1019345E0, &stru_1018772B8);
    }
    char v7 = (os_log_s *)qword_1019345E8;
    if (os_log_type_enabled((os_log_t)qword_1019345E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 24);
      *(_DWORD *)__int128 __p = 138477827;
      *(void *)&__p[4] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Client %{private}@ does not have appropriate motion entitlement.",  __p,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019345E0 != -1) {
        dispatch_once(&qword_1019345E0, &stru_1018772B8);
      }
      uint64_t v13 = *(void *)(a1 + 24);
      int v23 = 138477827;
      uint64_t v24 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345E8,  16LL,  "Client %{private}@ does not have appropriate motion entitlement.",  &v23,  12);
      uint64_t v15 = (char *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLSafetyAnomalySubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v14);
      if (v15 != __p) {
        free(v15);
      }
    }

    uint64_t v9 = *a2;
    uint64_t v21 = CMErrorMessage;
    int v22 = &off_1018D4208;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v22,  &v21,  1LL);
    CLConnectionMessage::sendReply(v9);
    return 0LL;
  }

  if ((v4 & 1) == 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (sub_100FE58D8()) {
    return 1LL;
  }
  if (qword_1019345E0 != -1) {
    dispatch_once(&qword_1019345E0, &stru_1018772B8);
  }
  unint64_t v10 = (os_log_s *)qword_1019345E8;
  if (os_log_type_enabled((os_log_t)qword_1019345E8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 __p = 138477827;
    *(void *)&__p[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Client %{private}@ is not available on this platform.",  __p,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019345E0 != -1) {
      dispatch_once(&qword_1019345E0, &stru_1018772B8);
    }
    uint64_t v16 = *(void *)(a1 + 24);
    int v23 = 138477827;
    uint64_t v24 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345E8,  16LL,  "Client %{private}@ is not available on this platform.",  &v23,  12);
    id v18 = (char *)v17;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLSafetyAnomalySubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v17);
    if (v18 != __p) {
      free(v18);
    }
  }

  uint64_t v12 = *a2;
  uint64_t v19 = CMErrorMessage;
  uint64_t v20 = &off_1018D4220;
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
  CLConnectionMessage::sendReply(v12);
  return 0LL;
}

void sub_100BE0884( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BE08A8(id a1)
{
  qword_1019345E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Kappa");
}

void sub_100BE08D4(id a1)
{
  qword_1019347D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Igneous");
}

__n128 sub_100BE0900(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101877308;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100BE093C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101877308;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BE0960(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100BE0968(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100BE09A4()
{
}

void sub_100BE09B0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  char v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  char v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    char v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  unint64_t v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    uint64_t v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100BE0A84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100BE0AA0(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100BE0B18(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100BE0B04(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100BE0B18(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  char v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100BE0D98(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  int v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    void *v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100BE0D80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100BE0D98@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100BE0E0C(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100BE0DF4(_Unwind_Exception *a1)
{
}

void *sub_100BE0E0C(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100BE0E64(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100BE0E80(void *a1, uint64_t a2)
{
  uint64_t result = 0LL;
  double Current = CFAbsoluteTimeGetCurrent();
  double v11 = Current + -8.0;
  uint64_t v10 = 0LL;
  float v9 = 0.0;
  __int128 v4 = (void *)(*(uint64_t (**)(void))(*(void *)*a1 + 16LL))(*a1);
  uint64_t v5 = operator new(0x30uLL);
  *uint64_t v5 = &off_101877398;
  v5[1] = &v11;
  _DWORD v5[2] = &Current;
  void v5[3] = (char *)&v10 + 4;
  v5[4] = &v10;
  void v5[5] = &v9;
  unint64_t v14 = v5;
  sub_1003A4D34(v4, (uint64_t)v13);
  uint64_t v6 = v14;
  if (v14 == v13)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = v13;
  }

  else
  {
    if (!v14) {
      goto LABEL_8;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_8:
  if (SHIDWORD(v10) < 6) {
    return 0LL;
  }
  else {
    return 1LL;
  }
}

void sub_100BE0FC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  unint64_t v19 = a17;
  if (a17 == v17)
  {
    uint64_t v20 = 4LL;
    unint64_t v19 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BE1000(_DWORD *a1)
{
  int v1 = *a1 - 4;
  else {
    return byte_10134F35E[v1];
  }
}

std::string *sub_100BE1028@<X0>(void *a1@<X0>, std::string *a2@<X8>)
{
  int v15 = 0;
  __int128 v4 = v34;
  for (unint64_t i = 7LL; i > 1; --i)
  {
    v4[8] = xmmword_10134F138;
    v4[9] = unk_10134F148;
    v4[10] = xmmword_10134F158;
    v4[11] = unk_10134F168;
    v4[4] = xmmword_10134F0F8;
    void v4[5] = unk_10134F108;
    v4[6] = xmmword_10134F118;
    v4[7] = unk_10134F128;
    _OWORD *v4 = xmmword_10134F0B8;
    v4[1] = unk_10134F0C8;
    void v4[2] = xmmword_10134F0D8;
    v4[3] = unk_10134F0E8;
    v4 += 12;
  }

  double Current = CFAbsoluteTimeGetCurrent();
  double v13 = Current + -8.0;
  uint64_t v6 = (void *)(*(uint64_t (**)(void))(*(void *)*a1 + 16LL))(*a1);
  uint64_t v7 = operator new(0x28uLL);
  void *v7 = &off_101877418;
  v7[1] = &v13;
  v7[2] = &Current;
  _OWORD v7[3] = &v15;
  v7[4] = v34;
  uint64_t v33 = v7;
  sub_1003A4D34(v6, (uint64_t)v32);
  unint64_t v8 = v33;
  if (v33 == v32)
  {
    uint64_t v9 = 4LL;
    unint64_t v8 = v32;
    goto LABEL_7;
  }

  if (v33)
  {
    uint64_t v9 = 5LL;
LABEL_7:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }

  sub_1010DDBC0(a2, "");
  unint64_t v10 = 0LL;
  double v11 = (double *)v34;
  do
  {
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v23 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf( __str,  0x100uLL,  "gpsStartTime%d,%.4f,gpsRawSpeed%d,%.4f,gpsDist%d,%.4f",  v10,  *v11,  v10,  v11[5],  v10,  v11[1]);
    uint64_t result = std::string::append(a2, __str);
    if (v10 <= 4) {
      uint64_t result = std::string::append(a2, ",");
    }
    ++v10;
    v11 += 24;
  }

  while (v10 != 6);
  return result;
}

void sub_100BE1230( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
}

__n128 sub_100BE1290(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &off_101877398;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_100BE12D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101877398;
  __n128 result = *(__n128 *)(a1 + 8);
  __int128 v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float sub_100BE1308(uint64_t a1, double *a2)
{
  double v2 = *a2;
  if (*a2 >= **(double **)(a1 + 8) && v2 <= **(double **)(a1 + 16))
  {
    __int128 v3 = *(int **)(a1 + 24);
    int v4 = *v3;
    unsigned int v5 = *v3 + 1;
    int *v3 = v5;
    if (v4 <= 2)
    {
      uint64_t v6 = (float **)(a1 + 32);
LABEL_7:
      uint64_t v7 = *v6;
      *(float *)&double v2 = a2[1] + *v7;
      float *v7 = *(float *)&v2;
      return *(float *)&v2;
    }

    if (v5 <= 6)
    {
      uint64_t v6 = (float **)(a1 + 40);
      goto LABEL_7;
    }
  }

  return *(float *)&v2;
}

uint64_t sub_100BE1378(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100BE13B4()
{
}

__n128 sub_100BE13C8(uint64_t a1)
{
  double v2 = (char *)operator new(0x28uLL);
  *(void *)double v2 = &off_101877418;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BE1408(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101877418;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_100BE1430(uint64_t a1, __int128 *a2)
{
  result.n128_u64[0] = *(void *)a2;
  if (*(double *)a2 >= **(double **)(a1 + 8) && result.n128_f64[0] <= **(double **)(a1 + 16))
  {
    int v3 = **(_DWORD **)(a1 + 24);
    if (v3 <= 5)
    {
      uint64_t v4 = *(void *)(a1 + 32) + 192LL * v3;
      __int128 v5 = *a2;
      __int128 v6 = a2[1];
      __int128 v7 = a2[3];
      *(_OWORD *)(v4 + 32) = a2[2];
      *(_OWORD *)(v4 + memset(v19, 0, 48) = v7;
      *(_OWORD *)uint64_t v4 = v5;
      *(_OWORD *)(v4 + 16) = v6;
      __int128 v8 = a2[4];
      __int128 v9 = a2[5];
      __int128 v10 = a2[7];
      *(_OWORD *)(v4 + 96) = a2[6];
      *(_OWORD *)(v4 + 112) = v10;
      *(_OWORD *)(v4 + 64) = v8;
      *(_OWORD *)(v4 + 80) = v9;
      __n128 result = (__n128)a2[8];
      __int128 v11 = a2[9];
      __int128 v12 = a2[11];
      *(_OWORD *)(v4 + 160) = a2[10];
      *(_OWORD *)(v4 + 176) = v12;
      *(__n128 *)(v4 + 1sub_100231C10(v1 + 28) = result;
      *(_OWORD *)(v4 + 144) = v11;
      ++**(_DWORD **)(a1 + 24);
    }
  }

  return result;
}

uint64_t sub_100BE14B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100BE14F0()
{
}

void sub_100BE179C(id a1)
{
  qword_10199AD50 = objc_alloc(&OBJC_CLASS___CLClientKeyPath_32);
  if (_os_feature_enabled_impl("CoreLocation", "cl_pula"))
  {
    strlcat((char *)(qword_10199AD50 + 8), (const char *)[(id)qword_10199AD48 UTF8String], 0x18uLL);
    strlcat((char *)(qword_10199AD50 + 8), ":", 0x18uLL);
  }

  strlcat((char *)(qword_10199AD50 + 8), "!:", 0x18uLL);
}

uint64_t sub_100BE2ECC(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    return ([(id)result isEqualToString:qword_10199AD40] & 1) != 0
        || ([v1 isEqualToString:qword_10199AD48] & 1) != 0
        || sub_100297480(v1);
  }

  return result;
}

void sub_100BE312C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BE320C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100BE4760( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BE4CE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1011F6920(v26);
  _Unwind_Resume(a1);
}

uint64_t sub_100BE5454(uint64_t a1)
{
  char v1 = *(_BYTE *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v4 = (unsigned __int8 *)(a1 + 9);
  do
  {
    uint64_t result = 2 * (result + v1);
    int v5 = *v4++;
    char v1 = v5;
  }

  while (v5);
  return result;
}

BOOL sub_100BE5484(uint64_t a1, uint64_t a2)
{
  return a1 == a2 || strcmp((const char *)(a1 + 8), (const char *)(a2 + 8)) == 0;
}

uint64_t sub_100BE54B8()
{
  if (qword_10199AD60 != -1) {
    dispatch_once(&qword_10199AD60, &stru_1018774A8);
  }
  return qword_10199AD68;
}

void sub_100BE54F8(id a1)
{
  qword_10199AD68 = -[NSPointerFunctions initWithOptions:]( objc_alloc(&OBJC_CLASS___NSPointerFunctions),  "initWithOptions:",  0LL);
  [(id)qword_10199AD68 setHashFunction:sub_100BE5454];
  _[(id)qword_10199AD68 setIsEqualFunction:sub_100BE5484];
}

uint64_t sub_100BE5544()
{
  if (qword_10199AD70 != -1) {
    dispatch_once(&qword_10199AD70, &stru_1018774C8);
  }
  return qword_10199AD78;
}

void sub_100BE5584(id a1)
{
  qword_10199AD78 = -[NSPointerFunctions initWithOptions:]( objc_alloc(&OBJC_CLASS___NSPointerFunctions),  "initWithOptions:",  0LL);
}

void sub_100BE55B0(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

BOOL sub_100BE55DC()
{
  return os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT);
}

BOOL sub_100BE55F0()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2440), OS_LOG_TYPE_INFO);
}

void sub_100BE5600()
{
  if (v5 >= 0) {
    uint64_t v0 = __p;
  }
  else {
    uint64_t v0 = (void **)__p[0];
  }
  char v1 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v0);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  qword_10199AD40 = (uint64_t)v1;
  sub_100FE36D4(__p);
  if (v5 >= 0) {
    double v2 = __p;
  }
  else {
    double v2 = (void **)__p[0];
  }
  int v3 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v2);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  qword_10199AD48 = (uint64_t)v3;
}

void sub_100BE56BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BE56DC(uint64_t a1, int a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)(a1 + 40) = 0LL;
  uint64_t v4 = a1 + 40;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 72) = 0LL;
  *(_OWORD *)(a1 + 88) = 0u;
  char v5 = (uint64_t *)(a1 + 88);
  __int128 v6 = (std::string *)(a1 + 96);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 120) = 0;
  sub_1002E4C3C(a1 + 128, "CMHealthColdStorageManager", 0LL, 1LL);
  *(_WORD *)(a1 + 1memset(v19, 0, 48) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  __int128 v7 = (char *)operator new(0x58uLL);
  *((void *)v7 + 1) = 0LL;
  *((void *)v7 + 2) = 0LL;
  *(void *)__int128 v7 = off_101877538;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 56) = 0u;
  *((void *)v7 + 9) = 0LL;
  *((void *)v7 + 10) = 0LL;
  *((void *)v7 + 6) = v7 + 56;
  *(void *)uint64_t buf = v7 + 24;
  *(void *)&uint8_t buf[8] = v7;
  sub_10005F550(v4, (__int128 *)buf);
  __int128 v8 = *(std::__shared_weak_count **)&buf[8];
  if (!*(void *)&buf[8]) {
    goto LABEL_5;
  }
  __int128 v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
  do
    unint64_t v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (v10)
  {
LABEL_5:
    if (!a2) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if (a2)
  {
LABEL_6:
    *(_BYTE *)(a1 + 120) = 1;
    *(_BYTE *)(*(void *)(a1 + 40) + 48LL) = 1;
    *(void *)(a1 + 80) = -[CMHealthColdStorageCloudKitManager initWithColdStorageManager:]( objc_alloc(&OBJC_CLASS___CMHealthColdStorageCloudKitManager),  "initWithColdStorageManager:",  a1);
  }

void sub_100BE5A9C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BE5AFC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 80);
    if (v2)
    {

      *(void *)(a1 + 80) = 0LL;
    }
  }

  sub_1000F0D38((void *)(a1 + 40));
  sub_1002E4CB0(a1 + 128);
  sub_100BE8878(a1 + 56, *(void **)(a1 + 64));
  sub_10000AE14(a1 + 40);
  return sub_100BE87B8(a1);
}

void sub_100BE5B74( uint64_t a1, uint64_t a2, std::string::size_type a3, unsigned __int8 a4, int a5, void *a6, unsigned __int8 a7)
{
  unsigned __int8 v41 = a4;
  id v40 = a6;
  unsigned __int8 v39 = a7;
  else {
    size_t v11 = *(void *)(a2 + 8);
  }
  p_p = &__p;
  sub_1000392EC((uint64_t)&__p, v11 + 1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v11)
  {
    else {
      uint64_t v13 = *(const void **)a2;
    }
    memmove(p_p, v13, v11);
  }

  *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v11) = 46;
  int v14 = *(char *)(a3 + 23);
  if (v14 >= 0) {
    uint64_t v15 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v15 = *(const std::string::value_type **)a3;
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v16 = *(void *)(a3 + 8);
  }
  uint64_t v17 = std::string::append(&__p, v15, v16);
  __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  std::string::size_type cap = v17->__r_.__value_.__l.__cap_;
  *(_OWORD *)unsigned int v37 = v18;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  else {
    std::string::size_type v19 = *(void *)a3;
  }
  __p.__r_.__value_.__r.__words[0] = v19;
  __int16 v42 = (std::string *)a1;
  int v35 = 1106247680;
  sub_100BE8948(&__p.__r_.__value_.__l.__data_, &v41, (uint64_t *)&v42, &v39, (float *)&v35, a2, (uint64_t *)&v40, &v36);
  else {
    std::string __p = *(std::string *)a3;
  }
  LOBYTE(v33) = v41;
  HIDWORD(v33) = a5;
  __int128 v34 = v36;
  if (*((void *)&v36 + 1))
  {
    __int128 v20 = (unint64_t *)(*((void *)&v36 + 1) + 8LL);
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  __int16 v42 = (std::string *)v37;
  __int128 v22 = sub_100BE8BBC(a1, (unsigned __int8 *)v37, (uint64_t)&unk_1012CF090, (__int128 **)&v42);
  std::string::size_type v23 = (void **)(v22 + 40);
  *(_OWORD *)std::string::size_type v23 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  uint64_t v24 = v33;
  *((void *)v22 + 7) = __p.__r_.__value_.__l.__cap_;
  __p.__r_.__value_.__s.__size_ = 0;
  __p.__r_.__value_.__s.__data_[0] = 0;
  *((void *)v22 + 8) = v24;
  sub_10005F550((uint64_t)(v22 + 72), &v34);
  __int128 v25 = (std::__shared_weak_count *)*((void *)&v34 + 1);
  if (*((void *)&v34 + 1))
  {
    uint64_t v26 = (unint64_t *)(*((void *)&v34 + 1) + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  if (v40)
  {
    sub_1010DDBC0(&__p, (char *)objc_msgSend(objc_msgSend(v40, "zoneName"), "UTF8String"));
    __int16 v42 = &__p;
    __int128 v28 = sub_100BE8F40( (uint64_t **)(a1 + 56),  (const void **)&__p.__r_.__value_.__l.__data_,  (uint64_t)&unk_1012CF090,  (_OWORD **)&v42);
    sub_1000F2F30((void *)v28 + 7, (uint64_t *)&v36);
  }

  __int128 v29 = (std::__shared_weak_count *)*((void *)&v36 + 1);
  if (*((void *)&v36 + 1))
  {
    __int128 v30 = (unint64_t *)(*((void *)&v36 + 1) + 8LL);
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  if (SHIBYTE(cap) < 0) {
    operator delete(v37[0]);
  }
}

void sub_100BE5E5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BE5EC8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100BE5F00(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = (unsigned __int16 *)(a1 + 144);
    __int128 v6 = (unsigned __int16 *)(a1 + 146);
    uint64_t v7 = 100LL;
    while (1)
    {
      int v8 = *((_DWORD *)v4 + 17);
      __int128 v9 = v6;
      if (v8)
      {
        if (v8 != 1) {
          goto LABEL_10;
        }
        __int128 v9 = v5;
      }

      unsigned int v10 = *v9;
      if (v10 >= 0x100 && v10 == 0)
      {
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        unint64_t v31 = v4 + 5;
        uint64_t v32 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v33 = v4 + 5;
          int v34 = *((_DWORD *)v4 + 17);
          *(_DWORD *)uint64_t buf = 67240450;
          LODWORD(v52[0]) = v34;
          WORD2(v52[0]) = 2082;
          *(void *)((char *)v52 + 6) = v33;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "[Manager] FitnessTracking disabled, preventing sync (source=%{public}d, table=%{public}s)",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v35 = *((_DWORD *)v4 + 17);
          LODWORD(__p) = 67240450;
          HIDWORD(__p) = v35;
          LOWORD(v5sub_100222B94(v46, (uint64_t)"CMHealthColdStorageManager.sync", 0) = 2082;
          *(void *)((char *)&v50 + 2) = v31;
          LODWORD(v43) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "[Manager] FitnessTracking disabled, preventing sync (source=%{public}d, table=%{public}s)",  &__p,  v43);
          unsigned int v37 = (uint8_t *)v36;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageManager::sync(ShouldInterruptCheck)",  "%s\n",  v36);
          if (v37 != buf) {
            free(v37);
          }
        }

        goto LABEL_63;
      }

void sub_100BE6640( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, id a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26)
{
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_1001BA1BC(&a21);
  _Unwind_Resume(a1);
}

void *sub_100BE66A4(void *result, uint64_t a2)
{
  if (*((_BYTE *)result + 120))
  {
    uint64_t result = (void *)result[10];
    if (result) {
      return _[result updateDeviceUnlockedState:a2];
    }
  }

  return result;
}

CKRecord *sub_100BE66C0(uint64_t a1, void *a2)
{
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v4 = sub_10008E8D0(a1 + 56, (const void **)__p);
  if (a1 + 64 != v4) {
    sub_1000F2F30(&v25, (uint64_t *)(v4 + 56));
  }
  if (v25 && (*(uint64_t (**)(uint64_t))(*(void *)(v25 + 72) + 40LL))(v25 + 72))
  {
    sub_100222B94(v24, (uint64_t)"CMHealthColdStorageManager.ckRecordForRecordID", 0);
    __int128 v22 = 0LL;
    uint64_t v23 = 0LL;
    sub_10023967C(v25, a2, &v23, &v22);
    if (!v23 || v22)
    {
      if (v23 && v22)
      {
        unint64_t v21 = 0LL;
        __int128 v9 = objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver);
        unsigned int v10 = -[NSKeyedUnarchiver initForReadingFromData:error:](v9, "initForReadingFromData:error:", v22, &v21);
        -[NSKeyedUnarchiver setRequiresSecureCoding:](v10, "setRequiresSecureCoding:", 1LL);
        uint64_t v7 = -[CKRecord initWithCoder:](objc_alloc(&OBJC_CLASS___CKRecord), "initWithCoder:", v10);
        -[NSKeyedUnarchiver finishDecoding](v10, "finishDecoding");
        if (v7)
        {
          id v11 = -[CKRecord encryptedValues](v7, "encryptedValues");
          objc_msgSend( v11,  "setObject:forKey:",  v23,  objc_msgSend( (id)(*(uint64_t (**)(uint64_t))(*(void *)(v25 + 72) + 40))(v25 + 72),  "dataFieldKey"));
        }

        else
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          double v13 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t buf = 138543362;
            uint64_t v32 = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "[Manager] Failed to decode record from system fields data: %{public}@",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_101877508);
            }
            int v29 = 138543362;
            uint64_t v30 = v21;
            __int128 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[Manager] Failed to decode record from system fields data: %{public}@",  &v29,  12);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "CKRecord *CMHealthColdStorageManager::ckRecordForRecordID(CKRecordID *)",  "%s\n",  v20);
          }
        }
      }

      else
      {
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        uint64_t v12 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 138412290;
          uint64_t v32 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "#warning: Requested CKRecord for a record ID that does not exist (%@)",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v29 = 138412290;
          uint64_t v30 = a2;
          unint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "#warning: Requested CKRecord for a record ID that does not exist (%@)",  &v29,  12);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CKRecord *CMHealthColdStorageManager::ckRecordForRecordID(CKRecordID *)",  "%s\n",  v19);
        }

        uint64_t v7 = 0LL;
      }
    }

    else
    {
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_101877508);
      }
      uint64_t v5 = (os_log_s *)qword_1019347B8;
      if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "[Manager] ckRecordForRecordID, no system field exists, creating a new record",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        LOWORD(v29) = 0;
        __int128 v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "[Manager] ckRecordForRecordID, no system field exists, creating a new record",  &v29,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CKRecord *CMHealthColdStorageManager::ckRecordForRecordID(CKRecordID *)",  "%s\n",  v18);
      }

      __int128 v6 = objc_alloc(&OBJC_CLASS___CKRecord);
      uint64_t v7 =  -[CKRecord initWithRecordType:recordID:]( v6,  "initWithRecordType:recordID:",  [(id)(*(uint64_t (**)(uint64_t))(*(void *)(v25 + 72) + 40))(v25 + 72) recordType],  a2);
      id v8 = -[CKRecord encryptedValues](v7, "encryptedValues");
      objc_msgSend( v8,  "setObject:forKey:",  v23,  objc_msgSend((id)(*(uint64_t (**)(uint64_t))(*(void *)(v25 + 72) + 40))(v25 + 72), "dataFieldKey"));
    }

    sub_1001BA1BC(v24);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  int v14 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  if (v28 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_100BE6CE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BE6D38(uint64_t a1, void *a2, void *a3)
{
  if (!a2) {
    return 0LL;
  }
  sub_1010DDBC0(__p, (char *)objc_msgSend(objc_msgSend(objc_msgSend(a2, "zoneID"), "zoneName"), "UTF8String"));
  uint64_t v12 = 0LL;
  double v13 = 0LL;
  uint64_t v6 = sub_10008E8D0(a1 + 56, (const void **)__p);
  if (a1 + 64 != v6) {
    sub_1000F2F30(&v12, (uint64_t *)(v6 + 56));
  }
  if (v12) {
    uint64_t v7 = sub_1002398B8(v12, a2, a3);
  }
  else {
    uint64_t v7 = 0LL;
  }
  id v8 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v15 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_100BE6E28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BE6E4C(CFAbsoluteTime *a1)
{
  uint64_t v1 = a1;
  a1[11] = CFAbsoluteTimeGetCurrent();
  v1 += 11;
  uint64_t v2 = sub_1002F8DDC();
  sub_1002AC820(v2, @"kColdStorageSyncStartTime", v1);
  uint64_t v3 = sub_1002F8DDC();
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 944LL))(v3);
  for (unint64_t i = (void *)*((void *)v1 - 9); i; unint64_t i = (void *)*i)
    uint64_t result = sub_100D8BAC8((void *)(i[9] + 72LL));
  return result;
}

uint64_t sub_100BE6EB0(uint64_t result)
{
  for (unint64_t i = *(void **)(result + 16); i; unint64_t i = (void *)*i)
    uint64_t result = sub_100239B8C(i[9]);
  return result;
}

void sub_100BE6EE0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1010DDBC0(__p, (char *)[a2 UTF8String]);
    uint64_t v7 = 0LL;
    id v8 = 0LL;
    uint64_t v3 = sub_10008E8D0(a1 + 56, (const void **)__p);
    if (a1 + 64 != v3) {
      sub_1000F2F30(&v7, (uint64_t *)(v3 + 56));
    }
    if (v7) {
      sub_100239B8C(v7);
    }
    uint64_t v4 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }

    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100BE6F98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BE6FBC(uint64_t a1, void *a2)
{
  uint64_t v8 = 0LL;
  __int128 v9 = 0LL;
  uint64_t v4 = sub_10008E8D0(a1 + 56, (const void **)__p);
  if (a1 + 64 != v4) {
    sub_1000F2F30(&v8, (uint64_t *)(v4 + 56));
  }
  if (v8) {
    sub_100239B98(v8, a2);
  }
  uint64_t v5 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v11 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100BE7084( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BE70A8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (!v1) {
    return 1LL;
  }
  LOBYTE(result) = 1;
  do
  {
    if ((result & 1) != 0) {
      uint64_t result = sub_100D8A92C(v1[9] + 72LL);
    }
    else {
      uint64_t result = 0LL;
    }
    uint64_t v1 = (void *)*v1;
  }

  while (v1);
  return result;
}

uint64_t sub_100BE70F4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_100BE7118(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t result = CKErrorIsCode(a2, 14LL);
    if ((_DWORD)result)
    {
      ++*(_DWORD *)(*(void *)(v3 + 40) + 8LL);
    }

    else
    {
      uint64_t result = CKErrorIsCode(a2, 11LL);
      if ((_DWORD)result)
      {
        ++*(_DWORD *)(*(void *)(v3 + 40) + 12LL);
      }

      else
      {
        uint64_t result = CKErrorIsCode(a2, 26LL);
        if ((_DWORD)result)
        {
          ++*(_DWORD *)(*(void *)(v3 + 40) + 16LL);
        }

        else
        {
          uint64_t result = CKErrorIsCode(a2, 112LL);
          unint64_t v4 = *(_DWORD **)(v3 + 40);
          if ((_DWORD)result) {
            ++v4[1];
          }
          else {
            ++*v4;
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100BE71D8(uint64_t a1)
{
  uint64_t v2 = a1 + 128;
  uint64_t v1 = *(void *)(a1 + 128);
  v45[1] = a1 + 128;
  (*(void (**)(uint64_t))(v1 + 16))(a1 + 128);
  __int16 v46 = 256;
  sub_100309AD8(0, (std::string *)__p);
  if (__p[23] >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = *(_BYTE **)__p;
  }
  unint64_t v4 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v5 = +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager");
  if (!-[NSFileManager fileExistsAtPath:](v5, "fileExistsAtPath:", v4))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    unint64_t v16 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "[Migration] No legacy database to migrate",  __p,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_101877508);
      }
      LOWORD(v47) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  1LL,  "[Migration] No legacy database to migrate",  &v47,  2);
      uint64_t v33 = (char *)v32;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v32);
      if (v33 != __p) {
        free(v33);
      }
    }

    goto LABEL_41;
  }

  uint64_t v44 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CMHealthColdStorageManager.preinitialization");
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_101877508);
  }
  unint64_t v6 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 138412290;
    *(void *)&__p[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[Migration] Migrating database at path %@",  __p,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    int v47 = 138412290;
    uint64_t v48 = v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[Migration] Migrating database at path %@",  &v47,  12);
    int v35 = (char *)v34;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v34);
    if (v35 != __p) {
      free(v35);
    }
  }

  sub_100309AD8(2, (std::string *)__p);
  if (__p[23] >= 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = *(_BYTE **)__p;
  }
  uint64_t v8 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  __int128 v9 = -[NSString UTF8String](v8, "UTF8String");
  uid_t v10 = getuid();
  gid_t v11 = getgid();
  if (!sub_100292C04(v9, v10, v11))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    __int128 v18 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
    {
      unint64_t v19 = -[NSString UTF8String](v8, "UTF8String");
      *(void *)std::string __p = 68289282LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(void *)&__p[20] = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:could not create path, path:%{public, location:escape_only}s}",  __p,  0x1Cu);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_101877508);
      }
    }

    __int128 v20 = (os_log_s *)qword_1019347B8;
    if (os_signpost_enabled((os_log_t)qword_1019347B8))
    {
      unint64_t v21 = -[NSString UTF8String](v8, "UTF8String");
      *(void *)std::string __p = 68289282LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(void *)&__p[20] = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "could not create path",  "{msg%{public}.0s:could not create path, path:%{public, location:escape_only}s}",  __p,  0x1Cu);
    }

LABEL_87:
    uint64_t v17 = 0LL;
    goto LABEL_88;
  }

  chmod(-[NSString UTF8String](v8, "UTF8String"), 0x1EFu);
  sub_100309AD8(1, (std::string *)__p);
  if (__p[23] >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = *(_BYTE **)__p;
  }
  double v13 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v12);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  v45[0] = 0LL;
  if (!-[NSFileManager fileExistsAtPath:](v5, "fileExistsAtPath:", v13))
  {
    for (unint64_t i = 0LL; ; ++i)
    {
      uint64_t v23 = (NSString *)[&off_1018D70C0 objectAtIndex:i];
      if (-[NSFileManager moveItemAtPath:toPath:error:]( v5,  "moveItemAtPath:toPath:error:",  -[NSString stringByAppendingString:](v4, "stringByAppendingString:", v23),  -[NSString stringByAppendingString:](v13, "stringByAppendingString:", v23),  v45))
      {
        chmod( -[NSString UTF8String]( -[NSString stringByAppendingString:](v13, "stringByAppendingString:", v23),  "UTF8String"),  0x1EFu);
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        uint64_t v24 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 138543875;
          *(void *)&__p[4] = v23;
          *(_WORD *)&_BYTE __p[12] = 2113;
          *(void *)&__p[14] = v4;
          *(_WORD *)&__p[22] = 2113;
          *(void *)&__p[24] = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "[Migration] Successfully moved db%{public}@ from %{private}@ to %{private}@",  __p,  0x20u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v47 = 138543875;
          uint64_t v48 = v23;
          __int16 v49 = 2113;
          __int128 v50 = v4;
          __int16 v51 = 2113;
          uint64_t v52 = v13;
          LODWORD(v43) = 32;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[Migration] Successfully moved db%{public}@ from %{private}@ to %{private}@",  &v47,  v43);
          uint64_t v26 = (char *)v25;
          sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v25);
LABEL_71:
          if (v26 != __p) {
            free(v26);
          }
          continue;
        }
      }

      else
      {
        if (!i)
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v29 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 138412802;
            *(void *)&__p[4] = v45[0];
            *(_WORD *)&_BYTE __p[12] = 2112;
            *(void *)&__p[14] = v4;
            *(_WORD *)&__p[22] = 2112;
            *(void *)&__p[24] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "[Migration] Unable to move root file, error: %@, move from %@ to %@",  __p,  0x20u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_101877508);
            }
            int v47 = 138412802;
            uint64_t v48 = (NSString *)v45[0];
            __int16 v49 = 2112;
            __int128 v50 = v4;
            __int16 v51 = 2112;
            uint64_t v52 = v13;
            LODWORD(v43) = 32;
            _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[Migration] Unable to move root file, error: %@, move from %@ to %@",  &v47,  v43);
            unsigned __int8 v41 = (char *)v40;
            sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v40);
            if (v41 != __p) {
              free(v41);
            }
          }

          if (-[NSFileManager removeItemAtPath:error:](v5, "removeItemAtPath:error:", v13, v45)) {
            goto LABEL_86;
          }
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          uint64_t v30 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 138412290;
            *(void *)&__p[4] = v45[0];
            _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "[Migration] Unable to remove corrupted mobile file, error: %@",  __p,  0xCu);
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_86;
          }
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v47 = 138412290;
          uint64_t v48 = (NSString *)v45[0];
          LODWORD(v43) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[Migration] Unable to remove corrupted mobile file, error: %@",  &v47,  v43);
          unsigned __int8 v39 = (char *)v42;
          sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v42);
          if (v39 == __p) {
            goto LABEL_86;
          }
          goto LABEL_112;
        }

        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        unint64_t v27 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 138412546;
          *(void *)&__p[4] = v23;
          *(_WORD *)&_BYTE __p[12] = 2112;
          *(void *)&__p[14] = v45[0];
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "[Migration] #Warning: Unable to move %@, error: %@",  __p,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v47 = 138412546;
          uint64_t v48 = v23;
          __int16 v49 = 2112;
          __int128 v50 = (NSString *)v45[0];
          LODWORD(v43) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[Migration] #Warning: Unable to move %@, error: %@",  &v47,  v43);
          uint64_t v26 = (char *)v28;
          sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v28);
          goto LABEL_71;
        }
      }
    }
  }

  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_101877508);
  }
  int v14 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "[Migration] DB exists in two locations. Deleting root",  __p,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    LOWORD(v47) = 0;
    LODWORD(v43) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  17LL,  "[Migration] DB exists in two locations. Deleting root",  &v47,  v43);
    unsigned int v37 = (char *)v36;
    sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v36);
    if (v37 != __p) {
      free(v37);
    }
  }

  -[NSFileManager removeItemAtPath:error:](v5, "removeItemAtPath:error:", v4, v45);
  if (v45[0])
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    char v15 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 138412290;
      *(void *)&__p[4] = v45[0];
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "[ColdStorage] Unable to delete mobile cold storage directory, error: %@",  __p,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_101877508);
      }
      int v47 = 138412290;
      uint64_t v48 = (NSString *)v45[0];
      LODWORD(v43) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[ColdStorage] Unable to delete mobile cold storage directory, error: %@",  &v47,  v43);
      unsigned __int8 v39 = (char *)v38;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CMHealthColdStorageManager::preinitialization()", "%s\n", v38);
      if (v39 != __p) {
LABEL_112:
      }
        free(v39);
    }

void sub_100BE80A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
}

void sub_100BE8138(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 144) = a2 | 0x100;
  if ((a2 & 1) == 0) {
    sub_100BE8150(a1, 1);
  }
}

void sub_100BE8150(uint64_t a1, int a2)
{
  for (unint64_t i = *(uint64_t **)(a1 + 16); i; unint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 17) == a2)
    {
      unint64_t v4 = i + 5;
      if (sub_100D8A92C(i[9] + 72))
      {
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        uint64_t v5 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v6 = i + 5;
          *(_DWORD *)uint64_t buf = 136446466;
          unint64_t v19 = v6;
          __int16 v20 = 1026;
          int v21 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[Manager] Deleting Table: %{public}s, source: %{public}d",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v14 = 136446466;
          char v15 = v4;
          __int16 v16 = 1026;
          int v17 = a2;
          LODWORD(v13) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[Manager] Deleting Table: %{public}s, source: %{public}d",  &v14,  v13);
          uid_t v10 = (uint8_t *)v9;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CMHealthColdStorageManager::deleteTablesBySource(SourceDevice)",  "%s\n",  v9);
          if (v10 != buf) {
            free(v10);
          }
        }

        sub_100D8BAC8((void *)(i[9] + 72));
      }

      else
      {
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_101877508);
        }
        unint64_t v7 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = i + 5;
          *(_DWORD *)uint64_t buf = 136446466;
          unint64_t v19 = v8;
          __int16 v20 = 1026;
          int v21 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "[Manager] Database inaccessible, could not delete table: %{public}s, source: %{public}d",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_101877508);
          }
          int v14 = 136446466;
          char v15 = v4;
          __int16 v16 = 1026;
          int v17 = a2;
          LODWORD(v13) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[Manager] Database inaccessible, could not delete table: %{public}s, source: %{public}d",  &v14,  v13);
          uint64_t v12 = (uint8_t *)v11;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CMHealthColdStorageManager::deleteTablesBySource(SourceDevice)",  "%s\n",  v11);
          if (v12 != buf) {
            free(v12);
          }
        }
      }
    }
  }

void sub_100BE84DC(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 146) = a2 | 0x100;
  if ((a2 & 1) == 0) {
    sub_100BE8150(a1, 0);
  }
}

id *sub_100BE84F4(uint64_t a1)
{
  uint64_t v13 = 0LL;
  int v14 = 0LL;
  uint64_t v2 = (uint64_t *)(a1 + 16);
  while (1)
  {
    uint64_t v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    if (*((_BYTE *)v2 + 64))
    {
      sub_1000F2F30(&v13, v2 + 9);
      if (v13 && (sub_100D8A92C(v13 + 72) & 1) != 0)
      {
        if (!*(_BYTE *)(a1 + 148) && sub_100236548(v13, "VO2MaxInputHistory"))
        {
          *(_BYTE *)(a1 + 1memset(v19, 0, 48) = 1;
          uint64_t v3 = sub_1002F8DDC();
          sub_1002AB464(v3, @"HealthColdStorageVO2MaxDeletionComplete", (_BYTE *)(a1 + 148));
          uint64_t v4 = sub_1002F8DDC();
          (*(void (**)(uint64_t))(*(void *)v4 + 944LL))(v4);
        }

        *(_BYTE *)(a1 + 149) = sub_10023AA60(v13);
        goto LABEL_15;
      }

      break;
    }
  }

  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_101877508);
  }
  uint64_t v5 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[Manager] #warning: Cannot run database clean up, db is inaccessible",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_101877508);
    }
    v12[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[Manager] #warning: Cannot run database clean up, db is inaccessible",  v12,  2);
    gid_t v11 = (uint8_t *)v10;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CMHealthColdStorageManager::cleanUpDatabase()", "%s\n", v10);
    if (v11 != buf) {
      free(v11);
    }
  }

void sub_100BE8764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_1001BA1BC((id *)va1);
  _Unwind_Resume(a1);
}

void sub_100BE878C(id a1)
{
  qword_1019347B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
}

uint64_t sub_100BE87B8(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100BE87F0(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_100BE882C((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void sub_100BE882C(uint64_t a1)
{
}

void sub_100BE8878(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100BE8878(a1, *a2);
    sub_100BE8878(a1, a2[1]);
    sub_100BE88C0((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_100BE88C0(uint64_t a1)
{
}

void sub_100BE88FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101877538;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BE8910(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101877538;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100BE8934(uint64_t a1)
{
}

void *sub_100BE8948@<X0>( char **a1@<X1>, unsigned __int8 *a2@<X2>, uint64_t *a3@<X3>, unsigned __int8 *a4@<X4>, float *a5@<X5>, uint64_t a6@<X6>, uint64_t *a7@<X7>, void *a8@<X8>)
{
  __int16 v16 = operator new(0x188uLL);
  uint64_t result = sub_100BE89E8(v16, a1, a2, a3, a4, a5, a6, a7);
  *a8 = v16 + 3;
  a8[1] = v16;
  return result;
}

void sub_100BE89D4(_Unwind_Exception *a1)
{
}

void *sub_100BE89E8( void *a1, char **a2, unsigned __int8 *a3, uint64_t *a4, unsigned __int8 *a5, float *a6, uint64_t a7, uint64_t *a8)
{
  a1[2] = 0LL;
  *a1 = off_101877588;
  a1[1] = 0LL;
  sub_100BE8AAC((uint64_t)&v10, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_100BE8A50(_Unwind_Exception *a1)
{
}

void sub_100BE8A64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101877588;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BE8A78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101877588;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100BE8A9C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void sub_100BE8AAC( uint64_t a1, uint64_t a2, char **a3, unsigned __int8 *a4, uint64_t *a5, unsigned __int8 *a6, float *a7, uint64_t a8, uint64_t *a9)
{
  gid_t v11 = *a3;
  int v12 = *a4;
  uint64_t v13 = *a5;
  int v14 = *a6;
  float v15 = *a7;
  uint64_t v16 = *a9;
  sub_1010DDBC0(v19, "startTime");
  sub_1010DDBC0(__p, "id");
  sub_1002349F0(a2, v11, v12 != 0, v13, v14 != 0, a8, v16, (__int128 *)v19, v15, (__int128 *)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v20 < 0) {
    operator delete(v19[0]);
  }
}

void sub_100BE8B88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_100BE8BBC(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    int v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (unint64_t i = *v14; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }

  sub_100BE8E54(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100019E10(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }

  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8LL);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }

      else
      {
        v24 &= v11 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }

  unint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0LL;
  ++*v8;
  sub_100BE8EFC((uint64_t)v26, 0LL);
  return i;
}

void sub_100BE8E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

double sub_100BE8E54@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = (char *)operator new(0x58uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(void *)uint64_t v8 = 0LL;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = v8 + 16;
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    sub_1010DD48C(v9, *(void **)v10, *((void *)v10 + 1));
  }

  else
  {
    __int128 v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)unint64_t v9 = v11;
  }

  double result = 0.0;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100BE8EE4(_Unwind_Exception *a1)
{
}

void sub_100BE8EFC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100BE882C((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

_OWORD *sub_100BE8F40(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_1000227E8((uint64_t)a1, &v14, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x48uLL);
    v12[1] = a1 + 1;
    unint64_t v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0LL;
    v9[2] = 0LL;
    *unint64_t v9 = 0LL;
    *((void *)v7 + 7) = 0LL;
    *((void *)v7 + 8) = 0LL;
    char v13 = 1;
    sub_1000085FC(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0LL;
    sub_100BE9000((uint64_t)v12, 0LL);
  }

  return v7;
}

void sub_100BE9000(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100BE88C0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_100BE9994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  if (a61 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

CLCppContainer *sub_100BE9A58(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = v2;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_1010DD48C(v2, *(void **)a1, *(void *)(a1 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
    v2[2] = *(void *)(a1 + 16);
  }

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100BEA2DC;
  void v5[3] = &unk_10181D3D0;
  v5[4] = v3;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v3,  v5,  0LL,  24LL);
}

void sub_100BE9AFC(_Unwind_Exception *a1)
{
}

void sub_100BE9E2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *__p, uint64_t a41, int a42, __int16 a43, char a44, char a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,char a58)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BEA2B0(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_100BEA2DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    operator delete((void *)v1);
  }

uint64_t sub_100BEA714(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        LODWORD(v6) = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v6) = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((unsigned __int16)(v6 >> 3))
    {
      case 1u:
        String = (void *)PBReaderReadString(a2);

        *(void *)(a1 + 24) = String;
        goto LABEL_35;
      case 2u:
        *(_BYTE *)(a1 + 40) |= 1u;
        unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v15 <= 0xFFFFFFFFFFFFFFF7LL && v15 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v16 = 0LL;
        }

        uint64_t v19 = 8LL;
        goto LABEL_34;
      case 3u:
        *(_BYTE *)(a1 + 40) |= 2u;
        unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v17 <= 0xFFFFFFFFFFFFFFF7LL && v17 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v16 = 0LL;
        }

        uint64_t v19 = 16LL;
LABEL_34:
        *(void *)(a1 + v19) = v16;
        goto LABEL_35;
      case 4u:
        float v18 = objc_alloc_init(&OBJC_CLASS___TRANSITPbMacModePair);
        [(id)a1 addMacModes:v18];

        if (PBReaderPlaceMark(a2, v20) && (sub_100EDA4D8((uint64_t)v18, a2) & 1) != 0)
        {
          PBReaderRecallMark(a2, v20);
LABEL_35:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0LL;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_35;
    }
  }

void sub_100BEB1B4(uint64_t a1, void *a2, double a3)
{
  if (sub_100B5C374())
  {
    if (a3 >= 0.1) {
      double v6 = a3;
    }
    else {
      double v6 = 0.1;
    }
    if (*(void *)(a1 + 240)) {
      sub_100BEB560(a1);
    }
    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_1018775E8);
    }
    uint64_t v7 = (os_log_s *)qword_101934798;
    if (os_log_type_enabled((os_log_t)qword_101934798, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 138543618;
      id v22 = [a2 identifier];
      __int16 v23 = 2050;
      double v24 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[CLInertialOdometryNotifierClient] %{public}@ requesting updates with interval: %{public}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934790 != -1) {
        dispatch_once(&qword_101934790, &stru_1018775E8);
      }
      uint64_t v12 = qword_101934798;
      int v17 = 138543618;
      id v18 = [a2 identifier];
      __int16 v19 = 2050;
      double v20 = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  0LL,  "[CLInertialOdometryNotifierClient] %{public}@ requesting updates with interval: %{public}f",  &v17,  22);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLInertialOdometryNotifierClient::startOdometryUpdates(CLSilo *, CFTimeInterval)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }

    unint64_t v8 = operator new(0x38uLL);
    sub_100BEBA80(v8, a2, (uint64_t)sub_100BEB76C, a1, 0LL);
    uint64_t v9 = *(void *)(a1 + 240);
    *(void *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
    uint64_t v10 = sub_100B5C374();
    sub_1006DCB40(v10, 0, *(void *)(a1 + 240), v6);
  }

  else
  {
    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_1018775E8);
    }
    int v11 = (os_log_s *)qword_101934798;
    if (os_log_type_enabled((os_log_t)qword_101934798, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't start updates",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934790 != -1) {
        dispatch_once(&qword_101934790, &stru_1018775E8);
      }
      LOWORD(v17) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934798,  16LL,  "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't start updates",  &v17,  2);
      uint64_t v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLInertialOdometryNotifierClient::startOdometryUpdates(CLSilo *, CFTimeInterval)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

void sub_100BEB544(_Unwind_Exception *a1)
{
}

void sub_100BEB560(uint64_t a1)
{
  if (sub_100B5C374())
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + memset(v19, 0, 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 1sub_100231C10(v1 + 28) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    if (*(void *)(a1 + 240))
    {
      uint64_t v2 = sub_100B5C374();
      sub_1006DD2A0(v2, 0, *(void *)(a1 + 240));
      uint64_t v3 = *(void *)(a1 + 240);
      *(void *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
      }
    }
  }

  else
  {
    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_1018775E8);
    }
    char v4 = (os_log_s *)qword_101934798;
    if (os_log_type_enabled((os_log_t)qword_101934798, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't stop updates",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934790 != -1) {
        dispatch_once(&qword_101934790, &stru_1018775E8);
      }
      v7[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934798,  16LL,  "[CLInertialOdometryNotifierClient] InertialOdometry notifier is not available, can't stop updates",  v7,  2);
      double v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLInertialOdometryNotifierClient::stopOdometryUpdates()", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

void sub_100BEB76C(_OWORD *a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a2 + 96) = v2;
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a2 + 224);
  __int128 v3 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a2 + 32) = v3;
  __int128 v4 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a2 + memset(v19, 0, 48) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a2 + 64) = v4;
  __int128 v6 = a1[3];
  __int128 v5 = a1[4];
  __int128 v7 = a1[6];
  *(_OWORD *)(a2 + 208) = a1[5];
  *(_OWORD *)(a2 + 224) = v7;
  *(_OWORD *)(a2 + 176) = v6;
  *(_OWORD *)(a2 + 192) = v5;
  __int128 v9 = a1[1];
  __int128 v8 = a1[2];
  *(_OWORD *)(a2 + 1sub_100231C10(v1 + 28) = *a1;
  *(_OWORD *)(a2 + 144) = v9;
  *(_OWORD *)(a2 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
  if (*(_BYTE *)(a2 + 8)) {
    sub_100BEB7C8(a2);
  }
  else {
    *(_BYTE *)(a2 + 8) = 1;
  }
}

void sub_100BEB7C8(uint64_t a1)
{
  v10[0] = *(void *)(a1 + 128);
  memset(&v10[1], 0, 15);
  float32x2_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unint64_t v1 = *(void *)(a1 + 24);
  if (v1 >= *(void *)(a1 + 208))
  {
    if (v1 >= *(void *)(a1 + 168))
    {
      for (uint64_t i = 0LL; i != 3; ++i)
        *((_BYTE *)&v10[2] + i + 4) = *(void *)(a1 + 184 + 8 * i) <= v1;
      float v6 = 0.0;
      float v7 = 0.0;
      if (BYTE4(v10[2])) {
        float v7 = *(float *)(a1 + 144) - *(float *)(a1 + 32);
      }
      *(float *)&v10[1] = v7;
      if (BYTE5(v10[2])) {
        float v6 = *(float *)(a1 + 148) - *(float *)(a1 + 36);
      }
      *((float *)&v10[1] + 1) = v6;
      if (BYTE6(v10[2])) {
        float v8 = *(float *)(a1 + 152) - *(float *)(a1 + 40);
      }
      else {
        float v8 = 0.0;
      }
      *(float *)&v10[2] = v8;
    }

    if (v1 >= *(void *)(a1 + 176))
    {
      float32x2_t v11 = vsub_f32(*(float32x2_t *)(a1 + 156), *(float32x2_t *)(a1 + 44));
      *(float *)&uint64_t v12 = *(float *)(a1 + 164) - *(float *)(a1 + 52);
      WORD2(v12) = 257;
      BYTE6(v12) = 1;
    }

    HIBYTE(v12) = *(_BYTE *)(a1 + 236);
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 16LL))(a1, v10);
  }

  else
  {
    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_1018775E8);
    }
    __int128 v2 = (os_log_s *)qword_101934798;
    if (os_log_type_enabled((os_log_t)qword_101934798, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "DeviceMotion has reinitialized, reference frame has changed",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934790 != -1) {
        dispatch_once(&qword_101934790, &stru_1018775E8);
      }
      __int16 v9 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934798,  16LL,  "DeviceMotion has reinitialized, reference frame has changed",  &v9,  2);
      __int128 v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLInertialOdometryNotifierClient::sendOdometryToClient()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }
  }

void sub_100BEBA54(id a1)
{
  qword_101934798 = (uint64_t)os_log_create("com.apple.locationd.Motion", "InertialOdometry");
}

void *sub_100BEBA80(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a1 = off_1018A2210;
  id v9 = a5;
  *a1 = off_101877618;
  a1[1] = v9;
  a1[2] = a3;
  a1[3] = a4;
  id v10 = a2;
  a1[5] = 0LL;
  a1[4] = v10;
  a1[6] = 0LL;
  v14[0] = 0LL;
  v14[1] = v14;
  void v14[2] = 0x2020000000LL;
  char v15 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472LL;
  aBlock[2] = sub_100BEBBB4;
  aBlock[3] = &unk_10182EFC8;
  aBlock[4] = v14;
  a1[5] = _Block_copy(aBlock);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  void v12[2] = sub_100BEBBC8;
  _OWORD v12[3] = &unk_10182EFF0;
  v12[4] = v14;
  a1[6] = _Block_copy(v12);
  _Block_object_dispose(v14, 8);
  return a1;
}

void sub_100BEBB8C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BEBBB4(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  return result;
}

BOOL sub_100BEBBC8(uint64_t a1)
{
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void sub_100BEBBE4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100BEBEBC(a1);
  operator delete(v1);
}

id sub_100BEBBF8(void *a1, int a2, void *__src, unint64_t a4)
{
  if (a4 >= 0x70) {
    size_t v8 = 112LL;
  }
  else {
    size_t v8 = a4;
  }
  memcpy(__dst, __src, v8);
  if (a4 >= 0x71)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101877658);
    }
    id v9 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 136315906;
      unint64_t v37 = 0x800000010134F45FLL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v38 = 2048;
      uint64_t v39 = 112LL;
      __int16 v40 = 2048;
      unint64_t v41 = a4;
      __int16 v42 = 1024;
      int v43 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101877658);
      }
      int v28 = 136315906;
      unint64_t v29 = 0x800000010134F45FLL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v30 = 2048;
      uint64_t v31 = 112LL;
      __int16 v32 = 2048;
      unint64_t v33 = a4;
      __int16 v34 = 1024;
      int v35 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  (const char *)&v28,  38,  v17,  LODWORD(v18[0]));
      uint64_t v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMotionNotifier::SiloDispatcher<CLInertialOdometryNotifier::InertialOdometryData>::dispatchData(in t, const void *, size_t) [T = CLInertialOdometryNotifier::InertialOdometryData]",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

  uint64_t v11 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v12 = a1[6];
  char v13 = (void *)a1[4];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  uint64_t v18[2] = sub_100BEBF14;
  _OWORD v18[3] = &unk_101843460;
  v18[4] = v12;
  v18[5] = v11;
  __int128 v23 = __dst[4];
  __int128 v24 = __dst[5];
  __int128 v25 = __dst[6];
  __int128 v19 = __dst[0];
  __int128 v20 = __dst[1];
  __int128 v22 = __dst[3];
  __int128 v21 = __dst[2];
  uint64_t v26 = v10;
  return [v13 async:v18];
}

uint64_t sub_100BEBEBC(uint64_t a1)
{
  *(void *)a1 = off_101877618;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));

  return sub_1011C07F8(a1);
}

uint64_t sub_100BEBF14(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, void))(a1 + 40))(a1 + 48, *(void *)(a1 + 160));
  }
  return result;
}

void sub_100BEBF58(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void *sub_100BEBF84(void *a1, _OWORD *a2)
{
  __int128 v4 = sub_100C0099C(a1);
  void *v4 = &off_101877688;
  *((_OWORD *)v4 + 7) = *a2;
  __int128 v5 = a2[1];
  __int128 v6 = a2[2];
  __int128 v7 = a2[3];
  *(_OWORD *)((char *)v4 + 17sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_OWORD *)((char *)a2 + 58);
  *((_OWORD *)v4 + 9) = v6;
  *((_OWORD *)v4 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v7;
  *((_OWORD *)v4 + 8) = v5;
  sub_100BEC010((float32x2_t *)v4);
  return a1;
}

void sub_100BEBFDC(_Unwind_Exception *a1)
{
}

void sub_100BEBFF8(_DWORD *a1)
{
  uint64_t v1 = sub_100C00A00(a1);
  operator delete(v1);
}

void sub_100BEC010(float32x2_t *a1)
{
  __int32 v2 = a1[8].i32[0];
  __int128 v3 = (char *)&a1[21] + 6;
  if (v2 != 2) {
    __int128 v3 = (char *)&a1[14] + 2;
  }
  if (v2 == 1) {
    __int128 v4 = (char *)&a1[17] + 2;
  }
  else {
    __int128 v4 = v3;
  }
  uint64_t v11 = *(void *)v4;
  int v12 = *((_DWORD *)v4 + 2);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_1018776E8);
  }
  __int128 v5 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    __int32 v6 = a1[8].i32[0];
    *(_DWORD *)uint64_t buf = 67110656;
    int v28 = (__int16)v11;
    __int16 v29 = 1024;
    int v30 = SWORD1(v11);
    __int16 v31 = 1024;
    int v32 = SWORD2(v11);
    __int16 v33 = 1024;
    int v34 = SHIWORD(v11);
    __int16 v35 = 1024;
    int v36 = (__int16)v12;
    __int16 v37 = 1024;
    int v38 = SHIWORD(v12);
    __int16 v39 = 1024;
    __int32 v40 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d",  buf,  0x2Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_1018776E8);
    }
    __int32 v7 = a1[8].i32[0];
    __int16 v15 = 1024;
    int v16 = SWORD1(v11);
    __int16 v17 = 1024;
    int v18 = SWORD2(v11);
    __int16 v19 = 1024;
    int v20 = SHIWORD(v11);
    __int16 v21 = 1024;
    int v22 = (__int16)v12;
    __int16 v23 = 1024;
    int v24 = SHIWORD(v12);
    __int16 v25 = 1024;
    __int32 v26 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d",  &v14,  44,  v10,  v11,  v12,  v13,  67110656);
    id v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasV10::chooseOffsetData()",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  sub_100C01740(a1, (__int16 *)&v11);
}

void sub_100BEC2A0(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

uint64_t sub_100BEC2CC(uint64_t result, uint64_t a2, int a3, int a4, int a5, int a6)
{
  *(void *)uint64_t result = &off_101877718;
  *(void *)(result + 8) = a2;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a4;
  *(_DWORD *)(result + 24) = a5;
  *(_DWORD *)(result + sub_100231C10(v1 + 28) = a6;
  return result;
}

uint64_t sub_100BEC2E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_100BEC2EC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

uint64_t sub_100BEC2F4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_100BEC2FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100BEC304(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

id sub_100BEC5B8(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *(double *)(v3 + 96);
  if (v4 == 0.0)
  {
    *(double *)(v3 + 96) = Current - (*(double *)(a1 + 40) + 5.0);
    uint64_t v3 = *(void *)(a1 + 32);
    double v4 = *(double *)(v3 + 96);
  }

  double v5 = *(double *)(v3 + 104);
  if (Current - v4 >= v5) {
    double v4 = Current - v5;
  }
  *(double *)(v3 + 96) = v4;
  if ([*(id *)(a1 + 32) registeredXPCTaskElevationProfile])
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    __int32 v6 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(*(void *)(a1 + 32) + 96LL) + 5.0;
      *(_DWORD *)uint64_t buf = 134218240;
      double v14 = v7;
      __int16 v15 = 2048;
      double v16 = Current;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "delay registration of XPC task for elevation profile calculation with startTime,%f,endTime,%f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  0LL,  "delay registration of XPC task for elevation profile calculation with startTime,%f,endTime,%f");
LABEL_25:
      int v12 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile initWithUniverse:delegate:withBuffer:withSourceAggregator:]_block_invoke",  "%s\n",  v8);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  else
  {
    double v9 = *(double *)(*(void *)(a1 + 32) + 96LL) + 5.0;
    if (+[CLContextManagerElevationProfileBase isQueryValidWithStartTime:andEndTime:]( &OBJC_CLASS___CLContextManagerElevationProfileBase,  "isQueryValidWithStartTime:andEndTime:",  v9,  Current))
    {
      [*(id *)(a1 + 32) pushElevationsFromTime:*(double *)(*(void *)(a1 + 32) + 96) + 5.0 toTime:Current];
      return [*(id *)(*(void *)(a1 + 32) + 88) setNextFireDelay:*(double *)(a1 + 40)];
    }

    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    int v10 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134218240;
      double v14 = v9;
      __int16 v15 = 2048;
      double v16 = Current;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "skip elevation profile calculation due to false startTime,%f,endTime,%f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  0LL,  "skip elevation profile calculation due to false startTime,%f,endTime,%f");
      goto LABEL_25;
    }
  }

  return [*(id *)(*(void *)(a1 + 32) + 88) setNextFireDelay:*(double *)(a1 + 40)];
}

uint64_t sub_100BECF28(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    double v4 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v81 = 0;
      *(_WORD *)&v81[4] = 2082;
      *(void *)&v81[6] = "";
      *(_WORD *)&v81[14] = 2114;
      *(void *)&v81[16] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:error fetching routine visits, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
    }

    double v5 = (os_log_s *)qword_1019346A8;
    if (os_signpost_enabled((os_log_t)qword_1019346A8))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v81 = 0;
      *(_WORD *)&v81[4] = 2082;
      *(void *)&v81[6] = "";
      *(_WORD *)&v81[14] = 2114;
      *(void *)&v81[16] = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v5,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "error fetching routine visits",  "{msg%{public}.0s:error fetching routine visits, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0x7FFFFFFFLL);
  }

  double v7 = a2;
  if ([a2 count])
  {
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    id v8 = [v7 countByEnumeratingWithState:&v61 objects:v79 count:16];
    if (!v8) {
      return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))( *(void *)(a1 + 40),  [*(id *)(a1 + 32) count] - 1);
    }
    id v9 = v8;
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    uint64_t v11 = &OBJC_METACLASS___CLPrivacyManager.vtable;
    uint64_t v60 = *(void *)v62;
    double v57 = v7;
    while (1)
    {
      int v12 = 0LL;
      id v58 = v9;
      do
      {
        if (*(void *)v62 != v60) {
          objc_enumerationMutation(v7);
        }
        int v13 = *(void **)(*((void *)&v61 + 1) + 8LL * (void)v12);
        double v14 = objc_alloc_init(&OBJC_CLASS___CLVisitTimePeriod);
        __int16 v15 = (os_log_s *)v11[213];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          id v16 = [v13 date];
          unsigned int v17 = [v13 type];
          id v18 = [v13 entry];
          id v19 = [v13 exit];
          [v13 confidence];
          uint64_t v21 = v20;
          unsigned int v22 = [v13 source];
          *(_DWORD *)uint64_t buf = 136317954;
          *(void *)uint64_t v81 = "date";
          *(_WORD *)&v81[8] = 2112;
          *(void *)&v81[10] = v16;
          *(_WORD *)&v81[18] = 2080;
          *(void *)&v81[20] = "type";
          __int16 v82 = 1024;
          *(_DWORD *)uint64_t v83 = v17;
          double v7 = v57;
          id v9 = v58;
          *(_WORD *)&v83[4] = 2080;
          *(void *)&v83[6] = "entryDate";
          *(_WORD *)&v83[14] = 2112;
          *(void *)&v83[16] = v18;
          p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
          *(_WORD *)&v83[24] = 2080;
          *(void *)&v83[26] = "exitDate";
          *(_WORD *)&v83[34] = 2112;
          *(void *)&v83[36] = v19;
          uint64_t v11 = &OBJC_METACLASS___CLPrivacyManager.vtable;
          *(_WORD *)&v83[44] = 2080;
          *(void *)&v83[46] = "confidence";
          __int16 v84 = 2048;
          uint64_t v85 = v21;
          __int16 v86 = 2080;
          uint64_t v87 = "source";
          __int16 v88 = 1024;
          unsigned int v89 = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "visit from Routine,%s,%@,%s,%d,%s,%@,%s,%@,%s,%f,%s,%d",  buf,  0x72u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          __int16 v33 = v11[213];
          id v34 = [v13 date];
          unsigned int v35 = [v13 type];
          id v36 = [v13 entry];
          id v37 = [v13 exit];
          [v13 confidence];
          uint64_t v39 = v38;
          unsigned int v40 = [v13 source];
          int v65 = 136317954;
          uint64_t v66 = "date";
          __int16 v67 = 2112;
          id v68 = v34;
          __int16 v69 = 2080;
          uint64_t v70 = "type";
          __int16 v71 = 1024;
          *(_DWORD *)double v72 = v35;
          *(_WORD *)&v72[4] = 2080;
          *(void *)&v72[6] = "entryDate";
          *(_WORD *)&v72[14] = 2112;
          *(void *)&v72[16] = v36;
          *(_WORD *)&v72[24] = 2080;
          *(void *)&v72[26] = "exitDate";
          *(_WORD *)&v72[34] = 2112;
          *(void *)&v72[36] = v37;
          *(_WORD *)&v72[44] = 2080;
          *(void *)&v72[46] = "confidence";
          __int16 v73 = 2048;
          uint64_t v74 = v39;
          __int16 v75 = 2080;
          uint64_t v76 = "source";
          __int16 v77 = 1024;
          unsigned int v78 = v40;
          LODWORD(v56) = 114;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  0LL,  "visit from Routine,%s,%@,%s,%d,%s,%@,%s,%@,%s,%f,%s,%d",  &v65,  v56);
          __int16 v42 = (uint8_t *)v41;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke",  "%s\n",  v41);
          if (v42 != buf) {
            free(v42);
          }
          double v7 = v57;
          id v9 = v58;
          p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          uint64_t v11 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        }

        if ([v13 exit])
        {
          objc_msgSend(objc_msgSend(v13, "entry"), "timeIntervalSinceReferenceDate");
          -[CLVisitTimePeriod setStartTime:](v14, "setStartTime:");
          objc_msgSend(objc_msgSend(v13, "exit"), "timeIntervalSinceReferenceDate");
        }

        else
        {
          if (objc_msgSend(objc_msgSend(v7, "firstObject"), "exit")) {
            goto LABEL_30;
          }
          objc_msgSend(objc_msgSend(v13, "entry"), "timeIntervalSinceReferenceDate");
          double v31 = v30;
          objc_msgSend(objc_msgSend(objc_msgSend(v7, "firstObject"), "entry"), "timeIntervalSinceReferenceDate");
          if (v31 != v32) {
            goto LABEL_30;
          }
          objc_msgSend(objc_msgSend(objc_msgSend(v7, "firstObject"), "entry"), "timeIntervalSinceReferenceDate");
          -[CLVisitTimePeriod setStartTime:](v14, "setStartTime:");
        }

        -[CLVisitTimePeriod setEndTime:](v14, "setEndTime:");
        __int16 v23 = (os_log_s *)v11[213];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          -[CLVisitTimePeriod startTime](v14, "startTime");
          uint64_t v25 = v24;
          -[CLVisitTimePeriod endTime](v14, "endTime");
          uint64_t v27 = v26;
          id v28 = [v13 entry];
          id v29 = [v13 exit];
          *(_DWORD *)uint64_t buf = 136316930;
          *(void *)uint64_t v81 = "entryTimestamp";
          *(_WORD *)&v81[8] = 2048;
          *(void *)&v81[10] = v25;
          *(_WORD *)&v81[18] = 2080;
          *(void *)&v81[20] = "exitTimestamp";
          __int16 v82 = 2048;
          *(void *)uint64_t v83 = v27;
          *(_WORD *)&v83[8] = 2080;
          *(void *)&v83[10] = "entryDate";
          *(_WORD *)&v83[18] = 2112;
          *(void *)&v83[20] = v28;
          uint64_t v11 = &OBJC_METACLASS___CLPrivacyManager.vtable;
          *(_WORD *)&v83[28] = 2080;
          *(void *)&v83[30] = "exitDate";
          *(_WORD *)&v83[38] = 2112;
          *(void *)&v83[40] = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "filtered visit from Routine,%s,%f,%s,%f,%s,%@,%s,%@",  buf,  0x52u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          int v43 = v11[213];
          -[CLVisitTimePeriod startTime](v14, "startTime");
          uint64_t v45 = v44;
          -[CLVisitTimePeriod endTime](v14, "endTime");
          uint64_t v47 = v46;
          id v48 = [v13 entry];
          id v49 = [v13 exit];
          int v65 = 136316930;
          uint64_t v66 = "entryTimestamp";
          __int16 v67 = 2048;
          id v68 = v45;
          __int16 v69 = 2080;
          uint64_t v70 = "exitTimestamp";
          __int16 v71 = 2048;
          *(void *)double v72 = v47;
          *(_WORD *)&v72[8] = 2080;
          *(void *)&v72[10] = "entryDate";
          *(_WORD *)&v72[18] = 2112;
          *(void *)&v72[20] = v48;
          *(_WORD *)&v72[28] = 2080;
          *(void *)&v72[30] = "exitDate";
          *(_WORD *)&v72[38] = 2112;
          *(void *)&v72[40] = v49;
          LODWORD(v56) = 82;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v43,  0LL,  "filtered visit from Routine,%s,%f,%s,%f,%s,%@,%s,%@",  &v65,  v56);
          __int16 v51 = (uint8_t *)v50;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke",  "%s\n",  v50);
          if (v51 != buf) {
            free(v51);
          }
          p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          uint64_t v11 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        }

        [*(id *)(a1 + 32) addObject:v14];
LABEL_30:

        int v12 = (char *)v12 + 1;
      }

      while (v9 != v12);
      id v52 = [v7 countByEnumeratingWithState:&v61 objects:v79 count:16];
      id v9 = v52;
      if (!v52) {
        return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))( *(void *)(a1 + 40),  [*(id *)(a1 + 32) count] - 1);
      }
    }
  }

  if (qword_1019346A0 != -1) {
    dispatch_once(&qword_1019346A0, &stru_101877818);
  }
  std::stringbuf::string_type v53 = (os_log_s *)qword_1019346A8;
  if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "empty visit fetched from Routine", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    LOWORD(v65) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  0LL,  "empty visit fetched from Routine",  &v65,  2);
    uint64_t v55 = (uint8_t *)v54;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile getStoredVisit:betweenStartTime:andEndTime:withCompletionBlock:]_block_invoke",  "%s\n",  v54);
    if (v55 != buf) {
      free(v55);
    }
  }

  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), 0xFFFFFFFFLL);
}

void sub_100BEDA24(uint64_t a1, void *a2, void *a3, int a4)
{
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  id v8 = [a2 countByEnumeratingWithState:&v41 objects:v57 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v42;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v42 != v10) {
          objc_enumerationMutation(a2);
        }
        int v12 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
        if (objc_msgSend(*(id *)(a1 + 32), "isLocationUsefulForCalibration:", objc_msgSend(v12, "type")))
        {
          int v13 = objc_alloc_init(&OBJC_CLASS___CLLocationPreFilterEntry);
          objc_msgSend(objc_msgSend(v12, "timestamp"), "timeIntervalSinceReferenceDate");
          -[CLLocationDBEntry setTimestamp:](v13, "setTimestamp:");
          [v12 altitude];
          -[CLLocationDBEntry setElevation:](v13, "setElevation:");
          [v12 verticalAccuracy];
          -[CLLocationDBEntry setVerticalAccuracy:](v13, "setVerticalAccuracy:");
          [v12 coordinate];
          -[CLLocationDBEntry setLatitude:](v13, "setLatitude:");
          [v12 coordinate];
          -[CLLocationDBEntry setLongitude:](v13, "setLongitude:", v14);
          [v12 horizontalAccuracy];
          -[CLLocationPreFilterEntry setHorizontalAccuracy:](v13, "setHorizontalAccuracy:");
          [*(id *)(a1 + 40) addObject:v13];
        }
      }

      id v9 = [a2 countByEnumeratingWithState:&v41 objects:v57 count:16];
    }

    while (v9);
  }

  if (qword_1019346A0 != -1) {
    dispatch_once(&qword_1019346A0, &stru_101877818);
  }
  __int16 v15 = (os_log_s *)qword_1019346A8;
  if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_INFO))
  {
    id v16 = [a2 count];
    *(_DWORD *)uint64_t buf = 134349056;
    id v52 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "received stored locations,count,%{public}lu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    uint64_t v25 = qword_1019346A8;
    id v26 = [a2 count];
    int v45 = 134349056;
    id v46 = v26;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  1LL,  "received stored locations,count,%{public}lu",  &v45,  12);
    id v28 = (uint8_t *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisitSe archStartIndex:andCompletionBlock:]_block_invoke",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

  if (a3)
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    unsigned int v17 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      id v52 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "error enumerating stored locations, %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      int v45 = 138412290;
      id v46 = a3;
      LODWORD(v39) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  1LL,  "error enumerating stored locations, %@",  &v45,  v39);
      double v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisit SearchStartIndex:andCompletionBlock:]_block_invoke",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }
  }

  if (a4)
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    id v18 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_INFO))
    {
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "startDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v20 = v19;
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v22 = v21;
      id v23 = [*(id *)(a1 + 40) count];
      *(_DWORD *)uint64_t buf = 134349568;
      id v52 = v20;
      __int16 v53 = 2050;
      uint64_t v54 = v22;
      __int16 v55 = 2050;
      id v56 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "received all stored locations,startDate,%{public}f,endDate,%{public}f,count,%{public}lu",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      uint64_t v31 = qword_1019346A8;
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "startDate"),  "timeIntervalSinceReferenceDate");
      __int16 v33 = v32;
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "dateInterval"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v35 = v34;
      id v36 = [*(id *)(a1 + 40) count];
      int v45 = 134349568;
      id v46 = v33;
      __int16 v47 = 2050;
      uint64_t v48 = v35;
      __int16 v49 = 2050;
      id v50 = v36;
      LODWORD(v39) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v31,  1LL,  "received all stored locations,startDate,%{public}f,endDate,%{public}f,count,%{public}lu",  &v45,  v39);
      uint64_t v38 = (uint8_t *)v37;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile fetchLocationsWithStartTime:andEndTime:andBatchSize:andLocationArray:andVisit SearchStartIndex:andCompletionBlock:]_block_invoke",  "%s\n",  v37);
      if (v38 != buf) {
        free(v38);
      }
    }

    uint64_t v24 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "silo"), "queue");
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100BEE094;
    block[3] = &unk_10184AF38;
    block[4] = *(void *)(a1 + 56);
    dispatch_async(v24, block);
  }

uint64_t sub_100BEE094(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

id sub_100BEE7A0(uint64_t a1)
{
  if (*(_BYTE *)(*(void *)(a1 + 32) + 112LL))
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    __int32 v2 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEBUG))
    {
      id v3 = [*(id *)(a1 + 40) count];
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "firstObject"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v5 = v4;
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v7 = v6;
      id v8 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "firstObject"), "endDate");
      id v9 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate");
      uint64_t v10 = *(void *)(a1 + 64);
      uint64_t v11 = *(void *)(a1 + 72);
      *(_DWORD *)uint64_t buf = 134219522;
      id v40 = v3;
      __int16 v41 = 2048;
      uint64_t v42 = v5;
      __int16 v43 = 2048;
      uint64_t v44 = v7;
      __int16 v45 = 2112;
      id v46 = v8;
      __int16 v47 = 2112;
      id v48 = v9;
      __int16 v49 = 2048;
      uint64_t v50 = v10;
      __int16 v51 = 2048;
      uint64_t v52 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "pushing elevation profile batch,batchSize,%lu,firstElevationTime,%f,lastElevationTime,%f,firstElevationDate,%@,l astElevationDate,%@,startIndex,%lu,endIndex,%lu",  buf,  0x48u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      uint64_t v13 = qword_1019346A8;
      id v14 = [*(id *)(a1 + 40) count];
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "firstObject"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v16 = v15;
      objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate"),  "timeIntervalSinceReferenceDate");
      uint64_t v18 = v17;
      id v19 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "firstObject"), "endDate");
      id v20 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "lastObject"), "endDate");
      uint64_t v21 = *(void *)(a1 + 64);
      uint64_t v22 = *(void *)(a1 + 72);
      int v25 = 134219522;
      id v26 = v14;
      __int16 v27 = 2048;
      uint64_t v28 = v16;
      __int16 v29 = 2048;
      uint64_t v30 = v18;
      __int16 v31 = 2112;
      id v32 = v19;
      __int16 v33 = 2112;
      id v34 = v20;
      __int16 v35 = 2048;
      uint64_t v36 = v21;
      __int16 v37 = 2048;
      uint64_t v38 = v22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  2LL,  "pushing elevation profile batch,batchSize,%lu,firstElevationTime,%f,lastElevationTime,%f,firstElevationDate,%@,l astElevationDate,%@,startIndex,%lu,endIndex,%lu",  &v25,  72);
      uint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile _sendElevationsFromEstimates:startIndex:withCompletionBlock:]_block_invoke",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }
  }

  return objc_msgSend(*(id *)(*(void *)(a1 + 32) + 120), "addElevations:handler:");
}

void sub_100BEEAE4(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_101877818);
    }
    uint64_t v4 = (os_log_s *)qword_1019346A8;
    if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "error adding elevations to routine: %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_101877818);
      }
      int v9 = 138412290;
      uint64_t v10 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  0LL,  "error adding elevations to routine: %@",  &v9,  12);
      id v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerElevationProfile _sendElevationsFromEstimates:startIndex:withCompletionBlock:]_block_invoke",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }

  else
  {
    objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "objectAtIndexedSubscript:", *(void *)(a1 + 64)), "timestamp");
    *(void *)(*(void *)(a1 + 40) + 96LL) = v5;
    [*(id *)(a1 + 40) saveLastPushedTime:*(double *)(*(void *)(a1 + 40) + 96)];
    uint64_t v6 = *(_BYTE **)(a1 + 64);
    else {
      [*(id *)(a1 + 40) _sendElevationsFromEstimates:*(void *)(a1 + 48) startIndex:*(void *)(a1 + 64) + 1 withCompletionBlock:*(void *)(a1 + 56)];
    }
  }

void sub_100BEF4A8(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

uint64_t sub_100BEF4D4()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199AD80, (void *)&_mh_execute_header);
}

unsigned __int8 *sub_100BEF518(unsigned __int8 *a1)
{
  return a1;
}

unsigned __int8 *sub_100BEF53C(unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return a1;
}

uuid_t sub_100BEF560(uuid_t uu, char *in)
{
  return uu;
}

uint64_t sub_100BEF58C(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) >> 31;
}

BOOL sub_100BEF5A4(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) == 0;
}

BOOL sub_100BEF5C0(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return uuid_compare(a1, a2) != 0;
}

void *sub_100BEF5DC@<X0>(const unsigned __int8 *a1@<X0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, out);
}

uint64_t sub_100BEF640(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (v1 > 0xA) {
    return 0LL;
  }
  else {
    return dword_10134F538[v1];
  }
}

BOOL sub_100BEF664(uint64_t a1)
{
  return (unint64_t)(a1 - 3) < 3;
}

BOOL sub_100BEF674(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFFFDLL) == 16;
}

BOOL sub_100BEF684(uint64_t a1)
{
  return (unint64_t)(*(void *)(a1 + 16) - 13LL) < 6;
}

uint64_t sub_100BEF698(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (v1 <= 0x11)
  {
    if (((1LL << v1) & 0x18002) != 0) {
      return 2LL;
    }
    if (((1LL << v1) & 0x22001) != 0) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_100BEF6EC(uint64_t result, uint64_t a2)
{
  switch(result)
  {
    case 1LL:
      if (a2 == 1)
      {
        return 16LL;
      }

      else if (a2 == 2)
      {
        return 15LL;
      }

      break;
    case 2LL:
      if (a2 == 1)
      {
        return 18LL;
      }

      else if (a2 == 2)
      {
        return 17LL;
      }

      break;
    case 3LL:
      if (a2 == 1)
      {
        return 5LL;
      }

      else if (a2 == 2)
      {
        return 4LL;
      }

      break;
  }

  return result;
}

uint64_t sub_100BEF764(uint64_t a1)
{
  else {
    return qword_10134F568[a1 - 1];
  }
}

uint64_t sub_100BEF788(unint64_t a1)
{
  if (((1LL << a1) & 0x2408801328010LL) != 0) {
    uint64_t v1 = 2LL;
  }
  else {
    uint64_t v1 = ((1LL << a1) & 0x1810000050020LL) != 0;
  }
  if (a1 <= 0x31) {
    return v1;
  }
  else {
    return 0LL;
  }
}

BOOL sub_100BEF7DC(uint64_t a1)
{
  return (unint64_t)(a1 - 1) < 2;
}

std::string *sub_100BEF7EC@<X0>(unint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t result = (std::string *)sub_1010DDBC0(a2, "invalid");
  if (a1 < 0x18 && ((0xFFFFDFu >> a1) & 1) != 0) {
    return std::string::assign(a2, (&off_101877858)[a1]);
  }
  return result;
}

void sub_100BEF848(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100BEF864(uint64_t a1)
{
  uint64_t result = 0LL;
  switch(*(void *)(a1 + 16))
  {
    case 0LL:
    case 1LL:
    case 2LL:
    case 3LL:
    case 6LL:
    case 7LL:
    case 9LL:
    case 0xBLL:
    case 0xELL:
    case 0x12LL:
    case 0x13LL:
    case 0x14LL:
    case 0x15LL:
    case 0x17LL:
      uint64_t result = 6LL;
      break;
    case 4LL:
      uint64_t result = 5LL;
      break;
    case 8LL:
      uint64_t result = 2LL;
      break;
    case 0xCLL:
    case 0xDLL:
    case 0x11LL:
      uint64_t result = 1LL;
      break;
    case 0x10LL:
      uint64_t result = 3LL;
      break;
    case 0x16LL:
      uint64_t v3 = *(void *)(a1 + 112);
      if (v3 == 26 || v3 == 0) {
        uint64_t result = 3LL;
      }
      else {
        uint64_t result = 4LL;
      }
      break;
    default:
      return result;
  }

  return result;
}

uint64_t sub_100BEF8D0(unint64_t a1)
{
  if (a1 > 6) {
    return 0LL;
  }
  unint64_t v1 = a1;
  if (((1LL << a1) & 0x4B) != 0)
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101877838);
    }
    __int32 v2 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Unexpected state for user dismiss, keeping as is",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101877838);
      }
      v5[0] = 0;
      uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "Unexpected state for user dismiss, keeping as is",  v5,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMWorkoutState CLWorkoutUtil::stateAfterUserDismiss(CMWorkoutState)",  "%s\n",  v3);
    }
  }

  else if (a1 == 4)
  {
    return 3LL;
  }

  else
  {
    return a1 == 5;
  }

  return v1;
}

void sub_100BEFAA0(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void *sub_100BEFACC(uint64_t a1)
{
  __int32 v2 = operator new(0x260uLL);
  sub_100BF0220((uint64_t)v2, a1);
  return v2;
}

void sub_100BEFB00(_Unwind_Exception *a1)
{
}

void sub_100BEFBB8(id a1)
{
  qword_10199AD98 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLEmergencyControllerAdapterSilo");
}

char *sub_100BEFC68(char *result, void *a2)
{
  id v18 = a2;
  if (a2)
  {
    __int32 v2 = result;
    id v3 = a2;
    sub_1001145B0((uint64_t **)v2 + 2, (unint64_t *)&v18, (uint64_t *)&v18);
    *(_DWORD *)uint64_t buf = 0;
    uint64_t v4 = sub_100781F1C((void *)v2 + 20, (int *)buf);
    if (v4)
    {
      id v5 = v18;
      sub_100BF71B4((uint64_t)v17, v4 + 3);
      [v5 emergencySettingsChange:sub_100BF29B0(v17) withReason:0];
      sub_100BF6F74((uint64_t)v17);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      uint64_t v6 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "#EmergCon #Warning inst0 settings find returned null",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101877978);
        }
        v16[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EmergCon #Warning inst0 settings find returned null",  v16,  2);
        uint64_t v11 = (uint8_t *)v10;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::registerObserver(id<CLEmergencyClientProtocol>)",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }
    }

    if (v2[133])
    {
      *(_DWORD *)uint64_t buf = 1;
      uint64_t v7 = sub_100781F1C((void *)v2 + 20, (int *)buf);
      if (v7)
      {
        id v8 = v18;
        sub_100BF71B4((uint64_t)v15, v7 + 3);
        [v8 emergencySettingsChange:sub_100BF29B0(v15) withReason:0];
        sub_100BF6F74((uint64_t)v15);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101877978);
        }
        int v9 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#EmergCon #Warning inst1 settings find returned null",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101877978);
          }
          v16[0] = 0;
          LODWORD(v14) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EmergCon #Warning inst1 settings find returned null",  v16,  v14);
          uint64_t v13 = (uint8_t *)v12;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::registerObserver(id<CLEmergencyClientProtocol>)",  "%s\n",  v12);
          if (v13 != buf) {
            free(v13);
          }
        }
      }
    }

    __int128 v23 = *(_OWORD *)(v2 + 72);
    int v24 = *((_DWORD *)v2 + 22);
    *(void *)uint64_t buf = _NSConcreteStackBlock;
    uint64_t v20 = 3221225472LL;
    uint64_t v21 = sub_100BFA354;
    uint64_t v22 = &unk_101877A48;
    objc_msgSend(v18, "emergencyStateChange:", -[uint8_t copy](buf, "copy"));
    return (char *)[v18 shouldLockoutNilr:v2[1]];
  }

  return result;
}

void sub_100BF004C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100BF0084(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (a2)
  {
    sub_1004C40E4(a1 + 16, (unint64_t *)&v2);
  }

void sub_100BF00C8(uint64_t a1, int a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    id v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = "emergencyenablementassertion";
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon E911Event, event:%{public, location:escape_only}s, CLEEA:%{public}d}",  (uint8_t *)v6,  0x22u);
  }

  *(_BYTE *)(a1 + 56) = a2;
  if (a2) {
    int v5 = 5;
  }
  else {
    int v5 = 0;
  }
  sub_100BF528C(a1, v5);
  sub_100BF1E7C(a1);
}

uint64_t sub_100BF0220(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = 0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(_BYTE *)(a1 + 56) = 0;
  *(void *)(a1 + 6sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_WORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 255;
  *(void *)(a1 + 84) = 0LL;
  *(void *)(a1 + 76) = 0LL;
  *(_BYTE *)(a1 + 92) = 0;
  *(void *)(a1 + 96) = 0x400000000LL;
  *(_WORD *)(a1 + 104) = 256;
  *(_DWORD *)(a1 + 108) = 255;
  *(_BYTE *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0x400000000LL;
  *(_WORD *)(a1 + 124) = 256;
  *(_DWORD *)(a1 + 1sub_100231C10(v1 + 28) = 255;
  *(_BYTE *)(a1 + 132) = 0;
  char v4 = sub_1004FAACC();
  *(_OWORD *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_BYTE *)(a1 + 133) = v4;
  *(_BYTE *)(a1 + 134) = 0;
  *(void *)(a1 + 136) = 0LL;
  *(_BYTE *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0LL;
  *(_DWORD *)(a1 + 192) = 1065353216;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 232) = 1065353216;
  *(void *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_DWORD *)(a1 + 2memset(v19, 0, 48) = -1;
  *(void *)(a1 + 256) = 0LL;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 1065353216;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 3sub_100231C10(v1 + 28) = 0u;
  *(_DWORD *)(a1 + 344) = 1065353216;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_DWORD *)(a1 + 384) = 1065353216;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 424) = 1065353216;
  uint64_t v25 = a1 + 432;
  uint64_t v26 = a1 + 352;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 4memset(v19, 0, 48) = 0u;
  *(_DWORD *)(a1 + 464) = 1065353216;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_DWORD *)(a1 + 504) = 1065353216;
  uint64_t v5 = a1 + 536;
  *(_BYTE *)(a1 + 5sub_100231C10(v1 + 28) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(void *)(a1 + 568) = 0LL;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  uint64_t v6 = operator new(0x728uLL);
  uint64_t v30 = (uint64_t)&off_1018779A8;
  v31.__r_.__value_.__r.__words[0] = a1;
  v31.__r_.__value_.__l.__cap_ = (std::string::size_type)&v30;
  sub_100F98658(v6, a2, &v30);
  *(void *)(a1 + 576) = v6;
  std::string::size_type cap = (uint64_t *)v31.__r_.__value_.__l.__cap_;
  if ((uint64_t *)v31.__r_.__value_.__l.__cap_ == &v30)
  {
    uint64_t v8 = 4LL;
    std::string::size_type cap = &v30;
    goto LABEL_5;
  }

  if (v31.__r_.__value_.__l.__cap_)
  {
    uint64_t v8 = 5LL;
LABEL_5:
    (*(void (**)(void))(*cap + 8 * v8))();
  }

  *(void *)(a1 + 584) = operator new(1uLL);
  *(_OWORD *)(a1 + 592) = 0u;
  id v9 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLStatusBarIconManager");
  *(void *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v9;
  id v10 = v9;
  sub_1003CC884((uint64_t)sub_100BF120C, a1, *(void **)(a1 + 8), &v30);
  uint64_t v11 = v30;
  uint64_t v30 = 0LL;
  uint64_t v12 = *(void *)v5;
  *(void *)uint64_t v5 = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    uint64_t v13 = v30;
    uint64_t v30 = 0LL;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
  }

  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:11 registrationInfo:0];
  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:7 registrationInfo:0];
  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:8 registrationInfo:0];
  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:6 registrationInfo:0];
  sub_100583844((uint64_t)sub_100BF13E4, a1, *(void **)(a1 + 8), &v30);
  uint64_t v14 = v30;
  uint64_t v30 = 0LL;
  uint64_t v15 = *(void *)(a1 + 544);
  *(void *)(a1 + 544) = v14;
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    uint64_t v16 = v30;
    uint64_t v30 = 0LL;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
  }

  [*(id *)(*(void *)(a1 + 544) + 16) register:*(void *)(*(void *)(a1 + 544) + 8) forNotification:4 registrationInfo:0];
  bzero(&v31, 0x480uLL);
  uint64_t v30 = 0x101000000FFLL;
  *(_OWORD *)&v31.__r_.__value_.__r.__words[1] = xmmword_10134F770;
  int v32 = 1;
  v34[0] = 0LL;
  uint64_t v33 = 0LL;
  *(void *)((char *)v34 + 5) = 0LL;
  __int128 v35 = xmmword_10134F770;
  int v36 = 1;
  memset(v38, 0, 13);
  uint64_t v37 = 0LL;
  uint64_t v39 = 0x401C000000000000LL;
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  char v43 = 0;
  uint64_t v45 = 0LL;
  uint64_t v44 = 0LL;
  int v47 = 0;
  uint64_t v46 = 0LL;
  uint64_t v48 = 0x402E000000000000LL;
  char v49 = 1;
  __int128 v50 = xmmword_10134F780;
  uint64_t v52 = 0LL;
  uint64_t v53 = 0LL;
  uint64_t v51 = 0LL;
  char v54 = 1;
  uint64_t v56 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v55 = 0LL;
  int v58 = 6;
  __int16 v59 = 257;
  __int128 v60 = 0uLL;
  __int128 v61 = 0uLL;
  __int128 v62 = 0uLL;
  __int128 v63 = 0uLL;
  __int128 v65 = xmmword_101329190;
  uint64_t v64 = 0LL;
  uint64_t v66 = 0x4024000000000000LL;
  uint64_t v68 = 0LL;
  uint64_t v67 = 0LL;
  uint64_t v69 = 0LL;
  char v70 = 1;
  uint64_t v73 = 0LL;
  uint64_t v71 = 0LL;
  uint64_t v72 = 0LL;
  __int16 v74 = 257;
  uint64_t v75 = 0x32000000018LL;
  char v76 = 0;
  char v77 = 1;
  int v78 = -115;
  uint64_t v79 = 0x4000000000000000LL;
  uint64_t v80 = 0x3E800000005LL;
  char v81 = 0;
  uint64_t v82 = -1LL;
  __int16 v83 = 257;
  char v84 = 1;
  __int16 v85 = 257;
  uint64_t v86 = 0x32000000018LL;
  char v87 = 0;
  char v88 = 0;
  uint64_t v89 = 0x6400000005LL;
  char v90 = 1;
  char v91 = 0;
  uint64_t v92 = -1LL;
  __int16 v93 = 257;
  char v94 = 1;
  char v95 = 0;
  uint64_t v96 = -1LL;
  __int16 v97 = 257;
  char v98 = 0;
  uint64_t v99 = -1LL;
  __int16 v100 = 257;
  __int16 v101 = 0;
  uint64_t v102 = -1LL;
  __int16 v103 = 257;
  uint64_t v104 = 0x6400000002LL;
  int v105 = 100;
  __int16 v106 = 256;
  char v107 = 1;
  __int128 v110 = 0uLL;
  __int128 v111 = 0uLL;
  __int128 v108 = 0uLL;
  __int128 v109 = 0uLL;
  uint64_t v112 = 0LL;
  __int128 v113 = xmmword_101329190;
  uint64_t v114 = 0x4024000000000000LL;
  uint64_t v116 = 0LL;
  uint64_t v115 = 0LL;
  uint64_t v117 = 0LL;
  __int16 v118 = 1;
  uint64_t v120 = 0LL;
  uint64_t v119 = 0LL;
  uint64_t v121 = 0LL;
  __int16 v122 = 257;
  uint64_t v123 = 0x32000000018LL;
  __int16 v124 = 0;
  char v125 = 1;
  int v126 = -115;
  uint64_t v127 = 0x4000000000000000LL;
  uint64_t v128 = 0x3E800000005LL;
  __int16 v129 = 0;
  uint64_t v130 = -1LL;
  __int16 v131 = 257;
  char v132 = 1;
  __int16 v133 = 257;
  uint64_t v134 = 0x32000000018LL;
  __int16 v135 = 0;
  __int16 v136 = 0;
  uint64_t v137 = 0x6400000005LL;
  __int16 v138 = 256;
  __int16 v139 = 0;
  uint64_t v140 = -1LL;
  __int16 v141 = 257;
  char v142 = 1;
  __int16 v143 = 0;
  uint64_t v144 = -1LL;
  __int16 v145 = 257;
  __int16 v146 = 0;
  uint64_t v147 = -1LL;
  __int16 v148 = 257;
  __int16 v149 = 0;
  uint64_t v150 = -1LL;
  __int16 v151 = 257;
  uint64_t v152 = 0x6400000002LL;
  int v153 = 100;
  __int128 v155 = 0uLL;
  __int128 v156 = 0uLL;
  __int128 v154 = 0uLL;
  __int16 v157 = 7275;
  uint64_t v158 = 0LL;
  __int16 v159 = 256;
  __int128 v160 = xmmword_1013291A0;
  uint64_t v161 = 0x93A80018B8200LL;
  __int16 v162 = 256;
  __int128 v163 = xmmword_1013291A0;
  uint64_t v164 = 0x93A80018B8200LL;
  __int128 v165 = 0uLL;
  __int128 v166 = 0uLL;
  __int128 v167 = 0uLL;
  __int128 v168 = 0uLL;
  __int128 v169 = 0uLL;
  __int128 v170 = 0uLL;
  int v28 = 0;
  __int16 v29 = &v28;
  uint64_t v17 = sub_100BF9B9C(a1 + 160, &v28, (uint64_t)&unk_1012CF090, &v29);
  sub_100BF15BC((uint64_t)(v17 + 3), &v30);
  sub_100BF6F74((uint64_t)&v30);
  LODWORD(v29) = 0;
  uint64_t v30 = (uint64_t)&v29;
  *((_DWORD *)sub_100BF9B9C(a1 + 160, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 6) = 0;
  sub_10032AB04((uint64_t)&v30, 0);
  int v28 = 0;
  __int16 v29 = &v28;
  id v18 = sub_100BF9F30(a1 + 200, &v28, (uint64_t)&unk_1012CF090, &v29);
  *((_DWORD *)v18 + 6) = v30;
  std::string::operator=((std::string *)(v18 + 4), &v31);
  *((_BYTE *)v18 + 56) = v32;
  std::string::operator=((std::string *)(v18 + 8), (const std::string *)((char *)&v33 + 4));
  *((_BYTE *)v18 + 88) = v35;
  sub_1002A576C((uint64_t)(v18 + 12), (uint64_t)&v35 + 8);
  *((_BYTE *)v18 + 112) = BYTE4(v37);
  sub_1002A576C((uint64_t)(v18 + 15), (uint64_t)&v38[4]);
  *((_BYTE *)v18 + 136) = v39;
  sub_1002A576C((uint64_t)(v18 + 18), (uint64_t)&v40);
  *((_BYTE *)v18 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v42;
  sub_10032ABFC((uint64_t)&v30);
  sub_10032AB04((uint64_t)&v30, 1);
  int v28 = 1;
  __int16 v29 = &v28;
  id v19 = sub_100BF9F30(a1 + 200, &v28, (uint64_t)&unk_1012CF090, &v29);
  *((_DWORD *)v19 + 6) = v30;
  std::string::operator=((std::string *)(v19 + 4), &v31);
  *((_BYTE *)v19 + 56) = v32;
  std::string::operator=((std::string *)(v19 + 8), (const std::string *)((char *)&v33 + 4));
  *((_BYTE *)v19 + 88) = v35;
  sub_1002A576C((uint64_t)(v19 + 12), (uint64_t)&v35 + 8);
  *((_BYTE *)v19 + 112) = BYTE4(v37);
  sub_1002A576C((uint64_t)(v19 + 15), (uint64_t)&v38[4]);
  *((_BYTE *)v19 + 136) = v39;
  sub_1002A576C((uint64_t)(v19 + 18), (uint64_t)&v40);
  *((_BYTE *)v19 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v42;
  sub_10032ABFC((uint64_t)&v30);
  LODWORD(v29) = 0;
  uint64_t v30 = (uint64_t)&v29;
  *((_DWORD *)sub_1007839D4(a1 + 272, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = 11;
  LODWORD(v29) = 0;
  uint64_t v30 = (uint64_t)&v29;
  *((_DWORD *)sub_1007839D4(v26, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = -1;
  LODWORD(v29) = 0;
  uint64_t v30 = (uint64_t)&v29;
  *((_DWORD *)sub_1007839D4(v25, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = -1;
  if (*(_BYTE *)(a1 + 133))
  {
    bzero(&v31, 0x480uLL);
    uint64_t v30 = 0x101000000FFLL;
    *(_OWORD *)&v31.__r_.__value_.__r.__words[1] = xmmword_10134F770;
    int v32 = 1;
    v34[0] = 0LL;
    uint64_t v33 = 0LL;
    *(void *)((char *)v34 + 5) = 0LL;
    __int128 v35 = xmmword_10134F770;
    int v36 = 1;
    memset(v38, 0, 13);
    uint64_t v37 = 0LL;
    uint64_t v39 = 0x401C000000000000LL;
    uint64_t v40 = 0LL;
    uint64_t v41 = 0LL;
    uint64_t v42 = 0LL;
    char v43 = 0;
    uint64_t v45 = 0LL;
    uint64_t v44 = 0LL;
    int v47 = 0;
    uint64_t v46 = 0LL;
    uint64_t v48 = 0x402E000000000000LL;
    char v49 = 1;
    __int128 v50 = xmmword_10134F780;
    uint64_t v52 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v51 = 0LL;
    char v54 = 1;
    uint64_t v56 = 0LL;
    uint64_t v57 = 0LL;
    uint64_t v55 = 0LL;
    int v58 = 6;
    __int16 v59 = 257;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v65 = xmmword_101329190;
    uint64_t v64 = 0LL;
    uint64_t v66 = 0x4024000000000000LL;
    uint64_t v68 = 0LL;
    uint64_t v67 = 0LL;
    uint64_t v69 = 0LL;
    char v70 = 1;
    uint64_t v73 = 0LL;
    uint64_t v71 = 0LL;
    uint64_t v72 = 0LL;
    __int16 v74 = 257;
    uint64_t v75 = 0x32000000018LL;
    char v76 = 0;
    char v77 = 1;
    int v78 = -115;
    uint64_t v79 = 0x4000000000000000LL;
    uint64_t v80 = 0x3E800000005LL;
    char v81 = 0;
    uint64_t v82 = -1LL;
    __int16 v83 = 257;
    char v84 = 1;
    __int16 v85 = 257;
    uint64_t v86 = 0x32000000018LL;
    char v87 = 0;
    char v88 = 0;
    uint64_t v89 = 0x6400000005LL;
    char v90 = 1;
    char v91 = 0;
    uint64_t v92 = -1LL;
    __int16 v93 = 257;
    char v94 = 1;
    char v95 = 0;
    uint64_t v96 = -1LL;
    __int16 v97 = 257;
    char v98 = 0;
    uint64_t v99 = -1LL;
    __int16 v100 = 257;
    __int16 v101 = 0;
    uint64_t v102 = -1LL;
    __int16 v103 = 257;
    uint64_t v104 = 0x6400000002LL;
    int v105 = 100;
    __int16 v106 = 256;
    char v107 = 1;
    __int128 v110 = 0u;
    __int128 v111 = 0u;
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    uint64_t v112 = 0LL;
    __int128 v113 = xmmword_101329190;
    uint64_t v114 = 0x4024000000000000LL;
    uint64_t v116 = 0LL;
    uint64_t v115 = 0LL;
    uint64_t v117 = 0LL;
    __int16 v118 = 1;
    uint64_t v120 = 0LL;
    uint64_t v119 = 0LL;
    uint64_t v121 = 0LL;
    __int16 v122 = 257;
    uint64_t v123 = 0x32000000018LL;
    __int16 v124 = 0;
    char v125 = 1;
    int v126 = -115;
    uint64_t v127 = 0x4000000000000000LL;
    uint64_t v128 = 0x3E800000005LL;
    __int16 v129 = 0;
    uint64_t v130 = -1LL;
    __int16 v131 = 257;
    char v132 = 1;
    __int16 v133 = 257;
    uint64_t v134 = 0x32000000018LL;
    __int16 v135 = 0;
    __int16 v136 = 0;
    uint64_t v137 = 0x6400000005LL;
    __int16 v138 = 256;
    __int16 v139 = 0;
    uint64_t v140 = -1LL;
    __int16 v141 = 257;
    char v142 = 1;
    __int16 v143 = 0;
    uint64_t v144 = -1LL;
    __int16 v145 = 257;
    __int16 v146 = 0;
    uint64_t v147 = -1LL;
    __int16 v148 = 257;
    __int16 v149 = 0;
    uint64_t v150 = -1LL;
    __int16 v151 = 257;
    uint64_t v152 = 0x6400000002LL;
    int v153 = 100;
    __int128 v155 = 0u;
    __int128 v156 = 0u;
    __int128 v154 = 0u;
    __int16 v157 = 7275;
    uint64_t v158 = 0LL;
    __int16 v159 = 256;
    __int128 v160 = xmmword_1013291A0;
    uint64_t v161 = 0x93A80018B8200LL;
    __int16 v162 = 256;
    __int128 v163 = xmmword_1013291A0;
    uint64_t v164 = 0x93A80018B8200LL;
    __int128 v165 = 0u;
    __int128 v166 = 0u;
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    __int128 v169 = 0u;
    __int128 v170 = 0u;
    int v28 = 1;
    __int16 v29 = &v28;
    uint64_t v20 = sub_100BF9B9C(a1 + 160, &v28, (uint64_t)&unk_1012CF090, &v29);
    sub_100BF15BC((uint64_t)(v20 + 3), &v30);
    sub_100BF6F74((uint64_t)&v30);
    LODWORD(v29) = 1;
    uint64_t v30 = (uint64_t)&v29;
    *((_DWORD *)sub_100BF9B9C(a1 + 160, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 6) = 1;
    sub_10032AB04((uint64_t)&v30, 2);
    int v28 = 2;
    __int16 v29 = &v28;
    uint64_t v21 = sub_100BF9F30(a1 + 200, &v28, (uint64_t)&unk_1012CF090, &v29);
    *((_DWORD *)v21 + 6) = v30;
    std::string::operator=((std::string *)(v21 + 4), &v31);
    *((_BYTE *)v21 + 56) = v32;
    std::string::operator=((std::string *)(v21 + 8), (const std::string *)((char *)&v33 + 4));
    *((_BYTE *)v21 + 88) = v35;
    sub_1002A576C((uint64_t)(v21 + 12), (uint64_t)&v35 + 8);
    *((_BYTE *)v21 + 112) = BYTE4(v37);
    sub_1002A576C((uint64_t)(v21 + 15), (uint64_t)&v38[4]);
    *((_BYTE *)v21 + 136) = v39;
    sub_1002A576C((uint64_t)(v21 + 18), (uint64_t)&v40);
    *((_BYTE *)v21 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v42;
    sub_10032ABFC((uint64_t)&v30);
    sub_10032AB04((uint64_t)&v30, 3);
    int v28 = 3;
    __int16 v29 = &v28;
    uint64_t v22 = sub_100BF9F30(a1 + 200, &v28, (uint64_t)&unk_1012CF090, &v29);
    *((_DWORD *)v22 + 6) = v30;
    std::string::operator=((std::string *)(v22 + 4), &v31);
    *((_BYTE *)v22 + 56) = v32;
    std::string::operator=((std::string *)(v22 + 8), (const std::string *)((char *)&v33 + 4));
    *((_BYTE *)v22 + 88) = v35;
    sub_1002A576C((uint64_t)(v22 + 12), (uint64_t)&v35 + 8);
    *((_BYTE *)v22 + 112) = BYTE4(v37);
    sub_1002A576C((uint64_t)(v22 + 15), (uint64_t)&v38[4]);
    *((_BYTE *)v22 + 136) = v39;
    sub_1002A576C((uint64_t)(v22 + 18), (uint64_t)&v40);
    *((_BYTE *)v22 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v42;
    sub_10032ABFC((uint64_t)&v30);
    LODWORD(v29) = 1;
    uint64_t v30 = (uint64_t)&v29;
    *((_DWORD *)sub_1007839D4(a1 + 272, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = 11;
    LODWORD(v29) = 1;
    uint64_t v30 = (uint64_t)&v29;
    *((_DWORD *)sub_1007839D4(v26, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = -1;
    LODWORD(v29) = 1;
    uint64_t v30 = (uint64_t)&v29;
    *((_DWORD *)sub_1007839D4(v25, (int *)&v29, (uint64_t)&unk_1012CF090, (_DWORD **)&v30) + 5) = -1;
  }

  id v23 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo"), "newTimer");
  *(void *)(a1 + 136) = v23;
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = sub_100BF1770;
  v27[3] = &unk_10181D3D0;
  v27[4] = a1;
  [v23 setHandler:v27];
  *(void *)(a1 + 60sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:",  @"CLAnalyticsLogger");
  return a1;
}

void sub_100BF105C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v30 = v25[74];
  v25[74] = 0LL;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  std::string v31 = (void *)v25[73];
  v25[73] = 0LL;
  if (v31) {
    operator delete(v31);
  }
  sub_100BF9A88(a10, 0LL);
  int v32 = (void *)v25[70];
  v25[70] = 0LL;
  if (v32) {
    operator delete(v32);
  }
  uint64_t v33 = v25[68];
  v25[68] = 0LL;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
  }
  uint64_t v34 = *v28;
  *int v28 = 0LL;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8LL))(v34);
  }
  sub_100019CEC(v24 + 272);
  sub_100019CEC(a23);
  sub_100019CEC(v24 + 192);
  sub_100019CEC(a24);
  sub_1002DDBC0(v24 + 112);
  sub_100019CEC(v27);
  sub_100BF9B28(v24);
  sub_100BF9AB4(v26);
  sub_100008390(a11, *a12);
  _Unwind_Resume(a1);
}

void sub_100BF120C(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101877958);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLEmergencyController::onDaemonStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101877958);
    }
    id v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLEmergencyController::onDaemonStatusNotification, event:%{public, location:escape_ only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100BF2A48(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100BF13C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BF13E4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101877958);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLEmergencyController::onClientNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101877958);
    }
    id v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLEmergencyController::onClientNotification, event:%{public, location:escape_only}s , this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100BF2E78(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100BF159C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BF15BC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_BYTE *)(a1 + 8) = *((_BYTE *)a2 + 8);
  *(void *)a1 = v4;
  __int128 v6 = *((_OWORD *)a2 + 5);
  __int128 v5 = *((_OWORD *)a2 + 6);
  __int128 v7 = *((_OWORD *)a2 + 4);
  *(void *)(a1 + 112) = a2[14];
  *(_OWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v6;
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 64) = v7;
  __int128 v8 = *((_OWORD *)a2 + 1);
  __int128 v9 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + memset(v19, 0, 48) = v9;
  *(_OWORD *)(a1 + 16) = v8;
  sub_100BF6C88(a1 + 120, (__int128 *)(a2 + 15));
  id v10 = (void **)(a1 + 944);
  __int128 v11 = *((_OWORD *)a2 + 59);
  *(void *)(a1 + 96sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2[120];
  *(_OWORD *)id v10 = v11;
  *((_BYTE *)a2 + 967) = 0;
  *((_BYTE *)a2 + 944) = 0;
  uint64_t v12 = (void **)(a1 + 968);
  __int128 v13 = *(_OWORD *)(a2 + 121);
  *(void *)(a1 + 984) = a2[123];
  *(_OWORD *)uint64_t v12 = v13;
  *((_BYTE *)a2 + 991) = 0;
  *((_BYTE *)a2 + 968) = 0;
  int v14 = *((_DWORD *)a2 + 250);
  *(void *)(a1 + 992) = a2[124];
  *(_DWORD *)(a1 + 100sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v14;
  uint64_t v15 = a2[132];
  __int128 v16 = *((_OWORD *)a2 + 65);
  __int128 v17 = *((_OWORD *)a2 + 64);
  *(_OWORD *)(a1 + 1008) = *((_OWORD *)a2 + 63);
  *(_OWORD *)(a1 + 1024) = v17;
  *(_OWORD *)(a1 + 104sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v16;
  *(void *)(a1 + 1056) = v15;
  __int16 v18 = (void **)(a1 + 1064);
  __int128 v19 = *(_OWORD *)(a2 + 133);
  *(void *)(a1 + 108sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2[135];
  *(_OWORD *)__int16 v18 = v19;
  *((_BYTE *)a2 + 1087) = 0;
  *((_BYTE *)a2 + 1064) = 0;
  uint64_t v20 = (void **)(a1 + 1088);
  __int128 v21 = *((_OWORD *)a2 + 68);
  *(void *)(a1 + 1104) = a2[138];
  *(_OWORD *)uint64_t v20 = v21;
  *((_BYTE *)a2 + 1111) = 0;
  *((_BYTE *)a2 + 1088) = 0;
  uint64_t v22 = (void **)(a1 + 1112);
  __int128 v23 = *(_OWORD *)(a2 + 139);
  *(void *)(a1 + 11sub_100231C10(v1 + 28) = a2[141];
  *(_OWORD *)uint64_t v22 = v23;
  *((_BYTE *)a2 + 1135) = 0;
  *((_BYTE *)a2 + 1112) = 0;
  uint64_t v24 = (void **)(a1 + 1136);
  __int128 v25 = *((_OWORD *)a2 + 71);
  *(void *)(a1 + 1152) = a2[144];
  *(_OWORD *)uint64_t v24 = v25;
  *((_BYTE *)a2 + 1159) = 0;
  *((_BYTE *)a2 + 1136) = 0;
  return a1;
}

void sub_100BF1770(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  id v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#Warning #EmergCon call connect timeout fired",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EmergCon call connect timeout fired",  v5,  2);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyController::CLEmergencyController(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_100BF1924((id *)v1);
  *(_BYTE *)(v1 + 68) = 1;
  sub_100BF1AD0(v1, *(_DWORD *)(v1 + 64));
  sub_100BF1E7C(v1);
}

id *sub_100BF1924(id *result)
{
  if (*((_BYTE *)result + 144))
  {
    uint64_t v1 = result;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EmergCon clearing call connect timeout",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      v5[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon clearing call connect timeout",  v5,  2);
      uint64_t v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::clearCallConnectTimeout()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }

    uint64_t result = (id *)[v1[17] setNextFireDelay:1.79769313e308];
    *((_BYTE *)v1 + 144) = 0;
  }

  return result;
}

void sub_100BF1AD0(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  if (*(_DWORD *)(a1 + 60) == a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)uint64_t buf = 67109376;
      int v23 = v5;
      __int16 v24 = 1024;
      LODWORD(v25) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,newState,ignoring,fEmergencyStateOld,%d,state,%d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      int v6 = *(_DWORD *)(a1 + 60);
      LODWORD(__p) = 67109376;
      HIDWORD(__p) = v6;
      __int16 v19 = 1024;
      unsigned int v20 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,newState,ignoring,fEmergencyStateOld,%d,state,%d",  &__p,  14);
      __int128 v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::newState(EmergencyState)", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    return;
  }

  if (*(_BYTE *)(a1 + 69)) {
    BOOL v9 = a2 > 0xA;
  }
  else {
    BOOL v9 = 1;
  }
  BOOL v10 = v9 || ((1 << a2) & 0x442) == 0;
  if (v10 || *(_BYTE *)(a1 + 68))
  {
    *(_DWORD *)(a1 + 6sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v11 = qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BF3898(a2, &__p);
      if (v21 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)uint64_t buf = 68289794;
      int v23 = 0;
      __int16 v24 = 2082;
      __int128 v25 = "";
      __int16 v26 = 2082;
      *(void *)uint64_t v27 = "newState";
      *(_WORD *)&v27[8] = 1026;
      *(_DWORD *)&_BYTE v27[10] = a2;
      __int16 v28 = 2082;
      __int16 v29 = p_p;
      __int128 v13 = "{msg%{public}.0s:#EmergCon E911Event, event:%{public, location:escape_only}s, Emergency: state"
            ":%{public}d, Emergency: StringifiedState:%{public, location:escape_only}s}";
      int v14 = (os_log_s *)v11;
      uint32_t v15 = 44;
      goto LABEL_26;
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v16 = qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BF3898(a2, &__p);
      if (v21 >= 0) {
        __int128 v17 = &__p;
      }
      else {
        __int128 v17 = __p;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      int v23 = 0;
      __int16 v24 = 2082;
      __int128 v25 = "";
      __int16 v26 = 1026;
      *(_DWORD *)uint64_t v27 = a2;
      *(_WORD *)&v27[4] = 2082;
      *(void *)&v27[6] = v17;
      __int128 v13 = "{msg%{public}.0s:#EmergCon delaying emergency state until call connects, state:%{public}d, Str"
            "ingifiedState:%{public, location:escape_only}s}";
      int v14 = (os_log_s *)v16;
      uint32_t v15 = 34;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
      if (v21 < 0) {
        operator delete(__p);
      }
    }
  }

void sub_100BF1E7C(uint64_t a1)
{
  __int128 v25 = *(_OWORD *)(a1 + 92);
  int v26 = *(_DWORD *)(a1 + 108);
  sub_100983060((uint64_t)v27, (unsigned __int8 *)&v25, *(unsigned __int8 *)(a1 + 56));
  if (*(_DWORD *)v27 == *(_DWORD *)(a1 + 72)
    && *(void *)&v27[4] == *(void *)(a1 + 76)
    && *(void *)&v27[12] == *(void *)(a1 + 84))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      sub_100982BDC(v27, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v29 = 2082;
      *(void *)&v29[2] = "";
      *(_WORD *)&v29[10] = 2082;
      *(void *)&v29[12] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon,updateEmergencyState,ignoring as it is same as current state, state:%{pub lic, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_100BF1924((id *)a1);
  }

  else
  {
    if (sub_1009830A8((uint64_t)v27))
    {
      if (!*(_BYTE *)(a1 + 134))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101877978);
        }
        uint64_t v4 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EmergCon,updateEmergencyState,emergency call not active but CT in voice emergency",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101877978);
          }
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EmergCon,updateEmergencyState,emergency call not active but CT in voice emergency",  &__p,  2);
          __int16 v19 = (uint8_t *)v18;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::updateEmergencyState()", "%s\n", v18);
          if (v19 != buf) {
            free(v19);
          }
        }

        sub_100BF48F8(a1);
      }
    }

    else
    {
      sub_100BF2498(a1);
    }

    if (*(_BYTE *)(a1 + 69) && sub_100983064((uint64_t)v27) && !*(_BYTE *)(a1 + 68))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      uint64_t v16 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        sub_100982BDC(v27, &__p);
        __int128 v17 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int16 v29 = 2082;
        *(void *)&v29[2] = "";
        *(_WORD *)&v29[10] = 2082;
        *(void *)&v29[12] = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon,updateEmergencyState,delaying emergency state until call connects, State :%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

      sub_100BF4CCC((id *)a1);
    }

    else
    {
      sub_100BF1924((id *)a1);
      BOOL v5 = sub_1009830FC((uint64_t)v27);
      sub_100BF3540((unsigned __int8 *)a1, !v5);
      BOOL v6 = sub_1009830C8(a1 + 72);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)v27;
      *(_DWORD *)(a1 + 88) = *(_DWORD *)&v27[16];
      BOOL v7 = sub_1009830C8(a1 + 72);
      if (!v6 || v7)
      {
        if (!v6 && v7) {
          sub_100BF3E68(a1);
        }
      }

      else
      {
        sub_100BF4734(a1);
      }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      __int128 v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        sub_100982BDC(v27, &__p);
        BOOL v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int16 v29 = 2082;
        *(void *)&v29[2] = "";
        *(_WORD *)&v29[10] = 2082;
        *(void *)&v29[12] = "newStateClass";
        *(_WORD *)&v29[20] = 2082;
        *(void *)&v29[22] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon E911Event, event:%{public, location:escape_only}s, Emergency: Stringi fiedState:%{public, location:escape_only}s}",  buf,  0x26u);
      }

      BOOL v10 = *(void **)(a1 + 16);
      if (v10 != (void *)(a1 + 24))
      {
        do
        {
          uint64_t v11 = (void *)v10[4];
          *(_OWORD *)&v29[24] = *(_OWORD *)v27;
          int v30 = *(_DWORD *)&v27[16];
          *(void *)uint64_t buf = _NSConcreteStackBlock;
          *(void *)__int16 v29 = 3221225472LL;
          *(void *)&void v29[8] = sub_100BFA354;
          *(void *)&v29[16] = &unk_101877A48;
          objc_msgSend(v11, "emergencyStateChange:", -[uint8_t copy](buf, "copy"));
          uint64_t v12 = (void *)v10[1];
          if (v12)
          {
            do
            {
              __int128 v13 = v12;
              uint64_t v12 = (void *)*v12;
            }

            while (v12);
          }

          else
          {
            do
            {
              __int128 v13 = (void *)v10[2];
              BOOL v14 = *v13 == (void)v10;
              BOOL v10 = v13;
            }

            while (!v14);
          }

          BOOL v10 = v13;
        }

        while (v13 != (void *)(a1 + 24));
      }

      uint64_t v15 = *(void *)(a1 + 576);
      __int128 v22 = *(_OWORD *)v27;
      int v23 = *(_DWORD *)&v27[16];
      sub_100F99624(v15, &v22);
      __int128 v20 = *(_OWORD *)v27;
      int v21 = *(_DWORD *)&v27[16];
      sub_100BF4E98(a1, &v20);
    }
  }

void sub_100BF2498(uint64_t a1)
{
  id v2 = *(void **)(a1 + 152);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 152) = 0LL;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,clearLongEemTimeout,timer cleared",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      LOWORD(v7[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,clearLongEemTimeout,timer cleared",  v7,  2,  v7[0]);
LABEL_19:
      BOOL v6 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::clearLongEemTimeout()", "%s\n", v4);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    BOOL v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,clearLongEemTimeout,no timer exists",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      LOWORD(v7[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,clearLongEemTimeout,no timer exists",  v7,  2,  v7[0]);
      goto LABEL_19;
    }
  }

void *sub_100BF270C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_101878180[a1]);
}

void *sub_100BF2720@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_1018781C0[a1]);
}

uint64_t sub_100BF2734(uint64_t a1)
{
  uint64_t v1 = sub_100BF294C(a1);
  uint64_t result = 0LL;
  switch((int)v1)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      uint64_t result = v1;
      break;
    case 9:
    case 10:
    case 11:
    case 15:
      uint64_t result = 3LL;
      break;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      id v3 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#EmergCon,mapCallTriggerType,invalid enum value",  buf,  2u);
      }

      BOOL v4 = sub_1002921D0(115, 0);
      uint64_t result = 0LL;
      if (v4)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101877978);
        }
        v7[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EmergCon,mapCallTriggerType,invalid enum value",  v7,  2);
        BOOL v6 = (uint8_t *)v5;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "static Emergency::CallTriggerType CLEmergencyController::mapCallTriggerType(EmergencyTriggerType)",  "%s\n",  v5);
        if (v6 != buf) {
          free(v6);
        }
        uint64_t result = 0LL;
      }

      break;
    default:
      return result;
  }

  return result;
}

uint64_t sub_100BF294C(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1 <= 0x12
    && ((1 << a1) & 0x60E80) != 0
    && (!objc_opt_class(&OBJC_CLASS___MCProfileConnection)
     || (objc_msgSend( +[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"),  "isSafetyDataSubmissionAllowed") & 1) == 0))
  {
    return 15LL;
  }

  return v1;
}

id sub_100BF29B0(uint64_t *a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768LL;
  void v3[2] = sub_100BFA334;
  v3[3] = &unk_101877A18;
  sub_100BF71B4((uint64_t)v4, a1);
  id v1 = [v3 copy];
  sub_100BF6F74((uint64_t)v4);
  return v1;
}

void sub_100BF2A34(_Unwind_Exception *a1)
{
}

void sub_100BF2A48(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v6 = *a3;
  if (*a3 == 6)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    BOOL v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v10 = *(unsigned int *)(a4 + 4);
      *(_DWORD *)uint64_t buf = 134349056;
      *(void *)__int16 v24 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#EmergCon,onDaemonStatusNotification,kNotificationReachability,[%{public}ld]",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      __int16 v18 = (const char *)*(unsigned int *)(a4 + 4);
      int v21 = 134349056;
      __int128 v22 = v18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EmergCon,onDaemonStatusNotification,kNotificationReachability,[%{public}ld]",  &v21,  12);
      __int128 v20 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLD aemonStatus_Type::NotificationData &)",  "%s\n",  v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    uint64_t v11 = *(unsigned int *)(a4 + 4);
    *(_DWORD *)(a1 + 512) = v11;
    sub_100F9A7B0(*(void *)(a1 + 576), v11);
  }

  else if (v6 == 7)
  {
    *(_DWORD *)(a1 + 524) = *(_DWORD *)(a4 + 12);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a4 + 12);
      int v14 = (int)*(double *)a4;
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)__int16 v24 = 0;
      *(_WORD *)&v24[4] = 2082;
      *(void *)&void v24[6] = "";
      __int16 v25 = 1025;
      int v26 = v13;
      __int16 v27 = 1026;
      int v28 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon,onDaemonStatusNotification, chargerType:%{private}d, batteryLevel:%{public}d}",  buf,  0x1Eu);
    }

    sub_100F9A520(*(void *)(a1 + 576), a4);
  }

  else if (v6 == 11)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    BOOL v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      if (*(_BYTE *)a4) {
        __int128 v8 = "locked";
      }
      else {
        __int128 v8 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)__int16 v24 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#EmergCon,onDaemonStatusNotification,kNotificationLockScreen,display [%{public}s]",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      if (*(_BYTE *)a4) {
        uint64_t v15 = "locked";
      }
      else {
        uint64_t v15 = "unlocked";
      }
      int v21 = 136446210;
      __int128 v22 = v15;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EmergCon,onDaemonStatusNotification,kNotificationLockScreen,display [%{public}s]",  &v21,  12);
      __int128 v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLD aemonStatus_Type::NotificationData &)",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    *(_BYTE *)(a1 + 5sub_100231C10(v1 + 28) = *(_BYTE *)a4;
  }

void sub_100BF2E78(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 4)
  {
    int v5 = *(_DWORD *)(a4 + 188);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    int v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 68289282;
      v7[1] = 0;
      __int16 v8 = 2082;
      BOOL v9 = "";
      __int16 v10 = 1026;
      BOOL v11 = v5 == 1;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon Location Services status change, enabled:%{public}hhd}",  (uint8_t *)v7,  0x18u);
    }

    sub_100F9A1CC(*(void *)(a1 + 576), v5 == 1);
  }

CLOSTransaction *sub_100BF2F8C(uint64_t a1)
{
  if (*(void *)(a1 + 552))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "#EmergCon Creating new transaction without releasing previous one",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#EmergCon Creating new transaction without releasing previous one",  v10,  2);
      __int16 v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyController::createTransaction()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    sub_100BF3270(a1);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  id v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EmergCon Creating os transaction CLEmergency",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v10[0] = 0;
    LODWORD(v9) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon Creating os transaction CLEmergency",  v10,  v9);
    int v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::createTransaction()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t result = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLEmergency");
  *(void *)(a1 + 552) = result;
  return result;
}

void sub_100BF3270(uint64_t a1)
{
  if (*(void *)(a1 + 552))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EmergCon Release os transaction CLEmergency",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon Release os transaction CLEmergency",  v8,  2);
      int v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::releaseTransaction()", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }

    *(void *)(a1 + 552) = 0LL;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#EmergCon Attempt to release transaction that was already released",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EmergCon Attempt to release transaction that was already released",  v8,  2);
      BOOL v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyController::releaseTransaction()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

void sub_100BF3540(unsigned __int8 *a1, int a2)
{
  if (*a1 == a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    BOOL v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *a1;
      *(_DWORD *)uint64_t buf = 67109376;
      int v19 = v5;
      __int16 v20 = 1024;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EmergCon setCLEEA,Current,%d,New,%d,ignoring",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      int v6 = *a1;
      int v14 = 67109376;
      int v15 = v6;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon setCLEEA,Current,%d,New,%d,ignoring",  &v14,  14);
      __int16 v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::setCLEEA(BOOL)", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *a1;
      *(_DWORD *)uint64_t buf = 67109376;
      int v19 = v10;
      __int16 v20 = 1024;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EmergCon setCLEEA,Current,%d,New,%d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      int v11 = *a1;
      int v14 = 67109376;
      int v15 = v11;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon setCLEEA,Current,%d,New,%d",  &v14,  14);
      int v13 = (uint8_t *)v12;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::setCLEEA(BOOL)", "%s\n", v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    *a1 = a2;
    objc_msgSend( objc_msgSend(objc_msgSend(*((id *)a1 + 1), "vendor"), "proxyForService:", @"CLClientManager"),  "markClientEmergencyEnablementTransition:",  *a1);
  }

void *sub_100BF3898@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 0xE) {
    id v2 = "UnknownState";
  }
  else {
    id v2 = off_101878260[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

id sub_100BF38C4(uint64_t a1, int a2)
{
  id result = (id)sub_1001B9A1C();
  if ((_DWORD)result)
  {
    id v5 = *(id *)(a1 + 568);
    if (a2)
    {
      if (!v5)
      {
        id v5 =  objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:forClient:",  @"CLStreamingAwareLocationProvider",  @"CLEmergencyController");
        *(void *)(a1 + 568) = v5;
      }

      return [v5 takeAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN withDesiredAccuracy:-1.0];
    }

    else
    {
      return [v5 releaseAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN];
    }
  }

  return result;
}

void sub_100BF3950()
{
  if (!v0) {
    return;
  }
  sub_1002F0B04(buf);
  int v1 = sub_1002A6F64(*(uint64_t *)buf, "EmergencyUnpickAirPlayRoutesEnabled", v10);
  if (v10[0]) {
    int v2 = 0;
  }
  else {
    int v2 = v1;
  }
  id v3 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
      if (v2) {
        goto LABEL_10;
      }
LABEL_20:
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
      dispatch_async(global_queue, &stru_101877938);
      return;
    }
  }

  if (!v2) {
    goto LABEL_20;
  }
LABEL_10:
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  int v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,unpick AirPlay routes is disabled",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    *(_WORD *)int v10 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,unpick AirPlay routes is disabled",  v10,  2);
    __int16 v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::unpickAirPlayRoutes()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

void sub_100BF3B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100BF3B84(id a1)
{
  uint64_t v9 = 0LL;
  id v1 = +[AVSystemController sharedAVSystemController](&OBJC_CLASS___AVSystemController, "sharedAVSystemController");
  if ([v1 setAttribute:&__kCFBooleanTrue forKey:AVSystemController_RouteAwayFromAirPlayAttribute error:&v9])
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    int v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,successfully unpicked AirPlay routes",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      LOWORD(v1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
      double v3 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,successfully unpicked AirPlay routes",  &v10,  2);
      unint64_t v5 = v4;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::unpickAirPlayRoutes()_block_invoke",  "%s\n",  v3);
LABEL_19:
      if (v5 != buf) {
        free(v5);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    int v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 138543362;
      uint64_t v13 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#EmergCon,error unpicking AirPlay routes,%{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      int v10 = 138543362;
      uint64_t v11 = v9;
      double v7 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EmergCon,error unpicking AirPlay routes,%{public}@",  &v10,  12);
      unint64_t v5 = v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyController::unpickAirPlayRoutes()_block_invoke",  "%s\n",  v7);
      goto LABEL_19;
    }
  }

id sub_100BF3E68(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  int v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,EnterEmergency", (uint8_t *)buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    LOWORD(v25.__r_.__value_.__l.__data_) = 0;
    LODWORD(v24) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,EnterEmergency",  &v25,  v24);
    uint64_t v13 = (std::stringbuf::string_type *)v12;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::enterEmergency()", "%s\n", v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  double v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = 0;
    buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v26;
    BOOL v4 = sub_100BF9B9C(a1 + 160, &v26, (uint64_t)&unk_1012CF090, buf);
    sub_100BF44A8((unsigned __int8 *)v4 + 24, buf);
    unint64_t v5 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
       ? buf
       : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
    LODWORD(v25.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EmgContext,repeating current settings for sim 1,%{private}s",  (uint8_t *)&v25,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v14 = qword_101934898;
    HIDWORD(v24) = 0;
    v25.__r_.__value_.__r.__words[0] = (std::string::size_type)&v24 + 4;
    int v15 = sub_100BF9B9C(a1 + 160, (int *)&v24 + 1, (uint64_t)&unk_1012CF090, &v25);
    sub_100BF44A8((unsigned __int8 *)v15 + 24, &v25);
    if ((v25.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v16 = &v25;
    }
    else {
      __int16 v16 = (std::stringbuf::string_type *)v25.__r_.__value_.__r.__words[0];
    }
    int v26 = 136380675;
    __int16 v27 = v16;
    LODWORD(v24) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  0LL,  "#EmgContext,repeating current settings for sim 1,%{private}s",  &v26,  v24);
    __int16 v18 = v17;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::enterEmergency()", "%s\n", (const char *)v18);
    if (v18 != buf) {
      free(v18);
    }
  }

  if (*(_BYTE *)(a1 + 133))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    int v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = 1;
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v26;
      double v7 = sub_100BF9B9C(a1 + 160, &v26, (uint64_t)&unk_1012CF090, buf);
      sub_100BF44A8((unsigned __int8 *)v7 + 24, buf);
      __int16 v8 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? buf
         : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
      LODWORD(v25.__r_.__value_.__l.__data_) = 136380675;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EmgContext,repeating current settings for sim 2,%{private}s",  (uint8_t *)&v25,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      uint64_t v19 = qword_101934898;
      HIDWORD(v24) = 1;
      v25.__r_.__value_.__r.__words[0] = (std::string::size_type)&v24 + 4;
      __int16 v20 = sub_100BF9B9C(a1 + 160, (int *)&v24 + 1, (uint64_t)&unk_1012CF090, &v25);
      sub_100BF44A8((unsigned __int8 *)v20 + 24, &v25);
      if ((v25.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v21 = &v25;
      }
      else {
        int v21 = (std::stringbuf::string_type *)v25.__r_.__value_.__r.__words[0];
      }
      int v26 = 136380675;
      __int16 v27 = v21;
      LODWORD(v24) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v19,  0LL,  "#EmgContext,repeating current settings for sim 2,%{private}s",  &v26,  v24);
      int v23 = v22;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::enterEmergency()", "%s\n", (const char *)v23);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v9 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(unsigned __int8 *)(a1 + 56);
    buf[0].__r_.__value_.__r.__words[0] = 68289282LL;
    LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(buf[0].__r_.__value_.__r.__words[2]) = 1026;
    HIDWORD(buf[0].__r_.__value_.__r.__words[2]) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmgContext, CleeaAsserted:%{public}d}",  (uint8_t *)buf,  0x18u);
  }

  sub_100BF2F8C(a1);
  sub_100BF38C4(a1, 1);
  sub_100BF3950();
  return [*(id *)(a1 + 40) setE911Active:1];
}

uint64_t sub_100BF44A8@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  BOOL v4 = sub_10000CF44(&v30, (uint64_t)"ins,", 4LL);
  unint64_t v5 = (void *)std::ostream::operator<<(v4, *(unsigned int *)a1);
  int v6 = sub_10000CF44(v5, (uint64_t)",Location", 9LL);
  double v7 = sub_10000CF44(v6, (uint64_t)",enableCpiDuringEmergencyMode,", 30LL);
  __int16 v8 = (void *)std::ostream::operator<<(v7, a1[4]);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",enableEarlyReturnDuringEmergencyMode,", 38LL);
  int v10 = (void *)std::ostream::operator<<(v9, a1[5]);
  uint64_t v11 = sub_10000CF44(v10, (uint64_t)",allowOTDOADuringEmergencyMode,", 31LL);
  uint64_t v12 = (void *)std::ostream::operator<<(v11, a1[6]);
  uint64_t v13 = sub_10000CF44(v12, (uint64_t)",EmergencyLocation,", 19LL);
  sub_100BF7AC4((uint64_t)(a1 + 16), &v28);
  if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v14 = &v28;
  }
  else {
    uint64_t v14 = (std::stringbuf::string_type *)v28.__r_.__value_.__r.__words[0];
  }
  if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v28.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v28.__r_.__value_.__l.__size_;
  }
  __int16 v16 = sub_10000CF44(v13, (uint64_t)v14, size);
  int v17 = sub_10000CF44(v16, (uint64_t)",SUPL,", 6LL);
  sub_100BF7D50((uint64_t)(a1 + 944), &v27);
  if ((v27.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int16 v18 = &v27;
  }
  else {
    __int16 v18 = (std::stringbuf::string_type *)v27.__r_.__value_.__r.__words[0];
  }
  if ((v27.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v19 = v27.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v19 = v27.__r_.__value_.__l.__size_;
  }
  __int16 v20 = sub_10000CF44(v17, (uint64_t)v18, v19);
  int v21 = sub_10000CF44(v20, (uint64_t)",BAA,", 5LL);
  sub_100BF621C(a1 + 1008, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v23 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v23 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v21, (uint64_t)p_p, v23);
  std::stringbuf::str(a2, &v31);
  *(void *)((char *)v29
  uint64_t v30 = v24;
  std::streambuf::~streambuf(&v31);
  return std::ios::~ios(&v32);
}

void sub_100BF46CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_1011F8850((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_100BF4734(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  int v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EmergCon,ExitEmergency", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,ExitEmergency",  v5,  2);
    BOOL v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::exitEmergency()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  [*(id *)(a1 + 40) setE911Active:0];
  *(_BYTE *)(a1 + 68) = 0;
  sub_100BF3270(a1);
}

void sub_100BF48F8(uint64_t a1)
{
  if (*(void *)(a1 + 152))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    id v1 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,createLongEemTimeout,timer already exists",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      *(_WORD *)uint64_t v14 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,createLongEemTimeout,timer already exists",  v14,  2);
      double v3 = (char *)v2;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::createLongEemTimeout()", "%s\n", v2);
LABEL_30:
    }
  }

  else
  {
    else {
      unsigned int v5 = vcvtpd_u64_f64(sub_101171D4C() - *(double *)(a1 + 256));
    }
    *(_DWORD *)(a1 + 264) = v5;
    id v6 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo"), "newTimer");
    *(void *)(a1 + 152) = v6;
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    v13[2] = sub_100BF5570;
    void v13[3] = &unk_10181D3D0;
    v13[4] = a1;
    [v6 setHandler:v13];
    sub_1002F0B04(buf);
    else {
      double v7 = 420.0;
    }
    __int16 v8 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
    if (*((void *)&buf[0] + 1))
    {
      uint64_t v9 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    [*(id *)(a1 + 152) setNextFireDelay:v7];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 134349056;
      *(double *)((char *)buf + 4) = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,createLongEemTimeout,started timer for %{public}f",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      *(_DWORD *)uint64_t v14 = 134349056;
      *(double *)&_DWORD v14[4] = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,createLongEemTimeout,started timer for %{public}f",  v14,  12);
      double v3 = (char *)v12;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::createLongEemTimeout()", "%s\n", v12);
      goto LABEL_30;
    }
  }

void sub_100BF4CB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id *sub_100BF4CCC(id *result)
{
  if (!*((_BYTE *)result + 144))
  {
    id v1 = result;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    int v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      uint64_t v8 = 0x4034000000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EmergCon setting call connect timeout for %{public}f s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      int v5 = 134349056;
      uint64_t v6 = 0x4034000000000000LL;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon setting call connect timeout for %{public}f s",  &v5,  12);
      BOOL v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyController::initCallConnectTimeout()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }

    id result = (id *)[v1[17] setNextFireDelay:20.0];
    *((_BYTE *)v1 + 144) = 1;
  }

  return result;
}

void sub_100BF4E98(uint64_t a1, _DWORD *a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  BOOL v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    sub_100982BDC(a2, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(void *)uint64_t buf = 68289282LL;
    *(_WORD *)int v17 = 2082;
    *(void *)&v17[2] = "";
    __int16 v18 = 2082;
    uint64_t v19 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmergCon logCommType, Emergency: StringifiedState:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  if (!sub_1009830C8((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)int v17 = 0;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__l.__cap_ = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100783D5C( (uint64_t)&__p.__r_.__value_.__l.__cap_,  (uint64_t)buf,  (uint64_t)&v21,  (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_10043AFF4((uint64_t)v17);
    uint64_t v8 = *(void **)(a1 + 600);
    memset(v12, 0, sizeof(v12));
    sub_10043BC44( v12,  (uint64_t)__p.__r_.__value_.__l.__data_,  __p.__r_.__value_.__l.__size_,  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v8 setMeasurements:sub_100435878(v12)];
    double v7 = v12;
    goto LABEL_13;
  }

  if (sub_1009830A8((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)int v17 = 1;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__l.__cap_ = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100783D5C( (uint64_t)&__p.__r_.__value_.__l.__cap_,  (uint64_t)buf,  (uint64_t)&v21,  (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_10043AFF4((uint64_t)v17);
    uint64_t v6 = *(void **)(a1 + 600);
    memset(v11, 0, sizeof(v11));
    sub_10043BC44( v11,  (uint64_t)__p.__r_.__value_.__l.__data_,  __p.__r_.__value_.__l.__size_,  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v6 setMeasurements:sub_100435878(v11)];
    double v7 = v11;
LABEL_13:
    *(void *)uint64_t buf = v7;
    sub_10043B844((void ***)buf);
    *(void *)uint64_t buf = &__p;
    sub_10043B844((void ***)buf);
    return;
  }

  if (sub_1009830B8((uint64_t)a2))
  {
    *(_DWORD *)uint64_t buf = 77;
    *(_DWORD *)int v17 = 2;
    int v20 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v14 = &__p;
    char v15 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__l.__cap_ = __p.__r_.__value_.__r.__words[0] + 40;
    __p.__r_.__value_.__l.__size_ = sub_100783D5C( (uint64_t)&__p.__r_.__value_.__l.__cap_,  (uint64_t)buf,  (uint64_t)&v21,  (uint64_t)__p.__r_.__value_.__l.__data_);
    sub_10043AFF4((uint64_t)v17);
    uint64_t v9 = *(void **)(a1 + 600);
    memset(v10, 0, sizeof(v10));
    sub_10043BC44( v10,  (uint64_t)__p.__r_.__value_.__l.__data_,  __p.__r_.__value_.__l.__size_,  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3));
    [v9 setMeasurements:sub_100435878(v10)];
    double v7 = v10;
    goto LABEL_13;
  }

void sub_100BF5210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  *(void *)(v18 - 96) = &a18;
  sub_10043B844((void ***)(v18 - 96));
  _Unwind_Resume(a1);
}

void sub_100BF528C(uint64_t a1, int a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  BOOL v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v13 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,updateCleeaEmergencyState,state,%d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v11[0] = 67109120;
    v11[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,updateCleeaEmergencyState,state,%d",  v11);
    uint64_t v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::updateCleeaEmergencyState(EmergencyState)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  int v5 = *(_DWORD *)(a1 + 60);
  if (v5 && v5 != 5)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EmergCon,skipping updateEmergencyState, do not clear telephony determined emergency state",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      LOWORD(v11[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon,skipping updateEmergencyState, do not clear telephony determined emergency state",  v11,  2);
      unint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::updateCleeaEmergencyState(EmergencyState)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

void sub_100BF5570(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  int v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "#EmergCon,longEemTimeout,longer than expected EEM detected",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EmergCon,longEemTimeout,longer than expected EEM detected",  v5,  2);
    BOOL v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyController::createLongEemTimeout()_block_invoke", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_100BF2498(v1);
  sub_100BF5710(v1);
}

void sub_100BF5710(uint64_t a1)
{
  uint64_t v2 = sub_100496E10((unsigned int *)(a1 + 72));
  int v14 = v2;
  *(_BYTE *)(a1 + 132) = 1;
  *(_BYTE *)(a1 + 92) = 0;
  *(void *)(a1 + 96) = 0x400000000LL;
  *(_WORD *)(a1 + 104) = 256;
  *(_DWORD *)(a1 + 108) = 255;
  sub_100BF1E7C(a1);
  double v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2),  @"simSlot");
  -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", @"Voice", @"communicationType");
  int v4 = sub_100BF294C(*(unsigned int *)(a1 + 244));
  sub_100BF2720(v4, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p),  @"callTriggerType");
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 264)),  @"callDuration");
  sub_100328ADC(a1 + 92, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v6 = &__p;
  }
  else {
    uint64_t v6 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v6),  @"emergencyModeRat");
  char v15 = &v14;
  double v7 = sub_1007839D4(a1 + 272, &v14, (uint64_t)&unk_1012CF090, &v15);
  sub_1011B92F4(*((_DWORD *)v7 + 5), &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v8 = &__p;
  }
  else {
    uint64_t v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8),  @"ratType");
  LODWORD(v15) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v15;
  sub_1007839D4(a1 + 352, (int *)&v15, (uint64_t)&unk_1012CF090, &__p);
  -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", @"Invalid", @"simCountry1");
  sub_100BF5BE4(a1, 0, 0, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v9 = &__p;
  }
  else {
    uint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9),  @"simBundleId1");
  LODWORD(v15) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v15;
  sub_1007839D4(a1 + 432, (int *)&v15, (uint64_t)&unk_1012CF090, &__p);
  -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", @"Invalid", @"operatorCountry1");
  sub_100BF5BE4(a1, 0, 1, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v10 = &__p;
  }
  else {
    unint64_t v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10),  @"operatorBundleId1");
  if (*(_BYTE *)(a1 + 133))
  {
    LODWORD(v15) = 1;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v15;
    sub_1007839D4(a1 + 352, (int *)&v15, (uint64_t)&unk_1012CF090, &__p);
    -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", @"Invalid", @"simCountry2");
    sub_100BF5BE4(a1, 1, 0, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11),  @"simBundleId2");
    LODWORD(v15) = 1;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v15;
    sub_1007839D4(a1 + 432, (int *)&v15, (uint64_t)&unk_1012CF090, &__p);
    -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", @"Invalid", @"operatorCountry2");
    sub_100BF5BE4(a1, 1, 1, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v12 = &__p;
    }
    else {
      uint64_t v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    -[NSMutableDictionary setValue:forKey:]( v3,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v12),  @"operatorBundleId2");
  }

  AnalyticsSendEvent(@"com.apple.locationd.emergency.long_eem", v3);
}

void sub_100BF5BA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef sub_100BF5BD8()
{
  return @"Invalid";
}

void sub_100BF5BE4(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, std::string *a4@<X8>)
{
  int v12 = a2;
  memset(&v11, 0, sizeof(v11));
  if (a3 == 1)
  {
    *(void *)uint64_t buf = &v12;
    int v5 = (const std::string *)(sub_100BF9B9C(a1 + 160, &v12, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 145);
    goto LABEL_5;
  }

  if (!a3)
  {
    *(void *)uint64_t buf = &v12;
    int v5 = (const std::string *)(sub_100BF9B9C(a1 + 160, &v12, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 139);
LABEL_5:
    std::string::operator=(&v11, v5);
    goto LABEL_11;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#EmergCon,getBundleId,unexpected bundle type",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v10[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EmergCon,getBundleId,unexpected bundle type",  v10,  2);
    uint64_t v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::string CLEmergencyController::getBundleId(SimInstance, BundleType)",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

void sub_100BF5E38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BF5E58(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 1) == a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    double v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1)) {
        int v4 = "locked";
      }
      else {
        int v4 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136446210;
      int v20 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#EmergCon NILR already %{public}s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      if (*(_BYTE *)(a1 + 1)) {
        int v5 = "locked";
      }
      else {
        int v5 = "unlocked";
      }
      int v17 = 136446210;
      uint64_t v18 = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon NILR already %{public}s",  &v17,  12);
      double v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::sendObserversNilrLockoutStatus(BOOL)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 1) = a2;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1)) {
        uint64_t v9 = "locked";
      }
      else {
        uint64_t v9 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136446210;
      int v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#EmergCon NILR %{public}s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101877978);
      }
      if (*(_BYTE *)(a1 + 1)) {
        int v14 = "locked";
      }
      else {
        int v14 = "unlocked";
      }
      int v17 = 136446210;
      uint64_t v18 = v14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EmergCon NILR %{public}s",  &v17,  12);
      __int16 v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyController::sendObserversNilrLockoutStatus(BOOL)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    unint64_t v10 = *(void **)(a1 + 16);
    if (v10 != (void *)(a1 + 24))
    {
      do
      {
        [(id)v10[4] shouldLockoutNilr:*(unsigned __int8 *)(a1 + 1)];
        std::string v11 = (void *)v10[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            std::string v11 = (void *)*v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            int v12 = (void *)v10[2];
            BOOL v13 = *v12 == (void)v10;
            unint64_t v10 = v12;
          }

          while (!v13);
        }

        unint64_t v10 = v12;
      }

      while (v12 != (void *)(a1 + 24));
    }
  }

uint64_t sub_100BF621C@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  int v4 = sub_10000CF44(&v22, (uint64_t)"#EED2,#BAA,Disabled,", 20LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",EEDEnabledOnly,", 16LL);
  double v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",CertValidityPeriod,", 20LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *((unsigned int *)a1 + 1));
  unint64_t v10 = sub_10000CF44(v9, (uint64_t)",NoCertRequestWindow,", 21LL);
  std::string v11 = (void *)std::ostream::operator<<(v10, *((unsigned int *)a1 + 2));
  int v12 = sub_10000CF44(v11, (uint64_t)",NoCertRetryWindow,", 19LL);
  BOOL v13 = (void *)std::ostream::operator<<(v12, *((unsigned int *)a1 + 3));
  int v14 = sub_10000CF44(v13, (uint64_t)",CertAvailableRequestWindowMin,", 31LL);
  char v15 = (void *)std::ostream::operator<<(v14, *((unsigned int *)a1 + 4));
  __int16 v16 = sub_10000CF44(v15, (uint64_t)",CertAvailableRequestWindowMax,", 31LL);
  int v17 = (void *)std::ostream::operator<<(v16, *((unsigned int *)a1 + 5));
  uint64_t v18 = sub_10000CF44(v17, (uint64_t)",CertAvailableRetryWindow,", 26LL);
  std::ostream::operator<<(v18, *((unsigned int *)a1 + 6));
  std::stringbuf::str(a2, &v23);
  *(void *)((char *)v21
  uint64_t v22 = v19;
  std::streambuf::~streambuf(&v23);
  return std::ios::~ios(&v24);
}

void sub_100BF638C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF63A0@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  int v4 = sub_10000CF44(&v39, (uint64_t)"enableMSAssisted,", 17LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",glonass,", 9LL);
  sub_100BF7F48(a1[1], v36);
  if ((v37 & 0x80u) == 0) {
    double v7 = v36;
  }
  else {
    double v7 = (void **)v36[0];
  }
  if ((v37 & 0x80u) == 0) {
    uint64_t v8 = v37;
  }
  else {
    uint64_t v8 = (uint64_t)v36[1];
  }
  uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
  unint64_t v10 = sub_10000CF44(v9, (uint64_t)",beidou,", 8LL);
  sub_100BF7F48(a1[5], v34);
  if ((v35 & 0x80u) == 0) {
    std::string v11 = v34;
  }
  else {
    std::string v11 = (void **)v34[0];
  }
  if ((v35 & 0x80u) == 0) {
    uint64_t v12 = v35;
  }
  else {
    uint64_t v12 = (uint64_t)v34[1];
  }
  BOOL v13 = sub_10000CF44(v10, (uint64_t)v11, v12);
  int v14 = sub_10000CF44(v13, (uint64_t)",galileo,", 9LL);
  sub_100BF7F48(a1[2], v32);
  if ((v33 & 0x80u) == 0) {
    char v15 = v32;
  }
  else {
    char v15 = (void **)v32[0];
  }
  if ((v33 & 0x80u) == 0) {
    uint64_t v16 = v33;
  }
  else {
    uint64_t v16 = (uint64_t)v32[1];
  }
  int v17 = sub_10000CF44(v14, (uint64_t)v15, v16);
  uint64_t v18 = sub_10000CF44(v17, (uint64_t)",qzss,", 6LL);
  sub_100BF7F48(a1[3], v30);
  if ((v31 & 0x80u) == 0) {
    uint64_t v19 = v30;
  }
  else {
    uint64_t v19 = (void **)v30[0];
  }
  if ((v31 & 0x80u) == 0) {
    uint64_t v20 = v31;
  }
  else {
    uint64_t v20 = (uint64_t)v30[1];
  }
  uint64_t v21 = sub_10000CF44(v18, (uint64_t)v19, v20);
  uint64_t v22 = sub_10000CF44(v21, (uint64_t)",lppRel13MeasSettings,", 22LL);
  sub_100BF819C(a1 + 6, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  std::stringbuf::string_type v25 = sub_10000CF44(v22, (uint64_t)p_p, size);
  int v26 = sub_10000CF44(v25, (uint64_t)",enableLocationSource,", 22LL);
  std::ostream::operator<<(v26, a1[9]);
  std::stringbuf::str(a2, &v40);
  *(void *)((char *)v38
  uint64_t v39 = v27;
  std::streambuf::~streambuf(&v40);
  return std::ios::~ios(&v41);
}

void sub_100BF662C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, char a39)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_1011F8850((uint64_t)&a39);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF66CC@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  int v4 = sub_10000CF44(&v14, (uint64_t)"provideHELOUnsolicited,", 23LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",timeStampSource,", 17LL);
  sub_100BF8530(*((_DWORD *)a1 + 1), __p);
  if ((v12 & 0x80u) == 0) {
    double v7 = __p;
  }
  else {
    double v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) == 0) {
    uint64_t v8 = v12;
  }
  else {
    uint64_t v8 = (uint64_t)__p[1];
  }
  sub_10000CF44(v6, (uint64_t)v7, v8);
  std::stringbuf::str(a2, &v15);
  *(void *)((char *)v13
  uint64_t v14 = v9;
  std::streambuf::~streambuf(&v15);
  return std::ios::~ios(&v16);
}

void sub_100BF67E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF6818@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  int v4 = sub_10000CF44(&v21, (uint64_t)"#AML,", 5LL);
  sub_100BF8758(a1, &v19);
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v5 = &v19;
  }
  else {
    int v5 = (std::stringbuf::string_type *)v19.__r_.__value_.__r.__words[0];
  }
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v19.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v19.__r_.__value_.__l.__size_;
  }
  double v7 = sub_10000CF44(v4, (uint64_t)v5, size);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",#EED2,", 7LL);
  sub_100BF8AD4((unsigned __int8 *)(a1 + 152), &v18);
  if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v9 = &v18;
  }
  else {
    uint64_t v9 = (std::stringbuf::string_type *)v18.__r_.__value_.__r.__words[0];
  }
  if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = v18.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v10 = v18.__r_.__value_.__l.__size_;
  }
  std::string v11 = sub_10000CF44(v8, (uint64_t)v9, v10);
  unsigned __int8 v12 = sub_10000CF44(v11, (uint64_t)",#EED2-sim,", 11LL);
  sub_100BF8AD4((unsigned __int8 *)(a1 + 488), &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v14 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v14 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v12, (uint64_t)p_p, v14);
  std::stringbuf::str(a2, &v22);
  *(void *)((char *)v20
  uint64_t v21 = v15;
  std::streambuf::~streambuf(&v22);
  return std::ios::~ios(&v23);
}

void sub_100BF69CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_1011F8850((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_100BF6A34(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

__n128 sub_100BF6A60(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_100231C10(v1 + 28) = 0LL;
  *(void *)(a1 + 44) = 0LL;
  *(void *)(a1 + 36) = 0LL;
  *(_DWORD *)(a1 + 52) = 0;
  *(void *)(a1 + 56) = 0x402E000000000000LL;
  *(_BYTE *)(a1 + 64) = 1;
  *(_OWORD *)(a1 + 72) = xmmword_10134F780;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(_BYTE *)(a1 + 112) = 1;
  *(void *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 1sub_100231C10(v1 + 28) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  *(_DWORD *)(a1 + 144) = 6;
  *(_BYTE *)(a1 + 154) = 1;
  *(_OWORD *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 224) = 0LL;
  *(_OWORD *)(a1 + 232) = xmmword_101329190;
  *(void *)(a1 + 2memset(v19, 0, 48) = 0x4024000000000000LL;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = 0LL;
  *(_WORD *)(a1 + 28sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 288) = 0LL;
  *(_WORD *)(a1 + 312) = 257;
  *(_WORD *)(a1 + 324) = 0;
  *(_BYTE *)(a1 + 3sub_100231C10(v1 + 28) = 1;
  *(_DWORD *)(a1 + 332) = -115;
  *(void *)(a1 + 336) = 0x4000000000000000LL;
  *(void *)(a1 + 344) = 0x3E800000005LL;
  *(_WORD *)(a1 + 352) = 0;
  *(_WORD *)(a1 + 364) = 257;
  *(_BYTE *)(a1 + 368) = 1;
  *(_WORD *)(a1 + 372) = 257;
  *(void *)(a1 + 376) = 0x32000000018LL;
  *(_WORD *)(a1 + 384) = 0;
  *(_WORD *)(a1 + 388) = 0;
  *(void *)(a1 + 392) = 0x6400000005LL;
  *(_WORD *)(a1 + 40sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 256;
  *(_WORD *)(a1 + 404) = 0;
  *(void *)(a1 + 408) = -1LL;
  *(_WORD *)(a1 + 416) = 257;
  *(_BYTE *)(a1 + 42sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1;
  *(_WORD *)(a1 + 424) = 0;
  *(_WORD *)(a1 + 436) = 257;
  *(_WORD *)(a1 + 44sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_WORD *)(a1 + 452) = 257;
  *(_WORD *)(a1 + 456) = 0;
  *(_WORD *)(a1 + 468) = 257;
  *(void *)(a1 + 472) = 0x6400000002LL;
  *(_DWORD *)(a1 + 48sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 100;
  *(_WORD *)(a1 + 488) = 256;
  *(_BYTE *)(a1 + 49sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1;
  *(void *)(a1 + 56sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_OWORD *)(a1 + 5sub_100231C10(v1 + 28) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(void *)(a1 + 568) = 0x3FF0000000000000LL;
  __asm { FMOV            V0.2D, #10.0 }

  *(__n128 *)(a1 + 576) = result;
  *(void *)(a1 + 608) = 0LL;
  *(void *)(a1 + 592) = 0LL;
  *(void *)(a1 + 60sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_WORD *)(a1 + 616) = 1;
  *(void *)(a1 + 64sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 624) = 0LL;
  *(void *)(a1 + 632) = 0LL;
  *(_WORD *)(a1 + 6memset(v19, 0, 48) = 257;
  *(_WORD *)(a1 + 66sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_BYTE *)(a1 + 664) = 1;
  *(_DWORD *)(a1 + 668) = -115;
  *(void *)(a1 + 672) = 0x4000000000000000LL;
  *(void *)(a1 + 68sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0x3E800000005LL;
  *(_WORD *)(a1 + 688) = 0;
  *(_WORD *)(a1 + 70sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 257;
  *(_BYTE *)(a1 + 704) = 1;
  *(_WORD *)(a1 + 708) = 257;
  *(void *)(a1 + 712) = 0x32000000018LL;
  *(_WORD *)(a1 + 72sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_WORD *)(a1 + 724) = 0;
  *(void *)(a1 + 7sub_100231C10(v1 + 28) = 0x6400000005LL;
  *(_WORD *)(a1 + 736) = 256;
  *(_WORD *)(a1 + 74sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(void *)(a1 + 744) = -1LL;
  *(_WORD *)(a1 + 752) = 257;
  *(_BYTE *)(a1 + 756) = 1;
  *(_WORD *)(a1 + 76sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_WORD *)(a1 + 772) = 257;
  *(_WORD *)(a1 + 776) = 0;
  *(_WORD *)(a1 + 788) = 257;
  *(_WORD *)(a1 + 792) = 0;
  *(_WORD *)(a1 + 804) = 257;
  *(void *)(a1 + 808) = 0x6400000002LL;
  *(_DWORD *)(a1 + 816) = 100;
  *(_WORD *)(a1 + 152) = 256;
  *(void *)(a1 + 316) = 0x32000000018LL;
  *(void *)(a1 + 356) = -1LL;
  *(void *)(a1 + 4sub_100231C10(v1 + 28) = -1LL;
  *(void *)(a1 + 444) = -1LL;
  *(void *)(a1 + 46sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = -1LL;
  *(void *)(a1 + 652) = 0x32000000018LL;
  *(void *)(a1 + 692) = -1LL;
  *(void *)(a1 + 764) = -1LL;
  *(void *)(a1 + 78sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = -1LL;
  *(void *)(a1 + 796) = -1LL;
  return result;
}

uint64_t sub_100BF6C88(uint64_t a1, __int128 *a2)
{
  __int128 v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_BYTE *)a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  int v5 = (void **)(a1 + 32);
  __int128 v6 = a2[2];
  *(void *)(a1 + memset(v19, 0, 48) = *((void *)a2 + 6);
  *(_OWORD *)int v5 = v6;
  *((_BYTE *)a2 + 55) = 0;
  *((_BYTE *)a2 + 32) = 0;
  __int128 v7 = *(__int128 *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 56) = *(__int128 *)((char *)a2 + 56);
  *(_OWORD *)(a1 + 72) = v7;
  uint64_t v8 = (void **)(a1 + 88);
  __int128 v9 = *(__int128 *)((char *)a2 + 88);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(_OWORD *)uint64_t v8 = v9;
  *((_BYTE *)a2 + 111) = 0;
  *((_BYTE *)a2 + 88) = 0;
  *(_BYTE *)(a1 + 112) = *((_BYTE *)a2 + 112);
  sub_10012EC68((uint64_t *)(a1 + 120));
  *(_OWORD *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(__int128 *)((char *)a2 + 120);
  *(void *)(a1 + 136) = *((void *)a2 + 17);
  *((void *)a2 + 15) = 0LL;
  *((void *)a2 + 16) = 0LL;
  *((void *)a2 + 17) = 0LL;
  *(_DWORD *)(a1 + 144) = *((_DWORD *)a2 + 36);
  sub_100BF6D98(a1 + 152, (__int16 *)a2 + 76);
  sub_100BF6D98(a1 + 488, (__int16 *)a2 + 244);
  return a1;
}

uint64_t sub_100BF6D98(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(_BYTE *)(a1 + 2) = *((_BYTE *)a2 + 2);
  *(_WORD *)a1 = v4;
  uint64_t v5 = a1 + 8;
  __int128 v6 = (__int128 *)(a2 + 4);
  __int128 v7 = *v6;
  *(void *)(v5 + 16) = *((void *)v6 + 2);
  *(_OWORD *)uint64_t v5 = v7;
  *((_BYTE *)a2 + 31) = 0;
  *((_BYTE *)a2 + 8) = 0;
  uint64_t v8 = (void **)(a1 + 32);
  __int128 v9 = *((_OWORD *)a2 + 2);
  *(void *)(a1 + memset(v19, 0, 48) = *((void *)a2 + 6);
  *(_OWORD *)uint64_t v8 = v9;
  *((_BYTE *)a2 + 55) = 0;
  *((_BYTE *)a2 + 32) = 0;
  uint64_t v10 = (void **)(a1 + 56);
  __int128 v11 = *(_OWORD *)(a2 + 28);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)uint64_t v10 = v11;
  *((_BYTE *)a2 + 79) = 0;
  *((_BYTE *)a2 + 56) = 0;
  uint64_t v12 = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((_OWORD *)a2 + 5);
  *(void *)(a1 + 96) = v12;
  BOOL v13 = (void **)(a1 + 104);
  __int128 v14 = *(_OWORD *)(a2 + 52);
  *(void *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((void *)a2 + 15);
  *(_OWORD *)BOOL v13 = v14;
  *((_BYTE *)a2 + 127) = 0;
  *((_BYTE *)a2 + 104) = 0;
  *(_WORD *)(a1 + 1sub_100231C10(v1 + 28) = a2[64];
  sub_100BF6F08((void **)(a1 + 136));
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 68);
  *(void *)(a1 + 152) = *((void *)a2 + 19);
  *((void *)a2 + 18) = 0LL;
  *((void *)a2 + 19) = 0LL;
  *((void *)a2 + 17) = 0LL;
  __int128 v15 = *((_OWORD *)a2 + 16);
  __int128 v17 = *((_OWORD *)a2 + 13);
  __int128 v16 = *((_OWORD *)a2 + 14);
  *(_OWORD *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((_OWORD *)a2 + 15);
  *(_OWORD *)(a1 + 256) = v15;
  *(_OWORD *)(a1 + 208) = v17;
  *(_OWORD *)(a1 + 224) = v16;
  __int128 v19 = *((_OWORD *)a2 + 18);
  __int128 v18 = *((_OWORD *)a2 + 19);
  __int128 v20 = *((_OWORD *)a2 + 17);
  *(_OWORD *)(a1 + 316) = *(_OWORD *)(a2 + 158);
  *(_OWORD *)(a1 + 288) = v19;
  *(_OWORD *)(a1 + 304) = v18;
  *(_OWORD *)(a1 + 272) = v20;
  __int128 v21 = *((_OWORD *)a2 + 12);
  __int128 v22 = *((_OWORD *)a2 + 10);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)a2 + 11);
  *(_OWORD *)(a1 + 192) = v21;
  *(_OWORD *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v22;
  return a1;
}

void sub_100BF6F08(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    __int16 v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80LL;
        sub_100783760((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      __int16 v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_100BF6F74(uint64_t a1)
{
  return a1;
}

uint64_t sub_100BF6FFC(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 624);
  sub_100BF7104(&v3);
  uint64_t v3 = (void **)(a1 + 288);
  sub_100BF7104(&v3);
  uint64_t v3 = (void **)(a1 + 120);
  sub_1000129D4(&v3);
  return a1;
}

void sub_100BF7104(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80LL;
        sub_100783760((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100BF7188(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

uint64_t sub_100BF71B4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_BYTE *)(a1 + 8) = *((_BYTE *)a2 + 8);
  *(void *)a1 = v4;
  __int128 v6 = *((_OWORD *)a2 + 5);
  __int128 v5 = *((_OWORD *)a2 + 6);
  __int128 v7 = *((_OWORD *)a2 + 4);
  *(void *)(a1 + 112) = a2[14];
  *(_OWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v6;
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 64) = v7;
  __int128 v8 = *((_OWORD *)a2 + 1);
  __int128 v9 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + memset(v19, 0, 48) = v9;
  *(_OWORD *)(a1 + 16) = v8;
  sub_100BF7414((char *)(a1 + 120), (uint64_t)(a2 + 15));
  if (*((char *)a2 + 967) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 944), (void *)a2[118], a2[119]);
  }

  else
  {
    __int128 v10 = *((_OWORD *)a2 + 59);
    *(void *)(a1 + 96sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2[120];
    *(_OWORD *)(a1 + 944) = v10;
  }

  __int128 v11 = (_BYTE *)(a1 + 968);
  if (*((char *)a2 + 991) < 0)
  {
    sub_1010DD48C(v11, (void *)a2[121], a2[122]);
  }

  else
  {
    __int128 v12 = *(_OWORD *)(a2 + 121);
    *(void *)(a1 + 984) = a2[123];
    *(_OWORD *)__int128 v11 = v12;
  }

  uint64_t v13 = a2[124];
  *(_DWORD *)(a1 + 100sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((_DWORD *)a2 + 250);
  *(void *)(a1 + 992) = v13;
  __int128 v14 = *((_OWORD *)a2 + 63);
  __int128 v15 = *((_OWORD *)a2 + 64);
  __int128 v16 = *((_OWORD *)a2 + 65);
  *(void *)(a1 + 1056) = a2[132];
  *(_OWORD *)(a1 + 104sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v16;
  *(_OWORD *)(a1 + 1008) = v14;
  *(_OWORD *)(a1 + 1024) = v15;
  if (*((char *)a2 + 1087) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 1064), (void *)a2[133], a2[134]);
  }

  else
  {
    __int128 v17 = *(_OWORD *)(a2 + 133);
    *(void *)(a1 + 108sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2[135];
    *(_OWORD *)(a1 + 1064) = v17;
  }

  if (*((char *)a2 + 1111) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 1088), (void *)a2[136], a2[137]);
  }

  else
  {
    __int128 v18 = *((_OWORD *)a2 + 68);
    *(void *)(a1 + 1104) = a2[138];
    *(_OWORD *)(a1 + 1088) = v18;
  }

  if (*((char *)a2 + 1135) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 1112), (void *)a2[139], a2[140]);
  }

  else
  {
    __int128 v19 = *(_OWORD *)(a2 + 139);
    *(void *)(a1 + 11sub_100231C10(v1 + 28) = a2[141];
    *(_OWORD *)(a1 + 1112) = v19;
  }

  __int128 v20 = (_BYTE *)(a1 + 1136);
  if (*((char *)a2 + 1159) < 0)
  {
    sub_1010DD48C(v20, (void *)a2[142], a2[143]);
  }

  else
  {
    __int128 v21 = *((_OWORD *)a2 + 71);
    *(void *)(a1 + 1152) = a2[144];
    *(_OWORD *)__int128 v20 = v21;
  }

  return a1;
}

void sub_100BF7390(_Unwind_Exception *a1)
{
  if (v2[1135] < 0) {
    operator delete(*v6);
  }
  if (v2[1111] < 0) {
    operator delete(*v5);
  }
  if (v2[1087] < 0) {
    operator delete(*v4);
  }
  sub_1000A56E8(v3);
  sub_100BF6FFC(v1);
  _Unwind_Resume(a1);
}

char *sub_100BF7414(char *a1, uint64_t a2)
{
  uint64_t v4 = sub_100BF74F4(a1, (__int128 *)a2);
  sub_100BF7644((uint64_t)(v4 + 152), (__int16 *)(a2 + 152));
  sub_100BF7644((uint64_t)(a1 + 488), (__int16 *)(a2 + 488));
  return a1;
}

void sub_100BF7464( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _Unwind_Exception *a9)
{
  a9 = (_Unwind_Exception *)(v9 + 288);
  sub_100BF7104((void ***)&a9);
  sub_1012656C8(v9, a1, a2, (uint64_t)&a9);
  __int128 v12 = a9;
  a9 = (_Unwind_Exception *)(v9 + 120);
  sub_1000129D4((void ***)&a9);
  _Unwind_Resume(v12);
}

char *sub_100BF74F4(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  *((void *)__dst + 3) = *((void *)a2 + 3);
  if (*((char *)a2 + 55) < 0)
  {
    sub_1010DD48C(__dst + 32, *((void **)a2 + 4), *((void *)a2 + 5));
  }

  else
  {
    __int128 v5 = a2[2];
    *((void *)__dst + 6) = *((void *)a2 + 6);
    *((_OWORD *)__dst + 2) = v5;
  }

  __int128 v6 = *(__int128 *)((char *)a2 + 56);
  *(_OWORD *)(__dst + 72) = *(__int128 *)((char *)a2 + 72);
  *(_OWORD *)(__dst + 56) = v6;
  if (*((char *)a2 + 111) < 0)
  {
    sub_1010DD48C(__dst + 88, *((void **)a2 + 11), *((void *)a2 + 12));
  }

  else
  {
    __int128 v7 = *(__int128 *)((char *)a2 + 88);
    *((void *)__dst + 13) = *((void *)a2 + 13);
    *(_OWORD *)(__dst + 88) = v7;
  }

  char v8 = *((_BYTE *)a2 + 112);
  *((void *)__dst + 15) = 0LL;
  __dst[112] = v8;
  *((void *)__dst + 16) = 0LL;
  *((void *)__dst + 17) = 0LL;
  sub_10010DEE0( __dst + 120,  *((__int128 **)a2 + 15),  *((__int128 **)a2 + 16),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 16) - *((void *)a2 + 15)) >> 3));
  *((_DWORD *)__dst + 36) = *((_DWORD *)a2 + 36);
  return __dst;
}

void sub_100BF75F8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100BF7644(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(_BYTE *)(a1 + 2) = *((_BYTE *)a2 + 2);
  *(_WORD *)a1 = v4;
  if (*((char *)a2 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 8), *((void **)a2 + 1), *((void *)a2 + 2));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 4);
    *(void *)(a1 + 24) = *((void *)a2 + 3);
    *(_OWORD *)(a1 + 8) = v5;
  }

  if (*((char *)a2 + 55) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 32), *((void **)a2 + 4), *((void *)a2 + 5));
  }

  else
  {
    __int128 v6 = *((_OWORD *)a2 + 2);
    *(void *)(a1 + memset(v19, 0, 48) = *((void *)a2 + 6);
    *(_OWORD *)(a1 + 32) = v6;
  }

  if (*((char *)a2 + 79) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 56), *((void **)a2 + 7), *((void *)a2 + 8));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a2 + 28);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *(_OWORD *)(a1 + 56) = v7;
  }

  __int128 v8 = *((_OWORD *)a2 + 5);
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
  if (*((char *)a2 + 127) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 104), *((void **)a2 + 13), *((void *)a2 + 14));
  }

  else
  {
    __int128 v9 = *(_OWORD *)(a2 + 52);
    *(void *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((void *)a2 + 15);
    *(_OWORD *)(a1 + 104) = v9;
  }

  __int16 v10 = a2[64];
  *(void *)(a1 + 136) = 0LL;
  *(_WORD *)(a1 + 1sub_100231C10(v1 + 28) = v10;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = 0LL;
  sub_100BF782C( (char *)(a1 + 136),  *((__int128 **)a2 + 17),  *((__int128 **)a2 + 18),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 18) - *((void *)a2 + 17)) >> 4));
  __int128 v11 = *((_OWORD *)a2 + 10);
  __int128 v12 = *((_OWORD *)a2 + 12);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)a2 + 11);
  *(_OWORD *)(a1 + 192) = v12;
  *(_OWORD *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v11;
  __int128 v13 = *((_OWORD *)a2 + 13);
  __int128 v14 = *((_OWORD *)a2 + 14);
  __int128 v15 = *((_OWORD *)a2 + 16);
  *(_OWORD *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((_OWORD *)a2 + 15);
  *(_OWORD *)(a1 + 256) = v15;
  *(_OWORD *)(a1 + 208) = v13;
  *(_OWORD *)(a1 + 224) = v14;
  __int128 v16 = *((_OWORD *)a2 + 17);
  __int128 v17 = *((_OWORD *)a2 + 18);
  __int128 v18 = *((_OWORD *)a2 + 19);
  *(_OWORD *)(a1 + 316) = *(_OWORD *)(a2 + 158);
  *(_OWORD *)(a1 + 288) = v17;
  *(_OWORD *)(a1 + 304) = v18;
  *(_OWORD *)(a1 + 272) = v16;
  return a1;
}

void sub_100BF77C8(_Unwind_Exception *exception_object)
{
  if (v1[79] < 0) {
    operator delete(*v4);
  }
  if (v1[55] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100BF782C(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    __int128 v6 = result;
    sub_10010E150(result, a4);
    __n128 result = sub_100BF78B0((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }

  return result;
}

void sub_100BF7890( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100BF7104(&a9);
  _Unwind_Resume(a1);
}

char *sub_100BF78B0(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  __int16 v4 = __dst;
  __int128 v11 = __dst;
  __int128 v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    __int128 v6 = a2;
    int v7 = a1;
    do
    {
      sub_100BF7958(v7, v4, v6);
      v6 += 5;
      __int16 v4 = v12 + 80;
      v12 += 80;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_100BF7A40((uint64_t)v9);
  return v4;
}

void sub_100BF7944( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

_BYTE *sub_100BF7958(int a1, char *__dst, __int128 *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v5 = *a3;
    *((void *)__dst + 2) = *((void *)a3 + 2);
    *(_OWORD *)__int128 __dst = v5;
  }

  if (*((char *)a3 + 47) < 0)
  {
    sub_1010DD48C(__dst + 24, *((void **)a3 + 3), *((void *)a3 + 4));
  }

  else
  {
    __int128 v6 = *(__int128 *)((char *)a3 + 24);
    *((void *)__dst + 5) = *((void *)a3 + 5);
    *(_OWORD *)(__dst + 24) = v6;
  }

  __dst[48] = *((_BYTE *)a3 + 48);
  __n128 result = __dst + 56;
  __int128 v8 = *(__int128 *)((char *)a3 + 56);
  *((void *)__dst + 9) = *((void *)a3 + 9);
  *(_OWORD *)__n128 result = v8;
  return result;
}

void sub_100BF7A0C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100BF7A40(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100BF7A74((uint64_t *)a1);
  }
  return a1;
}

void sub_100BF7A74(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 80LL;
      sub_100783760(v5, v3);
    }

    while (v3 != v4);
  }

uint64_t sub_100BF7AC4@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v26, (uint64_t)"ControlPlane,", 13LL);
  sub_100BF63A0((unsigned int *)a1, &v24);
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v5 = &v24;
  }
  else {
    uint64_t v5 = (std::stringbuf::string_type *)v24.__r_.__value_.__r.__words[0];
  }
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v24.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v24.__r_.__value_.__l.__size_;
  }
  int v7 = sub_10000CF44(v4, (uint64_t)v5, size);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)",ControlPlaneCdma,", 18LL);
  sub_100BF66CC((unsigned __int8 *)(a1 + 40), &v23);
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v9 = &v23;
  }
  else {
    uint64_t v9 = (std::stringbuf::string_type *)v23.__r_.__value_.__r.__words[0];
  }
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = v23.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v10 = v23.__r_.__value_.__l.__size_;
  }
  __int128 v11 = sub_10000CF44(v8, (uint64_t)v9, v10);
  __int128 v12 = sub_10000CF44(v11, (uint64_t)",UserPlane,", 11LL);
  sub_100BF63A0((unsigned int *)(a1 + 48), &v22);
  if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v13 = &v22;
  }
  else {
    __int128 v13 = (std::stringbuf::string_type *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v14 = v22.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v14 = v22.__r_.__value_.__l.__size_;
  }
  __int128 v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
  __int128 v16 = sub_10000CF44(v15, (uint64_t)",Action,", 8LL);
  sub_100BF6818(a1 + 104, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v18 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v18 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v16, (uint64_t)p_p, v18);
  std::stringbuf::str(a2, &v27);
  *(void *)((char *)v25
  uint64_t v26 = v19;
  std::streambuf::~streambuf(&v27);
  return std::ios::~ios(&v28);
}

void sub_100BF7CCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, char a34)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_1011F8850((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF7D50@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v32, (uint64_t)"HslpAddress,", 12LL);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  __int128 v8 = sub_10000CF44(v4, v6, v7);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",HslpCARootCert,", 16LL);
  int v10 = *(char *)(a1 + 47);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 24;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 24);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 32);
  }
  __int128 v13 = sub_10000CF44(v9, v11, v12);
  uint64_t v14 = sub_10000CF44(v13, (uint64_t)",port,", 6LL);
  __int128 v15 = (void *)std::ostream::operator<<(v14, *(unsigned __int16 *)(a1 + 48));
  __int128 v16 = sub_10000CF44(v15, (uint64_t)",udpPortConfig,", 15LL);
  __int128 v17 = (void *)std::ostream::operator<<(v16, *(unsigned int *)(a1 + 52));
  uint64_t v18 = sub_10000CF44(v17, (uint64_t)",suplFlags,", 11LL);
  uint64_t v19 = (void *)std::ostream::operator<<(v18, *(unsigned int *)(a1 + 56));
  __int128 v20 = sub_10000CF44(v19, (uint64_t)",allowNonEmergencySupl,", 23LL);
  __int128 v21 = (void *)std::ostream::operator<<(v20, *(_BYTE *)(a1 + 56) & 1);
  std::stringbuf::string_type v22 = sub_10000CF44(v21, (uint64_t)",allowSuplWithoutEmergencyNotification,", 39LL);
  std::stringbuf::string_type v23 = (void *)std::ostream::operator<<(v22, (*(unsigned __int8 *)(a1 + 56) >> 1) & 1);
  std::stringbuf::string_type v24 = sub_10000CF44(v23, (uint64_t)",allowHslpMismatch,", 19LL);
  std::stringbuf::string_type v25 = (void *)std::ostream::operator<<(v24, (*(unsigned __int8 *)(a1 + 56) >> 2) & 1);
  uint64_t v26 = sub_10000CF44(v25, (uint64_t)",allowHslpWildCard,", 19LL);
  std::stringbuf v27 = (void *)std::ostream::operator<<(v26, (*(unsigned __int8 *)(a1 + 56) >> 3) & 1);
  uint64_t v28 = sub_10000CF44(v27, (uint64_t)",allowNonConformingEslpAddress,", 31LL);
  std::ostream::operator<<(v28, (*(unsigned __int8 *)(a1 + 56) >> 4) & 1);
  std::stringbuf::str(a2, &v33);
  *(void *)((char *)v31
  uint64_t v32 = v29;
  std::streambuf::~streambuf(&v33);
  return std::ios::~ios(&v34);
}

void sub_100BF7F34(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100BF7F48@<X0>(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case 2:
      uint64_t v4 = "network-assisted";
      return sub_1010DDBC0(a2, v4);
    case 1:
      uint64_t v4 = "device-based";
      return sub_1010DDBC0(a2, v4);
    case 0:
      uint64_t v4 = "disabled";
      return sub_1010DDBC0(a2, v4);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v11 = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "undefined constellation usage %d\n", buf, 8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "undefined constellation usage %d\n",  v9);
    __int128 v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static std::string CLEmergencyController::LocationSettings::Emergency::Settings::toString(ConstellationUsage)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  return sub_1010DDBC0(a2, "undefined");
}

uint64_t sub_100BF819C@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v16, (uint64_t)"enable,", 7LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",apConfig,", 10LL);
  sub_100BF8308(a1[1], __p);
  if ((v14 & 0x80u) == 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v8 = v14;
  }
  else {
    uint64_t v8 = (uint64_t)__p[1];
  }
  uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
  int v10 = sub_10000CF44(v9, (uint64_t)",enableRssi,", 12LL);
  std::ostream::operator<<(v10, a1[2]);
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v11;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_100BF82D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void *sub_100BF8308@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 1)
  {
    uint64_t v4 = "AllScannedAPs";
    return sub_1010DDBC0(a2, v4);
  }

  if (!a1)
  {
    uint64_t v4 = "ServingApOnly";
    return sub_1010DDBC0(a2, v4);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v11 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#wlan,apConfigToString,undefined AccessPointConfig,%d\n",  buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#wlan,apConfigToString,undefined AccessPointConfig,%d\n",  v9);
    uint64_t v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static std::string CLEmergencyController::LocationSettings::Emergency::Settings::apConfigToString(AccessPointConfig)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  return sub_1010DDBC0(a2, "undefined");
}

void *sub_100BF8530@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 1)
  {
    uint64_t v4 = "Cdma";
    return sub_1010DDBC0(a2, v4);
  }

  if (!a1)
  {
    uint64_t v4 = "Gps";
    return sub_1010DDBC0(a2, v4);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101877978);
  }
  uint64_t v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v11 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "undefined MeasurementTimeStampSource,%d\n",  buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101877978);
    }
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "undefined MeasurementTimeStampSource,%d\n",  v9);
    uint64_t v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static std::string CLEmergencyController::LocationSettings::Emergency::measTimeStampSourceToString(MeasurementTimeStampSource)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  return sub_1010DDBC0(a2, "undefined");
}

uint64_t sub_100BF8758@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v43, (uint64_t)"smsAddress,", 11LL);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  uint64_t v8 = sub_10000CF44(v4, v6, v7);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",sendBinarySms,", 15LL);
  int v10 = (void *)std::ostream::operator<<(v9, *(unsigned __int8 *)(a1 + 24));
  int v11 = sub_10000CF44(v10, (uint64_t)",smsDestinationPort,", 20LL);
  uint64_t v12 = (void *)std::ostream::operator<<(v11, *(unsigned int *)(a1 + 28));
  __int128 v13 = sub_10000CF44(v12, (uint64_t)",httpsAddress,", 14LL);
  int v14 = *(char *)(a1 + 55);
  if (v14 >= 0) {
    uint64_t v15 = a1 + 32;
  }
  else {
    uint64_t v15 = *(void *)(a1 + 32);
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a1 + 55);
  }
  else {
    uint64_t v16 = *(void *)(a1 + 40);
  }
  std::stringbuf v17 = sub_10000CF44(v13, v15, v16);
  sub_10000CF44(v17, (uint64_t)",firstFixDelay,", 15LL);
  uint64_t v18 = (void *)std::ostream::operator<<(*(double *)(a1 + 56));
  uint64_t v19 = sub_10000CF44(v18, (uint64_t)",multipleSmsEnabled,", 20LL);
  __int128 v20 = (void *)std::ostream::operator<<(v19, *(unsigned __int8 *)(a1 + 64));
  sub_10000CF44(v20, (uint64_t)",maxFixDelay,", 13LL);
  __int128 v21 = (void *)std::ostream::operator<<(*(double *)(a1 + 72));
  sub_10000CF44(v21, (uint64_t)",minFixDelay,", 13LL);
  std::stringbuf::string_type v22 = (void *)std::ostream::operator<<(*(double *)(a1 + 80));
  std::stringbuf::string_type v23 = sub_10000CF44(v22, (uint64_t)",smsOverNasAddress,", 19LL);
  int v24 = *(char *)(a1 + 111);
  if (v24 >= 0) {
    uint64_t v25 = a1 + 88;
  }
  else {
    uint64_t v25 = *(void *)(a1 + 88);
  }
  if (v24 >= 0) {
    uint64_t v26 = *(unsigned __int8 *)(a1 + 111);
  }
  else {
    uint64_t v26 = *(void *)(a1 + 96);
  }
  std::stringbuf v27 = sub_10000CF44(v23, v25, v26);
  uint64_t v28 = sub_10000CF44(v27, (uint64_t)",AmlEnableForSatellitePLMNs,", 28LL);
  uint64_t v29 = (void *)std::ostream::operator<<(v28, *(unsigned __int8 *)(a1 + 112));
  sub_10000CF44(v29, (uint64_t)",AmlOverNASEnableForMCCOrPLMNs,[", 32LL);
  uint64_t v30 = *(void *)(a1 + 120);
  uint64_t v31 = *(void *)(a1 + 128);
  if (v30 != v31)
  {
    do
    {
      uint64_t v32 = sub_10000CF44(&v43, (uint64_t)"{", 1LL);
      int v33 = *(char *)(v30 + 23);
      if (v33 >= 0) {
        uint64_t v34 = v30;
      }
      else {
        uint64_t v34 = *(void *)v30;
      }
      if (v33 >= 0) {
        uint64_t v35 = *(unsigned __int8 *)(v30 + 23);
      }
      else {
        uint64_t v35 = *(void *)(v30 + 8);
      }
      int v36 = sub_10000CF44(v32, v34, v35);
      sub_10000CF44(v36, (uint64_t)"},", 2LL);
      v30 += 24LL;
    }

    while (v30 != v31);
    if (*(void *)(a1 + 128) != *(void *)(a1 + 120))
    {
      std::ostream::sentry::sentry(v46, &v43);
      unsigned __int8 v37 = (char *)&v43 + *(void *)(v43 - 24);
      if ((v37[32] & 5) == 0)
      {
        (*(void (**)(void *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v37 + 5) + 32LL))( v47,  *((void *)v37 + 5),  -1LL,  1LL,  16LL);
        if (v47[16] == -1LL) {
          std::ios_base::clear( (std::ios_base *)((char *)&v43 + *(void *)(v43 - 24)),  *(_DWORD *)((char *)&v44.__ninp_ + *(void *)(v43 - 24)) | 4);
        }
      }

      std::ostream::sentry::~sentry(v46);
    }
  }

  uint64_t v38 = sub_10000CF44(&v43, (uint64_t)"]", 1LL);
  uint64_t v39 = sub_10000CF44(v38, (uint64_t)",maAmloverNASFirstFixDelay,", 27LL);
  std::ostream::operator<<(v39, *(unsigned int *)(a1 + 144));
  std::stringbuf::str(a2, &v44);
  *(void *)((char *)v42
  uint64_t v43 = v40;
  std::streambuf::~streambuf(&v44);
  return std::ios::~ios(&v45);
}

void sub_100BF8AA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF8AD4@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v56, (uint64_t)"enabled,", 8LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",adrEnabled,", 12LL);
  uint64_t v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",requestsEnabled,", 17LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, a1[2]);
  int v10 = sub_10000CF44(v9, (uint64_t)",lisUrl,", 8LL);
  int v11 = (char)a1[31];
  if (v11 >= 0) {
    uint64_t v12 = (uint64_t)(a1 + 8);
  }
  else {
    uint64_t v12 = *((void *)a1 + 1);
  }
  if (v11 >= 0) {
    uint64_t v13 = a1[31];
  }
  else {
    uint64_t v13 = *((void *)a1 + 2);
  }
  int v14 = sub_10000CF44(v10, v12, v13);
  uint64_t v15 = sub_10000CF44(v14, (uint64_t)",adrUrl,", 8LL);
  int v16 = (char)a1[55];
  if (v16 >= 0) {
    uint64_t v17 = (uint64_t)(a1 + 32);
  }
  else {
    uint64_t v17 = *((void *)a1 + 4);
  }
  if (v16 >= 0) {
    uint64_t v18 = a1[55];
  }
  else {
    uint64_t v18 = *((void *)a1 + 5);
  }
  uint64_t v19 = sub_10000CF44(v15, v17, v18);
  __int128 v20 = sub_10000CF44(v19, (uint64_t)",controlUrl,", 12LL);
  int v21 = (char)a1[79];
  if (v21 >= 0) {
    uint64_t v22 = (uint64_t)(a1 + 56);
  }
  else {
    uint64_t v22 = *((void *)a1 + 7);
  }
  if (v21 >= 0) {
    uint64_t v23 = a1[79];
  }
  else {
    uint64_t v23 = *((void *)a1 + 8);
  }
  int v24 = sub_10000CF44(v20, v22, v23);
  sub_10000CF44(v24, (uint64_t)",firstLisPostDelay,", 19LL);
  uint64_t v25 = (void *)std::ostream::operator<<(*((double *)a1 + 10));
  sub_10000CF44(v25, (uint64_t)",periodicLisPostDelay,", 22LL);
  uint64_t v26 = (void *)std::ostream::operator<<(*((double *)a1 + 11));
  sub_10000CF44(v26, (uint64_t)",initialAdrPostTimeout,", 23LL);
  std::stringbuf v27 = (void *)std::ostream::operator<<(*((double *)a1 + 12));
  uint64_t v28 = sub_10000CF44(v27, (uint64_t)",intermediateCert,", 18LL);
  int v29 = (char)a1[127];
  if (v29 >= 0) {
    uint64_t v30 = (uint64_t)(a1 + 104);
  }
  else {
    uint64_t v30 = *((void *)a1 + 13);
  }
  if (v29 >= 0) {
    uint64_t v31 = a1[127];
  }
  else {
    uint64_t v31 = *((void *)a1 + 14);
  }
  uint64_t v32 = sub_10000CF44(v28, v30, v31);
  int v33 = sub_10000CF44(v32, (uint64_t)",dsaEnabled,", 12LL);
  uint64_t v34 = (void *)std::ostream::operator<<(v33, a1[128]);
  uint64_t v35 = sub_10000CF44(v34, (uint64_t)",unmaskCrashDetection,", 22LL);
  int v36 = (void *)std::ostream::operator<<(v35, a1[129]);
  sub_10000CF44(v36, (uint64_t)",partnerInfoVec,[", 17LL);
  uint64_t v37 = *((void *)a1 + 17);
  uint64_t v38 = *((void *)a1 + 18);
  if (v37 != v38)
  {
    do
    {
      uint64_t v39 = sub_10000CF44(&v56, (uint64_t)"{", 1LL);
      sub_100BF8FA4(v37, v59);
      if ((v59[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v40 = v59;
      }
      else {
        uint64_t v40 = (std::stringbuf::string_type *)v59[0].__r_.__value_.__r.__words[0];
      }
      if ((v59[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t size = v59[0].__r_.__value_.__s.__size_;
      }
      else {
        uint64_t size = v59[0].__r_.__value_.__l.__size_;
      }
      uint64_t v42 = sub_10000CF44(v39, (uint64_t)v40, size);
      sub_10000CF44(v42, (uint64_t)"},", 2LL);
      v37 += 80LL;
    }

    while (v37 != v38);
    if (*((void *)a1 + 18) != *((void *)a1 + 17))
    {
      std::ostream::sentry::sentry(&__p, &v56);
      uint64_t v43 = (char *)&v56 + *(void *)(v56 - 24);
      if ((v43[32] & 5) == 0)
      {
        (*(void (**)(std::stringbuf::string_type *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v43 + 5) + 32LL))( v59,  *((void *)v43 + 5),  -1LL,  1LL,  16LL);
        if (v60 == -1) {
          std::ios_base::clear( (std::ios_base *)((char *)&v56 + *(void *)(v56 - 24)),  *(_DWORD *)((char *)&v57.__ninp_ + *(void *)(v56 - 24)) | 4);
        }
      }

      std::ostream::sentry::~sentry(&__p);
    }
  }

  std::stringbuf v44 = sub_10000CF44(&v56, (uint64_t)"]", 1LL);
  uint64_t v45 = sub_10000CF44(v44, (uint64_t)",mitigationsConfig,", 19LL);
  sub_100BF9110(a1 + 160, v59);
  if ((v59[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v46 = v59;
  }
  else {
    uint64_t v46 = (std::stringbuf::string_type *)v59[0].__r_.__value_.__r.__words[0];
  }
  if ((v59[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v47 = v59[0].__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v47 = v59[0].__r_.__value_.__l.__size_;
  }
  uint64_t v48 = sub_10000CF44(v45, (uint64_t)v46, v47);
  char v49 = sub_10000CF44(v48, (uint64_t)",uploadConfig,", 14LL);
  sub_100BF939C((unsigned int *)a1 + 80, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v51 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v51 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v49, (uint64_t)p_p, v51);
  std::stringbuf::str(a2, &v57);
  *(void *)((char *)v55
  uint64_t v56 = v52;
  std::streambuf::~streambuf(&v57);
  return std::ios::~ios(&v58);
}

void sub_100BF8F30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_100BF8FA4@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v26, (uint64_t)"partnerId,", 10LL);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  uint64_t v8 = sub_10000CF44(v4, v6, v7);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",adrCert,", 9LL);
  int v10 = *(char *)(a1 + 47);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 24;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 24);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 32);
  }
  uint64_t v13 = sub_10000CF44(v9, v11, v12);
  int v14 = sub_10000CF44(v13, (uint64_t)",requestsSupported,", 19LL);
  uint64_t v15 = (void *)std::ostream::operator<<(v14, *(unsigned __int8 *)(a1 + 48));
  int v16 = sub_10000CF44(v15, (uint64_t)",baseURL,", 9LL);
  uint64_t v19 = *(void *)(a1 + 56);
  uint64_t v18 = a1 + 56;
  uint64_t v17 = v19;
  int v20 = *(char *)(v18 + 23);
  if (v20 >= 0) {
    uint64_t v21 = v18;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v20 >= 0) {
    uint64_t v22 = *(unsigned __int8 *)(v18 + 23);
  }
  else {
    uint64_t v22 = *(void *)(v18 + 8);
  }
  sub_10000CF44(v16, v21, v22);
  std::stringbuf::str(a2, &v27);
  *(void *)((char *)v25
  uint64_t v26 = v23;
  std::streambuf::~streambuf(&v27);
  return std::ios::~ios(&v28);
}

void sub_100BF90FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF9110@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v26, (uint64_t)"nominal,", 8LL);
  sub_100BF94A8(a1, &v24);
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v5 = &v24;
  }
  else {
    int v5 = (std::stringbuf::string_type *)v24.__r_.__value_.__r.__words[0];
  }
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v24.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v24.__r_.__value_.__l.__size_;
  }
  uint64_t v7 = sub_10000CF44(v4, (uint64_t)v5, size);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",cellular,", 10LL);
  sub_100BF95FC(a1 + 16, &v23);
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v9 = &v23;
  }
  else {
    uint64_t v9 = (std::stringbuf::string_type *)v23.__r_.__value_.__r.__words[0];
  }
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = v23.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v10 = v23.__r_.__value_.__l.__size_;
  }
  uint64_t v11 = sub_10000CF44(v8, (uint64_t)v9, v10);
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)",thermal,", 9LL);
  sub_100BF97A8(a1 + 56, &v22);
  if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v13 = &v22;
  }
  else {
    uint64_t v13 = (std::stringbuf::string_type *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v14 = v22.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v14 = v22.__r_.__value_.__l.__size_;
  }
  uint64_t v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
  int v16 = sub_10000CF44(v15, (uint64_t)",peakPower,", 11LL);
  sub_100BF97A8(a1 + 108, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v18 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v18 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v16, (uint64_t)p_p, v18);
  std::stringbuf::str(a2, &v27);
  *(void *)((char *)v25
  uint64_t v26 = v19;
  std::streambuf::~streambuf(&v27);
  return std::ios::~ios(&v28);
}

void sub_100BF9318( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, char a34)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_1011F8850((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF939C@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v12, (uint64_t)"numInFlightUploads,", 19LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",maxUploadFileSizeMB,", 21LL);
  uint64_t v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",maxUploadQuotaMB,", 18LL);
  std::ostream::operator<<(v8, a1[2]);
  std::stringbuf::str(a2, &v13);
  *(void *)((char *)v11
  uint64_t v12 = v9;
  std::streambuf::~streambuf(&v13);
  return std::ios::~ios(&v14);
}

void sub_100BF9494(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF94A8@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v18, (uint64_t)"allowNewStreamingRequests,", 26LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",allowNewMediaRequests,", 23LL);
  uint64_t v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)",maxFramerateFps,", 17LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *((unsigned int *)a1 + 1));
  uint64_t v10 = sub_10000CF44(v9, (uint64_t)",maxStreamingBitrateKbps,", 25LL);
  uint64_t v11 = (void *)std::ostream::operator<<(v10, *((unsigned int *)a1 + 2));
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)",dropStreaming,", 15LL);
  std::stringbuf v13 = (void *)std::ostream::operator<<(v12, a1[12]);
  uint64_t v14 = sub_10000CF44(v13, (uint64_t)",delayMedia,", 12LL);
  std::ostream::operator<<(v14, a1[13]);
  std::stringbuf::str(a2, &v19);
  *(void *)((char *)v17
  uint64_t v18 = v15;
  std::streambuf::~streambuf(&v19);
  return std::ios::~ios(&v20);
}

void sub_100BF95E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF95FC@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v20, (uint64_t)"enabled,", 8LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",rsrpThresholddBm,", 18LL);
  uint64_t v7 = (void *)std::ostream::operator<<(v6, *((unsigned int *)a1 + 1));
  sub_10000CF44(v7, (uint64_t)",rsrpQueryRateSecs,", 19LL);
  uint64_t v8 = (void *)std::ostream::operator<<(*((double *)a1 + 1));
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",rsrpSamplesToAvg,", 18LL);
  uint64_t v10 = (void *)std::ostream::operator<<(v9, *((unsigned int *)a1 + 4));
  uint64_t v11 = sub_10000CF44(v10, (uint64_t)",ulFreqThresholdMHz,", 20LL);
  uint64_t v12 = (void *)std::ostream::operator<<(v11, *((unsigned int *)a1 + 5));
  std::stringbuf v13 = sub_10000CF44(v12, (uint64_t)",belowThresholdParams,", 22LL);
  sub_100BF94A8(a1 + 24, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v13, (uint64_t)p_p, size);
  std::stringbuf::str(a2, &v21);
  *(void *)((char *)v19
  uint64_t v20 = v16;
  std::streambuf::~streambuf(&v21);
  return std::ios::~ios(&v22);
}

void sub_100BF9778( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF97A8@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v23, (uint64_t)"enabled,", 8LL);
  int v5 = (void *)std::ostream::operator<<(v4, *a1);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)",light,", 7LL);
  sub_100BF94A8(a1 + 4, &v21);
  if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v7 = &v21;
  }
  else {
    uint64_t v7 = (std::stringbuf::string_type *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v21.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v21.__r_.__value_.__l.__size_;
  }
  uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, size);
  uint64_t v10 = sub_10000CF44(v9, (uint64_t)",moderate,", 10LL);
  sub_100BF94A8(a1 + 20, &v20);
  if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v11 = &v20;
  }
  else {
    uint64_t v11 = (std::stringbuf::string_type *)v20.__r_.__value_.__r.__words[0];
  }
  if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v12 = v20.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v12 = v20.__r_.__value_.__l.__size_;
  }
  std::stringbuf v13 = sub_10000CF44(v10, (uint64_t)v11, v12);
  uint64_t v14 = sub_10000CF44(v13, (uint64_t)",heavyAndGreater,", 17LL);
  sub_100BF94A8(a1 + 36, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v16 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v16 = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v14, (uint64_t)p_p, v16);
  std::stringbuf::str(a2, &v24);
  *(void *)((char *)v22
  uint64_t v23 = v17;
  std::streambuf::~streambuf(&v24);
  return std::ios::~ios(&v25);
}

void sub_100BF9974( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_1011F8850((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void *sub_100BF99E4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1018779A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BF9A18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1018779A8;
  a2[1] = v2;
  return result;
}

void sub_100BF9A34(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_100BF9A40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100BF9A7C()
{
}

void sub_100BF9A88(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_100F98764();
    operator delete(v4);
  }

uint64_t sub_100BF9AB4(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100BF9AEC(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_100BF6F74((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

uint64_t sub_100BF9B28(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100BF9B60(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_10032ABFC((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

uint64_t *sub_100BF9B9C(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v13 = a1 + 16;
  uint64_t v14 = operator new(0x4A0uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  void *v14 = 0LL;
  v14[1] = v7;
  sub_100BF9DF0((uint64_t)(v14 + 2), *a4);
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1LL;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100019E10(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  std::stringbuf::string_type v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *std::stringbuf::string_type v21 = v24[0];
  }

  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8LL);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8) {
          v22 %= v8;
        }
      }

      else
      {
        v22 &= v8 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }

  uint64_t i = (uint64_t *)v24[0];
  v24[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_100BF9EEC((uint64_t)v24, 0LL);
  return i;
}

void sub_100BF9DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BF9DF0(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = (_OWORD *)(a1 + 1020);
  *(_DWORD *)a1 = *a2;
  bzero((void *)(a1 + 16), 0x480uLL);
  *(_DWORD *)(a1 + 8) = 255;
  *(_DWORD *)(a1 + 12) = 257;
  *(void *)&__int128 v4 = 0x100000001LL;
  *((void *)&v4 + 1) = 0x100000001LL;
  *(_OWORD *)(a1 + sub_100231C10(v1 + 28) = v4;
  *(void *)(a1 + 52) = 0LL;
  *(void *)(a1 + 44) = 0LL;
  *(void *)(a1 + 57) = 0LL;
  *(_OWORD *)(a1 + 76) = v4;
  *(void *)(a1 + 10sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 92) = 0LL;
  *(void *)(a1 + 105) = 0LL;
  *(void *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0x401C000000000000LL;
  sub_100BF6A60(a1 + 128);
  *(_OWORD *)(a1 + 968) = 0u;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_WORD *)(a1 + 100sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 7275;
  *(void *)(a1 + 1004) = 0LL;
  *(_WORD *)(a1 + 1016) = 256;
  _OWORD *v3 = xmmword_1013291A0;
  *(void *)(a1 + 1036) = 0x93A80018B8200LL;
  *(_WORD *)(a1 + 1044) = 256;
  *(_OWORD *)((char *)v3 + sub_100231C10(v1 + 28) = xmmword_1013291A0;
  *(void *)(a1 + 1064) = 0x93A80018B8200LL;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 112sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  return a1;
}

void sub_100BF9EEC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100BF6F74((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }

uint64_t *sub_100BF9F30(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
    }

    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }

    uint8x8_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v6) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v4) {
            break;
          }
        }
      }
    }
  }

  sub_100BFA174(a1, *a2, a4, (uint64_t)v21);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100019E10(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
      else {
        unint64_t v4 = v6;
      }
    }

    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
  }

  unint64_t v18 = *(void **)(*(void *)a1 + 8 * v4);
  if (v18)
  {
    *(void *)v21[0] = *v18;
    void *v18 = v21[0];
  }

  else
  {
    *(void *)v21[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v21[0])
    {
      unint64_t v19 = *(void *)(*(void *)v21[0] + 8LL);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v19 >= v7) {
          v19 %= v7;
        }
      }

      else
      {
        v19 &= v7 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v19) = v21[0];
    }
  }

  uint64_t i = (uint64_t *)v21[0];
  v21[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_100BFA2F0((uint64_t)v21, 0LL);
  return i;
}

void sub_100BFA15C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100BFA174@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0xA8uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0LL;
  v8[1] = a2;
  *((_DWORD *)v8 + 4) = **a3;
  uint64_t result = sub_100BFA1EC((uint64_t)(v8 + 3));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100BFA1D4(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFA1EC(uint64_t a1)
{
  *(_DWORD *)a1 = 255;
  sub_1010DDBC0((void *)(a1 + 8), (char *)[@"kBundleIDUnavailable" UTF8String]);
  *(_BYTE *)(a1 + 32) = 0;
  sub_1010DDBC0((void *)(a1 + 40), (char *)[@"kBundleVersionUnavailable" UTF8String]);
  *(_BYTE *)(a1 + 64) = 0;
  sub_1002A5370((void *)(a1 + 72));
  *(_BYTE *)(a1 + 88) = 0;
  sub_1002A5370((void *)(a1 + 96));
  *(_BYTE *)(a1 + 112) = 0;
  sub_1002A5370((void *)(a1 + 120));
  *(_BYTE *)(a1 + 136) = 0;
  return a1;
}

void sub_100BFA298(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  sub_1002A5590(v6);
  sub_1002A5590(v5);
  _Unwind_Resume(a1);
}

void sub_100BFA2F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10032ABFC((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }

uint64_t sub_100BFA334@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_100BF71B4(a2, (uint64_t *)(a1 + 32));
}

uint64_t sub_100BFA340(uint64_t a1, uint64_t a2)
{
  return sub_100BF71B4(a1 + 32, (uint64_t *)(a2 + 32));
}

uint64_t sub_100BFA34C(uint64_t a1)
{
  return sub_100BF6F74(a1 + 32);
}

__n128 sub_100BFA354@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = a1[2];
  *a2 = result;
  a2[1].n128_u32[0] = a1[3].n128_u32[0];
  return result;
}

std::locale *sub_100BFA368(std::locale *a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_10111D974(a1);
  LODWORD(v6[3].__locale_) = a3;
  *(_OWORD *)((char *)&v6[3].__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v6[5].__locale_ + 4) = 0u;
  HIDWORD(v6[7].__locale_) = 0;
  uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  if ((v7 & 0x80u) == 0LL) {
    uint8x8_t v8 = (char *)a2;
  }
  else {
    uint8x8_t v8 = *(char **)a2;
  }
  if ((v7 & 0x80u) != 0LL) {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  return a1;
}

void sub_100BFA3E4(_Unwind_Exception *a1)
{
}

char *sub_100BFA400(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = operator new(8uLL);
  *uint64_t v6 = &off_101877A78;
  uint64_t v7 = operator new(0x10uLL);
  void *v7 = &off_101877B48;
  v7[1] = v6;
  sub_10111DB20((void *)(a1 + 40), (uint64_t)v7);
  *(void *)(a1 + 56) = *(void *)(a1 + 40);
  unsigned int v8 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v8 > 0x3F)
  {
    switch(v8)
    {
      case 0x40u:
        return sub_100BFA7C8(a1, a2, a3);
      case 0x80u:
        return (char *)sub_100BFA868(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
      case 0x100u:
        return sub_100BFA998(a1, a2, a3);
      default:
        goto LABEL_14;
    }
  }

  else if (v8)
  {
    if (v8 != 16)
    {
      if (v8 != 32) {
LABEL_14:
      }
        sub_100BFAAC8();
      return sub_100BFA7C8(a1, a2, a3);
    }

    return sub_100BFA69C(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }

  else
  {
    return sub_100BFA59C(a1, (unsigned __int8 *)a2, a3);
  }

void sub_100BFA534(_Unwind_Exception *a1)
{
}

void sub_100BFA550()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_parse);
}

void sub_100BFA588(_Unwind_Exception *a1)
{
}

char *sub_100BFA59C(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = sub_100BFAB94(a1, a2, a3);
  if (v7 == a2)
  {
    unsigned int v8 = operator new(0x10uLL);
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = *(void *)(v9 + 8);
    *unsigned int v8 = &off_101877B48;
    v8[1] = v10;
    *(void *)(v9 + 8) = v8;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  while (*v7 == 124)
  {
    uint64_t v11 = *(void *)(a1 + 56);
    float v12 = v7 + 1;
    uint64_t v7 = sub_100BFAB94(a1, v7 + 1, a3);
    if (v12 == v7)
    {
      float v13 = operator new(0x10uLL);
      uint64_t v14 = *(void *)(a1 + 56);
      uint64_t v15 = *(void *)(v14 + 8);
      void *v13 = &off_101877B48;
      v13[1] = v15;
      *(void *)(v14 + 8) = v13;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }

    sub_10111E27C(a1, v6, v11);
  }

  return (char *)v7;
}

char *sub_100BFA69C(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return (char *)a2;
  }
  uint64_t v4 = (char *)a3;
  if (*a2 == 94)
  {
    uint64_t v6 = operator new(0x18uLL);
    BOOL v7 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(v8 + 8);
    *uint64_t v6 = &off_101877BF0;
    v6[1] = v9;
    *((_BYTE *)v6 + 16) = v7;
    *(void *)(v8 + 8) = v6;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    ++v3;
  }

  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      uint64_t v10 = v3;
      uint64_t v3 = sub_100BFF3C8(a1, (uint64_t)v3, v4);
    }

    while (v10 != v3);
    if (v10 != v4)
    {
      if (v10 + 1 != v4 || *v10 != 36) {
        sub_100BFF37C();
      }
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(v13 + 8);
      *uint64_t v11 = &off_101877C38;
      v11[1] = v14;
      *((_BYTE *)v11 + 16) = v12;
      *(void *)(v13 + 8) = v11;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }
  }

  return v4;
}

char *sub_100BFA7C8(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = sub_100BFF8C0(a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2) {
LABEL_9:
  }
    sub_100BFF37C();
  uint64_t v8 = v7;
  while (v8 != (unsigned __int8 *)a3)
  {
    if (*v8 != 124) {
      return (char *)v8;
    }
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = sub_100BFF8C0(a1, (char *)v8 + 1, a3);
    if (v8 + 1 == v10) {
      goto LABEL_9;
    }
    uint64_t v8 = v10;
    sub_10111E27C(a1, v6, v9);
  }

  return a3;
}

unsigned __int8 *sub_100BFA868(uint64_t a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s)
  {
    uint64_t v9 = operator new(0x10uLL);
    uint64_t v10 = *(void *)(v6 + 8);
    *uint64_t v9 = &off_101877B48;
    v9[1] = v10;
    *(void *)(v6 + 8) = v9;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  else
  {
    sub_100BFA69C(a1, __s, v8);
  }

  if (v8 != a3) {
    ++v8;
  }
  while (v8 != a3)
  {
    uint64_t v11 = (unsigned __int8 *)memchr(v8, 10, a3 - v8);
    if (v11) {
      BOOL v12 = v11;
    }
    else {
      BOOL v12 = a3;
    }
    uint64_t v13 = *(void *)(a1 + 56);
    if (v12 == v8)
    {
      uint64_t v14 = operator new(0x10uLL);
      uint64_t v15 = *(void *)(v13 + 8);
      void *v14 = &off_101877B48;
      v14[1] = v15;
      *(void *)(v13 + 8) = v14;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }

    else
    {
      sub_100BFA69C(a1, v8, v12);
    }

    sub_10111E27C(a1, v6, v13);
    if (v12 == a3) {
      uint64_t v8 = v12;
    }
    else {
      uint64_t v8 = v12 + 1;
    }
  }

  return a3;
}

char *sub_100BFA998(uint64_t a1, char *__s, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = (char *)memchr(__s, 10, a3 - __s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s)
  {
    uint64_t v9 = operator new(0x10uLL);
    uint64_t v10 = *(void *)(v6 + 8);
    *uint64_t v9 = &off_101877B48;
    v9[1] = v10;
    *(void *)(v6 + 8) = v9;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  else
  {
    sub_100BFA7C8(a1, __s, v8);
  }

  if (v8 != a3) {
    ++v8;
  }
  while (v8 != a3)
  {
    uint64_t v11 = (char *)memchr(v8, 10, a3 - v8);
    if (v11) {
      BOOL v12 = v11;
    }
    else {
      BOOL v12 = a3;
    }
    uint64_t v13 = *(void *)(a1 + 56);
    if (v12 == v8)
    {
      uint64_t v14 = operator new(0x10uLL);
      uint64_t v15 = *(void *)(v13 + 8);
      void *v14 = &off_101877B48;
      v14[1] = v15;
      *(void *)(v13 + 8) = v14;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }

    else
    {
      sub_100BFA7C8(a1, v8, v12);
    }

    sub_10111E27C(a1, v6, v13);
    if (v12 == a3) {
      uint64_t v8 = v12;
    }
    else {
      uint64_t v8 = v12 + 1;
    }
  }

  return a3;
}

void sub_100BFAAC8()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_grammar);
}

void sub_100BFAB00(_Unwind_Exception *a1)
{
}

void sub_100BFAB14(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

uint64_t sub_100BFAB28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_100BFAB40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_100BFAB80(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + 8);
  return result;
}

unsigned __int8 *sub_100BFAB94(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  do
  {
    uint64_t v5 = a2;
    a2 = sub_100BFABDC(a1, (char *)a2, a3);
  }

  while (v5 != a2);
  return v5;
}

unsigned __int8 *sub_100BFABDC(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)sub_100BFAC70(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    uint64_t v7 = *(void *)(a1 + 56);
    int v8 = *(_DWORD *)(a1 + 28);
    uint64_t v9 = sub_100BFAF00(a1, (unsigned __int8 *)a2, a3);
    uint64_t result = (unsigned __int8 *)a2;
  }

  return result;
}

char *sub_100BFAC70(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      if (v6 == 40 && a2 + 1 != a3 && a2[1] == 63 && a2 + 2 != a3)
      {
        int v7 = a2[2];
        if (v7 == 33)
        {
          sub_10111D974(v19);
          __int128 v20 = 0u;
          uint64_t v22 = 0LL;
          __int128 v21 = 0u;
          LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_DWORD *)(a1 + 24);
          int v8 = (char *)sub_100BFA400(v19, v3 + 3, a3);
          int v18 = DWORD1(v20);
          sub_10111EBB4(a1, (uint64_t)v19, 1, *(_DWORD *)(a1 + 28));
          *(_DWORD *)(a1 + 28) += v18;
          if (v8 == a3 || *v8 != 41) {
            sub_100BFB3E0();
          }
          goto LABEL_27;
        }

        if (v7 == 61)
        {
          sub_10111D974(v19);
          __int128 v20 = 0u;
          uint64_t v22 = 0LL;
          __int128 v21 = 0u;
          LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_DWORD *)(a1 + 24);
          int v8 = (char *)sub_100BFA400(v19, v3 + 3, a3);
          int v9 = DWORD1(v20);
          sub_10111EBB4(a1, (uint64_t)v19, 0, *(_DWORD *)(a1 + 28));
          *(_DWORD *)(a1 + 28) += v9;
          if (v8 == a3 || *v8 != 41) {
            sub_100BFB3E0();
          }
LABEL_27:
          uint64_t v3 = v8 + 1;
          sub_10000AE14((uint64_t)&v21);
          std::locale::~locale(v19);
          return v3;
        }
      }

      return v3;
    }

    uint64_t v10 = operator new(0x18uLL);
    BOOL v11 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(v12 + 8);
LABEL_17:
    *uint64_t v10 = v14 + 2;
    v10[1] = v13;
    *((_BYTE *)v10 + 16) = v11;
    *(void *)(v12 + 8) = v10;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    return ++v3;
  }

  if (v6 != 92)
  {
    if (v6 != 94) {
      return v3;
    }
    uint64_t v10 = operator new(0x18uLL);
    BOOL v11 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(v12 + 8);
    goto LABEL_17;
  }

  if (a2 + 1 != a3)
  {
    int v16 = a2[1];
    if (v16 == 66)
    {
      char v17 = 1;
    }

    else
    {
      if (v16 != 98) {
        return v3;
      }
      char v17 = 0;
    }

    sub_10111EB40(a1, v17);
    v3 += 2;
  }

  return v3;
}

void sub_100BFAED4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

unsigned __int8 *sub_100BFAF00(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 != (unsigned __int8 *)a3)
  {
    int v6 = (char)*a2;
    if (v6 <= 62)
    {
      if (v6 == 40)
      {
        BOOL v11 = a2 + 1;
        if (a2 + 1 != (unsigned __int8 *)a3)
        {
          if (a2 + 2 != (unsigned __int8 *)a3 && *v11 == 63 && a2[2] == 58)
          {
            ++*(_DWORD *)(a1 + 36);
            uint64_t v12 = (char *)sub_100BFA59C(a1, a2 + 3, a3);
            if (v12 != a3 && *v12 == 41)
            {
              --*(_DWORD *)(a1 + 36);
              return (unsigned __int8 *)(v12 + 1);
            }
          }

          else
          {
            sub_10111F720((void *)a1);
            int v13 = *(_DWORD *)(a1 + 28);
            ++*(_DWORD *)(a1 + 36);
            uint64_t v14 = (char *)sub_100BFA59C(a1, v11, a3);
            if (v14 != a3)
            {
              uint64_t v15 = v14;
              if (*v14 == 41)
              {
                sub_10111F784((void *)a1, v13);
                --*(_DWORD *)(a1 + 36);
                return (unsigned __int8 *)(v15 + 1);
              }
            }
          }
        }

        sub_100BFB3E0();
      }

      if (v6 == 46)
      {
        int v7 = operator new(0x10uLL);
        uint64_t v8 = *(void *)(a1 + 56);
        uint64_t v9 = *(void *)(v8 + 8);
        void *v7 = &off_101877D10;
        v7[1] = v9;
        *(void *)(v8 + 8) = v7;
        *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
        return ++v3;
      }

unsigned __int8 *sub_100BFB0D8( uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5, int a6)
{
  if (a2 == a3) {
    return a2;
  }
  int v6 = a6;
  int v7 = a5;
  uint64_t v10 = a1;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      int v13 = a2 + 1;
      if (v11) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v13 == a3;
      }
      if (!v20 && *v13 == 63)
      {
        int v13 = a2 + 2;
        uint64_t v14 = 0LL;
        uint64_t v18 = 1LL;
        goto LABEL_33;
      }

      uint64_t v14 = 0LL;
      uint64_t v18 = 1LL;
      goto LABEL_45;
    }

    int v13 = a2;
    if (v12 != 123) {
      return v13;
    }
    uint64_t v15 = a2 + 1;
    int v16 = sub_100BFEFA0(a1, a2 + 1, a3, &v28);
    if (v15 != v16)
    {
      if (v16 != a3)
      {
        int v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            int v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              int v13 = v16 + 2;
              uint64_t v14 = v28;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              uint64_t v18 = v28;
LABEL_33:
              uint64_t v21 = a4;
              char v22 = 0;
LABEL_46:
              sub_1011217B0(a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }

            uint64_t v14 = v28;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            uint64_t v18 = v28;
LABEL_45:
            uint64_t v21 = a4;
            char v22 = 1;
            goto LABEL_46;
          }

          goto LABEL_58;
        }

        uint64_t v23 = v16 + 1;
        if (v16 + 1 == a3) {
          goto LABEL_58;
        }
        if (*v23 == 125)
        {
          int v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            int v13 = v16 + 3;
            uint64_t v14 = v28;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }

          uint64_t v14 = v28;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          uint64_t v18 = -1LL;
          goto LABEL_45;
        }

        int v27 = -1;
        char v25 = sub_100BFEFA0(v10, v23, a3, &v27);
        if (v23 != v25 && v25 != a3 && *v25 == 125)
        {
          uint64_t v18 = v27;
          uint64_t v14 = v28;
          if (v27 >= v28)
          {
            int v13 = v25 + 1;
            char v22 = 1;
            if (!v11 && v13 != a3)
            {
              int v26 = v25[1];
              char v22 = v26 != 63;
              if (v26 == 63) {
                int v13 = v25 + 2;
              }
            }

            a5 = v7;
            a6 = v6;
            a1 = v10;
            uint64_t v21 = a4;
            goto LABEL_46;
          }

          goto LABEL_58;
        }
      }

      sub_100BFF088();
    }

void sub_100BFB3E0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_paren);
}

void sub_100BFB418(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFB42C(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(_BYTE *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0LL;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }

  else
  {
    if (!*(_BYTE *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1LL);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }

  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v4;
  return result;
}

uint64_t sub_100BFB48C(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(_BYTE *)(a2 + 88) & 2) == 0
    || *(_BYTE *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }

  else
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v5;
  return result;
}

uint64_t sub_100BFB4DC(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(_BYTE *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }

uint64_t sub_100BFB5F0(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  *(void *)a1 = off_101877CC8;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_OWORD *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(void *)(a1 + 64) = v9;
  if (v9)
  {
    int v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  *(void *)(a1 + 72) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a5;
  *(_BYTE *)(a1 + 84) = a3;
  return a1;
}

void sub_100BFB67C(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  char v25 = 0;
  __int128 v26 = 0uLL;
  char v27 = 0;
  char v28 = 0;
  uint64_t v29 = 0LL;
  std::stringbuf::string_type __p = 0LL;
  BOOL v19 = 0LL;
  unint64_t v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v20 = 0LL;
  *(void *)&__int128 v21 = v5;
  *((void *)&v21 + 1) = v5;
  char v22 = 0;
  sub_100BFB804((char **)&__p, v4, &v21);
  uint64_t v23 = v6;
  uint64_t v24 = v6;
  char v25 = 0;
  __int128 v26 = v21;
  char v27 = v22;
  uint64_t v29 = v6;
  char v28 = 1;
  uint64_t v7 = *(void *)(a2 + 16);
  if (*(_BYTE *)(a2 + 92)) {
    BOOL v8 = v7 == *(void *)(a2 + 8);
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  if (*(unsigned __int8 *)(a1 + 84) == sub_10111EF38( a1 + 16,  v7,  *(void *)(a2 + 24),  (uint64_t *)&__p,  *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u,  v9))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
    int v10 = (char *)__p;
    goto LABEL_13;
  }

  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(a1 + 8);
  int v10 = (char *)__p;
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (_BYTE *)__p) >> 3);
  if (v11 < 2)
  {
LABEL_13:
    if (!v10) {
      return;
    }
    goto LABEL_14;
  }

  int v12 = 0;
  int v13 = *(_DWORD *)(a1 + 80);
  uint64_t v14 = *(void *)(a2 + 32);
  unint64_t v15 = 1LL;
  do
  {
    int v16 = &v10[24 * v15];
    uint64_t v17 = v14 + 24LL * (v13 + v12);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
    *(_BYTE *)(v17 + 16) = v16[16];
    unint64_t v15 = (v12 + 2);
    ++v12;
  }

  while (v11 > v15);
LABEL_14:
  BOOL v19 = v10;
  operator delete(v10);
}

void sub_100BFB7E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100BFB804(char **a1, unint64_t a2, __int128 *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) >= a2)
  {
    unint64_t v15 = a1[1];
    unint64_t v16 = (v15 - result) / 24;
    if (v16 >= a2) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = (v15 - result) / 24;
    }
    if (v17)
    {
      uint64_t v18 = result;
      do
      {
        *(_OWORD *)uint64_t v18 = *a3;
        v18[16] = *((_BYTE *)a3 + 16);
        v18 += 24;
        --v17;
      }

      while (v17);
    }

    if (a2 <= v16)
    {
      a1[1] = &result[24 * a2];
    }

    else
    {
      BOOL v19 = &v15[24 * (a2 - v16)];
      uint64_t v20 = 24 * a2 - 24 * v16;
      do
      {
        __int128 v21 = *a3;
        *((void *)v15 + 2) = *((void *)a3 + 2);
        *(_OWORD *)unint64_t v15 = v21;
        v15 += 24;
        v20 -= 24LL;
      }

      while (v20);
      a1[1] = v19;
    }
  }

  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555LL) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t result = sub_100006E1C(a1, v10);
    unint64_t v11 = a1[1];
    int v12 = &v11[24 * a2];
    uint64_t v13 = 24 * a2;
    do
    {
      __int128 v14 = *a3;
      *((void *)v11 + 2) = *((void *)a3 + 2);
      *(_OWORD *)unint64_t v11 = v14;
      v11 += 24;
      v13 -= 24LL;
    }

    while (v13);
    a1[1] = v12;
  }

  return result;
}

void sub_100BFB978(uint64_t a1, unint64_t a2, __int128 *a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v4 = a2 >= v3;
  unint64_t v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    sub_100BFBD0C((void **)a1, v5, a3);
  }

  else if (!v4)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 24 * a2;
  }

void sub_100BFB9B4(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }

  else
  {
    sub_100BFBE80((void **)a1, a2 - v2);
  }

void sub_100BFB9E4()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_complexity);
}

void sub_100BFBA1C(_Unwind_Exception *a1)
{
}

void sub_100BFBA30()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_unknown);
}

void sub_100BFBA68(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFBA7C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100BFBAF0((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100BFBAF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    do
    {
      __int128 v8 = *(_OWORD *)(a3 - 80);
      *(_OWORD *)(v7 - 96) = *(_OWORD *)(a3 - 96);
      *(_OWORD *)(v7 - 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
      *(void *)(v7 - 56) = 0LL;
      *(void *)(v7 - memset(v19, 0, 48) = 0LL;
      *(void *)(v7 - 64) = 0LL;
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(void *)(v7 - memset(v19, 0, 48) = *(void *)(a3 - 48);
      *(void *)(a3 - 64) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      *(void *)(a3 - memset(v19, 0, 48) = 0LL;
      *(void *)(v7 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
      *(void *)(v7 - 32) = 0LL;
      *(void *)(v7 - 24) = 0LL;
      *(_OWORD *)(v7 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(void *)(a3 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      uint64_t v9 = *(void *)(a3 - 16);
      *(void *)(v7 - 11) = *(void *)(a3 - 11);
      *(void *)(v7 - 16) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 96LL;
      *((void *)&v15 + 1) -= 96LL;
      a3 -= 96LL;
    }

    while (a3 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  sub_100BFBBD0((uint64_t)v12);
  return v10;
}

uint64_t sub_100BFBBD0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100BFBC04((uint64_t *)a1);
  }
  return a1;
}

void sub_100BFBC04(uint64_t *a1)
{
  uint64_t v1 = *(void **)(a1[2] + 8);
  unint64_t v2 = *(void **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_100BFBC54(v3, v1);
      v1 += 12;
    }

    while (v1 != v2);
  }

void sub_100BFBC54(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[7];
  if (v3)
  {
    a2[8] = v3;
    operator delete(v3);
  }

  BOOL v4 = (void *)a2[4];
  if (v4)
  {
    a2[5] = v4;
    operator delete(v4);
  }

void **sub_100BFBC98(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100BFBCC8(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 96;
    sub_100BFBC54(v4, (void *)(i - 96));
  }

void sub_100BFBD0C(void **a1, unint64_t a2, __int128 *a3)
{
  __int128 v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(void **)(v6 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)v9) >> 3) >= a2)
  {
    if (a2)
    {
      __int128 v15 = &v9[3 * a2];
      uint64_t v16 = 24 * a2;
      do
      {
        __int128 v17 = *a3;
        v9[2] = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v9 = v17;
        v9 += 3;
        v16 -= 24LL;
      }

      while (v16);
      uint64_t v9 = v15;
    }

    a1[1] = v9;
  }

  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (_BYTE *)*a1) >> 3);
    unint64_t v11 = v10 + a2;
    if (v10 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555LL) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      __int128 v14 = (char *)sub_10000701C(v6, v13);
    }
    else {
      __int128 v14 = 0LL;
    }
    uint64_t v18 = &v14[24 * v10];
    BOOL v19 = &v18[24 * a2];
    uint64_t v20 = 24 * a2;
    __int128 v21 = v18;
    do
    {
      __int128 v22 = *a3;
      *((void *)v21 + 2) = *((void *)a3 + 2);
      *(_OWORD *)__int128 v21 = v22;
      v21 += 24;
      v20 -= 24LL;
    }

    while (v20);
    uint64_t v23 = &v14[24 * v13];
    char v25 = (char *)*a1;
    uint64_t v24 = (char *)a1[1];
    if (v24 != *a1)
    {
      do
      {
        __int128 v26 = *(_OWORD *)(v24 - 24);
        *((void *)v18 - 1) = *((void *)v24 - 1);
        *(_OWORD *)(v18 - 24) = v26;
        v18 -= 24;
        v24 -= 24;
      }

      while (v24 != v25);
      uint64_t v24 = (char *)*a1;
    }

    *a1 = v18;
    a1[1] = v19;
    a1[2] = v23;
    if (v24) {
      operator delete(v24);
    }
  }

void sub_100BFBE80(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = v7 - (_BYTE *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)sub_100037038(v4, v12);
    }
    else {
      unint64_t v13 = 0LL;
    }
    __int128 v14 = &v13[16 * v10];
    __int128 v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    uint64_t v18 = (char *)*a1;
    __int128 v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }

      while (v17 != v18);
      __int128 v17 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17) {
      operator delete(v17);
    }
  }

void sub_100BFBF8C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        sub_100BFBC54((uint64_t)(v1 + 2), v4);
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

unsigned __int8 *sub_100BFC010(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  uint64_t v5 = a2 + 1;
  if (a2 + 1 == a3) {
    sub_100BFC27C();
  }
  uint64_t result = sub_100BFC2C8(a1, a2 + 1, a3);
  if (v5 == result)
  {
    uint64_t result = (unsigned __int8 *)sub_100BFC37C(a1, (char *)a2 + 1, (char *)a3);
    if (v5 == result)
    {
      uint64_t result = sub_100BFC448(a1, a2 + 1, (char *)a3, 0LL);
      if (v5 == result) {
        return a2;
      }
    }
  }

  return result;
}

char *sub_100BFC0B0(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3) {
      goto LABEL_20;
    }
    uint64_t v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    uint64_t v6 = (uint64_t *)sub_101120170(a1, a2[1] == 94);
    if (v5 == a3) {
      goto LABEL_20;
    }
    uint64_t v7 = v6;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      sub_100BFCB4C((uint64_t)v6, 93LL);
      ++v5;
    }

    if (v5 == a3) {
      goto LABEL_20;
    }
    do
    {
      uint64_t v8 = v5;
      uint64_t v5 = sub_100BFD818(a1, v5, a3, v7);
    }

    while (v8 != v5);
    if (v8 == a3) {
      goto LABEL_20;
    }
    if (*v8 == 45)
    {
      sub_100BFCB4C((uint64_t)v7, 45LL);
      ++v8;
    }

    if (v8 == a3 || *v8 != 93) {
LABEL_20:
    }
      sub_100BFD7CC();
    return v8 + 1;
  }

  return a2;
}

void sub_100BFC1C0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badrepeat);
}

void sub_100BFC1F8(_Unwind_Exception *a1)
{
}

_BYTE *sub_100BFC20C(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = (char)*a2;
    BOOL v5 = (v4 - 36) > 0x3A || ((1LL << (*a2 - 36)) & 0x7800000080004F1LL) == 0;
    if (v5 && (v4 - 123) >= 3)
    {
      sub_10111FBF0(a1, (char)v4);
      ++v3;
    }
  }

  return v3;
}

void sub_100BFC27C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_escape);
}

void sub_100BFC2B4(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100BFC2C8(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = *a2;
    uint64_t v5 = (v4 - 48);
    if (v4 == 48)
    {
      sub_10111FBF0(a1, v5);
      return ++v3;
    }

    if (++v3 == a3)
    {
      uint64_t v3 = a3;
    }

    else
    {
      while (1)
      {
        int v6 = *v3;
        ++v3;
        LODWORD(sub_1012279C0(0LL, v4, v5) = v6 + 10 * v5 - 48;
        if (v3 == a3)
        {
          uint64_t v3 = a3;
          break;
        }
      }

      if (!(_DWORD)v5) {
        goto LABEL_16;
      }
    }

    if (v5 <= *(_DWORD *)(a1 + 28))
    {
      sub_10111FCD4(a1, v5);
      return v3;
    }

char *sub_100BFC37C(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v4 = *a2;
  if (v4 > 99)
  {
    if (v4 == 119)
    {
      char v5 = 0;
      goto LABEL_15;
    }

    if (v4 == 115)
    {
      char v9 = 0;
      goto LABEL_17;
    }

    if (v4 != 100) {
      return v3;
    }
    char v6 = 0;
LABEL_12:
    uint64_t v7 = sub_101120170(a1, v6);
    int v8 = v7[40] | 0x400;
LABEL_18:
    v7[40] = v8;
    goto LABEL_19;
  }

  switch(v4)
  {
    case 'D':
      char v6 = 1;
      goto LABEL_12;
    case 'S':
      char v9 = 1;
LABEL_17:
      uint64_t v7 = sub_101120170(a1, v9);
      int v8 = v7[40] | 0x4000;
      goto LABEL_18;
    case 'W':
      char v5 = 1;
LABEL_15:
      uint64_t v10 = sub_101120170(a1, v5);
      v10[40] |= 0x500u;
      sub_100BFCB4C((uint64_t)v10, 95LL);
LABEL_19:
      ++v3;
      break;
  }

  return v3;
}

unsigned __int8 *sub_100BFC448(uint64_t a1, unsigned __int8 *a2, char *a3, std::string *this)
{
  int v4 = a2;
  if (a2 != (unsigned __int8 *)a3)
  {
    int v5 = (char)*a2;
    if (v5 > 109)
    {
      char v6 = 0;
      switch(*a2)
      {
        case 'n':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v8) = 10;
            goto LABEL_52;
          }

          uint64_t v8 = 10LL;
          goto LABEL_61;
        case 'r':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v8) = 13;
            goto LABEL_52;
          }

          uint64_t v8 = 13LL;
          goto LABEL_61;
        case 't':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v8) = 9;
            goto LABEL_52;
          }

          uint64_t v8 = 9LL;
          goto LABEL_61;
        case 'u':
          int v9 = a2[1];
          if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38 && (v9 | 0x20u) - 97 >= 6) {
            goto LABEL_66;
          }
          int v4 = a2 + 2;
          int v10 = *v4;
          char v11 = -48;
          if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
            goto LABEL_24;
          }
          v10 |= 0x20u;
          char v11 = -87;
LABEL_24:
          char v6 = 16 * (v11 + v10);
LABEL_25:
          int v12 = v4[1];
          char v13 = -48;
          if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38) {
            goto LABEL_30;
          }
          v12 |= 0x20u;
          char v13 = -87;
LABEL_30:
          int v14 = v4[2];
          char v15 = -48;
          if ((v14 & 0xF8) == 0x30 || (v14 & 0xFE) == 0x38) {
            goto LABEL_35;
          }
          v14 |= 0x20u;
          char v15 = -87;
LABEL_35:
          if (this) {
            std::string::operator=(this, v15 + v14 + 16 * (v13 + v12 + v6));
          }
          else {
            sub_10111FBF0(a1, (char)(v15 + v14 + 16 * (v13 + v12 + v6)));
          }
          v4 += 3;
          return v4;
        case 'v':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v8) = 11;
            goto LABEL_52;
          }

          uint64_t v8 = 11LL;
          break;
        case 'x':
          goto LABEL_25;
        default:
          goto LABEL_47;
      }

      goto LABEL_61;
    }

    if (v5 == 48)
    {
      if (this)
      {
        uint64_t v7 = this;
        LOBYTE(v8) = 0;
        goto LABEL_52;
      }

      uint64_t v8 = 0LL;
LABEL_61:
      sub_10111FBF0(a1, v8);
      return ++v4;
    }

    if (v5 != 99)
    {
      if (v5 == 102)
      {
        if (this)
        {
          uint64_t v7 = this;
          LOBYTE(v8) = 12;
LABEL_52:
          std::string::operator=(v7, v8);
          return ++v4;
        }

        uint64_t v8 = 12LL;
        goto LABEL_61;
      }

void sub_100BFC724()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_backref);
}

void sub_100BFC75C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFC770(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = off_101877D58;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 8) + 40LL))( *(void *)(a2 + 8),  a3);
  return a1;
}

void sub_100BFC7DC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &off_101877BC0;
  uint64_t v4 = v1[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BFC814(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40LL))( *(void *)(result + 24),  *v3),  *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v5;
  return result;
}

uint64_t sub_100BFC88C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v3;
  return result;
}

uint64_t sub_100BFC8D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v3;
  return result;
}

uint64_t sub_100BFC91C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 40) - 1);
  if (*(_BYTE *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }

      uint64_t v8 = 0LL;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  *(char *)(*(void *)v3 + v8));
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != (_DWORD)result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }

  uint64_t v6 = 0LL;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v6;
  return result;
}

uint64_t sub_100BFCA00(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(_BYTE *)(v3 + 24LL * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24LL * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }

      int v9 = *(unsigned __int8 **)(a2 + 16);
      uint64_t v10 = v6;
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v9++;
        if (v11 != v13) {
          break;
        }
        if (!--v10) {
          goto LABEL_8;
        }
      }
    }
  }

  uint64_t v8 = 0LL;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
  return result;
}

unsigned int *sub_100BFCA90(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    sub_100BFC724();
  }
  unsigned int v5 = v2 - 1;
  if (*(_BYTE *)(v3 + 24LL * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24LL * v5,
        uint64_t result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (uint64_t result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !(_DWORD)result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }

  else
  {
    uint64_t v10 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v10;
  return result;
}

void sub_100BFCB4C(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(_BYTE **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 40);
      int64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          int v12 = operator new(v11);
        }
        else {
          int v12 = 0LL;
        }
        uint64_t v20 = &v8[(void)v12];
        __int128 v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          __int128 v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }

          while (v5 != (_BYTE *)v7);
LABEL_45:
          unsigned int v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }

        goto LABEL_46;
      }

uint64_t sub_100BFCD78(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = off_101877F08;
  *(void *)(a1 + 8) = a3;
  size_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  __int128 v12 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 24) = v12;
  *(_OWORD *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 168) = a4;
  *(_BYTE *)(a1 + 169) = a5;
  *(_BYTE *)(a1 + 17sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a6;
  std::locale::locale(&v15, v11);
  std::locale::name(&v16, &v15);
  if ((char)v16.__r_.__value_.__s.__size_ < 0)
  {
    BOOL v13 = v16.__r_.__value_.__l.__size_ != 1 || *v16.__r_.__value_.__l.__data_ != 67;
    operator delete(v16.__r_.__value_.__l.__data_);
  }

  else
  {
    BOOL v13 = v16.__r_.__value_.__s.__size_ != 1 || v16.__r_.__value_.__s.__data_[0] != 67;
  }

  std::locale::~locale(&v15);
  *(_BYTE *)(a1 + 171) = v13;
  return a1;
}

void sub_100BFCE88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  a10 = v10 + 17;
  sub_1000129D4((void ***)&a10);
  unint64_t v14 = (void *)v10[14];
  if (v14)
  {
    v10[15] = v14;
    operator delete(v14);
  }

  sub_100159450((void ***)&a10);
  std::locale v15 = (void *)v10[8];
  if (v15)
  {
    v10[9] = v15;
    operator delete(v15);
  }

  std::string v16 = *v12;
  if (*v12)
  {
    v10[6] = v16;
    operator delete(v16);
  }

  std::locale::~locale(v11);
  *unint64_t v10 = &off_101877BC0;
  uint64_t v17 = v10[1];
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  _Unwind_Resume(a1);
}

void sub_100BFCF14(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(signed __int8 **)(a2 + 16);
  unsigned int v5 = *(signed __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v37 = 0LL;
    int v36 = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_221;
  }

  if (!*(_BYTE *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_58;
  }
  signed __int8 v6 = *v4;
  unsigned __int8 v121 = *v4;
  signed __int8 v7 = v4[1];
  unsigned __int8 v122 = v7;
  if (*(_BYTE *)(a1 + 169))
  {
    unsigned __int8 v121 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v6);
    unsigned __int8 v122 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v7);
  }

  uint64_t v8 = a1 + 16;
  sub_1011203F0(a1 + 16, (char *)&v121, (char *)&v123, &__p);
  if (((char)__p.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (__p.__r_.__value_.__s.__size_) {
      goto LABEL_8;
    }
LABEL_58:
    int v36 = 0;
    uint64_t v37 = 1LL;
    goto LABEL_59;
  }

  std::string::size_type size = __p.__r_.__value_.__l.__size_;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!size) {
    goto LABEL_58;
  }
LABEL_8:
  uint64_t v9 = *(void *)(a1 + 112);
  uint64_t v10 = *(void *)(a1 + 120) - v9;
  if (v10)
  {
    uint64_t v11 = v10 >> 1;
    __int128 v12 = (_BYTE *)(v9 + 1);
    do
    {
      v12 += 2;
      --v11;
    }

    while (v11);
  }

  if (!*(_BYTE *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v36 = 0;
  }

  else
  {
    sub_101120354(a1 + 16, (char *)&v121, (char *)&v123);
    uint64_t v14 = *(void *)(a1 + 88);
    unsigned __int8 v15 = __p.__r_.__value_.__s.__size_;
    uint64_t v16 = *(void *)(a1 + 96) - v14;
    if (v16)
    {
      uint64_t v17 = 0LL;
      unint64_t v18 = v16 / 48;
      unsigned __int8 v111 = __p.__r_.__value_.__s.__size_;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v19 = __p.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v19 = __p.__r_.__value_.__l.__size_;
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (v18 <= 1) {
        uint64_t v21 = 1LL;
      }
      else {
        uint64_t v21 = v16 / 48;
      }
      BOOL v22 = 1;
      while (1)
      {
        int v23 = *(char *)(v14 + 23);
        if (v23 >= 0) {
          size_t v24 = *(unsigned __int8 *)(v14 + 23);
        }
        else {
          size_t v24 = *(void *)(v14 + 8);
        }
        if (v23 >= 0) {
          char v25 = (const void *)v14;
        }
        else {
          char v25 = *(const void **)v14;
        }
        if (v24 >= v19) {
          size_t v26 = v19;
        }
        else {
          size_t v26 = v24;
        }
        int v27 = memcmp(p_p, v25, v26);
        BOOL v28 = v19 >= v24;
        if (v27) {
          BOOL v28 = v27 >= 0;
        }
        if (v28)
        {
          int v29 = *(char *)(v14 + 47);
          if (v29 >= 0) {
            size_t v30 = *(unsigned __int8 *)(v14 + 47);
          }
          else {
            size_t v30 = *(void *)(v14 + 32);
          }
          if (v29 >= 0) {
            uint64_t v31 = (const void *)(v14 + 24);
          }
          else {
            uint64_t v31 = *(const void **)(v14 + 24);
          }
          if (v19 >= v30) {
            size_t v32 = v30;
          }
          else {
            size_t v32 = v19;
          }
          int v33 = memcmp(v31, p_p, v32);
          BOOL v34 = v30 >= v19;
          if (v33) {
            BOOL v34 = v33 >= 0;
          }
          if (v34) {
            break;
          }
        }

        BOOL v22 = ++v17 < v18;
        v14 += 48LL;
        if (v21 == v17)
        {
          int v35 = 0;
          int v36 = 0;
          goto LABEL_162;
        }
      }

      int v36 = 1;
      int v35 = 5;
LABEL_162:
      uint64_t v8 = a1 + 16;
      unsigned __int8 v15 = v111;
    }

    else
    {
      BOOL v22 = 0;
      int v35 = 0;
      int v36 = 0;
    }

    if ((v15 & 0x80) != 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v22) {
      goto LABEL_195;
    }
  }

  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_200;
  }
  sub_101120628(v8, (char *)&v121, (char *)&v123, (uint64_t)&__p);
  uint64_t v88 = *(void *)(a1 + 136);
  uint64_t v89 = __p.__r_.__value_.__s.__size_;
  uint64_t v90 = *(void *)(a1 + 144) - v88;
  if (v90)
  {
    uint64_t v91 = 0LL;
    unint64_t v92 = v90 / 24;
    __int128 v93 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v94 = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v94 = __p.__r_.__value_.__l.__size_;
    }
    if (v92 <= 1) {
      uint64_t v95 = 1LL;
    }
    else {
      uint64_t v95 = v90 / 24;
    }
    BOOL v96 = 1;
    while (1)
    {
      __int16 v97 = (unsigned __int8 **)(v88 + 24 * v91);
      char v98 = (unsigned __int8 *)*((unsigned __int8 *)v97 + 23);
      int v99 = (char)v98;
      if ((unsigned __int8 *)v94 == v98)
      {
        if (v99 >= 0) {
          __int16 v100 = (unsigned __int8 *)(v88 + 24 * v91);
        }
        else {
          __int16 v100 = *v97;
        }
        if ((v89 & 0x80) == 0)
        {
          if ((_DWORD)v89)
          {
            __int16 v101 = &__p;
            uint64_t v102 = v89;
            do
            {
              __int16 v101 = (std::string *)((char *)v101 + 1);
              ++v100;
              --v102;
            }

            while (v102);
            int v36 = 1;
            int v35 = 5;
            goto LABEL_192;
          }

          int v36 = 1;
          if (v96) {
            goto LABEL_220;
          }
LABEL_200:
          if ((char)v121 < 0)
          {
            int v107 = *(_DWORD *)(a1 + 164);
            goto LABEL_213;
          }

          int v104 = *(_DWORD *)(a1 + 160);
          uint64_t v105 = *(void *)(*(void *)(a1 + 24) + 16LL);
          int v106 = *(_DWORD *)(v105 + 4LL * v121);
          if ((v106 & v104) == 0 && (v121 != 95 || (v104 & 0x80) == 0)
            || (char)v122 < 0
            || (*(_DWORD *)(v105 + 4LL * v122) & v104) == 0 && ((v104 & 0x80) == 0 || v122 != 95))
          {
            int v107 = *(_DWORD *)(a1 + 164);
            if ((v106 & v107) != 0 || v121 == 95 && (v107 & 0x80) != 0)
            {
LABEL_217:
              int v108 = v36;
              goto LABEL_219;
            }

LABEL_218:
          int v108 = 1;
          goto LABEL_219;
        }

        unint64_t v116 = v92;
        uint64_t v119 = v89;
        int v103 = memcmp((const void *)v93, v100, *((size_t *)&v93 + 1));
        unint64_t v92 = v116;
        uint64_t v89 = v119;
        if (!v103) {
          break;
        }
      }

          *(_DWORD *)(a1 + 108) = v106;
          goto LABEL_252;
        case 0xDu:
          *(_WORD *)(a1 + 120) |= 0x10u;
          uint64_t v109 = *((void *)this + 1);
          int v110 = *((void *)this + 2);
          unsigned __int8 v111 = *(void *)this;
          if (v109 <= 0xFFFFFFFFFFFFFFF5LL && v109 + 10 <= v110)
          {
            unsigned __int8 v112 = 0;
            uint64_t v113 = 0;
            int v114 = 0LL;
            do
            {
              int v115 = v109 + 1;
              *((void *)this + 1) = v109 + 1;
              unint64_t v116 = *(_BYTE *)(v111 + v109);
              v114 |= (unint64_t)(v116 & 0x7F) << v112;
              if ((v116 & 0x80) == 0) {
                goto LABEL_221;
              }
              v112 += 7;
              uint64_t v109 = v115;
              uint64_t v21 = v113++ > 8;
            }

            while (!v21);
LABEL_179:
            LODWORD(v114) = 0;
            goto LABEL_221;
          }

          uint64_t v137 = 0;
          __int16 v138 = 0;
          int v114 = 0LL;
          if (v110 <= v109) {
            int v110 = *((void *)this + 1);
          }
          while (2)
          {
            if (v110 == v109)
            {
              LODWORD(v114) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              __int16 v139 = v109 + 1;
              uint64_t v140 = *(_BYTE *)(v111 + v109);
              *((void *)this + 1) = v139;
              v114 |= (unint64_t)(v140 & 0x7F) << v137;
              if (v140 < 0)
              {
                v137 += 7;
                uint64_t v109 = v139;
                uint64_t v21 = v138++ > 8;
                if (v21) {
                  goto LABEL_179;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v114) = 0;
              }
            }

            break;
          }

          *(void *)(a1 + 168) = v99;
          goto LABEL_245;
        case 0xFu:
          *(_WORD *)(a1 + 192) |= 0x80u;
          uint64_t v102 = *((void *)this + 1);
          if (v102 > 0xFFFFFFFFFFFFFFF7LL || v102 + 8 > *((void *)this + 2)) {
            goto LABEL_242;
          }
          *(void *)(a1 + 136) = *(void *)(*(void *)this + v102);
          goto LABEL_244;
        case 0x10u:
          *(_WORD *)(a1 + 192) |= 0x100u;
          int v103 = *((void *)this + 1);
          if (v103 > 0xFFFFFFFFFFFFFFF7LL || v103 + 8 > *((void *)this + 2)) {
            goto LABEL_242;
          }
          *(void *)(a1 + 144) = *(void *)(*(void *)this + v103);
          goto LABEL_244;
        case 0x11u:
          *(_WORD *)(a1 + 192) |= 0x200u;
          int v104 = *((void *)this + 1);
          if (v104 > 0xFFFFFFFFFFFFFFF7LL || v104 + 8 > *((void *)this + 2)) {
            goto LABEL_242;
          }
          *(void *)(a1 + 152) = *(void *)(*(void *)this + v104);
          goto LABEL_244;
        case 0x12u:
          *(_WORD *)(a1 + 192) |= 0x400u;
          uint64_t v105 = *((void *)this + 1);
          if (v105 > 0xFFFFFFFFFFFFFFF7LL || v105 + 8 > *((void *)this + 2)) {
            goto LABEL_242;
          }
          *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(*(void *)this + v105);
          goto LABEL_244;
        default:
          if ((PB::Reader::skip(this, v18 >> 3, v18 & 7, 0) & 1) == 0) {
            return 0LL;
          }
          goto LABEL_245;
      }
    }

    BOOL v22 = 0;
    int v23 = 0;
    unint64_t v18 = 0LL;
    if (v4 > v5) {
      unsigned int v5 = v4;
    }
    while (v5 != v4)
    {
      size_t v24 = v4 + 1;
      char v25 = *(_BYTE *)(v15 + v4);
      *((void *)this + 1) = v24;
      v18 |= (unint64_t)(v25 & 0x7F) << v22;
      if ((v25 & 0x80) == 0) {
        goto LABEL_21;
      }
      v22 += 7;
      unint64_t v4 = v24;
      if (v23++ >= 9)
      {
LABEL_20:
        unint64_t v18 = 0LL;
        goto LABEL_21;
      }
    }

    signed __int8 v6 = 1;
    *((_BYTE *)this + 24) = 1;
  }

  return v6 == 0;
}

            PB::Reader::recallMark(this, v175);
          }

          else
          {
            __int16 v143 = *(char **)(a1 + 16);
            char v142 = *(void *)(a1 + 24);
            if ((unint64_t)v143 >= v142)
            {
              __int16 v162 = (char *)*v10;
              __int128 v163 = (v143 - (_BYTE *)*v10) >> 2;
              uint64_t v164 = v163 + 1;
              if ((unint64_t)(v163 + 1) >> 62) {
LABEL_278:
              }
                sub_100007008();
              __int128 v165 = v142 - (void)v162;
              if (v165 >> 1 > v164) {
                uint64_t v164 = v165 >> 1;
              }
              else {
                __int128 v166 = v164;
              }
              if (v166)
              {
                __int128 v167 = (char *)sub_10000956C(v11, v166);
                __int16 v162 = *(char **)(a1 + 8);
                __int16 v143 = *(char **)(a1 + 16);
              }

              else
              {
                __int128 v167 = 0LL;
              }

              __int128 v170 = &v167[4 * v163];
              *(_DWORD *)__int128 v170 = 0;
              __int16 v141 = v170 + 4;
              while (v143 != v162)
              {
                int v171 = *((_DWORD *)v143 - 1);
                v143 -= 4;
                *((_DWORD *)v170 - 1) = v171;
                v170 -= 4;
              }

              *(void *)(a1 + 8) = v170;
              *(void *)(a1 + 16) = v141;
              *(void *)(a1 + 24) = &v167[4 * v166];
              if (v162) {
                operator delete(v162);
              }
            }

            else
            {
              *(_DWORD *)__int16 v143 = 0;
              __int16 v141 = v143 + 4;
            }

            *(void *)(a1 + 16) = v141;
LABEL_261:
            unsigned int v172 = *((void *)this + 1);
            if (v172 <= 0xFFFFFFFFFFFFFFFBLL && v172 + 4 <= *((void *)this + 2))
            {
              *(v141 - 1) = *(_DWORD *)(*(void *)this + v172);
LABEL_265:
              uint64_t v118 = *((void *)this + 1) + 4LL;
LABEL_266:
              *((void *)this + 1) = v118;
            }

            else
            {
LABEL_263:
              *((_BYTE *)this + 24) = 1;
            }
          }

LABEL_221:
  if (v36 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v109 = 0LL;
    int v110 = -993;
  }

  else
  {
    *(void *)(a2 + 16) += v37;
    uint64_t v109 = *(void *)(a1 + 8);
    int v110 = -995;
  }

  *(_DWORD *)a2 = v110;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v109;
}

          *(_DWORD *)(a1 + 104) = v114;
          goto LABEL_252;
        default:
          if ((PB::Reader::skip(this, v18 >> 3, v18 & 7, 0) & 1) == 0) {
            return 0LL;
          }
          goto LABEL_252;
      }
    }

    BOOL v22 = 0;
    int v23 = 0;
    unint64_t v18 = 0LL;
    if (v4 > v5) {
      unsigned int v5 = v4;
    }
    while (v5 != v4)
    {
      size_t v24 = v4 + 1;
      char v25 = *(_BYTE *)(v15 + v4);
      *((void *)this + 1) = v24;
      v18 |= (unint64_t)(v25 & 0x7F) << v22;
      if ((v25 & 0x80) == 0) {
        goto LABEL_21;
      }
      v22 += 7;
      unint64_t v4 = v24;
      if (v23++ >= 9)
      {
LABEL_20:
        unint64_t v18 = 0LL;
        goto LABEL_21;
      }
    }

    signed __int8 v6 = 1;
    *((_BYTE *)this + 24) = 1;
  }

  return v6 == 0;
}

void sub_100BFD7CC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brack);
}

void sub_100BFD804(_Unwind_Exception *a1)
{
}

char *sub_100BFD818(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  unint64_t v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  memset(&v26, 0, sizeof(v26));
  if (a2 + 1 == a3 || v5 != 91)
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
    goto LABEL_10;
  }

  int v9 = a2[1];
  if (v9 != 46)
  {
    if (v9 == 58)
    {
      uint64_t v10 = sub_100BFDDB8(a1, a2 + 2, a3, (uint64_t)a4);
      goto LABEL_38;
    }

    if (v9 == 61)
    {
      uint64_t v10 = sub_100BFDBDC(a1, a2 + 2, a3, a4);
LABEL_38:
      uint64_t v6 = (uint64_t)v10;
      char v21 = 0;
      goto LABEL_42;
    }

    goto LABEL_9;
  }

  std::string::size_type v19 = sub_100BFDE68(a1, a2 + 2, a3, (uint64_t)&v26);
  unint64_t v4 = v19;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  std::string::size_type size = v26.__r_.__value_.__s.__size_;
  if ((v26.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = v26.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = v19;
  if (!size)
  {
LABEL_10:
    if ((v11 | 0x40) == 0x40)
    {
      int v12 = *v4;
      if (v12 == 92)
      {
        BOOL v13 = v4 + 1;
        if (v11)
        {
          uint64_t v14 = sub_100BFE070(a1, v13, a3, &v26);
        }

        else
        {
          uint64_t v14 = (char *)sub_100BFDF4C(a1, (unsigned __int8 *)v13, a3, &v26, v6);
          int v11 = 0;
        }

        goto LABEL_16;
      }
    }

    else
    {
      LOBYTE(v12) = *v4;
    }

    std::string::operator=(&v26, v12);
    uint64_t v14 = v4 + 1;
  }

void sub_100BFDB64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100BFDBDC(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  uint64_t v6 = a3 - 2;
  signed __int8 v7 = a2;
  uint64_t v8 = a2;
  for (i = a2; ; uint64_t v8 = i)
  {
    int v10 = *i++;
    if (v10 == 61 && *i == 93) {
      break;
    }
    if (a2 == v6) {
      goto LABEL_33;
    }
    ++v7;
    --v6;
  }

  if (v8 == a3) {
LABEL_33:
  }
    sub_100BFD7CC();
  sub_100BFE8C0(a1, a2, v7, &v20);
  if (((char)v20.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    std::string::size_type size = v20.__r_.__value_.__s.__size_;
    if (v20.__r_.__value_.__s.__size_)
    {
      int v12 = &v20;
      goto LABEL_14;
    }

void sub_100BFDD80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100BFDDB8(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  int v5 = a3 - 2;
  uint64_t v6 = a2;
  signed __int8 v7 = a2;
  for (i = a2; ; signed __int8 v7 = i)
  {
    int v9 = *i++;
    if (v9 == 58 && *i == 93) {
      break;
    }
    if (a2 == v5) {
      goto LABEL_11;
    }
    ++v6;
    --v5;
  }

  if (v7 == a3) {
LABEL_11:
  }
    sub_100BFD7CC();
  int v10 = sub_100BFEAA0(a1, a2, v6, *(_DWORD *)(a1 + 24) & 1);
  if (!v10) {
    sub_100BFEA54();
  }
  *(_DWORD *)(a4 + 160) |= v10;
  return v6 + 2;
}

char *sub_100BFDE68(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  int v5 = a3 - 2;
  uint64_t v6 = a2;
  signed __int8 v7 = a2;
  for (i = a2; ; signed __int8 v7 = i)
  {
    int v9 = *i++;
    if (v9 == 46 && *i == 93) {
      break;
    }
    if (a2 == v5) {
      goto LABEL_15;
    }
    ++v6;
    --v5;
  }

  if (v7 == a3) {
LABEL_15:
  }
    sub_100BFD7CC();
  sub_100BFE8C0(a1, a2, v6, &v13);
  *(_OWORD *)a4 = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
  std::string::size_type cap = v13.__r_.__value_.__l.__cap_;
  *(void *)(a4 + 16) = v13.__r_.__value_.__l.__cap_;
  std::string::size_type v11 = HIBYTE(cap);
  if ((v11 & 0x80u) != 0LL) {
    std::string::size_type v11 = *(void *)(a4 + 8);
  }
  if (v11 - 1 >= 2) {
    sub_100BFE834();
  }
  return v6 + 2;
}

unsigned __int8 *sub_100BFDF4C(uint64_t a1, unsigned __int8 *a2, char *a3, std::string *this, uint64_t a5)
{
  int v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          return sub_100BFC448(a1, a2, a3, this);
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        sub_100BFCB4C(a5, 95LL);
        return a2 + 1;
      }

      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }

    else
    {
      if (v6 == 98)
      {
        int v10 = this;
        std::string::value_type v9 = 8;
LABEL_19:
        std::string::operator=(v10, v9);
        return a2 + 1;
      }

      if (v6 != 100) {
        return sub_100BFC448(a1, a2, a3, this);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }

    *(_DWORD *)(a5 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
    return a2 + 1;
  }

  if (v6 <= 82)
  {
    if (*a2)
    {
      if (v6 == 68)
      {
        int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_21:
        *(_DWORD *)(a5 + 164) = v7;
        return a2 + 1;
      }

      return sub_100BFC448(a1, a2, a3, this);
    }

    std::string::value_type v9 = 0;
    int v10 = this;
    goto LABEL_19;
  }

  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_21;
  }

  if (v6 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    sub_100BFEB58(a5, 95LL);
    return a2 + 1;
  }

  return sub_100BFC448(a1, a2, a3, this);
}

char *sub_100BFE070(uint64_t a1, char *a2, char *a3, std::string *this)
{
  if (a2 == a3) {
LABEL_52:
  }
    sub_100BFC27C();
  uint64_t v5 = *a2;
  if ((int)v5 > 97)
  {
    switch((int)v5)
    {
      case 'n':
        if (this)
        {
          int v6 = this;
          LOBYTE(sub_1012279C0(0LL, v4, v5) = 10;
          goto LABEL_16;
        }

        uint64_t v5 = 10LL;
        goto LABEL_49;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_21;
      case 'r':
        if (this)
        {
          int v6 = this;
          LOBYTE(sub_1012279C0(0LL, v4, v5) = 13;
          goto LABEL_16;
        }

        uint64_t v5 = 13LL;
        goto LABEL_49;
      case 't':
        if (this)
        {
          int v6 = this;
          LOBYTE(sub_1012279C0(0LL, v4, v5) = 9;
          goto LABEL_16;
        }

        uint64_t v5 = 9LL;
        goto LABEL_49;
      case 'v':
        if (this)
        {
          int v6 = this;
          LOBYTE(sub_1012279C0(0LL, v4, v5) = 11;
          goto LABEL_16;
        }

        uint64_t v5 = 11LL;
        goto LABEL_49;
      default:
        if ((_DWORD)v5 == 98)
        {
          if (this)
          {
            int v6 = this;
            LOBYTE(sub_1012279C0(0LL, v4, v5) = 8;
            goto LABEL_16;
          }

          uint64_t v5 = 8LL;
        }

        else
        {
          if ((_DWORD)v5 != 102) {
            goto LABEL_21;
          }
          if (this)
          {
            int v6 = this;
            LOBYTE(sub_1012279C0(0LL, v4, v5) = 12;
            goto LABEL_16;
          }

          uint64_t v5 = 12LL;
        }

        break;
    }

    goto LABEL_49;
  }

  if ((int)v5 > 91)
  {
    if ((_DWORD)v5 != 92)
    {
      if ((_DWORD)v5 != 97) {
        goto LABEL_21;
      }
      if (this)
      {
        int v6 = this;
        LOBYTE(sub_1012279C0(0LL, v4, v5) = 7;
LABEL_16:
        std::string::operator=(v6, v5);
        return a2 + 1;
      }

      uint64_t v5 = 7LL;
LABEL_49:
      sub_10111FBF0(a1, v5);
      return a2 + 1;
    }

void sub_100BFE248(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a3;
  unint64_t v4 = a2;
  if (*(_BYTE *)(a1 + 170))
  {
    if (*(_BYTE *)(a1 + 169))
    {
      for (unint64_t i = 0LL; ; ++i)
      {
        unint64_t v7 = v4[23] < 0 ? *((void *)v4 + 1) : v4[23];
        if (i >= v7) {
          break;
        }
        int v8 = v4;
        if (v4[23] < 0) {
          int v8 = *(char **)v4;
        }
        char v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v8[i]);
        int v10 = v4;
        if (v4[23] < 0) {
          int v10 = *(char **)v4;
        }
        v10[i] = v9;
      }

      for (unint64_t j = 0LL; ; ++j)
      {
        unint64_t v12 = v3[23] < 0 ? *((void *)v3 + 1) : v3[23];
        if (j >= v12) {
          break;
        }
        std::string v13 = v3;
        if (v3[23] < 0) {
          std::string v13 = *(char **)v3;
        }
        char v14 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v13[j]);
        int v15 = v3;
        if (v3[23] < 0) {
          int v15 = *(char **)v3;
        }
        v15[j] = v14;
      }
    }

    else
    {
      for (unint64_t k = 0LL; ; ++k)
      {
        unint64_t v18 = a2[23] < 0 ? *((void *)a2 + 1) : a2[23];
        if (k >= v18) {
          break;
        }
        unsigned __int8 v19 = a2;
        if (a2[23] < 0) {
          unsigned __int8 v19 = *(char **)a2;
        }
        std::string v20 = a2;
        if (a2[23] < 0) {
          std::string v20 = *(char **)a2;
        }
        v20[k] = v19[k];
      }

      for (unint64_t m = 0LL; ; ++m)
      {
        unint64_t v22 = a3[23] < 0 ? *((void *)a3 + 1) : a3[23];
        if (m >= v22) {
          break;
        }
        int v23 = a3;
        if (a3[23] < 0) {
          int v23 = *(char **)a3;
        }
        std::string v24 = a3;
        if (a3[23] < 0) {
          std::string v24 = *(char **)a3;
        }
        v24[m] = v23[m];
      }
    }

    if (v4[23] < 0)
    {
      std::string v26 = v4;
      unint64_t v4 = *(char **)v4;
      uint64_t v25 = *((void *)v26 + 1);
    }

    else
    {
      uint64_t v25 = v4[23];
    }

    sub_101121604(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      uint64_t v28 = v3;
      uint64_t v3 = *(char **)v3;
      uint64_t v27 = *((void *)v28 + 1);
    }

    else
    {
      uint64_t v27 = v3[23];
    }

    sub_101121604(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)uint64_t v40 = v38;
    uint64_t v41 = v39;
    *(_OWORD *)std::string __p = *(_OWORD *)v36;
    uint64_t v43 = v37;
    sub_100BFED84((uint64_t *)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }

  else
  {
    if (a2[23] < 0) {
      uint64_t v16 = *((void *)a2 + 1);
    }
    else {
      uint64_t v16 = a2[23];
    }
    if (*(_BYTE *)(a1 + 169))
    {
      size_t v30 = a2;
      if (a2[23] < 0) {
        size_t v30 = *(char **)a2;
      }
      char v31 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  *v30);
      size_t v32 = v4;
      if (v4[23] < 0) {
        size_t v32 = *(_BYTE **)v4;
      }
      *size_t v32 = v31;
      int v33 = v3;
      if (v3[23] < 0) {
        int v33 = *(char **)v3;
      }
      char v34 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  *v33);
      int v35 = v3;
      if (v3[23] < 0) {
        int v35 = *(_BYTE **)v3;
      }
      *int v35 = v34;
    }

    *(_OWORD *)uint64_t v40 = *(_OWORD *)v4;
    uint64_t v41 = *((void *)v4 + 2);
    *((void *)v4 + 1) = 0LL;
    *((void *)v4 + 2) = 0LL;
    *(void *)unint64_t v4 = 0LL;
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v43 = *((void *)v3 + 2);
    *(void *)uint64_t v3 = 0LL;
    *((void *)v3 + 1) = 0LL;
    *((void *)v3 + 2) = 0LL;
    sub_100BFED84((uint64_t *)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }

void sub_100BFE5C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
}

void sub_100BFE60C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a1 + 169))
  {
    uint64_t v18 = a1 + 128;
    unint64_t v19 = *(void *)(a1 + 128);
    int v10 = (char **)(a1 + 112);
    __int16 v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v9 = *(_WORD **)(a1 + 120);
    if (*(_BYTE *)(a1 + 170))
    {
      uint64_t v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        uint64_t v21 = v20 >> 1;
        unint64_t v22 = v19 - (void)*v10;
        if (v22 <= (v20 >> 1) + 1) {
          unint64_t v23 = v21 + 1;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v22 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)sub_1008DB604(v18, v24);
        }
        else {
          uint64_t v25 = 0LL;
        }
        uint64_t v27 = &v25[2 * v21];
        uint64_t v28 = &v25[2 * v24];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        __int128 v38 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v38) {
          goto LABEL_46;
        }
        do
        {
          __int16 v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }

        while (v29 != v38);
        goto LABEL_45;
      }
    }

    else
    {
      uint64_t v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        uint64_t v33 = v32 >> 1;
        unint64_t v34 = v19 - (void)*v10;
        if (v34 <= (v32 >> 1) + 1) {
          unint64_t v35 = v33 + 1;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v36 = v35;
        }
        if (v36) {
          uint64_t v37 = (char *)sub_1008DB604(v18, v36);
        }
        else {
          uint64_t v37 = 0LL;
        }
        uint64_t v27 = &v37[2 * v33];
        uint64_t v28 = &v37[2 * v36];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        uint64_t v40 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v40) {
          goto LABEL_46;
        }
        do
        {
          __int16 v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }

        while (v29 != v40);
        goto LABEL_45;
      }
    }

void sub_100BFE834()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_collate);
}

void sub_100BFE86C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFE880(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = a1 + 17;
  unint64_t v4 = a1[18];
  if (v4 >= a1[19])
  {
    uint64_t result = sub_10112142C(v3, a2);
  }

  else
  {
    sub_1011213D0(v3, a2);
    uint64_t result = v4 + 24;
  }

  a1[18] = result;
  return result;
}

void sub_100BFE8C0(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, std::string *a4@<X8>)
{
  a4->__r_.__value_.__r.__words[0] = 0LL;
  a4->__r_.__value_.__l.__size_ = 0LL;
  a4->__r_.__value_.__l.__cap_ = 0LL;
  if ((char)__s.__r_.__value_.__s.__size_ < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!__s.__r_.__value_.__s.__size_) {
      return;
    }
    p_s = &__s;
  }

  std::__get_collation_name(&v13, (const char *)p_s);
  *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
  std::string::size_type cap = v13.__r_.__value_.__l.__cap_;
  a4->__r_.__value_.__l.__cap_ = v13.__r_.__value_.__l.__cap_;
  std::string::size_type size = HIBYTE(cap);
  if ((size & 0x80u) != 0LL) {
    std::string::size_type size = a4->__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if ((char)__s.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type v9 = __s.__r_.__value_.__l.__size_;
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
    int v10 = (std::string *)__s.__r_.__value_.__r.__words[0];
  }

  else
  {
    std::string::size_type v9 = __s.__r_.__value_.__s.__size_;
    if (__s.__r_.__value_.__s.__size_ >= 3u) {
      return;
    }
    int v10 = &__s;
  }

  (*(void (**)(std::string *__return_ptr, void, std::string *, char *))(**(void **)(a1 + 16) + 32LL))( &v13,  *(void *)(a1 + 16),  v10,  (char *)v10 + v9);
  *a4 = v13;
  if (((char)a4->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    int v11 = a4->__r_.__value_.__s.__size_;
    if (v11 != 12 && v11 != 1)
    {
      a4->__r_.__value_.__s.__data_[0] = 0;
      a4->__r_.__value_.__s.__size_ = 0;
      goto LABEL_9;
    }

    goto LABEL_25;
  }

  std::string::size_type v12 = a4->__r_.__value_.__l.__size_;
  if (v12 == 1 || v12 == 12)
  {
LABEL_25:
    std::string::operator=(a4, &__s);
    goto LABEL_9;
  }

  *a4->__r_.__value_.__l.__data_ = 0;
  a4->__r_.__value_.__l.__size_ = 0LL;
LABEL_9:
}

void sub_100BFEA20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BFEA54()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_ctype);
}

void sub_100BFEA8C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFEAA0(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 8) + 48LL))( *(void *)(a1 + 8),  v7,  (char *)v7 + v6);
  if ((v12 & 0x80u) == 0) {
    __int16 v8 = __p;
  }
  else {
    __int16 v8 = (void **)__p[0];
  }
  uint64_t classname = std::__get_classname((const char *)v8, a4);
  return classname;
}

void sub_100BFEB3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BFEB58(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a2);
    unsigned __int8 v5 = *(_BYTE **)(a1 + 72);
    unint64_t v4 = *(void *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      unint64_t v6 = (unint64_t *)(a1 + 64);
      unint64_t v7 = *(void *)(a1 + 64);
      __int16 v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          unsigned __int8 v12 = operator new(v11);
        }
        else {
          unsigned __int8 v12 = 0LL;
        }
        uint64_t v20 = &v8[(void)v12];
        uint64_t v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          unint64_t v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }

          while (v5 != (_BYTE *)v7);
LABEL_45:
          unsigned __int8 v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }

        goto LABEL_46;
      }

void **sub_100BFED84(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555LL) {
      sub_100007008();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555LL;
    }
    else {
      unint64_t v14 = v12;
    }
    _OWORD v19[4] = result;
    if (v14) {
      unint64_t v15 = (char *)sub_1000BB1F4((uint64_t)result, v14);
    }
    else {
      unint64_t v15 = 0LL;
    }
    unint64_t v16 = &v15[48 * v11];
    v19[0] = v15;
    v19[1] = v16;
    std::locale v19[3] = &v15[48 * v14];
    __int128 v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v16 = v17;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v18 = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    void v19[2] = v16 + 48;
    sub_1001594D4(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_100159680(v19);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v10;
  return result;
}

void sub_100BFEED8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100BFEEEC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_range);
}

void sub_100BFEF24(_Unwind_Exception *a1)
{
}

uint64_t sub_100BFEF38(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + 8);
  return result;
}

uint64_t sub_100BFEF68(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(_BYTE *)(v2 + 16) = 1;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + 8);
  return result;
}

unsigned __int8 *sub_100BFEFA0(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      int v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }

      else
      {
        while (1)
        {
          int v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38) {
            break;
          }
          if (v5 >= 214748364) {
            sub_100BFF03C();
          }
          int v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3) {
            return a3;
          }
        }
      }
    }
  }

  return a2;
}

void sub_100BFF03C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badbrace);
}

void sub_100BFF074(_Unwind_Exception *a1)
{
}

void sub_100BFF088()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brace);
}

void sub_100BFF0C0(_Unwind_Exception *a1)
{
}

unsigned int *sub_100BFF0D4(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    unint64_t *v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }

    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return sub_100BFF288(result, a2);
    }

    goto LABEL_23;
  }

  unint64_t *v4 = 0LL;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }

unsigned int *sub_100BFF188(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }

  else
  {
    a3[10] = *((void *)result + 1);
    return sub_100BFF288(result, a3);
  }

  return result;
}

void *sub_100BFF1B8(void *a1)
{
  *a1 = &off_101878040;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *a1 = &off_101877BC0;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_100BFF220(void *__p)
{
  *std::string __p = &off_101878040;
  uint64_t v2 = __p[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *std::string __p = &off_101877BC0;
  uint64_t v3 = __p[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  operator delete(__p);
}

unsigned int *sub_100BFF288(unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16LL * result[10] + 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    uint64_t v7 = a2[4] + 24LL * v4 + 8;
    do
    {
      *(void *)(v7 - 8) = v5;
      *(void *)uint64_t v7 = v5;
      *(_BYTE *)(v7 + 8) = 0;
      v7 += 24LL;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t sub_100BFF2DC(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + 8);
  return result;
}

void sub_100BFF2F0(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t sub_100BFF2FC(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8LL;
  if (a2) {
    uint64_t v3 = 16LL;
  }
  *(void *)(a3 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + v3);
  return result;
}

uint64_t sub_100BFF320(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(void *)(result + 8);
  return result;
}

uint64_t sub_100BFF334(uint64_t a1, uint64_t a2, uint64_t a3)
{
  do
  {
    uint64_t v5 = a2;
    a2 = sub_100BFF3C8(a1, a2, a3);
  }

  while (v5 != a2);
  return v5;
}

void sub_100BFF37C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_empty);
}

void sub_100BFF3B4(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100BFF3C8(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_DWORD *)(a1 + 28);
  BOOL v8 = (unsigned __int8 *)sub_100BFF450(a1, a2, a3);
  else {
    return sub_100BFF560(a1, v8, (unsigned __int8 *)a3, v6, v7 + 1, *(_DWORD *)(a1 + 28) + 1);
  }
}

char *sub_100BFF450(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v6 = sub_100BFF700(a1, (char *)a2, a3);
  int v7 = v6;
  if ((char *)a2 == v6 && (char *)a2 != a3 && (char *)(a2 + 1) != a3)
  {
    uint64_t v9 = (uint64_t)v6;
    if (*(_BYTE *)a2 == 92) {
      uint64_t v9 = a2 + 2LL * (*(_BYTE *)(a2 + 1) == 40);
    }
    if (v9 == a2)
    {
      if (*(_BYTE *)a2 == 92)
      {
        int v12 = sub_101121F58(a1, *(_BYTE *)(a2 + 1));
        uint64_t v13 = 2LL;
        if (!v12) {
          uint64_t v13 = 0LL;
        }
        return (char *)(a2 + v13);
      }
    }

    else
    {
      sub_10111F720((void *)a1);
      int v10 = *(_DWORD *)(a1 + 28);
      unint64_t v11 = (char *)sub_100BFF334(a1, v9, (uint64_t)a3);
      if (v11 == a3 || v11 + 1 == a3 || *v11 != 92 || v11[1] != 41) {
        sub_100BFB3E0();
      }
      int v7 = v11 + 2;
      sub_10111F784((void *)a1, v10);
    }
  }

  return v7;
}

unsigned __int8 *sub_100BFF560( uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6 = a2;
  if (a2 != a3)
  {
    int v11 = *a2;
    if (v11 == 42)
    {
      sub_1011217B0(a1, 0LL, -1LL, a4, a5, a6, 1);
      return ++v6;
    }

    if (a2 + 1 != a3 && v11 == 92 && a2[1] == 123)
    {
      uint64_t v13 = a2 + 2;
      int v25 = 0;
      unint64_t v14 = sub_100BFEFA0(a1, a2 + 2, a3, &v25);
      if (v13 == v14) {
        goto LABEL_16;
      }
      if (v14 != a3)
      {
        unint64_t v15 = v14 + 1;
        int v16 = *v14;
        if (v16 == 44)
        {
          int v24 = -1;
          __int128 v17 = sub_100BFEFA0(a1, v15, a3, &v24);
          if (v17 != a3 && v17 + 1 != a3 && *v17 == 92 && v17[1] == 125)
          {
            uint64_t v19 = v24;
            uint64_t v18 = v25;
            if (v24 == -1)
            {
              uint64_t v19 = -1LL;
            }

            else if (v24 < v25)
            {
LABEL_16:
              sub_100BFF03C();
            }

            uint64_t v6 = &v17[2 * (v17[1] == 125)];
            int v20 = a5;
            int v21 = a6;
            uint64_t v22 = a1;
LABEL_23:
            sub_1011217B0(v22, v18, v19, a4, v20, v21, 1);
            return v6;
          }
        }

        else if (v15 != a3 && v16 == 92 && *v15 == 125)
        {
          uint64_t v6 = v14 + 2;
          uint64_t v18 = v25;
          int v20 = a5;
          int v21 = a6;
          uint64_t v22 = a1;
          uint64_t v19 = v25;
          goto LABEL_23;
        }
      }

      sub_100BFF088();
    }
  }

  return v6;
}

char *sub_100BFF700(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = sub_100BFF808(a1, a2, a3);
    if (result != a2) {
      return result;
    }
    return sub_100BFC0B0(a1, a2, a3);
  }

  int v6 = *a2;
  if ((a2 + 1 != a3 || v6 != 36)
    && ((v6 - 46) > 0x2E || ((1LL << (v6 - 46)) & 0x600000000001LL) == 0))
  {
    sub_10111FBF0(a1, (char)v6);
    return a2 + 1;
  }

  uint64_t result = sub_100BFF808(a1, a2, a3);
  if (result != a2) {
    return result;
  }
  if (*a2 != 46) {
    return sub_100BFC0B0(a1, a2, a3);
  }
  uint64_t v9 = operator new(0x10uLL);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(v10 + 8);
  *uint64_t v9 = &off_101878148;
  v9[1] = v11;
  *(void *)(v10 + 8) = v9;
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return a2 + 1;
}

_BYTE *sub_100BFF808(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3 && a2 + 1 != a3 && *a2 == 92)
  {
    int v4 = (char)a2[1];
    if ((v4 - 36) <= 0x3A && ((1LL << (a2[1] - 36)) & 0x580000000000441LL) != 0)
    {
      sub_10111FBF0(a1, (char)v4);
      v3 += 2;
    }
  }

  return v3;
}

uint64_t sub_100BFF880(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_BYTE **)(a2 + 16);
  if (v2 == *(_BYTE **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v3;
  return result;
}

unsigned __int8 *sub_100BFF8C0(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_100BFF91C(a1, a2, a3);
  do
  {
    int v7 = v6;
    int v6 = sub_100BFF91C(a1, (char *)v6, a3);
  }

  while (v7 != v6);
  return v7;
}

unsigned __int8 *sub_100BFF91C(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_DWORD *)(a1 + 28);
  BOOL v8 = sub_100BFFAAC(a1, a2, a3);
  uint64_t v9 = (unsigned __int8 *)v8;
  if (v8 != a2 || v8 == a3) {
    goto LABEL_12;
  }
  int v10 = *a2;
  switch(v10)
  {
    case '$':
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
      goto LABEL_8;
    case '(':
      sub_10111F720((void *)a1);
      int v16 = *(_DWORD *)(a1 + 28);
      ++*(_DWORD *)(a1 + 36);
      __int128 v17 = (char *)sub_100BFA7C8(a1, a2 + 1, a3);
      if (v17 == a3 || (uint64_t v18 = v17, *v17 != 41)) {
        sub_100BFB3E0();
      }
      sub_10111F784((void *)a1, v16);
      --*(_DWORD *)(a1 + 36);
      uint64_t v9 = (unsigned __int8 *)(v18 + 1);
LABEL_12:
      return (unsigned __int8 *)a2;
    case '^':
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
LABEL_8:
      uint64_t v15 = *(void *)(v13 + 8);
      *uint64_t v11 = v14 + 2;
      v11[1] = v15;
      *((_BYTE *)v11 + 16) = v12;
      *(void *)(v13 + 8) = v11;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
      uint64_t v9 = (unsigned __int8 *)(a2 + 1);
      return sub_100BFB0D8(a1, v9, (unsigned __int8 *)a3, v6, v7 + 1, *(_DWORD *)(a1 + 28) + 1);
  }

  return (unsigned __int8 *)a2;
}

char *sub_100BFFAAC(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = sub_100BFFB64(a1, a2, a3);
  if (result == a2)
  {
    uint64_t result = sub_100BFFBEC(a1, a2, a3);
    if (result == a2)
    {
      if (a2 == a3 || *a2 != 46)
      {
        return sub_100BFC0B0(a1, a2, a3);
      }

      else
      {
        int v7 = operator new(0x10uLL);
        uint64_t v8 = *(void *)(a1 + 56);
        uint64_t v9 = *(void *)(v8 + 8);
        void *v7 = &off_101878148;
        v7[1] = v9;
        *(void *)(v8 + 8) = v7;
        *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
        return a2 + 1;
      }
    }
  }

  return result;
}

char *sub_100BFFB64(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = *a2;
    uint64_t v5 = (v4 - 36);
    if (v5 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        return v3;
      }
    }

    else
    {
LABEL_8:
    }

    sub_10111FBF0(a1, *a2);
    ++v3;
  }

  return v3;
}

char *sub_100BFFBEC(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = a2 + 1;
    if (v3 + 1 != a3 && *v3 == 92)
    {
      int v5 = *v4;
      signed __int8 v6 = *v4;
      BOOL v7 = (v5 - 36) > 0x3A || ((1LL << (*v4 - 36)) & 0x5800000080004F1LL) == 0;
      if (v7 && (v5 - 123) >= 3)
      {
        if ((*(_DWORD *)(a1 + 24) & 0x1F0) == 0x40)
        {
          return sub_100BFE070(a1, v4, a3, 0LL);
        }

        else
        {
          int v9 = sub_101121F58(a1, v6);
          uint64_t v10 = 2LL;
          if (!v9) {
            uint64_t v10 = 0LL;
          }
          v3 += v10;
        }
      }

      else
      {
        sub_10111FBF0(a1, v6);
        v3 += 2;
      }
    }
  }

  return v3;
}

uint64_t sub_100BFFCB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  char v15 = 0;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  char v18 = 0;
  char v19 = 0;
  uint64_t v20 = 0LL;
  *(_OWORD *)std::string __p = 0u;
  memset(v12, 0, sizeof(v12));
  int v9 = sub_101123F54(a4, a1, a2, (uint64_t)__p, a5 | 0x1040u);
  sub_10112412C(a3, a1, a2, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (!v9) {
    return 0LL;
  }
  if (!*(_BYTE *)(a3 + 88)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_100BFFD88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100BFFDA4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 42 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100C00014(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2A)) + 96 * (v7 % 0x2A);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(v8 + memset(v19, 0, 48) = 0LL;
  *(void *)(v8 + 32) = 0LL;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + memset(v19, 0, 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a2 + memset(v19, 0, 48) = 0LL;
  *(void *)(v8 + 56) = 0LL;
  *(void *)(v8 + 64) = 0LL;
  *(void *)(v8 + 72) = 0LL;
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v8 + 56) = result;
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(v8 + 85) = *(void *)(a2 + 85);
  *(void *)(v8 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v11;
  ++a1[5];
  return result;
}

uint64_t sub_100BFFEA4(void *a1)
{
  unsigned int v2 = a1 + 5;
  unint64_t v3 = a1[5] + a1[4] - 1LL;
  sub_100BFBC54((uint64_t)(a1 + 5), (void *)(*(void *)(a1[1] + 8 * (v3 / 0x2A)) + 96 * (v3 % 0x2A)));
  --*v2;
  return sub_100C00328(a1, 1);
}

int64x2_t sub_100BFFF24(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100C0039C((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x2A));
  uint64_t v7 = *v6 + 96 * (v4 % 0x2A);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4032LL;
  }
  __int128 v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v7 - 96) = *(_OWORD *)a2;
  *(_OWORD *)(v7 - 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
  *(void *)(v7 - 56) = 0LL;
  *(void *)(v7 - memset(v19, 0, 48) = 0LL;
  *(void *)(v7 - 64) = 0LL;
  *(_OWORD *)(v7 - 64) = *(_OWORD *)(a2 + 32);
  *(void *)(v7 - memset(v19, 0, 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a2 + memset(v19, 0, 48) = 0LL;
  *(void *)(v7 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(v7 - 32) = 0LL;
  *(void *)(v7 - 24) = 0LL;
  *(_OWORD *)(v7 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_OWORD *)(a2 + 56);
  *(void *)(v7 - 24) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v7 - 11) = *(void *)(a2 + 85);
  *(void *)(v7 - 16) = v9;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1012E2F20);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void sub_100C00014(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int128 v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      __int128 v38 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int128 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int16 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int16 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100C002DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100C00328(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 42 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2A) {
    a2 = 1;
  }
  if (v5 < 0x54) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void sub_100C0039C(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 42 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x2A)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    __int128 v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::string __p = sub_1000071BC(v7, v11);
      uint64_t v43 = (char *)__p;
      int v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      __int16 v41 = operator new(0xFC0uLL);
      sub_1000ECB90(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                uint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)uint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              __int128 v31 = __p;
              std::string __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              int v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }

              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              uint64_t v43 = v22;
              int v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      uint64_t v43 = v33;
      __int128 v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      int v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 21LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        int v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0xFC0uLL);
        sub_1000EC960(a1, &__p);
        unint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        std::string __p = operator new(0xFC0uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 21LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 42;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_100C00668( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100C006B4(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = (void **)a1[2];
  if (v4 == v3)
  {
    unint64_t v4 = (void **)a1[1];
  }

  else
  {
    unint64_t v5 = a1[4];
    uint64_t v6 = &v3[v5 / 0x2A];
    uint64_t v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    unint64_t v8 = (unint64_t)v3[(a1[5] + v5) / 0x2A] + 96 * ((a1[5] + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_100BFBC54((uint64_t)v2, v7);
        v7 += 96;
        if (v7 - (_BYTE *)*v6 == 4032)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }

      while (v7 != (char *)v8);
      uint64_t v3 = (void **)a1[1];
      unint64_t v4 = (void **)a1[2];
    }
  }

  *uint64_t v2 = 0LL;
  unint64_t v10 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      unint64_t v4 = (void **)a1[2];
      uint64_t v3 = (void **)(a1[1] + 8LL);
      a1[1] = v3;
      unint64_t v10 = (char *)v4 - (char *)v3;
    }

    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 21LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 42LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v3 != v4)
  {
    uint64_t v13 = *v3++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_100C007F8(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_100C00834((void **)a1, v4);
  }

  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 24 * a2;
  }

void sub_100C00834(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (_BYTE *)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[3 * a2];
      uint64_t v14 = 24 * a2;
      do
      {
        void *v7 = 0LL;
        v7[1] = 0LL;
        *((_BYTE *)v7 + 16) = 0;
        v7 += 3;
        v14 -= 24LL;
      }

      while (v14);
      uint64_t v7 = v13;
    }

    a1[1] = v7;
  }

  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (_BYTE *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      uint64_t v12 = (char *)sub_10000701C(v4, v11);
    }
    else {
      uint64_t v12 = 0LL;
    }
    int64_t v15 = &v12[24 * v8];
    uint64_t v16 = &v15[24 * a2];
    uint64_t v17 = 24 * a2;
    uint64_t v18 = v15;
    do
    {
      *(void *)uint64_t v18 = 0LL;
      *((void *)v18 + 1) = 0LL;
      v18[16] = 0;
      v18 += 24;
      v17 -= 24LL;
    }

    while (v17);
    uint64_t v19 = &v12[24 * v11];
    int64_t v21 = (char *)*a1;
    int64_t v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        __int128 v22 = *(_OWORD *)(v20 - 24);
        *((void *)v15 - 1) = *((void *)v20 - 1);
        *(_OWORD *)(v15 - 24) = v22;
        v15 -= 24;
        v20 -= 24;
      }

      while (v20 != v21);
      int64_t v20 = (char *)*a1;
    }

    *a1 = v15;
    a1[1] = v16;
    a1[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }

void *sub_100C0099C(void *a1)
{
  unint64_t v2 = sub_100AE3320((uint64_t)a1);
  *unint64_t v2 = off_1018782E8;
  v2[4] = 0LL;
  *((_DWORD *)v2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(void *)((char *)v2 + 44) = -1LL;
  *((_DWORD *)v2 + 13) = -1;
  *((_BYTE *)v2 + 56) = 0;
  *(void *)((char *)v2 + 6sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = -1LL;
  a1[12] = 0LL;
  a1[13] = 0LL;
  a1[11] = 0LL;
  bzero(v2 + 9, 0x10uLL);
  return a1;
}

void *sub_100C00A00(_DWORD *a1)
{
  *(void *)a1 = off_1018782E8;
  sub_100C00A40(a1);
  bzero(a1 + 18, 0x10uLL);
  return sub_1008FA954(a1);
}

uint64_t sub_100C00A40(_DWORD *a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  int v3 = a1[11];
  if (v3 != -1)
  {
    notify_cancel(v3);
    a1[11] = -1;
  }

  int v4 = a1[13];
  if (v4 != -1)
  {
    notify_cancel(v4);
    a1[13] = -1;
  }

  uint64_t result = a1[15];
  if ((_DWORD)result != -1)
  {
    uint64_t result = notify_cancel(result);
    a1[15] = -1;
  }

  return result;
}

void sub_100C00AB4(_DWORD *a1)
{
  uint64_t v1 = sub_100C00A00(a1);
  operator delete(v1);
}

uint64_t sub_100C00AC8(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2 <= 1)
  {
    int v3 = (_BYTE *)result;
    *(void *)(result + 72 + 8LL * a2) = a3;
    if (*(void *)(result + 72) || *(void *)(result + 80))
    {
      sub_100C00B3C((int *)result);
      sub_100C01040((uint64_t)v3);
      sub_100C01378((uint64_t)v3);
      return sub_100C016A8(v3);
    }

    else
    {
      return sub_100C00A40((_DWORD *)result);
    }
  }

  return result;
}

void sub_100C00B3C(int *a1)
{
  if (a1[11] < 0)
  {
    if (notify_register_check("com.apple.isp.focusing", a1 + 11))
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      unint64_t v2 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v17 = "com.apple.isp.focusing";
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Could not register for notification %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101878348);
        }
        int v14 = 136315138;
        int64_t v15 = "com.apple.isp.focusing";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not register for notification %s",  (const char *)&v14);
        unint64_t v9 = (uint8_t *)v8;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()",  "%s\n",  v8);
        if (v9 != buf) {
          free(v9);
        }
      }
    }

    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_100C01E50,  @"com.apple.isp.focusing",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

  if (a1[13] < 0)
  {
    if (notify_register_check("com.apple.isp.backcamerapower", a1 + 13))
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v4 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v17 = "com.apple.isp.backcamerapower";
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Could not register for notification %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101878348);
        }
        int v14 = 136315138;
        int64_t v15 = "com.apple.isp.backcamerapower";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not register for notification %s",  (const char *)&v14);
        unint64_t v11 = (uint8_t *)v10;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }
    }

    unint64_t v5 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( v5,  a1,  (CFNotificationCallback)sub_100C01E50,  @"com.apple.isp.backcamerapower",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

  if (a1[15] < 0)
  {
    if (notify_register_check("com.apple.isp.backcamerasensorconfig", a1 + 15))
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      uint64_t v6 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v17 = "com.apple.isp.backcamerasensorconfig";
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Could not register for notification %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101878348);
        }
        int v14 = 136315138;
        int64_t v15 = "com.apple.isp.backcamerasensorconfig";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not register for notification %s",  (const char *)&v14);
        uint64_t v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
      }
    }

    uint64_t v7 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( v7,  a1,  (CFNotificationCallback)sub_100C01E50,  @"com.apple.isp.backcamerasensorconfig",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

void sub_100C01040(uint64_t a1)
{
  if (notify_get_state(*(_DWORD *)(a1 + 52), &state64))
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    unint64_t v2 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      int v14 = "com.apple.isp.backcamerapower";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v11 = 136315138;
      uint64_t v12 = "com.apple.isp.backcamerapower";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not get state for %s",  (const char *)&v11);
      int v4 = (uint8_t *)v3;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()",  "%s\n",  v3);
      if (v4 != buf) {
        free(v4);
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 56) = state64 != 0;
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    unint64_t v5 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      int v6 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)uint64_t buf = 67109120;
      LODWORD(v14) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "camera os_activity_scope_state_s state = %d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v7 = *(unsigned __int8 *)(a1 + 56);
      int v11 = 67109120;
      LODWORD(v12) = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "camera os_activity_scope_state_s state = %d",  &v11);
      unint64_t v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    (*(void (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
  }

void sub_100C01378(uint64_t a1)
{
  if (notify_get_state(*(_DWORD *)(a1 + 44), &state64))
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    unint64_t v2 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v17 = "com.apple.isp.focusing";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v14 = 136315138;
      int64_t v15 = "com.apple.isp.focusing";
      double v3 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not get state for %s",  (const char *)&v14);
      unint64_t v5 = v4;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()",  "%s\n",  v3);
LABEL_19:
      if (v5 != buf) {
        free(v5);
      }
    }
  }

  else
  {
    int v6 = state64;
    *(_DWORD *)(a1 + memset(v19, 0, 48) = state64;
    BOOL v12 = v6 == 0xFFFF;
    sub_1006DD65C(a1, 1LL, (uint64_t)&v12, 1LL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    int v7 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      int v8 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)uint64_t buf = 67109120;
      LODWORD(v17) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "focus position = %d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v9 = *(_DWORD *)(a1 + 48);
      int v14 = 67109120;
      LODWORD(v15) = v9;
      double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "focus position = %d",  &v14);
      unint64_t v5 = v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()",  "%s\n",  v10);
      goto LABEL_19;
    }
  }

uint64_t sub_100C016A8(_BYTE *a1)
{
  int v2 = *((_DWORD *)a1 + 12);
  if (v2 != 0xFFFF)
  {
    if (a1[56])
    {
      *((float32x2_t *)a1 + 4) = vmla_n_f32(*(float32x2_t *)(a1 + 100), *(float32x2_t *)(a1 + 88), (float)v2);
      *((float *)a1 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *((float *)a1 + 27) + (float)(*((float *)a1 + 24) * (float)v2);
    }

    else
    {
      bzero(a1 + 32, 0xCuLL);
    }
  }

  (*(void (**)(_BYTE *))(*(void *)a1 + 64LL))(a1);
  return sub_1006DD65C((uint64_t)a1, 0LL, (uint64_t)(a1 + 32), 12LL);
}

void sub_100C01740(float32x2_t *a1, __int16 *a2)
{
  a1[11].f32[0] = (float)*a2 * 0.01;
  a1[11].f32[1] = (float)a2[1] * 0.01;
  a1[12].f32[0] = (float)a2[2] * 0.01;
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101878348);
  }
  int v4 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    double v5 = a1[11].f32[0];
    double v6 = a1[11].f32[1];
    double v7 = a1[12].f32[0];
    *(_DWORD *)uint64_t buf = 134218496;
    double v30 = v5;
    __int16 v31 = 2048;
    double v32 = v6;
    __int16 v33 = 2048;
    double v34 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    double v12 = a1[11].f32[0];
    double v13 = a1[11].f32[1];
    double v14 = a1[12].f32[0];
    int v23 = 134218496;
    double v24 = v12;
    __int16 v25 = 2048;
    double v26 = v13;
    __int16 v27 = 2048;
    double v28 = v14;
    LODWORD(v22) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f",  COERCE_DOUBLE(&v23),  v22);
    uint64_t v16 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)",  "%s\n",  v15);
    if (v16 != buf) {
      free(v16);
    }
  }

  a1[11] = vdiv_f32(a1[11], (float32x2_t)vdup_n_s32(0x437F0000u));
  a1[12].f32[0] = a1[12].f32[0] / 255.0;
  a1[12].f32[1] = (float)a2[3] * 0.01;
  a1[13].f32[0] = (float)a2[4] * 0.01;
  a1[13].f32[1] = (float)a2[5] * 0.01;
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101878348);
  }
  int v8 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    double v9 = a1[12].f32[1];
    double v10 = a1[13].f32[0];
    double v11 = a1[13].f32[1];
    *(_DWORD *)uint64_t buf = 134218496;
    double v30 = v9;
    __int16 v31 = 2048;
    double v32 = v10;
    __int16 v33 = 2048;
    double v34 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    double v17 = a1[12].f32[1];
    double v18 = a1[13].f32[0];
    double v19 = a1[13].f32[1];
    int v23 = 134218496;
    double v24 = v17;
    __int16 v25 = 2048;
    double v26 = v18;
    __int16 v27 = 2048;
    double v28 = v19;
    LODWORD(v22) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f",  COERCE_DOUBLE(&v23),  v22);
    int64_t v21 = (uint8_t *)v20;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)",  "%s\n",  v20);
    if (v21 != buf) {
      free(v21);
    }
  }

BOOL sub_100C01B68()
{
  uint64_t v2 = v1;
  *(void *)&double v3 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
  double v5 = +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v2, v3, v4, 0LL);
  uint64_t v16 = v18;
  double v17 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  id v8 = +[CMMotionUtils sendMessage:withReplyClassesSync:]( &OBJC_CLASS___CMMotionUtils,  "sendMessage:withReplyClassesSync:",  &v16,  v5);
  double v9 = v17;
  if (v17)
  {
    double v10 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  id v0 = objc_msgSend(objc_msgSend(v8, "objectForKeyedSubscript:", CMDeviceHasOriginalBackCamera), "BOOLValue");
  double v12 = v19;
  if (v19)
  {
    double v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  return (BOOL)v0;
}

void sub_100C01CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  _Unwind_Resume(a1);
}

id sub_100C01CDC()
{
  if (sub_1006E2AC4())
  {
    id v0 = sub_1005D19D0((int)&v18);
  }

  else
  {
    sub_100C02820("kCLConnectionMessageCameraVcmActuatorId", &v18);
    objc_opt_class(&OBJC_CLASS___NSNumber);
    uint64_t v2 = v1;
    *(void *)&double v3 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
    uint64_t v5 = +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v2, v3, v4, 0LL);
    uint64_t v16 = v18;
    double v17 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }

    id v8 = +[CMMotionUtils sendMessage:withReplyClassesSync:]( &OBJC_CLASS___CMMotionUtils,  "sendMessage:withReplyClassesSync:",  &v16,  v5);
    double v9 = v17;
    if (v17)
    {
      double v10 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    id v0 = (NSNumber *)[v8 objectForKeyedSubscript:CMCameraVcmActuatorId];
    double v12 = v19;
    if (v19)
    {
      double v13 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  return (id)-[NSNumber intValue](v0, "intValue");
}

void sub_100C01E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100C01E50(int a1, uint64_t a2, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"com.apple.isp.focusing", 0LL))
  {
    if (CFStringCompare(theString1, @"com.apple.isp.backcamerapower", 0LL))
    {
      if (CFStringCompare(theString1, @"com.apple.isp.backcamerasensorconfig", 0LL)) {
        return;
      }
      uint64_t v5 = sub_1006E27E8();
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472LL;
      _DWORD v7[2] = sub_100C02794;
      _OWORD v7[3] = &unk_10181D3D0;
      v7[4] = a2;
      double v6 = v7;
    }

    else
    {
      uint64_t v5 = sub_1006E27E8();
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472LL;
      __int128 v8[2] = sub_100C0278C;
      _OWORD v8[3] = &unk_10181D3D0;
      v8[4] = a2;
      double v6 = v8;
    }
  }

  else
  {
    uint64_t v5 = sub_1006E27E8();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100C02784;
    void v9[3] = &unk_10181D3D0;
    _DWORD v9[4] = a2;
    double v6 = v9;
  }

  sub_1006E28B8(v5, (uint64_t)v6);
}

void sub_100C01F74(int *a1)
{
  if (notify_get_state(a1[15], &state64))
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    uint64_t v2 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      unint64_t v14 = "com.apple.isp.backcamerasensorconfig";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v11 = 136315138;
      double v12 = "com.apple.isp.backcamerasensorconfig";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not get state for %s",  (const char *)&v11);
      uint64_t v4 = (uint8_t *)v3;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()",  "%s\n",  v3);
      if (v4 != buf) {
        free(v4);
      }
    }
  }

  else
  {
    a1[16] = state64;
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    uint64_t v5 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      int v6 = a1[16];
      *(_DWORD *)uint64_t buf = 67109120;
      LODWORD(v14) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "camera mode = %d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101878348);
      }
      int v7 = a1[16];
      int v11 = 67109120;
      LODWORD(v12) = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "camera mode = %d",  &v11);
      double v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    (*(void (**)(int *))(*(void *)a1 + 56LL))(a1);
  }

uint64_t sub_100C022A4(_BYTE *a1)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101878348);
  }
  uint64_t v2 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received focusing notification", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Received focusing notification",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::onFocusingNotification()",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  sub_100C01378((uint64_t)a1);
  return sub_100C016A8(a1);
}

uint64_t sub_100C02444(_BYTE *a1)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101878348);
  }
  uint64_t v2 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received camera state notification", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Received camera state notification",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraStateNotification()",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  sub_100C01040((uint64_t)a1);
  return sub_100C016A8(a1);
}

uint64_t sub_100C025E4(int *a1)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101878348);
  }
  uint64_t v2 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received camera mode notification", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101878348);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Received camera mode notification",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraModeNotification()",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  sub_100C01F74(a1);
  return sub_100C016A8(a1);
}

uint64_t sub_100C02784(uint64_t a1)
{
  return sub_100C022A4(*(_BYTE **)(a1 + 32));
}

uint64_t sub_100C0278C(uint64_t a1)
{
  return sub_100C02444(*(_BYTE **)(a1 + 32));
}

uint64_t sub_100C02794(uint64_t a1)
{
  return sub_100C025E4(*(int **)(a1 + 32));
}

void sub_100C0279C(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

void *sub_100C027C8@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  uint64_t result = sub_100AE33EC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100C0280C(_Unwind_Exception *a1)
{
}

void *sub_100C02820@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  uint64_t result = sub_100AE33EC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100C02864(_Unwind_Exception *a1)
{
}

uint64_t sub_100C03200(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  int v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  void *v7 = off_101878378;
  v7[6] = 0LL;
  sub_10036B3B4((uint64_t)sub_100C032BC, a1, a3, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + memset(v19, 0, 48) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = v12;
    uint64_t v12 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a1;
}

void sub_100C03290(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + memset(v19, 0, 48) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_100C032BC(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101878400);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMotionActivitySubscription::onMotionActivityNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101878400);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int64_t v15 = "";
      __int16 v16 = 2082;
      double v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMotionActivitySubscription::onMotionActivityNotification, event:%{public, locatio n:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100C04790(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100C03474( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C03498(void *a1)
{
  *a1 = off_101878378;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return sub_100C6AB50((uint64_t)a1);
}

void sub_100C034DC(void *a1)
{
  *a1 = off_101878378;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = (void *)sub_100C6AB50((uint64_t)a1);
  operator delete(v3);
}

void *sub_100C03524@<X0>(uint64_t a1@<X8>)
{
  v19[0] = &off_101878450;
  v19[1] = sub_100C038E0;
  void v19[2] = 0LL;
  int64_t v20 = v19;
  sub_1010DDBC0(v21, "kCLConnectionMessageMotionActivityUpdate");
  sub_100899294((uint64_t)&v22, (uint64_t)v19);
  v17[0] = &off_101878450;
  v17[1] = sub_100C03D04;
  void v17[2] = 0LL;
  __int16 v18 = v17;
  sub_1010DDBC0(v23, "kCLConnectionMessageMotionActivityPeriodicUpdate");
  sub_100899294((uint64_t)&v24, (uint64_t)v17);
  v15[0] = &off_101878500;
  v15[1] = sub_100C04128;
  void v15[2] = 0LL;
  __int16 v16 = v15;
  sub_1010DDBC0(v25, "kCLConnectionMessageMotionActivityQuery");
  sub_100899294((uint64_t)&v26, (uint64_t)v15);
  v13[0] = &off_101878500;
  v13[1] = sub_100C046A8;
  void v13[2] = 0LL;
  __int16 v14 = v13;
  sub_1010DDBC0(v27, "kCLConnectionMessageMotionActivityAvailable");
  sub_100899294((uint64_t)v28, (uint64_t)v13);
  sub_100C05130(a1, (unsigned __int8 *)v21, 4LL);
  for (uint64_t i = 0LL; i != -28; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v28[i * 8 + 24];
    if (&v28[i * 8] == v3)
    {
      uint64_t v3 = &v28[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v27[i + 2]) < 0) {
      operator delete((void *)v27[i]);
    }
  }

  uint64_t v5 = v14;
  if (v14 == v13)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v13;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v14)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v16;
  if (v16 == v15)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v15;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v16)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  uint64_t v9 = v18;
  if (v18 == v17)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v17;
LABEL_24:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }

  else if (v18)
  {
    uint64_t v10 = 5LL;
    goto LABEL_24;
  }

  uint64_t result = v20;
  if (v20 == v19)
  {
    uint64_t v12 = 4LL;
    uint64_t result = v19;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }

  else if (v20)
  {
    uint64_t v12 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }

  return result;
}

void sub_100C0379C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20, char *a21, char a22, uint64_t a23, uint64_t a24, char *a25)
{
  for (uint64_t i = 168LL; i != -56; i -= 56LL)
    sub_10026E430(v25 + i);
  double v28 = a13;
  if (a13 == &a10)
  {
    uint64_t v29 = 4LL;
    double v28 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v29 = 5LL;
  }

  (*(void (**)(void))(*(void *)v28 + 8 * v29))();
LABEL_8:
  double v30 = a17;
  if (a17 == &a14)
  {
    uint64_t v31 = 4LL;
    double v30 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v31 = 5LL;
  }

  (*(void (**)(void))(*(void *)v30 + 8 * v31))();
LABEL_13:
  double v32 = a21;
  if (a21 == &a18)
  {
    uint64_t v33 = 4LL;
    double v32 = &a18;
  }

  else
  {
    if (!a21) {
      goto LABEL_18;
    }
    uint64_t v33 = 5LL;
  }

  (*(void (**)(void))(*(void *)v32 + 8 * v33))();
LABEL_18:
  double v34 = a25;
  if (a25 == &a22)
  {
    uint64_t v35 = 4LL;
    double v34 = &a22;
  }

  else
  {
    if (!a25) {
      goto LABEL_23;
    }
    uint64_t v35 = 5LL;
  }

  (*(void (**)(void))(*(void *)v34 + 8 * v35))();
LABEL_23:
  _Unwind_Resume(a1);
}

void sub_100C038E0(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019344F0 != -1) {
    dispatch_once(&qword_1019344F0, &stru_101878420);
  }
  uint64_t v5 = (os_log_s *)qword_1019344F8;
  if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)uint64_t buf = 138412546;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v26 = 1024;
    int v27 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Received MotionActivityUpdate request,client,%@,subscribe,%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    int v21 = 138412546;
    uint64_t v22 = v11;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "Received MotionActivityUpdate request,client,%@,subscribe,%d",  &v21,  18);
    int v13 = (char *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionActivitySubscription::handleRequestMotionActivityUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  if ((sub_10036AA0C() & 1) != 0)
  {
    if ((sub_100C6ADE0(a1) & 1) != 0)
    {
      sub_100C6AC8C(a1);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(v7 + 8);
      uint64_t v8 = *(void **)(v7 + 16);
      if (a2) {
        [v8 register:v9 forNotification:1 registrationInfo:0];
      }
      else {
        [v8 unregister:v9 forNotification:1];
      }
    }

    else
    {
      uint64_t v17 = CMErrorMessage;
      __int16 v18 = &off_1018D4280;
      *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
      sub_100C049F8(a1, buf);
    }
  }

  else
  {
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    uint64_t v10 = (os_log_s *)qword_1019344F8;
    if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Cannot subscribe to motion activity updates, motion activity is not available",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344F0 != -1) {
        dispatch_once(&qword_1019344F0, &stru_101878420);
      }
      LOWORD(v21) = 0;
      LODWORD(v16) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "Cannot subscribe to motion activity updates, motion activity is not available",  &v21,  v16);
      int64_t v15 = (char *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionActivitySubscription::handleRequestMotionActivityUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    uint64_t v19 = CMErrorMessage;
    int64_t v20 = &off_1018D4268;
    *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
    sub_100C049F8(a1, buf);
  }
}

void sub_100C03CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100C03D04(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019344F0 != -1) {
    dispatch_once(&qword_1019344F0, &stru_101878420);
  }
  uint64_t v5 = (os_log_s *)qword_1019344F8;
  if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)uint64_t buf = 138412546;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v26 = 1024;
    int v27 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Received MotionActivityPeriodicUpdate request,client,%@,subscribe,%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    int v21 = 138412546;
    uint64_t v22 = v11;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "Received MotionActivityPeriodicUpdate request,client,%@,subscribe,%d",  &v21,  18);
    int v13 = (char *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionActivitySubscription::handleRequestMotionActivityPeriodicUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  if ((sub_10036AA0C() & 1) != 0)
  {
    if ((sub_100C6ADE0(a1) & 1) != 0)
    {
      sub_100C6AC8C(a1);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(v7 + 8);
      uint64_t v8 = *(void **)(v7 + 16);
      if (a2) {
        [v8 register:v9 forNotification:10 registrationInfo:0];
      }
      else {
        [v8 unregister:v9 forNotification:10];
      }
    }

    else
    {
      uint64_t v17 = CMErrorMessage;
      __int16 v18 = &off_1018D4280;
      *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
      sub_100C04A98(a1, buf);
    }
  }

  else
  {
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    uint64_t v10 = (os_log_s *)qword_1019344F8;
    if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Cannot subscribe to motion activity updates, motion activity is not available",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344F0 != -1) {
        dispatch_once(&qword_1019344F0, &stru_101878420);
      }
      LOWORD(v21) = 0;
      LODWORD(v16) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "Cannot subscribe to motion activity updates, motion activity is not available",  &v21,  v16);
      int64_t v15 = (char *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionActivitySubscription::handleRequestMotionActivityPeriodicUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    uint64_t v19 = CMErrorMessage;
    int64_t v20 = &off_1018D4268;
    *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
    sub_100C04A98(a1, buf);
  }
}

void sub_100C040E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100C04128(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if ((sub_10036AA0C() & 1) == 0)
  {
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    __int16 v14 = (os_log_s *)qword_1019344F8;
    if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "query for motion activity was received but motion activity is not available",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344F0 != -1) {
        dispatch_once(&qword_1019344F0, &stru_101878420);
      }
      v34[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "query for motion activity was received but motion activity is not available",  v34,  2);
      uint64_t v29 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionActivitySubscription::handleMessageMotionActivityQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v28);
      if (v29 != buf) {
        free(v29);
      }
    }

    uint64_t v6 = *(CLConnectionMessage **)a2;
    uint64_t v39 = CMErrorMessage;
    uint64_t v40 = &off_1018D4268;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v40,  &v39,  1LL);
    goto LABEL_21;
  }

  char v5 = sub_100C6ADE0(a1);
  uint64_t v6 = *(CLConnectionMessage **)a2;
  if ((v5 & 1) == 0)
  {
    uint64_t v37 = CMErrorMessage;
    __int128 v38 = &off_1018D4280;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v38,  &v37,  1LL);
LABEL_21:
    CLConnectionMessage::sendReply(v6);
    goto LABEL_22;
  }

  Dictionary = (void *)CLConnectionMessage::getDictionary(*(CLConnectionMessage **)a2);
  id v8 = [Dictionary objectForKeyedSubscript:CMMotionActivityStartTime];
  id v9 = [Dictionary objectForKeyedSubscript:CMMotionActivityStopTime];
  uint64_t v10 = v9;
  if (v8) {
    BOOL v11 = v9 == 0LL;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11)
  {
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101878420);
    }
    uint64_t v12 = (os_log_s *)qword_1019344F8;
    if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Programmer error: Wrong parameters were passed!",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344F0 != -1) {
        dispatch_once(&qword_1019344F0, &stru_101878420);
      }
      v34[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  17LL,  "Programmer error: Wrong parameters were passed!",  v34,  2);
      uint64_t v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMotionActivitySubscription::handleMessageMotionActivityQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }

    int v13 = *(CLConnectionMessage **)a2;
    uint64_t v35 = CMErrorMessage;
    uint64_t v36 = &off_1018D4298;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v36,  &v35,  1LL);
    CLConnectionMessage::sendReply(v13);
  }

  else
  {
    [v8 doubleValue];
    double v16 = v15;
    [v10 doubleValue];
    double v18 = v17;
    uint64_t v19 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLDaemonClient.MotionActivityQuery");
    int64_t v20 = *(void **)(*(void *)(a1 + 48) + 16LL);
    sub_1010DDBC0(buf, "com.apple.locationd.activity");
    uint64_t v21 = sub_100C6AC9C(a1);
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3321888768LL;
    v32[2] = sub_100C04B38;
    v32[3] = &unk_1018783A0;
    uint64_t v22 = *(std::__shared_weak_count **)(a2 + 8);
    v32[5] = *(void *)a2;
    uint64_t v33 = v22;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        unint64_t v24 = __ldxr(p_shared_owners);
      while (__stxr(v24 + 1, p_shared_owners));
    }

    v32[4] = v19;
    [v20 queryMotionStatesWithStartTime:v21 endTime:v32 isFromInternalClient:v16 withReply:v18];
    if (v42 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v25 = v33;
    if (v33)
    {
      __int16 v26 = (unint64_t *)&v33->__shared_owners_;
      do
        unint64_t v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }

void sub_100C04634( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  _Unwind_Resume(a1);
}

void sub_100C046A8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  uint64_t v4 = *a2;
  uint64_t v5 = CMAvailable;
  uint64_t v6 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10036AA0C());
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL);
  CLConnectionMessage::sendReply(v4);
}

void sub_100C04768(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_100006BB8(exception_object);
}

void sub_100C04790(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 10 || *a3 == 1)
  {
    id v8 = objc_alloc(&OBJC_CLASS___CMMotionActivity);
    __int128 v9 = *(_OWORD *)(a4 + 112);
    v15[6] = *(_OWORD *)(a4 + 96);
    v15[7] = v9;
    uint64_t v16 = *(void *)(a4 + 128);
    __int128 v10 = *(_OWORD *)(a4 + 48);
    void v15[2] = *(_OWORD *)(a4 + 32);
    void v15[3] = v10;
    __int128 v11 = *(_OWORD *)(a4 + 80);
    v15[4] = *(_OWORD *)(a4 + 64);
    v15[5] = v11;
    __int128 v12 = *(_OWORD *)(a4 + 16);
    v15[0] = *(_OWORD *)a4;
    v15[1] = v12;
    int v13 = -[CMMotionActivity initWithMotionActivity:](v8, "initWithMotionActivity:", v15);
    uint64_t v17 = CMMotionActivityData;
    double v18 = v13;
    __int16 v14 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);

    if (*a3 == 10)
    {
      sub_100C04950(a1, &v14);
    }

    else if (*a3 == 1)
    {
      sub_100C048A8(a1, &v14);
    }
  }

void sub_100C048A8(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100C0493C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100C04950(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100C049E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100C049F8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(off_101878570, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100C04A84(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100C04A98(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_101878578, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100C04B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100C04B38(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = CMMotionActivityDataArray;
  uint64_t v4 = +[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", a2);
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v4,  &v3,  1LL);
  CLConnectionMessage::sendReply(*(void *)(a1 + 40));
}

void sub_100C04BD8(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100C04C04(id a1)
{
  qword_1019344F8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Activity");
}

__n128 sub_100C04C30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101878450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100C04C6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101878450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100C04C90(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_100C04C98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100C04CD4()
{
}

void sub_100C04CE0(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_100C04D64(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100C04D4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C04D64(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    id v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    __int128 v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      id v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_1018784C0);
    }
    __int128 v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_1018784C0);
      }
    }

    __int128 v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_100C04F48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100C04F64(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_100C04F90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101878500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100C04FCC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101878500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100C04FF0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100C04FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100C05034()
{
}

void sub_100C05040(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  double v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  __int128 v10 = v17;
  if (v17)
  {
    __int128 v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    int v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100C05114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100C05130(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100C051A8(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100C05194(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100C051A8(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    int v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100C05428(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    void *v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100C05410(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100C05428@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100C0549C(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100C05484(_Unwind_Exception *a1)
{
}

void *sub_100C0549C(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100C054F4(_Unwind_Exception *exception_object)
{
}

void *sub_100C05510(void *a1)
{
  if (v9 < 0) {
    operator delete(__p);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
  *a1 = off_101878590;
  return a1;
}

void sub_100C0559C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100C055B0(std::string *a1@<X8>)
{
  int v2 = sub_1002A6F64(*(uint64_t *)&buf[0], "WriteLocationdLogsToCrashReporterFolder", (BOOL *)&__str);
  if (__str.__r_.__value_.__s.__data_[0]) {
    int v3 = v2;
  }
  else {
    int v3 = 0;
  }
  __int128 v4 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    char v5 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  if (v3) {
    char v7 = "/var/mobile/Library/Logs/CrashReporter/com.apple.locationd";
  }
  else {
    char v7 = "/var/mobile/Library/Logs/locationd";
  }
  std::string::assign(a1 + 2, v7);
  sub_1010DDBC0(&__str, "locctl");
  std::string::operator=(a1 + 3, &__str);
  std::string::operator=(a1, &__str);
  a1[4].__r_.__value_.__r.__words[0] = 0x410FA40000000000LL;
  a1[4].__r_.__value_.__s.__size_ = 1;
  sub_1002F0B04(buf);
  int v8 = sub_1002A6F64(*(uint64_t *)&buf[0], "EnableLargeLocationControllerRecorderLogs", (BOOL *)&v19);
  if ((_BYTE)v19) {
    int v9 = v8;
  }
  else {
    int v9 = 0;
  }
  unint64_t v10 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_19;
  }
  uint8x8_t v11 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v9) {
      goto LABEL_25;
    }
  }

  else
  {
LABEL_19:
    if (!v9) {
      goto LABEL_25;
    }
  }

  a1[4].__r_.__value_.__l.__size_ *= 16LL;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_1018785B8);
  }
  int v13 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    std::string::size_type size = a1[4].__r_.__value_.__l.__size_;
    LODWORD(buf[0]) = 134283521;
    *(void *)((char *)buf + 4) = size;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "#locctl,#rec,EnableLargeLogs is set,maxDirectorySizeBytes,%{private}lld",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_1018785B8);
    }
    std::string::size_type v15 = a1[4].__r_.__value_.__l.__size_;
    int v19 = 134283521;
    std::string::size_type v20 = v15;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "#locctl,#rec,EnableLargeLogs is set,maxDirectorySizeBytes,%{private}lld",  &v19,  12);
    float v17 = (char *)v16;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static CLProtobufSerializer::Config CLLocationControllerSerializer::generateConfig()",  "%s\n",  v16);
  }

void sub_100C058C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100C05928(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100C05928(uint64_t a1)
{
  return a1;
}

uint64_t sub_100C0598C()
{
  if ((sub_100C059B0() & 1) != 0) {
    return 1LL;
  }
  else {
    return sub_100C05BD8();
  }
}

uint64_t sub_100C059B0()
{
  unsigned int v0 = sub_1002A6F64(*(uint64_t *)buf, "EnableLocationControllerProtoToOsLog", (BOOL *)v8);
  if (LOBYTE(v8[0])) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  int v2 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_1018785B8);
  }
  char v5 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v1;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#locctl,#rec,EnableLocationControllerProtoToOsLog,%{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_1018785B8);
    }
    v8[0] = 67240192;
    v8[1] = v1;
    char v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "#locctl,#rec,EnableLocationControllerProtoToOsLog,%{public}d",  v8,  8);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static BOOL CLLocationControllerSerializer::isOsLogEnabled()", "%s\n", v7);
  }

  return v1;
}

void sub_100C05BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100C05BD8()
{
  uint64_t v0 = sub_1004F8A40();
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_1018785B8);
  }
  uint64_t v1 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t buf = 67174657;
    int v6 = v0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_INFO,  "#locctl,#rec,serializer,isInternalInstall,%{private}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_1018785B8);
    }
    v4[0] = 67174657;
    v4[1] = v0;
    int v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "#locctl,#rec,serializer,isInternalInstall,%{private}d",  v4,  8);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static BOOL CLLocationControllerSerializer::isDiskEnabled()", "%s\n", v3);
  }

  return v0;
}

void sub_100C05D90(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100D9BDF8(a1);
  operator delete(v1);
}

void sub_100C05DA4(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

uint64_t sub_100C05DD0(uint64_t a1)
{
  int v2 = sub_1010DDBC0((void *)a1, "cl_proto");
  sub_1010DDBC0(v2 + 3, ".bin");
  sub_1010DDBC0((void *)(a1 + 48), "/var/mobile/Library/Logs/com.apple.locationd");
  sub_1010DDBC0((void *)(a1 + 72), "");
  *(void *)(a1 + 96) = 0x410FA40000000000LL;
  *(void *)(a1 + 104) = 314572800LL;
  *(_DWORD *)(a1 + 112) = 250;
  *(_DWORD *)(a1 + 116) = 65537;
  *(_WORD *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 257;
  return a1;
}

void sub_100C05E64(_Unwind_Exception *exception_object)
{
}

void sub_100C05FF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C06020(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  sub_100D2D9A4(a1 + 8);
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0xFFFF;
  *(void *)(a1 + 76) = 0LL;
  *(void *)(a1 + 68) = 0LL;
  *(_OWORD *)(a1 + 84) = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 10sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = _Q0;
  *(_OWORD *)(a1 + 116) = _Q0;
  *(_OWORD *)(a1 + 132) = _Q0;
  *(_DWORD *)(a1 + 1memset(v19, 0, 48) = 0;
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 152) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 18sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 188) = 0x7FFFFFFF;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 208) = 0LL;
  *(_BYTE *)(a1 + 216) = 0;
  return a1;
}

void sub_100C060A8(void *a1, uint64_t a2, double *a3)
{
}

void sub_100C060B8(void *a1, int a2, uint64_t a3, double *a4)
{
  double v7 = *a4;
  double v8 = *((double *)a1 + 6);
  double v9 = vabdd_f64(*a4, *((double *)a1 + 7));
  if ((a2 & 1) != 0 || v9 >= 2400.0)
  {
    memset(v31, 0, sizeof(v31));
    int v10 = (*(uint64_t (**)(void))(*(void *)*a1 + 16LL))();
    if ((v10 & 1) != 0)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018785E8);
      }
      uint8x8_t v11 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = a1[7];
        uint64_t v13 = *(void *)((char *)a1 + 68);
        uint64_t v14 = *(void *)((char *)a1 + 76);
        *(_DWORD *)uint64_t buf = 67110144;
        *(_DWORD *)&uint8_t buf[4] = a2;
        __int16 v42 = 1024;
        *(_DWORD *)uint64_t v43 = 1;
        *(_WORD *)&v43[4] = 2048;
        *(void *)&v43[6] = v12;
        __int16 v44 = 2048;
        uint64_t v45 = v13;
        __int16 v46 = 2048;
        *(void *)&__int128 v47 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "isStart,%d,manifest,%d,LastTime,%lf,LastLat,%.05lf,LastLon,%.05lf",  buf,  0x2Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_1018785E8);
        }
        uint64_t v20 = a1[7];
        uint64_t v21 = *(void *)((char *)a1 + 68);
        uint64_t v22 = *(void *)((char *)a1 + 76);
        *(_DWORD *)double v32 = 67110144;
        *(_DWORD *)&v32[4] = a2;
        __int16 v33 = 1024;
        int v34 = 1;
        __int16 v35 = 2048;
        uint64_t v36 = v20;
        __int16 v37 = 2048;
        uint64_t v38 = v21;
        __int16 v39 = 2048;
        uint64_t v40 = v22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "isStart,%d,manifest,%d,LastTime,%lf,LastLat,%.05lf,LastLon,%.05lf",  v32,  44,  v27,  v28,  v29);
        unint64_t v24 = (uint8_t *)v23;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTransitTilePreloader::makeRequestIfNeeded(BOOL, const CLDaemonLocation &, const CFAbsoluteTime &)",  "%s\n",  v23);
        if (v24 != buf) {
          free(v24);
        }
      }

      if (!a2)
      {
        if (*(double *)(a3 + 20) > 0.0)
        {
          sub_100D2DCA4((double *)a1 + 1, a3, (uint64_t)(a1 + 8));
        }

        goto LABEL_31;
      }

      if (vabdd_f64(v7, v8) >= 259200.0)
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_1018785E8);
        }
        std::string::size_type v15 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Request region preload manifest, update",  buf,  2u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_25;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_1018785E8);
        }
        *(_WORD *)double v32 = 0;
        LODWORD(v26) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Request region preload manifest, update",  v32,  v26);
        float v17 = (uint8_t *)v16;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTransitTilePreloader::makeRequestIfNeeded(BOOL, const CLDaemonLocation &, const CFAbsoluteTime &)",  "%s\n",  v16);
LABEL_40:
        if (v17 != buf) {
          free(v17);
        }
LABEL_25:
        sub_100C069A0(a1, v10 ^ 1, a4);
      }
    }

    else if (a2)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018785E8);
      }
      BOOL v18 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "Request region preload manifest, no manifest",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_25;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018785E8);
      }
      *(_WORD *)double v32 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Request region preload manifest, no manifest",  v32,  2);
      float v17 = (uint8_t *)v25;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTransitTilePreloader::makeRequestIfNeeded(BOOL, const CLDaemonLocation &, const CFAbsoluteTime &)",  "%s\n",  v25);
      goto LABEL_40;
    }

void sub_100C068E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void **a31)
{
  a31 = (void **)&a20;
  sub_1004F206C(&a31);
  _Unwind_Resume(a1);
}

void sub_100C06928(void *a1, uint64_t a2, double *a3)
{
}

double sub_100C06938(uint64_t a1)
{
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0xFFFF;
  *(void *)(a1 + 76) = 0LL;
  *(void *)(a1 + 68) = 0LL;
  *(_OWORD *)(a1 + 84) = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 10sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = _Q0;
  *(_OWORD *)(a1 + 116) = _Q0;
  *(_OWORD *)(a1 + 132) = _Q0;
  *(_DWORD *)(a1 + 1memset(v19, 0, 48) = 0;
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 152) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 18sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 188) = 0x7FFFFFFF;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_BYTE *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0LL;
  return sub_1003D33C8(a1 + 8);
}

uint64_t sub_100C069A0(void *a1, int a2, void *a3)
{
  a1[6] = *a3;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018785E8);
  }
  char v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v12 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Requesting download of preload manifest, allowCell,%d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018785E8);
    }
    v10[0] = 67109120;
    v10[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Requesting download of preload manifest, allowCell,%d",  v10);
    double v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTransitTilePreloader::requestDownloadManifest(const BOOL, const CFAbsoluteTime &)",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  unint64_t v13 = 0xBFF0000000000000LL;
  CFAbsoluteTime v15 = Current;
  __int16 v16 = 1;
  buf[0] = a2;
  buf[1] = a2;
  buf[2] = 0;
  int v14 = 0;
  return (*(uint64_t (**)(void, uint8_t *))(*(void *)*a1 + 24LL))(*a1, buf);
}

uint64_t sub_100C06B90(void *a1, int a2, uint64_t a3, void *a4)
{
  a1[7] = *a4;
  __int128 v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)a1 + 4) = *(_OWORD *)a3;
  *((_OWORD *)a1 + 5) = v7;
  __int128 v8 = *(_OWORD *)(a3 + 32);
  __int128 v9 = *(_OWORD *)(a3 + 48);
  __int128 v10 = *(_OWORD *)(a3 + 80);
  *((_OWORD *)a1 + 8) = *(_OWORD *)(a3 + 64);
  *((_OWORD *)a1 + 9) = v10;
  *((_OWORD *)a1 + 6) = v8;
  *((_OWORD *)a1 + 7) = v9;
  __int128 v11 = *(_OWORD *)(a3 + 96);
  __int128 v12 = *(_OWORD *)(a3 + 112);
  __int128 v13 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)((char *)a1 + 204) = *(_OWORD *)(a3 + 140);
  *((_OWORD *)a1 + 11) = v12;
  *((_OWORD *)a1 + 12) = v13;
  *((_OWORD *)a1 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v11;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018785E8);
  }
  int v14 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = *(void *)(a3 + 4);
    uint64_t v16 = *(void *)(a3 + 12);
    *(_DWORD *)uint64_t buf = 134218496;
    *(void *)uint64_t v31 = v15;
    *(_WORD *)&v31[8] = 2048;
    *(void *)&v31[10] = v16;
    __int16 v32 = 1024;
    LODWORD(v33) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Request tiles at lat,%.06lf,lon,%.06lf, allowCell,%d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018785E8);
    }
    uint64_t v19 = *(void *)(a3 + 4);
    uint64_t v20 = *(void *)(a3 + 12);
    int v24 = 134218496;
    uint64_t v25 = v19;
    __int16 v26 = 2048;
    uint64_t v27 = v20;
    __int16 v28 = 1024;
    int v29 = a2;
    LODWORD(v23) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Request tiles at lat,%.06lf,lon,%.06lf, allowCell,%d",  COERCE_DOUBLE(&v24),  v23);
    uint64_t v22 = (uint8_t *)v21;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTransitTilePreloader::requestDownloadWifiTile(const BOOL, const CLDaemonLocation &, const CFAbsoluteTime &)",  "%s\n",  v21);
    if (v22 != buf) {
      free(v22);
    }
  }

  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(void *)&v31[4] = 0xBFF0000000000000LL;
  CFAbsoluteTime v33 = Current;
  __int16 v34 = 1;
  buf[0] = a2;
  buf[1] = a2;
  buf[2] = 0;
  *(_DWORD *)&v31[12] = 0;
  return (*(uint64_t (**)(void, uint8_t *, void, double, double))(*(void *)*a1 + 32LL))( *a1,  buf,  0LL,  *(double *)(a3 + 4),  *(double *)(a3 + 12));
}

void sub_100C06E08(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100C06E34()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100C06E98()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100C06F0C(_Unwind_Exception *a1)
{
}

double sub_100C06F24(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0xBFF0000000000000LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + memset(v19, 0, 48) = 0u;
  *(void *)(a1 + 64) = 0LL;
  return result;
}

void sub_100C06F40(void *a1, _OWORD *a2)
{
  unint64_t v6 = a1[5];
  uint64_t v4 = (uint64_t)(a1 + 5);
  unint64_t v5 = v6;
  __int128 v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    __int128 v9 = (void **)(v4 - 16);
    uint64_t v10 = *(void *)(v4 - 16);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 4;
    unint64_t v12 = v11 + 1;
    uint64_t v13 = v5 - v10;
    if (v13 >> 3 > v12) {
      unint64_t v12 = v13 >> 3;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14) {
      uint64_t v15 = (char *)sub_100037038(v4, v14);
    }
    else {
      uint64_t v15 = 0LL;
    }
    uint64_t v16 = &v15[16 * v11];
    float v17 = &v15[16 * v14];
    *(_OWORD *)uint64_t v16 = *a2;
    __int128 v8 = (double *)(v16 + 16);
    uint64_t v19 = (char *)a1[3];
    BOOL v18 = (char *)a1[4];
    if (v18 != v19)
    {
      do
      {
        *((_OWORD *)v16 - 1) = *((_OWORD *)v18 - 1);
        v16 -= 16;
        v18 -= 16;
      }

      while (v18 != v19);
      BOOL v18 = (char *)*v9;
    }

    a1[3] = v16;
    a1[4] = v8;
    a1[5] = v17;
    if (v18) {
      operator delete(v18);
    }
  }

  else
  {
    _OWORD *v7 = *a2;
    __int128 v8 = (double *)(v7 + 1);
  }

  a1[4] = v8;
  uint64_t v20 = a1[3];
  if ((double *)v20 != v8 && *(v8 - 2) - *(double *)v20 >= 60.0)
  {
    unint64_t v21 = 0LL;
    double v22 = 0.0;
    float v23 = -3.4028e38;
    do
    {
      double v24 = *(double *)v20;
      v20 += 16LL;
      double v22 = v22 + v24;
      ++v21;
    }

    while ((double *)v20 != v8);
    unint64_t v25 = a1[8];
    double v26 = *(double *)a2;
    double v27 = v22 / (double)v21;
    __int16 v28 = (float *)a1[7];
    if ((unint64_t)v28 >= v25)
    {
      double v30 = (float *)a1[6];
      uint64_t v31 = ((char *)v28 - (char *)v30) >> 4;
      unint64_t v32 = v31 + 1;
      uint64_t v33 = v25 - (void)v30;
      if (v33 >> 3 > v32) {
        unint64_t v32 = v33 >> 3;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34)
      {
        __int16 v35 = (char *)sub_100037038((uint64_t)(a1 + 8), v34);
        double v30 = (float *)a1[6];
        __int16 v28 = (float *)a1[7];
      }

      else
      {
        __int16 v35 = 0LL;
      }

      uint64_t v36 = &v35[16 * v31];
      __int16 v37 = &v35[16 * v34];
      *(double *)uint64_t v36 = v27;
      *((float *)v36 + 2) = v23;
      int v29 = (double *)(v36 + 16);
      if (v28 != v30)
      {
        do
        {
          *((_OWORD *)v36 - 1) = *((_OWORD *)v28 - 1);
          v36 -= 16;
          v28 -= 4;
        }

        while (v28 != v30);
        double v30 = (float *)a1[6];
      }

      a1[6] = v36;
      a1[7] = v29;
      a1[8] = v37;
      if (v30) {
        operator delete(v30);
      }
    }

    else
    {
      *(double *)__int16 v28 = v27;
      v28[2] = v23;
      int v29 = (double *)(v28 + 4);
    }

    a1[7] = v29;
    uint64_t v38 = (double *)a1[6];
    if (v38 != v29)
    {
      while (vabdd_f64(v26, *v38) <= 86400.0)
      {
        v38 += 2;
        if (v38 == v29) {
          goto LABEL_51;
        }
      }

      if (v38 != v29)
      {
        __int16 v39 = v38 + 2;
        if (v38 + 2 != v29)
        {
          do
          {
            if (vabdd_f64(v26, *v39) <= 86400.0)
            {
              *(_OWORD *)uint64_t v38 = *(_OWORD *)v39;
              v38 += 2;
            }

            v39 += 2;
          }

          while (v39 != v29);
          int v29 = (double *)a1[7];
        }
      }

      if (v38 != v29) {
        a1[7] = v38;
      }
    }

uint64_t sub_100C0721C(uint64_t result, double a2, double a3)
{
  uint64_t v4 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  if (v4 != v3)
  {
    int v5 = 0;
    double v6 = -1.79769313e308;
    while (1)
    {
      double v7 = *(double *)v4;
      if (*(double *)v4 >= a2 && v7 < a3)
      {
        ++v5;
      }

      if (v7 < a3) {
        break;
      }
      v4 += 16LL;
      if (v4 == v3) {
        return result;
      }
    }

    if (v4 != v3)
    {
      uint64_t v9 = v4 + 16;
      if (v4 + 16 != v3)
      {
        do
        {
          double v10 = *(double *)v9;
          if (*(double *)v9 >= a2 && v10 < a3)
          {
            ++v5;
          }

          if (v10 >= a3)
          {
            *(_OWORD *)uint64_t v4 = *(_OWORD *)v9;
            v4 += 16LL;
          }

          v9 += 16LL;
        }

        while (v9 != v3);
        uint64_t v3 = *(void *)(result + 56);
      }

      if (v4 != v3) {
        *(void *)(result + 56) = v4;
      }
    }
  }

  return result;
}

void sub_100C07334(void *a1, double a2, double a3, double a4)
{
  double v7 = a4 / 60.0;
  sub_100C0721C((uint64_t)a1, a2, a3);
  double v9 = v8;
  if (qword_101934940 != -1) {
    dispatch_once(&qword_101934940, &stru_101878608);
  }
  double v10 = round(v7);
  uint64_t v11 = (os_log_s *)qword_101934948;
  if (os_log_type_enabled((os_log_t)qword_101934948, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67110144;
    BOOL v23 = v10 > 0.0;
    __int16 v24 = 2048;
    double v25 = a2;
    __int16 v26 = 2048;
    double v27 = a3;
    __int16 v28 = 2048;
    double v29 = v10;
    __int16 v30 = 2048;
    double v31 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Aggregated result, shouldWrite, %d, startTime, %f, endTime, %f, daylightMinutes, %f, maxLux, %f",  buf,  0x30u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934940 != -1) {
      dispatch_once(&qword_101934940, &stru_101878608);
    }
    LODWORD(v16) = 67110144;
    HIDWORD(v16) = v10 > 0.0;
    *(_WORD *)float v17 = 2048;
    *(double *)&void v17[2] = a2;
    *(_WORD *)&_BYTE v17[10] = 2048;
    *(double *)&v17[12] = a3;
    __int16 v18 = 2048;
    double v19 = v10;
    __int16 v20 = 2048;
    double v21 = v9;
    LODWORD(v15) = 48;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934948,  0LL,  "Aggregated result, shouldWrite, %d, startTime, %f, endTime, %f, daylightMinutes, %f, maxLux, %f",  &v16,  v15,  v16,  *(double *)v17,  *(double *)&v17[8]);
    unint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTimeInDaylightHealthKitAggregator::writeToHK(CFAbsoluteTime, CFAbsoluteTime, double)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

  if (v10 > 0.0)
  {
    float v12 = v9;
    (*(void (**)(void, double, double, double, float))(*(void *)*a1 + 16LL))(*a1, a2, a3, v10, v12);
  }

void sub_100C07590(uint64_t a1, double *a2)
{
  double v4 = *(double *)(a1 + 8);
  if (v4 == -1.0 || *(double *)(a1 + 16) == 0.0)
  {
    double v4 = *a2;
    *(double *)(a1 + 8) = *a2;
    double v5 = v4;
  }

  else
  {
    double v5 = *a2;
  }

  if (v5 - v4 > 300.0)
  {
    sub_100C07334((void *)a1, v4, v4 + 300.0, *(double *)(a1 + 16));
    double v4 = *a2;
    *(double *)(a1 + 8) = *a2;
    *(void *)(a1 + 16) = 0LL;
  }

  double v6 = a2[1];
  if (v6 - v4 >= 300.0)
  {
    double v8 = *(double *)(a1 + 16);
    do
    {
      double v7 = v4 + 300.0;
      sub_100C07334((void *)a1, v4, v4 + 300.0, v4 + 300.0 - v5 + v8);
      *(double *)(a1 + 8) = v7;
      *(void *)(a1 + 16) = 0LL;
      double v6 = a2[1];
      double v8 = 0.0;
      double v4 = v7;
      double v5 = v7;
    }

    while (v6 - v7 >= 300.0);
  }

  else
  {
    double v7 = v5;
  }

  if (v6 > v7) {
    *(double *)(a1 + 16) = v6 - v7 + *(double *)(a1 + 16);
  }
}

void sub_100C07690(id a1)
{
  qword_101934948 = (uint64_t)os_log_create("com.apple.locationd.Position", "Outdoor");
}

void sub_100C07760(id a1)
{
  qword_10199ADA8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLAutopauseProviderSilo");
}

uint64_t sub_100C07814(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100C07974;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199ADB8 != -1) {
    dispatch_once(&qword_10199ADB8, block);
  }
  return qword_1019A1EA0;
}

uint64_t sub_100C07974(uint64_t a1)
{
  if (sub_1004F8210())
  {
    int v2 = operator new(0x258uLL);
    uint64_t result = sub_100DD36E0(v2, *(void *)(a1 + 32));
  }

  else
  {
    int v2 = operator new(0x70uLL);
    uint64_t result = sub_100E08800(v2, *(void *)(a1 + 32));
  }

  qword_1019A1EA0 = (uint64_t)v2;
  return result;
}

void sub_100C079D0(_Unwind_Exception *a1)
{
}

void *sub_100C079E8(uint64_t a1, void *a2)
{
  uint64_t result = (void *)sub_100C07A14(a1, "CLAutopauseProvider", a2);
  *uint64_t result = off_101878658;
  return result;
}

uint64_t sub_100C07A14(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_1018787E0;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = [a3 silo];
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100C07A94(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100C07AB0(uint64_t a1)
{
  *(void *)a1 = off_101878658;
  *(_BYTE *)(a1 + 108) = 1;
  return sub_100C07AC8(a1);
}

uint64_t sub_100C07AC8(uint64_t a1)
{
  *(void *)a1 = off_1018787E0;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

void *sub_100C07B44@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void sub_100C07BBC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  double v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLAutopauseProvider");
  sub_100C07C84((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *double v8 = off_101878738;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100C07C58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100C07C84(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_1018788C0;
  *(void *)(a1 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    float v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_100C07D58(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        double v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)uint64_t buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018787B0);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)uint64_t buf = 136446466;
        double v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_1018787B0);
        }
        float v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        float v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        id v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::r emoveClient(int) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopausePro vider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100C07FCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_10198FCE8);
}

uint64_t sub_100C07FE0(uint64_t a1, int a2, int *a3, char *a4)
{
  int v42 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v43 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          __int16 v24 = (uint64_t *)v18;
        }
        else {
          __int16 v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          double v29 = (uint64_t *)v25;
        }
        else {
          double v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v41 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)uint64_t buf = &v42;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        buf[2] = 0;
        *(_WORD *)uint64_t buf = 0;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v36 = sub_100C0992C((uint64_t)buf);
          sub_100C099B4((_BYTE *)a1, (uint64_t)v43, (uint64_t)&v41, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v41 = a1 + 64;
        char v30 = byte_10198FCE9;
        HIDWORD(v4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v17;
        *(void *)uint64_t buf = (char *)&v40 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v30;
        HIDWORD(v4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *a3;
        *(void *)uint64_t buf = (char *)&v40 + 4;
        double v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *a3;
        *(void *)uint64_t buf = (char *)&v40 + 4;
        uint64_t v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)uint64_t buf = &v42;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)uint64_t buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v43 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018787B0);
  }
  id v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v47 = 1026;
    int v48 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018787B0);
    }
    __int16 v37 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v43 = 136446466;
    *(void *)&v43[4] = v37;
    __int16 v44 = 1026;
    int v45 = a2;
    LODWORD(v4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v43,
      v40);
    __int16 v39 = (char *)v38;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::regis terForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLAutopauseProvider_ Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, Re gistrationInfo_T = char]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_100C08440(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      double v9 = (uint64_t *)v5;
    }
    else {
      double v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018787B0);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136446466;
      char v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018787B0);
      }
      int v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      uint64_t v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      __int16 v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::cli entRegistered(int, const Notification_T &) [Notification_T = CLAutopauseProvider_Type::Notification, Notificatio nData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100C086C0(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018787B0);
              }
              uint64_t v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)uint64_t buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                __int16 v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_1018787B0);
                }
                double v29 = a1 + 8;
                if (a1[31] < 0) {
                  double v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                int v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                uint64_t v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::Notification Data>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLAutopauseProvider_Ty pe::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100C08A48(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(__int16 **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  __int16 v12 = *v11;
  *(_BYTE *)(a3 + 2) = *((_BYTE *)v11 + 2);
  *(_WORD *)a3 = v12;
  return 1LL;
}

uint64_t sub_100C08AB0(uint64_t a1, int *a2, __int16 *a3)
{
  int v6 = operator new(0x20uLL);
  _DWORD v6[2] = 0LL;
  *int v6 = off_101878908;
  v6[1] = 0LL;
  *((_BYTE *)v6 + 26) = *((_BYTE *)a3 + 2);
  __int16 v7 = *a3;
  *((void *)&v14 + 1) = v6;
  *((_WORD *)v6 + 12) = v7;
  *(void *)&__int128 v14 = v6 + 3;
  int v13 = *a2;
  int v15 = &v13;
  int v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  BOOL v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_100C08B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100C08BA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v6 = 0;
  __int16 v5 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, __int16 *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  &v5,  a3,  a4,  0LL);
}

void sub_100C08BDC(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018787B0);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int16 v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v67 = 2082;
      BOOL v68 = v12;
      __int16 v69 = 2050;
      uint64_t v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)uint64_t v71 = &v71[8];
      memset(&v71[8], 0, 24);
      uint64_t v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      __int16 v27 = operator new(0x20uLL);
      v27[2] = 0LL;
      *__int16 v27 = off_101878908;
      v27[1] = 0LL;
      *((_BYTE *)v27 + 26) = *(_BYTE *)(a3 + 2);
      *((_WORD *)v27 + 12) = *(_WORD *)a3;
      *(void *)uint64_t buf = v27 + 3;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        double v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    __int16 v31 = sub_100C0A300(a3);
    if (a5 == -1)
    {
      sub_100C0A388((void *)a1, (int *)a2, v31);
    }

    else
    {
      uint64_t v32 = a1 + 88;
      uint64_t v33 = *(void *)(a1 + 88);
      if (!v33) {
        goto LABEL_48;
      }
      uint64_t v34 = a1 + 88;
      do
      {
        int v35 = *(_DWORD *)(v33 + 32);
        BOOL v36 = v35 < a5;
        if (v35 >= a5) {
          __int16 v37 = (uint64_t *)v33;
        }
        else {
          __int16 v37 = (uint64_t *)(v33 + 8);
        }
        if (!v36) {
          uint64_t v34 = v33;
        }
        uint64_t v33 = *v37;
      }

      while (*v37);
      if (v34 == v32 || *(_DWORD *)(v34 + 32) > a5) {
LABEL_48:
      }
        uint64_t v34 = a1 + 88;
      uint64_t v64 = v34;
      unint64_t v38 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v39 = *a2;
      uint64_t v40 = (__n128 *)(a1 + 64);
      do
      {
        int v41 = *(_DWORD *)(v38 + 32);
        BOOL v42 = v41 < v39;
        if (v41 >= v39) {
          uint64_t v43 = (unint64_t *)v38;
        }
        else {
          uint64_t v43 = (unint64_t *)(v38 + 8);
        }
        if (!v42) {
          uint64_t v40 = (__n128 *)v38;
        }
        unint64_t v38 = *v43;
      }

      while (*v43);
      if (v40 == v15 || v39 < (signed __int32)v40[2].n128_u32[0])
      {
LABEL_59:
        int v63 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_1018787B0);
        }
        char v44 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v45 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            __int16 v46 = v71;
          }
          else {
            __int16 v46 = *(_BYTE **)v71;
          }
          *(_DWORD *)uint64_t buf = 136315650;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&_BYTE buf[18] = 2080;
          *(void *)&buf[20] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_1018787B0);
          }
          __int16 v47 = (void *)(a1 + 8);
          uint64_t v48 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v62 >= 0) {
            uint64_t v49 = __p;
          }
          else {
            uint64_t v49 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v71 = 136315650;
          *(void *)&v71[4] = v47;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v49;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v60);
          uint64_t v51 = v50;
          if (v62 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>: :notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, N otificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v51);
          if (v51 != buf) {
            free(v51);
          }
        }

        goto LABEL_83;
      }

      int v63 = v40;
      if (v34 == v32) {
        goto LABEL_60;
      }
      uint64_t v54 = v40[3].n128_i64[0];
      uint64_t v52 = v40 + 3;
      std::string::size_type v53 = (__n128 *)v54;
      if (!v54) {
        goto LABEL_60;
      }
      int v55 = *(_DWORD *)(v34 + 32);
      BOOL v56 = v52;
      do
      {
        int v57 = v53[1].n128_i32[3];
        BOOL v58 = v57 < v55;
        if (v57 >= v55) {
          __int16 v59 = v53;
        }
        else {
          __int16 v59 = (__n128 *)&v53->n128_i8[8];
        }
        if (!v58) {
          BOOL v56 = v53;
        }
        std::string::size_type v53 = (__n128 *)v59->n128_u64[0];
      }

      while (v59->n128_u64[0]);
      sub_100C099B4((_BYTE *)a1, (uint64_t)&v64, (uint64_t)&v63, v31);
    }

void sub_100C0921C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100C09268(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018787B0);
    }
    int v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136315138;
      __int16 v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018787B0);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      char v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::lis tClients() [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Ty pe::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018787B0);
    }
    __int16 v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315394;
      __int16 v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018787B0);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      unint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::lis tClients() [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Ty pe::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    BOOL v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      unint64_t v11 = (void *)(a1 + 8);
      do
      {
        __int16 v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_1018787B0);
            }
            int v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              __int128 v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)uint64_t buf = 136315650;
              __int16 v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018787B0);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationDa ta>::listClients() [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAuto pauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                __int16 v12 = v18;
              }

              while (!v19);
            }

            __int16 v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            BOOL v10 = v26;
          }

          while (!v19);
        }

        BOOL v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100C09814(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100C098A0(a1);
  operator delete(v1);
}

id sub_100C09828(uint64_t a1, int a2, void *a3)
{
  id result = sub_100C09AA0(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100C09874(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100C098A0(uint64_t a1)
{
  *(void *)a1 = &off_1018788C0;
  int v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *int v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

void sub_100C09900(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100C0992C(uint64_t a1)
{
  int v2 = operator new(3uLL);
  *(_WORD *)int v2 = *(_WORD *)a1;
  v2[2] = *(_BYTE *)(a1 + 2);
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  int v6 = sub_100C09A90;
  __int16 v7 = &unk_10181D3D0;
  int v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

_BYTE *sub_100C099B4(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    __int16 v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100C09AA0(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    unint64_t v11 = (uint64_t **)(*(void *)a3 + 40LL);
    __int128 v14 = (int *)(*(void *)a2 + 32LL);
    __int16 v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_100C09A90(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_100C09AA0(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100C09B18(a1);
  }
  objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_100C09EA0(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100C09B18(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_100C0A24C((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x800000010135E820LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    int v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x800000010135E820LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  __int16 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLAutopauseProvider_Type::NotificationData, Call bacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100C09EA0(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010135E820LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    int v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010135E820LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018788D8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  __int16 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLAutopauseProvider_Type::NotificationData, Call bacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100C0A24C(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D42B0))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)3) {
      sub_1012658B8();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_100C0A2C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101878908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0A2D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101878908;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

CLCppContainer *sub_100C0A300(uint64_t a1)
{
  id v2 = operator new(3uLL);
  *(_WORD *)id v2 = *(_WORD *)a1;
  v2[2] = *(_BYTE *)(a1 + 2);
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  int v6 = sub_100C0A75C;
  __int16 v7 = &unk_10181D3D0;
  uint64_t v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100C0A388(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v51 = v9;
        id v13 = sub_100C09AA0(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        unint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          unint64_t v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100C099B4(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              double v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  double v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v51 = v29;
              uint64_t v34 = v29[6];
              unint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                int v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    int v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      BOOL v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      BOOL v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      unint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  uint64_t v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      unint64_t v14 = v43;
                      uint64_t v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      unint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      int v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018787B0);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)uint64_t buf = 136446466;
                int v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_1018787B0);
                }
                int v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                std::string::size_type v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                uint64_t v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::i nvokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLAutopauseProvider_T ype::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

void sub_100C0A75C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

void sub_100C0A76C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      _DWORD v1[2] = xmmword_10134FCE8;
      v1[3] = unk_10134FCF8;
      v1[4] = xmmword_10134FD08;
      v1[0] = xmmword_10134FCC8;
      v1[1] = unk_10134FCD8;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100C0A840(_Unwind_Exception *a1)
{
}

uint64_t sub_100C0A858(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = &off_1018337C8;
  uint64_t v6 = a1 + 32;
  sub_101204164((unsigned __int8 *)(a1 + 8), "NatalimetryMaxDelay", &qword_1012E6B60, 0);
  *(void *)a1 = off_101878958;
  sub_1002B7870(v6, a3);
  sub_100DE96B0(a1 + 104, a3);
  *(void *)(a1 + 176) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 184) = v7;
  if (v7)
  {
    int v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  *(_OWORD *)(a1 + 192) = 0u;
  *(_BYTE *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + std::ostream::sentry::~sentry(v2 - 224) = 0u;
  int v10 = operator new(0x20uLL);
  v10[2] = 0LL;
  uint64_t v10[3] = &off_10183E4F0;
  *int v10 = off_1018789D8;
  v10[1] = 0LL;
  *(void *)(a1 + 2memset(v19, 0, 48) = v10 + 3;
  *(void *)(a1 + 256) = v10;
  BOOL v11 = (char *)operator new(0x58uLL);
  *((void *)v11 + 2) = 0LL;
  *(void *)BOOL v11 = off_101878A28;
  *((void *)v11 + 1) = 0LL;
  *((void *)v11 + 3) = &off_101880E80;
  *((_OWORD *)v11 + 2) = 0u;
  *((_OWORD *)v11 + 3) = 0u;
  *((void *)v11 + 8) = 0LL;
  *(_OWORD *)(v11 + 72) = xmmword_10134FE70;
  *(void *)(a1 + 264) = v11 + 24;
  *(void *)(a1 + 272) = v11;
  uint64_t v12 = operator new(0x20uLL);
  void v12[2] = 0LL;
  *uint64_t v12 = off_101878A78;
  v12[1] = 0LL;
  void v12[3] = &off_10184E788;
  *(void *)(a1 + 28sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v12 + 3;
  *(void *)(a1 + 288) = v12;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = a1 + 296;
  return a1;
}

void sub_100C0AA00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  do
  {
    v14 -= 16LL;
    sub_10000AE14(v14);
  }

  while ((void *)v14 != v13 + 7);
  sub_100210578(v13);
  sub_10000AE14(v12);
  v11[13] = off_10182F2C0;
  sub_100210A00(v11 + 15);
  _DWORD v11[4] = off_10182F2C0;
  sub_100210A00(v11 + 6);
  _Unwind_Resume(a1);
}

uint64_t sub_100C0AA90(uint64_t a1, double *a2)
{
  uint64_t result = sub_1003DA5EC(*(void ***)(a1 + 176), *a2);
  if (*((_DWORD *)a2 + 2))
  {
    double v5 = sub_100355FA8((void *)(a1 + 192), a2);
    (*(void (**)(void, double *, double))(**(void **)(*(void *)(a1 + 176) + 48LL) + 32LL))( *(void *)(*(void *)(a1 + 176) + 48LL),  a2,  v5);
    uint64_t result = (*(uint64_t (**)(void, uint64_t *, double))(**(void **)(*(void *)(a1 + 176) + 48LL) + 24LL))( *(void *)(*(void *)(a1 + 176) + 48LL),  &v9,  *a2);
    if ((_DWORD)result)
    {
      uint64_t v6 = 0LL;
      double v7 = *a2;
      uint64_t v8 = *(void *)(a1 + 176);
      do
      {
        uint64_t result = *(void *)(a1 + 248 + v6);
        if (result) {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, double))(*(void *)result + 24LL))(result, v8, v7);
        }
        v6 += 16LL;
      }

      while (v6 != 64);
    }

    if (!*(_BYTE *)(a1 + 240)) {
      return sub_100C0AB9C(a1);
    }
  }

  return result;
}

uint64_t sub_100C0AB9C(uint64_t result)
{
  if (*(void *)(result + 232))
  {
    uint64_t v1 = result;
    uint64_t v2 = result + 192;
    do
    {
      if ((*(unsigned int (**)(void, double))(**(void **)(*(void *)(v1 + 176) + 48LL) + 48LL))( *(void *)(*(void *)(v1 + 176) + 48LL),  v3)
        && (uint64_t v4 = (*(uint64_t (**)(void, _OWORD *, double))(**(void **)(*(void *)(v1 + 176) + 48LL) + 24LL))( *(void *)(*(void *)(v1 + 176) + 48LL),  v14,  v3),  (_DWORD)v4))
      {
        uint64_t result = sub_100C0AEF8(v3, v4, *(void *)(v1 + 176));
        if ((result & 1) == 0)
        {
          unint64_t v5 = *(void *)(v1 + 232) + *(void *)(v1 + 224) - 1LL;
          if (vabdd_f64( *(double *)(*(void *)(*(void *)(v1 + 200) + ((v5 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v5 & 0x1FF)),  v3) <= *(double *)(v1 + 16)) {
            return result;
          }
        }

        sub_1003DB0E8(*(void *)(v1 + 176), v3);
        void v12[12] = v14[12];
        v12[13] = v14[13];
        uint64_t v13 = v15;
        _WORD v12[8] = v14[8];
        v12[9] = v14[9];
        v12[11] = v14[11];
        v12[10] = v14[10];
        v12[4] = v14[4];
        void v12[5] = v14[5];
        v12[7] = v14[7];
        v12[6] = v14[6];
        v12[0] = v14[0];
        v12[1] = v14[1];
        void v12[3] = v14[3];
        void v12[2] = v14[2];
        sub_100C0AFDC(v1, (uint64_t)v12, *(void *)(v1 + 176));
      }

      else
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_1018789A8);
        }
        uint64_t v6 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#Warning Popping out an activity since there's no activity associated with current time.  This shouldn't happen",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_1018789A8);
          }
          v10[0] = 0;
          LODWORD(v9) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "#Warning Popping out an activity since there's no activity associated with current time.  This shouldn't happen",  v10,  v9);
          uint64_t v8 = (uint8_t *)v7;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLFitnessControllerYouth::processQueue()", "%s\n", v7);
          if (v8 != buf) {
            free(v8);
          }
        }
      }

      *(int64x2_t *)(v1 + std::ostream::sentry::~sentry(v2 - 224) = vaddq_s64(*(int64x2_t *)(v1 + 224), (int64x2_t)xmmword_1012CE4D0);
      uint64_t result = sub_1002109A4(v2, 1);
    }

    while (*(void *)(v1 + 232));
  }

  return result;
}

uint64_t sub_100C0AEF8(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 48) + 48LL))(*(void *)(a3 + 48));
  if ((_DWORD)result)
  {
    uint64_t result = (*(uint64_t (**)(void, _DWORD *, double))(**(void **)(a3 + 48) + 24LL))( *(void *)(a3 + 48),  v8,  a1);
    if ((_DWORD)result)
    {
      if (v9
        || (uint64_t result = (*(uint64_t (**)(void, double))(**(void **)(a3 + 32) + 48LL))( *(void *)(a3 + 32),  a1),  (_DWORD)result))
      {
        BOOL v6 = (CLMotionActivity::isTypeCycling(v8[2]) & (v9 != 0)) == 0;
        uint64_t v7 = 40LL;
        if (!v6) {
          uint64_t v7 = 16LL;
        }
        return (*(uint64_t (**)(void, double))(**(void **)(a3 + v7) + 48LL))(*(void *)(a3 + v7), a1);
      }
    }
  }

  return result;
}

void sub_100C0AFDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  unsigned int v7 = *(_DWORD *)(a2 + 136);
  uint64_t v8 = v7;
  do
  {
    uint64_t v9 = *(void *)(a1 + 248 + v6);
    if (v9)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16LL))(v9, v8, a3);
      *(_DWORD *)(a2 + 136) = v8;
    }

    v6 += 16LL;
  }

  while (v6 != 64);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_1018789A8);
  }
  int v10 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a2 + 88);
    int v12 = *(_DWORD *)(a2 + 136);
    *(_DWORD *)uint64_t buf = 134349568;
    uint64_t v24 = v11;
    __int16 v25 = 1026;
    unsigned int v26 = v7;
    __int16 v27 = 1026;
    int v28 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "startTime, %{public}.3f, rawActivity, %{public}d, overridenActivity, %{public}d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_1018789A8);
    }
    uint64_t v13 = *(void *)(a2 + 88);
    int v14 = *(_DWORD *)(a2 + 136);
    int v17 = 134349568;
    uint64_t v18 = v13;
    __int16 v19 = 1026;
    unsigned int v20 = v7;
    __int16 v21 = 1026;
    int v22 = v14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "startTime, %{public}.3f, rawActivity, %{public}d, overridenActivity, %{public}d",  &v17,  24);
    int v16 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFitnessControllerYouth::processEpoch(CLMotionStateMediator_Type::MediatedMotionActivity, const CLNatalieModelInput &)",  "%s\n",  v15);
    if (v16 != buf) {
      free(v16);
    }
  }

  sub_100B1D70C(a1 + 32, a2);
  sub_100B1D70C(a1 + 104, a2);
}

void sub_100C0B228(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 352))
  {
    sub_1000F0D38(*(void **)(a1 + 312));
    return;
  }

  id v3 = +[CMWorkout CMWorkoutTypeFromCLMotionActivityType:]( &OBJC_CLASS___CMWorkout,  "CMWorkoutTypeFromCLMotionActivityType:",  *(unsigned int *)(a2 + 152));
  if (v3 != (id)15 && v3 != (id)17)
  {
    unint64_t v5 = *(void **)(a1 + 312);
    if (!*v5)
    {
      if (v3 == (id)4)
      {
        uint64_t v6 = operator new(0x20uLL);
        v6[1] = 0LL;
        _DWORD v6[2] = 0LL;
        *uint64_t v6 = off_101878AC8;
        *((void *)&v12 + 1) = v6;
        void v6[3] = &off_10186F1D8;
        *(void *)&__int128 v12 = v6 + 3;
        sub_10005F550((uint64_t)v5, &v12);
        unsigned int v7 = (std::__shared_weak_count *)*((void *)&v12 + 1);
        if (!*((void *)&v12 + 1)) {
          return;
        }
        uint64_t v8 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
        do
          unint64_t v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
      }

      else
      {
        int v10 = operator new(0x20uLL);
        v10[1] = 0LL;
        v10[2] = 0LL;
        *int v10 = off_101878B18;
        *((void *)&v12 + 1) = v10;
        uint64_t v10[3] = &off_101831D00;
        *(void *)&__int128 v12 = v10 + 3;
        sub_10005F550((uint64_t)v5, &v12);
        unsigned int v7 = (std::__shared_weak_count *)*((void *)&v12 + 1);
        if (!*((void *)&v12 + 1)) {
          return;
        }
        uint64_t v11 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
        do
          unint64_t v9 = __ldaxr(v11);
        while (__stlxr(v9 - 1, v11));
      }

      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

uint64_t sub_100C0B374(uint64_t result)
{
  *(_BYTE *)(result + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1;
  return result;
}

uint64_t sub_100C0B380(uint64_t result)
{
  *(_BYTE *)(result + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  return result;
}

void *sub_100C0B388(void *a1)
{
  *a1 = off_101878958;
  for (uint64_t i = 37LL; i != 29; i -= 2LL)
    sub_10000AE14((uint64_t)&a1[i]);
  sub_100210578(a1 + 24);
  sub_10000AE14((uint64_t)(a1 + 22));
  a1[13] = off_10182F2C0;
  sub_100210A00(a1 + 15);
  a1[4] = off_10182F2C0;
  sub_100210A00(a1 + 6);
  return a1;
}

void sub_100C0B400(void *a1)
{
  *a1 = off_101878958;
  for (uint64_t i = 37LL; i != 29; i -= 2LL)
    sub_10000AE14((uint64_t)&a1[i]);
  sub_100210578(a1 + 24);
  sub_10000AE14((uint64_t)(a1 + 22));
  a1[13] = off_10182F2C0;
  sub_100210A00(a1 + 15);
  a1[4] = off_10182F2C0;
  sub_100210A00(a1 + 6);
  operator delete(a1);
}

void sub_100C0B478(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_100C0B4A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018789D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0B4B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018789D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100C0B4DC(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100C0B4EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101878A28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0B500(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101878A28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100C0B524(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100C0B534(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101878A78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0B548(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101878A78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100C0B56C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100C0B57C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101878AC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0B590(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101878AC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100C0B5B4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100C0B5C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101878B18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C0B5D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101878B18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100C0B5FC(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_100C0B60C(uint64_t a1)
{
  return a1;
}

const char *sub_100C0B634(unsigned int a1)
{
  if (a1 > 0xA) {
    return "?unknown?";
  }
  else {
    return off_101878BB8[a1];
  }
}

int8x8_t sub_100C0B658(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = *(_OWORD *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  __int128 v5 = *(_OWORD *)(a1 + 32);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + memset(v19, 0, 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 64) = v6;
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 128);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 1sub_100231C10(v1 + 28) = v9;
  *(_OWORD *)(a2 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v7;
  *(_OWORD *)(a2 + 96) = v8;
  __int128 v10 = *(_OWORD *)(a1 + 144);
  __int128 v11 = *(_OWORD *)(a1 + 160);
  __int128 v12 = *(_OWORD *)(a1 + 176);
  *(_DWORD *)(a2 + 192) = *(_DWORD *)(a1 + 192);
  *(_OWORD *)(a2 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v11;
  *(_OWORD *)(a2 + 176) = v12;
  *(_OWORD *)(a2 + 144) = v10;
  sub_100DD8CEC((unsigned __int16 *)a1, a2);
  *(int8x16_t *)(a2 + 12) = vrev32q_s8(*(int8x16_t *)(a1 + 12));
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 28));
  *(int8x8_t *)(a2 + sub_100231C10(v1 + 28) = result;
  *(_DWORD *)(a2 + 36) = bswap32(*(_DWORD *)(a1 + 36));
  unint64_t v14 = bswap64(*(void *)(a1 + 40));
  unint64_t v15 = bswap64(*(void *)(a1 + 188));
  *(_DWORD *)(a2 + 176) = bswap32(*(_DWORD *)(a1 + 176));
  *(void *)(a2 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v14;
  *(void *)(a2 + 188) = v15;
  return result;
}

unsigned __int16 *sub_100C0B704(unsigned __int16 *result, uint64_t a2)
{
  *(_WORD *)a2 = bswap32(*result) >> 16;
  *(_WORD *)(a2 + 2) = bswap32(result[1]) >> 16;
  *(_DWORD *)(a2 + 4) = bswap32(*((_DWORD *)result + 1));
  *(_WORD *)(a2 + 8) = bswap32(result[4]) >> 16;
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = bswap32(result[5]) >> 16;
  *(_DWORD *)(a2 + 12) = *((_DWORD *)result + 3);
  return result;
}

uint64_t sub_100C0B75C@<X0>(unsigned __int16 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v18, (uint64_t)"mcc, ", 5LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", mnc, ", 7LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", lac, ", 7LL);
  __int128 v9 = (void *)std::ostream::operator<<(v8, *((unsigned int *)a1 + 1));
  __int128 v10 = sub_10000CF44(v9, (uint64_t)", subY, ", 8LL);
  __int128 v11 = (void *)std::ostream::operator<<(v10, a1[4]);
  __int128 v12 = sub_10000CF44(v11, (uint64_t)", subX, ", 8LL);
  uint64_t v13 = (void *)std::ostream::operator<<(v12, a1[5]);
  unint64_t v14 = sub_10000CF44(v13, (uint64_t)", hUnc, ", 8LL);
  std::ostream::operator<<(v14, *((unsigned __int8 *)a1 + 12));
  std::stringbuf::str(a2, &v19);
  *(void *)((char *)v17
  uint64_t v18 = v15;
  std::streambuf::~streambuf(&v19);
  return std::ios::~ios(&v20);
}

void sub_100C0B89C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

int8x8_t sub_100C0B8B0(unsigned __int16 *a1, uint64_t a2)
{
  *(_WORD *)a2 = bswap32(*a1) >> 16;
  *(_WORD *)(a2 + 2) = bswap32(a1[1]) >> 16;
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 2));
  *(int8x8_t *)(a2 + 4) = result;
  return result;
}

uint64_t sub_100C0B8E0@<X0>(unsigned __int16 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v14, (uint64_t)"mcc, ", 5LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", mnc, ", 7LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", lac, ", 7LL);
  __int128 v9 = (void *)std::ostream::operator<<(v8, *((unsigned int *)a1 + 1));
  __int128 v10 = sub_10000CF44(v9, (uint64_t)", offset, ", 10LL);
  std::ostream::operator<<(v10, *((unsigned int *)a1 + 2));
  std::stringbuf::str(a2, &v15);
  *(void *)((char *)v13
  uint64_t v14 = v11;
  std::streambuf::~streambuf(&v15);
  return std::ios::~ios(&v16);
}

void sub_100C0B9F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C0BA04(_DWORD *a1, _DWORD *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  return 1LL;
}

int8x8_t sub_100C0BA1C(int8x8_t *a1, int8x8_t *a2)
{
  int8x8_t result = vrev32_s8(*a1);
  *a2 = result;
  a2[1].i16[0] = bswap32(a1[1].u16[0]) >> 16;
  a2[1].i16[1] = bswap32(a1[1].u16[1]) >> 16;
  a2[1].i16[2] = a1[1].i16[2];
  return result;
}

uint64_t sub_100C0BA54@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v16, (uint64_t)", lac, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", ci, ", 6LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", subY, ", 8LL);
  __int128 v9 = (void *)std::ostream::operator<<(v8, *((unsigned __int16 *)a1 + 4));
  __int128 v10 = sub_10000CF44(v9, (uint64_t)", subX, ", 8LL);
  uint64_t v11 = (void *)std::ostream::operator<<(v10, *((unsigned __int16 *)a1 + 5));
  __int128 v12 = sub_10000CF44(v11, (uint64_t)", hUnc, ", 8LL);
  std::ostream::operator<<(v12, *((unsigned __int8 *)a1 + 12));
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v13;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_100C0BB7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

int8x8_t sub_100C0BB90(int8x8_t *a1, int8x8_t *a2)
{
  int8x8_t result = vrev32_s8(*a1);
  *a2 = result;
  a2[1].i32[0] = bswap32(a1[1].u32[0]);
  return result;
}

uint64_t sub_100C0BBAC@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v12, (uint64_t)", lac, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", ci, ", 6LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", offset, ", 10LL);
  std::ostream::operator<<(v8, a1[2]);
  std::stringbuf::str(a2, &v13);
  *(void *)((char *)v11
  uint64_t v12 = v9;
  std::streambuf::~streambuf(&v13);
  return std::ios::~ios(&v14);
}

void sub_100C0BCA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C0BCB8(void *a1, void *a2)
{
  *a1 = *a2;
  return 1LL;
}

uint64_t sub_100C0BCC8@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v16, (uint64_t)", tac, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", ci, ", 6LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", subY, ", 8LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *((unsigned __int16 *)a1 + 4));
  __int128 v10 = sub_10000CF44(v9, (uint64_t)", subX, ", 8LL);
  uint64_t v11 = (void *)std::ostream::operator<<(v10, *((unsigned __int16 *)a1 + 5));
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)", hUnc, ", 8LL);
  std::ostream::operator<<(v12, *((unsigned __int8 *)a1 + 12));
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v13;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_100C0BDF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C0BE04@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v12, (uint64_t)", tac, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", ci, ", 6LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", offset, ", 10LL);
  std::ostream::operator<<(v8, a1[2]);
  std::stringbuf::str(a2, &v13);
  *(void *)((char *)v11
  uint64_t v12 = v9;
  std::streambuf::~streambuf(&v13);
  return std::ios::~ios(&v14);
}

void sub_100C0BEFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C0BF10@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v16, (uint64_t)", sid, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", bsid, ", 8LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", subY, ", 8LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *((unsigned __int16 *)a1 + 4));
  __int128 v10 = sub_10000CF44(v9, (uint64_t)", subX, ", 8LL);
  uint64_t v11 = (void *)std::ostream::operator<<(v10, *((unsigned __int16 *)a1 + 5));
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)", hUnc, ", 8LL);
  std::ostream::operator<<(v12, *((unsigned __int8 *)a1 + 12));
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v13;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_100C0C038(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C0C04C@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v12, (uint64_t)", sid, ", 7LL);
  __int128 v5 = (void *)std::ostream::operator<<(v4, *a1);
  __int128 v6 = sub_10000CF44(v5, (uint64_t)", bsid, ", 8LL);
  __int128 v7 = (void *)std::ostream::operator<<(v6, a1[1]);
  __int128 v8 = sub_10000CF44(v7, (uint64_t)", offset, ", 10LL);
  std::ostream::operator<<(v8, a1[2]);
  std::stringbuf::str(a2, &v13);
  *(void *)((char *)v11
  uint64_t v12 = v9;
  std::streambuf::~streambuf(&v13);
  return std::ios::~ios(&v14);
}

void sub_100C0C144(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

int8x8_t sub_100C0C158(uint64_t a1, uint64_t a2)
{
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 12));
  *(int8x8_t *)(a2 + 12) = result;
  return result;
}

unsigned __int16 *sub_100C0C188(unsigned __int16 *result, uint64_t a2)
{
  *(_WORD *)a2 = bswap32(*result) >> 16;
  *(_WORD *)(a2 + 2) = bswap32(result[1]) >> 16;
  *(_DWORD *)(a2 + 4) = bswap32(*((_DWORD *)result + 1));
  *(_WORD *)(a2 + 8) = result[4];
  int v2 = *(_WORD *)(a2 + 10) & 0xFFFE | result[5] & 1;
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_WORD *)(a2 + 10) & 0xFFFE | result[5] & 1;
  unsigned int v3 = v2 & 0xFFFFFFFD | (2 * ((result[5] >> 1) & 1));
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v3;
  unsigned int v4 = v3 & 0xFFFFFFFB | (4 * ((result[5] >> 2) & 1));
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v4;
  unsigned int v5 = v4 & 0xFFFFFFF7 | (8 * ((result[5] >> 3) & 1));
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v5;
  unsigned int v6 = v5 & 0xFFFFFFEF | (16 * ((result[5] >> 4) & 1));
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v6;
  unsigned int v7 = v6 & 0xFFFFFFDF | (32 * ((result[5] >> 5) & 1));
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v7;
  *(_WORD *)(a2 + 1sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = result[5] & 0xFFC0 | v7 & 0x3F;
  return result;
}

unsigned int *sub_100C0C22C(unsigned int *result, _DWORD *a2)
{
  *a2 = bswap32(*result);
  return result;
}

int8x8_t sub_100C0C23C(uint64_t a1, uint64_t a2)
{
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 12));
  *(int8x8_t *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = bswap32(*(_DWORD *)(a1 + 20));
  return result;
}

int8x8_t sub_100C0C278(uint64_t a1, uint64_t a2)
{
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 12));
  *(int8x8_t *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = bswap32(*(_DWORD *)(a1 + 20));
  *(_WORD *)(a2 + 24) = bswap32(*(unsigned __int16 *)(a1 + 24)) >> 16;
  *(_WORD *)(a2 + 26) = bswap32(*(unsigned __int16 *)(a1 + 26)) >> 16;
  return result;
}

void sub_100C0C2D4()
{
  unsigned __int8 v0 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    uint64_t v1 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v2 = __ldaxr(v1);
    while (__stlxr(v2 - 1, v1));
    if (!v2)
    {
      ((void (*)(std::__shared_weak_count *))v0->__on_zero_shared)(v0);
      std::__shared_weak_count::__release_weak(v0);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  unsigned int v3 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 134349056;
    *(void *)((char *)buf + 4) = qword_10198FCF0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "TileFile, fTileDownloadCoolOffPeriod, %{public}.1lf",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v21 = 134349056;
    uint64_t v22 = qword_10198FCF0;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, fTileDownloadCoolOffPeriod, %{public}.1lf",  &v21,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLTileFile::initStaticGlobals()", "%s\n", v16);
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)&buf[0], "TileDownloadExtendedCoolOffPeriod", &qword_10198FCF8);
  unsigned int v4 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    unsigned int v5 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  unsigned int v7 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 134349056;
    *(void *)((char *)buf + 4) = qword_10198FCF8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TileFile, fTileDownloadExtendedCoolOffPeriod, %{public}.1lf",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v21 = 134349056;
    uint64_t v22 = qword_10198FCF8;
    LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    std::stringbuf v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, fTileDownloadExtendedCoolOffPeriod, %{public}.1lf",  &v21,  v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLTileFile::initStaticGlobals()", "%s\n", v17);
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)&buf[0], "TileForceExpirationPeriod", &qword_10198FD00);
  __int128 v8 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    uint64_t v9 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v11 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 134349056;
    *(void *)((char *)buf + 4) = qword_10198FD00;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "TileFile, fTileForceExpirationPeriod, %{public}.1lf",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v21 = 134349056;
    uint64_t v22 = qword_10198FD00;
    LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, fTileForceExpirationPeriod, %{public}.1lf",  &v21,  v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLTileFile::initStaticGlobals()", "%s\n", v18);
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)&buf[0], "TileMinExpirationPeriod", &qword_10198FD08);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    std::stringbuf v13 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  std::stringbuf v15 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 134349056;
    *(void *)((char *)buf + 4) = qword_10198FD08;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "TileFile, fTileMinExpirationPeriod, %{public}.1lf",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v21 = 134349056;
    uint64_t v22 = qword_10198FD08;
    LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    std::stringbuf v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, fTileMinExpirationPeriod, %{public}.1lf",  &v21,  v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLTileFile::initStaticGlobals()", "%s\n", v19);
  }

void sub_100C0C9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100C0CA10(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)a1 = off_101878C20;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(_BYTE *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a3;
  sub_1008ACE9C(a1 + 48, a2);
  *(void *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(_OWORD *)(a1 + 208) = 0u;
  *(_WORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 114) = 0;
  *(void *)(a1 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 1sub_100231C10(v1 + 28) = 0;
  *(CFAbsoluteTime *)(a1 + 136) = Current;
  *(_WORD *)(a1 + 144) = 1;
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0LL;
  *(_DWORD *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = -1;
  *(_WORD *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 68;
  *(_OWORD *)(a1 + std::ostream::sentry::~sentry(v2 - 224) = 0u;
  sub_100D2D9A4(a1 + 248);
  *(_DWORD *)(a1 + 288) = 0;
  pthread_once(&stru_10198FD10, sub_100C0C2D4);
  return a1;
}

void sub_100C0CADC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100C0CB28(uint64_t a1)
{
  *(void *)a1 = off_101878C20;
  return a1;
}

uint64_t sub_100C0CB8C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
    *(void *)(a1 + 104) = 0LL;
  }

  *(_BYTE *)(a1 + 168) = 0;
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(_BYTE *)(a1 + 32) = 0;
  *(void *)(a1 + 192) = 0LL;
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

void sub_100C0CC0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

double sub_100C0CC24(uint64_t a1, double a2)
{
  return vabdd_f64(a2, *(double *)(a1 + 176));
}

double sub_100C0CC30(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  BOOL v5 = sub_100C0CCC8(a1);
  uint64_t v6 = 160LL;
  if (v5) {
    uint64_t v6 = 232LL;
  }
  double v7 = *(double *)(a1 + v6);
  (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  return a2 - v7;
}

void sub_100C0CCB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL sub_100C0CCC8(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 32);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return (_DWORD)v1 == 0;
}

uint64_t sub_100C0CD18(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 168);
}

double sub_100C0CD20(uint64_t a1)
{
  return *(double *)(a1 + 160);
}

double sub_100C0CD28(uint64_t a1)
{
  return *(double *)(a1 + 232);
}

BOOL sub_100C0CD30(uint64_t a1, int a2, double a3, float a4)
{
  int v4 = *(_DWORD *)(a1 + 200);
  if (v4 < 1) {
    return 0LL;
  }
  double v7 = vabdd_f64(a3, *(double *)(a1 + 176));
  double v8 = (double)v4;
  if (a2)
  {
    double v9 = a4 * v8;
    else {
      double v10 = *(double *)&qword_10198FD08;
    }
  }

  else if (*(double *)&qword_10198FD08 < v8)
  {
    double v10 = (double)v4;
  }

  else
  {
    double v10 = *(double *)&qword_10198FD08;
  }

  BOOL v11 = v7 >= v10;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v12 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    int v13 = *(_DWORD *)(a1 + 200);
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
    unint64_t v14 = (SBYTE1(v29) & 0x80u) == 0 ? &__p : (void **)__p;
    *(_DWORD *)uint64_t buf = 67241475;
    BOOL v35 = v7 >= v10;
    __int16 v36 = 1026;
    int v37 = a2;
    __int16 v38 = 1026;
    int v39 = v13;
    __int16 v40 = 2050;
    double v41 = v10;
    __int16 v42 = 2050;
    double v43 = v7;
    __int16 v44 = 2081;
    int v45 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "@TileQueue, hasDataExpired, %{public}d, isLargeConnectivity, %{public}d, fExpirationAge, %{public}d, dataExpiratio nPeriod, %{public}.1lf, dataAge, %{public}.1lf, tile, %{private}s",  buf,  0x32u);
    if (SBYTE1(v29) < 0) {
      operator delete(__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v16 = qword_101934858;
    int v17 = *(_DWORD *)(a1 + 200);
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v21, a1);
    if (v22 >= 0) {
      uint64_t v18 = v21;
    }
    else {
      uint64_t v18 = (void **)v21[0];
    }
    LODWORD(__p) = 67241475;
    HIDWORD(__p) = v7 >= v10;
    __int16 v24 = 1026;
    int v25 = a2;
    __int16 v26 = 1026;
    int v27 = v17;
    __int16 v28 = 2050;
    double v29 = v10;
    __int16 v30 = 2050;
    double v31 = v7;
    __int16 v32 = 2081;
    uint64_t v33 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "@TileQueue, hasDataExpired, %{public}d, isLargeConnectivity, %{public}d, fExpirationAge, %{public}d, dataExpiratio nPeriod, %{public}.1lf, dataAge, %{public}.1lf, tile, %{private}s",  &__p,  50);
    uint64_t v20 = v19;
    if (v22 < 0) {
      operator delete(v21[0]);
    }
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileFile::hasDataExpired(CFAbsoluteTime, BOOL, float)", "%s\n", v20);
  }

  return v11;
}

double sub_100C0D048(uint64_t a1, uint64_t a2)
{
  double result = *(double *)(a2 + 176);
  *(double *)(a1 + 176) = result;
  *(_DWORD *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *(_DWORD *)(a2 + 200);
  return result;
}

BOOL sub_100C0D05C(uint64_t a1, int a2, float a3, double a4)
{
  double v8 = *(double *)(a1 + 160);
  double v9 = *(double *)&qword_10198FCF0;
  BOOL v10 = sub_100BD82F0(*(void *)(a1 + 96), a4, *(double *)&qword_10198FCF0);
  double v11 = *(double *)&qword_10198FCF8;
  double v12 = vabdd_f64(a4, v8);
  if (sub_100C0DB30(a1))
  {
    int v13 = "InProgress";
LABEL_48:
    std::string::assign(&v60, v13);
    LODWORD(v16) = 0;
    BOOL v21 = 0LL;
    goto LABEL_49;
  }

  if (*(_BYTE *)(a1 + 168))
  {
LABEL_4:
    BOOL v14 = sub_100C0CCC8(a1);
    if (v12 >= v11 && v14)
    {
      BOOL v16 = sub_100C0CD30(a1, a2, a4, a3);
      if (v16)
      {
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        int v17 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
          uint64_t v18 = v64 >= 0 ? __p : *(_BYTE **)__p;
          double v19 = vabdd_f64(a4, *(double *)(a1 + 176));
          int v20 = *(_DWORD *)(a1 + 200);
          *(_DWORD *)uint64_t buf = 136381187;
          *(void *)&uint8_t buf[4] = v18;
          __int16 v87 = 2050;
          double v88 = v19;
          __int16 v89 = 1024;
          LODWORD(v9sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, expirationAge, %d",  buf,  0x1Cu);
          if (SHIBYTE(v64) < 0) {
            operator delete(*(void **)__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          uint64_t v49 = qword_101934858;
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v82, a1);
          if (v85 >= 0) {
            uint64_t v50 = v82;
          }
          else {
            uint64_t v50 = *(_BYTE **)v82;
          }
          double v51 = vabdd_f64(a4, *(double *)(a1 + 176));
          int v52 = *(_DWORD *)(a1 + 200);
          *(_DWORD *)std::string __p = 136381187;
          *(void *)&__p[4] = v50;
          __int16 v62 = 2050;
          double v63 = v51;
          __int16 v64 = 1024;
          LODWORD(v65) = v52;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  2LL,  "TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, expirationAge, %d",  __p,  28);
          __int16 v54 = v53;
          if (v85 < 0) {
            operator delete(*(void **)v82);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::canRequestBasedOnAttempts(BOOL, float, CFAbsoluteTime)",  "%s\n",  v54);
          if (v54 != buf) {
            free(v54);
          }
        }
      }

      std::string::assign(&v60, "Aged");
      BOOL v21 = v16;
      goto LABEL_49;
    }

    if (*(_BYTE *)(a1 + 168) && !sub_100C0CCC8(a1))
    {
      BOOL v21 = v12 >= 1209600.0;
      if (v12 >= 1209600.0)
      {
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        __int16 v26 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
          int v27 = v64 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)uint64_t buf = 136381187;
          *(void *)&uint8_t buf[4] = v27;
          __int16 v87 = 2050;
          double v88 = v12;
          __int16 v89 = 1026;
          LODWORD(v9sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1209600;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "TileFile, canRequestBasedOnAttempts, tile, %{private}s, sinceLastDownload, %{public}.1lf, %{public}d, needs to be refreshed, TileDoesNotExistOnTheServer",  buf,  0x1Cu);
          if (SHIBYTE(v64) < 0) {
            operator delete(*(void **)__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          uint64_t v55 = qword_101934858;
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v82, a1);
          if (v85 >= 0) {
            BOOL v56 = v82;
          }
          else {
            BOOL v56 = *(_BYTE **)v82;
          }
          *(_DWORD *)std::string __p = 136381187;
          *(void *)&__p[4] = v56;
          __int16 v62 = 2050;
          double v63 = v12;
          __int16 v64 = 1026;
          LODWORD(v65) = 1209600;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v55,  2LL,  "TileFile, canRequestBasedOnAttempts, tile, %{private}s, sinceLastDownload, %{public}.1lf, %{public}d, needs to be refreshed, TileDoesNotExistOnTheServer",  __p,  28);
          __int16 v58 = v57;
          if (v85 < 0) {
            operator delete(*(void **)v82);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::canRequestBasedOnAttempts(BOOL, float, CFAbsoluteTime)",  "%s\n",  v58);
          if (v58 != buf) {
            free(v58);
          }
        }
      }

      std::string::assign(&v60, "DoesntExist");
      LODWORD(v16) = 0;
LABEL_49:
      if (*(_BYTE *)(a1 + 240) == 65 && !v21) {
        goto LABEL_58;
      }
      goto LABEL_51;
    }

void sub_100C0DAE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100C0DB30(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  uint64_t v3 = *(void *)(a1 + 104);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3 != 0;
}

uint64_t sub_100C0DB80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (int *)(a1 + 48);
  sub_1008AE164(a1 + 48, v61);
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    double v8 = (const std::string::value_type *)a2;
  }
  else {
    double v8 = *(const std::string::value_type **)a2;
  }
  if (v7 >= 0) {
    std::string::size_type v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v9 = *(void *)(a2 + 8);
  }
  BOOL v10 = std::string::insert((std::string *)v61, 0LL, v8, v9);
  __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0LL;
  v10->__r_.__value_.__l.__cap_ = 0LL;
  v10->__r_.__value_.__r.__words[0] = 0LL;
  if ((v63[9] & 0x80000000) != 0) {
    operator delete(*(void **)v61);
  }
  sub_1008AE67C(v6, a1 + 208, &v54);
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  double v12 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    int v13 = *(_BYTE **)__p;
    if (v60[9] >= 0) {
      int v13 = __p;
    }
    BOOL v14 = (void *)(a1 + 8);
    std::stringbuf v15 = &v54;
    if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf v15 = (std::string *)v54.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int v61 = 136381187;
    *(void *)&v61[4] = v13;
    __int16 v62 = 2082;
    *(void *)double v63 = v14;
    *(_WORD *)&v63[8] = 2082;
    *(void *)&v63[10] = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TileFile, startDownloading, tile, %{private}s, localFilename, %{public}s, tempFilename, %{public}s",  v61,  0x20u);
    if ((v60[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v61, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v36 = qword_101934858;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v51, a1);
    int v37 = (void **)v51[0];
    if (v53 >= 0) {
      int v37 = v51;
    }
    double v38 = (void *)(a1 + 8);
    double v39 = &v54;
    if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v39 = (std::string *)v54.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 136381187;
    *(void *)&__p[4] = v37;
    __int16 v59 = 2082;
    *(void *)std::string v60 = v38;
    *(_WORD *)&v60[8] = 2082;
    *(void *)&v60[10] = v39;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v36,  2LL,  "TileFile, startDownloading, tile, %{private}s, localFilename, %{public}s, tempFilename, %{public}s",  __p,  32);
    BOOL v41 = v40;
    if (v53 < 0) {
      operator delete(v51[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::startDownloading(const std::string &, CLFileDownload *)",  "%s\n",  v41);
    if (v41 != v61) {
      free(v41);
    }
  }

  BOOL v16 = *(void **)(a1 + 40);
  v51[0] = v16;
  (*(void (**)(void *))(*(void *)v16 + 16LL))(v16);
  __int16 v52 = 256;
  if (!a3)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    BOOL v23 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v61, a1);
      __int16 v24 = v63[9] >= 0 ? v61 : *(_BYTE **)v61;
      *(_DWORD *)std::string __p = 136380675;
      *(void *)&__p[4] = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "TileFile, startDownloading, failed to download without a downloadRequest, %{private}s, #CloneMe",  __p,  0xCu);
      if ((v63[9] & 0x80000000) != 0) {
        operator delete(*(void **)v61);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_49;
    }
    bzero(v61, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v42 = qword_101934858;
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    if (v60[9] >= 0) {
      double v43 = __p;
    }
    else {
      double v43 = *(_BYTE **)__p;
    }
    *(_DWORD *)BOOL v56 = 136380675;
    *(void *)&v56[4] = v43;
    LODWORD(v5sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v42,  16LL,  "TileFile, startDownloading, failed to download without a downloadRequest, %{private}s, #CloneMe",  v56,  v50);
    BOOL v22 = v44;
    if ((v60[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_99;
  }

  if (sub_100C0DB30(a1))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v17 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v61, a1);
      uint64_t v18 = v63[9] >= 0 ? v61 : *(_BYTE **)v61;
      *(_DWORD *)std::string __p = 136380675;
      *(void *)&__p[4] = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "TileFile, startDownloading, tile is already being downloaded, %{private}s, #CloneMe",  __p,  0xCu);
      if ((v63[9] & 0x80000000) != 0) {
        operator delete(*(void **)v61);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_49;
    }
    bzero(v61, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v19 = qword_101934858;
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    if (v60[9] >= 0) {
      int v20 = __p;
    }
    else {
      int v20 = *(_BYTE **)__p;
    }
    *(_DWORD *)BOOL v56 = 136380675;
    *(void *)&v56[4] = v20;
    LODWORD(v5sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v19,  16LL,  "TileFile, startDownloading, tile is already being downloaded, %{private}s, #CloneMe",  v56,  v50);
    BOOL v22 = v21;
    if ((v60[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
LABEL_99:
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::startDownloading(const std::string &, CLFileDownload *)",  "%s\n",  v22);
    if (v22 != v61) {
      free(v22);
    }
LABEL_49:
    uint64_t v25 = 0LL;
    goto LABEL_75;
  }

  *(void *)(a1 + 104) = a3;
  (*(void (**)(uint64_t))(*(void *)a3 + 24LL))(a3);
  if (*(_BYTE *)(a1 + 144))
  {
    __int16 v26 = (const std::string::value_type *)sub_100C0E58C();
    int v27 = v26[23];
    if (v27 >= 0) {
      __int16 v28 = v26;
    }
    else {
      __int16 v28 = *(const std::string::value_type **)v26;
    }
    if (v27 >= 0) {
      std::string::size_type v29 = *((unsigned __int8 *)v26 + 23);
    }
    else {
      std::string::size_type v29 = *((void *)v26 + 1);
    }
    std::string::append(&v55, v28, v29);
  }

  if ((v55.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    double v30 = &v55;
  }
  else {
    double v30 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if ((v54.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    double v31 = &v54;
  }
  else {
    double v31 = (std::string *)v54.__r_.__value_.__r.__words[0];
  }
  uint64_t v25 = (*(uint64_t (**)(void, std::string *, std::string *, void *))(**(void **)(a1 + 104) + 16LL))( *(void *)(a1 + 104),  v30,  v31,  &unk_101350098);
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v32 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    if (v60[9] >= 0) {
      BOOL v33 = __p;
    }
    else {
      BOOL v33 = *(_BYTE **)__p;
    }
    uint64_t v34 = &v55;
    if ((v55.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v34 = (std::string *)v55.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int v61 = 136381187;
    *(void *)&v61[4] = v33;
    __int16 v62 = 1026;
    *(_DWORD *)double v63 = v25;
    *(_WORD *)&v63[4] = 2081;
    *(void *)&v63[6] = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "TileFile, startDownloading, tile, %{private}s, started, %{public}d, strFileUrl, %{private}s",  v61,  0x1Cu);
    if ((v60[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v61, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v45 = qword_101934858;
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v56, a1);
    if (v57 >= 0) {
      int v46 = v56;
    }
    else {
      int v46 = *(_BYTE **)v56;
    }
    __int16 v47 = &v55;
    if ((v55.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v47 = (std::string *)v55.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 136381187;
    *(void *)&__p[4] = v46;
    __int16 v59 = 1026;
    *(_DWORD *)std::string v60 = v25;
    *(_WORD *)&v60[4] = 2081;
    *(void *)&v60[6] = v47;
    LODWORD(v5sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v45,  2LL,  "TileFile, startDownloading, tile, %{private}s, started, %{public}d, strFileUrl, %{private}s",  __p,  v50);
    uint64_t v49 = v48;
    if (v57 < 0) {
      operator delete(*(void **)v56);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::startDownloading(const std::string &, CLFileDownload *)",  "%s\n",  v49);
    if (v49 != v61) {
      free(v49);
    }
  }

void sub_100C0E4E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void *sub_100C0E58C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10198FD38);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10198FD38))
  {
    sub_1010DDBC0(qword_10198FD20, ".gz");
    __cxa_atexit((void (*)(void *))&std::string::~string, qword_10198FD20, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10198FD38);
  }

  return qword_10198FD20;
}

void sub_100C0E60C(_Unwind_Exception *a1)
{
}

BOOL sub_100C0E624(uint64_t a1, unsigned int *a2)
{
  *a2 = 0;
  int v4 = (int *)(a1 + 48);
  sub_1008AE67C((int *)(a1 + 48), a1 + 208, &v77);
  sub_1008AE67C(v4, a1 + 8, &__p);
  if (*(_BYTE *)(a1 + 144))
  {
    BOOL v5 = (const void **)sub_100C0E58C();
    sub_10010B8E0((const void **)&v77.__r_.__value_.__l.__data_, v5, (uint64_t)v86);
    double v6 = sub_101171D38();
    if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v7 = &v77;
    }
    else {
      int v7 = (std::string *)v77.__r_.__value_.__r.__words[0];
    }
    if (v87 >= 0) {
      double v8 = v86;
    }
    else {
      double v8 = *(const char **)v86;
    }
    BOOL v9 = sub_100292D88((const char *)v7, v8);
    if (!v9)
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      BOOL v10 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
      {
        if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v11 = &v77;
        }
        else {
          __int128 v11 = (std::string *)v77.__r_.__value_.__r.__words[0];
        }
        if (v87 >= 0) {
          double v12 = v86;
        }
        else {
          double v12 = *(_BYTE **)v86;
        }
        int v13 = *__error();
        BOOL v14 = __error();
        std::stringbuf v15 = strerror(*v14);
        *(_DWORD *)uint64_t buf = 136446978;
        *(void *)&uint8_t buf[4] = v11;
        __int16 v83 = 2082;
        *(void *)double v84 = v12;
        *(_WORD *)&v84[8] = 1026;
        *(_DWORD *)char v85 = v13;
        *(_WORD *)&v85[4] = 2082;
        *(void *)&v85[6] = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "TileFile, decompress, failed to move, %{public}s, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  buf,  0x26u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        uint64_t v52 = qword_101934858;
        if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          char v53 = &v77;
        }
        else {
          char v53 = (std::string *)v77.__r_.__value_.__r.__words[0];
        }
        if (v87 >= 0) {
          std::string v54 = v86;
        }
        else {
          std::string v54 = *(_BYTE **)v86;
        }
        int v55 = *__error();
        BOOL v56 = __error();
        char v57 = strerror(*v56);
        *(_DWORD *)__int16 v78 = 136446978;
        *(void *)&v78[4] = v53;
        __int16 v79 = 2082;
        *(void *)__int16 v80 = v54;
        *(_WORD *)&v80[8] = 1026;
        *(_DWORD *)char v81 = v55;
        *(_WORD *)&v81[4] = 2082;
        *(void *)&v81[6] = v57;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v52,  16LL,  "TileFile, decompress, failed to move, %{public}s, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  v78,  38);
        __int16 v59 = (char *)v58;
        sub_10029211C("Generic", 1LL, 0, 0LL, "virtual BOOL CLTileFile::decompress(unsigned int &)", "%s\n", v58);
        if (v59 != buf) {
          free(v59);
        }
      }
    }

    double v16 = sub_101171D38();
    if (v9)
    {
      double v17 = v16;
      if (v87 >= 0) {
        uint64_t v18 = v86;
      }
      else {
        uint64_t v18 = *(const char **)v86;
      }
      unsigned int v19 = sub_100293D24(v18);
      *a2 = v19;
      if (v19)
      {
        if (v87 >= 0) {
          int v20 = v86;
        }
        else {
          int v20 = *(char **)v86;
        }
        if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          BOOL v21 = &v77;
        }
        else {
          BOOL v21 = (std::string *)v77.__r_.__value_.__r.__words[0];
        }
        BOOL v9 = sub_100293D74(v20, (const char *)v21);
        if (v9)
        {
          if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            BOOL v22 = &v77;
          }
          else {
            BOOL v22 = (std::string *)v77.__r_.__value_.__r.__words[0];
          }
          unsigned int v23 = sub_100293D24((const char *)v22);
        }

        else
        {
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          double v31 = (os_log_s *)qword_101934858;
          if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
          {
            if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              int v32 = &v77;
            }
            else {
              int v32 = (std::string *)v77.__r_.__value_.__r.__words[0];
            }
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              p_p = &__p;
            }
            else {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            int v34 = *__error();
            BOOL v35 = __error();
            uint64_t v36 = strerror(*v35);
            *(_DWORD *)uint64_t buf = 136446978;
            *(void *)&uint8_t buf[4] = v32;
            __int16 v83 = 2082;
            *(void *)double v84 = p_p;
            *(_WORD *)&v84[8] = 1026;
            *(_DWORD *)char v85 = v34;
            *(_WORD *)&v85[4] = 2082;
            *(void *)&v85[6] = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "TileFile, decompress, from, %{public}s, to, %{public}s, failed, errno, %{public}d, %{public}s, #CloneMe",  buf,  0x26u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934850 != -1) {
              dispatch_once(&qword_101934850, &stru_101878CA0);
            }
            uint64_t v65 = qword_101934858;
            if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              __int16 v66 = &v77;
            }
            else {
              __int16 v66 = (std::string *)v77.__r_.__value_.__r.__words[0];
            }
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              int v67 = &__p;
            }
            else {
              int v67 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            int v68 = *__error();
            BOOL v69 = __error();
            __int16 v70 = strerror(*v69);
            *(_DWORD *)__int16 v78 = 136446978;
            *(void *)&v78[4] = v66;
            __int16 v79 = 2082;
            *(void *)__int16 v80 = v67;
            *(_WORD *)&v80[8] = 1026;
            *(_DWORD *)char v81 = v68;
            *(_WORD *)&v81[4] = 2082;
            *(void *)&v81[6] = v70;
            LODWORD(v73) = 38;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v65,  16LL,  "TileFile, decompress, from, %{public}s, to, %{public}s, failed, errno, %{public}d, %{public}s, #CloneMe",  v78,  v73);
            __int16 v72 = (char *)v71;
            sub_10029211C("Generic", 1LL, 0, 0LL, "virtual BOOL CLTileFile::decompress(unsigned int &)", "%s\n", v71);
            if (v72 != buf) {
              free(v72);
            }
          }

          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v37 = &__p;
          }
          else {
            int v37 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          sub_100296964((const char *)v37);
          unsigned int v23 = 0;
        }

        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        double v38 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          unsigned int v39 = *a2;
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v78, a1);
          int v40 = v80[9] >= 0 ? v78 : *(_BYTE **)v78;
          *(_DWORD *)uint64_t buf = 134349827;
          *(double *)&uint8_t buf[4] = v17 - v6;
          __int16 v83 = 1026;
          *(_DWORD *)double v84 = v39;
          *(_WORD *)&v84[4] = 1026;
          *(_DWORD *)&v84[6] = v23;
          *(_WORD *)char v85 = 2081;
          *(void *)&v85[2] = v40;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEBUG,  "TileFile, decompress, in, %{public}.6lf, seconds, size, %{public}u, to, %{public}u, tile, %{private}s",  buf,  0x22u);
          if ((v80[9] & 0x80000000) != 0) {
            operator delete(*(void **)v78);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          uint64_t v47 = qword_101934858;
          unsigned int v48 = *a2;
          (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v74, a1);
          if (v75 >= 0) {
            uint64_t v49 = v74;
          }
          else {
            uint64_t v49 = (void **)v74[0];
          }
          *(_DWORD *)__int16 v78 = 134349827;
          *(double *)&v78[4] = v17 - v6;
          __int16 v79 = 1026;
          *(_DWORD *)__int16 v80 = v48;
          *(_WORD *)&v80[4] = 1026;
          *(_DWORD *)&v80[6] = v23;
          *(_WORD *)char v81 = 2081;
          *(void *)&v81[2] = v49;
          LODWORD(v73) = 34;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "TileFile, decompress, in, %{public}.6lf, seconds, size, %{public}u, to, %{public}u, tile, %{private}s",  v78,  v73);
          double v51 = v50;
          if (v75 < 0) {
            operator delete(v74[0]);
          }
          sub_10029211C("Generic", 1LL, 0, 2LL, "virtual BOOL CLTileFile::decompress(unsigned int &)", "%s\n", v51);
          if (v51 != buf) {
            free(v51);
          }
        }
      }

      else
      {
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        int v27 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
        {
          __int16 v28 = &v77;
          if ((v77.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v28 = (std::string *)v77.__r_.__value_.__r.__words[0];
          }
          std::string::size_type v29 = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          unsigned int v30 = *a2;
          *(_DWORD *)uint64_t buf = 136446722;
          *(void *)&uint8_t buf[4] = v28;
          __int16 v83 = 2082;
          *(void *)double v84 = v29;
          *(_WORD *)&v84[8] = 1026;
          *(_DWORD *)char v85 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "TileFile, decompress, from, %{public}s, to, %{public}s, failed, %{public}u byte file, #CloneMe",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          std::string v60 = &v77;
          if ((v77.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string v60 = (std::string *)v77.__r_.__value_.__r.__words[0];
          }
          int v61 = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v61 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          unsigned int v62 = *a2;
          *(_DWORD *)__int16 v78 = 136446722;
          *(void *)&v78[4] = v60;
          __int16 v79 = 2082;
          *(void *)__int16 v80 = v61;
          *(_WORD *)&v80[8] = 1026;
          *(_DWORD *)char v81 = v62;
          LODWORD(v73) = 28;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile, decompress, from, %{public}s, to, %{public}s, failed, %{public}u byte file, #CloneMe",  v78,  v73);
          __int16 v64 = (char *)v63;
          sub_10029211C("Generic", 1LL, 0, 0LL, "virtual BOOL CLTileFile::decompress(unsigned int &)", "%s\n", v63);
          if (v64 != buf) {
            free(v64);
          }
        }

        BOOL v9 = 0LL;
      }
    }

    if (v87 >= 0) {
      BOOL v41 = v86;
    }
    else {
      BOOL v41 = *(const char **)v86;
    }
    sub_100296964(v41);
    if (v87 < 0) {
      operator delete(*(void **)v86);
    }
  }

  else
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v24 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(buf, a1);
      uint64_t v25 = v84[9] >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)__int16 v78 = 136380675;
      *(void *)&v78[4] = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "TileFile, decompress, file is not compressed, %{private}s",  v78,  0xCu);
      if ((v84[9] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v43 = qword_101934858;
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v78, a1);
      if (v80[9] >= 0) {
        __int16 v44 = v78;
      }
      else {
        __int16 v44 = *(_BYTE **)v78;
      }
      *(_DWORD *)unsigned int v86 = 136380675;
      *(void *)&v86[4] = v44;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v43,  2LL,  "TileFile, decompress, file is not compressed, %{private}s",  v86,  12);
      int v46 = v45;
      if ((v80[9] & 0x80000000) != 0) {
        operator delete(*(void **)v78);
      }
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual BOOL CLTileFile::decompress(unsigned int &)", "%s\n", v46);
      if (v46 != buf) {
        free(v46);
      }
    }

    if ((v77.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v26 = &v77;
    }
    else {
      __int16 v26 = (std::string *)v77.__r_.__value_.__r.__words[0];
    }
    *a2 = sub_100293D24((const char *)v26);
    BOOL v9 = 1LL;
  }

  return v9;
}

void sub_100C0F1D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C0F25C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1008AE674((int *)(a1 + 48));
  else {
    int v4 = *(char **)v3;
  }
  std::string __s = v4;
  std::string __p = 0LL;
  __int128 v51 = 0uLL;
  memset(&v49, 0, sizeof(v49));
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  do
  {
    sub_10000CE18((uint64_t)v57);
    if (SHIBYTE(v51) < 0)
    {
      *(_BYTE *)std::string __p = 0;
      *(void *)&__int128 v51 = 0LL;
    }

    else
    {
      LOBYTE(__p) = 0;
      HIBYTE(v51) = 0;
    }

    int v7 = *(char *)(a2 + 23);
    if (v7 >= 0) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = *(void *)a2;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    BOOL v10 = sub_10000CF44(&v59[2], v8, v9);
    v52.__r_.__value_.__s.__data_[0] = 48;
    __int128 v11 = sub_1007EC2C0(v10, (char *)&v52);
    *(void *)((char *)v11 + *(void *)(*v11 - 24LL) + 24) = 8LL;
    uint64_t v12 = dword_10199ADC0++;
    std::ostream::operator<<(v11, v12);
    sub_1010DDBC0(&v48, __s);
    sub_1010DDBC0(buf, "/");
    if ((v55 & 0x80u) == 0) {
      int v13 = buf;
    }
    else {
      int v13 = *(const std::string::value_type **)buf;
    }
    if ((v55 & 0x80u) == 0) {
      std::string::size_type v14 = v55;
    }
    else {
      std::string::size_type v14 = *(void *)&buf[8];
    }
    std::stringbuf v15 = std::string::append(&v48, v13, v14);
    __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__l.__cap_ = v15->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0LL;
    v15->__r_.__value_.__l.__cap_ = 0LL;
    v15->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf::str(&v53, &v60);
    if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v17 = &v53;
    }
    else {
      double v17 = (std::stringbuf::string_type *)v53.__r_.__value_.__r.__words[0];
    }
    if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v53.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v53.__r_.__value_.__l.__size_;
    }
    unsigned int v19 = std::string::append(&v52, (const std::string::value_type *)v17, size);
    int v20 = (void *)v19->__r_.__value_.__r.__words[0];
    v56[0] = v19->__r_.__value_.__l.__size_;
    *(void *)((char *)v56 + 7) = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v21 = v19->__r_.__value_.__s.__size_;
    v19->__r_.__value_.__l.__size_ = 0LL;
    v19->__r_.__value_.__l.__cap_ = 0LL;
    v19->__r_.__value_.__r.__words[0] = 0LL;
    if (SHIBYTE(v51) < 0) {
      operator delete(__p);
    }
    std::string __p = v20;
    *(void *)&__int128 v51 = v56[0];
    *(void *)((char *)&v51 + 7) = *(void *)((char *)v56 + 7);
    HIBYTE(v51) = v21;
    dword_10199ADC0 %= 0x989680u;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    BOOL v22 = (os_log_s *)p_vtable[267];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str(&v52, &v60);
      int v23 = (char)v52.__r_.__value_.__s.__size_;
      std::string::size_type v24 = v52.__r_.__value_.__r.__words[0];
      (*(void (**)(std::string *__return_ptr))(*(void *)a1 + 16LL))(&v48);
      uint64_t v25 = &v52;
      if (v23 < 0) {
        uint64_t v25 = (std::string *)v24;
      }
      uint64_t v26 = &v48;
      if ((v48.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v26 = (std::string *)v48.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 136446467;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&_BYTE buf[12] = 2081;
      *(void *)&buf[14] = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "TileFile, generateUniqueFileName, trying, %{public}s, tile, %{private}s",  buf,  0x16u);
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&v52, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      __int16 v28 = p_vtable[267];
      std::stringbuf::str(&v48, &v60);
      int v29 = (char)v48.__r_.__value_.__s.__size_;
      std::string::size_type v30 = v48.__r_.__value_.__r.__words[0];
      (*(void (**)(_BYTE *__return_ptr))(*(void *)a1 + 16LL))(buf);
      double v31 = &v48;
      if (v29 < 0) {
        double v31 = (std::string *)v30;
      }
      int v32 = buf;
      if ((v55 & 0x80u) != 0) {
        int v32 = *(_BYTE **)buf;
      }
      LODWORD(v53.__r_.__value_.__l.__data_) = 136446467;
      *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
      WORD2(v53.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&v53.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v32;
      LODWORD(v43) = 22;
      BOOL v33 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v52,  1628LL,  &_mh_execute_header,  v28,  2LL,  "TileFile, generateUniqueFileName, trying, %{public}s, tile, %{private}s",  &v53,  v43);
      p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::generateUniqueFileName(const std::string &)",  "%s\n",  (const char *)v33);
      if (v33 != &v52) {
        free(v33);
      }
    }

    std::stringbuf::str(&v52, &v60);
    std::string v49 = v52;
    *(void *)char v57 = v5;
    *(void *)&v57[*(void *)(v5 - 24)] = v46;
    *(void *)&v59[2] = v45;
    std::streambuf::~streambuf(&v60);
    std::ios::~ios(&v61);
    if (v51 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
  }

  while (sub_100292D28(p_p));
  if ((v49.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v34 = &v49;
  }
  else {
    int v34 = (std::string *)v49.__r_.__value_.__r.__words[0];
  }
  sub_100C0FAA0(a1, (const std::string::value_type *)v34);
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  BOOL v35 = (os_log_s *)p_vtable[267];
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v36 = (void *)(a1 + 8);
    int v37 = (void *)(a1 + 208);
    LODWORD(v52.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
    WORD2(v52.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v52.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v37;
    _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "TileFile, generateUniqueFileName, end, localFilename, %{public}s, temp, %{public}s",  (uint8_t *)&v52,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v52, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    unsigned int v39 = p_vtable[267];
    int v40 = (void *)(a1 + 8);
    BOOL v41 = (void *)(a1 + 208);
    *(_DWORD *)char v57 = 136446466;
    *(void *)&v57[4] = v40;
    __int16 v58 = 2082;
    *(void *)__int16 v59 = v41;
    LODWORD(v43) = 22;
    uint64_t v42 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v52,  1628LL,  &_mh_execute_header,  v39,  2LL,  "TileFile, generateUniqueFileName, end, localFilename, %{public}s, temp, %{public}s",  v57,  v43);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::generateUniqueFileName(const std::string &)",  "%s\n",  (const char *)v42);
    if (v42 != &v52) {
      free(v42);
    }
  }

  if (SHIBYTE(v51) < 0) {
    operator delete(__p);
  }
  return 1LL;
}

void sub_100C0F9C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  _Unwind_Resume(a1);
}

void sub_100C0FAA0(uint64_t a1, const std::string::value_type *a2)
{
  int v4 = (void *)(a1 + 8);
  std::string::assign((std::string *)(a1 + 8), a2);
  uint64_t v5 = sub_100C11EB0();
  std::operator+<char>(buf, a2, v5);
  double v6 = (void **)(a1 + 208);
  *(_OWORD *)double v6 = *(_OWORD *)buf;
  *(void *)(a1 + std::ostream::sentry::~sentry(v2 - 224) = *(void *)&buf[16];
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v7 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = v4;
    uint64_t v9 = (void *)(a1 + 208);
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TileFile, setLocalfilename, localFilename, %{public}s, tempFilename, %{public}s",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v11 = 136446466;
    uint64_t v12 = v4;
    __int16 v13 = 2082;
    std::string::size_type v14 = v6;
    BOOL v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, setLocalfilename, localFilename, %{public}s, tempFilename, %{public}s",  &v11,  22);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileFile::setLocalfilename(const char *)", "%s\n", v10);
    if (v10 != buf) {
      free(v10);
    }
  }

void sub_100C0FCEC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
}

BOOL sub_100C0FCFC(uint64_t a1)
{
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    if (!__p.__r_.__value_.__l.__size_)
    {
      BOOL v2 = 0LL;
LABEL_10:
      operator delete(__p.__r_.__value_.__l.__data_);
      return v2;
    }

    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!__p.__r_.__value_.__s.__size_) {
      return 0LL;
    }
    p_p = &__p;
  }

  BOOL v2 = sub_100292D28((const char *)p_p);
  return v2;
}

void sub_100C0FD80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C0FD9C(uint64_t a1)
{
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v1 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136446210;
    *(void *)&uint8_t buf[4] = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEBUG,  "TileFile, deleteFile, unlink, %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    double v6 = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v6 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    int v10 = 136446210;
    int v11 = v6;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, deleteFile, unlink, %{public}s",  &v10,  12);
    uint64_t v8 = (char *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileFile::deleteFile()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v3 = &__p;
  }
  else {
    uint64_t v3 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  sub_100296964((const char *)v3);
  int v4 = (const void **)sub_100C1001C();
  sub_10010B8E0((const void **)&__p.__r_.__value_.__l.__data_, v4, (uint64_t)buf);
  if (v13 >= 0) {
    uint64_t v5 = buf;
  }
  else {
    uint64_t v5 = *(const char **)buf;
  }
  sub_100296964(v5);
  if (v13 < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100C0FFD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100C1001C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10198FD58);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10198FD58))
  {
    sub_1010DDBC0(qword_10198FD40, ".plist");
    __cxa_atexit((void (*)(void *))&std::string::~string, qword_10198FD40, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10198FD58);
  }

  return qword_10198FD40;
}

void sub_100C1009C(_Unwind_Exception *a1)
{
}

void sub_100C100B4(uint64_t a1)
{
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v1 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136446210;
    int v11 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEBUG,  "TileFile, deleteTempFile, unlink, %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v4 = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v4 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    int v8 = 136446210;
    uint64_t v9 = v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, deleteTempFile, unlink, %{public}s",  &v8,  12);
    double v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileFile::deleteTempFile()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v3 = &__p;
  }
  else {
    uint64_t v3 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  sub_100296964((const char *)v3);
}

void sub_100C102B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100C102DC(uint64_t a1, int a2, int a3, double a4)
{
  LODWORD(sub_1012279C0(0LL, v4, v5) = a3;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v91 = v8;
  (*(void (**)(uint64_t))(*(void *)v8 + 16LL))(v8);
  __int16 v92 = 256;
  sub_1008AE67C((int *)(a1 + 48), a1 + 208, &v90);
  sub_1008AE67C((int *)(a1 + 48), a1 + 8, &v89);
  char v85 = (unsigned int *)(a1 + 48);
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  int v10 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    int v11 = v5;
    uint64_t v5 = *(void *)(a1 + 104);
    sub_100C11224((double *)(a1 + 112), (std::stringbuf::string_type *)__p);
    if (__p[23] >= 0) {
      uint64_t v12 = __p;
    }
    else {
      uint64_t v12 = *(_BYTE **)__p;
    }
    *(_DWORD *)uint64_t buf = 67240962;
    *(_DWORD *)&uint8_t buf[4] = a2;
    *(_WORD *)&uint8_t buf[8] = 2050;
    *(void *)&buf[10] = v5;
    *(_WORD *)&_BYTE buf[18] = 1026;
    LODWORD(sub_1012279C0(0LL, v4, v5) = v11;
    *(_DWORD *)&buf[20] = v11;
    *(_WORD *)&buf[24] = 2082;
    *(void *)&buf[26] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TileFile, onDownloadCompleted, success, %{public}d, fDownloadRequest, %{public}p, tileDoesNotExist, %{public}d, de tails, %{public}s",  buf,  0x22u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v48 = v5;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v49 = qword_101934858;
    uint64_t v5 = *(void *)(a1 + 104);
    sub_100C11224((double *)(a1 + 112), &v94);
    if ((v94.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v50 = &v94;
    }
    else {
      uint64_t v50 = (std::stringbuf::string_type *)v94.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 67240962;
    *(_DWORD *)&__p[4] = a2;
    *(_WORD *)&__p[8] = 2050;
    *(void *)&__p[10] = v5;
    *(_WORD *)&__p[18] = 1026;
    LOBYTE(sub_1012279C0(0LL, v4, v5) = v48;
    *(_DWORD *)&__p[20] = v48;
    *(_WORD *)&__p[24] = 2082;
    *(void *)&__p[26] = v50;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  2LL,  "TileFile, onDownloadCompleted, success, %{public}d, fDownloadRequest, %{public}p, tileDoesNotExist, %{public}d, de tails, %{public}s",  __p,  34);
    std::string v52 = v51;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v52);
    if (v52 != buf) {
      free(v52);
    }
  }

  *(double *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a4;
  *(double *)(a1 + 232) = a4;
  *(void *)(a1 + 192) = 0LL;
  *(_BYTE *)(a1 + 168) = a2;
  *(_BYTE *)(a1 + 32) = v5;
  *(void *)(a1 + 104) = 0LL;
  if (!a2)
  {
    if ((v5 & 1) == 0)
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      int v20 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(buf, a1);
        unsigned __int8 v21 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)std::string __p = 136380675;
        *(void *)&__p[4] = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "TileFile, tile, %{private}s, download failed, #CloneMe",  __p,  0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        uint64_t v64 = qword_101934858;
        (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
        if (__p[23] >= 0) {
          uint64_t v65 = __p;
        }
        else {
          uint64_t v65 = *(_BYTE **)__p;
        }
        LODWORD(v94.__r_.__value_.__l.__data_) = 136380675;
        *(std::string::size_type *)((char *)v94.__r_.__value_.__r.__words + 4) = (std::string::size_type)v65;
        LODWORD(v84) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v64,  0LL,  "TileFile, tile, %{private}s, download failed, #CloneMe",  &v94,  v84);
        int v67 = v66;
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v67);
        if (v67 != buf) {
          free(v67);
        }
      }
    }

    if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      BOOL v22 = &v90;
    }
    else {
      BOOL v22 = (std::string *)v90.__r_.__value_.__r.__words[0];
    }
    sub_100296964((const char *)v22);
    goto LABEL_96;
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  char v13 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    std::string::size_type v14 = &v90;
    if ((v90.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v14 = (std::string *)v90.__r_.__value_.__r.__words[0];
    }
    std::stringbuf v15 = &v89;
    if ((v89.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf v15 = (std::string *)v89.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "TileFile, copy from, %{public}s, to, %{public}s, start",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    std::stringbuf::string_type v53 = &v90;
    if ((v90.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf::string_type v53 = (std::string *)v90.__r_.__value_.__r.__words[0];
    }
    std::string v54 = &v89;
    if ((v89.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string v54 = (std::string *)v89.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 136446466;
    *(void *)&__p[4] = v53;
    *(_WORD *)&_BYTE __p[12] = 2082;
    *(void *)&__p[14] = v54;
    LODWORD(v84) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, copy from, %{public}s, to, %{public}s, start",  __p,  v84);
    BOOL v56 = (char *)v55;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v55);
    if (v56 != buf) {
      free(v56);
    }
  }

  v94.__r_.__value_.__r.__words[0] = (std::string::size_type)"";
  LOWORD(v94.__r_.__value_.__r.__words[1]) = 0;
  nullsub_10(0LL);
  v94.__r_.__value_.__l.__cap_ = v16;
  v94.__r_.__value_.__r.__words[0] = (std::string::size_type)"CLTileFile::onDownloadCompleted";
  LOWORD(v94.__r_.__value_.__r.__words[1]) = 1;
  if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    double v17 = &v90;
  }
  else {
    double v17 = (std::string *)v90.__r_.__value_.__r.__words[0];
  }
  sub_1010DDBC0(buf, (char *)v17);
  sub_100C1145C((void *)a1, (uint64_t)buf, (uint64_t)&v94);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  int v18 = *(_DWORD *)(a1 + 184);
  if (v18) {
    BOOL v19 = v18 >= (*(int (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
  }
  else {
    BOOL v19 = 1;
  }
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  std::string::size_type v24 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    char v25 = v5;
    int v26 = *(_DWORD *)(a1 + 184);
    int v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    if (__p[23] >= 0) {
      __int16 v28 = __p;
    }
    else {
      __int16 v28 = *(_BYTE **)__p;
    }
    *(_DWORD *)uint64_t buf = 67240963;
    *(_DWORD *)&uint8_t buf[4] = v26;
    *(_WORD *)&uint8_t buf[8] = 1026;
    *(_DWORD *)&buf[10] = v27;
    *(_WORD *)&buf[14] = 1026;
    *(_DWORD *)&buf[16] = v19;
    *(_WORD *)&buf[20] = 2081;
    *(void *)&_BYTE buf[22] = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, tile, %{private}s",  buf,  0x1Eu);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    LOBYTE(sub_1012279C0(0LL, v4, v5) = v25;
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    char v57 = v5;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v58 = qword_101934858;
    int v59 = *(_DWORD *)(a1 + 184);
    int v60 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v87, a1);
    if (v88 >= 0) {
      uint64_t v61 = v87;
    }
    else {
      uint64_t v61 = (void **)v87[0];
    }
    *(_DWORD *)std::string __p = 67240963;
    *(_DWORD *)&__p[4] = v59;
    *(_WORD *)&__p[8] = 1026;
    *(_DWORD *)&__p[10] = v60;
    *(_WORD *)&__p[14] = 1026;
    *(_DWORD *)&__p[16] = v19;
    *(_WORD *)&__p[20] = 2081;
    *(void *)&__p[22] = v61;
    LODWORD(v84) = 30;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v58,  2LL,  "TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, tile, %{private}s",  __p,  v84);
    double v63 = v62;
    if (v88 < 0) {
      operator delete(v87[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v63);
    p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
    LOBYTE(sub_1012279C0(0LL, v4, v5) = v57;
    if (v63 != buf) {
      free(v63);
    }
  }

  if (!v19)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    BOOL v41 = (os_log_s *)p_vtable[267];
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      int v42 = *(_DWORD *)(a1 + 184);
      int v43 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
      unsigned int v44 = *v85;
      uint64_t v45 = sub_100DD8CC8(*v85);
      *(_DWORD *)uint64_t buf = 67241218;
      *(_DWORD *)&uint8_t buf[4] = v42;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v43;
      *(_WORD *)&buf[14] = 1026;
      *(_DWORD *)&buf[16] = 0;
      *(_WORD *)&buf[20] = 1026;
      *(_DWORD *)&_BYTE buf[22] = v44;
      *(_WORD *)&buf[26] = 2082;
      *(void *)&_BYTE buf[28] = v45;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, type, %{public}d, %{public}s, #CloneMe",  buf,  0x24u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      int v68 = p_vtable[267];
      int v69 = *(_DWORD *)(a1 + 184);
      int v70 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
      unsigned int v71 = *v85;
      __int16 v72 = sub_100DD8CC8(*v85);
      *(_DWORD *)std::string __p = 67241218;
      *(_DWORD *)&__p[4] = v69;
      *(_WORD *)&__p[8] = 1026;
      *(_DWORD *)&__p[10] = v70;
      *(_WORD *)&__p[14] = 1026;
      *(_DWORD *)&__p[16] = 0;
      *(_WORD *)&__p[20] = 1026;
      *(_DWORD *)&__p[22] = v71;
      *(_WORD *)&__p[26] = 2082;
      *(void *)&__p[28] = v72;
      LODWORD(v84) = 36;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v68,  16LL,  "TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, type, %{public}d, %{public}s, #CloneMe",  __p,  v84);
      __int16 v74 = (char *)v73;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v73);
      if (v74 != buf) {
        free(v74);
      }
    }

    if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v46 = &v90;
    }
    else {
      uint64_t v46 = (std::string *)v90.__r_.__value_.__r.__words[0];
    }
    sub_100296964((const char *)v46);
LABEL_96:
    BOOL v32 = 0LL;
    goto LABEL_97;
  }

  if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v29 = &v90;
  }
  else {
    int v29 = (std::string *)v90.__r_.__value_.__r.__words[0];
  }
  if ((v89.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v30 = &v89;
  }
  else {
    std::string::size_type v30 = (std::string *)v89.__r_.__value_.__r.__words[0];
  }
  BOOL v31 = sub_100292D88((const char *)v29, (const char *)v30);
  BOOL v32 = v31;
  if (!v31)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    BOOL v33 = (os_log_s *)p_vtable[267];
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      char v34 = v5;
      BOOL v35 = &v90;
      if ((v90.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        BOOL v35 = (std::string *)v90.__r_.__value_.__r.__words[0];
      }
      unsigned int v86 = v35;
      if ((v89.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v36 = &v89;
      }
      else {
        uint64_t v36 = (std::string *)v89.__r_.__value_.__r.__words[0];
      }
      LODWORD(sub_1012279C0(0LL, v4, v5) = *__error();
      int v37 = __error();
      double v38 = strerror(*v37);
      *(_DWORD *)uint64_t buf = 136446978;
      *(void *)&uint8_t buf[4] = v86;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v36;
      *(_WORD *)&_BYTE buf[22] = 1026;
      *(_DWORD *)&buf[24] = v5;
      *(_WORD *)&_BYTE buf[28] = 2082;
      *(void *)&buf[30] = v38;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "TileFile, failed to move from, %{public}s, to, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  buf,  0x26u);
      LOBYTE(sub_1012279C0(0LL, v4, v5) = v34;
    }

    if (sub_1002921D0(115, 0))
    {
      char v75 = v5;
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      __int16 v76 = p_vtable[267];
      if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string v77 = &v90;
      }
      else {
        std::string v77 = (std::string *)v90.__r_.__value_.__r.__words[0];
      }
      if ((v89.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v78 = &v89;
      }
      else {
        __int16 v78 = (std::string *)v89.__r_.__value_.__r.__words[0];
      }
      int v79 = *__error();
      __int16 v80 = __error();
      char v81 = strerror(*v80);
      *(_DWORD *)std::string __p = 136446978;
      *(void *)&__p[4] = v77;
      *(_WORD *)&_BYTE __p[12] = 2082;
      *(void *)&__p[14] = v78;
      *(_WORD *)&__p[22] = 1026;
      *(_DWORD *)&__p[24] = v79;
      *(_WORD *)&__p[28] = 2082;
      *(void *)&__p[30] = v81;
      LODWORD(v84) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v76,  16LL,  "TileFile, failed to move from, %{public}s, to, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  __p,  v84);
      __int16 v83 = (char *)v82;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::onDownloadCompleted(BOOL, BOOL, CFAbsoluteTime)",  "%s\n",  v82);
      if (v83 != buf) {
        free(v83);
      }
      LOBYTE(sub_1012279C0(0LL, v4, v5) = v75;
    }

    if ((v89.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v39 = &v89;
    }
    else {
      unsigned int v39 = (std::string *)v89.__r_.__value_.__r.__words[0];
    }
    sub_100296964((const char *)v39);
  }

  if ((v90.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v40 = &v90;
  }
  else {
    int v40 = (std::string *)v90.__r_.__value_.__r.__words[0];
  }
  sub_100296964((const char *)v40);
  v23.n128_u64[0] = qword_10198FD00;
  if (v31 && (v5 & 1) == 0) {
    sub_100C11C74(a1);
  }
LABEL_97:
  (*(void (**)(uint64_t, __n128))(*(void *)v8 + 24LL))(v8, v23);
  return v32;
}

void sub_100C11168( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_1011C52D0((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100C11224@<X0>(double *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = sub_10000CF44(&v27, (uint64_t)"tileFileDownloadDetails", 23LL);
  double v6 = sub_10000CF44(v5, (uint64_t)", cellIfCurrent, ", 17LL);
  int v7 = (void *)std::ostream::operator<<(v6, *(unsigned __int8 *)a1);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)", cellIfNotCurrent, ", 20LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *((unsigned __int8 *)a1 + 1));
  int v10 = sub_10000CF44(v9, (uint64_t)", redownload, ", 14LL);
  int v11 = (void *)std::ostream::operator<<(v10, *((unsigned __int8 *)a1 + 2));
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)", timeout, ", 11LL);
  uint64_t v13 = *v12;
  *(uint64_t *)((char *)v12 + *(void *)(*v12 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v12 + *(void *)(v13 - 24) + 8) = *(_DWORD *)((_BYTE *)v12 + *(void *)(v13 - 24) + 8) & 0xFFFFFEFB | 4;
  std::string::size_type v14 = (void *)std::ostream::operator<<(a1[1]);
  std::stringbuf v15 = sub_10000CF44(v14, (uint64_t)", numNeighbors, ", 16LL);
  std::string::size_type v16 = (void *)std::ostream::operator<<(v15, *((unsigned int *)a1 + 4));
  double v17 = sub_10000CF44(v16, (uint64_t)", timestamp, ", 13LL);
  uint64_t v18 = *v17;
  *(uint64_t *)((char *)v17 + *(void *)(*v17 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v17 + *(void *)(v18 - 24) + 8) = *(_DWORD *)((_BYTE *)v17 + *(void *)(v18 - 24) + 8) & 0xFFFFFEFB | 4;
  BOOL v19 = (void *)std::ostream::operator<<(a1[3]);
  int v20 = sub_10000CF44(v19, (uint64_t)", age, ", 7LL);
  uint64_t v21 = *v20;
  *(uint64_t *)((char *)v20 + *(void *)(*v20 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v20 + *(void *)(v21 - 24) + 8) = *(_DWORD *)((_BYTE *)v20 + *(void *)(v21 - 24) + 8) & 0xFFFFFEFB | 4;
  BOOL v22 = (void *)std::ostream::operator<<(Current - a1[3]);
  __n128 v23 = sub_10000CF44(v22, (uint64_t)", decompress, ", 14LL);
  std::ostream::operator<<(v23, *((unsigned __int8 *)a1 + 32));
  std::stringbuf::str(a2, &v28);
  *(void *)((char *)v26
  uint64_t v27 = v24;
  std::streambuf::~streambuf(&v28);
  return std::ios::~ios(&v29);
}

void sub_100C1143C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C1145C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[5];
  uint64_t v48 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16LL))(v6);
  __int16 v49 = 256;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1010DD48C(__filename, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)__filename = *(_OWORD *)a2;
    uint64_t v47 = *(void *)(a2 + 16);
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v7 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = __filename;
    if (v47 < 0) {
      uint64_t v8 = *(char **)__filename;
    }
    int v9 = *(unsigned __int8 *)(a3 + 8);
    int v10 = *(unsigned __int8 *)(a3 + 9);
    *(_DWORD *)uint64_t buf = 136446722;
    char v57 = v8;
    __int16 v58 = 1026;
    int v59 = v9;
    __int16 v60 = 1024;
    LODWORD(v61[0]) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TileFile, readTileFileByFileName, start, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v26 = __filename;
    if (v47 < 0) {
      int v26 = *(char **)__filename;
    }
    int v27 = *(unsigned __int8 *)(a3 + 8);
    int v28 = *(unsigned __int8 *)(a3 + 9);
    int v50 = 136446722;
    __int128 v51 = v26;
    __int16 v52 = 1026;
    int v53 = v27;
    __int16 v54 = 1024;
    *(_DWORD *)unsigned __int8 v55 = v28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, readTileFileByFileName, start, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %d",  &v50,  24);
    std::string::size_type v30 = (uint8_t *)v29;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::readTileFileByFileName(const std::string &, const TraverseDetails &)",  "%s\n",  v29);
    if (v30 != buf) {
      free(v30);
    }
  }

  if (SHIBYTE(v47) < 0)
  {
    int v11 = *(char **)__filename;
    if (*(void *)&__filename[8] != 1LL) {
      goto LABEL_32;
    }
    int v12 = **(_BYTE **)__filename;
  }

  else
  {
    int v11 = __filename;
    if (SHIBYTE(v47) != 1) {
      goto LABEL_32;
    }
    int v12 = __filename[0];
  }

  if (v12 == 45)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v13 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "TileFile, readTileFileByFileName, reading input from stdin",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      LOWORD(v5sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
      LODWORD(v45) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, readTileFileByFileName, reading input from stdin",  &v50,  v45);
      int v37 = (uint8_t *)v36;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::readTileFileByFileName(const std::string &, const TraverseDetails &)",  "%s\n",  v36);
      if (v37 != buf) {
        free(v37);
      }
    }

    std::string::size_type v14 = __stdinp;
    if (!__stdinp) {
      goto LABEL_23;
    }
    goto LABEL_33;
  }

void sub_100C11C1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011C52D0((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100C11C74(uint64_t a1)
{
  uint64_t v2 = sub_100C14158(a1, 3LL);
  if ((_DWORD)v2)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v3 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
    {
      int v4 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      *(_DWORD *)uint64_t buf = 136446723;
      uint64_t v18 = v4;
      __int16 v19 = 2049;
      double v20 = sub_1008ADB4C(a1 + 48);
      __int16 v21 = 2049;
      double v22 = sub_1008ADB70(a1 + 48);
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "@TileList, %{public}s, unlocked, llsw, %{private}.2lf, %{private}.2lf, ClassC",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v6 = qword_101934858;
      unsigned int v8 = *(_DWORD *)(a1 + 48);
      uint64_t v7 = a1 + 48;
      int v11 = 136446723;
      int v12 = sub_100DD8CC8(v8);
      __int16 v13 = 2049;
      double v14 = sub_1008ADB4C(v7);
      __int16 v15 = 2049;
      double v16 = sub_1008ADB70(v7);
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  1LL,  "@TileList, %{public}s, unlocked, llsw, %{private}.2lf, %{private}.2lf, ClassC",  &v11,  32);
      int v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileFile::unlockTile()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  return v2;
}

void *sub_100C11EB0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10198FD78);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10198FD78))
  {
    sub_1010DDBC0(qword_10198FD60, ".download");
    __cxa_atexit((void (*)(void *))&std::string::~string, qword_10198FD60, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10198FD78);
  }

  return qword_10198FD60;
}

void sub_100C11F30(_Unwind_Exception *a1)
{
}

uint64_t sub_100C11F48(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  int v10 = (int)(a5 * 10000.0);
  int v11 = (int)(a6 * 10000.0);
  if (v10) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v13 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240448;
      int v23 = v10;
      __int16 v24 = 1026;
      int v25 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "TileFile, Delta lat/lon zero, %{public}d, %{public}d, #CloneMe",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      v19[0] = 67240448;
      v19[1] = v10;
      __int16 v20 = 1026;
      int v21 = v11;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile, Delta lat/lon zero, %{public}d, %{public}d, #CloneMe",  v19,  14);
      uint64_t v18 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLTileFileUtility::initTileIdWithLatitudeAndLongitude(TileId &, double, double, double, double, sec_key_t)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }

    int v11 = 10000;
    int v10 = 10000;
  }

  int v14 = (int)((a3 + 90.0) * 10000.0) / v10 * v10;
  int v15 = (int)((a4 + 180.0) * 10000.0) / v11 * v11;
  *(_DWORD *)(a1 + 4) = v15;
  *(_DWORD *)(a1 + 8) = v14;
  *(void *)(a1 + 16) = a2;
  return sub_1008ACE90(a1, v14, v15, a2);
}

void sub_100C121BC(uint64_t a1, int a2, unsigned int *a3, double a4)
{
  int v12 = a2;
  if (a2)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101878CC0);
    }
    int v9 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTileFile.mm";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1000;
      *(_WORD *)&_BYTE buf[18] = 2080;
      *(void *)&buf[20] = "tileType == CLTilesManager_Type::TileType::WIFI_Location";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101878CC0);
      }
      int v13 = 136315650;
      int v14 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTileFile.mm";
      __int16 v15 = 1024;
      int v16 = 1000;
      __int16 v17 = 2080;
      uint64_t v18 = "tileType == CLTilesManager_Type::TileType::WIFI_Location";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assert Failed, %s, %d, %s",  (const char *)&v13,  28);
      int v11 = (char *)v10;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLTileFile::extractPropertiesFromTileHeader(CLTilesManager_Type::TileType, const CLWifiTileHeaderEntry &, CFAbsoluteTime)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    sub_1002920DC();
  }

  sub_1008ACE9C((uint64_t)buf, &v12);
  *(_DWORD *)&uint8_t buf[4] = sub_100496E10(a3);
  *(_DWORD *)&uint8_t buf[8] = sub_100924300((uint64_t)a3);
  *(void *)&buf[16] = -1LL;
  *(void *)(a1 + 64) = -1LL;
  *(_OWORD *)(a1 + memset(v19, 0, 48) = *(_OWORD *)buf;
  std::string::operator=((std::string *)(a1 + 72), (const std::string *)&buf[24]);
  *(_BYTE *)(a1 + 168) = 1;
  *(double *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a4;
  double v7 = sub_100924330((uint64_t)a3);
  *(double *)(a1 + 232) = v7;
  *(double *)(a1 + 192) = v7;
  *(_DWORD *)(a1 + 288) = 2;
  *(double *)(a1 + 176) = sub_100924318((uint64_t)a3);
  int v8 = sub_100924320((uint64_t)a3);
  *(_DWORD *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v8;
  *(_DWORD *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  if (v8 <= 0) {
    *(_DWORD *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 1209600;
  }
  if (v20 < 0) {
    operator delete(*(void **)&buf[24]);
  }
}

void sub_100C124A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

uint64_t sub_100C124C8(uint64_t *a1, char *a2, std::string::value_type *a3, int a4, int a5, double a6)
{
  uint64_t v84 = "";
  __int16 v85 = 0;
  nullsub_10(0LL);
  uint64_t v86 = v12;
  if (*a2)
  {
    sub_1010DDBC0(v89, a2);
    sub_1010DDBC0(__p, "/");
    if ((v82 & 0x80u) == 0) {
      int v13 = __p;
    }
    else {
      int v13 = (void **)__p[0];
    }
    if ((v82 & 0x80u) == 0) {
      std::string::size_type v14 = v82;
    }
    else {
      std::string::size_type v14 = (std::string::size_type)__p[1];
    }
    __int16 v15 = std::string::append((std::string *)v89, (const std::string::value_type *)v13, v14);
    __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    *(void *)&v93[16] = v15->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int16 v93 = v16;
    v15->__r_.__value_.__l.__size_ = 0LL;
    v15->__r_.__value_.__l.__cap_ = 0LL;
    v15->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v17 = std::string::append((std::string *)v93, a3);
    __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0LL;
    v17->__r_.__value_.__l.__cap_ = 0LL;
    v17->__r_.__value_.__r.__words[0] = 0LL;
    if ((v93[23] & 0x80000000) != 0) {
      operator delete(*(void **)v93);
    }
    if ((v90[9] & 0x80000000) != 0) {
      operator delete(*(void **)v89);
    }
  }

  else
  {
    sub_1010DDBC0(&v83, a3);
  }

  if (sub_100292D28(a3))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v19 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int16 v93 = 136446210;
      *(void *)&v93[4] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "TileFile,: extractTileIdFromFile, prefer local file name because it exists, %{public}s",  v93,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(v93, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      *(_DWORD *)std::string v89 = 136446210;
      *(void *)&v89[4] = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile,: extractTileIdFromFile, prefer local file name because it exists, %{public}s",  v89,  12);
      unsigned int v62 = (char *)v61;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v61);
      if (v62 != v93) {
        free(v62);
      }
    }

    std::string::assign(&v83, a3);
  }

  char v20 = (const void **)sub_100C1001C();
  sub_10010B8E0((const void **)&v83.__r_.__value_.__l.__data_, v20, (uint64_t)__p);
  sub_100C0FAA0((uint64_t)a1, a3);
  uint64_t v84 = "extractTileIdFromFile";
  __int16 v85 = a5;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v21 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    double v22 = &v83;
    if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v22 = (std::string *)v83.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int16 v93 = 136447234;
    *(void *)&v93[4] = a2;
    *(_WORD *)&v93[12] = 2082;
    *(void *)&v93[14] = a3;
    *(_WORD *)&v93[22] = 2082;
    *(void *)&v93[24] = v22;
    LOWORD(v94) = 1026;
    *(_DWORD *)((char *)&v94 + 2) = a4;
    HIWORD(v94) = 1026;
    int v95 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "TileFile, extractTileIdFromFile, directory, %{public}s, filename, %{public}s, absFilename, %{public}s, type, %{pub lic}d, isHeadersOnly, %{public}d",  v93,  0x2Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v58 = &v83;
    if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v58 = (std::string *)v83.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string v89 = 136447234;
    *(void *)&v89[4] = a2;
    *(_WORD *)&v89[12] = 2082;
    *(void *)std::string v90 = a3;
    *(_WORD *)&v90[8] = 2082;
    *(void *)&v90[10] = v58;
    LOWORD(v91) = 1026;
    *(_DWORD *)((char *)&v91 + 2) = a4;
    HIWORD(v91) = 1026;
    int v92 = a5;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 44;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, extractTileIdFromFile, directory, %{public}s, filename, %{public}s, absFilename, %{public}s, type, %{pub lic}d, isHeadersOnly, %{public}d",  v89,  v80);
    __int16 v60 = (char *)v59;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v59);
    if (v60 != v93) {
      free(v60);
    }
  }

  if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v23 = &v83;
  }
  else {
    int v23 = (std::string *)v83.__r_.__value_.__r.__words[0];
  }
  __int16 v24 = fopen((const char *)v23, "rb");
  if (!v24)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v27 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v28 = &v83;
      }
      else {
        int v28 = (std::string *)v83.__r_.__value_.__r.__words[0];
      }
      int v29 = *__error();
      std::string::size_type v30 = __error();
      BOOL v31 = strerror(*v30);
      *(_DWORD *)__int16 v93 = 136446722;
      *(void *)&v93[4] = v28;
      *(_WORD *)&v93[12] = 1026;
      *(_DWORD *)&v93[14] = v29;
      *(_WORD *)&v93[18] = 2082;
      *(void *)&v93[20] = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "TileFile, extractTileIdFromFile, failed to open file, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  v93,  0x1Cu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_106;
    }
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v32 = qword_101934858;
    if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v33 = &v83;
    }
    else {
      int v33 = (std::string *)v83.__r_.__value_.__r.__words[0];
    }
    int v34 = *__error();
    BOOL v35 = __error();
    uint64_t v36 = strerror(*v35);
    *(_DWORD *)std::string v89 = 136446722;
    *(void *)&v89[4] = v33;
    *(_WORD *)&v89[12] = 1026;
    *(_DWORD *)std::string v90 = v34;
    *(_WORD *)&v90[4] = 2082;
    *(void *)&v90[6] = v36;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  v32,  16LL,  "TileFile, extractTileIdFromFile, failed to open file, %{public}s, errno, %{public}d, %{public}s, #CloneMe",  v89,  v80);
    uint64_t v38 = (char *)v37;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v37);
LABEL_62:
    if (v38 == v93) {
      goto LABEL_106;
    }
    goto LABEL_63;
  }

  if (((*(uint64_t (**)(uint64_t *, FILE *, const char **))(*a1 + 88))(a1, v24, &v84) & 1) == 0)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    unsigned int v39 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      int v40 = &v83;
      if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v40 = (std::string *)v83.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int16 v93 = 136446210;
      *(void *)&v93[4] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "TileFile, extractTileIdFromFile, failed, %{public}s, #CloneMe",  v93,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_106;
    }
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    BOOL v41 = &v83;
    if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      BOOL v41 = (std::string *)v83.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string v89 = 136446210;
    *(void *)&v89[4] = v41;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile, extractTileIdFromFile, failed, %{public}s, #CloneMe",  v89,  v80);
    uint64_t v38 = (char *)v42;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v42);
    goto LABEL_62;
  }

  int v25 = *((_DWORD *)a1 + 46);
  if (v25) {
    BOOL v26 = v25 >= (*(int (**)(uint64_t *))(*a1 + 48))(a1);
  }
  else {
    BOOL v26 = 1;
  }
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v43 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    int v44 = *((_DWORD *)a1 + 46);
    int v45 = (*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
    double v46 = (*(double (**)(uint64_t *))(*a1 + 56))(a1);
    double v47 = (*(double (**)(uint64_t *))(*a1 + 64))(a1);
    *(_DWORD *)__int16 v93 = 67241216;
    *(_DWORD *)&v93[4] = v44;
    *(_WORD *)&v93[8] = 1026;
    *(_DWORD *)&v93[10] = v45;
    *(_WORD *)&v93[14] = 1026;
    *(_DWORD *)&v93[16] = v26;
    *(_WORD *)&v93[20] = 2050;
    *(double *)&v93[22] = v46;
    *(_WORD *)&v93[30] = 2050;
    double v94 = v47;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "TileFile, extractTileIdFromFile, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, dLat, %{public}.5lf, dLon, %{public}.5lf",  v93,  0x28u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v63 = qword_101934858;
    int v64 = *((_DWORD *)a1 + 46);
    int v65 = (*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
    double v66 = (*(double (**)(uint64_t *))(*a1 + 56))(a1);
    double v67 = (*(double (**)(uint64_t *))(*a1 + 64))(a1);
    *(_DWORD *)std::string v89 = 67241216;
    *(_DWORD *)&v89[4] = v64;
    *(_WORD *)&v89[8] = 1026;
    *(_DWORD *)&v89[10] = v65;
    *(_WORD *)std::string v90 = 1026;
    *(_DWORD *)&v90[2] = v26;
    *(_WORD *)&v90[6] = 2050;
    *(double *)&v90[8] = v66;
    *(_WORD *)&v90[16] = 2050;
    double v91 = v67;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 40;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  v63,  2LL,  "TileFile, extractTileIdFromFile, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, dLat, %{public}.5lf, dLon, %{public}.5lf",  v89,  v80);
    int v69 = (char *)v68;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v68);
    if (v69 != v93) {
      free(v69);
    }
    if (v26) {
      goto LABEL_71;
    }
LABEL_106:
    sub_1008AD150((uint64_t)(a1 + 6));
    uint64_t v54 = 0LL;
    if (!v24) {
      goto LABEL_108;
    }
    goto LABEL_107;
  }

  if (!v26) {
    goto LABEL_106;
  }
LABEL_71:
  int v49 = *((_DWORD *)a1 + 13);
  int v48 = *((_DWORD *)a1 + 14);
  (*(void (**)(uint64_t *))(*a1 + 56))(a1);
  (*(void (**)(uint64_t *))(*a1 + 64))(a1);
  sub_1008ACE90((uint64_t)(a1 + 6), v48, v49, a1[8]);
  if (!sub_1008AD614((uint64_t)(a1 + 6)))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    unsigned __int8 v55 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 16))(v93, a1);
      BOOL v56 = v93[23] >= 0 ? v93 : *(_BYTE **)v93;
      *(_DWORD *)std::string v89 = 136380675;
      *(void *)&v89[4] = v56;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_ERROR,  "TileFile, extractTileIdFromFile, invalid hash value for, %{private}s, #CloneMe",  v89,  0xCu);
      if ((v93[23] & 0x80000000) != 0) {
        operator delete(*(void **)v93);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_106;
    }
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v74 = qword_101934858;
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 16))(v89, a1);
    if (v90[9] >= 0) {
      char v75 = v89;
    }
    else {
      char v75 = *(_BYTE **)v89;
    }
    int v87 = 136380675;
    char v88 = v75;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  v74,  16LL,  "TileFile, extractTileIdFromFile, invalid hash value for, %{private}s, #CloneMe",  &v87,  v80);
    uint64_t v38 = v76;
    if ((v90[9] & 0x80000000) != 0) {
      operator delete(*(void **)v89);
    }
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v38);
    if (v38 == v93) {
      goto LABEL_106;
    }
LABEL_63:
    free(v38);
    goto LABEL_106;
  }

  *((_BYTE *)a1 + 168) = 1;
  *((double *)a1 + 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a6;
  *((double *)a1 + 29) = a6;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v50 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 16))(v93, a1);
    __int128 v51 = v93[23] >= 0 ? v93 : *(_BYTE **)v93;
    *(_DWORD *)std::string v89 = 136380675;
    *(void *)&v89[4] = v51;
    _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "TileFile, extractTileIdFromFile, read tileid from file, %{private}s",  v89,  0xCu);
    if ((v93[23] & 0x80000000) != 0) {
      operator delete(*(void **)v93);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v93, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v70 = qword_101934858;
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 16))(v89, a1);
    if (v90[9] >= 0) {
      unsigned int v71 = v89;
    }
    else {
      unsigned int v71 = *(_BYTE **)v89;
    }
    int v87 = 136380675;
    char v88 = v71;
    LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  v70,  2LL,  "TileFile, extractTileIdFromFile, read tileid from file, %{private}s",  &v87,  v80);
    uint64_t v73 = v72;
    if ((v90[9] & 0x80000000) != 0) {
      operator delete(*(void **)v89);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v73);
    if (v73 != v93) {
      free(v73);
    }
  }

  if (a4)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v52 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      int v53 = __p;
      if ((v82 & 0x80u) != 0) {
        int v53 = (void **)__p[0];
      }
      *(_DWORD *)__int16 v93 = 136446210;
      *(void *)&v93[4] = v53;
      _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEBUG,  "TileFile, extractTileIdFromFile, read, absFilenameParams, %{public}s",  v93,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(v93, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      std::string v77 = __p;
      if ((v82 & 0x80u) != 0) {
        std::string v77 = (void **)__p[0];
      }
      *(_DWORD *)std::string v89 = 136446210;
      *(void *)&v89[4] = v77;
      LODWORD(v8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  v93,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, extractTileIdFromFile, read, absFilenameParams, %{public}s",  v89,  v80);
      int v79 = (char *)v78;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, BOOL, CFAbsoluteTime)",  "%s\n",  v78);
      if (v79 != v93) {
        free(v79);
      }
    }

    sub_100C135B4((uint64_t)a1, (uint64_t)__p);
  }

  uint64_t v54 = 1LL;
LABEL_107:
  fclose(v24);
LABEL_108:
  *((_DWORD *)a1 + 72) = sub_100C13840((uint64_t)a1);
  return v54;
}

void sub_100C134EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C135B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v16 = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  __int16 v17 = 256;
  sub_100C157C0(a2, (uint64_t)&v14);
  int v5 = v15;
  if (v15) {
    *(void *)(a1 + 232) = v14;
  }
  else {
    sub_100C153F4(a1);
  }
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v6 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    else {
      uint64_t v7 = *(void *)a2;
    }
    uint64_t v8 = *(void *)(a1 + 232);
    *(_DWORD *)uint64_t buf = 67240706;
    int v24 = v5;
    __int16 v25 = 2082;
    uint64_t v26 = v7;
    __int16 v27 = 2050;
    uint64_t v28 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TileFile, paramsFileExist, %{public}d, loading, %{public}s, accessTimestamp, %{public}.1lf",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    else {
      uint64_t v10 = *(void *)a2;
    }
    uint64_t v11 = *(void *)(a1 + 232);
    v18[0] = 67240706;
    v18[1] = v5;
    __int16 v19 = 2082;
    uint64_t v20 = v10;
    __int16 v21 = 2050;
    uint64_t v22 = v11;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, paramsFileExist, %{public}d, loading, %{public}s, accessTimestamp, %{public}.1lf",  v18,  28);
    int v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileFile::loadPersistentPropertiesFromFile(const std::string &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
}

void sub_100C13818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_100C13840(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  uint64_t v3 = *(unsigned int *)(a1 + 288);
  if (!(_DWORD)v3)
  {
    sub_1008AE67C((int *)(a1 + 48), a1 + 8, &v20);
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v4 = &v20;
    }
    else {
      uint64_t v4 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    int v5 = open((const char *)v4, 2);
    if (v5 < 0)
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v7 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = &v20;
        if ((v20.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v8 = (std::string *)v20.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t buf = 136446210;
        __int16 v19 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TileFile, getProtectionClass, failed to open, %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        uint64_t v11 = &v20;
        if ((v20.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v11 = (std::string *)v20.__r_.__value_.__r.__words[0];
        }
        int v16 = 136446210;
        __int16 v17 = v11;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, getProtectionClass, failed to open, %{public}s",  &v16,  12);
        int v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTileFile::ProtectionClass CLTileFile::getProtectionClass()",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
      }

      uint64_t v3 = 0LL;
    }

    else
    {
      uint64_t v6 = fcntl(v5, 63);
      uint64_t v3 = v6;
      if ((v6 - 1) >= 4)
      {
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101878CA0);
        }
        int v9 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 67240192;
          LODWORD(v19) = v3;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "TileFile, getProtectionClass, failed to set protection class, %{public}d, #CloneMe",  buf,  8u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101878CA0);
          }
          LODWORD(v20.__r_.__value_.__l.__data_) = 67240192;
          HIDWORD(v20.__r_.__value_.__r.__words[0]) = v3;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile, getProtectionClass, failed to set protection class, %{public}d, #CloneMe",  &v20,  8);
          unsigned __int8 v15 = (uint8_t *)v14;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLTileFile::ProtectionClass CLTileFile::getProtectionClass()",  "%s\n",  v14);
          if (v15 != buf) {
            free(v15);
          }
        }
      }

      else
      {
        *(_DWORD *)(a1 + 288) = v6;
      }

      close(v5);
    }
  }

  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

void sub_100C13C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

double sub_100C13C70(uint64_t a1, unsigned int a2, unsigned int a3, double *a4, double *a5)
{
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80LL))(a1);
  double v11 = sub_1008ADB4C(a1 + 48);
  double v12 = (*(double (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
  *a4 = v11 + (double)a2 / (double)v10 * v12 + v12 / (double)v10 * 0.5;
  LODWORD(a4) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  double v13 = sub_1008ADB70(a1 + 48);
  double v14 = (*(double (**)(uint64_t))(*(void *)a1 + 64LL))(a1);
  double result = v13 + (double)a3 / (double)a4 * v14 + v14 / (double)a4 * 0.5;
  *a5 = result;
  return result;
}

BOOL sub_100C13D60(const char *a1, uint64_t a2)
{
  if (!a1)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v5 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "TileFile,filename==nullptr", buf, 2u);
    }

    BOOL v6 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (!v6) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    *(_WORD *)double v12 = 0;
    uint64_t v7 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile,filename==nullptr",  v12,  2,  *(void *)v12);
LABEL_30:
    int v9 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLTileFile::setProtectionClass(const char *, ProtectionClass)",  "%s\n");
LABEL_31:
    if (v9 != buf) {
      free(v9);
    }
    return 0LL;
  }

  int v2 = a2;
  if (sub_100296E50(a1, a2)) {
    return 1LL;
  }
  if ((v2 - 1) >= 2)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    unsigned int v10 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v16) = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "TileFile,setProtectionClass,failed,protectionClass,%{public}d,#CloneMe",  buf,  8u);
    }

    BOOL v11 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (!v11) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    *(_DWORD *)double v12 = 67240192;
    *(_DWORD *)&v12[4] = v2;
    uint64_t v7 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile,setProtectionClass,failed,protectionClass,%{public}d,#CloneMe",  v12,  8,  *(void *)v12);
    goto LABEL_30;
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  uint64_t v8 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 136446466;
    int v16 = a1;
    __int16 v17 = 1026;
    int v18 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TileFile,setProtectionClass,failed,%{public}s,protectionClass,%{public}d",  buf,  0x12u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    *(_DWORD *)double v12 = 136446466;
    *(void *)&v12[4] = a1;
    __int16 v13 = 1026;
    int v14 = v2;
    int v9 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile,setProtectionClass,failed,%{public}s,protectionClass,%{public}d",  v12,  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLTileFile::setProtectionClass(const char *, ProtectionClass)",  "%s\n");
    goto LABEL_31;
  }

  return result;
}

uint64_t sub_100C14158(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v24 = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  __int16 v25 = 256;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  int v5 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(v27, a1);
    BOOL v6 = v31 >= 0 ? v27 : *(_BYTE **)v27;
    int v7 = *(_DWORD *)(a1 + 288);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136381187;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = a2;
    WORD1(buf[0].__r_.__value_.__r.__words[2]) = 1026;
    HIDWORD(buf[0].__r_.__value_.__r.__words[2]) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "TileFile, setProtectionClass, tile, %{private}s, newClass, %{public}d, curClass, %{public}d",  (uint8_t *)buf,  0x18u);
    if (SHIBYTE(v31) < 0) {
      operator delete(*(void **)v27);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v14 = qword_101934858;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 16LL))(__p, a1);
    if (v23 >= 0) {
      unsigned __int8 v15 = __p;
    }
    else {
      unsigned __int8 v15 = (void **)__p[0];
    }
    int v16 = *(_DWORD *)(a1 + 288);
    *(_DWORD *)__int16 v27 = 136381187;
    *(void *)&v27[4] = v15;
    __int16 v28 = 1026;
    int v29 = a2;
    __int16 v30 = 1026;
    int v31 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  2LL,  "TileFile, setProtectionClass, tile, %{private}s, newClass, %{public}d, curClass, %{public}d",  v27,  24);
    int v18 = v17;
    if (v23 < 0) {
      operator delete(__p[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::setProtectionClass(ProtectionClass)",  "%s\n",  (const char *)v18);
    if (v18 != buf) {
      free(v18);
    }
  }

  if (*(_DWORD *)(a1 + 288) == (_DWORD)a2) {
    goto LABEL_11;
  }
  if ((a2 - 1) >= 4)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    double v12 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "TileFile, setProtectionClass, invalid protectionClass, %{public}d, #CloneMe",  (uint8_t *)buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      *(_DWORD *)__int16 v27 = 67240192;
      *(_DWORD *)&v27[4] = a2;
      LODWORD(v21) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "TileFile, setProtectionClass, invalid protectionClass, %{public}d, #CloneMe",  v27,  v21);
      std::string v20 = (std::string *)v19;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLTileFile::setProtectionClass(ProtectionClass)", "%s\n", v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    goto LABEL_24;
  }

  sub_1008AE67C((int *)(a1 + 48), a1 + 8, buf);
  if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v9 = buf;
  }
  else {
    int v9 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
  }
  BOOL v10 = sub_100C13D60((const char *)v9, a2);
  BOOL v11 = v10;
  if (((char)buf[0].__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (v10) {
      goto LABEL_27;
    }
LABEL_24:
    uint64_t v8 = 0LL;
    goto LABEL_25;
  }

  operator delete(buf[0].__r_.__value_.__l.__data_);
  if (!v11) {
    goto LABEL_24;
  }
LABEL_27:
  *(_DWORD *)(a1 + 288) = a2;
LABEL_11:
  uint64_t v8 = 1LL;
LABEL_25:
  (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  return v8;
}

void sub_100C145A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
}

uint64_t sub_100C145F0(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100C14158(a1, 2LL);
  if ((_DWORD)v4)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v5 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
    {
      BOOL v6 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      if (a2) {
        int v7 = "locked";
      }
      else {
        int v7 = "unlocked";
      }
      *(_DWORD *)uint64_t buf = 136447235;
      __int16 v27 = v6;
      __int16 v28 = 2082;
      int v29 = v7;
      __int16 v30 = 2049;
      double v31 = sub_1008ADB4C(a1 + 48);
      __int16 v32 = 2049;
      double v33 = sub_1008ADB70(a1 + 48);
      __int16 v34 = 1026;
      int v35 = 66;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "@TileList, %{public}s, %{public}s, llsw, %{private}.2lf, %{private}.2lf, Class%{public}c",  buf,  0x30u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v9 = qword_101934858;
      unsigned int v11 = *(_DWORD *)(a1 + 48);
      uint64_t v10 = a1 + 48;
      double v12 = sub_100DD8CC8(v11);
      if (a2) {
        __int16 v13 = "locked";
      }
      else {
        __int16 v13 = "unlocked";
      }
      int v16 = 136447235;
      __int16 v17 = v12;
      __int16 v18 = 2082;
      __int16 v19 = v13;
      __int16 v20 = 2049;
      double v21 = sub_1008ADB4C(v10);
      __int16 v22 = 2049;
      double v23 = sub_1008ADB70(v10);
      __int16 v24 = 1026;
      int v25 = 66;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v9,  1LL,  "@TileList, %{public}s, %{public}s, llsw, %{private}.2lf, %{private}.2lf, Class%{public}c",  &v16,  48);
      unsigned __int8 v15 = (uint8_t *)v14;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileFile::lockTile(BOOL)", "%s\n", v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

  return v4;
}

BOOL sub_100C148A0(const char *a1)
{
  return sub_100C13D60(a1, 2LL);
}

BOOL sub_100C148A8(const char *a1)
{
  return sub_100C13D60(a1, 3LL);
}

BOOL sub_100C148B0(double *a1, uint64_t a2, float a3)
{
  double v4 = *(double *)(a2 + 20);
  double v5 = a3;
  double v6 = *(double *)(a2 + 4);
  double v7 = *(double *)(a2 + 12);
  if (v4 >= v5 || v4 < 0.0) {
    double v9 = *(double *)(a2 + 20);
  }
  else {
    double v9 = v5;
  }
  double v10 = v9 * 1.1;
  if (v9 < 0.0) {
    double v10 = v9;
  }
  if (v10 < 0.0
    || (*(double (**)(double *))(*(void *)a1 + 56LL))(a1) <= 0.0
    || (*(double (**)(double *))(*(void *)a1 + 64LL))(a1) <= 0.0)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    __int16 v28 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      (*(void (**)(_BYTE *__return_ptr, double *))(*(void *)a1 + 16LL))(__p, a1);
      int v29 = v44 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)uint64_t buf = 136381187;
      double v47 = *(double *)&v29;
      __int16 v48 = 2049;
      double v49 = v6;
      __int16 v50 = 2049;
      double v51 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "TileFile, no location / coordinates, tile, %{private}s, scaledLocation, %{private}.8lf, %{private}.8lf, #CloneMe",  buf,  0x20u);
      if (SHIBYTE(v44) < 0) {
        operator delete(*(void **)__p);
      }
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v30 = qword_101934858;
      (*(void (**)(void **__return_ptr, double *))(*(void *)a1 + 16LL))(v39, a1);
      if (v40 >= 0) {
        double v31 = v39;
      }
      else {
        double v31 = (void **)v39[0];
      }
      *(_DWORD *)std::string __p = 136381187;
      *(void *)&__p[4] = v31;
      __int16 v42 = 2049;
      double v43 = v6;
      __int16 v44 = 2049;
      double v45 = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v30,  2LL,  "TileFile, no location / coordinates, tile, %{private}s, scaledLocation, %{private}.8lf, %{private}.8lf, #CloneMe",  __p,  32);
      double v33 = v32;
      if (v40 < 0) {
        operator delete(v39[0]);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::doesLocationIntersectWithTile(const CLDaemonLocation &, float)",  "%s\n",  v33);
      return 0LL;
    }
  }

  else
  {
    double v11 = sub_1008ADB4C((uint64_t)(a1 + 6));
    double v12 = sub_1008ADB70((uint64_t)(a1 + 6));
    double v13 = sub_1008ADB4C((uint64_t)(a1 + 6));
    double v14 = v13 + (*(double (**)(double *))(*(void *)a1 + 56LL))(a1);
    double v15 = sub_1008ADB70((uint64_t)(a1 + 6));
    double v16 = (*(double (**)(double *))(*(void *)a1 + 64LL))(a1);
    double v17 = sub_100D2DBDC(a1 + 31, v11, v12, v14, v15 + v16, 0.0);
    double v18 = sub_1008ADB4C((uint64_t)(a1 + 6));
    double v19 = v18 + (*(double (**)(double *))(*(void *)a1 + 56LL))(a1) * 0.5;
    double v20 = sub_1008ADB70((uint64_t)(a1 + 6));
    double v21 = (*(double (**)(double *))(*(void *)a1 + 64LL))(a1);
    double v22 = sub_100D2DBDC(a1 + 31, v6, v7, v19, v20 + v21 * 0.5, 0.0) - v9;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    double v23 = v22 - v17 * 0.5;
    __int16 v24 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      double v25 = (*(double (**)(double *))(*(void *)a1 + 56LL))(a1);
      double v26 = (*(double (**)(double *))(*(void *)a1 + 64LL))(a1);
      *(_DWORD *)uint64_t buf = 134349568;
      double v47 = v23;
      __int16 v48 = 2050;
      double v49 = v25;
      __int16 v50 = 2050;
      double v51 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "TileFile, doesLocationIntersectWithTile, distance, %{public}.1lf, deltas, %{public}.1lf, %{public}.1lf",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v34 = qword_101934858;
      double v35 = (*(double (**)(double *))(*(void *)a1 + 56LL))(a1);
      double v36 = (*(double (**)(double *))(*(void *)a1 + 64LL))(a1);
      *(_DWORD *)std::string __p = 134349568;
      *(double *)&__p[4] = v23;
      __int16 v42 = 2050;
      double v43 = v35;
      __int16 v44 = 2050;
      double v45 = v36;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v34,  2LL,  "TileFile, doesLocationIntersectWithTile, distance, %{public}.1lf, deltas, %{public}.1lf, %{public}.1lf",  __p,  32);
      uint64_t v38 = (uint8_t *)v37;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::doesLocationIntersectWithTile(const CLDaemonLocation &, float)",  "%s\n",  v37);
      if (v38 != buf) {
        free(v38);
      }
    }

    return v23 <= 0.0;
  }

  return result;
}

uint64_t sub_100C14E3C(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  uint64_t v5 = sub_100C0CCC8(a1);
  if ((a2 & 1) != 0)
  {
    else {
      uint64_t v5 = 0LL;
    }
  }

  (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  return v5;
}

void sub_100C14EC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100C14EDC(uint64_t a1, double *a2, double *a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v31 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16LL))(v6);
  __int16 v32 = 256;
  double v7 = *a2;
  double v8 = *(double *)(a1 + 192);
  if (*a2 < v8 || v7 < *(double *)(a1 + 232))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    double v9 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
    {
      double v10 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      double v11 = *a2;
      *(_DWORD *)uint64_t buf = 136446466;
      double v43 = v10;
      __int16 v44 = 2050;
      double v45 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "@TileList, %{public}s, touch, ignoring, %{public}.2lf, #CloneMe",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v19 = qword_101934858;
      double v20 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      double v21 = *a2;
      *(_DWORD *)unsigned int v39 = 136446466;
      *(void *)&v39[4] = v20;
      *(_WORD *)&v39[12] = 2050;
      *(double *)&v39[14] = v21;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v19,  16LL,  "@TileList, %{public}s, touch, ignoring, %{public}.2lf, #CloneMe",  v39,  22);
      double v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFile::touchMTime(const CFAbsoluteTime &, const CFAbsoluteTime &)",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }

    goto LABEL_8;
  }

  if (vabdd_f64(v7, v8) < *a3)
  {
LABEL_8:
    uint64_t v12 = 0LL;
    goto LABEL_9;
  }

  sub_1008AE67C((int *)(a1 + 48), a1 + 8, &v30);
  double v14 = *a2;
  *(double *)(a1 + 192) = *a2;
  *(double *)(a1 + 232) = v14;
  sub_100C153F4(a1);
  *(_OWORD *)unsigned int v39 = *(_OWORD *)(a1 + 48);
  *(void *)&v39[16] = *(void *)(a1 + 64);
  if (*(char *)(a1 + 95) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }

  else
  {
    __int128 __p = *(_OWORD *)(a1 + 72);
    uint64_t v41 = *(void *)(a1 + 88);
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  double v15 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
  {
    double v16 = sub_100DD8CC8(*(unsigned int *)v39);
    double v17 = sub_1008ADB4C((uint64_t)v39);
    double v18 = sub_1008ADB70((uint64_t)v39);
    *(_DWORD *)uint64_t buf = 136446723;
    double v43 = v16;
    __int16 v44 = 2049;
    double v45 = v17;
    __int16 v46 = 2049;
    double v47 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "@TileList, %{public}s, touch, llsw, %{private}.2lf, %{private}.2lf",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    uint64_t v24 = qword_101934858;
    double v25 = sub_100DD8CC8(*(unsigned int *)v39);
    double v26 = sub_1008ADB4C((uint64_t)v39);
    double v27 = sub_1008ADB70((uint64_t)v39);
    int v33 = 136446723;
    uint64_t v34 = v25;
    __int16 v35 = 2049;
    double v36 = v26;
    __int16 v37 = 2049;
    double v38 = v27;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  1LL,  "@TileList, %{public}s, touch, llsw, %{private}.2lf, %{private}.2lf",  &v33,  32);
    int v29 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileFile::touchMTime(const CFAbsoluteTime &, const CFAbsoluteTime &)",  "%s\n",  v28);
    if (v29 != buf) {
      free(v29);
    }
  }

  if (SHIBYTE(v41) < 0) {
    operator delete((void *)__p);
  }
  uint64_t v12 = 1LL;
LABEL_9:
  (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  return v12;
}

void sub_100C1537C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1011C52D0((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100C153F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  _DWORD v18[2] = v2;
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  __int16 v19 = 256;
  sub_1002A5370(v18);
  sub_1002AC7B8((uint64_t)v18, "atime", (const void *)(a1 + 232));
  v22.__r_.__value_.__r.__words[0] = 0LL;
  sub_1002AC7B8((uint64_t)v18, "stime", &v22);
  sub_1008AE67C((int *)(a1 + 48), a1 + 8, &v22);
  uint64_t v3 = (const std::string::value_type *)sub_100C1001C();
  int v4 = v3[23];
  if (v4 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = *(const std::string::value_type **)v3;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *((unsigned __int8 *)v3 + 23);
  }
  else {
    std::string::size_type v6 = *((void *)v3 + 1);
  }
  double v7 = std::string::append(&v22, v5, v6);
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  int64_t cap = v7->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101878CA0);
  }
  double v9 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    double v10 = __p;
    if (cap < 0) {
      double v10 = (void **)__p[0];
    }
    LODWORD(v22.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v22.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "TileFile, saving, %{public}s",  (uint8_t *)&v22,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v22, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    double v13 = __p;
    if (cap < 0) {
      double v13 = (void **)__p[0];
    }
    int v20 = 136446210;
    double v21 = v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v22,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TileFile, saving, %{public}s",  &v20,  12);
    double v15 = (std::string *)v14;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileFile::savePersistentPropertiesToFile()", "%s\n", v14);
    if (v15 != &v22) {
      free(v15);
    }
  }

  if (cap >= 0) {
    double v11 = __p;
  }
  else {
    double v11 = (void **)__p[0];
  }
  sub_1002A6270((uint64_t)v18, (uint64_t)v11);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  sub_1002A5590(v18);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

void sub_100C156B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1002A5590(&a17);
  sub_1011C52D0((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100C15724(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  *(_BYTE *)(a1 + 241) = 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

BOOL sub_100C15770(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 241);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return (_DWORD)v1 != 0;
}

uint64_t sub_100C157C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = a1;
  uint64_t result = sub_100292D28((const char *)a1);
  if ((_DWORD)result)
  {
    sub_1002A5370(v7);
    else {
      uint64_t v5 = *(void *)v2;
    }
    sub_1002A59D4((uint64_t)v7, v5);
    sub_1002A82BC((uint64_t)v7, "atime", &v9);
    sub_1002A82BC((uint64_t)v7, "stime", &v8);
    uint64_t v6 = v8;
    *(void *)a2 = v9;
    *(void *)(a2 + 8) = v6;
    *(_BYTE *)(a2 + 16) = 1;
    return sub_1002A5590(v7);
  }

  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 16) = 0;
  }

  return result;
}

void sub_100C15874( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100C15888(uint64_t a1, int a2)
{
  BYTE6(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a2;
  uint64_t v2 = (char *)(a1 + 240);
  if (a2 != 68 && *(unsigned __int8 *)(a1 + 240) != a2)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101878CA0);
    }
    int v4 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      double v6 = sub_1008ADB4C(a1 + 48);
      double v7 = sub_1008ADB70(a1 + 48);
      *(void *)uint64_t buf = (char *)&v20 + 6;
      uint64_t v8 = sub_100C15EB8((uint64_t **)&unk_1019A1EA8, (char *)&v20 + 6, (uint64_t)&unk_1012CF090, (_BYTE **)buf)[5];
      *(void *)uint64_t buf = v2;
      uint64_t v9 = sub_100C15EB8((uint64_t **)&unk_1019A1EA8, v2, (uint64_t)&unk_1012CF090, (_BYTE **)buf)[5];
      *(_DWORD *)uint64_t buf = 136447235;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v31 = 2049;
      double v32 = v6;
      __int16 v33 = 2049;
      double v34 = v7;
      __int16 v35 = 2082;
      double v36 = v8;
      __int16 v37 = 2082;
      double v38 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "@TileReq, %{public}s, skip, llsw, %{private}.2lf, %{private}.2lf, reason, %{public}s, last, %{public}s",  buf,  0x34u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101878CA0);
      }
      uint64_t v10 = qword_101934858;
      unsigned int v12 = *(_DWORD *)(a1 + 48);
      uint64_t v11 = a1 + 48;
      double v13 = sub_100DD8CC8(v12);
      double v14 = sub_1008ADB4C(v11);
      double v15 = sub_1008ADB70(v11);
      *(void *)double v21 = (char *)&v20 + 6;
      double v16 = sub_100C15EB8((uint64_t **)&unk_1019A1EA8, (char *)&v20 + 6, (uint64_t)&unk_1012CF090, (_BYTE **)v21)[5];
      *(void *)double v21 = v2;
      double v17 = sub_100C15EB8((uint64_t **)&unk_1019A1EA8, v2, (uint64_t)&unk_1012CF090, (_BYTE **)v21)[5];
      *(_DWORD *)double v21 = 136447235;
      *(void *)&v21[4] = v13;
      __int16 v22 = 2049;
      double v23 = v14;
      __int16 v24 = 2049;
      double v25 = v15;
      __int16 v26 = 2082;
      double v27 = v16;
      __int16 v28 = 2082;
      int v29 = v17;
      LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 52;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  1LL,  "@TileReq, %{public}s, skip, llsw, %{private}.2lf, %{private}.2lf, reason, %{public}s, last, %{public}s",  v21,  v20);
      __int16 v19 = (char *)v18;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileFile::setSkipDownloadReason(char)", "%s\n", v18);
      if (v19 != buf) {
        free(v19);
      }
    }
  }

  *uint64_t v2 = BYTE6(v20);
}

void sub_100C15BB8(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100C15BE4(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100C15C10(uint64_t a1, char *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0LL;
  int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 16 * a3;
    do
    {
      sub_100C15C8C((uint64_t **)a1, v4, a2, a2);
      a2 += 16;
      v6 -= 16LL;
    }

    while (v6);
  }

  return a1;
}

void sub_100C15C74(_Unwind_Exception *a1)
{
}

uint64_t *sub_100C15C8C(uint64_t **a1, uint64_t *a2, char *a3, _OWORD *a4)
{
  uint64_t v6 = sub_100C15D10(a1, a2, &v11, &v10, a3);
  double v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    double v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000085FC(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_100C15D10(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, char *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *a5, v7 = *((char *)a2 + 32), v6 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      double v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        double v13 = v10;
      }

      while (v14);
    }

    int v15 = *a5;
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          double v17 = (uint64_t *)v16;
          int v18 = *(char *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      double v17 = a1 + 1;
    }

uint64_t **sub_100C15EB8(uint64_t **a1, char *a2, uint64_t a3, _BYTE **a4)
{
  int v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((char *)v6 + 32);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[32] = **a4;
    *((void *)v11 + 5) = 0LL;
    sub_1000085FC(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t sub_100C15F78()
{
  _DWORD v1[2] = unk_101878B78;
  v1[3] = unk_101878B88;
  v1[4] = unk_101878B98;
  _OWORD v1[5] = unk_101878BA8;
  v1[0] = unk_101878B58;
  v1[1] = unk_101878B68;
  sub_100C15C10((uint64_t)&unk_1019A1EA8, (char *)v1, 6LL);
  return __cxa_atexit((void (*)(void *))sub_100C0B60C, &unk_1019A1EA8, (void *)&_mh_execute_header);
}

void *sub_100C16018(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a3;
    uint64_t v10 = *(void *)(a3 + 16);
  }

  int v11 = *(_DWORD *)(a3 + 24);
  sub_1008666C8((uint64_t)a1, a2, (__int128 *)__p);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101878CF0;
  sub_10001A504((uint64_t)(a1 + 24), a4);
  return a1;
}

void sub_100C160BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

unint64_t sub_100C160EC(uint64_t a1)
{
  uint64_t v1 = a1;
  int v2 = *(_DWORD *)(a1 + 144);
  __chkstk_darwin(a1);
  uint64_t v119 = (char *)&v113 - v4;
  uint64_t v6 = sub_100865E44(v3 + 48, (char *)&v113 - v4, v5);
  uint64_t v7 = v6;
  uint64_t v118 = (void *)(v1 + 120);
  float v8 = 1.0 / (float)v2;
  if ((_DWORD)v6)
  {
    double v9 = (double)*(unint64_t *)(v119 + 12);
    double v10 = v9 - *(double *)(v1 + 224);
    uint64_t v11 = (int)v6 - 1LL;
    unsigned int v12 = &v119[20 * v11];
    double v13 = (unint64_t *)(v12 + 12);
    double v14 = (double)*(unint64_t *)(v12 + 12) - v9;
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101878D20);
    }
    double v15 = v10 / 1000000.0;
    uint64_t v16 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
    {
      double v17 = v118;
      uint64_t v18 = *(void *)(v119 + 12);
      unint64_t v19 = *v13;
      int v131 = 136447746;
      char v132 = v17;
      __int16 v133 = 1026;
      *(_DWORD *)uint64_t v134 = v7;
      *(_WORD *)&v134[4] = 2050;
      *(double *)&v134[6] = v15;
      *(_WORD *)&v134[14] = 2050;
      *(void *)&v134[16] = vabdd_f64(v15, v8);
      *(_WORD *)&v134[24] = 2050;
      *(void *)&v134[26] = v18;
      *(_WORD *)&v134[34] = 2050;
      *(void *)&v134[36] = v19;
      *(_WORD *)&v134[44] = 2050;
      *(double *)&v134[46] = v14 / 1000000.0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "[manager-%{public}s] read %{public}d, timestamp from previous [%{public}f %{public}f], range [%{public}llu %{pub lic}llu], time interval %{public}f",  (uint8_t *)&v131,  0x44u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&v131, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101878D20);
      }
      std::string v83 = v118;
      uint64_t v84 = *(void *)(v119 + 12);
      unint64_t v85 = *v13;
      int v123 = 136447746;
      __int16 v124 = v83;
      __int16 v125 = 1026;
      *(_DWORD *)int v126 = v7;
      *(_WORD *)&v126[4] = 2050;
      *(double *)&v126[6] = v15;
      *(_WORD *)&v126[14] = 2050;
      *(void *)&v126[16] = vabdd_f64(v15, v8);
      *(_WORD *)&v126[24] = 2050;
      *(void *)&v126[26] = v84;
      *(_WORD *)&v126[34] = 2050;
      *(void *)&v126[36] = v85;
      *(_WORD *)&v126[44] = 2050;
      *(double *)&v126[46] = v14 / 1000000.0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &v131,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[manager-%{public}s] read %{public}d, timestamp from previous [%{public}f %{public}f], range [%{public}llu %{pub lic}llu], time interval %{public}f",  &v123,  68);
      int v87 = (int *)v86;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual int CLBatchedAccelerometerClient::Client::read()", "%s\n", v86);
      if (v87 != &v131) {
        free(v87);
      }
    }

    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101878D20);
    }
    uint64_t v20 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_INFO))
    {
      double v21 = v118;
      unint64_t v22 = *(void *)(v119 + 12);
      unint64_t v23 = *v13;
      double v24 = (double)*v13 * 0.000000999999997;
      double v25 = *(float *)v119;
      double v26 = *((float *)v119 + 1);
      double v27 = *((float *)v119 + 2);
      double v28 = *(float *)v12;
      int v29 = &v119[20 * v11];
      double v30 = *((float *)v29 + 1);
      double v31 = *((float *)v29 + 2);
      int v131 = 136448770;
      char v132 = v21;
      __int16 v133 = 2050;
      *(void *)uint64_t v134 = v22;
      *(_WORD *)&v134[8] = 2050;
      *(void *)&v134[10] = v23;
      *(_WORD *)&v134[18] = 2050;
      *(double *)&v134[20] = (double)v22 * 0.000000999999997;
      *(_WORD *)&v134[28] = 2050;
      *(double *)&v134[30] = v24;
      *(_WORD *)&v134[38] = 2050;
      *(double *)&v134[40] = v25;
      *(_WORD *)&v134[48] = 2050;
      *(double *)&v134[50] = v26;
      *(_WORD *)&v134[58] = 2050;
      *(double *)__int16 v135 = v27;
      v135[4] = 2050;
      *(double *)&v135[5] = v28;
      v135[9] = 2050;
      double v136 = v30;
      __int16 v137 = 2050;
      double v138 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "[manager-%{public}s] read [%{public}llu %{public}llu], timeS [%{public}f %{public}f], first sample [%{public}f % {public}f %{public}f], last sample [%{public}f %{public}f %{public}f]",  (uint8_t *)&v131,  0x70u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&v131, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101878D20);
      }
      char v88 = v118;
      unint64_t v89 = *(void *)(v119 + 12);
      unint64_t v90 = *v13;
      double v91 = (double)*v13 * 0.000000999999997;
      double v92 = *(float *)v119;
      double v93 = *((float *)v119 + 1);
      double v94 = *((float *)v119 + 2);
      double v95 = *(float *)v12;
      double v96 = &v119[20 * v11];
      double v97 = *((float *)v96 + 1);
      double v98 = *((float *)v96 + 2);
      int v123 = 136448770;
      __int16 v124 = v88;
      __int16 v125 = 2050;
      *(void *)int v126 = v89;
      *(_WORD *)&v126[8] = 2050;
      *(void *)&v126[10] = v90;
      *(_WORD *)&v126[18] = 2050;
      *(double *)&v126[20] = (double)v89 * 0.000000999999997;
      *(_WORD *)&v126[28] = 2050;
      *(double *)&v126[30] = v91;
      *(_WORD *)&v126[38] = 2050;
      *(double *)&v126[40] = v92;
      *(_WORD *)&v126[48] = 2050;
      *(double *)&v126[50] = v93;
      *(_WORD *)&v126[58] = 2050;
      *(double *)uint64_t v127 = v94;
      v127[4] = 2050;
      *(double *)&v127[5] = v95;
      v127[9] = 2050;
      double v128 = v97;
      __int16 v129 = 2050;
      double v130 = v98;
      LODWORD(v112) = 112;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &v131,  1628LL,  &_mh_execute_header,  qword_1019347C8,  1LL,  "[manager-%{public}s] read [%{public}llu %{public}llu], timeS [%{public}f %{public}f], first sample [%{public}f % {public}f %{public}f], last sample [%{public}f %{public}f %{public}f]",  &v123,  v112);
      BOOL v100 = (int *)v99;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual int CLBatchedAccelerometerClient::Client::read()", "%s\n", v99);
      if (v100 != &v131) {
        free(v100);
      }
    }

    *(double *)(v1 + std::ostream::sentry::~sentry(v2 - 224) = (double)*v13;
  }

  uint64_t v120 = 0LL;
  unsigned __int8 v121 = 0LL;
  unsigned __int8 v122 = 0LL;
  sub_100C1720C((void **)&v120, (int)v7);
  uint64_t v114 = v7;
  if ((int)v7 >= 1)
  {
    uint64_t v33 = 0LL;
    unint64_t v34 = 0LL;
    uint64_t v117 = &v122;
    uint64_t v35 = v114;
    *(void *)&__int128 v32 = 136446722LL;
    __int128 v116 = v32;
    *(void *)&__int128 v32 = 136446466LL;
    __int128 v115 = v32;
    uint64_t v36 = v1;
    while (1)
    {
      __int16 v37 = &v119[20 * v33];
      unint64_t v38 = *(void *)(v37 + 12);
LABEL_61:
      if (++v33 == v35) {
        goto LABEL_70;
      }
    }

    if (v38 >= v34)
    {
      if (!v34)
      {
LABEL_44:
        unint64_t v34 = *(void *)(v37 + 12);
        double v47 = v121;
        if (v121 >= v122)
        {
          unint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * ((v121 - v120) >> 2);
          unint64_t v51 = v50 + 1;
          if (v50 + 1 > 0xCCCCCCCCCCCCCCCLL) {
            sub_100007008();
          }
          if (0x999999999999999ALL * ((v122 - v120) >> 2) > v51) {
            unint64_t v51 = 0x999999999999999ALL * ((v122 - v120) >> 2);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((v122 - v120) >> 2) >= 0x666666666666666LL) {
            unint64_t v52 = 0xCCCCCCCCCCCCCCCLL;
          }
          else {
            unint64_t v52 = v51;
          }
          if (v52) {
            int v53 = (char *)sub_10009D074((uint64_t)v117, v52);
          }
          else {
            int v53 = 0LL;
          }
          uint64_t v54 = &v53[20 * v50];
          __int128 v55 = *(_OWORD *)v37;
          *((_DWORD *)v54 + 4) = *((_DWORD *)v37 + 4);
          *(_OWORD *)uint64_t v54 = v55;
          char v57 = v120;
          BOOL v56 = v121;
          __int16 v58 = v54;
          if (v121 != v120)
          {
            do
            {
              __int128 v59 = *(_OWORD *)(v56 - 20);
              *((_DWORD *)v58 - 1) = *((_DWORD *)v56 - 1);
              *(_OWORD *)(v58 - 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v59;
              v58 -= 20;
              v56 -= 20;
            }

            while (v56 != v57);
            BOOL v56 = v120;
          }

          double v49 = v54 + 20;
          uint64_t v120 = v58;
          unsigned __int8 v121 = v54 + 20;
          unsigned __int8 v122 = &v53[20 * v52];
          if (v56) {
            operator delete(v56);
          }
        }

        else
        {
          __int128 v48 = *(_OWORD *)v37;
          *((_DWORD *)v121 + 4) = *((_DWORD *)v37 + 4);
          *(_OWORD *)double v47 = v48;
          double v49 = v47 + 20;
        }

        unsigned __int8 v121 = v49;
        goto LABEL_61;
      }
    }

    else
    {
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101878D20);
      }
      unsigned int v39 = (os_log_s *)qword_1019347C8;
      if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
      {
        char v40 = v118;
        int v131 = v116;
        char v132 = v40;
        __int16 v133 = 2048;
        *(void *)uint64_t v134 = v38;
        *(_WORD *)&v134[8] = 2048;
        *(void *)&v134[10] = v34;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "[manager-%{public}s] time went backwards, current %llu, previous %llu",  (uint8_t *)&v131,  0x20u);
      }

      uint64_t v1 = v36;
      if (sub_1002921D0(115, 0))
      {
        bzero(&v131, 0x65CuLL);
        if (qword_1019347C0 != -1) {
          dispatch_once(&qword_1019347C0, &stru_101878D20);
        }
        uint64_t v41 = v118;
        int v123 = v116;
        __int16 v124 = v41;
        __int16 v125 = 2048;
        *(void *)int v126 = v38;
        *(_WORD *)&v126[8] = 2048;
        *(void *)&v126[10] = v34;
        LODWORD(v112) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v131,  1628LL,  &_mh_execute_header,  qword_1019347C8,  16LL,  "[manager-%{public}s] time went backwards, current %llu, previous %llu",  &v123,  v112);
        double v43 = (int *)v42;
        sub_10029211C("Generic", 1LL, 0, 0LL, "virtual int CLBatchedAccelerometerClient::Client::read()", "%s\n", v42);
        if (v43 != &v131) {
          free(v43);
        }
        uint64_t v1 = v36;
      }
    }

    double v44 = (double)(v38 - v34) / 1000000.0;
    if (v44 > v8 * 1.5)
    {
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101878D20);
      }
      double v45 = (os_log_s *)qword_1019347C8;
      if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
      {
        __int16 v46 = v118;
        int v131 = v115;
        char v132 = v46;
        __int16 v133 = 2050;
        *(double *)uint64_t v134 = 1.0 / v44;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "[manager-%{public}s] wrong frequency read, %{public}f",  (uint8_t *)&v131,  0x16u);
      }

      uint64_t v1 = v36;
      if (sub_1002921D0(115, 0))
      {
        bzero(&v131, 0x65CuLL);
        if (qword_1019347C0 != -1) {
          dispatch_once(&qword_1019347C0, &stru_101878D20);
        }
        __int16 v60 = v118;
        int v123 = v115;
        __int16 v124 = v60;
        __int16 v125 = 2050;
        *(double *)int v126 = 1.0 / v44;
        LODWORD(v112) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v131,  1628LL,  &_mh_execute_header,  qword_1019347C8,  16LL,  "[manager-%{public}s] wrong frequency read, %{public}f",  &v123,  v112);
        unsigned int v62 = (int *)v61;
        sub_10029211C("Generic", 1LL, 0, 0LL, "virtual int CLBatchedAccelerometerClient::Client::read()", "%s\n", v61);
        if (v62 != &v131) {
          free(v62);
        }
        uint64_t v1 = v36;
      }
    }

    goto LABEL_44;
  }

void sub_100C171C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 72);
  if (v3)
  {
    *(void *)(v1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100C1720C(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - (_BYTE *)*a1) >> 2) < a2)
  {
    if (a2 >= 0xCCCCCCCCCCCCCCDLL) {
      sub_100007008();
    }
    uint64_t v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 20;
    uint64_t v6 = (char *)sub_10009D074(v3, a2);
    uint64_t v7 = &v6[20 * v5];
    double v9 = &v6[20 * v8];
    uint64_t v11 = (char *)*a1;
    double v10 = (char *)a1[1];
    unsigned int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        __int128 v13 = *(_OWORD *)(v10 - 20);
        *((_DWORD *)v12 - 1) = *((_DWORD *)v10 - 1);
        *(_OWORD *)(v12 - 2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v13;
        v12 -= 20;
        v10 -= 20;
      }

      while (v10 != v11);
      double v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_100C172E4(void *a1)
{
  *a1 = off_101878CF0;
  int v2 = a1 + 24;
  uint64_t v3 = (void *)a1[27];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return sub_100866A6C((uint64_t)a1);
}

void sub_100C17340(void *a1)
{
  *a1 = off_101878CF0;
  int v2 = a1 + 24;
  uint64_t v3 = (void *)a1[27];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  uint64_t v5 = (void *)sub_100866A6C((uint64_t)a1);
  operator delete(v5);
}

void sub_100C173A0(id a1)
{
  qword_1019347C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "BatchedSensor");
}

uint64_t sub_100C173CC()
{
  dword_10199ADE0 = 800;
  __cxa_atexit((void (*)(void *))sub_100355650, qword_10199ADC8, (void *)&_mh_execute_header);
  sub_1010DDBC0(qword_10199ADE8, "DmFp");
  dword_10199AE00 = 200;
  return __cxa_atexit((void (*)(void *))sub_100355650, qword_10199ADE8, (void *)&_mh_execute_header);
}

BOOL *sub_100C17458(BOOL *a1)
{
  *a1 = 0;
  uint64_t v2 = sub_1006E27E8();
  sub_100413284(v2, buf);
  int v3 = sub_1002A6F64(*(uint64_t *)buf, "HRR_UseWorkoutEndTimeForRecoveryOnset", a1);
  int v4 = v3;
  uint64_t v5 = v16;
  if (!v16) {
    goto LABEL_5;
  }
  p_shared_owners = (unint64_t *)&v16->__shared_owners_;
  do
    unint64_t v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if (!v4) {
      return a1;
    }
  }

  else
  {
LABEL_5:
    if (!v3) {
      return a1;
    }
  }

  if (qword_101934770 != -1) {
    dispatch_once(&qword_101934770, &stru_101878D40);
  }
  uint64_t v8 = (os_log_s *)qword_101934778;
  if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "CLHRPeakEstimator,fUseWorkoutEndTimeForRecoveryOnset overridden (%{public}d)",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934770 != -1) {
      dispatch_once(&qword_101934770, &stru_101878D40);
    }
    BOOL v11 = *a1;
    v14[0] = 67240192;
    v14[1] = v11;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934778,  0LL,  "CLHRPeakEstimator,fUseWorkoutEndTimeForRecoveryOnset overridden (%{public}d)",  v14,  8);
    __int128 v13 = (uint8_t *)v12;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLHRPeakEstimator::CLHRPeakEstimator()", "%s\n", v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  return a1;
}

void sub_100C1767C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100C1769C(_BYTE *a1, uint64_t a2, uint64_t *a3, __int128 **a4)
{
  if (*(double *)(a2 + 56) == 0.0)
  {
    int v7 = 5;
LABEL_5:
    uint64_t result = 0LL;
    *(_DWORD *)a2 = v7;
    return result;
  }

  sub_100C18B34(v6, a2, a3);
  if (*(double *)(a2 + 64) == 0.0)
  {
    int v7 = 6;
    goto LABEL_5;
  }

  return 1LL;
}

void sub_100C17704(_BYTE *a1, uint64_t a2, __int128 **a3)
{
  double v3 = *(double *)(a2 + 48);
  if (*a1)
  {
    *(double *)(a2 + 56) = v3;
    return;
  }

  double v4 = v3 + -180.0;
  __int128 __p = 0LL;
  char v142 = 0LL;
  __int16 v143 = 0LL;
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (*a3 == v5)
  {
    int v64 = 0;
    double v12 = 0.0;
    double v11 = 0.0;
    double v10 = 0.0;
    double v67 = 0.0;
  }

  else
  {
    int v7 = 0LL;
    int v8 = 0;
    double v9 = 0.0;
    double v10 = 0.0;
    double v11 = 0.0;
    double v12 = 0.0;
    double v13 = 0.0;
    double v136 = a3[1];
    do
    {
      double v14 = *((double *)v6 + 1);
      if (v14 > v4)
      {
        if (v13 == 0.0 || v9 == 0.0) {
          goto LABEL_43;
        }
        if (v9 + 3.84 >= v14)
        {
LABEL_43:
          int v28 = v8;
        }

        else
        {
          do
          {
            double v9 = v9 + 2.56;
            double v15 = v142;
            if (v142 >= v143)
            {
              double v17 = (char *)__p;
              uint64_t v18 = 0x6DB6DB6DB6DB6DB7LL * ((v142 - (_BYTE *)__p) >> 3);
              unint64_t v19 = v18 + 1;
              if (0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3) > v19) {
                unint64_t v19 = 0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3);
              }
              else {
                unint64_t v20 = v19;
              }
              if (v20)
              {
                double v21 = (char *)sub_1000AC8F0((uint64_t)&v143, v20);
                double v17 = (char *)__p;
                double v15 = v142;
              }

              else
              {
                double v21 = 0LL;
              }

              unint64_t v22 = &v21[8 * ((v142 - (_BYTE *)__p) >> 3)];
              *(void *)unint64_t v22 = 0LL;
              *((double *)v22 + 1) = v9;
              *((double *)v22 + 2) = v13;
              *((_DWORD *)v22 + 6) = 0;
              *((void *)v22 + 4) = 0LL;
              *((void *)v22 + 5) = 0LL;
              *((_DWORD *)v22 + 12) = 3;
              if (v15 == v17)
              {
                double v27 = &v21[56 * v18];
              }

              else
              {
                unint64_t v23 = &v21[56 * v18];
                do
                {
                  __int128 v24 = *(_OWORD *)(v15 - 56);
                  __int128 v25 = *(_OWORD *)(v15 - 40);
                  __int128 v26 = *(_OWORD *)(v15 - 24);
                  double v27 = v23 - 56;
                  *((_DWORD *)v23 - 2) = *((_DWORD *)v15 - 2);
                  *(_OWORD *)(v23 - 24) = v26;
                  *(_OWORD *)(v23 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v25;
                  *(_OWORD *)(v23 - 56) = v24;
                  v15 -= 56;
                  v23 -= 56;
                }

                while (v15 != v17);
              }

              uint64_t v16 = v22 + 56;
              __int128 __p = v27;
              char v142 = v22 + 56;
              __int16 v143 = &v21[56 * v20];
              if (v17) {
                operator delete(v17);
              }
            }

            else
            {
              *(void *)char v142 = 0LL;
              *((double *)v15 + 1) = v9;
              *((double *)v15 + 2) = v13;
              *((_DWORD *)v15 + 6) = 0;
              *((void *)v15 + 4) = 0LL;
              *((void *)v15 + 5) = 0LL;
              uint64_t v16 = v15 + 56;
              *((_DWORD *)v15 + 12) = 3;
            }

            char v142 = v16;
            int v28 = v8 + 1;
            if (v8)
            {
              double v29 = v13 - v10;
              double v10 = v10 + (v13 - v10) / (double)v28;
              double v12 = v11 + v29 * (v13 - v10);
              double v11 = v12;
            }

            else
            {
              double v11 = 0.0;
              double v10 = v13;
            }

            if (qword_101934770 != -1) {
              dispatch_once(&qword_101934770, &stru_101878D40);
            }
            double v30 = (os_log_s *)qword_101934778;
            if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint64_t buf = 134283777;
              *(double *)&uint8_t buf[4] = v9;
              *(_WORD *)&_BYTE buf[12] = 2049;
              *(double *)__int16 v151 = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "CLHRPeakEstimator::estimateRecoveryOnset,fillerEntry.startTime,%{private}f,fillerEntry.mets,%{private}f",  buf,  0x16u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934770 != -1) {
                dispatch_once(&qword_101934770, &stru_101878D40);
              }
              *(_DWORD *)__int16 v148 = 134283777;
              *(double *)&v148[4] = v9;
              *(_WORD *)&v148[12] = 2049;
              *(double *)&v148[14] = v13;
              LODWORD(v134) = 22;
              double v31 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934778,  2LL,  "CLHRPeakEstimator::estimateRecoveryOnset,fillerEntry.startTime,%{private}f,fillerEntry.mets,%{private}f",  v148,  v134);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHRPeakEstimator::estimateRecoveryOnset(HRRecoveryResult &, const std::vector<HRRecoveryInputWR> &)",  "%s\n",  v31);
              if (v31 != buf) {
                free(v31);
              }
            }

            int v8 = v28;
          }

          while (v9 + 3.84 < *((double *)v6 + 1));
          int v7 = v142;
        }

        if (v7 >= v143)
        {
          uint64_t v35 = (char *)__p;
          uint64_t v36 = 0x6DB6DB6DB6DB6DB7LL * ((v7 - (_BYTE *)__p) >> 3);
          unint64_t v37 = v36 + 1;
          if (0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3) > v37) {
            unint64_t v37 = 0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3);
          }
          else {
            unint64_t v38 = v37;
          }
          if (v38)
          {
            unsigned int v39 = (char *)sub_1000AC8F0((uint64_t)&v143, v38);
            uint64_t v35 = (char *)__p;
            int v7 = v142;
          }

          else
          {
            unsigned int v39 = 0LL;
          }

          char v40 = &v39[56 * v36];
          __int128 v41 = *v6;
          __int128 v42 = v6[1];
          __int128 v43 = v6[2];
          *((void *)v40 + 6) = *((void *)v6 + 6);
          *((_OWORD *)v40 + 1) = v42;
          *((_OWORD *)v40 + 2) = v43;
          *(_OWORD *)char v40 = v41;
          if (v7 == v35)
          {
            __int128 v48 = &v39[56 * v36];
          }

          else
          {
            double v44 = &v39[56 * v36];
            do
            {
              __int128 v45 = *(_OWORD *)(v7 - 56);
              __int128 v46 = *(_OWORD *)(v7 - 40);
              __int128 v47 = *(_OWORD *)(v7 - 24);
              __int128 v48 = v44 - 56;
              *((_DWORD *)v44 - 2) = *((_DWORD *)v7 - 2);
              *(_OWORD *)(v44 - 24) = v47;
              *(_OWORD *)(v44 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v46;
              *(_OWORD *)(v44 - 56) = v45;
              v7 -= 56;
              v44 -= 56;
            }

            while (v7 != v35);
          }

          int v7 = v40 + 56;
          __int128 __p = v48;
          char v142 = v40 + 56;
          __int16 v143 = &v39[56 * v38];
          if (v35) {
            operator delete(v35);
          }
        }

        else
        {
          __int128 v32 = *v6;
          __int128 v33 = v6[1];
          __int128 v34 = v6[2];
          *((void *)v7 + 6) = *((void *)v6 + 6);
          *((_OWORD *)v7 + 1) = v33;
          *((_OWORD *)v7 + 2) = v34;
          *(_OWORD *)int v7 = v32;
          v7 += 56;
        }

        char v142 = v7;
        double v13 = *((double *)v6 + 2);
        int v8 = v28 + 1;
        if (v28)
        {
          double v49 = v13 - v10;
          double v10 = v10 + (v13 - v10) / (double)v8;
          double v12 = v11 + v49 * (v13 - v10);
          double v11 = v12;
        }

        else
        {
          double v11 = 0.0;
          double v10 = *((double *)v6 + 2);
        }

        double v9 = *((double *)v6 + 1);
        uint64_t v5 = v136;
      }

      uint64_t v6 = (__int128 *)((char *)v6 + 56);
    }

    while (v6 != v5);
    if (v9 <= 0.0 || (double v50 = v9 + 2.56, v50 >= *(double *)(a2 + 8)))
    {
      int v64 = v8;
      double v67 = v10;
    }

    else
    {
      do
      {
        unint64_t v51 = v142;
        if (v142 >= v143)
        {
          int v53 = (char *)__p;
          uint64_t v54 = 0x6DB6DB6DB6DB6DB7LL * ((v142 - (_BYTE *)__p) >> 3);
          unint64_t v55 = v54 + 1;
          if (0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3) > v55) {
            unint64_t v55 = 0xDB6DB6DB6DB6DB6ELL * ((v143 - (_BYTE *)__p) >> 3);
          }
          else {
            unint64_t v56 = v55;
          }
          if (v56)
          {
            char v57 = (char *)sub_1000AC8F0((uint64_t)&v143, v56);
            int v53 = (char *)__p;
            unint64_t v51 = v142;
          }

          else
          {
            char v57 = 0LL;
          }

          __int16 v58 = &v57[8 * ((v142 - (_BYTE *)__p) >> 3)];
          *(void *)__int16 v58 = 0LL;
          *((double *)v58 + 1) = v50;
          *((double *)v58 + 2) = v13;
          *((_DWORD *)v58 + 6) = 0;
          *((void *)v58 + 4) = 0LL;
          *((void *)v58 + 5) = 0LL;
          *((_DWORD *)v58 + 12) = 3;
          if (v51 == v53)
          {
            uint64_t v63 = &v57[56 * v54];
          }

          else
          {
            __int128 v59 = &v57[56 * v54];
            do
            {
              __int128 v60 = *(_OWORD *)(v51 - 56);
              __int128 v61 = *(_OWORD *)(v51 - 40);
              __int128 v62 = *(_OWORD *)(v51 - 24);
              uint64_t v63 = v59 - 56;
              *((_DWORD *)v59 - 2) = *((_DWORD *)v51 - 2);
              *(_OWORD *)(v59 - 24) = v62;
              *(_OWORD *)(v59 - 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v61;
              *(_OWORD *)(v59 - 56) = v60;
              v51 -= 56;
              v59 -= 56;
            }

            while (v51 != v53);
          }

          unint64_t v52 = v58 + 56;
          __int128 __p = v63;
          char v142 = v58 + 56;
          __int16 v143 = &v57[56 * v56];
          if (v53) {
            operator delete(v53);
          }
        }

        else
        {
          *(void *)char v142 = 0LL;
          *((double *)v51 + 1) = v50;
          *((double *)v51 + 2) = v13;
          *((_DWORD *)v51 + 6) = 0;
          *((void *)v51 + 4) = 0LL;
          *((void *)v51 + 5) = 0LL;
          unint64_t v52 = v51 + 56;
          *((_DWORD *)v51 + 12) = 3;
        }

        char v142 = v52;
        int v64 = v8 + 1;
        if (v8)
        {
          double v65 = v13 - v10;
          double v10 = v10 + (v13 - v10) / (double)v64;
          double v12 = v11 + v65 * (v13 - v10);
          double v11 = v12;
        }

        else
        {
          double v11 = 0.0;
          double v10 = v13;
        }

        if (qword_101934770 != -1) {
          dispatch_once(&qword_101934770, &stru_101878D40);
        }
        double v66 = (os_log_s *)qword_101934778;
        if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 134283777;
          *(double *)&uint8_t buf[4] = v50;
          *(_WORD *)&_BYTE buf[12] = 2049;
          *(double *)__int16 v151 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEBUG,  "CLHRPeakEstimator::estimateRecoveryOnset,fillerEntry.startTime,%{private}f,fillerEntry.mets,%{private}f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934770 != -1) {
            dispatch_once(&qword_101934770, &stru_101878D40);
          }
          *(_DWORD *)__int16 v148 = 134283777;
          *(double *)&v148[4] = v50;
          *(_WORD *)&v148[12] = 2049;
          *(double *)&v148[14] = v13;
          LODWORD(v134) = 22;
          uint64_t v68 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934778,  2LL,  "CLHRPeakEstimator::estimateRecoveryOnset,fillerEntry.startTime,%{private}f,fillerEntry.mets,%{private}f",  v148,  v134);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHRPeakEstimator::estimateRecoveryOnset(HRRecoveryResult &, const std::vector<HRRecoveryInputWR> &)",  "%s\n",  v68);
          if (v68 != buf) {
            free(v68);
          }
        }

        double v50 = v50 + 2.56;
        int v8 = v64;
        double v67 = v10;
      }

      while (v50 < *(double *)(a2 + 8));
    }
  }

  if (qword_101934770 != -1) {
    dispatch_once(&qword_101934770, &stru_101878D40);
  }
  int v69 = (os_log_s *)qword_101934778;
  if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEBUG))
  {
    if (v64 < 2)
    {
      double v70 = 0.0;
      double v71 = 0.0;
      if (v64 != 1)
      {
LABEL_110:
        *(_DWORD *)uint64_t buf = 134284033;
        *(double *)&uint8_t buf[4] = v4;
        *(_WORD *)&_BYTE buf[12] = 2049;
        *(double *)__int16 v151 = v70;
        *(_WORD *)&v151[8] = 2049;
        double v152 = v71;
        _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "CLHRPeakEstimator::estimateRecoveryOnset,recoveryOnsetWindowStart,%{private}f,metsStdDev,%{private}f,metsMean,%{private}f",  buf,  0x20u);
        goto LABEL_111;
      }
    }

    else
    {
      double v70 = sqrt(v12 / (double)(v64 - 1));
    }

    double v71 = v10;
    goto LABEL_110;
  }

void sub_100C18A8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a31) {
    operator delete(a31);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C18B34(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  double v3 = *(double *)(a2 + 56);
  if (v3 != 0.0)
  {
    uint64_t v4 = *a3;
    uint64_t v5 = a3[1];
    if (*a3 == v5)
    {
      double v8 = 0.0;
    }

    else
    {
      double v6 = v3 + -30.0;
      double v7 = v3 + 30.0;
      double v8 = 0.0;
      do
      {
        double v9 = *(double *)(v4 + 8);
        BOOL v10 = v9 < v6 || v9 > v7;
        v4 += 32LL;
      }

      while (v4 != v5);
    }

    *(double *)(a2 + 64) = v8;
  }

void sub_100C18BA0(id a1)
{
  qword_101934778 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HRRecovery");
}

void sub_100C18C70(id a1)
{
  qword_10199AE20 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLTilesManagerSilo");
}

uint64_t sub_100C18D24(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100C29EBC;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199AE30 != -1) {
    dispatch_once(&qword_10199AE30, block);
  }
  return qword_1019A1EC0;
}

uint64_t sub_100C190F8( uint64_t a1, unsigned int a2, uint64_t a3, const std::string *a4, __int128 *a5, double a6, double a7, double a8)
{
  unsigned int v261 = a2;
  double v259 = a7;
  double v260 = a6;
  if ((a2 & 0xFFFFFFF7) - 1 >= 2)
  {
    sub_101265D04();
    __break(1u);
    goto LABEL_315;
  }

  sub_1008ACE9C((uint64_t)&v257, &v261);
  std::string::operator=(&v258, a4);
  __int128 v14 = a5[1];
  __int128 v254 = *a5;
  __int128 v255 = v14;
  uint64_t v256 = *((void *)a5 + 4);
  uint64_t v15 = sub_100C29628(a1, v257.__r_.__value_.__l.__data_);
  uint64_t v16 = v15;
  double v8 = __p;
  if (!*(_BYTE *)v15)
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_101934830 == -1)
    {
LABEL_33:
      __int128 v34 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v35 = v261;
        uint64_t v36 = sub_100DD8CC8(v261);
        *(_DWORD *)uint64_t buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v35;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)(v8 + 154) = v36;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "TILE: requestDownload, type, %d, %s, not active",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        uint64_t v166 = qword_101934838;
        unsigned int v167 = v261;
        __int128 v168 = sub_100DD8CC8(v261);
        *(_DWORD *)int v266 = 67109378;
        *(_DWORD *)&v266[4] = v167;
        *(_WORD *)&v266[8] = 2080;
        *(void *)(v8 + 9sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v168;
        LODWORD(v23sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v166,  2LL,  "TILE: requestDownload, type, %d, %s, not active",  v266,  v230);
        __int128 v170 = (char *)v169;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::requestDownload(CLTilesManager_Type::TileType, double, double, sec_key_t, const std::stri ng &, const CLTileFileDownloadDetails &, CFAbsoluteTime)",  "%s\n",  v169);
        if (v170 != buf) {
          free(v170);
        }
      }

      goto LABEL_36;
    }

void sub_100C1BE1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, void *__p, uint64_t a46, int a47, __int16 a48, char a49, char a50)
{
  if (a50 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100C1C118(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 456) != a2)
  {
    uint64_t v3 = result;
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v4 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *(unsigned __int8 *)(v3 + 456);
      *(_DWORD *)uint64_t buf = 67109376;
      int v15 = a2;
      __int16 v16 = 1024;
      int v17 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: shouldEnableAppTiles, %d, fAppTilesEnabled, %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      int v8 = *(unsigned __int8 *)(v3 + 456);
      v11[0] = 67109376;
      v11[1] = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: shouldEnableAppTiles, %d, fAppTilesEnabled, %d",  v11,  14);
      BOOL v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::enableAppTilesDownload(BOOL)", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint64_t result = sub_100C29628(v3, 9u);
    if (a2) {
      int v6 = 1;
    }
    else {
      int v6 = -1;
    }
    *(_DWORD *)(result + 1memset(v19, 0, 48) = v6;
    *(_BYTE *)(result + 177) = a2;
    if (a2) {
      int v7 = 100;
    }
    else {
      int v7 = 0;
    }
    *(_DWORD *)(result + 132) = v7;
    *(_BYTE *)(v3 + 456) = a2;
  }

  return result;
}

void sub_100C1C34C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(sub_100C29628(a1, 1u) + 288);
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)uint64_t buf = 67109120;
    int v17 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: stats: getTileStats, demTilesDownloaded, %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v8 = *(_DWORD *)(a2 + 84);
    int v14 = 67109120;
    int v15 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: stats: getTileStats, demTilesDownloaded, %d",  &v14);
    BOOL v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::getTileStats(CLDaemonStats_Type::LocationNetworkQueries &)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  *(_DWORD *)(a2 + 88) = *(_DWORD *)(sub_100C29628(a1, 2u) + 288);
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  int v6 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(_DWORD *)(a2 + 88);
    *(_DWORD *)uint64_t buf = 67109120;
    int v17 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TILE: stats: getTileStats, hrseTilesDownloaded, %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v11 = *(_DWORD *)(a2 + 88);
    int v14 = 67109120;
    int v15 = v11;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: stats: getTileStats, hrseTilesDownloaded, %d",  &v14);
    int v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::getTileStats(CLDaemonStats_Type::LocationNetworkQueries &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  sub_100C217CC(a1, (uint64_t)"resetStats", (uint64_t)&stru_101878F30);
}

void sub_100C1C740( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C1C7A4(uint64_t a1, unsigned int *a2, const char *a3)
{
  if ((*a2 & 0xFFFFFFF7) - 1 >= 2)
  {
    sub_101265FD4();
    __break(1u);
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  int v6 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
  {
    unsigned int v7 = *a2;
    int v8 = sub_100DD8CC8(*a2);
    *(_DWORD *)uint64_t buf = 67240707;
    *(_DWORD *)&uint8_t buf[4] = v7;
    *(_WORD *)uint64_t v36 = 2081;
    *(void *)&v36[2] = v8;
    __int16 v37 = 2082;
    unint64_t v38 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "TileMgr, deleteTileFile, tileType, %{public}d, %{private}s, localPathToFile, %{public}s, #CloneMe",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    uint64_t v21 = qword_101934858;
    unsigned int v22 = *a2;
    unint64_t v23 = sub_100DD8CC8(*a2);
    *(_DWORD *)__int128 v32 = 67240707;
    *(_DWORD *)&v32[4] = v22;
    *(_WORD *)&uint8_t v32[8] = 2081;
    *(void *)&v32[10] = v23;
    __int16 v33 = 2082;
    __int128 v34 = a3;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  16LL,  "TileMgr, deleteTileFile, tileType, %{public}d, %{private}s, localPathToFile, %{public}s, #CloneMe",  v32,  28);
    __int128 v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTilesManager::deleteTileFile(const CLTilesManager_Type::TileType &, const char *)",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  double v9 = (uint64_t **)(sub_100C29628(a1, *a2) + 184);
  BOOL v10 = (void *)sub_1005B46E8((uint64_t)v9);
  while (1)
  {
    uint64_t v11 = v10[10];
    sub_100C0FCEC(v11, (std::string *)buf);
    size_t v12 = strlen(a3);
    if (SBYTE3(v38) < 0) {
      break;
    }
    if (v12 == BYTE3(v38))
    {
      if (v12 == -1LL) {
        goto LABEL_49;
      }
      if (!memcmp(buf, a3, v12)) {
        goto LABEL_25;
      }
    }

void sub_100C1CCA4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100C1CD00(uint64_t a1, double a2, double a3, float a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v12 = a1;
  int v107 = 9;
  uint64_t v13 = sub_100C29628(a1, 9u);
  sub_1001B4C40(a6);
  if (!*(_BYTE *)(v12 + 201))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    double v73 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v74 = *(unsigned __int8 *)(v12 + 200);
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v74;
      _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, index is not available until first unlock, fDataProtectionEnabled, %d",  buf,  8u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v75 = *(unsigned __int8 *)(v12 + 200);
    LODWORD(v108.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(v108.__r_.__value_.__r.__words[0]) = v75;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: getAppAvailabilityForArea, index is not available until first unlock, fDataProtectionEnabled, %d",  &v108);
    uint64_t v77 = (char *)v76;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list<A ppAvailability> &, BOOL)",  "%s\n",  v76);
LABEL_138:
    if (v77 != buf) {
      free(v77);
    }
    return 0LL;
  }

  if (*(_BYTE *)v13)
  {
    v106[0] = 0LL;
    v106[1] = 0LL;
    double v93 = (uint64_t *)v106;
    unsigned int v105 = (uint64_t *)v106;
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v14 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 134218496;
      *(double *)&uint8_t buf[4] = a2;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&_BYTE buf[14] = a3;
      *(_WORD *)&_BYTE buf[22] = 2048;
      double v115 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, loc, %.8lf, %.8lf, radius, %.3f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      LODWORD(v108.__r_.__value_.__l.__data_) = 134218496;
      *(double *)((char *)v108.__r_.__value_.__r.__words + 4) = a2;
      WORD2(v108.__r_.__value_.__r.__words[1]) = 2048;
      *(double *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = a3;
      HIWORD(v108.__r_.__value_.__r.__words[2]) = 2048;
      *(double *)uint64_t v109 = a4;
      LODWORD(v91) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: getAppAvailabilityForArea, loc, %.8lf, %.8lf, radius, %.3f",  COERCE_DOUBLE(&v108),  *(double *)&v91,  *(double *)&v92);
      double v80 = (char *)v79;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list <AppAvailability> &, BOOL)",  "%s\n",  v79);
      if (v80 != buf) {
        free(v80);
      }
    }

    sub_1008ACE9C((uint64_t)&v102, &v107);
    sub_100C11F48((uint64_t)&v102, -1LL, a2, a3, *(double *)(v13 + 152), *(double *)(v13 + 160));
    sub_100295604(&v101, &v100, &v99, &v98, a2, a3, a4);
    uint64_t v95 = v12;
    int v15 = (void *)sub_1006025CC(v13 + 184, (unsigned int *)&v102);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    __int16 v16 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v15 + 16LL))(buf, v15);
      BOOL v17 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
      LODWORD(v108.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, tile, %s",  (uint8_t *)&v108,  0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    uint64_t v12 = v95;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      uint64_t v83 = qword_101934838;
      (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*(void *)v15 + 16LL))(&v108, v15);
      if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v84 = &v108;
      }
      else {
        uint64_t v84 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v84;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v83,  2LL,  "TILE: getAppAvailabilityForArea, tile, %s",  (const char *)__p);
      uint64_t v86 = v85;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list <AppAvailability> &, BOOL)",  "%s\n",  v86);
      if (v86 != buf) {
        free(v86);
      }
      uint64_t v12 = v95;
    }

    else if (!v15)
    {
LABEL_31:
      for (unsigned int i = -1; i != 2; ++i)
      {
        for (unsigned int j = -1; j != 2; ++j)
        {
          if (j | i)
          {
            std::stringbuf::string_type v108 = v102;
            if (SHIBYTE(v104) < 0)
            {
              sub_1010DD48C(v109, (void *)v103, *((unint64_t *)&v103 + 1));
            }

            else
            {
              *(_OWORD *)uint64_t v109 = v103;
              *(void *)&v109[16] = v104;
            }

            double v25 = *(double *)(v13 + 160);
            float32_t v26 = *(double *)(v13 + 152);
            *(float *)&double v25 = v25;
            sub_1008AE784((uint64_t)&v108, i, j, v26, *(float32x2_t *)&v25);
            if (sub_10060238C(v13 + 184, (unsigned int *)&v108))
            {
              uint64_t v27 = sub_1006025CC(v13 + 184, (unsigned int *)&v108);
              int v28 = (void *)v27;
              if (v27)
              {
                if (sub_100C14E3C(v27, *(_BYTE *)(v12 + 200)))
                {
                  double v29 = v106[0];
                  if (!v106[0]) {
                    goto LABEL_49;
                  }
                  int v30 = v106;
                  do
                  {
                    double v31 = v29;
                    __int128 v32 = v30;
                    unint64_t v33 = v29[4];
                    __int128 v34 = v29 + 1;
                    if (v33 >= (unint64_t)v28)
                    {
                      __int128 v34 = v31;
                      int v30 = (void **)v31;
                    }

                    double v29 = (void *)*v34;
                  }

                  while (v29);
                  if (v30 == v106) {
                    goto LABEL_49;
                  }
                  if ((unint64_t)v28 >= v31[4])
                  {
                    if (qword_101934830 != -1) {
                      dispatch_once(&qword_101934830, &stru_101879178);
                    }
                    char v40 = (os_log_s *)qword_101934838;
                    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)uint64_t buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEBUG,  "TILE: already been searched",  buf,  2u);
                    }

                    uint64_t v12 = v95;
                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934830 != -1) {
                        dispatch_once(&qword_101934830, &stru_101879178);
                      }
                      LOWORD(__p[0]) = 0;
                      LODWORD(v91) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: already been searched",  __p,  v91);
                      uint64_t v46 = (char *)v45;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchCont ext &, std::list<AppAvailability> &, BOOL)",  "%s\n",  v45);
                      if (v46 != buf) {
                        free(v46);
                      }
                      uint64_t v12 = v95;
                    }
                  }

                  else
                  {
LABEL_49:
                    if (qword_101934830 != -1) {
                      dispatch_once(&qword_101934830, &stru_101879178);
                    }
                    unsigned int v35 = (os_log_s *)qword_101934838;
                    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
                    {
                      (*(void (**)(void **__return_ptr, void *))(*(void *)v28 + 16LL))(__p, v28);
                      uint64_t v36 = __p;
                      if (SBYTE7(v113[0]) < 0) {
                        uint64_t v36 = (void **)__p[0];
                      }
                      *(_DWORD *)uint64_t buf = 67109634;
                      *(_DWORD *)&uint8_t buf[4] = i;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = j;
                      *(_WORD *)&_BYTE buf[14] = 2080;
                      *(void *)&buf[16] = v36;
                      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, y, %d, x, %d, ntile, %s",  buf,  0x18u);
                      if (SBYTE7(v113[0]) < 0) {
                        operator delete(__p[0]);
                      }
                    }

                    uint64_t v12 = v95;
                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934830 != -1) {
                        dispatch_once(&qword_101934830, &stru_101879178);
                      }
                      uint64_t v41 = qword_101934838;
                      (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*(void *)v28 + 16LL))( &v97,  v28);
                      __int128 v42 = &v97;
                      if ((v97.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        __int128 v42 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(__p[0]) = 67109634;
                      HIDWORD(__p[0]) = i;
                      LOWORD(__p[1]) = 1024;
                      *(_DWORD *)((char *)&__p[1] + 2) = j;
                      HIWORD(__p[1]) = 2080;
                      *(void *)&v113[0] = v42;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v41,  2LL,  "TILE: getAppAvailabilityForArea, y, %d, x, %d, ntile, %s",  __p,  24,  v92);
                      double v44 = v43;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchCont ext &, std::list<AppAvailability> &, BOOL)",  "%s\n",  v44);
                      if (v44 != buf) {
                        free(v44);
                      }
                      uint64_t v12 = v95;
                    }

                    *(void *)uint64_t buf = buf;
                    *(void *)&uint8_t buf[8] = buf;
                    *(void *)&buf[16] = 0LL;
                    v97.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
                    __p[0] = &v97;
                    __int16 v37 = sub_100C37D80(&v105, (unint64_t *)&v97, (uint64_t)&unk_1012CF090, (uint64_t **)__p);
                    sub_100C37EAC(v37 + 5, buf);
                    sub_1001B4C40(buf);
                    *(double *)__int128 __p = v99 - v101;
                    *(double *)&v97.__r_.__value_.__l.__data_ = v98 - v100;
                    unint64_t v96 = v28;
                    *(void *)uint64_t buf = &v96;
                    unint64_t v38 = sub_100C37D80(&v105, (unint64_t *)&v96, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
                    (*(void (**)(void *, double *, double *, void **, std::stringbuf::string_type *, uint64_t, void, uint64_t *))(*(void *)v28 + 176LL))( v28,  &v101,  &v100,  __p,  &v97,  1LL,  0LL,  v38 + 5);
                    __p[0] = v28;
                    *(void *)uint64_t buf = __p;
                    if (sub_100C37D80(&v105, (unint64_t *)__p, (uint64_t)&unk_1012CF090, (uint64_t **)buf)[7])
                    {
                      double v39 = (*(double (**)(void))(**(void **)(v12 + 464) + 56LL))(*(void *)(v12 + 464));
                      sub_100DD963C((uint64_t)v28, v39);
                    }
                  }
                }
              }
            }

            if ((v109[23] & 0x80000000) != 0) {
              operator delete(*(void **)v109);
            }
          }
        }
      }

      sub_1001B4C40(a6);
      __p[0] = 0LL;
      *((void *)&v47 + 1) = 0LL;
      memset((char *)v113 + 8, 0, 32);
      __int128 v48 = v105;
      if (v105 != (uint64_t *)v106)
      {
        *(void *)&__int128 v47 = 134219266LL;
        __int128 v94 = v47;
        do
        {
          uint64_t v49 = v48[6];
          if ((uint64_t *)v49 != v48 + 5)
          {
            uint64_t v50 = v48[4];
            do
            {
              unsigned int v51 = *(unsigned __int16 *)(v49 + 26);
              int8x16_t v52 = (int8x16_t)vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vdup_n_s16(v51), (int8x8_t)0x8000400020001LL));
              *(int8x8_t *)v52.i8 = vorr_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
              LODWORD(__p[0]) = v52.i32[0] | v51 & 0x10 | v52.i32[1] | (uint64_t)__p[0] & 0xFFFFFFE0;
              else {
                int v53 = 0;
              }
              __p[0] = (void *)__PAIR64__(*(_DWORD *)(v49 + 20), (uint64_t)__p[0] & 0xFFFFFFDF | v53);
              unsigned int v54 = *(unsigned __int8 *)(v49 + 25);
              LODWORD(__p[1]) = 10 * *(unsigned __int8 *)(v49 + 24);
              HIDWORD(__p[1]) = v54 >> 4;
              LODWORD(v113[0]) = v54 & 0xF;
              sub_100C13C70( v50,  *(unsigned __int16 *)(v49 + 16),  *(unsigned __int16 *)(v49 + 18),  (double *)v113 + 1,  (double *)&v113[1]);
              uint64_t v55 = *(void *)(v13 + 168);
              v56.i64[0] = v55;
              v56.i64[1] = HIDWORD(v55);
              *(float64x2_t *)((char *)&v113[1] + 8) = vdivq_f64(*(float64x2_t *)(v13 + 152), vcvtq_f64_u64(v56));
              if (qword_101934830 != -1) {
                dispatch_once(&qword_101934830, &stru_101879178);
              }
              char v57 = (os_log_s *)qword_101934838;
              if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v58 = a6[2];
                sub_100C34680((unsigned __int16 *)(v49 + 16), &v108);
                int v59 = &v108;
                if ((v108.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  int v59 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)uint64_t buf = v94;
                *(void *)&uint8_t buf[4] = v58;
                *(_WORD *)&_BYTE buf[12] = 2080;
                *(void *)&_BYTE buf[14] = v59;
                *(_WORD *)&_BYTE buf[22] = 2048;
                double v115 = *((double *)v113 + 1);
                __int16 v116 = 2048;
                uint64_t v117 = *(void *)&v113[1];
                __int16 v118 = 2048;
                uint64_t v119 = *((void *)&v113[1] + 1);
                __int16 v120 = 2048;
                uint64_t v121 = *(void *)&v113[2];
                _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, appRecommendation, %lu, %s, loc, %.10lf, %.10lf, span, %.10lf, %.10lf",  buf,  0x3Eu);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934830 != -1) {
                  dispatch_once(&qword_101934830, &stru_101879178);
                }
                uint64_t v64 = qword_101934838;
                std::string::size_type v65 = a6[2];
                sub_100C34680((unsigned __int16 *)(v49 + 16), &v97);
                double v66 = &v97;
                if ((v97.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  double v66 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
                }
                LODWORD(v108.__r_.__value_.__l.__data_) = v94;
                *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = v65;
                WORD2(v108.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v66;
                HIWORD(v108.__r_.__value_.__r.__words[2]) = 2048;
                *(void *)uint64_t v109 = *((void *)&v113[0] + 1);
                *(_WORD *)&v109[8] = 2048;
                *(void *)&v109[10] = *(void *)&v113[1];
                *(_WORD *)&v109[18] = 2048;
                *(void *)&v109[20] = *((void *)&v113[1] + 1);
                __int16 v110 = 2048;
                uint64_t v111 = *(void *)&v113[2];
                LODWORD(v91) = 62;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v64,  2LL,  "TILE: getAppAvailabilityForArea, appRecommendation, %lu, %s, loc, %.10lf, %.10lf, span, %.10lf, %.10lf",  &v108,  v91,  *(double *)&v92,  *(double *)&v93,  *(double *)&v94,  *((double *)&v94 + 1));
                uint64_t v68 = v67;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list<AppAvailability> &, BOOL)",  "%s\n",  v68);
                if (v68 != buf) {
                  free(v68);
                }
              }

              char v60 = operator new(0x48uLL);
              v60[8] = *(void *)&v113[2];
              __int128 v61 = v113[1];
              __int128 v62 = *(_OWORD *)__p;
              *((_OWORD *)v60 + 2) = v113[0];
              *((_OWORD *)v60 + 3) = v61;
              *((_OWORD *)v60 + 1) = v62;
              uint64_t v63 = *a6;
              *char v60 = *a6;
              v60[1] = a6;
              *(void *)(v63 + 8) = v60;
              *a6 = (uint64_t)v60;
              ++a6[2];
              uint64_t v49 = *(void *)(v49 + 8);
            }

            while ((uint64_t *)v49 != v48 + 5);
          }

          double v69 = (uint64_t *)v48[1];
          if (v69)
          {
            do
            {
              double v70 = v69;
              double v69 = (uint64_t *)*v69;
            }

            while (v69);
          }

          else
          {
            do
            {
              double v70 = (uint64_t *)v48[2];
              BOOL v71 = *v70 == (void)v48;
              __int128 v48 = v70;
            }

            while (!v71);
          }

          __int128 v48 = v70;
        }

        while (v70 != v93);
      }

      if (SHIBYTE(v104) < 0) {
        operator delete((void *)v103);
      }
      sub_100C37D38((uint64_t)&v105, v106[0]);
      return 1LL;
    }

    if (sub_100C14E3C((uint64_t)v15, *(_BYTE *)(v12 + 200)))
    {
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      unsigned int v18 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v15 + 16LL))(buf, v15);
        unint64_t v19 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
        LODWORD(v108.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, ctile, %s",  (uint8_t *)&v108,  0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      uint64_t v12 = v95;
      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        uint64_t v87 = qword_101934838;
        (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*(void *)v15 + 16LL))(&v108, v15);
        if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          double v88 = &v108;
        }
        else {
          double v88 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v88;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v87,  2LL,  "TILE: getAppAvailabilityForArea, ctile, %s",  (const char *)__p);
        unint64_t v90 = v89;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::li st<AppAvailability> &, BOOL)",  "%s\n",  v90);
        if (v90 != buf) {
          free(v90);
        }
        uint64_t v12 = v95;
      }

      *(void *)uint64_t buf = buf;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0LL;
      __p[0] = v15;
      v108.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      double v20 = sub_100C37D80(&v105, (unint64_t *)__p, (uint64_t)&unk_1012CF090, (uint64_t **)&v108);
      sub_100C37EAC(v20 + 5, buf);
      sub_1001B4C40(buf);
      *(double *)&v108.__r_.__value_.__l.__data_ = v99 - v101;
      *(double *)__int128 __p = v98 - v100;
      v97.__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
      *(void *)uint64_t buf = &v97;
      uint64_t v21 = sub_100C37D80(&v105, (unint64_t *)&v97, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
      (*(void (**)(void *, double *, double *, std::stringbuf::string_type *, void **, uint64_t, uint64_t, uint64_t *))(*(void *)v15 + 176LL))( v15,  &v101,  &v100,  &v108,  __p,  1LL,  a7,  v21 + 5);
      v108.__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
      *(void *)uint64_t buf = &v108;
      if (sub_100C37D80(&v105, (unint64_t *)&v108, (uint64_t)&unk_1012CF090, (uint64_t **)buf)[7])
      {
        double v22 = (*(double (**)(void))(**(void **)(v12 + 464) + 56LL))(*(void *)(v12 + 464));
        sub_100DD963C((uint64_t)v15, v22);
      }
    }

    goto LABEL_31;
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  BOOL v78 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = 9;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = sub_100DD8CC8(9u);
    _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEBUG,  "TILE: getAppAvailabilityForArea, tiles, %d, %s, are not active on this device",  buf,  0x12u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v81 = qword_101934838;
    v108.__r_.__value_.__r.__words[0] = 0x904000202LL;
    LOWORD(v108.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)sub_100DD8CC8(9u);
    LODWORD(v91) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v81,  2LL,  "TILE: getAppAvailabilityForArea, tiles, %d, %s, are not active on this device",  &v108,  v91);
    uint64_t v77 = (char *)v82;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list<A ppAvailability> &, BOOL)",  "%s\n",  v82);
    goto LABEL_138;
  }

  return result;
}

void sub_100C1E0CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35, char a36, void *a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, int a45, __int16 a46, char a47, char a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_100C37D38((uint64_t)&a36, a37);
  _Unwind_Resume(a1);
}

uint64_t sub_100C1E1C0(uint64_t a1, uint64_t *a2)
{
  if (!a2)
  {
    sub_10126613C();
    __break(1u);
LABEL_32:
    dispatch_once(&qword_101934830, &stru_101879178);
    goto LABEL_4;
  }

  uint64_t v2 = a2;
  uint64_t v3 = a1;
  uint64_t v4 = (_BYTE *)sub_100C29628(a1, 0xAu);
  sub_1004F20AC(v2);
  if (!*v4) {
    return 0LL;
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934830 != -1) {
    goto LABEL_32;
  }
LABEL_4:
  int v6 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = sub_100019240((uint64_t)(v4 + 184));
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Get manifest tile, %lu", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    uint64_t v14 = qword_101934838;
    LODWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 134217984;
    *(void *)((char *)&v20 + 4) = sub_100019240((uint64_t)(v4 + 184));
    _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v14, 2LL, "Get manifest tile, %lu", &v20);
    __int16 v16 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getRegionPreloadManifest(std::vector<CLMarketRegion> *)",  "%s\n",  v15);
    if (v16 != buf) {
      free(v16);
    }
  }

  uint64_t v7 = (uint64_t)(v4 + 184);
  uint64_t result = sub_100019240(v7);
  if (result)
  {
    if ((unint64_t)sub_100019240(v7) >= 2)
    {
      double v9 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Why do we have more than one, we only want one",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        LOWORD(v2sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  17LL,  "Why do we have more than one, we only want one",  &v20,  2);
        unsigned int v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTilesManager::getRegionPreloadManifest(std::vector<CLMarketRegion> *)",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }
    }

    uint64_t v10 = *(void *)(sub_1005B46E8(v7) + 80);
    *(_OWORD *)uint64_t buf = *(_OWORD *)(v10 + 48);
    uint64_t v23 = *(void *)(v10 + 64);
    if (*(char *)(v10 + 95) < 0)
    {
      sub_1010DD48C(&__p, *(void **)(v10 + 72), *(void *)(v10 + 80));
    }

    else
    {
      __int128 __p = *(_OWORD *)(v10 + 72);
      uint64_t v25 = *(void *)(v10 + 88);
    }

    if (sub_100C14E3C(v10, *(_BYTE *)(v3 + 200)))
    {
      __int128 v20 = 0uLL;
      uint64_t v21 = 0LL;
      if (sub_1004F09F4(v10, (uint64_t *)&v20))
      {
        uint64_t v12 = *((void *)&v20 + 1);
        uint64_t v11 = v20;
        if ((void)v20 != *((void *)&v20 + 1))
        {
          unint64_t v13 = v2[1];
          do
          {
            if (v13 >= v2[2])
            {
              unint64_t v13 = sub_1004F215C(v2, v11);
            }

            else
            {
              sub_1004F20F8((uint64_t)v2, v11);
              v13 += 56LL;
            }

            v2[1] = v13;
            v11 += 56LL;
          }

          while (v11 != v12);
        }
      }

      unint64_t v19 = (void **)&v20;
      sub_1004F206C(&v19);
    }

    if (SHIBYTE(v25) < 0) {
      operator delete((void *)__p);
    }
    return 1LL;
  }

  return result;
}

void sub_100C1E5E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  a12 = &a13;
  sub_1004F206C((void ***)&a12);
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100C1E66C(uint64_t a1, id **a2, uint64_t a3, double a4, double a5)
{
  if (!a3)
  {
    sub_1012662A4();
    __break(1u);
LABEL_21:
    dispatch_once(&qword_101934830, &stru_101879178);
    goto LABEL_5;
  }

  uint64_t v5 = a3;
  int v6 = a2;
  uint64_t v7 = a1;
  int v26 = 11;
  uint64_t v12 = (double *)sub_100C29628(a1, 0xBu);
  *(void *)(v5 + 8) = *(void *)v5;
  if (!*(_BYTE *)v12) {
    return 0LL;
  }
  unint64_t v13 = v12;
  sub_1008ACE9C((uint64_t)v23, &v26);
  sub_100C11F48((uint64_t)v23, -1LL, a4, a5, v13[19], v13[20]);
  uint64_t v14 = (uint64_t)(v13 + 23);
  if (!sub_10060238C(v14, v23)) {
    goto LABEL_15;
  }
  uint64_t v8 = sub_1006025CC(v14, v23);
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934830 != -1) {
    goto LABEL_21;
  }
LABEL_5:
  int v15 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v8 + 16LL))(__p, v8);
    __int16 v16 = v32 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "TransitMac: getTransitMacAddresses, tile exists, %s",  buf,  0xCu);
    if (v32 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    uint64_t v19 = qword_101934838;
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)v8 + 16LL))(buf, v8);
    if (v28 >= 0) {
      __int128 v20 = buf;
    }
    else {
      __int128 v20 = *(_BYTE **)buf;
    }
    int v29 = 136315138;
    int v30 = v20;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v19,  2LL,  "TransitMac: getTransitMacAddresses, tile exists, %s",  (const char *)&v29);
    double v22 = v21;
    if (v28 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::getTransitMacAddresses(std::vector<uint64_t> *, double, double, std::vector<CLTilesManager_Ty pe::TransitMac> *)",  "%s\n",  v22);
  }

  else if (!v8)
  {
    goto LABEL_15;
  }

  if (sub_100C14E3C(v8, *(_BYTE *)(v7 + 200)))
  {
    sub_1003988D4(v8, v6, (char **)v5);
    uint64_t v17 = 1LL;
    goto LABEL_16;
  }

void sub_100C1E974( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C1EA28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100C1EA44(uint64_t a1, uint64_t a2, unsigned int a3, double a4)
{
  if ((a3 & 0xFFFFFFF7) - 1 >= 2)
  {
    sub_10126640C();
  }

  else
  {
    double v9 = a4;
    unsigned int v7 = a3;
    uint64_t v4 = a2;
    uint64_t v5 = a1;
    uint64_t v6 = sub_100C29628(a1, a3);
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_101934830 == -1) {
      goto LABEL_3;
    }
  }

  dispatch_once(&qword_101934830, &stru_101879178);
LABEL_3:
  uint64_t v10 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109378;
    unsigned int v20 = v7;
    __int16 v21 = 2080;
    double v22 = sub_100DD8CC8(v7);
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TILE: listTilesDirectory, tileType, %d, %s",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    uint64_t v12 = qword_101934838;
    v16[0] = 67109378;
    v16[1] = v7;
    __int16 v17 = 2080;
    unsigned int v18 = sub_100DD8CC8(v7);
    LODWORD(v15) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  2LL,  "TILE: listTilesDirectory, tileType, %d, %s",  v16,  v15);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::listTilesDirectory(const std::string &, CLTilesManager_Type::TileType, CFAbsoluteTime)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

  return sub_100C29F08(v5, v4, *(_DWORD *)(v6 + 4), v9);
}

uint64_t sub_100C1EC68(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = a1 + 268;
  uint64_t v8 = sub_100C1F880(a1, "CLTilesManager", a2);
  *(void *)(v8 + 12sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)uint64_t v8 = &off_101878D90;
  *(void *)(v8 + 112) = v8 + 120;
  *(void *)(v8 + 1sub_100231C10(v1 + 28) = 0LL;
  *(void *)(v8 + 136) = "";
  *(_BYTE *)(v8 + 144) = 0;
  *(void *)(v8 + 152) = 0LL;
  *(void *)(v8 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(v8 + 168) = "";
  *(_BYTE *)(v8 + 176) = 0;
  *(void *)(v8 + 184) = 0LL;
  *(void *)(v8 + 192) = 0LL;
  *(_WORD *)(v8 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_OWORD *)(v8 + 208) = xmmword_101350110;
  *(void *)(v8 + std::ostream::sentry::~sentry(v2 - 224) = 0x40C5180000000000LL;
  *(void *)(v8 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(_DWORD *)(v8 + 2memset(v19, 0, 48) = 0xFFFF;
  *(void *)(v8 + 252) = 0LL;
  *(void *)(v8 + 26sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }

  *(_OWORD *)uint64_t v7 = xmmword_1012E0070;
  *(_OWORD *)(v7 + 16) = _Q1;
  *(_OWORD *)(v7 + 32) = _Q1;
  *(_OWORD *)(v7 + memset(v19, 0, 48) = _Q1;
  *(_DWORD *)(v8 + 332) = 0;
  *(_DWORD *)(v8 + 36sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(void *)(v8 + 336) = 0xBFF0000000000000LL;
  *(void *)(v8 + 344) = 0LL;
  *(void *)(v8 + 352) = 0LL;
  *(void *)(v7 + 96) = 0xBFF0000000000000LL;
  *(_DWORD *)(v8 + 372) = 0x7FFFFFFF;
  *(void *)(v8 + 384) = 0LL;
  *(void *)(v8 + 392) = 0LL;
  *(void *)(v8 + 376) = 0LL;
  *(_BYTE *)(v8 + 40sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_DWORD *)(v8 + 424) = 0;
  *(void *)(v8 + 408) = 0LL;
  *(void *)(v8 + 416) = 0LL;
  *(_BYTE *)(v8 + 4sub_100231C10(v1 + 28) = 1;
  *(void *)(v8 + 432) = 0x190000000C8LL;
  *(_BYTE *)(v8 + 44sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  *(_DWORD *)(v8 + 444) = 8;
  *(_BYTE *)(v8 + 4memset(v19, 0, 48) = 0;
  *(_DWORD *)(v8 + 452) = 5;
  *(_BYTE *)(v8 + 456) = 1;
  uint64_t v14 = *a3;
  *a3 = 0LL;
  *(void *)(v8 + 464) = v14;
  sub_100BD82E0((void *)(v8 + 472), *(void *)(a1 + 40));
  *(_BYTE *)(a1 + 496) = 0;
  sub_100E79F28(a1 + 504);
  *(void *)(a1 + 5sub_100231C10(v1 + 28) = a1 + 528;
  *(void *)(a1 + 536) = a1 + 528;
  *(void *)(a1 + 544) = 0LL;
  *(_BYTE *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 556) = 0;
  *(_BYTE *)(a1 + 56sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0;
  sub_1010DDBC0((void *)(a1 + 568), "cldavl.avl");
  *(_BYTE *)(a1 + 592) = 0;
  *(void *)(a1 + 60sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 616) = 0LL;
  *(void *)(a1 + 608) = 0LL;
  *(void *)(a1 + 624) = a1 + 624;
  *(void *)(a1 + 632) = a1 + 624;
  *(void *)(a1 + 656) = 0LL;
  *(void *)(a1 + 672) = 0LL;
  *(void *)(a1 + 664) = 0LL;
  *(void *)(a1 + 64sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  *(void *)(a1 + 646) = 0LL;
  sub_1010DDBC0((void *)(a1 + 680), "clhrseavl.avl");
  *(_BYTE *)(a1 + 704) = 0;
  if (*(_BYTE *)(a4 + 24))
  {
    sub_100E79F2C((__int128 *)(a1 + 504), (__int128 *)a4);
  }

  else
  {
    sub_100C1F91C(a1, buf);
    sub_100E79F2C((__int128 *)(a1 + 504), (__int128 *)buf);
    *(void *)int8x16_t v52 = buf;
    sub_1009708B4((void ***)v52);
  }

  sub_1002F0B04(buf);
  int v15 = (int *)(a1 + 436);
  sub_1002A7CB0(*(uint64_t *)buf, "MaxDownloadListSize", (_DWORD *)(a1 + 436));
  __int16 v16 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    __int16 v17 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v19 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v20 = *v15;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "TILE: fDefaultMaxDownloadListSize, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v37 = *v15;
    *(_DWORD *)int8x16_t v52 = 67109120;
    *(_DWORD *)&v52[4] = v37;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fDefaultMaxDownloadListSize, %d",  v52);
    double v39 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)buf, "MTimeModificationPeriod", &qword_101991110);
  __int16 v21 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    double v22 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  int v24 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = qword_101991110;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "TILE: MTimeModificationPeriod, %.1lf", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    *(_DWORD *)int8x16_t v52 = 134217984;
    *(void *)&v52[4] = qword_101991110;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: MTimeModificationPeriod, %.1lf",  COERCE_DOUBLE(v52));
    uint64_t v41 = (uint8_t *)v40;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)",  "%s\n",  v40);
    if (v41 != buf) {
      free(v41);
    }
  }

  *(void *)(a1 + 232) = *(void *)(a1 + 224);
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 3221225472LL;
  v51[2] = sub_100C21A44;
  v51[3] = &unk_101838B18;
  v51[4] = a1;
  sub_100C217CC(a1, (uint64_t)"initialize", (uint64_t)v51);
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  char v25 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "TmmMgr, ctor", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    *(_WORD *)int8x16_t v52 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TmmMgr, ctor",  v52,  2);
    int v43 = (uint8_t *)v42;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)",  "%s\n",  v42);
    if (v43 != buf) {
      free(v43);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  int v26 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v27 = *(void *)(a1 + 232);
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v27;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "TILE: fMinEncryptionGracePeriod, %.2lf",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v44 = *(void *)(a1 + 232);
    *(_DWORD *)int8x16_t v52 = 134217984;
    *(void *)&v52[4] = v44;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fMinEncryptionGracePeriod, %.2lf",  COERCE_DOUBLE(v52));
    uint64_t v46 = (uint8_t *)v45;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)",  "%s\n",  v45);
    if (v46 != buf) {
      free(v46);
    }
  }

  *(_BYTE *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = (*(uint64_t (**)(void))(**(void **)(a1 + 464) + 24LL))(*(void *)(a1 + 464));
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  char v28 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
  {
    int v29 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "@TileEvent, all, locked, %{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    int v47 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)int8x16_t v52 = 67240192;
    *(_DWORD *)&v52[4] = v47;
    LODWORD(v5sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "@TileEvent, all, locked, %{public}d",  v52,  v50);
    uint64_t v49 = (uint8_t *)v48;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)",  "%s\n",  v48);
    if (v49 != buf) {
      free(v49);
    }
  }

  int v30 = operator new(0x38uLL);
  sub_1010DDBC0(buf, "ExpiredLocationTimer");
  sub_1006B5FBC(v30, buf, sub_100C21C24, a1, *(void *)(a1 + 40), 1LL, 1.79769313e308, 1.79769313e308, 0.9);
  *(void *)(a1 + 24sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v30;
  double v31 = (*(double (**)(void))(**(void **)(a1 + 464) + 56LL))(*(void *)(a1 + 464));
  sub_100C21DF4(a1, v31);
  char v32 = operator new(0x78uLL);
  sub_100E74504(v32, *(void *)(a1 + 40), sub_100C22240, a1);
  uint64_t v33 = *(void *)(a1 + 160);
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = v32;
  if (v33)
  {
    (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
    char v32 = *(_BYTE **)(a1 + 160);
  }

  v32[80] = 1;
  *(void *)(a1 + 136) = "Small";
  __int128 v34 = operator new(0x78uLL);
  sub_100E74504(v34, *(void *)(a1 + 40), sub_100C22240, a1);
  uint64_t v35 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = v34;
  if (v35)
  {
    (*(void (**)(uint64_t))(*(void *)v35 + 8LL))(v35);
    __int128 v34 = *(_BYTE **)(a1 + 192);
  }

  v34[80] = 0;
  *(void *)(a1 + 168) = "Large";
  return a1;
}

void sub_100C1F758( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  uint64_t v29 = *(void *)(v24 + 464);
  *(void *)(v24 + 464) = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  uint64_t v30 = *(void *)(v24 + 192);
  *(void *)(v24 + 192) = 0LL;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  uint64_t v31 = *(void *)(v24 + 160);
  *(void *)(v24 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8LL))(v31);
  }
  sub_100603BE4(v25, *(void **)(v24 + 120));
  sub_100C224CC(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_100C1F880(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_1018791E8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = [a3 silo];
  *(void *)(a1 + memset(v19, 0, 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100C1F900(_Unwind_Exception *exception_object)
{
}

void sub_100C1F91C(uint64_t a1@<X0>, void *a2@<X8>)
{
  char v150 = (*(uint64_t (**)(void))(**(void **)(a1 + 464) + 40LL))(*(void *)(a1 + 464));
  char v149 = 1;
  sub_1002F0B04(buf);
  sub_1002A6F64(*(uint64_t *)buf, "AppTilesActive", (BOOL *)&v150);
  uint64_t v4 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v5 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v7 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v150;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "TILE: isAppTilesActive, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v150;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: isAppTilesActive, %d",  &__dst);
    double v101 = (char *)v100;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v100);
    if (v101 != buf) {
      free(v101);
    }
  }

  sub_1002F0B04(buf);
  sub_1002A6F64(*(uint64_t *)buf, "TilePreloadManifestTilesActive", (BOOL *)&v149);
  uint64_t v8 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    double v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v11 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v149;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "TILE: isTilePreloadManifestActive, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v149;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: isTilePreloadManifestActive, %d",  &__dst);
    __int128 v103 = (char *)v102;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v102);
    if (v103 != buf) {
      free(v103);
    }
  }

  sub_100C225F4();
  if (byte_10199AEB0[23] < 0) {
    sub_1010DD48C(&__dst, *(void **)byte_10199AEB0, *(unint64_t *)&byte_10199AEB0[8]);
  }
  else {
    std::string __dst = *(std::string *)byte_10199AEB0;
  }
  sub_1002F0B04(buf);
  BOOL v141 = sub_1002A8560(*(uint64_t *)buf, "DEMTilesServerUrl", &__dst);
  uint64_t v12 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  double v143 = a2;
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  int v15 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    p_dst = &__dst;
    if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136380931;
    *(void *)&uint8_t buf[4] = p_dst;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&_BYTE buf[14] = v141;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "TILE: defaultDemTilesServerUrl, %{private}s, overridden, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    uint64_t v104 = &__dst;
    if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v104 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    LODWORD(v157.__r_.__value_.__l.__data_) = 136380931;
    *(std::string::size_type *)((char *)v157.__r_.__value_.__r.__words + 4) = (std::string::size_type)v104;
    WORD2(v157.__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&v157.__r_.__value_.__r.__words[1] + 6) = v141;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TILE: defaultDemTilesServerUrl, %{private}s, overridden, %{public}d",  &v157,  18);
    int v106 = (char *)v105;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v105);
    if (v106 != buf) {
      free(v106);
    }
  }

  sub_100C22688();
  if (byte_10199AF00[23] < 0) {
    sub_1010DD48C(&v157, *(void **)byte_10199AF00, *(unint64_t *)&byte_10199AF00[8]);
  }
  else {
    std::string v157 = *(std::string *)byte_10199AF00;
  }
  sub_1002F0B04(buf);
  BOOL v140 = sub_1002A8560(*(uint64_t *)buf, "HrseTilesServerUrl", &v157);
  __int16 v17 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v18 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  int v20 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    __int16 v21 = &v157;
    if ((v157.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v21 = (std::string *)v157.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136380931;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&_BYTE buf[14] = v140;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "TILE: defaultHrseTilesServerUrl, %{private}s, overridden, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    int v107 = &v157;
    if ((v157.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v107 = (std::string *)v157.__r_.__value_.__r.__words[0];
    }
    LODWORD(v156.__r_.__value_.__l.__data_) = 136380931;
    *(std::string::size_type *)((char *)v156.__r_.__value_.__r.__words + 4) = (std::string::size_type)v107;
    WORD2(v156.__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&v156.__r_.__value_.__r.__words[1] + 6) = v140;
    LODWORD(v137) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TILE: defaultHrseTilesServerUrl, %{private}s, overridden, %{public}d",  &v156,  v137);
    uint64_t v109 = (char *)v108;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v108);
    if (v109 != buf) {
      free(v109);
    }
  }

  sub_100C2271C();
  if (byte_10199AFA0[23] < 0) {
    sub_1010DD48C(&v156, *(void **)byte_10199AFA0, *(unint64_t *)&byte_10199AFA0[8]);
  }
  else {
    std::string v156 = *(std::string *)byte_10199AFA0;
  }
  sub_1002F0B04(buf);
  BOOL v139 = sub_1002A8560(*(uint64_t *)buf, "TilePreloadManifestServerUrl", &v156);
  double v22 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v23 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  uint64_t v25 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v26 = &v156;
    if ((v156.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v26 = (std::string *)v156.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136380931;
    *(void *)&uint8_t buf[4] = v26;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&_BYTE buf[14] = v139;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "TILE: defaultTilePreloadManifestServerUrl, %{private}s, overridden, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    __int16 v110 = &v156;
    if ((v156.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v110 = (std::string *)v156.__r_.__value_.__r.__words[0];
    }
    LODWORD(v155.__r_.__value_.__l.__data_) = 136380931;
    *(std::string::size_type *)((char *)v155.__r_.__value_.__r.__words + 4) = (std::string::size_type)v110;
    WORD2(v155.__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&v155.__r_.__value_.__r.__words[1] + 6) = v139;
    LODWORD(v137) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TILE: defaultTilePreloadManifestServerUrl, %{private}s, overridden, %{public}d",  &v155,  v137);
    uint64_t v112 = (char *)v111;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v111);
    if (v112 != buf) {
      free(v112);
    }
  }

  sub_100C227B0();
  if (byte_10199AFF0[23] < 0) {
    sub_1010DD48C(&v155, *(void **)byte_10199AFF0, *(unint64_t *)&byte_10199AFF0[8]);
  }
  else {
    std::string v155 = *(std::string *)byte_10199AFF0;
  }
  sub_1002F0B04(buf);
  BOOL v138 = sub_1002A8560(*(uint64_t *)buf, "TransitMacServerUrl", &v155);
  uint64_t v27 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    char v28 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  uint64_t v30 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v31 = &v155;
    if ((v155.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v31 = (std::string *)v155.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 136380931;
    *(void *)&uint8_t buf[4] = v31;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&_BYTE buf[14] = v138;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "TILE: defaultTransitMacTilesServerUrl, %{private}s, overridden, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    uint64_t v113 = &v155;
    if ((v155.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v113 = (std::string *)v155.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 __p = 136380931;
    *(void *)&__p[4] = v113;
    __int16 v152 = 1026;
    BOOL v153 = v138;
    LODWORD(v137) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TILE: defaultTransitMacTilesServerUrl, %{private}s, overridden, %{public}d",  __p,  v137);
    double v115 = (char *)v114;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v114);
    if (v115 != buf) {
      free(v115);
    }
  }

  sub_1002F0B04(buf);
  char v32 = (uint64_t *)(a1 + 208);
  sub_1002A82BC(*(uint64_t *)buf, "MaxTileAge", (void *)(a1 + 208));
  uint64_t v33 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    __int128 v34 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v36 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v37 = *v32;
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "TILE: fDefaultMaxTileAge, %.1lf", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v116 = *v32;
    *(_DWORD *)__int128 __p = 134217984;
    *(void *)&__p[4] = v116;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fDefaultMaxTileAge, %.1lf",  COERCE_DOUBLE(__p));
    __int16 v118 = (char *)v117;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v117);
    if (v118 != buf) {
      free(v118);
    }
  }

  sub_1002F0B04(buf);
  unint64_t v38 = (uint64_t *)(a1 + 216);
  sub_1002A82BC(*(uint64_t *)buf, "AncientTilesThreshold", (void *)(a1 + 216));
  double v39 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    char v40 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  __int128 v42 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v43 = *v38;
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v43;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "TILE: fDefaultMaxTileDataAge, %.1lf", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v119 = *v38;
    *(_DWORD *)__int128 __p = 134217984;
    *(void *)&__p[4] = v119;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fDefaultMaxTileDataAge, %.1lf",  COERCE_DOUBLE(__p));
    uint64_t v121 = (char *)v120;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v120);
    if (v121 != buf) {
      free(v121);
    }
  }

  sub_1002F0B04(buf);
  uint64_t v44 = (uint64_t *)(a1 + 224);
  sub_1002A82BC(*(uint64_t *)buf, "EncryptionGracePeriod", (void *)(a1 + 224));
  BOOL v45 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v46 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  __int128 v48 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v49 = *v44;
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v49;
    _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEBUG,  "TILE: fDefaultEncryptionGracePeriod, %.1lf",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v122 = *v44;
    *(_DWORD *)__int128 __p = 134217984;
    *(void *)&__p[4] = v122;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fDefaultEncryptionGracePeriod, %.1lf",  COERCE_DOUBLE(__p));
    double v124 = (char *)v123;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v123);
    if (v124 != buf) {
      free(v124);
    }
  }

  sub_1002F0B04(buf);
  uint64_t v50 = (int *)(a1 + 432);
  sub_1002A7CB0(*(uint64_t *)buf, "MaxNumOfTiles", (_DWORD *)(a1 + 432));
  unsigned int v51 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    int8x16_t v52 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  unsigned int v54 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v55 = *v50;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "TILE: fMaxNumOfTiles, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v125 = *v50;
    *(_DWORD *)__int128 __p = 67109120;
    *(_DWORD *)&__p[4] = v125;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fMaxNumOfTiles, %d",  __p);
    __int128 v127 = (char *)v126;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()",  "%s\n",  v126);
    if (v127 != buf) {
      free(v127);
    }
  }

  sub_1002F0B04(buf);
  uint64x2_t v56 = (BOOL *)(a1 + 440);
  char v57 = sub_1002A6F64(*(uint64_t *)buf, "DisableTilesWhileLocked", (BOOL *)(a1 + 440));
  char v58 = v57;
  int v59 = *(std::__shared_weak_count **)&buf[8];
  if (!*(void *)&buf[8]) {
    goto LABEL_125;
  }
  char v60 = (unint64_t *)(*(void *)&buf[8] + 8LL);
  do
    unint64_t v61 = __ldaxr(v60);
  while (__stlxr(v61 - 1, v60));
  if (v61)
  {
LABEL_125:
    if ((v57 & 1) != 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }

  ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
  std::__shared_weak_count::__release_weak(v59);
  if ((v58 & 1) == 0)
  {
LABEL_126:
    sub_1004F2598();
    *uint64x2_t v56 = sub_1004F7B54();
  }

void sub_100C21584( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *a44, uint64_t a45, int a46, __int16 a47, char a48, char a49, uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C217CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v14 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLTilesManager::traverseAllTilesSets");
  for (unsigned int i = 0; i != 13; ++i)
  {
    if ((i & 0x7FFFFFF7) - 1 <= 1)
    {
      uint64_t v7 = sub_100C29628(a1, i);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      uint64_t v8 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = v7 + 8;
        *(_DWORD *)uint64_t buf = 136315394;
        uint64_t v20 = a2;
        __int16 v21 = 2080;
        uint64_t v22 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: performing, sAction, %s, tilesSet, %s",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        uint64_t v10 = v7 + 8;
        int v15 = 136315394;
        uint64_t v16 = a2;
        __int16 v17 = 2080;
        uint64_t v18 = v10;
        LODWORD(v13) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: performing, sAction, %s, tilesSet, %s",  (const char *)&v15,  v13);
        uint64_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::traverseAllTilesSets(const char *, CLTileManagerTraverseTilesSetBlock)",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v7);
    }
  }
}

void sub_100C21A44(uint64_t a1, uint64_t a2)
{
  *(double *)(*(void *)(a1 + 32) + 232LL) = fmin(*(double *)(*(void *)(a1 + 32) + 232LL), *(double *)(a2 + 136));
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v3 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = a2 + 8;
    *(_DWORD *)uint64_t buf = 136315138;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "TILE: registered, tilesSet, %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v6 = a2 + 8;
    uint64_t v5 = v7;
    int v10 = 136315138;
    uint64_t v11 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: registered, tilesSet, %s",  (const char *)&v10);
    uint64_t v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CL TilesSetCollection>)_block_invoke",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

void sub_100C21C24(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101879138);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLTilesManager::onPCTimerFired",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101879138);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLTilesManager::onPCTimerFired, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100C324F8(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_100C21DD4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100C21DF4(uint64_t a1, double a2)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "TILE: listAvailableFilesAllTypes, start", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    v17[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: listAvailableFilesAllTypes, start",  v17,  2);
    uint64_t v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  int v5 = *(unsigned __int8 *)(a1 + 200);
  if (*(_BYTE *)(a1 + 200))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v6 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TILE: listAvailableFilesAllTypes, can't list tiles while locked, wait for unlock",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      v17[0] = 0;
      LODWORD(v14) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: listAvailableFilesAllTypes, can't list tiles while locked, wait for unlock",  v17,  v14);
LABEL_15:
      uint64_t v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  else if (!*(_BYTE *)(a1 + 201))
  {
    if ((byte_10199AE38 & 1) != 0) {
      goto LABEL_20;
    }
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472LL;
    _DWORD v16[2] = sub_100C2AEAC;
    v16[3] = &unk_101878EE8;
    v16[4] = &stru_101878EC0;
    void v16[5] = a1;
    sub_100C217CC(a1, (uint64_t)"listerSetClass", (uint64_t)v16);
    byte_10199AE38 = 1;
    if (!*(_BYTE *)(a1 + 201))
    {
LABEL_20:
      int v9 = *(void **)(a1 + 40);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      void v15[2] = sub_100C2B724;
      void v15[3] = &unk_101830538;
      v15[4] = a1;
      *(double *)&v15[5] = a2;
      [v9 async:v15];
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      __int16 v10 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TILE: listAvailableFilesAllTypes, done",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        v17[0] = 0;
        LODWORD(v14) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: listAvailableFilesAllTypes, done",  v17,  v14);
        goto LABEL_15;
      }
    }
  }

  return v5 == 0;
}

id sub_100C22240(uint64_t a1, int a2, uint64_t a3)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v6 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v15 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TILE: _tileDownloadCompleted, success, %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    v13[0] = 67109120;
    v13[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: _tileDownloadCompleted, success, %d",  v13);
    __int16 v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLTilesManager::_tileDownloadCompleted(CLFileDownload *, BOOL, void *)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  char v7 = *(void **)(a3 + 40);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_100C2FA28;
  uint64_t v11[3] = &unk_101861AD0;
  char v12 = a2;
  _DWORD v11[4] = a3;
  v11[5] = a1;
  v11[6] = a3;
  return [v7 async:v11];
}

uint64_t sub_100C2243C(uint64_t a1)
{
  return a1;
}

uint64_t sub_100C22484(uint64_t a1)
{
  return a1;
}

uint64_t sub_100C224CC(uint64_t a1)
{
  *(void *)a1 = off_1018791E8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100C22540(uint64_t a1, void *a2)
{
  v6[0] = 0;
  char v7 = 0;
  sub_100C1EC68(a1, a2, &v8, (uint64_t)v6);
  if (v7)
  {
    int v9 = (void **)v6;
    sub_1009708B4(&v9);
  }

  uint64_t v4 = v8;
  uint64_t v8 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return a1;
}

void sub_100C225C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13)
{
  if (a12)
  {
    *(void *)(v13 - 24) = &a9;
    sub_1009708B4((void ***)(v13 - 24));
  }

  sub_1012549C0(&a13);
  _Unwind_Resume(a1);
}

__int128 *sub_100C225F4()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AEC8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AEC8))
  {
    xmmword_10199AEB0 = 0uLL;
    unk_10199AEC0 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199AEB0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AEC8);
  }

  if (qword_10199AED0 != -1) {
    dispatch_once(&qword_10199AED0, &stru_101878F90);
  }
  return &xmmword_10199AEB0;
}

__int128 *sub_100C22688()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AF18);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AF18))
  {
    xmmword_10199AF00 = 0uLL;
    unk_10199AF10 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199AF00, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AF18);
  }

  if (qword_10199AF20 != -1) {
    dispatch_once(&qword_10199AF20, &stru_101878FD0);
  }
  return &xmmword_10199AF00;
}

__int128 *sub_100C2271C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AFB8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AFB8))
  {
    xmmword_10199AFA0 = 0uLL;
    unk_10199AFB0 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199AFA0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AFB8);
  }

  if (qword_10199AFC0 != -1) {
    dispatch_once(&qword_10199AFC0, &stru_101879050);
  }
  return &xmmword_10199AFA0;
}

__int128 *sub_100C227B0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199B008);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199B008))
  {
    xmmword_10199AFF0 = 0uLL;
    unk_10199B000 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199AFF0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199B008);
  }

  if (qword_10199B010 != -1) {
    dispatch_once(&qword_10199B010, &stru_101879090);
  }
  return &xmmword_10199AFF0;
}

uint64_t *sub_100C22844()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AEA0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AEA0))
  {
    qword_10199AE88 = 0LL;
    unk_10199AE90 = 0LL;
    qword_10199AE98 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AE88, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AEA0);
  }

  if (qword_10199AEA8 != -1) {
    dispatch_once(&qword_10199AEA8, &stru_101878F70);
  }
  return &qword_10199AE88;
}

uint64_t *sub_100C228D8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AEF0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AEF0))
  {
    qword_10199AED8 = 0LL;
    unk_10199AEE0 = 0LL;
    qword_10199AEE8 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AED8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AEF0);
  }

  if (qword_10199AEF8 != -1) {
    dispatch_once(&qword_10199AEF8, &stru_101878FB0);
  }
  return &qword_10199AED8;
}

uint64_t *sub_100C2296C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AF40);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AF40))
  {
    qword_10199AF28 = 0LL;
    unk_10199AF30 = 0LL;
    qword_10199AF38 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AF28, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AF40);
  }

  if (qword_10199AF48 != -1) {
    dispatch_once(&qword_10199AF48, &stru_101878FF0);
  }
  return &qword_10199AF28;
}

void sub_100C22A00(uint64_t a1@<X0>, std::string::size_type a2@<X8>)
{
  uint64_t v3 = (__CFString *)(*(uint64_t (**)(void))(**(void **)(a1 + 464) + 16LL))(*(void *)(a1 + 464));
  if (v3 && (uint64_t v4 = v3, -[__CFString length](v3, "length")))
  {
    id v5 = -[__CFString rangeOfCharacterFromSet:]( v4,  "rangeOfCharacterFromSet:",  -[NSCharacterSet invertedSet]( +[NSCharacterSet decimalDigitCharacterSet](&OBJC_CLASS___NSCharacterSet, "decimalDigitCharacterSet"),  "invertedSet"));
    if (v5 != (id)0x7FFFFFFFFFFFFFFFLL) {
      uint64_t v4 = (__CFString *)-[__CFString substringToIndex:](v4, "substringToIndex:", v5);
    }
  }

  else
  {
    uint64_t v4 = @"143441";
  }

  sub_1010DDBC0(v23, (char *)-[__CFString UTF8String](v4, "UTF8String"));
  sub_1004F2598();
  else {
    uint64_t v6 = "1";
  }
  sub_1010DDBC0(__p, v6);
  sub_100C348B0();
  sub_10010B8E0((const void **)&qword_10199AF50, (const void **)__p, (uint64_t)&v20);
  char v7 = std::string::append(&v20, "/");
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__l.__cap_ = v7->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  if ((v24 & 0x80u) == 0) {
    int v9 = v23;
  }
  else {
    int v9 = (void **)v23[0];
  }
  if ((v24 & 0x80u) == 0) {
    std::string::size_type v10 = v24;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)v23[1];
  }
  uint64_t v11 = std::string::append(&v26, (const std::string::value_type *)v9, v10);
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__l.__cap_ = v11->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v13 = std::string::append(&v25, "/v1");
  __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  *(void *)(a2 + 16) = v13->__r_.__value_.__l.__cap_;
  *(_OWORD *)a2 = v14;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  int v15 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    else {
      std::string::size_type v16 = *(void *)a2;
    }
    LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "TILE: fullAppTilesServerUrl, %s",  (uint8_t *)&v25,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v25, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    else {
      std::string::size_type v17 = *(void *)a2;
    }
    LODWORD(v26.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v26.__r_.__value_.__r.__words + 4) = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v25,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: fullAppTilesServerUrl, %s",  (const char *)&v26);
    unint64_t v19 = (std::string *)v18;
    sub_10029211C("Generic", 1LL, 0, 2LL, "std::string CLTilesManager::composeFullAppTilesServerUrl()", "%s\n", v18);
    if (v19 != &v25) {
      free(v19);
    }
  }

  if (v22 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100C22D60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100C22DFC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AF90);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AF90))
  {
    qword_10199AF78 = 0LL;
    unk_10199AF80 = 0LL;
    qword_10199AF88 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AF78, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AF90);
  }

  if (qword_10199AF98 != -1) {
    dispatch_once(&qword_10199AF98, &stru_101879030);
  }
  return &qword_10199AF78;
}

uint64_t *sub_100C22E90()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_10199AFE0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_10199AFE0))
  {
    qword_10199AFC8 = 0LL;
    unk_10199AFD0 = 0LL;
    qword_10199AFD8 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199AFC8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199AFE0);
  }

  if (qword_10199AFE8 != -1) {
    dispatch_once(&qword_10199AFE8, &stru_101879070);
  }
  return &qword_10199AFC8;
}

uint64_t sub_100C22F24(uint64_t a1)
{
  *(void *)a1 = &off_101878D90;
  sub_100C3336C((void *)a1);
  sub_1001B4C40((void *)(a1 + 624));
  sub_1001B4C40((void *)(a1 + 528));
  uint64_t v6 = (void **)(a1 + 504);
  sub_1009708B4(&v6);
  uint64_t v2 = *(void *)(a1 + 464);
  *(void *)(a1 + 464) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 160);
  *(void *)(a1 + 16sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_100603BE4(a1 + 112, *(void **)(a1 + 120));
  return sub_100C224CC(a1);
}

void sub_100C23024(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100C22F24(a1);
  operator delete(v1);
}

void sub_100C23038(uint64_t a1, uint64_t a2, int *a3, int *a4)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  char v7 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v8 = *a3;
    *(_DWORD *)uint64_t buf = 134218240;
    *(void *)unint64_t v38 = a1;
    *(_WORD *)&v38[8] = 1024;
    v39[0] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: onDataProtectionNotification, %p, notification, %d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v21 = *a3;
    int v34 = 134218240;
    *(void *)uint64_t v35 = a1;
    *(_WORD *)&v35[8] = 1024;
    v36[0] = v21;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: onDataProtectionNotification, %p, notification, %d",  &v34,  18);
    unint64_t v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const C LDataProtectionManager_Type::NotificationData &)",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

  (*(void (**)(void))(**(void **)(a1 + 464) + 56LL))(*(void *)(a1 + 464));
  if (!*a3)
  {
    double v10 = v9;
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v11 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *(unsigned __int8 *)(a1 + 200);
      int v13 = *a4;
      BOOL v14 = *a4 != 1;
      *(_DWORD *)uint64_t buf = 67109632;
      *(_DWORD *)unint64_t v38 = v12;
      *(_WORD *)&v38[4] = 1024;
      *(_DWORD *)&v38[6] = v14;
      LOWORD(v39[0]) = 1024;
      *(_DWORD *)((char *)v39 + 2) = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "TILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      int v24 = *a4;
      BOOL v25 = *a4 != 1;
      *(_WORD *)&v35[4] = 1024;
      *(_DWORD *)&v35[6] = v25;
      LOWORD(v36[0]) = 1024;
      *(_DWORD *)((char *)v36 + 2) = v24;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d",  &v34,  20,  67109632);
      uint64_t v27 = (uint8_t *)v26;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)",  "%s\n",  v26);
      if (v27 != buf) {
        free(v27);
      }
    }

    int v15 = *(unsigned __int8 *)(a1 + 200);
    BOOL v16 = *a4 == 1;
    *(_BYTE *)(a1 + 20sub_100222B94(v15, (uint64_t)"CMHealthColdStorageManager.cleanUpDatabase", 0) = *a4 != 1;
    if (v16)
    {
      sub_100C21DF4(a1, v10);
      int v17 = *(unsigned __int8 *)(a1 + 200);
    }

    else
    {
      int v17 = 1;
    }

    if (v15 != v17)
    {
      sub_100C236C8(a1, v10);
      if (*(_BYTE *)(a1 + 200))
      {
        sub_100C23E74(a1, (std::string::size_type)"onDataProtectionNotification", a1 + 248, 1);
      }

      else
      {
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        uint64_t v18 = (os_log_s *)qword_101934838;
        if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "TILE: updateProtectionClass, skip on unlock",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934830 != -1) {
            dispatch_once(&qword_101934830, &stru_101879178);
          }
          LOWORD(v34) = 0;
          LODWORD(v33) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: updateProtectionClass, skip on unlock",  &v34,  v33);
          char v32 = (uint8_t *)v31;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, c onst CLDataProtectionManager_Type::NotificationData &)",  "%s\n",  v31);
          if (v32 != buf) {
            free(v32);
          }
        }

        sub_100C2424C(a1);
        sub_100C217CC(a1, (uint64_t)"onDataProtectionNotification.cleanUnknownCache", (uint64_t)&stru_101878E60);
      }

      sub_100C24408(a1, v10);
    }

    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    unint64_t v19 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
    {
      int v20 = *(unsigned __int8 *)(a1 + 200);
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)unint64_t v38 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "@TileEvent, all, locked, %{public}d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101879158);
      }
      int v28 = *(unsigned __int8 *)(a1 + 200);
      int v34 = 67240192;
      *(_DWORD *)uint64_t v35 = v28;
      LODWORD(v33) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "@TileEvent, all, locked, %{public}d",  &v34,  v33);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }
  }

void sub_100C236C8(uint64_t a1, double a2)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: cleanUpDownloadList, start, isLocked, %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v27 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)uint64_t v37 = 67109120;
    *(_DWORD *)&v37[4] = v27;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: cleanUpDownloadList, start, isLocked, %d",  v37);
    unint64_t v29 = (char *)v28;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::cleanUpDownloadList(CFAbsoluteTime)", "%s\n", v28);
    if (v29 != buf) {
      free(v29);
    }
  }

  if (*(void *)(a1 + 128) >= (unint64_t)*(int *)(a1 + 436))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v6 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(a1 + 128);
      *(_DWORD *)uint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TILES: cleanUpDownloadList, download list is too large, %lu",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      uint64_t v33 = *(void *)(a1 + 128);
      *(_DWORD *)uint64_t v37 = 134217984;
      *(void *)&v37[4] = v33;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILES: cleanUpDownloadList, download list is too large, %lu",  v37);
      uint64_t v35 = (char *)v34;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::cleanUpDownloadList(CFAbsoluteTime)", "%s\n", v34);
      if (v35 != buf) {
        free(v35);
      }
    }

    sub_100C26B54(a1);
  }

  int v36 = 0;
  if (!*(_BYTE *)(a1 + 200))
  {
    int v8 = *(uint64_t **)(a1 + 112);
    if (v8 != (uint64_t *)(a1 + 120))
    {
      int v36 = 0;
      do
      {
        double v9 = (uint64_t *)v8[1];
        double v10 = v8;
        if (v9)
        {
          do
          {
            uint64_t v11 = v9;
            double v9 = (uint64_t *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            uint64_t v11 = (uint64_t *)v10[2];
            BOOL v12 = *v11 == (void)v10;
            double v10 = v11;
          }

          while (!v12);
        }

        int v13 = (unsigned int *)v8[10];
        uint64_t v14 = sub_100C29628(a1, v13[12]);
        int v15 = *(_DWORD *)(a1 + 424);
        BOOL v16 = sub_10060238C(v14 + 184, v13 + 12);
        if (v16)
        {
          uint64_t v17 = sub_1006025CC(v14 + 184, v13 + 12);
          BOOL v18 = sub_100C0D05C(v17, v15 > 1, *(float *)(v14 + 128), a2);
        }

        else
        {
          BOOL v18 = 0;
        }

        if (!sub_100C0DB30((uint64_t)v13) && !v18 && (v16 & sub_100C0CCC8((uint64_t)v13)) == 1)
        {
          if (qword_101934830 != -1) {
            dispatch_once(&qword_101934830, &stru_101879178);
          }
          unint64_t v19 = (os_log_s *)qword_101934838;
          if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
          {
            (*(void (**)(_BYTE *__return_ptr, unsigned int *))(*(void *)v13 + 16LL))(buf, v13);
            int v20 = buf;
            if (v42 < 0) {
              int v20 = *(_BYTE **)buf;
            }
            *(_DWORD *)uint64_t v37 = 136315138;
            *(void *)&v37[4] = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "TILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download",  v37,  0xCu);
            if (v42 < 0) {
              operator delete(*(void **)buf);
            }
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934830 != -1) {
              dispatch_once(&qword_101934830, &stru_101879178);
            }
            uint64_t v21 = qword_101934838;
            (*(void (**)(_BYTE *__return_ptr, unsigned int *))(*(void *)v13 + 16LL))(v37, v13);
            char v22 = v37;
            if (v38 < 0) {
              char v22 = *(_BYTE **)v37;
            }
            int v39 = 136315138;
            char v40 = v22;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "TILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download",  (const char *)&v39);
            int v24 = v23;
            if (v38 < 0) {
              operator delete(*(void **)v37);
            }
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::cleanUpDownloadList(CFAbsoluteTime)",  "%s\n",  v24);
            if (v24 != buf) {
              free(v24);
            }
          }

          sub_1000087E8((uint64_t **)(a1 + 112), v8);
          sub_1006035CC((uint64_t)(v8 + 4));
          operator delete(v8);
          ++v36;
        }

        if (*(_BYTE *)(a1 + 200)) {
          break;
        }
        int v8 = v11;
      }

      while (v11 != (uint64_t *)(a1 + 120));
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  BOOL v25 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v26 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)uint64_t buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v26;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v36;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "TILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v30 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)uint64_t v37 = 67109376;
    *(_DWORD *)&v37[4] = v30;
    *(_WORD *)&v37[8] = 1024;
    *(_DWORD *)&v37[10] = v36;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u",  v37,  14);
    char v32 = (char *)v31;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::cleanUpDownloadList(CFAbsoluteTime)", "%s\n", v31);
    if (v32 != buf) {
      free(v32);
    }
  }

void sub_100C23E74(uint64_t a1, std::string::size_type a2, uint64_t a3, int a4)
{
  uint64_t v17 = 0LL;
  BOOL v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  int v20 = 0;
  if (*(_BYTE *)(a1 + 200))
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472LL;
    void v15[2] = sub_100C303BC;
    void v15[3] = &unk_101878F10;
    void v15[6] = a3;
    v15[7] = a2;
    char v16 = a4;
    v15[4] = &v17;
    v15[5] = a1;
    sub_100C217CC(a1, (uint64_t)"updateProtectionClass", (uint64_t)v15);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v7 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *((_DWORD *)v18 + 6);
      *(_DWORD *)uint64_t buf = 67109376;
      int v25 = a4;
      __int16 v26 = 1024;
      int v27 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: updateProtectionClass, done, isAboutToLock, %d, numOfUnProtectedTiles, %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      int v10 = *((_DWORD *)v18 + 6);
      v21[0] = 67109376;
      v21[1] = a4;
      __int16 v22 = 1024;
      int v23 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: updateProtectionClass, done, isAboutToLock, %d, numOfUnProtectedTiles, %d",  v21,  14);
      BOOL v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, BOOL)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    if (*(_BYTE *)(a1 + 200) && *((_DWORD *)v18 + 6)) {
      sub_100C31DEC(a1, a2);
    }
    else {
      sub_100C2424C(a1);
    }
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    double v9 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning TILE: updateProtectionClass, called on when not locked",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      LOWORD(v21[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  0LL,  "#Warning TILE: updateProtectionClass, called on when not locked",  v21,  2);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, BOOL)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  _Block_object_dispose(&v17, 8);
}

void sub_100C24228( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100C2424C(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "TILE: cancelExpiredLocationTimer", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: cancelExpiredLocationTimer",  v6,  2);
    int v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::cancelExpiredLocationTimer()", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  id result = *(id *)(a1 + 240);
  if (result) {
    return sub_1006B6294((uint64_t)result);
  }
  return result;
}

void sub_100C243E8(id a1, void *a2)
{
  if (*(_BYTE *)a2)
  {
    uint64_t v2 = *((void *)a2 + 38);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 32LL))(v2);
    }
  }

void sub_100C24408(uint64_t a1, double a2)
{
  char v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 464) + 32LL))(*(void *)(a1 + 464));
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 464) + 48LL))(*(void *)(a1 + 464)) & 1) == 0)
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v10 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TILE: checkDownloadSchedule, location services disabled - no tile downloads",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      *(_WORD *)char v132 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: checkDownloadSchedule, location services disabled - no tile downloads",  v132,  2);
      double v9 = (char *)v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)", "%s\n", v11);
      goto LABEL_264;
    }

    return;
  }

  if (!*(_BYTE *)(a1 + 201))
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_101934830 != -1) {
LABEL_237:
    }
      dispatch_once(&qword_101934830, &stru_101879178);
    uint64_t v14 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v15 = *(unsigned __int8 *)(a1 + 200);
      *(_DWORD *)uint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "TILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      int v16 = *(unsigned __int8 *)(a1 + 200);
      *(_DWORD *)char v132 = 67109120;
      *(_DWORD *)&v132[4] = v16;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %d",  v132);
      double v9 = (char *)v17;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)", "%s\n", v17);
      goto LABEL_264;
    }

    return;
  }

  if (*(_BYTE *)(a1 + 200) && *(_BYTE *)(a1 + 440))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v7 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: checkDownloadSchedule, no tiles while locked",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      *(_WORD *)char v132 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: checkDownloadSchedule, no tiles while locked",  v132,  2);
      double v9 = (char *)v8;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)", "%s\n", v8);
LABEL_264:
      if (v9 != buf) {
        free(v9);
      }
      return;
    }

    return;
  }

  int v12 = *(_DWORD *)(a1 + 424);
  if (v12 > 1)
  {
    BOOL v13 = 1;
    BOOL v126 = 1;
LABEL_44:
    BOOL v124 = v13;
    goto LABEL_45;
  }

  BOOL v126 = *(_BYTE *)(a1 + 496) != 0;
  if (v12 == 1)
  {
    if ((v5 & 1) == 0)
    {
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      std::stringbuf::string_type v97 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEBUG,  "TILE: checkDownloadSchedule, no download on none broadband cellular connections",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        *(_WORD *)char v132 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: checkDownloadSchedule, no download on none broadband cellular connections",  v132,  2);
        double v9 = (char *)v98;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)", "%s\n", v98);
        goto LABEL_264;
      }

      return;
    }

    BOOL v13 = 1;
    goto LABEL_44;
  }

  if (v12)
  {
    BOOL v13 = *(_BYTE *)(a1 + 496) != 0;
    goto LABEL_44;
  }

  BOOL v124 = *(_BYTE *)(a1 + 496) != 0;
  if (!*(_BYTE *)(a1 + 496))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    BOOL v18 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "TILE: checkDownloadSchedule, no data connectivity, avoiding downloads",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101879158);
      }
      *(_WORD *)char v132 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "TILE: checkDownloadSchedule, no data connectivity, avoiding downloads",  v132,  2);
      double v9 = (char *)v19;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)", "%s\n", v19);
      goto LABEL_264;
    }

    return;
  }

void sub_100C2637C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a64 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

id sub_100C263DC(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    uint64_t v12 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "TILE: onCleanupAgedTiles, %p", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v9 = 134217984;
    uint64_t v10 = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: onCleanupAgedTiles, %p",  &v9);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::onCleanupAgedTiles()", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  double v3 = (*(double (**)(void))(**(void **)(a1 + 464) + 56LL))(*(void *)(a1 + 464));
  uint64_t v4 = *(void **)(a1 + 40);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  __int128 v8[2] = sub_100C265D4;
  _OWORD v8[3] = &unk_101830538;
  _DWORD v8[4] = a1;
  *(double *)&void v8[5] = v3;
  return [v4 async:v8];
}

void sub_100C265D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100C26670(v2, *(double *)(a1 + 40));
  sub_100C217CC(v2, (uint64_t)"onCleanupAgedTiles", (uint64_t)&stru_101878E80);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_100C2C930;
  v3[3] = &unk_101838B18;
  void v3[4] = v2;
  sub_100C217CC(v2, (uint64_t)"refreshTilesDataIfNeeded", (uint64_t)v3);
  sub_100C24408(v2, *(double *)(a1 + 40));
}

uint64_t *sub_100C26670(uint64_t a1, double a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  v9[2] = sub_100C29A1C;
  void v9[3] = &unk_101840280;
  _DWORD v9[4] = a1;
  *(double *)&void v9[5] = a2;
  sub_100C217CC(a1, (uint64_t)"deleteAgedTiles", (uint64_t)v9);
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "TILE: deleteAgedTiles, fTilesToDownload", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: deleteAgedTiles, fTilesToDownload",  v8,  2);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::deleteAgedTiles(CFAbsoluteTime)", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return sub_100C27E28(a1, a1 + 112, a2);
}

void sub_100C26860(id a1, void *a2)
{
  uint64_t v3 = *((void *)a2 + 37);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40LL))(v3);
  }
  uint64_t v4 = *((void *)a2 + 38);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
  }
}

id *sub_100C268AC(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    int v16 = "clearLocationInformationTiles";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "TILE: %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v13 = 136446210;
    uint64_t v14 = "clearLocationInformationTiles";
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: %{public}s",  &v13,  12);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::clearLocationInformation()", "%s\n", v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  sub_100C26B54(a1);
  *(_DWORD *)(a1 + 2memset(v19, 0, 48) = 0xFFFF;
  *(void *)(a1 + 26sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = 0LL;
  *(void *)(a1 + 252) = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }

  *(_OWORD *)(a1 + 26_Block_object_dispose(va, 8) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 284) = _Q1;
  *(_OWORD *)(a1 + 30sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = _Q1;
  *(_OWORD *)(a1 + 316) = _Q1;
  *(_DWORD *)(a1 + 332) = 0;
  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 352) = 0LL;
  *(void *)(a1 + 336) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 36sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = 0;
  *(void *)(a1 + 364) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 372) = 0x7FFFFFFF;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 376) = 0LL;
  *(_BYTE *)(a1 + 40sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = 0;
  *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 416) = 0LL;
  sub_100BD8374(a1 + 472);
  sub_1002581DC(a1 + 624);
  sub_100606EB8(a1 + 528);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_100C26E08;
  uint64_t v11[3] = &unk_101838B18;
  _DWORD v11[4] = a1;
  sub_100C217CC(a1, (uint64_t)"clearLocationInformationTiles", (uint64_t)v11);
  return sub_1001BA1BC(v12);
}

void sub_100C26B34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t *sub_100C26B54(uint64_t a1)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  _DWORD v16[2] = sub_100C29C4C;
  v16[3] = &unk_101862770;
  v16[4] = a1;
  v17[0] = mach_absolute_time();
  v17[1] = (uint64_t)v16;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 128);
    *(_DWORD *)uint64_t buf = 134217984;
    uint64_t v21 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "TILE: cancelAllDownloads, planned, %lu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v13 = *(void *)(a1 + 128);
    int v18 = 134217984;
    uint64_t v19 = v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: cancelAllDownloads, planned, %lu",  &v18);
    int v15 = (uint8_t *)v14;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTilesManager::cancelAllDownloads()", "%s\n", v14);
    if (v15 != buf) {
      free(v15);
    }
  }

  uint64_t v4 = *(void *)(a1 + 192);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
    *(_BYTE *)(a1 + 176) = 0;
  }

  uint64_t v5 = *(void *)(a1 + 160);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    *(_BYTE *)(a1 + 144) = 0;
  }

  __n128 v6 = *(void **)(a1 + 112);
  uint64_t v7 = (void *)(a1 + 120);
  if (v6 != (void *)(a1 + 120))
  {
    do
    {
      uint64_t v8 = v6[10];
      sub_100C0FD9C(v8);
      sub_100C100B4(v8);
      int v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          uint64_t v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          __n128 v6 = v10;
        }

        while (!v11);
      }

      __n128 v6 = v10;
    }

    while (v10 != v7);
  }

  sub_100603BE4(a1 + 112, *(void **)(a1 + 120));
  *(void *)(a1 + 12sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = 0LL;
  *(void *)(a1 + 1sub_100231C10(v1 + 28) = 0LL;
  *(void *)(a1 + 112) = v7;
  return sub_1011F6BE4(v17);
}

void sub_100C26DEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100C26E08(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 296);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
  }
  uint64_t result = *(void *)(a2 + 304);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 32LL))(result);
  }
  return result;
}

uint64_t *sub_100C26E64(uint64_t a1, int a2, unsigned int a3)
{
  if ((a3 & 0xFFFFFFF7) - 1 >= 2)
  {
    sub_1012666D4();
    __break(1u);
  }

  else
  {
    unsigned int v6 = a3;
    int v5 = a2;
    uint64_t v4 = a1;
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 3221225472LL;
    v48[2] = sub_100C29D84;
    v48[3] = &unk_101862750;
    unsigned int v49 = a3;
    v50[0] = mach_absolute_time();
    v50[1] = (uint64_t)v48;
    uint64_t v7 = sub_100C29628(v4, v6);
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_101934830 == -1) {
      goto LABEL_3;
    }
  }

  dispatch_once(&qword_101934830, &stru_101879178);
LABEL_3:
  uint64_t v8 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = v7 + 8;
    *(_DWORD *)uint64_t buf = 67109378;
    *(_DWORD *)char v58 = v6;
    *(_WORD *)&v58[4] = 2080;
    *(void *)&v58[6] = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: removeAllTiles, cleaning map, %d, %s",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    uint64_t v36 = v7 + 8;
    int v51 = 67109378;
    *(_DWORD *)int v52 = v6;
    *(_WORD *)&v52[4] = 2080;
    *(void *)&v52[6] = v36;
    LODWORD(v46) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: removeAllTiles, cleaning map, %d, %s",  &v51,  v46);
    __int128 v38 = (uint8_t *)v37;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::removeAllTiles(BOOL, CLTilesManager_Type::TileType)",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
  }

  uint64_t v47 = v4;
  uint64_t v10 = v7 + 184;
  BOOL v11 = (void *)sub_1005B46E8(v7 + 184);
  if (v11 != (void *)sub_100056FA8(v7 + 184))
  {
    do
    {
      if (v5)
      {
        uint64_t v12 = v11[10];
        sub_100C0FD9C(v12);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101879158);
        }
        uint64_t v13 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = sub_100DD8CC8(*(_DWORD *)(v12 + 48));
          double v15 = sub_1008ADB4C(v12 + 48);
          double v16 = sub_1008ADB70(v12 + 48);
          uint64_t v17 = sub_100019240(v10);
          *(_DWORD *)uint64_t buf = 136446979;
          *(void *)char v58 = v14;
          *(_WORD *)&v58[8] = 2049;
          *(double *)&v58[10] = v15;
          __int16 v59 = 2049;
          double v60 = v16;
          __int16 v61 = 2050;
          uint64_t v62 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu",  buf,  0x2Au);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101879158);
          }
          uint64_t v21 = qword_101934858;
          unsigned int v23 = *(_DWORD *)(v12 + 48);
          uint64_t v22 = v12 + 48;
          int v24 = sub_100DD8CC8(v23);
          double v25 = sub_1008ADB4C(v22);
          double v26 = sub_1008ADB70(v22);
          uint64_t v27 = sub_100019240(v10);
          int v51 = 136446979;
          *(void *)int v52 = v24;
          *(_WORD *)&v52[8] = 2049;
          *(double *)&v52[10] = v25;
          __int16 v53 = 2049;
          double v54 = v26;
          __int16 v55 = 2050;
          uint64_t v56 = v27;
          LODWORD(v46) = 42;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  0LL,  "@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu",  &v51,  v46);
          unint64_t v29 = (uint8_t *)v28;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::removeAllTiles(BOOL, CLTilesManager_Type::TileType)",  "%s\n",  v28);
          if (v29 != buf) {
            free(v29);
          }
        }
      }

      int v18 = (void *)v11[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          int v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          uint64_t v19 = (void *)v11[2];
          BOOL v20 = *v19 == (void)v11;
          BOOL v11 = v19;
        }

        while (!v20);
      }

      BOOL v11 = v19;
    }

    while (v19 != (void *)sub_100056FA8(v10));
  }

  sub_100603210(v10);
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  int v30 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    else {
      uint64_t v31 = *(void *)(v7 + 8);
    }
    uint64_t v32 = sub_100019240(v10);
    uint64_t v33 = sub_100603208(v10);
    uint64_t v34 = *(void *)(v4 + 128);
    *(_DWORD *)uint64_t buf = 136315906;
    *(void *)char v58 = v31;
    *(_WORD *)&v58[8] = 2048;
    *(void *)&v58[10] = v32;
    __int16 v59 = 2048;
    double v60 = *(double *)&v33;
    __int16 v61 = 2048;
    uint64_t v62 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    uint64_t v39 = qword_101934838;
    else {
      uint64_t v40 = *(void *)(v7 + 8);
    }
    uint64_t v41 = sub_100019240(v10);
    uint64_t v42 = sub_100603208(v10);
    uint64_t v43 = *(void *)(v47 + 128);
    int v51 = 136315906;
    *(void *)int v52 = v40;
    *(_WORD *)&v52[8] = 2048;
    *(void *)&v52[10] = v41;
    __int16 v53 = 2048;
    double v54 = *(double *)&v42;
    __int16 v55 = 2048;
    uint64_t v56 = v43;
    LODWORD(v46) = 42;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v39,  1LL,  "TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu",  (const char *)&v51,  v46,  v7,  v47);
    BOOL v45 = (uint8_t *)v44;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::removeAllTiles(BOOL, CLTilesManager_Type::TileType)",  "%s\n",  v44);
    if (v45 != buf) {
      free(v45);
    }
  }

  return sub_1011F6BE4(v50);
}

void sub_100C2752C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_100C27568(uint64_t a1, uint64_t a2, int *a3, unsigned __int8 *a4)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v7 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v8 = *a3;
    *(_DWORD *)uint64_t buf = 67109120;
    int v17 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "onCompanionNotification, notification, %d, Tiles",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v12 = *a3;
    v15[0] = 67109120;
    v15[1] = v12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "onCompanionNotification, notification, %d, Tiles",  v15);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanio nNotifier_Type::NotificationData &)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

  (*(void (**)(void))(**(void **)(a1 + 464) + 56LL))(*(void *)(a1 + 464));
  if (*a3 == 5)
  {
    double v10 = v9;
    sub_1004F2598();
    if ((sub_1001B9A1C() & 1) != 0)
    {
      int v11 = *a4;
      *(_BYTE *)(a1 + 496) = v11;
      if (!v11) {
        return;
      }
    }

    else if (!*(_BYTE *)(a1 + 496))
    {
      return;
    }

    sub_100C24408(a1, v10);
  }

void sub_100C27780(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v7 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v8 = *a3;
    *(_DWORD *)uint64_t buf = 134218240;
    uint64_t v30 = a1;
    __int16 v31 = 1024;
    int v32 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: onClientNotification, %p, notification, %d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v16 = *a3;
    *(_DWORD *)double v26 = 134218240;
    *(void *)&v26[4] = a1;
    __int16 v27 = 1024;
    int v28 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: onClientNotification, %p, notification, %d",  v26,  18);
    int v18 = (uint8_t *)v17;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_T ype::NotificationData &)",  "%s\n",  v17);
    if (v18 != buf) {
      free(v18);
    }
  }

  int v9 = *a3;
  if (*a3 == 6)
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v11 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "TILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_34;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    *(_WORD *)double v26 = 0;
    LODWORD(v25) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  0LL,  "TILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery",  v26,  v25,  *(void *)v26);
    goto LABEL_51;
  }

  if (v9 != 4)
  {
    if (!v9)
    {
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101879178);
      }
      double v10 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "TILE: kNotificationReset", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101879178);
        }
        *(_WORD *)double v26 = 0;
        LODWORD(v25) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: kNotificationReset",  v26,  v25);
        BOOL v20 = (uint8_t *)v19;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManag er_Type::NotificationData &)",  "%s\n",  v19);
        if (v20 != buf) {
          free(v20);
        }
      }

      sub_100C268AC(a1);
      (*(void (**)(void))(**(void **)(a1 + 464) + 64LL))(*(void *)(a1 + 464));
    }

    return;
  }

  *(_BYTE *)(a1 + 4sub_100231C10(v1 + 28) = *(_DWORD *)(a4 + 188) == 1;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v13 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v14 = *(unsigned __int8 *)(a1 + 428);
    *(_DWORD *)uint64_t buf = 67109120;
    LODWORD(v3sub_100222B94(v12, (uint64_t)"clearLocationInformationTiles", 0) = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "TILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    int v21 = *(unsigned __int8 *)(a1 + 428);
    *(_DWORD *)double v26 = 67109120;
    *(_DWORD *)&v26[4] = v21;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %d",  v26);
    unsigned int v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_T ype::NotificationData &)",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

  if (!*(_BYTE *)(a1 + 428))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    double v15 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "TILE: location services off, remove all the tiles",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_34;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    *(_WORD *)double v26 = 0;
    LODWORD(v25) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: location services off, remove all the tiles",  v26,  v25,  *(void *)v26);
LABEL_51:
    int v24 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_T ype::NotificationData &)",  "%s\n",  v12);
    if (v24 != buf) {
      free(v24);
    }
LABEL_34:
    sub_100C268AC(a1);
  }

uint64_t *sub_100C27E28(uint64_t a1, uint64_t a2, double a3)
{
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 3221225472LL;
  v57[2] = sub_100C2863C;
  v57[3] = &unk_101862770;
  *(double *)&v57[4] = a3;
  v58[0] = mach_absolute_time();
  v58[1] = (uint64_t)v57;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "TILE: deleteAgedDownloadItems, start", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101879178);
    }
    LOWORD(v59) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "TILE: deleteAgedDownloadItems, start",  &v59,  2);
    uint64_t v47 = (uint8_t *)v46;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::deleteAgedDownloadItems(std::map<TileId, std::unique_ptr<CLTileFile>> &, CFAbsoluteTime)",  "%s\n",  v46);
    if (v47 != buf) {
      free(v47);
    }
  }

  uint64_t v5 = a1 + 248;
  __int128 v6 = *(_OWORD *)(a1 + 360);
  __int128 v7 = *(_OWORD *)(a1 + 376);
  __int128 v8 = *(_OWORD *)(a1 + 328);
  v55[6] = *(_OWORD *)(a1 + 344);
  v55[7] = v6;
  v56[0] = v7;
  *(_OWORD *)((char *)v56 + 12) = *(_OWORD *)(a1 + 388);
  __int128 v9 = *(_OWORD *)(a1 + 296);
  __int128 v10 = *(_OWORD *)(a1 + 312);
  __int128 v11 = *(_OWORD *)(a1 + 264);
  void v55[2] = *(_OWORD *)(a1 + 280);
  v55[3] = v9;
  int v12 = *(uint64_t **)a2;
  v55[4] = v10;
  v55[5] = v8;
  v55[0] = *(_OWORD *)(a1 + 248);
  v55[1] = v11;
  BOOL v13 = sub_100DD9248((uint64_t)v55, a3);
  sub_100D2D9A4((uint64_t)v54);
  if (v12 == (uint64_t *)(a2 + 8))
  {
    int v14 = 0;
  }

  else
  {
    int v14 = 0;
    do
    {
      double v15 = (uint64_t *)v12[1];
      int v16 = v12;
      if (v15)
      {
        do
        {
          int v17 = v15;
          double v15 = (uint64_t *)*v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          int v17 = (uint64_t *)v16[2];
          BOOL v26 = *v17 == (void)v16;
          int v16 = v17;
        }

        while (!v26);
      }

      uint64_t v18 = v12[10];
      double v19 = *(double *)(v18 + 136);
      if (v13)
      {
        int v20 = *(_DWORD *)(v18 + 48);
        if (v20 == 1)
        {
          double v21 = sub_1008ADB4C(v18 + 48);
          double v22 = sub_1008ADB70(v18 + 48);
          int v23 = sub_100D2E080(v54, v5, v21, v22) >= 250000.0 && !sub_100C0FCFC(v18);
          int v20 = *(_DWORD *)(v18 + 48);
        }

        else
        {
          int v23 = 0;
        }

        if (v20 == 2)
        {
          double v24 = sub_1008ADB4C(v18 + 48);
          double v25 = sub_1008ADB70(v18 + 48);
          if (sub_100D2E080(v54, v5, v24, v25) >= 200000.0) {
            v23 |= !sub_100C0FCFC(v18);
          }
        }
      }

      else
      {
        int v23 = 0;
      }

      BOOL v26 = vabdd_f64(a3, v19) < *(double *)(a1 + 208) && v23 == 0;
      if (!v26)
      {
        sub_100C0FD9C(v18);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_101879158);
        }
        __int16 v27 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = sub_100DD8CC8(*(_DWORD *)(v18 + 48));
          double v29 = sub_1008ADB4C(v18 + 48);
          double v30 = sub_1008ADB70(v18 + 48);
          uint64_t v31 = *(void *)(a2 + 16) - 1LL;
          *(_DWORD *)uint64_t buf = 136446979;
          *(void *)int v66 = v28;
          *(_WORD *)&v66[8] = 2049;
          *(double *)&v66[10] = v29;
          *(_WORD *)&v66[18] = 2049;
          double v67 = v30;
          __int16 v68 = 2050;
          uint64_t v69 = v31;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "@TileReq, %{public}s, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld",  buf,  0x2Au);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_101879158);
          }
          uint64_t v32 = qword_101934858;
          unsigned int v34 = *(_DWORD *)(v18 + 48);
          uint64_t v33 = v18 + 48;
          uint64_t v35 = sub_100DD8CC8(v34);
          double v36 = sub_1008ADB4C(v33);
          double v37 = sub_1008ADB70(v33);
          uint64_t v38 = *(void *)(a2 + 16) - 1LL;
          int v59 = 136446979;
          *(void *)double v60 = v35;
          *(_WORD *)&v60[8] = 2049;
          *(double *)&v60[10] = v36;
          __int16 v61 = 2049;
          double v62 = v37;
          __int16 v63 = 2050;
          uint64_t v64 = v38;
          LODWORD(v51) = 42;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v32,  0LL,  "@TileReq, %{public}s, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld",  &v59,  v51);
          uint64_t v40 = (uint8_t *)v39;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::deleteAgedDownloadItems(std::map<TileId, std::unique_ptr<CLTileFile>> &, CFAbsoluteTime)",  "%s\n",  v39);
          if (v40 != buf) {
            free(v40);
          }
        }

        sub_1000087E8((uint64_t **)a2, v12);
        sub_1006035CC((uint64_t)(v12 + 4));
        operator delete(v12);
        ++v14;
      }

      int v12 = v17;
    }

    while (v17 != (uint64_t *)(a2 + 8));
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101879158);
  }
  int v41 = v14;
  uint64_t v42 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = *(void *)(a2 + 16);
    *(_DWORD *)uint64_t buf = 67240448;
    *(_DWORD *)int v66 = v41;
    *(_WORD *)&v66[4] = 2050;
    *(void *)&v66[6] = v43;
    _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101879158);
    }
    uint64_t v48 = *(void *)(a2 + 16);
    int v59 = 67240448;
    *(_DWORD *)double v60 = v41;
    *(_WORD *)&v60[4] = 2050;
    *(void *)&v60[6] = v48;
    LODWORD(v51) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu",  &v59,  v51);
    uint64_t v50 = (uint8_t *)v49;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTilesManager::deleteAgedDownloadItems(std::map<TileId, std::unique_ptr<CLTileFile>> &, CFAbsoluteTime)",  "%s\n",  v49);
    if (v50 != buf) {
      free(v50);
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101879178);
  }
  BOOL v44 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)int v66 = 0;
    *(_WORD *)&v66[4] = 2082;
    *(void *)&v66[6] = "";
    *(_WORD *)&v66[14] = 1026;
    *(_DWORD *)&v66[16] = v41;
    _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Finished CLTilesManager::deleteAgedDownloadItems, deleted:%{public}u}",  buf,  0x18u);
  }

  return sub_1011F6BE4(v58);
}