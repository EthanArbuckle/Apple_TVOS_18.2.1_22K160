uint64_t **sub_100F410C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  int v9;
  v9 = a2;
  if (!*(void *)(a1 + 72))
  {
    sub_100ACD980((uint64_t)sub_100F41174, a1, *(void **)(a1 + 24), &v8);
    v4 = v8;
    v8 = 0LL;
    v5 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      v6 = v8;
      v8 = 0LL;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
    }
  }

  objc_msgSend( *(id *)(*(void *)(a1 + 48) + 16),  "register:forNotification:registrationInfo:",  *(void *)(*(void *)(a1 + 48) + 8),  a2,  0,  v8);
  return sub_10004A8FC((uint64_t **)(a1 + 56), &v9, &v9);
}

void sub_100F41174(int a1, int *a2, _DWORD *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10188D790);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLHarvestControllerExternal::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10188D790);
    }
    v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      v15 = "";
      __int16 v16 = 2082;
      v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLHarvestControllerExternal::onDataProtectionNotification, event:%{public, location :escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10031AC40(*(void *)(a4 + 40), a1, *a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F4133C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F4135C(uint64_t a1, uint64_t a2)
{
  int v4 = a2;
  [*(id *)(*(void *)(a1 + 48) + 16) unregister:*(void *)(*(void *)(a1 + 48) + 8) forNotification:a2];
  uint64_t result = sub_1004EF494(a1 + 56, &v4);
  if (!*(void *)(a1 + 72))
  {
    uint64_t result = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

uint64_t **sub_100F413C0(uint64_t a1, uint64_t a2)
{
  int v9 = a2;
  if (!*(void *)(a1 + 104))
  {
    sub_10043AC3C((uint64_t)sub_100F414E8, a1, *(void **)(a1 + 24), &v8);
    uint64_t v4 = v8;
    uint64_t v8 = 0LL;
    uint64_t v5 = *(void *)(a1 + 80);
    *(void *)(a1 + 80) = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      uint64_t v6 = v8;
      uint64_t v8 = 0LL;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
    }

    if (+[CLGnssProviderAdapter isSupported](&OBJC_CLASS___CLGnssProviderAdapter, "isSupported", v8)) {
      sub_100A9E608();
    }
  }

  [*(id *)(*(void *)(a1 + 80) + 16) register:*(void *)(*(void *)(a1 + 80) + 8) forNotification:a2 registrationInfo:0];
  return sub_10004A8FC((uint64_t **)(a1 + 88), &v9, &v9);
}

void sub_100F414E8(int a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10188D790);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v12 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLHarvestControllerExternal::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10188D790);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      __int16 v18 = "activity";
      __int16 v19 = 2050;
      uint64_t v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLHarvestControllerExternal::onLocationNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v12 = 0;
  }

  int v10 = *a2;
  if (*a2 == 13) {
    *(_BYTE *)(a4 + 288) = *(_BYTE *)(a3 + 824);
  }
  sub_10031AF6C(*(void *)(a4 + 40), a1, v10, a3);
  if (v12) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F416C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F416E0(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10188D790);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLHarvestControllerExternal::onGnssNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10188D790);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLHarvestControllerExternal::onGnssNotification, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100F41938(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F41898( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F418B8(uint64_t a1, uint64_t a2)
{
  int v5 = a2;
  [*(id *)(*(void *)(a1 + 80) + 16) unregister:*(void *)(*(void *)(a1 + 80) + 8) forNotification:a2];
  uint64_t result = sub_1004EF494(a1 + 88, &v5);
  if (!*(void *)(a1 + 104))
  {
    uint64_t v4 = *(void *)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t result = *(void *)(a1 + 144);
    *(void *)(a1 + 144) = 0LL;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    *(_WORD *)(a1 + 288) = 0;
  }

  return result;
}

void sub_100F41938(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (*a3 == 13)
  {
    *(_BYTE *)(a1 + 289) = *(_BYTE *)(a4 + 824);
  }

  else
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188D770);
    }
    int v5 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_FAULT))
    {
      int v6 = *a3;
      *(_DWORD *)buf = 67109376;
      int v14 = v6;
      __int16 v15 = 1024;
      int v16 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Sent unhandled notification 0x%04X (%d)",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188D770);
      }
      int v7 = *a3;
      v10[0] = 67109376;
      v10[1] = v7;
      __int16 v11 = 1024;
      int v12 = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  17LL,  "Sent unhandled notification 0x%04X (%d)",  v10,  14);
      int v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLHarvestControllerExternal::onGnssNotification(int, const CLLocationProvider_Type::Notification &, const C LLocationProvider_Type::NotificationData &)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

uint64_t **sub_100F41B18(uint64_t a1, uint64_t a2)
{
  int v9 = a2;
  if (!*(void *)(a1 + 176))
  {
    sub_10036B3B4((uint64_t)sub_100F41BCC, a1, *(void **)(a1 + 24), &v8);
    uint64_t v4 = v8;
    uint64_t v8 = 0LL;
    uint64_t v5 = *(void *)(a1 + 152);
    *(void *)(a1 + 152) = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      uint64_t v6 = v8;
      uint64_t v8 = 0LL;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
    }
  }

  objc_msgSend( *(id *)(*(void *)(a1 + 152) + 16),  "register:forNotification:registrationInfo:",  *(void *)(*(void *)(a1 + 152) + 8),  a2,  0,  v8);
  return sub_10004A8FC((uint64_t **)(a1 + 160), &v9, &v9);
}

void sub_100F41BCC(int a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10188D790);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLHarvestControllerExternal::onMotionStateNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10188D790);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLHarvestControllerExternal::onMotionStateNotification, event:%{public, location:es cape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10031B300(*(_BYTE **)(a4 + 40), a1, *a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F41D94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F41DB4(uint64_t a1, uint64_t a2)
{
  int v4 = a2;
  [*(id *)(*(void *)(a1 + 152) + 16) unregister:*(void *)(*(void *)(a1 + 152) + 8) forNotification:a2];
  uint64_t result = sub_1004EF494(a1 + 160, &v4);
  if (!*(void *)(a1 + 176))
  {
    uint64_t result = *(void *)(a1 + 152);
    *(void *)(a1 + 152) = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

uint64_t sub_100F41E18(uint64_t a1)
{
  return sub_101024128(*(void *)(a1 + 280));
}

id sub_100F41E20(uint64_t a1, unsigned int *a2)
{
  return sub_1010240A4(*(void *)(a1 + 280), a2);
}

id sub_100F41E28(uint64_t a1, int *a2)
{
  return sub_1010240E8(*(void *)(a1 + 280), a2);
}

void sub_100F41E30(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
}

void sub_100F41E38(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
}

void *sub_100F41E44@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>, double a6@<D0>, double a7@<D1>)
{
  __int16 v14 = operator new(0x40uLL);
  *__int16 v14 = off_10188D7C0;
  sub_1006B5FBC(v14 + 1, a1, a2, a3, a4, 0LL, a6, a7, 0.9);
  return sub_100F4244C(a5, (uint64_t)v14);
}

void sub_100F41EDC(_Unwind_Exception *a1)
{
}

uint64_t sub_100F41EF4()
{
  return sub_1004F64FC();
}

BOOL sub_100F41F08(uint64_t a1, void *a2)
{
  BOOL v3 = sub_1002A8F8C(v8, off_1019928D8, a2);
  int v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return v3;
}

void sub_100F41F8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100F41FA0(uint64_t a1, const __CFDictionary *a2, double *a3)
{
  uint64_t result = sub_100294EE0(a2, a3, &v4);
  if ((_DWORD)result) {
    return TMSetSourceTime(type metadata for , v4, 15.0);
  }
  return result;
}

uint64_t *sub_100F41FE8(uint64_t a1, int a2)
{
  return sub_100517954((uint64_t *)(a1 + 232), a2, a1 + 8);
}

void sub_100F41FF8(uint64_t a1, int a2)
{
}

void sub_100F42008(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  double v4 = (std::__shared_weak_count *)a3[1];
  uint64_t v10 = *a3;
  char v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  sub_10031BEA8(v3, a2, &v10);
  int v7 = v11;
  if (v11)
  {
    uint64_t v8 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

void sub_100F4208C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F420A0(uint64_t a1, int a2, uint64_t *a3)
{
}

id sub_100F420A8(uint64_t a1)
{
  return [*(id *)(a1 + 304) startLeechingVisitsForClient:*(void *)(a1 + 32)];
}

id sub_100F420B8(uint64_t a1)
{
  return [*(id *)(a1 + 304) stopLeechingVisitsForClient:*(void *)(a1 + 32)];
}

void *sub_100F420C8(void *result, void *a2)
{
  if (result[38])
  {
    uint64_t v3 = result;
    double v4 = objc_alloc(&OBJC_CLASS___CLLocation);
    [a2 coordinate];
    double v6 = v5;
    [a2 coordinate];
    int v7 = -[CLLocation initWithLatitude:longitude:](v4, "initWithLatitude:longitude:", v6);
    uint64_t v8 = (void *)v3[38];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100F4217C;
    v9[3] = &unk_101872B88;
    v9[4] = a2;
    v9[5] = v3;
    return [v8 fetchLocationOfInterestAtLocation:v7 withReply:v9];
  }

  return result;
}

void sub_100F4217C(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188D770);
    }
    double v4 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v10 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Received error when fetching LOI at location: %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188D770);
      }
      int v7 = 138412290;
      uint64_t v8 = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "Received error when fetching LOI at location: %@",  &v7,  12);
      double v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLHarvestControllerExternal::onVisit(CLVisit *)_block_invoke",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    sub_10031BC7C(*(void *)(*(void *)(a1 + 40) + 40LL), *(void *)(a1 + 32), a2);
  }

void sub_100F42368(uint64_t a1, void *a2, void *a3, void *a4)
{
}

void sub_100F42370(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

id sub_100F4239C()
{
  return +[CLPMeta updateRegulatoryDomainEstimates](&OBJC_CLASS___CLPMeta, "updateRegulatoryDomainEstimates");
}

void sub_100F423A8(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void *sub_100F423D4(void *a1)
{
  *a1 = off_10188D7C0;
  sub_1006B6010(a1 + 1);
  return a1;
}

void sub_100F42408(void *a1)
{
  *a1 = off_10188D7C0;
  sub_1006B6010(a1 + 1);
  operator delete(a1);
}

id sub_100F4243C(uint64_t a1)
{
  return sub_1006B6294(a1 + 8);
}

id sub_100F42444(uint64_t a1, double a2)
{
  return sub_1006B6014(a1 + 8, a2);
}

void *sub_100F4244C(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10188D808;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100F42494(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F424B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_100F424CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_100F42520()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_10136605C;
      v1[3] = unk_10136606C;
      v1[4] = xmmword_10136607C;
      v1[0] = xmmword_10136603C;
      v1[1] = unk_10136604C;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100F425F4(_Unwind_Exception *a1)
{
}

void sub_100F4260C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100F42670()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100F426E4(_Unwind_Exception *a1)
{
}

uint64_t sub_100F426FC()
{
  return __cxa_atexit( (void (*)(void *))&std::string::~string,  &xmmword_10199F5D0,  (void *)&_mh_execute_header);
}

void sub_100F42740(double *a1, uint64_t *a2, uint64_t a3)
{
  if (sub_100F2B880(*a2))
  {
    double v5 = sub_100F2BA88(*a2, (uint64_t)v15);
    double v6 = *a1;
    double v7 = a1[1];
    if (*a1 > v5 || v6 < 0.0) {
      double v6 = v5;
    }
    if (v7 >= v5 && v7 >= 0.0) {
      double v5 = a1[1];
    }
    *a1 = v6;
    a1[1] = v5;
  }

  if (sub_100F2B950(*a2))
  {
    double v10 = sub_100F2BB6C(*a2, (uint64_t)v15);
    double v11 = a1[2];
    double v12 = a1[3];
    if (v11 > v10 || v11 < 0.0) {
      double v11 = v10;
    }
    if (v12 >= v10 && v12 >= 0.0) {
      double v10 = a1[3];
    }
    a1[2] = v11;
    a1[3] = v10;
  }

uint64_t sub_100F427FC(uint64_t a1, void *a2)
{
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 72) = a1 + 80;
  *(void *)(a1 + 88) = 0LL;
  uint64_t v3 = a2[1];
  *(void *)(a1 + 96) = *a2;
  *(void *)(a1 + 104) = v3;
  if (v3)
  {
    double v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  *(CFAbsoluteTime *)(a1 + 120) = CFAbsoluteTimeGetCurrent();
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 128) = _Q0;
  *(_OWORD *)(a1 + 144) = _Q0;
  *(_OWORD *)(a1 + 160) = _Q0;
  *(_OWORD *)(a1 + 176) = _Q0;
  sub_100F428C0(a1);
  return a1;
}

void sub_100F42894(_Unwind_Exception *a1)
{
}

__n128 sub_100F428C0(uint64_t a1)
{
  uint64_t v1 = (__n128 *)a1;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v2 = (void *)(a1 + 56);
  sub_100008390(a1 + 48, *(void **)(a1 + 56));
  v1[3].n128_u64[0] = (unint64_t)v2;
  *uint64_t v2 = 0LL;
  uint64_t v3 = (void *)v1[5].n128_u64[0];
  v1 += 5;
  v1[-1].n128_u64[0] = 0LL;
  sub_100008390((uint64_t)&v1[-1].n128_i64[1], v3);
  v1[-1].n128_u64[1] = (unint64_t)v1;
  v1->n128_u64[0] = 0LL;
  v1->n128_u64[1] = 0LL;
  v1[2].n128_f64[0] = CFAbsoluteTimeGetCurrent();
  __asm { FMOV            V0.2D, #-1.0 }

  v1[3] = result;
  v1[4] = result;
  _OWORD v1[5] = result;
  v1[6] = result;
  v1[-3].n128_u64[0] = 0LL;
  v1[-3].n128_u32[2] = 0;
  return result;
}

uint64_t sub_100F42934(uint64_t a1)
{
  return a1;
}

CFAbsoluteTime sub_100F4299C(uint64_t a1, unint64_t a2)
{
  CFAbsoluteTime result = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 112);
  if (result >= (double)a2)
  {
    if (*(_DWORD *)a1 + *(_DWORD *)(a1 + 4))
    {
      sub_100F42C10((double *)a1);
      *(void *)&CFAbsoluteTime result = sub_100F428C0(a1).n128_u64[0];
    }
  }

  return result;
}

BOOL sub_100F429FC(uint64_t a1)
{
  BOOL result = sub_100F2BA20(*(void *)(a1 + 96));
  if (!result)
  {
    uint64_t v3 = (_DWORD *)(a1 + 28);
    goto LABEL_7;
  }

  ++*(_DWORD *)(a1 + 24);
  if (sub_100F2B880(*(void *)(a1 + 96))) {
    ++*(_DWORD *)(a1 + 16);
  }
  BOOL result = sub_100F2B950(*(void *)(a1 + 96));
  if (result)
  {
    uint64_t v3 = (_DWORD *)(a1 + 20);
LABEL_7:
    ++*v3;
  }

  return result;
}

void sub_100F42A84(uint64_t a1, uint64_t *a2)
{
  uint64_t v12 = *a2;
  sub_100352AB8((uint64_t **)(a1 + 48), &v12, &v12);
  double v4 = (double *)(a1 + 128);
  uint64_t v5 = *(void *)(a1 + 96);
  double v6 = *(std::__shared_weak_count **)(a1 + 104);
  v11[0] = v5;
  v11[1] = (uint64_t)v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  sub_100F42740(v4, v11, (uint64_t)a2);
  if (v6)
  {
    unint64_t v9 = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100F42B30(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F42B44(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (double *)(a1 + 160);
  double v4 = *(std::__shared_weak_count **)(a1 + 104);
  v9[0] = *(void *)(a1 + 96);
  v9[1] = (uint64_t)v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  sub_100F42740(v3, v9, a2);
  if (v4)
  {
    double v7 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_100F42BE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100F42BF8(uint64_t a1, uint64_t *a2)
{
  return sub_100352AB8((uint64_t **)(a1 + 72), a2, a2);
}

void sub_100F42C10(double *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 16);
  uint64_t v3 = *((unsigned int *)a1 + 22);
  CFAbsoluteTime v4 = (CFAbsoluteTimeGetCurrent() - a1[14]) / 3600.0;
  CFAbsoluteTime v5 = (CFAbsoluteTimeGetCurrent() - a1[15]) / 3600.0;
  v11[0] = @"numBadAps";
  v12[0] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)a1);
  v11[1] = @"numDistinctBadAps";
  v12[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2);
  uint64_t v11[2] = @"numGoodAps";
  v12[2] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 1));
  v11[3] = @"numApsRemovedFromDatabase";
  v12[3] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 2));
  v11[4] = @"numDistinctApsRemovedFromDatabase";
  v12[4] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v3);
  v11[5] = @"numCrossCheckCentroidsRequests";
  v12[5] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 3));
  v11[6] = @"numCrossCheckCentroidsRequestsWithGps";
  v12[6] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 4));
  v11[7] = @"numCrossCheckCentroidsRequestsWithCell";
  v12[7] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 5));
  v11[8] = @"numCrossCheckCentroidsRequestsWithGpsOrCell";
  v12[8] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 6));
  v11[9] = @"numCrossCheckCentroidsRequestsWithoutGpsOrCell";
  v12[9] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 7));
  v11[10] = @"maxGpsDistanceToBadCentroids";
  v12[10] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[17]);
  v11[11] = @"minGpsDistanceToBadCentroids";
  v12[11] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[16]);
  v11[12] = @"maxCellDistanceToBadCentroids";
  v12[12] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[19]);
  v11[13] = @"minCellDistanceToBadCentroids";
  v12[13] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[18]);
  v11[14] = @"maxGpsDistanceToGoodCentroids";
  v12[14] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[21]);
  v11[15] = @"minGpsDistanceToGoodCentroids";
  v12[15] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[20]);
  v11[16] = @"maxCellDistanceToGoodCentroids";
  v12[16] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[23]);
  v11[17] = @"minCellDistanceToGoodCentroids";
  v12[17] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)a1[22]);
  v11[18] = @"eventDurationInHours";
  v12[18] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v4);
  v11[19] = @"sessionDurationInHours";
  v12[19] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v5);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_100F42FE4;
  v8[3] = &unk_101820740;
  v8[4] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  20LL);
  *(void *)&double v6 = AnalyticsSendEventLazy(@"com.apple.clx.wifiloc.movingApDetector", v8).n128_u64[0];
  v9[0] = @"bothCrossCheckersMatch";
  v10[0] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 8), v6);
  v9[1] = @"rejectedByGpsCrossCheck";
  v10[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 9));
  uint64_t v9[2] = @"rejectedByCellCrossCheck";
  _DWORD v10[2] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 10));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_100F42FEC;
  v7[3] = &unk_101820740;
  v7[4] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v10,  v9,  3LL);
  AnalyticsSendEventLazy(@"com.apple.locationd.crosscheckmismatchcode", v7);
}

uint64_t sub_100F42FE4(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_100F42FEC(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

_DWORD *sub_100F42FF4(_DWORD *result, int a2, int a3)
{
  if (a2 == a3)
  {
    ++result[8];
  }

  else if (a2)
  {
    ++result[9];
  }

  else
  {
    ++result[10];
  }

  return result;
}

double sub_100F43030(int a1, int a2)
{
  if (a1 == 2)
  {
    double v2 = -0.122;
    double v3 = 6.08;
  }

  else if (a1 == 1)
  {
    double v2 = -0.17;
    double v3 = 4.65;
  }

  else
  {
    double v2 = -0.12;
    double v3 = 4.63;
  }

  double v4 = (double)a2;
  double result = v3 + v2 * v4;
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

void sub_100F4309C(uint64_t a1, __int128 *a2)
{
  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v4 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)a2 + 1);
    int v6 = *((_DWORD *)a2 + 4);
    int v7 = *((_DWORD *)a2 + 5);
    *(_DWORD *)buf = 134218496;
    uint64_t v24 = v5;
    __int16 v25 = 1024;
    int v26 = v6;
    __int16 v27 = 1024;
    int v28 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[live data] updating elevation anchor, startTime, %f, elevationAscended, %u, elevationDescended, %u",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v12 = *((void *)a2 + 1);
    int v13 = *((_DWORD *)a2 + 4);
    int v14 = *((_DWORD *)a2 + 5);
    int v17 = 134218496;
    uint64_t v18 = v12;
    __int16 v19 = 1024;
    int v20 = v13;
    __int16 v21 = 1024;
    int v22 = v14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] updating elevation anchor, startTime, %f, elevationAscended, %u, elevationDescended, %u",  COERCE_DOUBLE(&v17),  24);
    __int16 v16 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::SourceData<CLElevationChangeEntry>::setAnchor(const CLElevationChangeEntry &) [T = C LElevationChangeEntry]",  "%s\n",  v15);
    if (v16 != buf) {
      free(v16);
    }
  }

  int v8 = *(unsigned __int8 *)(a1 + 64);
  __int128 v9 = a2[3];
  __int128 v11 = *a2;
  __int128 v10 = a2[1];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v9;
  *(_OWORD *)a1 = v11;
  *(_OWORD *)(a1 + 16) = v10;
  if (!v8) {
    *(_BYTE *)(a1 + 64) = 1;
  }
}

void sub_100F432A0(uint64_t a1, uint64_t *a2)
{
  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v4 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    uint64_t v6 = a2[6];
    *(_DWORD *)buf = 134218240;
    uint64_t v27 = v5;
    __int16 v28 = 2048;
    uint64_t v29 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[live data] updating odometer anchor, startTime, %f, odometer, %f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v17 = *a2;
    uint64_t v18 = a2[6];
    int v22 = 134218240;
    uint64_t v23 = v17;
    __int16 v24 = 2048;
    uint64_t v25 = v18;
    LODWORD(v21) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] updating odometer anchor, startTime, %f, odometer, %f",  COERCE_DOUBLE(&v22),  v21);
    int v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::SourceData<CLOdometerEntry>::setAnchor(const CLOdometerEntry &) [T = CLOdometerEntry]",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  int v7 = *(unsigned __int8 *)(a1 + 192);
  __int128 v8 = *((_OWORD *)a2 + 3);
  __int128 v10 = *(_OWORD *)a2;
  __int128 v9 = *((_OWORD *)a2 + 1);
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + 48) = v8;
  *(_OWORD *)a1 = v10;
  *(_OWORD *)(a1 + 16) = v9;
  __int128 v11 = *((_OWORD *)a2 + 7);
  __int128 v13 = *((_OWORD *)a2 + 4);
  __int128 v12 = *((_OWORD *)a2 + 5);
  *(_OWORD *)(a1 + 96) = *((_OWORD *)a2 + 6);
  *(_OWORD *)(a1 + 112) = v11;
  *(_OWORD *)(a1 + 64) = v13;
  *(_OWORD *)(a1 + 80) = v12;
  __int128 v14 = *((_OWORD *)a2 + 11);
  __int128 v16 = *((_OWORD *)a2 + 8);
  __int128 v15 = *((_OWORD *)a2 + 9);
  *(_OWORD *)(a1 + 160) = *((_OWORD *)a2 + 10);
  *(_OWORD *)(a1 + 176) = v14;
  *(_OWORD *)(a1 + 128) = v16;
  *(_OWORD *)(a1 + 144) = v15;
  if (!v7) {
    *(_BYTE *)(a1 + 192) = 1;
  }
}

uint64_t sub_100F434B4(uint64_t a1)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  *(_BYTE *)(a1 + 216) = 0;
  *(_BYTE *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 416) = 0;
  *(_BYTE *)(a1 + 608) = 0;
  *(_BYTE *)(a1 + 616) = 0;
  *(_BYTE *)(a1 + 808) = 0;
  *(_BYTE *)(a1 + 896) = 0;
  *(_DWORD *)(a1 + 904) = 0;
  *(void *)(a1 + 912) = 0LL;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 873) = 0u;
  *(CFAbsoluteTime *)(a1 + 888) = CFAbsoluteTimeGetCurrent();
  *(_BYTE *)(a1 + 896) = 1;
  return a1;
}

void sub_100F43538(uint64_t a1, uint64_t *a2, unsigned __int8 *src)
{
  uint64_t v4 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v71 = *a2;
  v72 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  __p = 0LL;
  v69 = 0LL;
  uint64_t v70 = 0LL;
  uuid_copy(dst, src);
  if (sub_100C46C04(v4, dst, (uint64_t)&__p) == 100)
  {
    __int128 v10 = (double *)__p;
    __int128 v9 = v69;
    if (__p == v69)
    {
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      v60 = (os_log_s *)qword_101934668;
      if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_ERROR,  "[live data] no published runs exist yet, including missing anchor",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934660 != -1) {
          dispatch_once(&qword_101934660, &stru_10188D870);
        }
        LOWORD(v73) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  16LL,  "[live data] no published runs exist yet, including missing anchor",  &v73,  2);
        v45 = (uint8_t *)v63;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSkiLiveDataController::setup(CLSkiDataStore &, const CLMotionStateMediator_Type::WorkoutSettings &)",  "%s\n",  v63);
        goto LABEL_64;
      }
    }

    else
    {
      double v66 = *(double *)&v5;
      double v11 = 0.0;
      *(void *)&__int128 v8 = 134219264LL;
      __int128 v67 = v8;
      do
      {
        if (vabdd_f64(v10[6], v10[5]) >= 2.22044605e-16)
        {
          if (qword_101934660 != -1) {
            dispatch_once(&qword_101934660, &stru_10188D870);
          }
          uint64_t v27 = (os_log_s *)qword_101934668;
          if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = *(void *)v10;
            uint64_t v29 = *((void *)v10 + 5);
            uint64_t v30 = *((void *)v10 + 6);
            uint64_t v31 = *((void *)v10 + 7);
            uint64_t v32 = *((void *)v10 + 11);
            uint64_t v33 = *((void *)v10 + 9);
            *(_DWORD *)buf = v67;
            *(void *)v78 = v28;
            *(_WORD *)&v78[8] = 2048;
            *(void *)&v78[10] = v29;
            *(_WORD *)&v78[18] = 2048;
            *(void *)&v78[20] = v30;
            *(_WORD *)&v78[28] = 2048;
            *(void *)&v78[30] = v31;
            *(_WORD *)&v78[38] = 2048;
            *(void *)&v78[40] = v32;
            __int16 v79 = 2048;
            uint64_t v80 = v33;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "[live data] query returned existing runs for workout,recordId,%llu,startTime,%f,endTime,%f,distance,%f,ver tical,%f,maxSpeed,%f",  buf,  0x3Eu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934660 != -1) {
              dispatch_once(&qword_101934660, &stru_10188D870);
            }
            uint64_t v35 = *(void *)v10;
            uint64_t v36 = *((void *)v10 + 5);
            uint64_t v37 = *((void *)v10 + 6);
            uint64_t v38 = *((void *)v10 + 7);
            uint64_t v39 = *((void *)v10 + 11);
            uint64_t v40 = *((void *)v10 + 9);
            int v73 = v67;
            *(void *)v74 = v35;
            *(_WORD *)&v74[8] = 2048;
            *(void *)&v74[10] = v36;
            *(_WORD *)&v74[18] = 2048;
            *(void *)&v74[20] = v37;
            *(_WORD *)&v74[28] = 2048;
            *(void *)&v74[30] = v38;
            *(_WORD *)&v74[38] = 2048;
            *(void *)&v74[40] = v39;
            __int16 v75 = 2048;
            uint64_t v76 = v40;
            LODWORD(v64) = 62;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] query returned existing runs for workout,recordId,%llu,startTime,%f,endTime,%f,distance,%f,ver tical,%f,maxSpeed,%f",  &v73,  v64,  v65,  v66,  *(double *)&v67,  *((double *)&v67 + 1));
            v42 = (uint8_t *)v41;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::setup(CLSkiDataStore &, const CLMotionStateMediator_Type::WorkoutSettings &)",  "%s\n",  v41);
            if (v42 != buf) {
              free(v42);
            }
          }

          double v11 = v11 + vabdd_f64(v10[6], v10[5]);
          else {
            uint64_t v34 = *((void *)v10 + 9);
          }
          *(void *)(a1 + 912) = v34;
          ++*(_DWORD *)(a1 + 904);
        }

        else
        {
          if (qword_101934660 != -1) {
            dispatch_once(&qword_101934660, &stru_10188D870);
          }
          __int128 v12 = (os_log_s *)qword_101934668;
          if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = *(void *)v10;
            uint64_t v14 = *((void *)v10 + 5);
            uint64_t v15 = *((void *)v10 + 6);
            uint64_t v16 = *((void *)v10 + 7);
            uint64_t v17 = *((void *)v10 + 11);
            uint64_t v18 = *((void *)v10 + 9);
            *(_DWORD *)buf = v67;
            *(void *)v78 = v13;
            *(_WORD *)&v78[8] = 2048;
            *(void *)&v78[10] = v14;
            *(_WORD *)&v78[18] = 2048;
            *(void *)&v78[20] = v15;
            *(_WORD *)&v78[28] = 2048;
            *(void *)&v78[30] = v16;
            *(_WORD *)&v78[38] = 2048;
            *(void *)&v78[40] = v17;
            __int16 v79 = 2048;
            uint64_t v80 = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "[live data] got anchor run,recordId,%llu,startTime,%f,endTime,%f,distance,%f,vertical,%f,maxSpeed,%f",  buf,  0x3Eu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934660 != -1) {
              dispatch_once(&qword_101934660, &stru_10188D870);
            }
            uint64_t v19 = *(void *)v10;
            uint64_t v20 = *((void *)v10 + 5);
            uint64_t v21 = *((void *)v10 + 6);
            uint64_t v22 = *((void *)v10 + 7);
            uint64_t v23 = *((void *)v10 + 11);
            uint64_t v24 = *((void *)v10 + 9);
            int v73 = v67;
            *(void *)v74 = v19;
            *(_WORD *)&v74[8] = 2048;
            *(void *)&v74[10] = v20;
            *(_WORD *)&v74[18] = 2048;
            *(void *)&v74[20] = v21;
            *(_WORD *)&v74[28] = 2048;
            *(void *)&v74[30] = v22;
            *(_WORD *)&v74[38] = 2048;
            *(void *)&v74[40] = v23;
            __int16 v75 = 2048;
            uint64_t v76 = v24;
            LODWORD(v64) = 62;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] got anchor run,recordId,%llu,startTime,%f,endTime,%f,distance,%f,vertical,%f,maxSpeed,%f",  &v73,  v64,  v65,  v66,  *(double *)&v67,  *((double *)&v67 + 1));
            int v26 = (uint8_t *)v25;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::setup(CLSkiDataStore &, const CLMotionStateMediator_Type::WorkoutSettings &)",  "%s\n",  v25);
            if (v26 != buf) {
              free(v26);
            }
          }
        }

        v10 += 12;
      }

      while (v10 != v9);
      double v46 = *(v69 - 5) - *((double *)__p + 7);
      double v47 = *(v69 - 1) - *((double *)__p + 11);
      *(double *)(a1 + 864) = v11;
      *(double *)(a1 + 872) = v46;
      *(double *)(a1 + 880) = v47;
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      v48 = (os_log_s *)qword_101934668;
      if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
      {
        int v49 = *(_DWORD *)(a1 + 904);
        uint64_t v50 = *(void *)(a1 + 864);
        uint64_t v51 = *(void *)(a1 + 872);
        uint64_t v52 = *(void *)(a1 + 880);
        uint64_t v53 = *(void *)(a1 + 912);
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)v78 = v49;
        *(_WORD *)&v78[4] = 2048;
        *(void *)&v78[6] = v50;
        *(_WORD *)&v78[14] = 2048;
        *(void *)&v78[16] = v51;
        *(_WORD *)&v78[24] = 2048;
        *(void *)&v78[26] = v52;
        *(_WORD *)&v78[34] = 2048;
        *(void *)&v78[36] = v53;
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "[live data] starting off with published run metrics,runCount,%d,publishedDuration,%f,publishedDistance,%f,publ ishedElevation,%f,maxSpeed,%f",  buf,  0x30u);
      }

      uint64_t v5 = *(std::__shared_weak_count **)&v66;
      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934660 != -1) {
          dispatch_once(&qword_101934660, &stru_10188D870);
        }
        int v54 = *(_DWORD *)(a1 + 904);
        uint64_t v55 = *(void *)(a1 + 864);
        uint64_t v56 = *(void *)(a1 + 872);
        uint64_t v57 = *(void *)(a1 + 880);
        uint64_t v58 = *(void *)(a1 + 912);
        int v73 = 67110144;
        *(_DWORD *)v74 = v54;
        *(_WORD *)&v74[4] = 2048;
        *(void *)&v74[6] = v55;
        *(_WORD *)&v74[14] = 2048;
        *(void *)&v74[16] = v56;
        *(_WORD *)&v74[24] = 2048;
        *(void *)&v74[26] = v57;
        *(_WORD *)&v74[34] = 2048;
        *(void *)&v74[36] = v58;
        LODWORD(v64) = 48;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] starting off with published run metrics,runCount,%d,publishedDuration,%f,publishedDistance,%f,publ ishedElevation,%f,maxSpeed,%f",  &v73,  v64,  v65,  v66,  *(double *)&v67);
        v45 = (uint8_t *)v59;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::setup(CLSkiDataStore &, const CLMotionStateMediator_Type::WorkoutSettings &)",  "%s\n",  v59);
LABEL_64:
        if (v45 != buf) {
          free(v45);
        }
      }
    }
  }

  else
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    v43 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "[live data] couldn't query db for published runs",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      LOWORD(v73) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  16LL,  "[live data] couldn't query db for published runs",  &v73,  2);
      v45 = (uint8_t *)v44;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSkiLiveDataController::setup(CLSkiDataStore &, const CLMotionStateMediator_Type::WorkoutSettings &)",  "%s\n",  v44);
      goto LABEL_64;
    }
  }

  if (__p)
  {
    v69 = (double *)__p;
    operator delete(__p);
  }

  if (v5)
  {
    v61 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

void sub_100F43E34( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10000AE14((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_100F43E78(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char v3 = *(_BYTE *)(a1 + 896);
  if (!v3) {
    goto LABEL_10;
  }
  if (!sub_100F44148(a1))
  {
    char v3 = 0;
LABEL_10:
    *(_BYTE *)a2 = 0;
    goto LABEL_11;
  }

  double v5 = *(double *)(a1 + 832) + *(double *)(a1 + 856);
  double v6 = *(double *)(a1 + 816) + *(double *)(a1 + 840) + *(double *)(a1 + 864);
  double v7 = *(double *)(a1 + 824) + *(double *)(a1 + 848) + *(double *)(a1 + 872);
  double v8 = *(double *)(a1 + 880);
  uint64_t v9 = *(void *)(a1 + 616);
  int v10 = *(_DWORD *)(a1 + 904) + 1;
  uint64_t v11 = *(void *)(a1 + 912);
  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v12 = v5 + v8;
  uint64_t v13 = (os_log_s *)qword_101934668;
  double v14 = v7 / v6;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)(a1 + 904) + 1;
    *(_DWORD *)buf = 67110656;
    int v28 = v15;
    __int16 v29 = 2048;
    uint64_t v30 = v9;
    __int16 v31 = 2048;
    double v32 = v7;
    __int16 v33 = 2048;
    double v34 = v12;
    __int16 v35 = 2048;
    double v36 = v14;
    __int16 v37 = 2048;
    uint64_t v38 = v11;
    __int16 v39 = 1024;
    int v40 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "[live data] sending update,pendingRunCount,%d,updateTime,%f,distance,%f,vertical,%f,speed,%f,maxSpeed,%f,runCount,%d",  buf,  0x40u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    int v16 = *(_DWORD *)(a1 + 904) + 1;
    LODWORD(v20) = 67110656;
    HIDWORD(v20) = v16;
    *(_WORD *)uint64_t v21 = 2048;
    *(void *)&v21[2] = v9;
    *(_WORD *)&v21[10] = 2048;
    *(double *)&v21[12] = v7;
    *(_WORD *)&v21[20] = 2048;
    *(_WORD *)&v21[22] = LOWORD(v12);
    double v22 = v14;
    __int16 v23 = 2048;
    uint64_t v24 = v11;
    __int16 v25 = 1024;
    int v26 = v10;
    LODWORD(v19) = 64;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] sending update,pendingRunCount,%d,updateTime,%f,distance,%f,vertical,%f,speed,%f,maxSpeed,%f,runCount,%d",  &v20,  v19,  v20,  *(double *)v21,  *(double *)&v21[8],  *(double *)&v21[16],  *(void *)&v12 >> 16);
    uint64_t v18 = (uint8_t *)v17;
    sub_10029211C("Generic", 1LL, 0, 2LL, "std::optional<CLLiveSkiData> CLSkiLiveDataController::tick()", "%s\n", v17);
    if (v18 != buf) {
      free(v18);
    }
  }

  *(void *)a2 = v9;
  *(double *)(a2 + 8) = v7;
  *(double *)(a2 + 16) = v14;
  *(double *)(a2 + 24) = v12;
  *(_DWORD *)(a2 + 32) = v10;
  char v3 = 1;
  *(void *)(a2 + 40) = v11;
LABEL_11:
  *(_BYTE *)(a2 + 48) = v3;
}

BOOL sub_100F44148(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 64)
    || !*(_BYTE *)(a1 + 136)
    || !*(_BYTE *)(a1 + 208)
    || !*(_BYTE *)(a1 + 408)
    || !*(_BYTE *)(a1 + 608)
    || !*(_BYTE *)(a1 + 808)
    || !*(_BYTE *)(a1 + 896))
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v11 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
    {
      int v12 = *(unsigned __int8 *)(a1 + 408);
      int v13 = *(unsigned __int8 *)(a1 + 808);
      int v14 = *(unsigned __int8 *)(a1 + 64);
      int v15 = *(unsigned __int8 *)(a1 + 208);
      int v16 = *(unsigned __int8 *)(a1 + 896);
      *(_DWORD *)buf = 67110144;
      *(_DWORD *)v85 = v12;
      *(_WORD *)&v85[4] = 1024;
      *(_DWORD *)&v85[6] = v13;
      *(_WORD *)&v85[10] = 1024;
      *(_DWORD *)&v85[12] = v14;
      *(_WORD *)&v85[16] = 1024;
      *(_DWORD *)&v85[18] = v15;
      *(_WORD *)&v85[22] = 1024;
      *(_DWORD *)&v85[24] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "[live data] invalid update, odometer validity, %d, %d, elevation validity, %d, %d, tracking state %d",  buf,  0x20u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      uint64_t v9 = qword_101934668;
      int v48 = *(unsigned __int8 *)(a1 + 408);
      int v49 = *(unsigned __int8 *)(a1 + 808);
      int v50 = *(unsigned __int8 *)(a1 + 64);
      int v51 = *(unsigned __int8 *)(a1 + 208);
      int v52 = *(unsigned __int8 *)(a1 + 896);
      *(_DWORD *)v72 = 67110144;
      *(_DWORD *)&v72[4] = v48;
      *(_WORD *)&v72[8] = 1024;
      *(_DWORD *)&v72[10] = v49;
      *(_WORD *)&v72[14] = 1024;
      *(_DWORD *)&v72[16] = v50;
      *(_WORD *)&v72[20] = 1024;
      *(_DWORD *)&v72[22] = v51;
      *(_WORD *)&v72[26] = 1024;
      *(_DWORD *)&v72[28] = v52;
      LODWORD(v69) = 32;
      int v10 = "[live data] invalid update, odometer validity, %d, %d, elevation validity, %d, %d, tracking state %d";
      uint64_t v41 = 1LL;
      goto LABEL_72;
    }

    return result;
  }

  unsigned int v2 = *(_DWORD *)(a1 + 160);
  unsigned int v3 = *(_DWORD *)(a1 + 164);
  double v4 = *(double *)(a1 + 152);
  double v5 = (double)(v3 - *(_DWORD *)(a1 + 92));
  double v6 = ((double)(v2 - *(_DWORD *)(a1 + 88)) - v5) / (v4 - *(double *)(a1 + 80));
  if (v6 > -39.9287987)
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    double v7 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(double *)v85 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[live data] sample failed descent rate threshold, %f",  buf,  0xCu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      uint64_t v9 = qword_101934668;
      *(_DWORD *)v72 = 134217984;
      *(double *)&v72[4] = v6;
      LODWORD(v69) = 12;
      int v10 = "[live data] sample failed descent rate threshold, %f";
LABEL_40:
      uint64_t v41 = 0LL;
LABEL_72:
      _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v9, v41, v10, v72, *(void *)&v69);
      int v54 = (uint8_t *)v53;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSkiLiveDataController::updateCurrentRun()", "%s\n", v53);
      if (v54 != buf) {
        free(v54);
      }
      return 0LL;
    }

    return result;
  }

  *(double *)&unint64_t v17 = (double)v2;
  LODWORD(v5) = *(_DWORD *)(a1 + 16);
  LODWORD(v17) = *(_DWORD *)(a1 + 20);
  double v18 = ((double)v3 - (double)v2 + (double)*(unint64_t *)&v5 - (double)v17) / 100.0;
  double v19 = *(double *)(a1 + 664) - *(double *)(a1 + 264);
  double v20 = v19 * v19 + v18 * v18;
  double v21 = vabdd_f64(*(double *)(a1 + 616), *(double *)(a1 + 216));
  double v22 = vabdd_f64(v4, *(double *)(a1 + 8));
  if (qword_101934660 != -1)
  {
    double v71 = v22;
    dispatch_once(&qword_101934660, &stru_10188D870);
    double v22 = v71;
  }

  double v23 = fabs(v18);
  double v24 = fmax(v21, v22);
  __int16 v25 = (os_log_s *)qword_101934668;
  double v26 = sqrt(v20);
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
  {
    int v27 = *(_DWORD *)(a1 + 904) + 1;
    double v28 = *(double *)(a1 + 8);
    *(void *)&v85[16] = *(void *)(a1 + 152);
    *(double *)&v85[6] = v28;
    double v29 = *(double *)&v85[16] - v28;
    double v30 = *(double *)(a1 + 216);
    double v87 = *(double *)(a1 + 616);
    *(double *)&v85[36] = v30;
    double v31 = v87 - v30;
    uint64_t v32 = *(void *)(a1 + 824);
    uint64_t v33 = *(void *)(a1 + 832);
    uint64_t v34 = *(void *)(a1 + 816);
    *(_DWORD *)buf = 67112192;
    *(_DWORD *)v85 = v27;
    *(_WORD *)&v85[4] = 2048;
    *(_WORD *)&v85[14] = 2048;
    *(_WORD *)&v85[24] = 2048;
    *(double *)&v85[26] = v29;
    *(_WORD *)&v85[34] = 2048;
    __int16 v86 = 2048;
    __int16 v88 = 2048;
    double v89 = v31;
    __int16 v90 = 2048;
    uint64_t v91 = v32;
    __int16 v92 = 2048;
    double v93 = v26;
    __int16 v94 = 2048;
    uint64_t v95 = v33;
    __int16 v96 = 2048;
    double v97 = v23;
    __int16 v98 = 2048;
    uint64_t v99 = v34;
    __int16 v100 = 2048;
    double v101 = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "[live data] intermediates,pendingRunCount,%d, elevationAnchorTime,%f,elevationCurrentTime,%f,elevationDelta,%f,odo meterAnchorTime,%f,odometerCurrentTime,%f,odometerDelta,%f,currentDistance,%f,proposedDistance,%f,currentVertical, %f,proposedVertical,%f,currentDuration,%f,proposedDuration,%f",  buf,  0x80u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    int v55 = *(_DWORD *)(a1 + 904) + 1;
    double v56 = *(double *)(a1 + 8);
    *(void *)&v72[20] = *(void *)(a1 + 152);
    *(double *)&v72[10] = v56;
    double v57 = *(double *)&v72[20] - v56;
    double v58 = *(double *)(a1 + 216);
    *(void *)&v73[2] = *(void *)(a1 + 616);
    *(double *)&v72[40] = v58;
    double v59 = *(double *)&v73[2] - v58;
    uint64_t v60 = *(void *)(a1 + 824);
    uint64_t v61 = *(void *)(a1 + 832);
    uint64_t v62 = *(void *)(a1 + 816);
    *(_DWORD *)v72 = 67112192;
    *(_DWORD *)&v72[4] = v55;
    *(_WORD *)&v72[8] = 2048;
    *(_WORD *)&v72[18] = 2048;
    *(_WORD *)&v72[28] = 2048;
    *(double *)&v72[30] = v57;
    *(_WORD *)&v72[38] = 2048;
    *(_WORD *)int v73 = 2048;
    *(_WORD *)&v73[10] = 2048;
    *(double *)&v73[12] = v59;
    *(_WORD *)&v73[20] = 2048;
    *(void *)&v73[22] = v60;
    __int16 v74 = 2048;
    double v75 = v26;
    __int16 v76 = 2048;
    uint64_t v77 = v61;
    __int16 v78 = 2048;
    double v79 = v23;
    __int16 v80 = 2048;
    uint64_t v81 = v62;
    __int16 v82 = 2048;
    double v83 = v24;
    LODWORD(v69) = 128;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  1LL,  "[live data] intermediates,pendingRunCount,%d, elevationAnchorTime,%f,elevationCurrentTime,%f,elevationDelta,%f,odo meterAnchorTime,%f,odometerCurrentTime,%f,odometerDelta,%f,currentDistance,%f,proposedDistance,%f,currentVertical, %f,proposedVertical,%f,currentDuration,%f,proposedDuration,%f",  v72,  v69,  v70,  v71,  *(double *)v72,  *(double *)&v72[8],  *(double *)&v72[16],  *(double *)&v72[24],  *(double *)&v72[32],  *(double *)&v72[40],  *(double *)v73,  *(double *)&v73[8],  *(double *)&v73[16]);
    double v64 = (uint8_t *)v63;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSkiLiveDataController::updateCurrentRun()", "%s\n", v63);
    if (v64 != buf) {
      free(v64);
    }
  }

  double v35 = *(double *)(a1 + 848);
  if (v35 <= 0.0 && *(double *)(a1 + 856) <= 0.0)
  {
LABEL_47:
    if (v24 >= *(double *)(a1 + 816)
      && (double v43 = *(double *)(a1 + 824), v26 >= v43)
      && (double v44 = *(double *)(a1 + 832), v23 >= v44))
    {
      if (v26 == v43 && v23 == v44)
      {
        if (qword_101934660 != -1) {
          dispatch_once(&qword_101934660, &stru_10188D870);
        }
        double v47 = (os_log_s *)qword_101934668;
        if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "[live data] skipping update because it's unchanged",  buf,  2u);
        }

        BOOL result = sub_1002921D0(115, 2);
        if (result)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934660 != -1) {
            dispatch_once(&qword_101934660, &stru_10188D870);
          }
          uint64_t v9 = qword_101934668;
          *(_WORD *)v72 = 0;
          LODWORD(v69) = 2;
          int v10 = "[live data] skipping update because it's unchanged";
          goto LABEL_40;
        }

        return result;
      }
    }

    else
    {
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      v45 = (os_log_s *)qword_101934668;
      if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "[live data] metrics should be monotonically increasing!",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934660 != -1) {
          dispatch_once(&qword_101934660, &stru_10188D870);
        }
        *(_WORD *)v72 = 0;
        LODWORD(v69) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  16LL,  "[live data] metrics should be monotonically increasing!",  v72,  *(void *)&v69);
        double v66 = (uint8_t *)v65;
        sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLSkiLiveDataController::updateCurrentRun()", "%s\n", v65);
        if (v66 != buf) {
          free(v66);
        }
      }
    }

    *(double *)(a1 + 816) = v24;
    *(double *)(a1 + 824) = v26;
    BOOL result = 1LL;
    *(double *)(a1 + 832) = v23;
    return result;
  }

  if (v35 <= v26 && *(double *)(a1 + 856) <= v23)
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    v42 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "[live data] resetting overhead as we've reconciled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      *(_WORD *)v72 = 0;
      LODWORD(v69) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] resetting overhead as we've reconciled",  v72,  *(void *)&v69);
      v68 = (uint8_t *)v67;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSkiLiveDataController::updateCurrentRun()", "%s\n", v67);
      if (v68 != buf) {
        free(v68);
      }
    }

    *(void *)(a1 + 840) = 0LL;
    *(void *)(a1 + 848) = 0LL;
    *(void *)(a1 + 856) = 0LL;
    goto LABEL_47;
  }

  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v36 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = *(void *)(a1 + 848);
    uint64_t v38 = *(void *)(a1 + 856);
    *(_DWORD *)buf = 134218752;
    *(void *)v85 = v37;
    *(_WORD *)&v85[8] = 2048;
    *(void *)&v85[10] = v38;
    *(_WORD *)&v85[18] = 2048;
    *(double *)&v85[20] = v26;
    *(_WORD *)&v85[28] = 2048;
    *(double *)&v85[30] = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "[live data] still have overhead to make up, overhead distance,%f,overhead vertical,%f,proposed distance,%f,proposed vertical,%f",  buf,  0x2Au);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v9 = qword_101934668;
    uint64_t v39 = *(void *)(a1 + 848);
    uint64_t v40 = *(void *)(a1 + 856);
    *(_DWORD *)v72 = 134218752;
    *(void *)&v72[4] = v39;
    *(_WORD *)&v72[12] = 2048;
    *(void *)&v72[14] = v40;
    *(_WORD *)&v72[22] = 2048;
    *(double *)&v72[24] = v26;
    *(_WORD *)&v72[32] = 2048;
    *(double *)&v72[34] = v23;
    LODWORD(v69) = 42;
    int v10 = "[live data] still have overhead to make up, overhead distance,%f,overhead vertical,%f,proposed distance,%f,pro"
          "posed vertical,%f";
    goto LABEL_40;
  }

  return result;
}

void sub_100F44CA8(uint64_t a1, uint64_t a2)
{
  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v4 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void *)(a2 + 8);
    int v6 = *(_DWORD *)(a2 + 16);
    int v7 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)buf = 134218496;
    uint64_t v20 = v5;
    __int16 v21 = 1024;
    int v22 = v6;
    __int16 v23 = 1024;
    int v24 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "[live data] feeding elevation,startTime,%f,elevationUp,%u,elevationDown,%u",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v8 = *(void *)(a2 + 8);
    int v9 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
    int v13 = 134218496;
    uint64_t v14 = v8;
    __int16 v15 = 1024;
    int v16 = v9;
    __int16 v17 = 1024;
    int v18 = v10;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  1LL,  "[live data] feeding elevation,startTime,%f,elevationUp,%u,elevationDown,%u",  COERCE_DOUBLE(&v13),  24);
    int v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::feedElevation(const CLElevationChangeEntry &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  sub_100F44E9C(a1, a1, (double *)a2);
}

void sub_100F44E9C(uint64_t a1, uint64_t a2, double *a3)
{
  if (*(_BYTE *)(a1 + 896))
  {
    uint64_t v5 = (__int128 *)(a2 + 144);
    if (*(_BYTE *)(a2 + 208))
    {
      if (*(double *)(a2 + 152) != a3[1])
      {
        __int128 v6 = *v5;
        *(_OWORD *)(a2 + 88) = *(_OWORD *)(a2 + 160);
        __int128 v7 = *(_OWORD *)(a2 + 192);
        *(_OWORD *)(a2 + 104) = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a2 + 120) = v7;
        *(_BYTE *)(a2 + 136) = *(_BYTE *)(a2 + 208);
        *(_OWORD *)(a2 + 72) = v6;
        __int128 v9 = *((_OWORD *)a3 + 2);
        __int128 v8 = *((_OWORD *)a3 + 3);
        __int128 v10 = *((_OWORD *)a3 + 1);
        *uint64_t v5 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 160) = v10;
        *(_OWORD *)(a2 + 176) = v9;
        *(_OWORD *)(a2 + 192) = v8;
      }
    }

    else
    {
      __int128 v11 = *(_OWORD *)a3;
      __int128 v12 = *((_OWORD *)a3 + 1);
      __int128 v13 = *((_OWORD *)a3 + 3);
      *(_OWORD *)(a2 + 176) = *((_OWORD *)a3 + 2);
      *(_OWORD *)(a2 + 192) = v13;
      *uint64_t v5 = v11;
      *(_OWORD *)(a2 + 160) = v12;
      *(_BYTE *)(a2 + 208) = 1;
    }

    if (!*(_BYTE *)(a2 + 64) && sub_100F45DD4(a1 + 72, a1 + 144)) {
      sub_100F4309C(a2, (__int128 *)a3);
    }
  }

  else
  {
    if (*(_BYTE *)(a2 + 64)) {
      *(_BYTE *)(a2 + 64) = 0;
    }
    if (*(_BYTE *)(a2 + 136)) {
      *(_BYTE *)(a2 + 136) = 0;
    }
    if (*(_BYTE *)(a2 + 208)) {
      *(_BYTE *)(a2 + 208) = 0;
    }
  }

void sub_100F44F84(uint64_t a1, uint64_t *a2)
{
  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  double v4 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *a2;
    uint64_t v6 = a2[6];
    uint64_t v7 = a2[4];
    *(_DWORD *)buf = 134218496;
    uint64_t v21 = v5;
    __int16 v22 = 2048;
    uint64_t v23 = v6;
    __int16 v24 = 2048;
    uint64_t v25 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "[live data] feeding odometer,startTime,%f,distance,%f,speed,%f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    uint64_t v8 = *a2;
    uint64_t v9 = a2[6];
    uint64_t v10 = a2[4];
    int v14 = 134218496;
    uint64_t v15 = v8;
    __int16 v16 = 2048;
    uint64_t v17 = v9;
    __int16 v18 = 2048;
    uint64_t v19 = v10;
    LODWORD(v13) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  1LL,  "[live data] feeding odometer,startTime,%f,distance,%f,speed,%f",  COERCE_DOUBLE(&v14),  v13);
    __int128 v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::feedOdometer(const CLOdometerEntry &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  sub_100F45180(a1, a1 + 216, a2);
}

void sub_100F45180(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_BYTE *)(a1 + 896))
  {
    uint64_t v5 = (double *)(a2 + 400);
    if (*(_BYTE *)(a2 + 592))
    {
      if (*v5 != *(double *)a3)
      {
        __int128 v6 = *(_OWORD *)(a2 + 432);
        *(_OWORD *)(a2 + 248) = *(_OWORD *)(a2 + 448);
        *(_OWORD *)(a2 + 232) = v6;
        __int128 v7 = *(_OWORD *)v5;
        *(_OWORD *)(a2 + 216) = *(_OWORD *)(a2 + 416);
        __int128 v8 = *(_OWORD *)(a2 + 512);
        *(_OWORD *)(a2 + 296) = *(_OWORD *)(a2 + 496);
        *(_OWORD *)(a2 + 312) = v8;
        __int128 v9 = *(_OWORD *)(a2 + 480);
        *(_OWORD *)(a2 + 264) = *(_OWORD *)(a2 + 464);
        *(_OWORD *)(a2 + 280) = v9;
        *(_BYTE *)(a2 + 392) = *(_BYTE *)(a2 + 592);
        __int128 v10 = *(_OWORD *)(a2 + 576);
        *(_OWORD *)(a2 + 360) = *(_OWORD *)(a2 + 560);
        *(_OWORD *)(a2 + 376) = v10;
        __int128 v11 = *(_OWORD *)(a2 + 544);
        *(_OWORD *)(a2 + 328) = *(_OWORD *)(a2 + 528);
        *(_OWORD *)(a2 + 344) = v11;
        *(_OWORD *)(a2 + 200) = v7;
        __int128 v12 = *(_OWORD *)a3;
        __int128 v13 = *((_OWORD *)a3 + 1);
        __int128 v14 = *((_OWORD *)a3 + 3);
        *(_OWORD *)(a2 + 432) = *((_OWORD *)a3 + 2);
        *(_OWORD *)(a2 + 448) = v14;
        *(_OWORD *)uint64_t v5 = v12;
        *(_OWORD *)(a2 + 416) = v13;
        __int128 v15 = *((_OWORD *)a3 + 4);
        __int128 v16 = *((_OWORD *)a3 + 5);
        __int128 v17 = *((_OWORD *)a3 + 7);
        *(_OWORD *)(a2 + 496) = *((_OWORD *)a3 + 6);
        *(_OWORD *)(a2 + 512) = v17;
        *(_OWORD *)(a2 + 464) = v15;
        *(_OWORD *)(a2 + 480) = v16;
        __int128 v18 = *((_OWORD *)a3 + 8);
        __int128 v19 = *((_OWORD *)a3 + 9);
        __int128 v20 = *((_OWORD *)a3 + 11);
        *(_OWORD *)(a2 + 560) = *((_OWORD *)a3 + 10);
        *(_OWORD *)(a2 + 576) = v20;
        *(_OWORD *)(a2 + 528) = v18;
        *(_OWORD *)(a2 + 544) = v19;
      }
    }

    else
    {
      __int128 v21 = *(_OWORD *)a3;
      __int128 v22 = *((_OWORD *)a3 + 1);
      __int128 v23 = *((_OWORD *)a3 + 3);
      *(_OWORD *)(a2 + 432) = *((_OWORD *)a3 + 2);
      *(_OWORD *)(a2 + 448) = v23;
      *(_OWORD *)uint64_t v5 = v21;
      *(_OWORD *)(a2 + 416) = v22;
      __int128 v24 = *((_OWORD *)a3 + 4);
      __int128 v25 = *((_OWORD *)a3 + 5);
      __int128 v26 = *((_OWORD *)a3 + 7);
      *(_OWORD *)(a2 + 496) = *((_OWORD *)a3 + 6);
      *(_OWORD *)(a2 + 512) = v26;
      *(_OWORD *)(a2 + 464) = v24;
      *(_OWORD *)(a2 + 480) = v25;
      __int128 v27 = *((_OWORD *)a3 + 8);
      __int128 v28 = *((_OWORD *)a3 + 9);
      __int128 v29 = *((_OWORD *)a3 + 11);
      *(_OWORD *)(a2 + 560) = *((_OWORD *)a3 + 10);
      *(_OWORD *)(a2 + 576) = v29;
      *(_OWORD *)(a2 + 528) = v27;
      *(_OWORD *)(a2 + 544) = v28;
      *(_BYTE *)(a2 + 592) = 1;
    }

    if (!*(_BYTE *)(a2 + 192) && sub_100F45DD4(a1 + 72, a1 + 144)) {
      sub_100F432A0(a2, a3);
    }
  }

  else
  {
    if (*(_BYTE *)(a2 + 192)) {
      *(_BYTE *)(a2 + 192) = 0;
    }
    if (*(_BYTE *)(a2 + 392)) {
      *(_BYTE *)(a2 + 392) = 0;
    }
    if (*(_BYTE *)(a2 + 592)) {
      *(_BYTE *)(a2 + 592) = 0;
    }
  }

void sub_100F452CC(uint64_t a1, int a2)
{
  if (a2)
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    unsigned int v3 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "[live data] resumed tracking,now,%f", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      uint64_t v5 = qword_101934668;
      int v11 = 134217984;
      CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent();
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v5,  1LL,  "[live data] resumed tracking,now,%f",  COERCE_DOUBLE(&v11));
      __int128 v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSkiLiveDataController::feedTrackingUpdate(BOOL)", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    *(CFAbsoluteTime *)(a1 + 888) = CFAbsoluteTimeGetCurrent();
    *(_BYTE *)(a1 + 896) = 1;
  }

  else
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    double v4 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "[live data] paused tracking,now,%f", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      uint64_t v8 = qword_101934668;
      int v11 = 134217984;
      CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent();
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  1LL,  "[live data] paused tracking,now,%f",  COERCE_DOUBLE(&v11));
      __int128 v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSkiLiveDataController::feedTrackingUpdate(BOOL)", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    if (*(_BYTE *)(a1 + 896)) {
      *(_BYTE *)(a1 + 896) = 0;
    }
  }

  if (*(_BYTE *)(a1 + 64)) {
    *(_BYTE *)(a1 + 64) = 0;
  }
  if (*(_BYTE *)(a1 + 136)) {
    *(_BYTE *)(a1 + 136) = 0;
  }
  if (*(_BYTE *)(a1 + 208)) {
    *(_BYTE *)(a1 + 208) = 0;
  }
  if (*(_BYTE *)(a1 + 408)) {
    *(_BYTE *)(a1 + 408) = 0;
  }
  if (*(_BYTE *)(a1 + 608)) {
    *(_BYTE *)(a1 + 608) = 0;
  }
  if (*(_BYTE *)(a1 + 808)) {
    *(_BYTE *)(a1 + 808) = 0;
  }
}

void sub_100F45634(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    ++*(_DWORD *)(a1 + 904);
    *(double *)(a1 + 864) = *(double *)(a1 + 864) + *(double *)(a2 + 48) - *(double *)(a2 + 40);
    *(double *)(a1 + 872) = *(double *)(a2 + 56) + *(double *)(a1 + 872);
    *(double *)(a1 + 880) = *(double *)(a2 + 88) + *(double *)(a1 + 880);
  }

  if (qword_101934660 != -1) {
    dispatch_once(&qword_101934660, &stru_10188D870);
  }
  __int128 v6 = (os_log_s *)qword_101934668;
  if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 904);
    double v8 = *(double *)a2;
    double v9 = *(double *)(a2 + 40);
    double v10 = *(double *)(a2 + 48);
    uint64_t v11 = *(void *)(a2 + 88);
    uint64_t v12 = *(void *)(a2 + 56);
    uint64_t v13 = *(void *)(a2 + 64);
    uint64_t v14 = *(void *)(a1 + 816);
    uint64_t v15 = *(void *)(a1 + 824);
    uint64_t v16 = *(void *)(a1 + 832);
    uint64_t v17 = *(void *)(a1 + 864);
    uint64_t v18 = *(void *)(a1 + 872);
    uint64_t v19 = *(void *)(a1 + 880);
    *(_DWORD *)buf = 67112704;
    *(_DWORD *)uint64_t v53 = a3;
    *(_WORD *)&v53[4] = 1024;
    *(_DWORD *)&v53[6] = v7;
    *(_WORD *)int v54 = 2048;
    *(double *)&v54[2] = v8;
    __int16 v55 = 2048;
    double v56 = v9;
    __int16 v57 = 2048;
    double v58 = v10;
    __int16 v59 = 2048;
    double v60 = v10 - v9;
    __int16 v61 = 2048;
    uint64_t v62 = v12;
    __int16 v63 = 2048;
    uint64_t v64 = v11;
    __int16 v65 = 2048;
    uint64_t v66 = v13;
    __int16 v67 = 2048;
    uint64_t v68 = v14;
    __int16 v69 = 2048;
    uint64_t v70 = v15;
    __int16 v71 = 2048;
    uint64_t v72 = v16;
    __int16 v73 = 2048;
    uint64_t v74 = v17;
    __int16 v75 = 2048;
    uint64_t v76 = v18;
    __int16 v77 = 2048;
    uint64_t v78 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[live data] feeding published run,isValid,%d,runCount,%d,recordId,%llu,startTime,%f,endTime,%f,duration,%f,runDist ance,%f,runVertical,%f,runSpeed,%f,currentDuration,%f,currentDistance,%f,currentVertical,%f,totalDuration,%f,total Distance,%f,totalVertical,%f",  buf,  0x90u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    int v23 = *(_DWORD *)(a1 + 904);
    double v24 = *(double *)a2;
    double v25 = *(double *)(a2 + 40);
    double v26 = *(double *)(a2 + 48);
    uint64_t v27 = *(void *)(a2 + 88);
    double v28 = *(double *)(a2 + 56);
    uint64_t v29 = *(void *)(a2 + 64);
    uint64_t v30 = *(void *)(a1 + 816);
    double v31 = *(double *)(a1 + 824);
    uint64_t v32 = *(void *)(a1 + 832);
    uint64_t v33 = *(void *)(a1 + 864);
    uint64_t v34 = *(void *)(a1 + 872);
    uint64_t v35 = *(void *)(a1 + 880);
    *(_DWORD *)uint64_t v41 = 67112704;
    *(_DWORD *)&v41[4] = a3;
    *(_WORD *)&v41[8] = 1024;
    *(_DWORD *)&v41[10] = v23;
    *(_WORD *)&v41[14] = 2048;
    *(_WORD *)v42 = 2048;
    *(double *)&v42[2] = v25;
    *(_WORD *)&v42[10] = 2048;
    *(double *)&v42[12] = v26;
    *(_WORD *)&v42[20] = 2048;
    *(double *)&v42[22] = v26 - v25;
    *(_WORD *)&v42[30] = 2048;
    *(_WORD *)double v43 = 2048;
    *(void *)&v43[2] = v27;
    *(_WORD *)&v43[10] = 2048;
    *(void *)&v43[12] = v29;
    *(_WORD *)&v43[20] = 2048;
    *(void *)&v43[22] = v30;
    *(_WORD *)&v43[30] = 2048;
    __int16 v44 = 2048;
    uint64_t v45 = v32;
    __int16 v46 = 2048;
    uint64_t v47 = v33;
    __int16 v48 = 2048;
    uint64_t v49 = v34;
    __int16 v50 = 2048;
    uint64_t v51 = v35;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] feeding published run,isValid,%d,runCount,%d,recordId,%llu,startTime,%f,endTime,%f,duration,%f,runDist ance,%f,runVertical,%f,runSpeed,%f,currentDuration,%f,currentDistance,%f,currentVertical,%f,totalDuration,%f,total Distance,%f,totalVertical,%f",  v41,  144,  *(void *)v41,  *(double *)&v41[8],  v24,  *(double *)v42,  *(double *)&v42[8],  *(double *)&v42[16],  *(double *)&v42[24],  v28,  *(double *)v43,  *(double *)&v43[8],  *(double *)&v43[16],  *(double *)&v43[24],  v31);
    uint64_t v37 = (uint8_t *)v36;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::feedPublishedRun(const CLSkiEntry &, BOOL)",  "%s\n",  v36);
    if (v37 != buf) {
      free(v37);
    }
  }

  double v20 = *(double *)(a2 + 56) - *(double *)(a1 + 824);
  double v21 = *(double *)(a2 + 88) - *(double *)(a1 + 832);
  *(void *)(a1 + 816) = 0LL;
  *(void *)(a1 + 824) = 0LL;
  *(void *)(a1 + 832) = 0LL;
  if (v20 < 0.0 || v21 < 0.0)
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    __int128 v22 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(double *)uint64_t v53 = v20;
      *(_WORD *)&v53[8] = 2048;
      *(double *)int v54 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "[live data] we overestimated live updates, discounting from the next run,distanceDelta,%f,verticalDelta,%f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      *(_DWORD *)uint64_t v41 = 134218240;
      *(double *)&v41[4] = v20;
      *(_WORD *)&v41[12] = 2048;
      *(double *)&v41[14] = v21;
      LODWORD(v40) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] we overestimated live updates, discounting from the next run,distanceDelta,%f,verticalDelta,%f",  COERCE_DOUBLE(v41),  v40);
      uint64_t v39 = (uint8_t *)v38;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSkiLiveDataController::feedPublishedRun(const CLSkiEntry &, BOOL)",  "%s\n",  v38);
      if (v39 != buf) {
        free(v39);
      }
    }

    *(double *)(a1 + 848) = fabs(v20);
    *(double *)(a1 + 856) = fabs(v21);
  }

  else
  {
    *(void *)(a1 + 856) = 0LL;
    *(_OWORD *)(a1 + 840) = 0u;
  }

  if (*(_BYTE *)(a1 + 64)) {
    *(_BYTE *)(a1 + 64) = 0;
  }
  if (*(_BYTE *)(a1 + 136)) {
    *(_BYTE *)(a1 + 136) = 0;
  }
  if (*(_BYTE *)(a1 + 208)) {
    *(_BYTE *)(a1 + 208) = 0;
  }
  if (*(_BYTE *)(a1 + 408)) {
    *(_BYTE *)(a1 + 408) = 0;
  }
  if (*(_BYTE *)(a1 + 608)) {
    *(_BYTE *)(a1 + 608) = 0;
  }
  if (*(_BYTE *)(a1 + 808)) {
    *(_BYTE *)(a1 + 808) = 0;
  }
}

void sub_100F45B84(uint64_t a1)
{
}

void sub_100F45BE4(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 912) < a2)
  {
    if (qword_101934660 != -1) {
      dispatch_once(&qword_101934660, &stru_10188D870);
    }
    double v4 = (os_log_s *)qword_101934668;
    if (os_log_type_enabled((os_log_t)qword_101934668, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 912);
      *(_DWORD *)buf = 134218240;
      uint64_t v16 = v5;
      __int16 v17 = 2048;
      double v18 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[live data] updated max speed from %f to %f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934660 != -1) {
        dispatch_once(&qword_101934660, &stru_10188D870);
      }
      uint64_t v7 = *(void *)(a1 + 912);
      int v11 = 134218240;
      uint64_t v12 = v7;
      __int16 v13 = 2048;
      double v14 = a2;
      LODWORD(v10) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934668,  0LL,  "[live data] updated max speed from %f to %f",  COERCE_DOUBLE(&v11),  v10);
      double v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSkiLiveDataController::updateMaxSpeed(double)", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  double v6 = *(double *)(a1 + 912);
  if (v6 <= a2) {
    double v6 = a2;
  }
  *(double *)(a1 + 912) = v6;
}

BOOL sub_100F45DD4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 64)) {
    BOOL v2 = *(_BYTE *)(a2 + 64) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2
      && ((double)(*(_DWORD *)(a2 + 16) - *(_DWORD *)(a1 + 16))
}

void sub_100F45E38(id a1)
{
  qword_101934668 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Skiing");
}

void sub_100F45F08(id a1)
{
  qword_10199F5E8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLAudioAccessoryServiceSilo");
}

void sub_100F45FBC(id a1)
{
}

id sub_100F461AC(uint64_t a1, uint64_t a2, void *a3)
{
  return _[a3 onAudioAccessoryInterfaceDailyUsageCallback:a1 data:a2];
}

void sub_100F46E98(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

void sub_100F472A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100F474D8(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v3 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v3;
  }

  *(_OWORD *)(__dst + 72) = 0u;
  *(_OWORD *)(__dst + 56) = 0u;
  *(_OWORD *)(__dst + 40) = 0u;
  *(_OWORD *)(__dst + 24) = 0u;
  *((void *)__dst + 11) = 0LL;
  *((void *)__dst + 12) = 0xC08F380000000000LL;
  return __dst;
}

uint64_t sub_100F47544(uint64_t result, uint64_t a2, double a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  if (v3 != v4)
  {
    double v6 = (void *)result;
    double v79 = (uint64_t *)(result + 24);
    do
    {
      unint64_t v7 = v6[3];
      unint64_t v8 = v6[4];
      v84 = *(void **)v3;
      if (*(char *)(v3 + 31) < 0)
      {
        sub_1010DD48C(&__p, *(void **)(v3 + 8), *(void *)(v3 + 16));
      }

      else
      {
        __int128 v9 = *(_OWORD *)(v3 + 8);
        uint64_t v86 = *(void *)(v3 + 24);
        __int128 __p = v9;
      }

      __int128 v10 = *(_OWORD *)(v3 + 32);
      __int128 v11 = *(_OWORD *)(v3 + 48);
      __int128 v12 = *(_OWORD *)(v3 + 64);
      uint64_t v90 = *(void *)(v3 + 80);
      __int128 v88 = v11;
      __int128 v89 = v12;
      __int128 v87 = v10;
      if (v7 != v8)
      {
        while (1)
        {
          int v13 = *(_DWORD *)(v7 + 24);
          v80[0] = v84;
          unint64_t v14 = sub_1005B46E8((uint64_t)v80);
          v7 += 80LL;
          if (v7 == v8)
          {
            unint64_t v7 = v8;
            break;
          }
        }
      }

      if (SHIBYTE(v86) < 0) {
        operator delete((void *)__p);
      }
      uint64_t v15 = (int *)(v3 + 32);
      if (v7 == v6[4])
      {
        memset(v83, 0, sizeof(v83));
        __int128 v81 = 0u;
        *(_OWORD *)__int16 v82 = 0u;
        *(_OWORD *)__int16 v80 = 0u;
        if (v7 >= v6[5])
        {
          uint64_t v26 = sub_100F48CEC(v79, (uint64_t)v80);
          uint64_t v27 = v82[0];
          v6[4] = v26;
          if (v27)
          {
            v82[1] = v27;
            operator delete(v27);
          }
        }

        else
        {
          *(void *)(v7 + 8) = 0LL;
          *(void *)(v7 + 16) = 0LL;
          *(void *)unint64_t v7 = 0LL;
          *(_OWORD *)unint64_t v7 = *(_OWORD *)v80;
          *(void *)(v7 + 16) = v81;
          v80[0] = 0LL;
          v80[1] = 0LL;
          *(void *)&__int128 v81 = 0LL;
          *(_DWORD *)(v7 + 24) = DWORD2(v81);
          *(void *)(v7 + 40) = 0LL;
          *(void *)(v7 + 48) = 0LL;
          *(void *)(v7 + 32) = 0LL;
          *(_OWORD *)(v7 + 32) = *(_OWORD *)v82;
          *(void *)(v7 + 48) = *(void *)&v83[0];
          v82[0] = 0LL;
          v82[1] = 0LL;
          *(void *)&v83[0] = 0LL;
          __int128 v19 = *(_OWORD *)((char *)v83 + 8);
          *(_DWORD *)(v7 + 72) = DWORD2(v83[1]);
          *(_OWORD *)(v7 + 56) = v19;
          v6[4] = v7 + 80;
        }

        if (v80[0])
        {
          v80[1] = v80[0];
          operator delete(v80[0]);
        }

        uint64_t v28 = v6[4];
        v80[0] = *(void **)v3;
        unint64_t v29 = sub_1005B46E8((uint64_t)v80);
        *(_DWORD *)(v28 - 56) = sub_100DEA75C(v29);
        uint64_t v30 = *(double **)(v28 - 72);
        unint64_t v31 = *(void *)(v28 - 64);
        if ((unint64_t)v30 >= v31)
        {
          uint64_t v33 = *(double **)(v28 - 80);
          uint64_t v34 = v30 - v33;
          unint64_t v35 = v31 - (void)v33;
          unint64_t v36 = (uint64_t)(v31 - (void)v33) >> 2;
          if (v36 <= v34 + 1) {
            unint64_t v36 = v34 + 1;
          }
          if (v35 >= 0x7FFFFFFFFFFFFFF8LL) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          if (v37)
          {
            uint64_t v38 = (char *)sub_1000071BC(v28 - 64, v37);
            uint64_t v33 = *(double **)(v28 - 80);
            uint64_t v30 = *(double **)(v28 - 72);
          }

          else
          {
            uint64_t v38 = 0LL;
          }

          uint64_t v53 = (double *)&v38[8 * v34];
          *uint64_t v53 = a3;
          uint64_t v32 = v53 + 1;
          while (v30 != v33)
          {
            uint64_t v54 = *((void *)v30-- - 1);
            *((void *)v53-- - 1) = v54;
          }

          *(void *)(v28 - 80) = v53;
          *(void *)(v28 - 72) = v32;
          *(void *)(v28 - 64) = &v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }

        else
        {
          *uint64_t v30 = a3;
          uint64_t v32 = v30 + 1;
        }

        unint64_t v55 = *(void *)(v28 - 32);
        *(void *)(v28 - 72) = v32;
        int v56 = *v15;
        __int16 v57 = *(char **)(v28 - 40);
        if ((unint64_t)v57 >= v55)
        {
          __int16 v59 = *(char **)(v28 - 48);
          uint64_t v60 = (v57 - v59) >> 2;
          if ((unint64_t)(v60 + 1) >> 62) {
LABEL_104:
          }
            sub_100007008();
          unint64_t v61 = v55 - (void)v59;
          unint64_t v62 = (uint64_t)(v55 - (void)v59) >> 1;
          if (v62 <= v60 + 1) {
            unint64_t v62 = v60 + 1;
          }
          if (v61 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v63 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v63 = v62;
          }
          if (v63)
          {
            uint64_t v64 = (char *)sub_10000956C(v28 - 32, v63);
            __int16 v59 = *(char **)(v28 - 48);
            __int16 v57 = *(char **)(v28 - 40);
          }

          else
          {
            uint64_t v64 = 0LL;
          }

          __int16 v65 = &v64[4 * v60];
          *(_DWORD *)__int16 v65 = v56;
          double v58 = v65 + 4;
          while (v57 != v59)
          {
            int v66 = *((_DWORD *)v57 - 1);
            v57 -= 4;
            *((_DWORD *)v65 - 1) = v66;
            v65 -= 4;
          }

          *(void *)(v28 - 48) = v65;
          *(void *)(v28 - 40) = v58;
          *(void *)(v28 - 32) = &v64[4 * v63];
          if (v59) {
            operator delete(v59);
          }
        }

        else
        {
          *(_DWORD *)__int16 v57 = v56;
          double v58 = v57 + 4;
        }

        *(void *)(v28 - 40) = v58;
      }

      else
      {
        unint64_t v16 = *(void *)(v7 + 16);
        __int16 v17 = *(double **)(v7 + 8);
        if ((unint64_t)v17 >= v16)
        {
          double v20 = *(double **)v7;
          uint64_t v21 = ((uint64_t)v17 - *(void *)v7) >> 3;
          unint64_t v22 = v21 + 1;
          uint64_t v23 = v16 - (void)v20;
          if (v23 >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            double v25 = (char *)sub_1000071BC(v7 + 16, v24);
            double v20 = *(double **)v7;
            __int16 v17 = *(double **)(v7 + 8);
          }

          else
          {
            double v25 = 0LL;
          }

          uint64_t v39 = (double *)&v25[8 * v21];
          *uint64_t v39 = a3;
          double v18 = v39 + 1;
          while (v17 != v20)
          {
            uint64_t v40 = *((void *)v17-- - 1);
            *((void *)v39-- - 1) = v40;
          }

          *(void *)unint64_t v7 = v39;
          *(void *)(v7 + 8) = v18;
          *(void *)(v7 + 16) = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }

        else
        {
          double *v17 = a3;
          double v18 = v17 + 1;
        }

        unint64_t v41 = *(void *)(v7 + 48);
        *(void *)(v7 + 8) = v18;
        int v42 = *v15;
        double v43 = *(char **)(v7 + 40);
        if ((unint64_t)v43 >= v41)
        {
          uint64_t v45 = *(char **)(v7 + 32);
          uint64_t v46 = (v43 - v45) >> 2;
          unint64_t v47 = v41 - (void)v45;
          unint64_t v48 = (uint64_t)(v41 - (void)v45) >> 1;
          if (v48 <= v46 + 1) {
            unint64_t v48 = v46 + 1;
          }
          if (v47 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v48;
          }
          if (v49)
          {
            __int16 v50 = (char *)sub_10000956C(v7 + 48, v49);
            uint64_t v45 = *(char **)(v7 + 32);
            double v43 = *(char **)(v7 + 40);
          }

          else
          {
            __int16 v50 = 0LL;
          }

          uint64_t v51 = &v50[4 * v46];
          *(_DWORD *)uint64_t v51 = v42;
          __int16 v44 = v51 + 4;
          while (v43 != v45)
          {
            int v52 = *((_DWORD *)v43 - 1);
            v43 -= 4;
            *((_DWORD *)v51 - 1) = v52;
            v51 -= 4;
          }

          *(void *)(v7 + 32) = v51;
          *(void *)(v7 + 40) = v44;
          *(void *)(v7 + 48) = &v50[4 * v49];
          if (v45) {
            operator delete(v45);
          }
        }

        else
        {
          *(_DWORD *)double v43 = v42;
          __int16 v44 = v43 + 4;
        }

        *(void *)(v7 + 40) = v44;
      }

      v3 += 88LL;
    }

    while (v3 != v4);
    unint64_t v67 = v6[8];
    uint64_t v68 = (double *)v6[7];
    if ((unint64_t)v68 >= v67)
    {
      uint64_t v70 = (double *)v6[6];
      uint64_t v71 = v68 - v70;
      if ((unint64_t)(v71 + 1) >> 61) {
LABEL_106:
      }
        sub_100007008();
      unint64_t v72 = v67 - (void)v70;
      unint64_t v73 = (uint64_t)(v67 - (void)v70) >> 2;
      if (v73 <= v71 + 1) {
        unint64_t v73 = v71 + 1;
      }
      if (v72 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v74 = v73;
      }
      if (v74)
      {
        __int16 v75 = (char *)sub_1000071BC((uint64_t)(v6 + 8), v74);
        uint64_t v70 = (double *)v6[6];
        uint64_t v68 = (double *)v6[7];
      }

      else
      {
        __int16 v75 = 0LL;
      }

      uint64_t v76 = (double *)&v75[8 * v71];
      __int16 v77 = &v75[8 * v74];
      *uint64_t v76 = a3;
      __int16 v69 = v76 + 1;
      while (v68 != v70)
      {
        uint64_t v78 = *((void *)v68-- - 1);
        *((void *)v76-- - 1) = v78;
      }

      v6[6] = v76;
      v6[7] = v69;
      v6[8] = v77;
      if (v70) {
        operator delete(v70);
      }
    }

    else
    {
      double *v68 = a3;
      __int16 v69 = v68 + 1;
    }

    v6[7] = v69;
    return sub_100F47B0C(v6, a3);
  }

  return result;
}

void sub_100F47AE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
}

uint64_t sub_100F47B0C(void *a1, double a2)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  uint64_t v4 = (uint64_t)(a1 + 3);
  if (v5 == v6)
  {
LABEL_26:
    uint64_t v13 = v5;
  }

  else
  {
LABEL_2:
    unint64_t v8 = *(double **)v5;
    unint64_t v7 = *(double **)(v5 + 8);
    while (v8 != v7)
    {
      if (vabdd_f64(a2, *v8) <= 150.0)
      {
        v5 += 80LL;
        if (v5 != v6) {
          goto LABEL_2;
        }
        uint64_t v13 = v6;
        goto LABEL_27;
      }

      int64_t v9 = (char *)v7 - (char *)(v8 + 1);
      if (v7 != v8 + 1) {
        memmove(v8, v8 + 1, (char *)v7 - (char *)(v8 + 1));
      }
      unint64_t v7 = (double *)((char *)v8 + v9);
      *(void *)(v5 + 8) = (char *)v8 + v9;
      uint64_t v11 = *(void *)(v5 + 32);
      uint64_t v10 = *(void *)(v5 + 40);
      uint64_t v12 = v10 - (v11 + 4);
      if (v10 != v11 + 4)
      {
        memmove(*(void **)(v5 + 32), (const void *)(v11 + 4), v10 - (v11 + 4));
        unint64_t v7 = *(double **)(v5 + 8);
      }

      *(void *)(v5 + 40) = v11 + v12;
      unint64_t v8 = *(double **)v5;
    }

    if (v5 == v6) {
      goto LABEL_26;
    }
    uint64_t v14 = v5 + 80;
    if (v5 + 80 == v6) {
      goto LABEL_26;
    }
    uint64_t v13 = v5;
    do
    {
      uint64_t v15 = v5;
      uint64_t v5 = v14;
      __int16 v17 = *(double **)(v15 + 80);
      unint64_t v16 = *(double **)(v15 + 88);
      if (v17 != v16)
      {
        while (vabdd_f64(a2, *v17) > 150.0)
        {
          int64_t v18 = (char *)v16 - (char *)(v17 + 1);
          if (v16 != v17 + 1) {
            memmove(v17, v17 + 1, (char *)v16 - (char *)(v17 + 1));
          }
          unint64_t v16 = (double *)((char *)v17 + v18);
          *(void *)(v15 + 88) = (char *)v17 + v18;
          uint64_t v20 = *(void *)(v15 + 112);
          uint64_t v19 = *(void *)(v15 + 120);
          uint64_t v21 = v19 - (v20 + 4);
          if (v19 != v20 + 4)
          {
            memmove(*(void **)(v15 + 112), (const void *)(v20 + 4), v19 - (v20 + 4));
            unint64_t v16 = *(double **)(v15 + 88);
          }

          *(void *)(v15 + 120) = v20 + v21;
          __int16 v17 = *(double **)v5;
        }

        sub_100007664(v13, (__n128 *)v5);
        *(_DWORD *)(v13 + 24) = *(_DWORD *)(v15 + 104);
        sub_100007664(v13 + 32, (__n128 *)(v15 + 112));
        __int128 v22 = *(_OWORD *)(v15 + 136);
        *(_DWORD *)(v13 + 72) = *(_DWORD *)(v15 + 152);
        *(_OWORD *)(v13 + 56) = v22;
        v13 += 80LL;
      }

uint64_t sub_100F47E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_100F4907C((uint64_t)&v9, a3, *(void *)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 80LL;
        sub_10031CCB4(a1 + 16, v7);
      }

      while (v7 != v6);
    }

    *(void *)(a1 + 8) = v6;
  }

  return a2;
}

double sub_100F47E8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  uint64_t v2 = *(void *)(a1 + 80);
  if (v1 == v2) {
    return 0.0;
  }
  else {
    return *(double *)(v2 - 8) - *(double *)(v1 + 8);
  }
}

double sub_100F47EB0(uint64_t a1)
{
  double v1 = *(double *)(a1 + 96);
  if (v1 == -999.0) {
    return -1.0;
  }
  __int128 v3 = xmmword_101366360;
  double v5 = (v1 + 96.0) / 65.5;
  sub_100CC57E4((uint64_t)&v5, v4, (uint64_t *)&v3, 2LL, 1LL);
  return v4[0];
}

float sub_100F47F54(uint64_t a1, double a2)
{
  __int128 v3 = *(double **)(a1 + 48);
  uint64_t v4 = *(double **)(a1 + 56);
  double v5 = 0.0;
  double v6 = 0.0;
  if (v3 != v4) {
    double v6 = vabdd_f64(*(v4 - 1), *v3);
  }
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  if (v7 != v8) {
    double v5 = *(double *)(v8 - 8) - *(double *)(v7 + 8);
  }
  BOOL v10 = v6 <= 120.0
     || v5 < 100.0
     || 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4) < 2;
  sub_100F48298((uint64_t *)a1);
  float v11 = sub_100F4846C(a1);
  double v12 = sub_100F47EB0(a1);
  if (qword_101934750 != -1) {
    dispatch_once(&qword_101934750, &stru_10188DBC0);
  }
  uint64_t v13 = (os_log_s *)qword_101934758;
  if (os_log_type_enabled((os_log_t)qword_101934758, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = a1;
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4);
    *(_DWORD *)buf = 136316674;
    uint64_t v36 = v14;
    __int16 v37 = 2050;
    double v38 = v6;
    __int16 v39 = 2050;
    double v40 = v5;
    __int16 v41 = 2050;
    unint64_t v42 = v15;
    __int16 v43 = 1026;
    BOOL v44 = v10;
    __int16 v45 = 2050;
    double v46 = v11;
    __int16 v47 = 2050;
    double v48 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "IndoorOutdoor,WifiModel,context,%s,scanRange,%{public}f,distanceTraveled,%{public}f,numAps,%{public}zu,invalidResu lt,%{public}d,stationaryProbability,%{public}f,wifiRssiModelIndoorProbability,%{public}f",  buf,  0x44u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934750 != -1) {
      dispatch_once(&qword_101934750, &stru_10188DBC0);
    }
    uint64_t v17 = a1;
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4);
    int v21 = 136316674;
    uint64_t v22 = v17;
    __int16 v23 = 2050;
    double v24 = v6;
    __int16 v25 = 2050;
    double v26 = v5;
    __int16 v27 = 2050;
    unint64_t v28 = v18;
    __int16 v29 = 1026;
    BOOL v30 = v10;
    __int16 v31 = 2050;
    double v32 = v11;
    __int16 v33 = 2050;
    double v34 = v12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934758,  1LL,  "IndoorOutdoor,WifiModel,context,%s,scanRange,%{public}f,distanceTraveled,%{public}f,numAps,%{public}zu,invalidResu lt,%{public}d,stationaryProbability,%{public}f,wifiRssiModelIndoorProbability,%{public}f",  &v21,  68);
    uint64_t v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CLIndoorOutdoorWifiModel::computeProbability(CFAbsoluteTime)",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  if (v10)
  {
    float v11 = -1.0;
    if (v5 < 100.0) {
      return v12;
    }
  }

  return v11;
}

void sub_100F48298(uint64_t *a1)
{
  a1[12] = 0xC08F380000000000LL;
  uint64_t v1 = a1[3];
  for (uint64_t i = a1[4]; v1 != i; v1 += 80LL)
  {
    uint64_t v4 = (*(void *)(v1 + 8) - *(void *)v1) >> 3;
    if ((int)v4 >= 2)
    {
      float v5 = sub_100F488C8(a1, (uint64_t *)(v1 + 32), 25.0);
      uint64_t v7 = (double *)a1[6];
      uint64_t v6 = a1[7];
      double v8 = (*(double *)(*(void *)(v1 + 8) - 8LL) - **(double **)v1) / (*(double *)(v6 - 8) - *v7);
      double v9 = v5;
      double v10 = exp( (v8 + -0.00137940772) / 0.998620592 * 5.78228066 + ((double)(int)v4 / (double)(unint64_t)((v6 - (uint64_t)v7) >> 3) + -0.0689655172)
            / 0.931034483
            * 1.87654821
            + (v5 + 99.25) / 71.25 * 1.10882815
            + -5.98543736);
      *(double *)(v1 + 56) = v8;
      *(double *)(v1 + 64) = v10 / (v10 + 1.0);
      float v11 = *(int **)(v1 + 32);
      double v12 = *(int **)(v1 + 40);
      if (v11 != v12)
      {
        uint64_t v13 = v11 + 1;
        if (v11 + 1 != v12)
        {
          int v14 = *v11;
          unint64_t v15 = v11 + 1;
          do
          {
            int v17 = *v15++;
            int v16 = v17;
            BOOL v18 = v14 < v17;
            if (v14 <= v17) {
              int v14 = v16;
            }
            if (v18) {
              float v11 = v13;
            }
            uint64_t v13 = v15;
          }

          while (v15 != v12);
        }
      }

      *(_DWORD *)(v1 + 72) = *v11;
    }
  }

float sub_100F4846C(uint64_t a1)
{
  unint64_t v61 = 0LL;
  unint64_t v62 = 0LL;
  unint64_t v63 = 0LL;
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v1 == v2)
  {
    uint64_t v22 = 0LL;
    unint64_t v3 = 0LL;
  }

  else
  {
    unint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(int **)(v1 + 32);
      float v5 = *(int **)(v1 + 40);
      uint64_t v6 = v4 + 1;
      if (v4 != v5 && v6 != v5)
      {
        int v8 = *v4;
        int v9 = *v4;
        double v10 = v4 + 1;
        float v11 = *(int **)(v1 + 32);
        double v12 = v4 + 1;
        do
        {
          int v14 = *v12++;
          int v13 = v14;
          BOOL v15 = v9 < v14;
          if (v9 <= v14) {
            int v9 = v13;
          }
          if (v15) {
            float v11 = v10;
          }
          double v10 = v12;
        }

        while (v12 != v5);
        int v16 = *v11;
        int v17 = v4 + 1;
        do
        {
          int v19 = *v17++;
          int v18 = v19;
          if (v19 < v8)
          {
            int v8 = v18;
            uint64_t v4 = v6;
          }

          uint64_t v6 = v17;
        }

        while (v17 != v5);
        int v20 = *v4;
        if (*(double *)(v1 + 64) > 0.0 && v16 != v20)
        {
          if (v3 >= v63)
          {
            unint64_t v3 = sub_100F493FC((uint64_t *)&v61, v1);
          }

          else
          {
            sub_100F49508((uint64_t)&v63, v3, v1);
            v3 += 80LL;
          }

          unint64_t v62 = (__int128 *)v3;
        }
      }

      v1 += 80LL;
    }

    while (v1 != v2);
    uint64_t v22 = v61;
  }

  unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3 - (void)v22) >> 4);
  float v24 = -1.0;
  if (v23 >= 2)
  {
    unint64_t v25 = 126 - 2 * __clz(v23);
    else {
      uint64_t v26 = v25;
    }
    sub_100F49594(v22, v3, v26, 1);
    uint64_t v27 = (uint64_t)v61;
    unint64_t v28 = 0xCCCCCCCCCCCCCCCDLL * (v62 - v61);
    if (v28 >= 0x1A)
    {
      uint64_t v33 = 0LL;
      int v29 = 0;
      do
      {
        v29 += (*((void *)&v61[v33] + 1) - *(void *)&v61[v33]) >> 3;
        v33 += 5LL;
      }

      while (v33 != 120);
    }

    else if (v61 == v62)
    {
      int v29 = 0;
    }

    else
    {
      int v29 = 0;
      BOOL v30 = v61;
      do
      {
        uint64_t v32 = *(void *)v30;
        uint64_t v31 = *((void *)v30 + 1);
        v30 += 5;
        v29 += (unint64_t)(v31 - v32) >> 3;
      }

      while (v30 != v62);
    }

    if ((int)v28 < 1)
    {
      double v34 = 0LL;
    }

    else
    {
      double v34 = 0LL;
      unint64_t v35 = 0LL;
      uint64_t v36 = 0LL;
      uint64_t v37 = 0LL;
      double v38 = (double)v29;
      do
      {
        uint64_t v39 = v27 + 80 * v37;
        double v40 = (double)(int)((*(void *)(v39 + 8) - *(void *)v39) >> 3) / v38;
        double v41 = *(double *)(v39 + 64);
        double v42 = 1.0 - v41;
        if (v36 >= v35)
        {
          unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (v36 - v34) + 1;
          if (v43 > 0xAAAAAAAAAAAAAAALL) {
            sub_100007008();
          }
          if (0x5555555555555556LL * (v35 - v34) > v43) {
            unint64_t v43 = 0x5555555555555556LL * (v35 - v34);
          }
          if (0xAAAAAAAAAAAAAAABLL * (v35 - v34) >= 0x555555555555555LL) {
            unint64_t v44 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v44 = v43;
          }
          if (v44)
          {
            if (v44 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000070D4();
            }
            __int16 v45 = (char *)operator new(24 * v44);
          }

          else
          {
            __int16 v45 = 0LL;
          }

          double v46 = (double *)&v45[8 * (v36 - v34)];
          *double v46 = v40;
          v46[1] = v41;
          v46[2] = v42;
          if (v36 == v34)
          {
            unint64_t v49 = v36;
            double v34 = (double *)&v45[8 * (v36 - v34)];
          }

          else
          {
            __int16 v47 = (double *)&v45[8 * (v36 - v34)];
            do
            {
              __int128 v48 = *(_OWORD *)(v36 - 3);
              *(v47 - 1) = *(v36 - 1);
              *(_OWORD *)(v47 - 3) = v48;
              v47 -= 3;
              v36 -= 3;
            }

            while (v36 != v34);
            unint64_t v49 = v34;
            double v34 = v47;
          }

          unint64_t v35 = (double *)&v45[24 * v44];
          uint64_t v36 = v46 + 3;
          if (v49) {
            operator delete(v49);
          }
        }

        else
        {
          *uint64_t v36 = v40;
          v36[1] = v41;
          v36[2] = v42;
          v36 += 3;
        }

        ++v37;
        uint64_t v27 = (uint64_t)v61;
        int v50 = -858993459 * ((unint64_t)((char *)v62 - (char *)v61) >> 4);
        if (v50 >= 25) {
          int v50 = 25;
        }
      }

      while (v37 < v50);
      if (v34 != v36)
      {
        double v51 = 1.0;
        int v52 = v34;
        do
        {
          double v54 = *v52;
          double v53 = v52[1];
          v52 += 3;
          double v51 = v51 * pow(v53, v54);
        }

        while (v52 != v36);
        double v55 = 1.0;
        int v56 = v34;
        do
        {
          double v57 = v56[2];
          double v58 = *v56;
          v56 += 3;
          double v55 = v55 * pow(v57, v58);
        }

        while (v56 != v36);
LABEL_73:
        double v59 = exp(v51 * (1.0 / (v51 + v55)) * 11.1434693 + -4.35656828);
        float v24 = v59 / (v59 + 1.0);
        if (v34) {
          operator delete(v34);
        }
        goto LABEL_75;
      }
    }

    double v51 = 1.0;
    double v55 = 1.0;
    goto LABEL_73;
  }

void sub_100F48888( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10031CC30(&a12);
  _Unwind_Resume(a1);
}

float sub_100F488C8(uint64_t *a1, uint64_t *a2, float a3)
{
  uint64_t v5 = *a2;
  uint64_t v6 = (int *)a2[1];
  uint64_t v7 = (uint64_t)v6 - *a2;
  if ((unint64_t)v7 > 7)
  {
    float v15 = (float)(a3 / 100.0) * (float)(unint64_t)((v7 >> 2) - 1);
    float v16 = floorf(v15);
    float v17 = ceilf(v15);
    if (v16 == v17)
    {
      int v18 = (int *)(v5 + 4 * (uint64_t)v15);
      if (v18 != v6)
      {
        sub_100F49100(v5, v18, v6);
        uint64_t v5 = *a2;
      }

      return (float)*(int *)(v5 + 4 * (unint64_t)v15);
    }

    else
    {
      int v19 = (int *)(v5 + 4 * (uint64_t)v16);
      if (v19 != v6)
      {
        sub_100F49100(v5, v19, v6);
        uint64_t v5 = *a2;
        uint64_t v6 = (int *)a2[1];
      }

      int v20 = *(_DWORD *)(v5 + 4 * (unint64_t)v16);
      int v21 = (int *)(v5 + 4 * (uint64_t)v17);
      if (v21 != v6)
      {
        sub_100F49100(v5, v21, v6);
        uint64_t v5 = *a2;
      }
    }
  }

  else
  {
    if (qword_101934750 != -1) {
      dispatch_once(&qword_101934750, &stru_10188DBC0);
    }
    int v8 = (os_log_s *)qword_101934758;
    if (os_log_type_enabled((os_log_t)qword_101934758, OS_LOG_TYPE_ERROR))
    {
      int v9 = a1;
      uint64_t v10 = (a2[1] - *a2) >> 2;
      *(_DWORD *)buf = 136315394;
      unint64_t v28 = v9;
      __int16 v29 = 2050;
      uint64_t v30 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "IndoorOutdoor, context, %s, can't compute percentile on buffer of this size %{public}zu",  buf,  0x16u);
    }

    float v11 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934750 != -1) {
        dispatch_once(&qword_101934750, &stru_10188DBC0);
      }
      uint64_t v12 = (a2[1] - *a2) >> 2;
      int v23 = 136315394;
      float v24 = a1;
      __int16 v25 = 2050;
      uint64_t v26 = v12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934758,  16LL,  "IndoorOutdoor, context, %s, can't compute percentile on buffer of this size %{public}zu",  &v23,  22);
      int v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CLIndoorOutdoorWifiModel::computePercentile(std::vector<int> &, float)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  return v11;
}

void sub_100F48BA4(void *a1, double a2, double a3, double a4)
{
  uint64_t v7 = (double *)a1[9];
  int v8 = (double *)a1[10];
  if (v7 == v8) {
    double v9 = 0.0;
  }
  else {
    double v9 = *(v8 - 1);
  }
  double v10 = v9 + a3;
  unint64_t v11 = a1[11];
  if ((unint64_t)v8 >= v11)
  {
    uint64_t v13 = ((char *)v8 - (char *)v7) >> 4;
    unint64_t v14 = v13 + 1;
    uint64_t v15 = v11 - (void)v7;
    if (v15 >> 3 > v14) {
      unint64_t v14 = v15 >> 3;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      float v17 = (char *)sub_100037038((uint64_t)(a1 + 11), v16);
      uint64_t v7 = (double *)a1[9];
      int v8 = (double *)a1[10];
    }

    else
    {
      float v17 = 0LL;
    }

    int v18 = (double *)&v17[16 * v13];
    int v19 = &v17[16 * v16];
    *int v18 = a2;
    v18[1] = v10;
    uint64_t v12 = v18 + 2;
    if (v8 != v7)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v8 - 1);
        v18 -= 2;
        v8 -= 2;
      }

      while (v8 != v7);
      uint64_t v7 = (double *)a1[9];
    }

    a1[9] = v18;
    a1[10] = v12;
    a1[11] = v19;
    if (v7) {
      operator delete(v7);
    }
  }

  else
  {
    double *v8 = a2;
    v8[1] = v10;
    uint64_t v12 = v8 + 2;
  }

  a1[10] = v12;
}

void sub_100F48CC0(id a1)
{
  qword_101934758 = (uint64_t)os_log_create("com.apple.locationd.Motion", "IndoorOutdoor");
}

uint64_t sub_100F48CEC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x199999999999999LL) {
    unint64_t v9 = 0x333333333333333LL;
  }
  else {
    unint64_t v9 = v5;
  }
  v15[4] = a1 + 2;
  if (v9) {
    double v10 = (char *)sub_10003E20C(v7, v9);
  }
  else {
    double v10 = 0LL;
  }
  unint64_t v11 = &v10[80 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v15[3] = &v10[80 * v9];
  *(void *)unint64_t v11 = 0LL;
  *((void *)v11 + 1) = 0LL;
  *((void *)v11 + 2) = 0LL;
  *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
  *((void *)v11 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = 0LL;
  *((_DWORD *)v11 + 6) = *(_DWORD *)(a2 + 24);
  *((void *)v11 + 5) = 0LL;
  *((void *)v11 + 6) = 0LL;
  *((void *)v11 + 4) = 0LL;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  __int128 v12 = *(_OWORD *)(a2 + 56);
  *((_DWORD *)v11 + 18) = *(_DWORD *)(a2 + 72);
  *(_OWORD *)(v11 + 56) = v12;
  v15[2] = v11 + 80;
  sub_100F48E38(a1, v15);
  uint64_t v13 = a1[1];
  sub_100F49008(v15);
  return v13;
}

void sub_100F48E24(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F48E38(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100F48EAC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100F48EAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    do
    {
      *(void *)(v7 - 80) = 0LL;
      *(void *)(v7 - 72) = 0LL;
      *(void *)(v7 - 64) = 0LL;
      __int128 v8 = *(_OWORD *)(a3 - 80);
      a3 -= 80LL;
      *(_OWORD *)(v7 - 80) = v8;
      *(void *)(v7 - 64) = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      *(void *)a3 = 0LL;
      *(_DWORD *)(v7 - 56) = *(_DWORD *)(a3 + 24);
      *(void *)(v7 - 40) = 0LL;
      *(void *)(v7 - 32) = 0LL;
      *(void *)(v7 - 48) = 0LL;
      *(_OWORD *)(v7 - 48) = *(_OWORD *)(a3 + 32);
      *(void *)(v7 - 32) = *(void *)(a3 + 48);
      *(void *)(a3 + 32) = 0LL;
      *(void *)(a3 + 40) = 0LL;
      *(void *)(a3 + 48) = 0LL;
      int v9 = *(_DWORD *)(a3 + 72);
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 56);
      *(_DWORD *)(v7 - 8) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 80LL;
      *((void *)&v15 + 1) -= 80LL;
    }

    while (a3 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  sub_100F48F84((uint64_t)v12);
  return v10;
}

uint64_t sub_100F48F84(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100F48FB8((uint64_t *)a1);
  }
  return a1;
}

void sub_100F48FB8(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10031CCB4(v3, v1);
      v1 += 80LL;
    }

    while (v1 != v2);
  }

void **sub_100F49008(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100F49038(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 80;
    sub_10031CCB4(v4, i - 80);
  }

uint64_t sub_100F4907C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    sub_100007664(a4, (__n128 *)v5);
    *(_DWORD *)(a4 + 24) = *(_DWORD *)(v5 + 24);
    sub_100007664(a4 + 32, (__n128 *)(v5 + 32));
    __int128 v7 = *(_OWORD *)(v5 + 56);
    *(_DWORD *)(a4 + 72) = *(_DWORD *)(v5 + 72);
    *(_OWORD *)(a4 + 56) = v7;
    a4 += 80LL;
    v5 += 80LL;
  }

  while (v5 != v6);
  return v6;
}

uint64_t sub_100F49100(uint64_t result, int *a2, int *a3)
{
  if (a3 != a2)
  {
    uint64_t v3 = a3;
    uint64_t v5 = (int *)result;
    do
    {
      unint64_t v6 = v3 - v5;
      if (v6 < 2) {
        break;
      }
      if (v6 == 3) {
        return sub_100092FCC(v5, v5 + 1, v3 - 1);
      }
      if (v6 == 2)
      {
        int v33 = *(v3 - 1);
        int v34 = *v5;
        if (v33 < *v5)
        {
          *uint64_t v5 = v33;
          *(v3 - 1) = v34;
        }

        return result;
      }

      __int128 v7 = &v5[v6 >> 1];
      __int128 v8 = v3 - 1;
      uint64_t result = sub_100092FCC(v5, v7, v3 - 1);
      int v9 = *v5;
      if (*v5 >= *v7)
      {
        uint64_t v10 = v3 - 1;
        while (--v10 != v5)
        {
          if (*v10 < *v7)
          {
            *uint64_t v5 = *v10;
            *uint64_t v10 = v9;
            uint64_t result = (result + 1);
            goto LABEL_13;
          }
        }

        uint64_t v22 = v5 + 1;
        if (v9 >= *v8)
        {
          while (v22 != v8)
          {
            int v23 = *v22;
            if (v9 < *v22)
            {
              *v22++ = *v8;
              int *v8 = v23;
              goto LABEL_45;
            }

            ++v22;
          }

          return result;
        }

int *sub_100F49388(int *result, int *a2)
{
  while (result != a2 - 1)
  {
    uint64_t v2 = result++;
    if (v2 != a2 && result != a2)
    {
      int v3 = *v2;
      uint64_t v4 = result;
      uint64_t v5 = v2;
      unint64_t v6 = result;
      do
      {
        int v8 = *v6++;
        int v7 = v8;
        if (v8 < v3)
        {
          int v3 = v7;
          uint64_t v5 = v4;
        }

        uint64_t v4 = v6;
      }

      while (v6 != a2);
      if (v5 != v2)
      {
        int v9 = *v2;
        *uint64_t v2 = *v5;
        *uint64_t v5 = v9;
      }
    }
  }

  return result;
}

uint64_t sub_100F493FC(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x333333333333333LL) {
    sub_100007008();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999LL) {
    unint64_t v6 = 0x333333333333333LL;
  }
  else {
    unint64_t v6 = v4;
  }
  int v14 = a1 + 2;
  if (v6) {
    int v7 = (char *)sub_10003E20C((uint64_t)(a1 + 2), v6);
  }
  else {
    int v7 = 0LL;
  }
  uint64_t v10 = v7;
  unint64_t v11 = &v7[80 * v3];
  int v13 = &v7[80 * v6];
  sub_100F49508((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  __int128 v12 = v11 + 80;
  sub_100F48E38(a1, &v10);
  uint64_t v8 = a1[1];
  sub_100F49008(&v10);
  return v8;
}

void sub_100F494F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 sub_100F49508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  sub_100007590( (void *)a2,  *(const void **)a3,  *(void *)(a3 + 8),  (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  int v5 = *(_DWORD *)(a3 + 24);
  *(void *)(a2 + 32) = 0LL;
  *(_DWORD *)(a2 + 24) = v5;
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  sub_10001B72C( (void *)(a2 + 32),  *(const void **)(a3 + 32),  *(void *)(a3 + 40),  (uint64_t)(*(void *)(a3 + 40) - *(void *)(a3 + 32)) >> 2);
  __n128 result = *(__n128 *)(a3 + 56);
  *(_DWORD *)(a2 + 72) = *(_DWORD *)(a3 + 72);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

void sub_100F49578(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100F49594(__int128 *a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v6 = a1;
  v261 = a1;
  v260 = (__int128 *)a2;
  while (2)
  {
    uint64_t v7 = a2 - (void)v6;
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)v6) >> 4);
    switch(v8)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v260 = (__int128 *)(a2 - 80);
        unint64_t v86 = (uint64_t)(*(void *)(a2 - 72) - *(void *)(a2 - 80)) >> 3;
        uint64_t v87 = *((void *)v6 + 1) - *(void *)v6;
        if (v86 == v87 >> 3)
        {
          double v88 = *(double *)(a2 - 24);
          double v89 = *((double *)v6 + 7);
          BOOL v90 = v88 <= v89;
          if (v88 == v89) {
            BOOL v90 = *(_DWORD *)(a2 - 8) <= *((_DWORD *)v6 + 18);
          }
          if (v90) {
            return;
          }
        }

        else if (v86 <= v87 >> 3)
        {
          return;
        }

        sub_100F4A8B0(&v261, (uint64_t *)&v260);
        return;
      case 3uLL:
        v260 = (__int128 *)(a2 - 80);
        sub_100F4AB64((uint64_t)v6, (uint64_t)(v6 + 5), a2 - 80);
        return;
      case 4uLL:
        v260 = (__int128 *)(a2 - 80);
        sub_100F4B088((uint64_t)v6, (uint64_t)(v6 + 5), (uint64_t)(v6 + 10), a2 - 80);
        return;
      case 5uLL:
        v260 = (__int128 *)(a2 - 80);
        sub_100F4A9A4((uint64_t)v6, (uint64_t)(v6 + 5), (uint64_t)(v6 + 10), (uint64_t)(v6 + 15), a2 - 80);
        return;
      default:
        if (v7 <= 1919)
        {
          uint64_t v91 = v6 + 5;
          v252 = (__int128 *)a2;
          BOOL v93 = v6 == (__int128 *)a2 || v91 == (__int128 *)a2;
          if ((a4 & 1) == 0)
          {
            if (v93) {
              return;
            }
            for (uint64_t i = (char *)v6 + 136; ; i += 80)
            {
              v201 = v6;
              unint64_t v6 = v91;
              uint64_t v203 = *((void *)v201 + 10);
              uint64_t v202 = *((void *)v201 + 11);
              unint64_t v204 = (v202 - v203) >> 3;
              uint64_t v205 = *((void *)v201 + 1) - *(void *)v201;
              if (v204 == v205 >> 3) {
                break;
              }
              if (v204 > v205 >> 3) {
                goto LABEL_291;
              }
LABEL_305:
              uint64_t v91 = v6 + 5;
              if (v6 + 5 == v252) {
                return;
              }
            }

            double v206 = *((double *)v201 + 17);
            double v207 = *((double *)v201 + 7);
            BOOL v208 = v206 <= v207;
            if (v206 == v207) {
              BOOL v208 = *((_DWORD *)v201 + 38) <= *((_DWORD *)v201 + 18);
            }
            if (v208) {
              goto LABEL_305;
            }
LABEL_291:
            uint64_t v209 = *((void *)v201 + 12);
            *(void *)unint64_t v6 = 0LL;
            *((void *)v6 + 1) = 0LL;
            *((void *)v6 + 2) = 0LL;
            int v210 = *((_DWORD *)v201 + 26);
            __int128 v250 = v201[7];
            uint64_t v211 = *((void *)v201 + 16);
            *((void *)v201 + 15) = 0LL;
            *((void *)v201 + 16) = 0LL;
            *((void *)v201 + 14) = 0LL;
            __int128 v259 = *(__int128 *)((char *)v201 + 136);
            v212 = i;
            int v213 = *((_DWORD *)v201 + 38);
            while (1)
            {
              sub_100007664((uint64_t)(v212 - 56), (__n128 *)(v212 - 136));
              *((_DWORD *)v212 - 8) = *((_DWORD *)v212 - 28);
              sub_100007664((uint64_t)(v212 - 24), (__n128 *)(v212 - 104));
              *(_OWORD *)v212 = *((_OWORD *)v212 - 5);
              *((_DWORD *)v212 + 4) = *((_DWORD *)v212 - 16);
              uint64_t v214 = *((void *)v212 - 26) - *((void *)v212 - 27);
              if (v204 == v214 >> 3)
              {
                double v215 = *((double *)v212 - 20);
                BOOL v216 = *(double *)&v259 <= v215;
                if (v216)
                {
LABEL_300:
                  v217 = (void *)*((void *)v212 - 17);
                  if (v217)
                  {
                    *((void *)v212 - 16) = v217;
                    operator delete(v217);
                  }

                  *((void *)v212 - 17) = v203;
                  *((void *)v212 - 16) = v202;
                  *((void *)v212 - 15) = v209;
                  *((_DWORD *)v212 - 28) = v210;
                  v218 = (void *)*((void *)v212 - 13);
                  if (v218)
                  {
                    *((void *)v212 - 12) = v218;
                    operator delete(v218);
                  }

                  *(_OWORD *)(v212 - 104) = v250;
                  *((void *)v212 - 11) = v211;
                  *((_OWORD *)v212 - 5) = v259;
                  *((_DWORD *)v212 - 16) = v213;
                  goto LABEL_305;
                }
              }

              else if (v204 <= v214 >> 3)
              {
                goto LABEL_300;
              }

              v212 -= 80;
            }
          }

          if (v93) {
            return;
          }
          uint64_t v94 = 0LL;
          uint64_t v95 = v6;
LABEL_159:
          __int16 v96 = v95;
          uint64_t v95 = v91;
          uint64_t v97 = *((void *)v96 + 11);
          unint64_t v98 = (v97 - *((void *)v96 + 10)) >> 3;
          uint64_t v99 = *((void *)v96 + 1) - *(void *)v96;
          if (v98 == v99 >> 3)
          {
            double v100 = *((double *)v96 + 17);
            double v101 = *((double *)v96 + 7);
            BOOL v102 = v100 <= v101;
            if (v100 == v101) {
              BOOL v102 = *((_DWORD *)v96 + 38) <= *((_DWORD *)v96 + 18);
            }
            if (v102) {
              goto LABEL_184;
            }
          }

          else if (v98 <= v99 >> 3)
          {
            goto LABEL_184;
          }

          uint64_t v246 = *((void *)v96 + 10);
          uint64_t v231 = *((void *)v96 + 12);
          *(void *)uint64_t v91 = 0LL;
          *((void *)v91 + 1) = 0LL;
          *((void *)v91 + 2) = 0LL;
          int v226 = *((_DWORD *)v96 + 26);
          uint64_t v236 = *((void *)v96 + 14);
          __int128 v241 = *(__int128 *)((char *)v96 + 120);
          *((void *)v96 + 15) = 0LL;
          *((void *)v96 + 16) = 0LL;
          *((void *)v96 + 14) = 0LL;
          double v103 = *((double *)v96 + 17);
          uint64_t v104 = *((void *)v96 + 18);
          int v256 = *((_DWORD *)v96 + 38);
          sub_100007664((uint64_t)v91, (__n128 *)v96);
          *((_DWORD *)v95 + 6) = *((_DWORD *)v96 + 6);
          uint64_t v105 = (uint64_t)(v96 + 2);
          sub_100007664((uint64_t)(v95 + 2), (__n128 *)v96 + 2);
          uint64_t v106 = (uint64_t)v96 + 56;
          *(__int128 *)((char *)v95 + 56) = *(__int128 *)((char *)v96 + 56);
          *((_DWORD *)v95 + 18) = *((_DWORD *)v96 + 18);
          if (v96 == v6)
          {
            __int16 v96 = v6;
            goto LABEL_179;
          }

          uint64_t v223 = v97;
          uint64_t v107 = v94;
          while (1)
          {
            uint64_t v108 = (uint64_t)v6 + v107;
            uint64_t v109 = *(void *)((char *)v6 + v107 - 72) - *(void *)((char *)v6 + v107 - 80);
            if (v98 == v109 >> 3)
            {
              double v110 = *(double *)(v108 - 24);
              if (v103 == v110)
              {
              }

              else if (v103 <= v110)
              {
                __int16 v96 = (__int128 *)((char *)v6 + v107);
                uint64_t v106 = (uint64_t)v6 + v107 + 56;
                uint64_t v105 = (uint64_t)v6 + v107 + 32;
LABEL_177:
                uint64_t v97 = v223;
LABEL_179:
                v112 = *(void **)v96;
                if (*(void *)v96)
                {
                  *((void *)v96 + 1) = v112;
                  operator delete(v112);
                }

                *(void *)__int16 v96 = v246;
                *((void *)v96 + 1) = v97;
                *((void *)v96 + 2) = v231;
                *((_DWORD *)v96 + 6) = v226;
                v113 = *(void **)v105;
                if (*(void *)v105)
                {
                  *((void *)v96 + 5) = v113;
                  operator delete(v113);
                  *(void *)(v105 + 8) = 0LL;
                  *(void *)(v105 + 16) = 0LL;
                }

                *(void *)uint64_t v105 = v236;
                *(__int128 *)((char *)v96 + 40) = v241;
                *(double *)uint64_t v106 = v103;
                *(void *)(v106 + 8) = v104;
                *(_DWORD *)(v106 + 16) = v256;
LABEL_184:
                uint64_t v91 = v95 + 5;
                v94 += 80LL;
                if (v95 + 5 == v252) {
                  return;
                }
                goto LABEL_159;
              }
            }

            else if (v98 <= v109 >> 3)
            {
              goto LABEL_177;
            }

            sub_100007664(v108, (__n128 *)((char *)v6 + v107 - 80));
            v111 = (char *)v6 + v107;
            *(_DWORD *)((char *)v6 + v107 + 24) = *(_DWORD *)((char *)v6 + v107 - 56);
            uint64_t v105 = (uint64_t)(v96 - 3);
            sub_100007664((uint64_t)v6 + v107 + 32, (__n128 *)((char *)v6 + v107 - 48));
            uint64_t v106 = (uint64_t)v96 - 24;
            *(_OWORD *)(v111 + 56) = *(_OWORD *)(v111 - 24);
            *((_DWORD *)v111 + 18) = *((_DWORD *)v111 - 2);
            v96 -= 5;
            v107 -= 80LL;
            if (!v107)
            {
              uint64_t v106 = (uint64_t)v6 + 56;
              __int16 v96 = v6;
              goto LABEL_177;
            }
          }
        }

        if (!a3)
        {
          uint64_t v253 = a2;
          int64_t v114 = (v8 - 2) >> 1;
          while (1)
          {
            int64_t v115 = v114;
            uint64_t v116 = (2 * v114) | 1;
            v117 = (__n128 *)&v6[5 * v116];
            unint64_t v118 = (uint64_t)(v117->n128_u64[1] - v117->n128_u64[0]) >> 3;
            uint64_t v119 = v117[5].n128_u64[1] - v117[5].n128_u64[0];
            if (v118 == v119 >> 3) {
              break;
            }
            if (v118 > v119 >> 3) {
              goto LABEL_198;
            }
LABEL_199:
            v123 = &v6[5 * v114];
            unint64_t v124 = (uint64_t)(v117->n128_u64[1] - v117->n128_u64[0]) >> 3;
            unint64_t v125 = (uint64_t)(*((void *)v123 + 1) - *(void *)v123) >> 3;
            if (v124 == v125)
            {
              double v126 = v117[3].n128_f64[1];
              double v127 = *((double *)&v6[5 * v115 + 3] + 1);
              BOOL v128 = v126 <= v127;
              if (v126 == v127) {
                BOOL v128 = (signed __int32)v117[4].n128_u32[2] <= SDWORD2(v6[5 * v115 + 4]);
              }
              if (!v128) {
                goto LABEL_230;
              }
            }

            else
            {
              if (v124 > v125) {
                goto LABEL_230;
              }
              double v127 = *((double *)&v6[5 * v115 + 3] + 1);
            }

            unint64_t v237 = *(void *)v123;
            unint64_t v242 = *((void *)v123 + 1);
            unint64_t v224 = *((void *)v123 + 2);
            *(void *)v123 = 0LL;
            *((void *)v123 + 1) = 0LL;
            *((void *)v123 + 2) = 0LL;
            uint64_t v129 = (uint64_t)&v6[5 * v115];
            unint64_t v130 = *(void *)(v129 + 32);
            v129 += 32LL;
            unint64_t v232 = v130;
            unsigned __int32 v222 = *(_DWORD *)(v129 - 8);
            __n128 v227 = *(__n128 *)(v129 + 8);
            *(void *)uint64_t v129 = 0LL;
            *(void *)(v129 + 8) = 0LL;
            *(void *)(v129 + 16) = 0LL;
            uint64_t v131 = *(void *)(v129 + 32);
            signed __int32 v247 = *(_DWORD *)(v129 + 40);
            sub_100007664((uint64_t)v123, v117);
            *(_DWORD *)(v129 - 8) = v117[1].n128_u32[2];
            v132 = v117 + 2;
            sub_100007664(v129, v117 + 2);
            v133 = &v117[3].n128_i8[8];
            __int128 v134 = *(__int128 *)((char *)&v117[3] + 8);
            *(_DWORD *)(v129 + 40) = v117[4].n128_u32[2];
            *(_OWORD *)(v129 + 24) = v134;
            for (int64_t j = (v8 - 2) >> 1; ; int64_t j = (v8 - 2) >> 1)
            {
              if (j < v116) {
                goto LABEL_225;
              }
              uint64_t v136 = (uint64_t)v117;
              uint64_t v137 = 2 * v116;
              uint64_t v116 = (2 * v116) | 1;
              v117 = (__n128 *)&v6[5 * v116];
              if (v137 + 2 < (uint64_t)v8)
              {
                unint64_t v138 = (uint64_t)(v117->n128_u64[1] - v117->n128_u64[0]) >> 3;
                uint64_t v139 = v117[5].n128_u64[1] - v117[5].n128_u64[0];
                if (v138 != v139 >> 3)
                {
                  if (v138 <= v139 >> 3) {
                    goto LABEL_217;
                  }
LABEL_216:
                  v117 += 5;
                  uint64_t v116 = v137 + 2;
                  goto LABEL_217;
                }

                double v140 = *((double *)&v6[5 * v116 + 3] + 1);
                double v141 = v117[8].n128_f64[1];
                BOOL v142 = v140 <= v141;
                if (v140 == v141) {
                  BOOL v142 = SDWORD2(v6[5 * v116 + 4]) <= (signed __int32)v117[9].n128_u32[2];
                }
                if (!v142) {
                  goto LABEL_216;
                }
              }

__n128 sub_100F4A8B0(__int128 **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  __int128 v4 = **a1;
  uint64_t v5 = *((void *)*a1 + 2);
  *((void *)v2 + 1) = 0LL;
  *((void *)v2 + 2) = 0LL;
  *(void *)uint64_t v2 = 0LL;
  int v6 = *((_DWORD *)v2 + 6);
  __int128 v12 = v4;
  __int128 v13 = v2[2];
  uint64_t v7 = *((void *)v2 + 6);
  *((void *)v2 + 4) = 0LL;
  *((void *)v2 + 5) = 0LL;
  *((void *)v2 + 6) = 0LL;
  __n128 v14 = *(__n128 *)((char *)v2 + 56);
  int v15 = *((_DWORD *)v2 + 18);
  sub_100007664((uint64_t)v2, (__n128 *)v3);
  *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
  sub_100007664((uint64_t)(v2 + 2), (__n128 *)(v3 + 32));
  __int128 v8 = *(_OWORD *)(v3 + 56);
  *((_DWORD *)v2 + 18) = *(_DWORD *)(v3 + 72);
  *(__int128 *)((char *)v2 + 56) = v8;
  unint64_t v9 = *(void **)v3;
  if (*(void *)v3)
  {
    *(void *)(v3 + 8) = v9;
    operator delete(v9);
  }

  *(_OWORD *)uint64_t v3 = v12;
  *(void *)(v3 + 16) = v5;
  *(_DWORD *)(v3 + 24) = v6;
  uint64_t v10 = *(void **)(v3 + 32);
  if (v10)
  {
    *(void *)(v3 + 40) = v10;
    operator delete(v10);
  }

  *(_OWORD *)(v3 + 32) = v13;
  *(void *)(v3 + 48) = v7;
  __n128 result = v14;
  *(__n128 *)(v3 + 56) = v14;
  *(_DWORD *)(v3 + 72) = v15;
  return result;
}

double sub_100F4A9A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v30 = (__int128 *)a2;
  unint64_t v31 = (__int128 *)a1;
  unint64_t v28 = (__int128 *)a4;
  double v29 = (__int128 *)a3;
  uint64_t v27 = a5;
  double result = sub_100F4B088(a1, a2, a3, a4);
  unint64_t v11 = (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3;
  uint64_t v12 = *(void *)(a4 + 8) - *(void *)a4;
  if (v11 == v12 >> 3)
  {
    double result = *(double *)(a5 + 56);
    double v13 = *(double *)(a4 + 56);
    BOOL v14 = result <= v13;
    if (result == v13) {
      BOOL v14 = *(_DWORD *)(a5 + 72) <= *(_DWORD *)(a4 + 72);
    }
    if (v14) {
      return result;
    }
  }

  else if (v11 <= v12 >> 3)
  {
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v28, &v27).n128_u64[0];
  unint64_t v15 = (uint64_t)(*((void *)v28 + 1) - *(void *)v28) >> 3;
  uint64_t v16 = *(void *)(a3 + 8) - *(void *)a3;
  if (v15 == v16 >> 3)
  {
    double result = *((double *)v28 + 7);
    double v17 = *(double *)(a3 + 56);
    BOOL v18 = result <= v17;
    if (result == v17) {
      BOOL v18 = *((_DWORD *)v28 + 18) <= *(_DWORD *)(a3 + 72);
    }
    if (v18) {
      return result;
    }
  }

  else if (v15 <= v16 >> 3)
  {
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v29, (uint64_t *)&v28).n128_u64[0];
  unint64_t v19 = (uint64_t)(*((void *)v29 + 1) - *(void *)v29) >> 3;
  uint64_t v20 = *(void *)(a2 + 8) - *(void *)a2;
  if (v19 == v20 >> 3)
  {
    double result = *((double *)v29 + 7);
    double v21 = *(double *)(a2 + 56);
    BOOL v22 = result <= v21;
    if (result == v21) {
      BOOL v22 = *((_DWORD *)v29 + 18) <= *(_DWORD *)(a2 + 72);
    }
    if (v22) {
      return result;
    }
  }

  else if (v19 <= v20 >> 3)
  {
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v30, (uint64_t *)&v29).n128_u64[0];
  unint64_t v23 = (uint64_t)(*((void *)v30 + 1) - *(void *)v30) >> 3;
  uint64_t v24 = *(void *)(a1 + 8) - *(void *)a1;
  if (v23 != v24 >> 3)
  {
    if (v23 <= v24 >> 3) {
      return result;
    }
    goto LABEL_29;
  }

  double result = *((double *)v30 + 7);
  double v25 = *(double *)(a1 + 56);
  BOOL v26 = result <= v25;
  if (result == v25) {
    BOOL v26 = *((_DWORD *)v30 + 18) <= *(_DWORD *)(a1 + 72);
  }
  if (!v26) {
LABEL_29:
  }
    *(void *)&double result = sub_100F4A8B0(&v31, (uint64_t *)&v30).n128_u64[0];
  return result;
}

double sub_100F4AB64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = (__int128 *)a1;
  uint64_t v25 = a3;
  BOOL v26 = (__int128 *)a2;
  unint64_t v3 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3;
  uint64_t v4 = *(void *)(a1 + 8) - *(void *)a1;
  if (v3 == v4 >> 3)
  {
    double result = *(double *)(a2 + 56);
    double v6 = *(double *)(a1 + 56);
    BOOL v7 = result <= v6;
    if (result == v6) {
      BOOL v7 = *(_DWORD *)(a2 + 72) <= *(_DWORD *)(a1 + 72);
    }
    if (!v7) {
      goto LABEL_13;
    }
LABEL_6:
    unint64_t v8 = (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3;
    if (v8 == v3)
    {
      double result = *(double *)(a3 + 56);
      double v9 = *(double *)(a2 + 56);
      BOOL v10 = result <= v9;
      if (result == v9) {
        BOOL v10 = *(_DWORD *)(a3 + 72) <= *(_DWORD *)(a2 + 72);
      }
      if (v10) {
        return result;
      }
    }

    else if (v8 <= v3)
    {
      return result;
    }

    *(void *)&double result = sub_100F4A8B0(&v26, &v25).n128_u64[0];
    unint64_t v19 = (uint64_t)(*((void *)v26 + 1) - *(void *)v26) >> 3;
    uint64_t v20 = *((void *)v27 + 1) - *(void *)v27;
    if (v19 == v20 >> 3)
    {
      double result = *((double *)v26 + 7);
      double v21 = *((double *)v27 + 7);
      BOOL v22 = result <= v21;
      if (result == v21) {
        BOOL v22 = *((_DWORD *)v26 + 18) <= *((_DWORD *)v27 + 18);
      }
      if (v22) {
        return result;
      }
    }

    else if (v19 <= v20 >> 3)
    {
      return result;
    }

    unint64_t v23 = &v27;
    uint64_t v24 = (uint64_t *)&v26;
    goto LABEL_38;
  }

  if (v3 <= v4 >> 3) {
    goto LABEL_6;
  }
LABEL_13:
  unint64_t v11 = (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3;
  if (v11 == v3)
  {
    double v12 = *(double *)(a3 + 56);
    double v13 = *(double *)(a2 + 56);
    BOOL v14 = v12 <= v13;
    if (v12 == v13) {
      BOOL v14 = *(_DWORD *)(a3 + 72) <= *(_DWORD *)(a2 + 72);
    }
    if (!v14) {
      goto LABEL_32;
    }
  }

  else if (v11 > v3)
  {
LABEL_32:
    unint64_t v23 = &v27;
LABEL_35:
    uint64_t v24 = &v25;
LABEL_38:
    *(void *)&double result = sub_100F4A8B0(v23, v24).n128_u64[0];
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v27, (uint64_t *)&v26).n128_u64[0];
  unint64_t v15 = (uint64_t)(*(void *)(v25 + 8) - *(void *)v25) >> 3;
  uint64_t v16 = *((void *)v26 + 1) - *(void *)v26;
  if (v15 != v16 >> 3)
  {
    if (v15 <= v16 >> 3) {
      return result;
    }
    goto LABEL_34;
  }

  double result = *(double *)(v25 + 56);
  double v17 = *((double *)v26 + 7);
  BOOL v18 = result <= v17;
  if (result == v17) {
    BOOL v18 = *(_DWORD *)(v25 + 72) <= *((_DWORD *)v26 + 18);
  }
  if (!v18)
  {
LABEL_34:
    unint64_t v23 = &v26;
    goto LABEL_35;
  }

  return result;
}

BOOL sub_100F4AD1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v39 = a2;
  unint64_t v40 = (__int128 *)a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 4);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = *(void *)(a2 - 80);
      uint64_t v39 = a2 - 80;
      unint64_t v7 = (*(void *)(a2 - 72) - v6) >> 3;
      uint64_t v8 = *(void *)(a1 + 8) - *(void *)a1;
      if (v7 != v8 >> 3)
      {
        if (v7 <= v8 >> 3) {
          return result;
        }
LABEL_42:
        sub_100F4A8B0(&v40, &v39);
        return 1LL;
      }

      double v9 = *(double *)(a2 - 24);
      double v10 = *(double *)(a1 + 56);
      BOOL v11 = v9 <= v10;
      if (v9 == v10) {
        BOOL v11 = *(_DWORD *)(a2 - 8) <= *(_DWORD *)(a1 + 72);
      }
      if (!v11) {
        goto LABEL_42;
      }
      return result;
    case 3uLL:
      sub_100F4AB64(a1, a1 + 80, a2 - 80);
      return 1LL;
    case 4uLL:
      sub_100F4B088(a1, a1 + 80, a1 + 160, a2 - 80);
      return 1LL;
    case 5uLL:
      sub_100F4A9A4(a1, a1 + 80, a1 + 160, a1 + 240, a2 - 80);
      return 1LL;
    default:
      double v12 = (__n128 *)(a1 + 160);
      sub_100F4AB64(a1, a1 + 80, a1 + 160);
      uint64_t v13 = a1 + 240;
      if (a1 + 240 == v2) {
        return 1LL;
      }
      int v14 = 0;
      uint64_t v15 = a1 + 216;
      break;
  }

double sub_100F4B088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v23 = (__int128 *)a2;
  uint64_t v24 = (__int128 *)a1;
  uint64_t v21 = a4;
  int v22 = (__int128 *)a3;
  double result = sub_100F4AB64(a1, a2, a3);
  unint64_t v9 = (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3;
  uint64_t v10 = *(void *)(a3 + 8) - *(void *)a3;
  if (v9 == v10 >> 3)
  {
    double result = *(double *)(a4 + 56);
    double v11 = *(double *)(a3 + 56);
    BOOL v12 = result <= v11;
    if (result == v11) {
      BOOL v12 = *(_DWORD *)(a4 + 72) <= *(_DWORD *)(a3 + 72);
    }
    if (v12) {
      return result;
    }
  }

  else if (v9 <= v10 >> 3)
  {
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v22, &v21).n128_u64[0];
  unint64_t v13 = (uint64_t)(*((void *)v22 + 1) - *(void *)v22) >> 3;
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v13 == v14 >> 3)
  {
    double result = *((double *)v22 + 7);
    double v15 = *(double *)(a2 + 56);
    BOOL v16 = result <= v15;
    if (result == v15) {
      BOOL v16 = *((_DWORD *)v22 + 18) <= *(_DWORD *)(a2 + 72);
    }
    if (v16) {
      return result;
    }
  }

  else if (v13 <= v14 >> 3)
  {
    return result;
  }

  *(void *)&double result = sub_100F4A8B0(&v23, (uint64_t *)&v22).n128_u64[0];
  unint64_t v17 = (uint64_t)(*((void *)v23 + 1) - *(void *)v23) >> 3;
  uint64_t v18 = *(void *)(a1 + 8) - *(void *)a1;
  if (v17 != v18 >> 3)
  {
    if (v17 <= v18 >> 3) {
      return result;
    }
    goto LABEL_22;
  }

  double result = *((double *)v23 + 7);
  double v19 = *(double *)(a1 + 56);
  BOOL v20 = result <= v19;
  if (result == v19) {
    BOOL v20 = *((_DWORD *)v23 + 18) <= *(_DWORD *)(a1 + 72);
  }
  if (!v20) {
LABEL_22:
  }
    *(void *)&double result = sub_100F4A8B0(&v24, (uint64_t *)&v23).n128_u64[0];
  return result;
}

void sub_100F4B1DC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 95) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 163) = 0u;
  char v21 = 0;
  sub_100F4B568((audit_token_t *)a1, &v21, &__str);
  if (v21)
  {
    std::string::operator=((std::string *)(a2 + 24), &__str);
  }

  else
  {
    sub_100FE2D54(&__str, (uint64_t)&v7);
    sub_1011DBE2C(a2, (__int128 *)&v7);
    if (v19 < 0) {
      operator delete(__p);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if (v15 < 0) {
      operator delete(v14);
    }
    if (v13 < 0) {
      operator delete(v12);
    }
    if (v11 < 0) {
      operator delete(v10);
    }
    if (v9 < 0) {
      operator delete(v8);
    }
  }

  __int128 v5 = *(_OWORD *)(a1 + 16);
  v6[0] = *(_OWORD *)a1;
  v6[1] = v5;
  CLConnection::getUserNameFromAuditToken(&v7, (CLConnection *)v6, v4);
  sub_100FE36F4((std::string *)a2, &v7);
}

void sub_100F4B324( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
}

std::string *sub_100F4B370@<X0>(audit_token_t *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  double result = (std::string *)proc_pidpath_audittoken(a1, buffer, 0x1000u);
  return result;
}

void sub_100F4B408(_Unwind_Exception *exception_object)
{
}

void sub_100F4B424(audit_token_t *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  unint64_t v4 = sub_1002A6F04((char *)p_p);
  if (v4)
  {
    CFURLRef v5 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v4, kCFURLPOSIXPathStyle, 0);
    CFURLRef v6 = v5;
    if (v5)
    {
      std::string v7 = (const void *)_CFBundleCopyBundleURLForExecutableURL(v5);
      if (v7)
      {
        Unique = (__CFBundle *)_CFBundleCreateUnique(kCFAllocatorDefault, v7);
        char v9 = Unique;
        if (Unique)
        {
          Identifier = CFBundleGetIdentifier(Unique);
          if (Identifier)
          {
            sub_1002A6C50(Identifier, &v11);
            *a2 = v11;
          }

          CFRelease(v9);
        }

        CFRelease(v7);
      }

      CFRelease(v6);
    }

    CFRelease(v4);
  }

void sub_100F4B528( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F4B568(audit_token_t *a1@<X0>, _BYTE *a2@<X1>, std::string *a3@<X8>)
{
  *a2 = 0;
  std::string::size_type size = __p.__r_.__value_.__s.__size_;
  int v7 = (char)__p.__r_.__value_.__s.__size_;
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    *a3 = __p;
  }

  else
  {
    *a2 = 1;
    sub_100F4B370(a1, a3);
    if (v7 < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

void sub_100F4B604( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (v10 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100F4B61C(uint64_t a1)
{
  return *(double *)a1;
}

void sub_100F4B62C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = operator new(0x28uLL);
  v4[1] = *(_OWORD *)a2;
  *((void *)v4 + 4) = *(void *)(a2 + 16);
  uint64_t v5 = *a1;
  *(void *)unint64_t v4 = *a1;
  *((void *)v4 + 1) = a1;
  *(void *)(v5 + 8) = v4;
  *a1 = (uint64_t)v4;
  uint64_t v6 = a1[2];
  BOOL v7 = __CFADD__(v6, 1LL);
  uint64_t v8 = v6 + 1;
  a1[2] = v8;
  if (!v7)
  {
    do
    {
      char v9 = (double *)a1[1];
      double v10 = *v9;
      *(double *)(*(void *)&v10 + 8LL) = v9[1];
      **((double **)v9 + 1) = v10;
      a1[2] = v8 - 1;
      operator delete(v9);
      uint64_t v8 = a1[2];
    }

    while (v8);
  }

  uint64_t v11 = a1[1];
  if ((uint64_t *)v11 != a1)
  {
    int v12 = 0;
    double v13 = 0.0;
    do
    {
      double v14 = *(double *)(v11 + 24);
      v12 += v14 >= 0.0 && *(double *)(v11 + 32) <= 50.0;
      double v13 = v13 + v14;
      uint64_t v11 = *(void *)(v11 + 8);
    }

    while ((uint64_t *)v11 != a1);
  }

int64_t sub_100F4B97C(id a1, id a2, id a3)
{
  return (int64_t)[a2 compare:a3];
}

void sub_100F4B9F4(id a1)
{
  qword_10199F608 = &off_1018D72D0;
}

void sub_100F4BA88(id a1)
{
  qword_10199F618 = &off_1018D72E8;
}

void sub_100F4BB1C(id a1)
{
  qword_10199F628 = &off_1018D7300;
}

void sub_100F4BBB0(id a1)
{
  qword_10199F638 = &off_1018D7318;
}

void sub_100F4BC3C(id a1)
{
  qword_10199F648 = &off_1018D7330;
}

void sub_100F4BCC8(id a1)
{
  qword_10199F658 = &off_1018D7348;
}

void sub_100F4BCEC(id a1)
{
  qword_101934878 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeoFencing");
}

void sub_100F4BD18(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = 0LL;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  do
  {
    v19[v3] = *(float *)(a1 + 4LL * dword_101366388[v3]);
    ++v3;
  }

  while (v3 != 150);
  for (uint64_t i = 0LL; i != 1600; ++i)
  {
    int v5 = word_1013665E0[i];
    if (v5 < 0)
    {
      ++v5;
    }

    else
    {
      do
      {
        if (v19[aM[v5]] <= flt_1013896CC[v5]) {
          uint64_t v6 = (__int16 *)((char *)&unk_10137292E + 2 * v5);
        }
        else {
          uint64_t v6 = &asc_101367260[v5];
        }
        int v5 = *v6;
      }

      while (v5 > 0);
    }

    *((float *)&v17 + (i & 7)) = flt_1013A0468[-v5] + *((float *)&v17 + (i & 7));
  }

  float v7 = *(float *)&v17;
  for (uint64_t j = 4LL; j != 32; j += 4LL)
  {
  }

  uint64_t v9 = 0LL;
  float v10 = 0.0;
  do
  {
    float v11 = expf(*(float *)((char *)&v17 + v9) - v7);
    *(float *)((char *)&v17 + v9) = v11;
    float v10 = v10 + v11;
    v9 += 4LL;
  }

  while (v9 != 32);
  uint64_t v12 = 0LL;
  __int16 v13 = 0;
  float v14 = -3.4028e38;
  do
  {
    float v15 = *((float *)&v17 + v12) / v10;
    *((float *)&v17 + v12) = v15;
    if (v15 > v14)
    {
      __int16 v13 = v12;
      float v14 = v15;
    }

    ++v12;
  }

  while (v12 != 8);
  *(void *)a2 = qword_1013B8B08[v13];
  *(float *)(a2 + 8) = v14;
  __int128 v16 = v18;
  *(_OWORD *)(a2 + 12) = v17;
  *(_OWORD *)(a2 + 28) = v16;
}

uint64_t sub_100F4BEEC(uint64_t a1)
{
  return sub_1005CE680(a1);
}

__int128 *sub_100F4BF14()
{
  return &xmmword_1019A3DE0;
}

void *sub_100F4BF20()
{
  return &unk_1019A3E60;
}

void *sub_100F4BF2C()
{
  return &unk_101992948;
}

void *sub_100F4BF38()
{
  return &unk_101992950;
}

void *sub_100F4BF44()
{
  return &unk_101992960;
}

BOOL sub_100F4BF50(unsigned __int8 *a1, uint64_t a2)
{
  char v2 = a2 + 1;
  switch(a2)
  {
    case -1LL:
      int v3 = a1[91];
      goto LABEL_7;
    case 0LL:
      return sub_100F4BFA8((uint64_t)a1);
    case 1LL:
      int v3 = a1[88];
      goto LABEL_7;
    case 2LL:
      int v3 = a1[89];
      goto LABEL_7;
    case 3LL:
      int v3 = a1[90];
LABEL_7:
      char v2 = v3 != 0;
      break;
    default:
      return v2 & 1;
  }

  return v2 & 1;
}

BOOL sub_100F4BFA8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 118))
  {
    HIBYTE(v14) = 0;
    sub_1002F0B04(buf);
    int v3 = sub_1002A6F64(*(uint64_t *)&buf[0], "isWifiPositionWithAssociatedApHomeLoiEnabled", (BOOL *)&v14 + 7);
    int v4 = v3;
    int v5 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
    if (!*((void *)&buf[0] + 1)) {
      goto LABEL_7;
    }
    uint64_t v6 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if (v4) {
        goto LABEL_8;
      }
    }

    else
    {
LABEL_7:
      if (v3)
      {
LABEL_8:
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10188DD00);
        }
        uint64_t v8 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
        {
          if (HIBYTE(v14)) {
            uint64_t v9 = "true";
          }
          else {
            uint64_t v9 = "false";
          }
          LODWORD(buf[0]) = 136380675;
          *(void *)((char *)buf + 4) = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Warning defaults write isWifiPositionWithAssociatedApHomeLoiEnabled to %{private}s",  (uint8_t *)buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_10188DD00);
          }
          if (HIBYTE(v14)) {
            uint64_t v12 = "true";
          }
          else {
            uint64_t v12 = "false";
          }
          int v15 = 136380675;
          __int128 v16 = v12;
          LODWORD(v14) = 12;
          __int16 v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "#Warning defaults write isWifiPositionWithAssociatedApHomeLoiEnabled to %{private}s",  &v15,  v14);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifi1Settings::WifiPositionWithAssociatedAp::isHomeLoiEnabledBySettings()",  "%s\n",  v13);
        }

        float v10 = (unsigned __int8 *)&v14 + 7;
        goto LABEL_19;
      }
    }

    float v10 = (unsigned __int8 *)(a1 + 114);
LABEL_19:
    int v2 = *v10;
    *(_WORD *)(a1 + 117) = v2 | 0x100;
    return v2 != 0;
  }

  int v2 = *(unsigned __int8 *)(a1 + 117);
  return v2 != 0;
}

void sub_100F4C220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100F4C23C(id a1)
{
  int v1 = sub_1002A6F64(*(uint64_t *)&buf[0], "isWifiPositionWithAssociatedApEnabled", (BOOL *)&byte_10199F66A);
  int v2 = v1;
  int v3 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_5;
  }
  int v4 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v5 = __ldaxr(v4);
  while (__stlxr(v5 - 1, v4));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (!v2) {
      return;
    }
  }

  else
  {
LABEL_5:
    if (!v1) {
      return;
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188DD00);
  }
  uint64_t v6 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10199F66A) {
      unint64_t v7 = "true";
    }
    else {
      unint64_t v7 = "false";
    }
    LODWORD(buf[0]) = 136380675;
    *(void *)((char *)buf + 4) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning defaults write isWifiPositionWithAssociatedApEnabled to %{private}s",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188DD00);
    }
    if (byte_10199F66A) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    int v11 = 136380675;
    uint64_t v12 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "#Warning defaults write isWifiPositionWithAssociatedApEnabled to %{private}s",  &v11,  12);
    float v10 = (char *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<BOOL> CLWifi1Settings::WifiPositionWithAssociatedAp::isEnabledByDefaultsWrite()_block_invoke",  "%s\n",  v9);
  }

  word_10199F668 = byte_10199F66A | 0x100;
}

void sub_100F4C498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

BOOL sub_100F4C4B4(uint64_t a1)
{
  if (qword_10199F670 != -1) {
    dispatch_once(&qword_10199F670, &stru_10188DCE0);
  }
  int v2 = &word_10199F668;
  if (!HIBYTE(word_10199F668)) {
    int v2 = (__int16 *)(a1 + 113);
  }
  return *(_BYTE *)v2 != 0;
}

uint64_t sub_100F4C51C(uint64_t a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199F680);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199F680))
  {
    unk_10199F678 = sub_100F4C5A8();
    __cxa_guard_release(&qword_10199F680);
  }

  int v3 = (unsigned __int8 *)&unk_10199F678;
  if (!byte_10199F679) {
    int v3 = (unsigned __int8 *)(a1 + 115);
  }
  return *v3;
}

void sub_100F4C590(_Unwind_Exception *a1)
{
}

uint64_t sub_100F4C5A8()
{
  HIBYTE(v12) = 0;
  sub_1002F0B04(buf);
  int v0 = sub_1002A6F64(*(uint64_t *)&buf[0], "isWifiHarvestEnabled", (BOOL *)&v12 + 7);
  int v1 = v0;
  unsigned __int8 v2 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    int v3 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      if (v1) {
        goto LABEL_6;
      }
LABEL_16:
      int v7 = 0;
      int v8 = 0;
      return v8 | (v7 << 8);
    }
  }

  if (!v0) {
    goto LABEL_16;
  }
LABEL_6:
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188DD00);
  }
  unint64_t v5 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    if (HIBYTE(v12)) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    LODWORD(buf[0]) = 136380675;
    *(void *)((char *)buf + 4) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning defaults write isWifiHarvestEnabled to %{private}s",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188DD00);
    }
    if (HIBYTE(v12)) {
      float v10 = "true";
    }
    else {
      float v10 = "false";
    }
    int v13 = 136380675;
    uint64_t v14 = v10;
    LODWORD(v12) = 12;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "#Warning defaults write isWifiHarvestEnabled to %{private}s",  &v13,  v12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "std::optional<BOOL> isWifiHarvestEnabledByDefaultsWrite()", "%s\n", v11);
  }

  int v7 = 1;
  int v8 = HIBYTE(v12);
  return v8 | (v7 << 8);
}

void sub_100F4C7FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100F4C818(uint64_t a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199F690);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199F690))
  {
    unk_10199F688 = sub_100F4C8A4();
    __cxa_guard_release(&qword_10199F690);
  }

  int v3 = (unsigned __int8 *)&unk_10199F688;
  if (!byte_10199F689) {
    int v3 = (unsigned __int8 *)(a1 + 116);
  }
  return *v3;
}

void sub_100F4C88C(_Unwind_Exception *a1)
{
}

uint64_t sub_100F4C8A4()
{
  HIBYTE(v12) = 0;
  sub_1002F0B04(buf);
  int v0 = sub_1002A6F64(*(uint64_t *)&buf[0], "isWifiHarvestUsed", (BOOL *)&v12 + 7);
  int v1 = v0;
  unsigned __int8 v2 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    int v3 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      if (v1) {
        goto LABEL_6;
      }
LABEL_16:
      int v7 = 0;
      int v8 = 0;
      return v8 | (v7 << 8);
    }
  }

  if (!v0) {
    goto LABEL_16;
  }
LABEL_6:
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188DD00);
  }
  unint64_t v5 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    if (HIBYTE(v12)) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    LODWORD(buf[0]) = 136380675;
    *(void *)((char *)buf + 4) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning defaults write isWifiHarvestUsed to %{private}s",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188DD00);
    }
    if (HIBYTE(v12)) {
      float v10 = "true";
    }
    else {
      float v10 = "false";
    }
    int v13 = 136380675;
    uint64_t v14 = v10;
    LODWORD(v12) = 12;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "#Warning defaults write isWifiHarvestUsed to %{private}s",  &v13,  v12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "std::optional<BOOL> isWifiHarvestUsedByDefaultsWrite()", "%s\n", v11);
  }

  int v7 = 1;
  int v8 = HIBYTE(v12);
  return v8 | (v7 << 8);
}

void sub_100F4CAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

double sub_100F4CB14(uint64_t *a1)
{
  int v1 = a1;
  uint64_t v10 = *a1;
  sub_1002F0B04(buf);
  int v2 = sub_1002A82BC(*(uint64_t *)&buf[0], "databasePurgeThreshold", &v10);
  int v3 = v2;
  unint64_t v4 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_5;
  }
  unint64_t v5 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if (!v3) {
      return *(double *)v1;
    }
  }

  else
  {
LABEL_5:
    if (!v2) {
      return *(double *)v1;
    }
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188DD00);
  }
  int v7 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0]) = 134283521;
    *(void *)((char *)buf + 4) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "CLWifi1Settings, #Warning defaults write databasePurgeThreshold to %{private}.1f",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188DD00);
    }
    int v11 = 134283521;
    uint64_t v12 = v10;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "CLWifi1Settings, #Warning defaults write databasePurgeThreshold to %{private}.1f",  &v11,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFTimeInterval CLWifi1Settings::WifiPositionWithAssociatedAp::getDatabasePurgeThreshold()",  "%s\n",  v9);
  }

  int v1 = &v10;
  return *(double *)v1;
}

void sub_100F4CD34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_100F4CD50()
{
  return &unk_1019929D8;
}

void *sub_100F4CD5C()
{
  return &unk_101992A38;
}

void *sub_100F4CD68()
{
  return &unk_101992A58;
}

void *sub_100F4CD74()
{
  return &unk_1019A4020;
}

void *sub_100F4CD80()
{
  return &unk_101992A60;
}

void *sub_100F4CD8C()
{
  return &unk_101992A80;
}

void *sub_100F4CD98()
{
  return &unk_101992A8C;
}

void *sub_100F4CDA4()
{
  return &unk_101992A94;
}

uint64_t sub_100F4CDB0@<X0>(void *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  char v17 = a2;
  unint64_t v6 = a1 + 5;
  uint64_t v5 = a1[5];
  int v15 = a1 + 5;
  (*(void (**)(void *))(v5 + 16))(a1 + 5);
  __int16 v16 = 256;
  int v7 = sub_100F4D088(a1, &v17);
  if (!v7)
  {
LABEL_7:
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 24) = 0;
    return (*(uint64_t (**)(void *))(*v6 + 24LL))(v6);
  }

  std::string __p = 0LL;
  int v13 = 0LL;
  uint64_t v14 = 0LL;
  sub_10001B72C(&__p, v7[3], (uint64_t)v7[4], ((char *)v7[4] - (char *)v7[3]) >> 2);
  int v8 = __p;
  uint64_t v9 = (uint64_t)v13;
  int64_t v10 = v13 - (_BYTE *)__p;
  if (v13 == __p)
  {
    if (v13) {
      operator delete(v13);
    }
    goto LABEL_7;
  }

  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  sub_10001B72C((void *)a3, v8, v9, v10 >> 2);
  *(_BYTE *)(a3 + 24) = 1;
  if (__p)
  {
    int v13 = __p;
    operator delete(__p);
  }

  return (*(uint64_t (**)(void *))(*v6 + 24LL))(v6);
}

void sub_100F4CE90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1011C52D0((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100F4CEC4(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  sub_1002E4C3C(a1 + 40, "CLWifi1SettingsWifiService", 1LL, 1LL);
  return a1;
}

void sub_100F4CF0C(_Unwind_Exception *a1)
{
}

BOOL sub_100F4CF20(uint64_t a1)
{
  return *(_DWORD *)(a1 + 4) > 0;
}

double sub_100F4CF30(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_1013B8B60;
  *(_OWORD *)(a1 + 16) = xmmword_1013B8B70;
  *(_OWORD *)(a1 + 32) = xmmword_1013B8B80;
  *(_OWORD *)(a1 + 48) = xmmword_1013B8B90;
  *(_OWORD *)(a1 + 64) = xmmword_1013B8BA0;
  *(_OWORD *)(a1 + 80) = xmmword_1013B8BB0;
  *(int64x2_t *)(a1 + 96) = vdupq_n_s64(0x405E000000000000uLL);
  *(_OWORD *)(a1 + 112) = xmmword_1013B8BC0;
  *(_OWORD *)(a1 + 128) = xmmword_1013B8BD0;
  *(_OWORD *)(a1 + 144) = xmmword_1013B8BE0;
  *(_OWORD *)(a1 + 160) = xmmword_1013B8BF0;
  *(_DWORD *)(a1 + 176) = 3;
  *(_OWORD *)(a1 + 184) = xmmword_1013B8C00;
  *(void *)(a1 + 200) = 0x402E000000000000LL;
  *(_DWORD *)(a1 + 208) = 18;
  *(_OWORD *)(a1 + 216) = xmmword_1013B8C10;
  *(void *)&__int128 v1 = 0xA0000000ALL;
  *((void *)&v1 + 1) = 0xA0000000ALL;
  *(_OWORD *)(a1 + 232) = v1;
  *(void *)(a1 + 248) = 0xA0000000ALL;
  *(_OWORD *)(a1 + 256) = xmmword_1013B8C20;
  *(_OWORD *)(a1 + 272) = xmmword_1012EE470;
  *(_DWORD *)(a1 + 288) = 10;
  *(void *)(a1 + 296) = 0x4008000000000000LL;
  *(_OWORD *)(a1 + 304) = xmmword_1013B8BF0;
  *(_OWORD *)(a1 + 320) = xmmword_1013B8C30;
  *(_OWORD *)(a1 + 336) = xmmword_1013B8C40;
  *(_OWORD *)(a1 + 352) = xmmword_1013B8C70;
  *(_OWORD *)(a1 + 384) = xmmword_1013B8C60;
  *(_OWORD *)(a1 + 400) = xmmword_1013B8C50;
  *(_OWORD *)(a1 + 416) = xmmword_1013B8C90;
  *(_OWORD *)(a1 + 432) = xmmword_1013B8C80;
  double result = 100000000.0;
  *(_OWORD *)(a1 + 368) = xmmword_1013B8CA0;
  return result;
}

void sub_100F4D05C(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

uint64_t **sub_100F4D088(void *a1, char *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (*(void *)&v2 - 1LL) & v3;
  }

  unint64_t v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  for (double result = *v6; result; double result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
    }

    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }

      else
      {
        v8 &= *(void *)&v2 - 1LL;
      }

      if (v8 != v5) {
        return 0LL;
      }
    }
  }

  return result;
}

void sub_100F4D13C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      __int128 v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)__int128 v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100F4D1D8(_Unwind_Exception *a1)
{
}

void sub_100F4D1F0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      __int128 v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      _WORD *v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100F4D27C(_Unwind_Exception *a1)
{
}

uint64_t sub_100F4D294()
{
  xmmword_1019A3DE0 = xmmword_1013B8CB0;
  *(_OWORD *)algn_1019A3DF0 = xmmword_1013B8CC0;
  xmmword_1019A3E00 = xmmword_1013B8CD0;
  unk_1019A3E10 = xmmword_1013B8CE0;
  xmmword_1019A3E20 = xmmword_1013B8CF0;
  qword_1019A3E30 = 0x120000000ALL;
  dword_1019A3E38 = 2;
  qword_1019A3E40 = 0x40E1170000000000LL;
  qword_1019A3E48 = 0x4100000004LL;
  qword_1019A3E50 = 0x408C200000000000LL;
  byte_1019A3E58 = 0;
  sub_100F4CF30((uint64_t)&unk_1019A3E60);
  sub_100F4CEC4((uint64_t)&unk_1019A4020);
  return __cxa_atexit((void (*)(void *))sub_100F4BEEC, &unk_1019A4020, (void *)&_mh_execute_header);
}

void sub_100F4D51C(uint64_t a1)
{
  int8x8_t v2 = +[NSBundle bundleWithPath:]( &OBJC_CLASS___NSBundle,  "bundleWithPath:",  @"/System/Library/LocationBundles/AppleWatchWorkout.bundle");
  if (v2)
  {
    unint64_t v3 = v2;
    *(void *)(*(void *)(a1 + 32) + 16) = -[CLLocationManager initWithEffectiveBundlePath:delegate:onQueue:]( [CLLocationManager alloc],  "initWithEffectiveBundlePath:delegate:onQueue:",  @"/System/Library/LocationBundles/AppleWatchWorkout.bundle",  *(void *)(a1 + 32),  [*(id *)(a1 + 40) queue]);
    [*(id *)(*(void *)(a1 + 32) + 16) setDesiredAccuracy:kCLLocationAccuracyHundredMeters];
  }

void sub_100F4D680(uint64_t a1)
{
}

void sub_100F4D9D4(dispatch_source_t *a1, uint64_t a2, void *a3, void *a4)
{
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10188DD20);
  }
  unint64_t v8 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v18 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "#gfc Scheduling timer with timeout %llu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188DD20);
    }
    int v15 = 134217984;
    uint64_t v16 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "#gfc Scheduling timer with timeout %llu",  &v15);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void scheduleTimer(dispatch_source_t *, const uint64_t, CLDispatchSilo *, void (^)(void))",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

  uint64_t v9 = *a1;
  if (*a1)
  {
    dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, 1000000000 * a2);
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler(*a1, a4);
  }

  else
  {
    int v11 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0,  0,  (dispatch_queue_t)[a3 queue]);
    *a1 = v11;
    dispatch_time_t v12 = dispatch_time(0x8000000000000000LL, 1000000000 * a2);
    dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler(*a1, a4);
    dispatch_resume(*a1);
  }

id sub_100F4DC34(uint64_t a1)
{
  return _[*(id *)(a1 + 32) onLocationUpdateTimerFire];
}

void sub_100F4E568(dispatch_source_t *a1)
{
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10188DD20);
  }
  int8x8_t v2 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "#gfc Canceling timer", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188DD20);
    }
    v9[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "#gfc Canceling timer",  v9,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void cancelTimer(dispatch_source_t *)", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if (*a1)
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188DD20);
    }
    unint64_t v3 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#gfc Timer existed, canceling now", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10188DD20);
      }
      v9[0] = 0;
      LODWORD(v8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "#gfc Timer existed, canceling now",  v9,  v8);
      int v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void cancelTimer(dispatch_source_t *)", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    dispatch_source_cancel(*a1);
    dispatch_release(*a1);
    *a1 = 0LL;
  }

id sub_100F4F644(uint64_t a1)
{
  return _[*(id *)(a1 + 32) onGeoFenceTimerFire];
}

void sub_100F4FB24(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

uint64_t sub_100F4FB50()
{
  if (qword_1019A4058) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4058 + 8LL))(qword_1019A4058);
  }
  if (qword_1019A4060) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4060 + 8LL))(qword_1019A4060);
  }
  if (qword_1019A4068) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4068 + 8LL))(qword_1019A4068);
  }
  if (qword_1019A4070) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4070 + 8LL))(qword_1019A4070);
  }
  if (qword_1019A4078) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4078 + 8LL))(qword_1019A4078);
  }
  if (qword_1019A4080) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A4080 + 8LL))(qword_1019A4080);
  }
  uint64_t result = qword_1019A4088;
  if (qword_1019A4088) {
    return (*(uint64_t (**)(uint64_t))(*(void *)qword_1019A4088 + 8LL))(qword_1019A4088);
  }
  return result;
}

void sub_100F4FC0C(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_10199F698 & 1) == 0)
  {
    byte_10199F698 = 1;
    wireless_diagnostics::google::protobuf::internal::VerifyVersion( (wireless_diagnostics::google::protobuf::internal *)0x1E9808,  2005000,  (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  a4);
    uint8x8_t v4 = operator new(0x28uLL);
    *uint8x8_t v4 = off_10188DD50;
    v4[1] = 0LL;
    double v4[2] = 0LL;
    v4[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v4[4] = 0LL;
    qword_1019A4058 = (uint64_t)v4;
    unint64_t v5 = operator new(0x18uLL);
    v5[1] = 0LL;
    v5[2] = 0LL;
    *unint64_t v5 = off_10188DDC8;
    qword_1019A4060 = (uint64_t)v5;
    unint64_t v6 = (char *)operator new(0x38uLL);
    *(void *)unint64_t v6 = &off_10188DE40;
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 36) = 0u;
    qword_1019A4068 = (uint64_t)v6;
    int v7 = (char *)operator new(0x50uLL);
    *(void *)int v7 = off_10188DEB8;
    *(_OWORD *)(v7 + 8) = 0u;
    *(_OWORD *)(v7 + 24) = 0u;
    *((_DWORD *)v7 + 10) = 1;
    *(void *)(v7 + 68) = 0LL;
    *(void *)(v7 + 44) = 0LL;
    *(void *)(v7 + 60) = 0LL;
    *(void *)(v7 + 52) = 0LL;
    qword_1019A4070 = (uint64_t)v7;
    uint64_t v8 = operator new(0x30uLL);
    *(void *)((char *)v8 + 36) = 0LL;
    void *v8 = &off_10188DF30;
    v8[1] = 0LL;
    v8[2] = 0LL;
    v8[3] = 0LL;
    qword_1019A4078 = (uint64_t)v8;
    uint64_t v9 = operator new(0x30uLL);
    *(void *)((char *)v9 + 36) = 0LL;
    void *v9 = &off_10188DFA8;
    v9[1] = 0LL;
    uint64_t v9[2] = 0LL;
    void v9[3] = 0LL;
    qword_1019A4080 = (uint64_t)v9;
    dispatch_time_t v10 = operator new(0xD8uLL);
    qword_1019A4088 = (uint64_t)v10;
    v10[5] = 0LL;
    v10[6] = 0LL;
    v10[8] = 0LL;
    v10[9] = 0LL;
    v10[11] = 0LL;
    v10[12] = 0LL;
    *((_DWORD *)v10 + 26) = 0;
    v10[14] = 0LL;
    v10[15] = 0LL;
    *((_DWORD *)v10 + 32) = 0;
    v10[17] = 0LL;
    v10[18] = 0LL;
    *((_DWORD *)v10 + 38) = 0;
    *((_DWORD *)v10 + 44) = 0;
    v10[20] = 0LL;
    v10[21] = 0LL;
    *((_DWORD *)v10 + 50) = 0;
    v10[23] = 0LL;
    v10[24] = 0LL;
    v10[26] = 0LL;
    _DWORD v10[2] = 0LL;
    void v10[3] = 0LL;
    v4[1] = v6;
    double v4[2] = v10;
    *((void *)v6 + 1) = v5;
    *dispatch_time_t v10 = off_10188E020;
    v10[1] = v7;
    wireless_diagnostics::google::protobuf::internal::OnShutdown( (wireless_diagnostics::google::protobuf::internal *)sub_100F4FB50,  v11);
  }

void *sub_100F4FDFC(void *result)
{
  *uint64_t result = off_10188DD50;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[4] = 0LL;
  return result;
}

void sub_100F4FE1C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v13,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  292LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v13,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v12, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }

  LOBYTE(v5) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      *(_DWORD *)(a1 + 36) |= 1u;
      unint64_t v6 = *(char **)(a1 + 8);
      if (!v6)
      {
        unint64_t v6 = (char *)operator new(0x38uLL);
        *(void *)unint64_t v6 = &off_10188DE40;
        *(_OWORD *)(v6 + 8) = 0u;
        *(_OWORD *)(v6 + 24) = 0u;
        *(_OWORD *)(v6 + 36) = 0u;
        *(void *)(a1 + 8) = v6;
      }

      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_1019A4058 + 8);
      }
      sub_100F508F0((uint64_t)v6, v7);
      int v5 = *(_DWORD *)(a2 + 36);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return;
        }
        goto LABEL_18;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    *(_DWORD *)(a1 + 36) |= 2u;
    uint64_t v8 = *(void **)(a1 + 16);
    if (!v8)
    {
      uint64_t v8 = operator new(0xD8uLL);
      void v8[5] = 0LL;
      v8[6] = 0LL;
      v8[8] = 0LL;
      v8[9] = 0LL;
      v8[11] = 0LL;
      v8[12] = 0LL;
      *((_DWORD *)v8 + 26) = 0;
      v8[14] = 0LL;
      v8[15] = 0LL;
      *((_DWORD *)v8 + 32) = 0;
      v8[17] = 0LL;
      v8[18] = 0LL;
      *((_DWORD *)v8 + 38) = 0;
      *((_DWORD *)v8 + 44) = 0;
      v8[20] = 0LL;
      v8[21] = 0LL;
      *((_DWORD *)v8 + 50) = 0;
      v8[23] = 0LL;
      v8[24] = 0LL;
      v8[26] = 0LL;
      void *v8 = off_10188E020;
      v8[1] = 0LL;
      v8[2] = 0LL;
      v8[3] = 0LL;
      *(void *)(a1 + 16) = v8;
    }

    uint64_t v9 = *(void *)(a2 + 16);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A4058 + 16);
    }
    sub_100F50A6C((uint64_t)v8, v9);
    if ((*(_DWORD *)(a2 + 36) & 4) != 0)
    {
LABEL_18:
      dispatch_time_t v10 = *(const std::string **)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 4u;
      int v11 = *(std::string **)(a1 + 24);
      if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        int v11 = (std::string *)operator new(0x18uLL);
        v11->__r_.__value_.__l.__size_ = 0LL;
        v11->__r_.__value_.__l.__cap_ = 0LL;
        v11->__r_.__value_.__r.__words[0] = 0LL;
        *(void *)(a1 + 24) = v11;
      }

      std::string::operator=(v11, v10);
    }
  }

void sub_100F4FFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F4FFD8(void *a1)
{
  uint64_t v2 = a1[3];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    operator delete((void *)v2);
  }

  if ((void *)qword_1019A4058 != a1)
  {
    uint64_t v4 = a1[1];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = a1[2];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

void sub_100F50064(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DD50;
  sub_100F4FFD8(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100F50094(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DD50;
  sub_100F4FFD8(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

uint64_t sub_100F500C8(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_1019A4058;
  if (!qword_1019A4058)
  {
    sub_100F4FC0C(0LL, a2, a3, a4);
    return qword_1019A4058;
  }

  return result;
}

void *sub_100F500F4()
{
  uint64_t result = operator new(0x28uLL);
  *uint64_t result = off_10188DD50;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[4] = 0LL;
  return result;
}

uint64_t sub_100F50128(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 36);
  if ((_BYTE)v2)
  {
    if ((*(_BYTE *)(result + 36) & 1) != 0)
    {
      uint64_t result = *(void *)(result + 8);
      if (result)
      {
        uint64_t result = sub_100F501B0(result);
        int v2 = *(_DWORD *)(v1 + 36);
      }
    }

    if ((v2 & 2) != 0)
    {
      uint64_t result = *(void *)(v1 + 16);
      if (result)
      {
        uint64_t result = sub_100F501E8(result);
        int v2 = *(_DWORD *)(v1 + 36);
      }
    }

    if ((v2 & 4) != 0)
    {
      uint64_t v3 = *(void *)(v1 + 24);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }
  }

  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t sub_100F501B0(uint64_t result)
{
  if (*(_BYTE *)(result + 48))
  {
    if ((*(_BYTE *)(result + 48) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 20)) {
          *(void *)(v1 + 8) = 0LL;
        }
        *(_DWORD *)(v1 + 20) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(_DWORD *)(result + 40) = 0;
    *(void *)(result + 32) = 0LL;
  }

  *(_DWORD *)(result + 48) = 0;
  return result;
}

uint64_t sub_100F501E8(uint64_t result)
{
  uint64_t v1 = result;
  if ((*(_BYTE *)(result + 212) & 1) != 0)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      int v3 = *(_DWORD *)(v2 + 72);
      if ((_BYTE)v3)
      {
        *(_OWORD *)(v2 + 24) = 0u;
        *(_OWORD *)(v2 + 8) = 0u;
        *(_DWORD *)(v2 + 40) = 1;
      }

      if ((v3 & 0xFF00) != 0)
      {
        *(void *)(v2 + 52) = 0LL;
        *(void *)(v2 + 44) = 0LL;
        *(void *)(v2 + 60) = 0LL;
      }

      *(_DWORD *)(v2 + 72) = 0;
    }
  }

  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  if (*(int *)(result + 96) >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v1 + 88) + 8 * v4);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32LL))(v5);
      ++v4;
    }

    while (v4 < *(int *)(v1 + 96));
  }

  *(_DWORD *)(v1 + 96) = 0;
  if (*(int *)(v1 + 120) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(v1 + 112) + 8 * v6);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32LL))(v7);
      ++v6;
    }

    while (v6 < *(int *)(v1 + 120));
  }

  *(_DWORD *)(v1 + 120) = 0;
  if (*(int *)(v1 + 144) >= 1)
  {
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(v1 + 136) + 8 * v8);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 32LL))(v9);
      ++v8;
    }

    while (v8 < *(int *)(v1 + 144));
  }

  *(_DWORD *)(v1 + 144) = 0;
  if (*(int *)(v1 + 168) >= 1)
  {
    uint64_t v10 = 0LL;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(v1 + 160) + 8 * v10);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 32LL))(v11);
      ++v10;
    }

    while (v10 < *(int *)(v1 + 168));
  }

  *(_DWORD *)(v1 + 168) = 0;
  if (*(int *)(v1 + 192) >= 1)
  {
    uint64_t v12 = 0LL;
    do
    {
      uint64_t v13 = *(void *)(*(void *)(v1 + 184) + 8 * v12);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 32LL))(v13);
      ++v12;
    }

    while (v12 < *(int *)(v1 + 192));
  }

  *(_DWORD *)(v1 + 192) = 0;
  *(_DWORD *)(v1 + 212) = 0;
  return result;
}

uint64_t sub_100F50374( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v7 = TagFallback >> 3;
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_20;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        uint64_t v9 = *(char **)(a1 + 8);
        if (!v9)
        {
          uint64_t v9 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v9 = &off_10188DE40;
          *(_OWORD *)(v9 + 8) = 0u;
          *(_OWORD *)(v9 + 24) = 0u;
          *(_OWORD *)(v9 + 36) = 0u;
          *(void *)(a1 + 8) = v9;
        }

        uint64_t v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v30)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v30 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        int v11 = *((_DWORD *)this + 14);
        int v12 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v11 + 1;
        if (v11 >= v12) {
          return 0LL;
        }
        int v13 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v30);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v13);
        int v15 = *((_DWORD *)this + 14);
        BOOL v16 = __OFSUB__(v15, 1);
        int v17 = v15 - 1;
        if (v17 < 0 == v16) {
          *((_DWORD *)this + 14) = v17;
        }
        uint64_t v18 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v18 < *((void *)this + 2) && *v18 == 18)
        {
          *((void *)this + 1) = v18 + 1;
          goto LABEL_32;
        }
      }

      if (v7 == 2) {
        break;
      }
      if (v7 == 3)
      {
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_46;
        }
      }

      else
      {
        int v8 = TagFallback & 7;
      }

uint64_t sub_100F506E4( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A4058 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(3LL, *(void *)(v5 + 24), a2);
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t v8 = *(void *)(v5 + 16);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_1019A4058 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  if ((*(_DWORD *)(v5 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(3LL, *(void *)(v5 + 24), a2);
  }
  return result;
}

uint64_t sub_100F5077C(uint64_t a1, unint64_t a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_28;
  }

  if ((*(_BYTE *)(a1 + 36) & 1) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (!v5) {
      uint64_t v5 = *(void *)(qword_1019A4058 + 8);
    }
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F517E4(v5, a2);
    int v7 = (int)v6;
    else {
      int v8 = 1;
    }
    uint64_t v4 = (v7 + v8 + 1);
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v4 = 0LL;
  if ((*(_BYTE *)(a1 + 36) & 2) != 0)
  {
LABEL_12:
    uint64_t v9 = *(void *)(a1 + 16);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A4058 + 16);
    }
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F54520(v9, a2);
    int v11 = (int)v10;
    else {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v11 + v12 + 1);
    int v3 = *(_DWORD *)(a1 + 36);
  }

void sub_100F508A4(uint64_t a1, void *lpsrc)
{
}

double sub_100F508F0(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v13,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  791LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v13,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v12, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 48);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 48) & 1) != 0)
    {
      *(_DWORD *)(a1 + 48) |= 1u;
      int v7 = *(void **)(a1 + 8);
      if (!v7)
      {
        int v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        *int v7 = off_10188DDC8;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A4068 + 8);
      }
      double result = sub_100F50FFC((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 48);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_18;
      }
    }

    else if ((*(_BYTE *)(a2 + 48) & 2) == 0)
    {
      goto LABEL_6;
    }

    int v9 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 48) |= 2u;
    *(_DWORD *)(a1 + 16) = v9;
    int v6 = *(_DWORD *)(a2 + 48);
    if ((v6 & 4) == 0)
    {
LABEL_7:
      if ((v6 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_19;
    }

void sub_100F50A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F50A6C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v51,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  2415LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v51,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v50, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v51);
  }

  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_10008D024(a1 + 16, *(_DWORD *)(a1 + 24) + v5);
    memcpy((void *)(*(void *)(a1 + 16) + 8LL * *(int *)(a1 + 24)), *(const void **)(a2 + 16), 8LL * *(int *)(a2 + 24));
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
  }

  int v6 = *(_DWORD *)(a2 + 48);
  if (v6)
  {
    sub_10004AAFC(a1 + 40, *(_DWORD *)(a1 + 48) + v6);
    memcpy((void *)(*(void *)(a1 + 40) + 4LL * *(int *)(a1 + 48)), *(const void **)(a2 + 40), 4LL * *(int *)(a2 + 48));
    *(_DWORD *)(a1 + 48) += *(_DWORD *)(a2 + 48);
  }

  int v7 = *(_DWORD *)(a2 + 72);
  if (v7)
  {
    sub_10004AAFC(a1 + 64, *(_DWORD *)(a1 + 72) + v7);
    memcpy((void *)(*(void *)(a1 + 64) + 4LL * *(int *)(a1 + 72)), *(const void **)(a2 + 64), 4LL * *(int *)(a2 + 72));
    *(_DWORD *)(a1 + 72) += *(_DWORD *)(a2 + 72);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88),  *(_DWORD *)(a2 + 96) + *(_DWORD *)(a1 + 96));
  if (*(int *)(a2 + 96) >= 1)
  {
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(a2 + 88) + 8 * v8);
      int v10 = *(_DWORD *)(a1 + 100);
      uint64_t v11 = *(int *)(a1 + 96);
      if ((int)v11 >= v10)
      {
        if (v10 == *(_DWORD *)(a1 + 104))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88),  v10 + 1);
          int v10 = *(_DWORD *)(a1 + 100);
        }

        *(_DWORD *)(a1 + 100) = v10 + 1;
        uint64_t v13 = operator new(0x30uLL);
        v13[9] = 0;
        v13[10] = 0;
        *(void *)uint64_t v13 = &off_10188DFA8;
        *((void *)v13 + 1) = 0LL;
        *((void *)v13 + 2) = 0LL;
        *((void *)v13 + 3) = 0LL;
        uint64_t v14 = *(void *)(a1 + 88);
        uint64_t v15 = *(int *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v15 + 1;
        *(void *)(v14 + 8 * v15) = v13;
      }

      else
      {
        uint64_t v12 = *(void *)(a1 + 88);
        *(_DWORD *)(a1 + 96) = v11 + 1;
        uint64_t v13 = *(_DWORD **)(v12 + 8 * v11);
      }

      sub_100F52F58((uint64_t)v13, v9);
      ++v8;
    }

    while (v8 < *(int *)(a2 + 96));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112),  *(_DWORD *)(a2 + 120) + *(_DWORD *)(a1 + 120));
  if (*(int *)(a2 + 120) >= 1)
  {
    uint64_t v16 = 0LL;
    do
    {
      uint64_t v17 = *(void *)(*(void *)(a2 + 112) + 8 * v16);
      int v18 = *(_DWORD *)(a1 + 124);
      uint64_t v19 = *(int *)(a1 + 120);
      if ((int)v19 >= v18)
      {
        if (v18 == *(_DWORD *)(a1 + 128))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112),  v18 + 1);
          int v18 = *(_DWORD *)(a1 + 124);
        }

        *(_DWORD *)(a1 + 124) = v18 + 1;
        int v21 = operator new(0x30uLL);
        v21[9] = 0;
        v21[10] = 0;
        *(void *)int v21 = &off_10188DF30;
        *((void *)v21 + 1) = 0LL;
        *((void *)v21 + 2) = 0LL;
        *((void *)v21 + 3) = 0LL;
        uint64_t v22 = *(void *)(a1 + 112);
        uint64_t v23 = *(int *)(a1 + 120);
        *(_DWORD *)(a1 + 120) = v23 + 1;
        *(void *)(v22 + 8 * v23) = v21;
      }

      else
      {
        uint64_t v20 = *(void *)(a1 + 112);
        *(_DWORD *)(a1 + 120) = v19 + 1;
        int v21 = *(_DWORD **)(v20 + 8 * v19);
      }

      sub_100F526CC((uint64_t)v21, v17);
      ++v16;
    }

    while (v16 < *(int *)(a2 + 120));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 136),  *(_DWORD *)(a2 + 144) + *(_DWORD *)(a1 + 144));
  if (*(int *)(a2 + 144) >= 1)
  {
    uint64_t v24 = 0LL;
    do
    {
      uint64_t v25 = *(void *)(*(void *)(a2 + 136) + 8 * v24);
      int v26 = *(_DWORD *)(a1 + 148);
      uint64_t v27 = *(int *)(a1 + 144);
      if ((int)v27 >= v26)
      {
        if (v26 == *(_DWORD *)(a1 + 152))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 136),  v26 + 1);
          int v26 = *(_DWORD *)(a1 + 148);
        }

        *(_DWORD *)(a1 + 148) = v26 + 1;
        double v29 = operator new(0x30uLL);
        v29[9] = 0;
        v29[10] = 0;
        *(void *)double v29 = &off_10188DF30;
        *((void *)v29 + 1) = 0LL;
        *((void *)v29 + 2) = 0LL;
        *((void *)v29 + 3) = 0LL;
        uint64_t v30 = *(void *)(a1 + 136);
        uint64_t v31 = *(int *)(a1 + 144);
        *(_DWORD *)(a1 + 144) = v31 + 1;
        *(void *)(v30 + 8 * v31) = v29;
      }

      else
      {
        uint64_t v28 = *(void *)(a1 + 136);
        *(_DWORD *)(a1 + 144) = v27 + 1;
        double v29 = *(_DWORD **)(v28 + 8 * v27);
      }

      sub_100F526CC((uint64_t)v29, v25);
      ++v24;
    }

    while (v24 < *(int *)(a2 + 144));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 160),  *(_DWORD *)(a2 + 168) + *(_DWORD *)(a1 + 168));
  if (*(int *)(a2 + 168) >= 1)
  {
    uint64_t v32 = 0LL;
    do
    {
      uint64_t v33 = *(void *)(*(void *)(a2 + 160) + 8 * v32);
      int v34 = *(_DWORD *)(a1 + 172);
      uint64_t v35 = *(int *)(a1 + 168);
      if ((int)v35 >= v34)
      {
        if (v34 == *(_DWORD *)(a1 + 176))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 160),  v34 + 1);
          int v34 = *(_DWORD *)(a1 + 172);
        }

        *(_DWORD *)(a1 + 172) = v34 + 1;
        unint64_t v37 = operator new(0x30uLL);
        v37[9] = 0;
        v37[10] = 0;
        *(void *)unint64_t v37 = &off_10188DF30;
        *((void *)v37 + 1) = 0LL;
        *((void *)v37 + 2) = 0LL;
        *((void *)v37 + 3) = 0LL;
        uint64_t v38 = *(void *)(a1 + 160);
        uint64_t v39 = *(int *)(a1 + 168);
        *(_DWORD *)(a1 + 168) = v39 + 1;
        *(void *)(v38 + 8 * v39) = v37;
      }

      else
      {
        uint64_t v36 = *(void *)(a1 + 160);
        *(_DWORD *)(a1 + 168) = v35 + 1;
        unint64_t v37 = *(_DWORD **)(v36 + 8 * v35);
      }

      sub_100F526CC((uint64_t)v37, v33);
      ++v32;
    }

    while (v32 < *(int *)(a2 + 168));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 184),  *(_DWORD *)(a2 + 192) + *(_DWORD *)(a1 + 192));
  if (*(int *)(a2 + 192) >= 1)
  {
    uint64_t v40 = 0LL;
    do
    {
      uint64_t v41 = *(void *)(*(void *)(a2 + 184) + 8 * v40);
      int v42 = *(_DWORD *)(a1 + 196);
      uint64_t v43 = *(int *)(a1 + 192);
      if ((int)v43 >= v42)
      {
        if (v42 == *(_DWORD *)(a1 + 200))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 184),  v42 + 1);
          int v42 = *(_DWORD *)(a1 + 196);
        }

        *(_DWORD *)(a1 + 196) = v42 + 1;
        __int128 v45 = operator new(0x30uLL);
        v45[9] = 0;
        v45[10] = 0;
        *(void *)__int128 v45 = &off_10188DF30;
        *((void *)v45 + 1) = 0LL;
        *((void *)v45 + 2) = 0LL;
        *((void *)v45 + 3) = 0LL;
        uint64_t v46 = *(void *)(a1 + 184);
        uint64_t v47 = *(int *)(a1 + 192);
        *(_DWORD *)(a1 + 192) = v47 + 1;
        *(void *)(v46 + 8 * v47) = v45;
      }

      else
      {
        uint64_t v44 = *(void *)(a1 + 184);
        *(_DWORD *)(a1 + 192) = v43 + 1;
        __int128 v45 = *(_DWORD **)(v44 + 8 * v43);
      }

      sub_100F526CC((uint64_t)v45, v41);
      ++v40;
    }

    while (v40 < *(int *)(a2 + 192));
  }

  if ((*(_BYTE *)(a2 + 212) & 1) != 0)
  {
    *(_DWORD *)(a1 + 212) |= 1u;
    BOOL v48 = *(char **)(a1 + 8);
    if (!v48)
    {
      BOOL v48 = (char *)operator new(0x50uLL);
      *(void *)BOOL v48 = off_10188DEB8;
      *(_OWORD *)(v48 + 8) = 0u;
      *(_OWORD *)(v48 + 24) = 0u;
      *((_DWORD *)v48 + 10) = 1;
      *((_DWORD *)v48 + 17) = 0;
      *((_DWORD *)v48 + 18) = 0;
      *(void *)(v48 + 44) = 0LL;
      *(void *)(v48 + 60) = 0LL;
      *(void *)(v48 + 52) = 0LL;
      *(void *)(a1 + 8) = v48;
    }

    uint64_t v49 = *(void *)(a2 + 8);
    if (!v49) {
      uint64_t v49 = *(void *)(qword_1019A4088 + 8);
    }
    sub_100F51950((uint64_t)v48, v49);
  }

void sub_100F50FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100F50FE4()
{
  return 1LL;
}

void *sub_100F50FEC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.LogEntry");
}

double sub_100F50FFC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v7,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  465LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v7,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v6, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }

  if ((*(_BYTE *)(a2 + 20) & 1) != 0)
  {
    double result = *(double *)(a2 + 8);
    *(_DWORD *)(a1 + 20) |= 1u;
    *(double *)(a1 + 8) = result;
  }

  return result;
}

void sub_100F51084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F5109C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DDC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100F510AC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DDC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100F510CC()
{
  double result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *double result = off_10188DDC8;
  return result;
}

uint64_t sub_100F510F4(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100F51108( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      int v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
      }

      if ((_DWORD)TagFallback != 9) {
        break;
      }
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v8) & 1) == 0) {
        return 0LL;
      }
      *(void *)(a1 + 8) = v8;
      *(_DWORD *)(a1 + 20) |= 1u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100F511F4( uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  if ((*(_BYTE *)(result + 20) & 1) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  a2,  *(double *)(result + 8),  a3);
  }
  return result;
}

uint64_t sub_100F5120C(uint64_t a1)
{
  uint64_t v1 = ((int)(*(_DWORD *)(a1 + 20) << 31) >> 31) & 9;
  *(_DWORD *)(a1 + 16) = v1;
  return v1;
}

double sub_100F51228(uint64_t a1, void *lpsrc)
{
  return sub_100F50FFC(a1, (uint64_t)lpsrc);
}

uint64_t sub_100F51274()
{
  return 1LL;
}

void *sub_100F5127C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.RayTracingTileTimestamp");
}

void sub_100F5128C(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_10188DE40;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A4068 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100F512E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100F512F4()
{
  unsigned __int8 v0 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v0 = &off_10188DE40;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 36) = 0u;
  return result;
}

uint64_t sub_100F51328( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unsigned int *)(a1 + 16);
  char v6 = (unsigned int *)(a1 + 20);
  int v7 = (unsigned int *)(a1 + 40);
  while (2)
  {
    unint64_t v8 = (char *)*((void *)this + 1);
    if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v8 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_24;
        }
        *(_DWORD *)(a1 + 48) |= 1u;
        uint64_t v11 = *(void **)(a1 + 8);
        if (!v11)
        {
          uint64_t v11 = operator new(0x18uLL);
          v11[1] = 0LL;
          uint64_t v11[2] = 0LL;
          *uint64_t v11 = off_10188DDC8;
          *(void *)(a1 + 8) = v11;
        }

        uint64_t v12 = (char *)*((void *)this + 1);
        if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v30)) {
            return 0LL;
          }
        }

        else
        {
          v30[0] = *v12;
          *((void *)this + 1) = v12 + 1;
        }

        int v17 = *((_DWORD *)this + 14);
        int v18 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v17 + 1;
        if (v17 >= v18) {
          return 0LL;
        }
        int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v30[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v19);
        int v21 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v21, 1);
        int v23 = v21 - 1;
        if (v23 < 0 == v22) {
          *((_DWORD *)this + 14) = v23;
        }
        uint64_t v24 = (_BYTE *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        uint64_t v14 = v24 + 1;
        *((void *)this + 1) = v14;
        goto LABEL_36;
      case 2u:
        int v10 = TagFallback & 7;
        uint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
LABEL_36:
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v25 = (_BYTE *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v14;
          uint64_t v25 = v14 + 1;
          *((void *)this + 1) = v25;
        }

        *(_DWORD *)(a1 + 48) |= 2u;
        uint64_t v15 = v25 + 1;
        *((void *)this + 1) = v15;
LABEL_44:
        if ((unint64_t)v15 >= v13 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v27 = (_BYTE *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          *char v6 = *v15;
          uint64_t v27 = v15 + 1;
          *((void *)this + 1) = v27;
        }

        *(_DWORD *)(a1 + 48) |= 4u;
        uint64_t v16 = v27 + 1;
        *((void *)this + 1) = v16;
LABEL_52:
        if ((unint64_t)v16 >= v13 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v28 = (_BYTE *)*((void *)this + 1);
          unint64_t v13 = *((void *)this + 2);
        }

        else
        {
          *int v7 = *v16;
          uint64_t v28 = v16 + 1;
          *((void *)this + 1) = v28;
        }

        *(_DWORD *)(a1 + 48) |= 8u;
        *((void *)this + 1) = v28 + 1;
LABEL_60:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v30) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 24) = *(void *)v30;
        *(_DWORD *)(a1 + 48) |= 0x10u;
        double v29 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v29 + 1;
LABEL_64:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v30) & 1) != 0)
        {
          *(void *)(a1 + 32) = *(void *)v30;
          *(_DWORD *)(a1 + 48) |= 0x20u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v10 = TagFallback & 7;
        uint64_t v15 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_44;
      case 4u:
        int v10 = TagFallback & 7;
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_52;
      case 5u:
        int v10 = TagFallback & 7;
        if (v10 == 1) {
          goto LABEL_60;
        }
        goto LABEL_24;
      case 6u:
        int v10 = TagFallback & 7;
        if (v10 != 1) {
          goto LABEL_24;
        }
        goto LABEL_64;
      default:
        int v10 = TagFallback & 7;
LABEL_24:
        if (v10 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100F51708( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 48);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A4068 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }

uint64_t sub_100F517E4(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_29;
  }

  if ((*(_BYTE *)(a1 + 48) & 1) == 0)
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 48) & 2) == 0) {
      goto LABEL_13;
    }
    goto LABEL_9;
  }

  uint64_t v6 = *(void *)(a1 + 8);
  if (!v6) {
    uint64_t v6 = *(void *)(qword_1019A4068 + 8);
  }
  int v7 = ((int)(*(_DWORD *)(v6 + 20) << 31) >> 31) & 9;
  *(_DWORD *)(v6 + 16) = v7;
  int v4 = v7 | 2;
  int v3 = *(_DWORD *)(a1 + 48);
  if ((v3 & 2) != 0)
  {
LABEL_9:
    unint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v8 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 48);
    }

    else
    {
      int v9 = 2;
    }

    v4 += v9;
  }

double sub_100F518EC(uint64_t a1, void *lpsrc)
{
  return sub_100F508F0(a1, (uint64_t)lpsrc);
}

uint64_t sub_100F51938()
{
  return 1LL;
}

void *sub_100F51940@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.RayTracingTileHeader");
}

void sub_100F51950(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v21,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  1373LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v21,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v20, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v21);
  }

  int v5 = *(_DWORD *)(a2 + 72);
  if (!(_BYTE)v5) {
    goto LABEL_13;
  }
  if ((v5 & 1) != 0)
  {
    uint64_t v8 = *(void *)(a2 + 8);
    *(_DWORD *)(a1 + 72) |= 1u;
    *(void *)(a1 + 8) = v8;
    int v5 = *(_DWORD *)(a2 + 72);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_24;
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_6;
  }

  int v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 72) |= 2u;
  *(_DWORD *)(a1 + 16) = v9;
  int v5 = *(_DWORD *)(a2 + 72);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_25;
  }

void sub_100F51B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F51BA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DEB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100F51BB4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188DEB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100F51BD4()
{
  unsigned __int8 v0 = (char *)operator new(0x50uLL);
  *(void *)unsigned __int8 v0 = off_10188DEB8;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *((_DWORD *)v0 + 10) = 1;
  *((_DWORD *)v0 + 17) = 0;
  *((_DWORD *)v0 + 18) = 0;
  *(void *)(v0 + 44) = 0LL;
  *(void *)(v0 + 60) = 0LL;
  *(void *)(v0 + 52) = 0LL;
  return result;
}

uint64_t sub_100F51C1C(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 72);
  if ((_BYTE)v1)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_DWORD *)(result + 40) = 1;
  }

  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(result + 52) = 0LL;
    *(void *)(result + 44) = 0LL;
    *(void *)(result + 60) = 0LL;
  }

  *(_DWORD *)(result + 72) = 0;
  return result;
}

uint64_t sub_100F51C58( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v40 = (unint64_t *)(a1 + 2);
  uint64_t v41 = a1 + 4;
  int v5 = a1 + 10;
  int v6 = a1 + 11;
  int v7 = a1 + 12;
  uint64_t v8 = a1 + 13;
  int v9 = a1 + 14;
  int v10 = a1 + 15;
  int v11 = a1 + 16;
  while (2)
  {
    int v12 = (char *)*((void *)this + 1);
    if ((unint64_t)v12 >= *((void *)this + 2) || *v12 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v12;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v12 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v14 = TagFallback & 7;
        if (v14 != 1) {
          goto LABEL_42;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, v40);
        if ((_DWORD)result)
        {
          a1[18] |= 1u;
          int v17 = (_BYTE *)*((void *)this + 1);
          unint64_t v16 = *((void *)this + 2);
          if ((unint64_t)v17 < v16 && *v17 == 16)
          {
            int v18 = v17 + 1;
            *((void *)this + 1) = v18;
            goto LABEL_16;
          }

          continue;
        }

        return result;
      case 2u:
        int v14 = TagFallback & 7;
        int v18 = (char *)*((void *)this + 1);
        unint64_t v16 = *((void *)this + 2);
LABEL_16:
        if ((unint64_t)v18 >= v16 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41);
          if (!(_DWORD)result) {
            return result;
          }
          int v19 = (_BYTE *)*((void *)this + 1);
          unint64_t v16 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v41 = *v18;
          int v19 = v18 + 1;
          *((void *)this + 1) = v19;
        }

        a1[18] |= 2u;
        if ((unint64_t)v19 < v16 && *v19 == 29)
        {
          *((void *)this + 1) = v19 + 1;
          goto LABEL_51;
        }

        continue;
      case 3u:
        int v14 = TagFallback & 7;
        if (v14 != 5) {
          goto LABEL_42;
        }
LABEL_51:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v42) & 1) == 0) {
          return 0LL;
        }
        a1[5] = v42;
        a1[18] |= 4u;
        uint64_t v28 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v28 + 1;
LABEL_55:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v42) & 1) == 0) {
          return 0LL;
        }
        a1[6] = v42;
        a1[18] |= 8u;
        double v29 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v29 + 1;
LABEL_59:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v42) & 1) == 0) {
          return 0LL;
        }
        a1[7] = v42;
        a1[18] |= 0x10u;
        uint64_t v30 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v30 + 1;
LABEL_63:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v42) & 1) == 0) {
          return 0LL;
        }
        a1[8] = v42;
        a1[18] |= 0x20u;
        uint64_t v31 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v31 + 1;
LABEL_67:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v42) & 1) != 0)
        {
          a1[9] = v42;
          a1[18] |= 0x40u;
          uint64_t v32 = (_BYTE *)*((void *)this + 1);
          unint64_t v20 = *((void *)this + 2);
          if ((unint64_t)v32 < v20 && *v32 == 64)
          {
            int v21 = v32 + 1;
            *((void *)this + 1) = v21;
LABEL_71:
            if ((unint64_t)v21 >= v20 || *v21 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
              if (!(_DWORD)result) {
                return result;
              }
              uint64_t v33 = (_BYTE *)*((void *)this + 1);
              unint64_t v20 = *((void *)this + 2);
            }

            else
            {
              *int v5 = *v21;
              uint64_t v33 = v21 + 1;
              *((void *)this + 1) = v33;
            }

            a1[18] |= 0x80u;
            if ((unint64_t)v33 < v20 && *v33 == 72)
            {
              BOOL v22 = v33 + 1;
              *((void *)this + 1) = v22;
LABEL_79:
              if ((unint64_t)v22 >= v20 || *v22 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
                if (!(_DWORD)result) {
                  return result;
                }
                int v34 = (_BYTE *)*((void *)this + 1);
                unint64_t v20 = *((void *)this + 2);
              }

              else
              {
                *int v6 = *v22;
                int v34 = v22 + 1;
                *((void *)this + 1) = v34;
              }

              a1[18] |= 0x100u;
              if ((unint64_t)v34 < v20 && *v34 == 80)
              {
                int v23 = v34 + 1;
                *((void *)this + 1) = v23;
LABEL_87:
                if ((unint64_t)v23 >= v20 || *v23 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
                  if (!(_DWORD)result) {
                    return result;
                  }
                  uint64_t v35 = (_BYTE *)*((void *)this + 1);
                  unint64_t v20 = *((void *)this + 2);
                }

                else
                {
                  *int v7 = *v23;
                  uint64_t v35 = v23 + 1;
                  *((void *)this + 1) = v35;
                }

                a1[18] |= 0x200u;
                if ((unint64_t)v35 < v20 && *v35 == 88)
                {
                  uint64_t v24 = v35 + 1;
                  *((void *)this + 1) = v24;
LABEL_95:
                  if ((unint64_t)v24 >= v20 || *v24 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v8);
                    if (!(_DWORD)result) {
                      return result;
                    }
                    uint64_t v36 = (_BYTE *)*((void *)this + 1);
                    unint64_t v20 = *((void *)this + 2);
                  }

                  else
                  {
                    unsigned int *v8 = *v24;
                    uint64_t v36 = v24 + 1;
                    *((void *)this + 1) = v36;
                  }

                  a1[18] |= 0x400u;
                  if ((unint64_t)v36 < v20 && *v36 == 96)
                  {
                    uint64_t v25 = v36 + 1;
                    *((void *)this + 1) = v25;
LABEL_103:
                    if ((unint64_t)v25 >= v20 || *v25 < 0)
                    {
                      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v9);
                      if (!(_DWORD)result) {
                        return result;
                      }
                      unint64_t v37 = (_BYTE *)*((void *)this + 1);
                      unint64_t v20 = *((void *)this + 2);
                    }

                    else
                    {
                      unsigned int *v9 = *v25;
                      unint64_t v37 = v25 + 1;
                      *((void *)this + 1) = v37;
                    }

                    a1[18] |= 0x800u;
                    if ((unint64_t)v37 < v20 && *v37 == 104)
                    {
                      int v26 = v37 + 1;
                      *((void *)this + 1) = v26;
LABEL_111:
                      if ((unint64_t)v26 >= v20 || *v26 < 0)
                      {
                        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v10);
                        if (!(_DWORD)result) {
                          return result;
                        }
                        uint64_t v38 = (_BYTE *)*((void *)this + 1);
                        unint64_t v20 = *((void *)this + 2);
                      }

                      else
                      {
                        *int v10 = *v26;
                        uint64_t v38 = v26 + 1;
                        *((void *)this + 1) = v38;
                      }

                      a1[18] |= 0x1000u;
                      if ((unint64_t)v38 < v20 && *v38 == 112)
                      {
                        uint64_t v27 = v38 + 1;
                        *((void *)this + 1) = v27;
LABEL_119:
                        if ((unint64_t)v27 >= v20 || *v27 < 0)
                        {
                          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v11);
                          if (!(_DWORD)result) {
                            return result;
                          }
                          uint64_t v39 = (unsigned __int8 *)*((void *)this + 1);
                          unint64_t v20 = *((void *)this + 2);
                        }

                        else
                        {
                          *int v11 = *v27;
                          uint64_t v39 = (unsigned __int8 *)(v27 + 1);
                          *((void *)this + 1) = v39;
                        }

                        a1[18] |= 0x2000u;
                        if (v39 == (unsigned __int8 *)v20
                          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                        {
                          *((_DWORD *)this + 8) = 0;
                          uint64_t result = 1LL;
                          *((_BYTE *)this + 36) = 1;
                          return result;
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          continue;
        }

        return 0LL;
      case 4u:
        int v14 = TagFallback & 7;
        if (v14 == 5) {
          goto LABEL_55;
        }
        goto LABEL_42;
      case 5u:
        int v14 = TagFallback & 7;
        if (v14 == 5) {
          goto LABEL_59;
        }
        goto LABEL_42;
      case 6u:
        int v14 = TagFallback & 7;
        if (v14 == 5) {
          goto LABEL_63;
        }
        goto LABEL_42;
      case 7u:
        int v14 = TagFallback & 7;
        if (v14 == 5) {
          goto LABEL_67;
        }
        goto LABEL_42;
      case 8u:
        int v14 = TagFallback & 7;
        int v21 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_71;
      case 9u:
        int v14 = TagFallback & 7;
        BOOL v22 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_79;
      case 0xAu:
        int v14 = TagFallback & 7;
        int v23 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_87;
      case 0xBu:
        int v14 = TagFallback & 7;
        uint64_t v24 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_95;
      case 0xCu:
        int v14 = TagFallback & 7;
        uint64_t v25 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_103;
      case 0xDu:
        int v14 = TagFallback & 7;
        int v26 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_111;
      case 0xEu:
        int v14 = TagFallback & 7;
        uint64_t v27 = (char *)*((void *)this + 1);
        unint64_t v20 = *((void *)this + 2);
        goto LABEL_119;
      default:
        int v14 = TagFallback & 7;
LABEL_42:
        if (v14 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100F522E0( uint64_t result, unint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 72);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFixed64( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(void *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 72);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_18;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  v4,  a4);
  int v6 = *(_DWORD *)(v5 + 72);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_19;
  }

uint64_t sub_100F5248C(unsigned int *a1, unsigned int a2)
{
  unsigned int v3 = a1[18];
  if ((_BYTE)v3)
  {
    int v4 = ((int)(v3 << 31) >> 31) & 9;
    if ((v3 & 2) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[4];
      if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
        unsigned int v3 = a1[18];
      }

      else
      {
        int v6 = 2;
      }

      v4 += v6;
    }

    unsigned int v8 = v4 + 5;
    if ((v3 & 4) == 0) {
      unsigned int v8 = v4;
    }
    if ((v3 & 8) != 0) {
      v8 += 5;
    }
    if ((v3 & 0x10) != 0) {
      v8 += 5;
    }
    if ((v3 & 0x20) != 0) {
      v8 += 5;
    }
    if ((v3 & 0x40) != 0) {
      uint64_t v7 = v8 + 5;
    }
    else {
      uint64_t v7 = v8;
    }
    if ((v3 & 0x80) != 0)
    {
      int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[10];
      if (v9 >= 0x80)
      {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
        unsigned int v3 = a1[18];
      }

      else
      {
        int v10 = 2;
      }

      uint64_t v7 = (v10 + v7);
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if ((v3 & 0xFF00) == 0) {
    goto LABEL_56;
  }
  if ((v3 & 0x100) != 0)
  {
    int v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[11];
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2) + 1;
      unsigned int v3 = a1[18];
    }

    else
    {
      int v12 = 2;
    }

    uint64_t v7 = (v12 + v7);
    if ((v3 & 0x200) == 0)
    {
LABEL_27:
      if ((v3 & 0x400) == 0) {
        goto LABEL_28;
      }
      goto LABEL_40;
    }
  }

  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_27;
  }

  int v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[12];
  if (v13 >= 0x80)
  {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2) + 1;
    unsigned int v3 = a1[18];
  }

  else
  {
    int v14 = 2;
  }

  uint64_t v7 = (v14 + v7);
  if ((v3 & 0x400) == 0)
  {
LABEL_28:
    if ((v3 & 0x800) == 0) {
      goto LABEL_29;
    }
LABEL_44:
    int v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[14];
    if (v17 >= 0x80)
    {
      int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2) + 1;
      unsigned int v3 = a1[18];
    }

    else
    {
      int v18 = 2;
    }

    uint64_t v7 = (v18 + v7);
    if ((v3 & 0x1000) == 0)
    {
LABEL_30:
      if ((v3 & 0x2000) == 0) {
        goto LABEL_56;
      }
      goto LABEL_52;
    }

    goto LABEL_48;
  }

void sub_100F52668(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100F526B4()
{
  return 1LL;
}

void *sub_100F526BC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.RayTracingTilePayloadMetaData");
}

void sub_100F526CC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  1675LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_10004AAFC(a1 + 16, *(_DWORD *)(a1 + 24) + v5);
    memcpy((void *)(*(void *)(a1 + 16) + 4LL * *(int *)(a1 + 24)), *(const void **)(a2 + 16), 4LL * *(int *)(a2 + 24));
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 40);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 40) & 1) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 40) |= 1u;
      *(_DWORD *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 40);
    }

    if ((v6 & 2) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 40) |= 2u;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }

void sub_100F527B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F527D0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_10188DF30;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2) {
    operator delete[](v2);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100F5280C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

_DWORD *sub_100F52820()
{
  uint64_t result = operator new(0x30uLL);
  result[9] = 0;
  result[10] = 0;
  *(void *)uint64_t result = &off_10188DF30;
  *((void *)result + 1) = 0LL;
  *((void *)result + 2) = 0LL;
  *((void *)result + 3) = 0LL;
  return result;
}

uint64_t sub_100F5284C(uint64_t result)
{
  if (*(_BYTE *)(result + 40)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

uint64_t sub_100F52864( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 16;
  int v6 = (unsigned int *)(a1 + 12);
  do
  {
    while (1)
    {
      while (1)
      {
        int v7 = (char *)*((void *)this + 1);
        if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v7 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v9 = TagFallback >> 3;
        int v10 = TagFallback & 7;
        int v13 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        if ((unint64_t)v13 >= v11 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v14 = v25;
          int v15 = (_BYTE *)*((void *)this + 1);
          unint64_t v11 = *((void *)this + 2);
        }

        else
        {
          unsigned int v14 = *v13;
          int v15 = v13 + 1;
          *((void *)this + 1) = v15;
        }

        *(_DWORD *)(a1 + 8) = -(v14 & 1) ^ (v14 >> 1);
        *(_DWORD *)(a1 + 40) |= 1u;
        if ((unint64_t)v15 < v11 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *((void *)this + 1) = v16;
          goto LABEL_30;
        }
      }

      if (v9 != 2) {
        break;
      }
      int v10 = TagFallback & 7;
      int v16 = (char *)*((void *)this + 1);
      unint64_t v11 = *((void *)this + 2);
LABEL_30:
      if ((unint64_t)v16 >= v11 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
        if (!(_DWORD)result) {
          return result;
        }
        int v18 = (_BYTE *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
      }

      else
      {
        *int v6 = *v16;
        int v18 = v16 + 1;
        *((void *)this + 1) = v18;
      }

      *(_DWORD *)(a1 + 40) |= 2u;
      if ((unint64_t)v18 < v11 && *v18 == 26)
      {
        int v12 = v18 + 1;
        *((void *)this + 1) = v12;
LABEL_38:
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v27)) {
            return 0LL;
          }
          unsigned int v19 = v27;
        }

        else
        {
          unsigned int v19 = *v12;
          unsigned int v27 = v19;
          *((void *)this + 1) = v12 + 1;
        }

        int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v19);
        while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
        {
          int v21 = (char *)*((void *)this + 1);
          if ((unint64_t)v21 >= *((void *)this + 2) || *v21 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v26)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v26 = *v21;
            *((void *)this + 1) = v21 + 1;
          }

          int v22 = *(_DWORD *)(a1 + 24);
          if (v22 == *(_DWORD *)(a1 + 28))
          {
            sub_10004AAFC(v5, v22 + 1);
            int v22 = *(_DWORD *)(a1 + 24);
          }

          unsigned int v23 = v26;
          uint64_t v24 = *(void *)(a1 + 16);
          *(_DWORD *)(a1 + 24) = v22 + 1;
          *(_DWORD *)(v24 + 4LL * v22) = v23;
        }

        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
LABEL_53:
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v9 == 3)
    {
      int v10 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t result = sub_100F52B48(1, 0x1Au, this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_53;
      }

      if (v10 == 2)
      {
        int v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        goto LABEL_38;
      }
    }

    else
    {
      int v10 = TagFallback & 7;
    }

uint64_t sub_100F52B48( int a1, unsigned int a2, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a4)
{
  int v7 = (char *)*((void *)this + 1);
  if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    unsigned int v22 = *v7;
    *((void *)this + 1) = v7 + 1;
  }

  int v9 = *(_DWORD *)(a4 + 8);
  if (v9 == *(_DWORD *)(a4 + 12))
  {
    sub_10004AAFC(a4, v9 + 1);
    int v9 = *(_DWORD *)(a4 + 8);
  }

  unsigned int v10 = v22;
  uint64_t v11 = *(void *)a4;
  *(_DWORD *)(a4 + 8) = v9 + 1;
  *(_DWORD *)(v11 + 4LL * v9) = v10;
  int v12 = *(_DWORD *)(a4 + 12) - *(_DWORD *)(a4 + 8);
  if (v12 >= 1)
  {
    int v13 = v12 + 1;
    do
    {
      if (a2 > 0x7F)
      {
        if (a2 >> 14) {
          return 1LL;
        }
        int v17 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        int v16 = (char *)(v17 + 2);
      }

      else
      {
        int v15 = (unsigned __int8 *)*((void *)this + 1);
        unint64_t v14 = *((void *)this + 2);
        int v16 = (char *)(v15 + 1);
      }

      *((void *)this + 1) = v16;
      if ((unint64_t)v16 >= v14 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22);
        if (!(_DWORD)result) {
          return result;
        }
      }

      else
      {
        unsigned int v22 = *v16;
        *((void *)this + 1) = v16 + 1;
      }

      int v18 = *(_DWORD *)(a4 + 8);
      if (v18 >= *(_DWORD *)(a4 + 12))
      {
        wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v24,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Contents/Develop er/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h",  602LL);
        uint64_t v19 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v24,  "CHECK failed: (size()) < (Capacity()): ");
        wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v23, v19);
        wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v24);
        int v18 = *(_DWORD *)(a4 + 8);
      }

      unsigned int v20 = v22;
      uint64_t v21 = *(void *)a4;
      *(_DWORD *)(a4 + 8) = v18 + 1;
      *(_DWORD *)(v21 + 4LL * v18) = v20;
      --v13;
    }

    while (v13 > 1);
  }

  return 1LL;
}

void sub_100F52D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100F52D38( uint64_t result, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 40);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteSInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  (int)a2,  a4);
    int v6 = *(_DWORD *)(v5 + 40);
  }

  if ((v6 & 2) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  if (*(int *)(v5 + 24) >= 1)
  {
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, 0x1Au);
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, *(_DWORD *)(v5 + 32));
    if (*(int *)(v5 + 24) >= 1)
    {
      uint64_t v7 = 0LL;
      do
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32( a2,  *(_DWORD *)(*(void *)(v5 + 16) + 4 * v7++));
      while (v7 < *(int *)(v5 + 24));
    }
  }

  return result;
}

uint64_t sub_100F52DE4(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 40);
  if (!v3)
  {
    int v4 = 0;
    goto LABEL_14;
  }

  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)((2 * *(_DWORD *)(a1 + 8)) ^ (*(int *)(a1 + 8) >> 31));
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 40) & 2) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 40) & 2) == 0) {
      goto LABEL_14;
    }
  }

  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 < 1)
  {
    LODWORD(v10) = 0;
  }

  else
  {
    uint64_t v9 = 0LL;
    LODWORD(v10) = 0;
    do
    {
      if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 24);
      }

      else
      {
        int v12 = 1;
      }

      unsigned int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v12 + (_DWORD)v10);
      ++v9;
    }

    while (v9 < v8);
    if ((int)v10 > 0)
    {
      else {
        int v13 = 2;
      }
      v4 += v13;
    }
  }

  uint64_t result = (v4 + (_DWORD)v10);
  *(_DWORD *)(a1 + 32) = (_DWORD)v10;
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

void sub_100F52EF4(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100F52F40()
{
  return 1LL;
}

void *sub_100F52F48@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.PointFacetVisibilityData");
}

void sub_100F52F58(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRayTracingTileData.pb.cc",  1929LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_10004AAFC(a1 + 16, *(_DWORD *)(a1 + 24) + v5);
    memcpy((void *)(*(void *)(a1 + 16) + 4LL * *(int *)(a1 + 24)), *(const void **)(a2 + 16), 4LL * *(int *)(a2 + 24));
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 40);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 40) & 1) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 40) |= 1u;
      *(_DWORD *)(a1 + 8) = v7;
      int v6 = *(_DWORD *)(a2 + 40);
    }

    if ((v6 & 2) != 0)
    {
      int v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a1 + 40) |= 2u;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }

void sub_100F53044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F5305C(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_10188DFA8;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2) {
    operator delete[](v2);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100F53098(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

_DWORD *sub_100F530AC()
{
  uint64_t result = operator new(0x30uLL);
  result[9] = 0;
  result[10] = 0;
  *(void *)uint64_t result = &off_10188DFA8;
  *((void *)result + 1) = 0LL;
  *((void *)result + 2) = 0LL;
  *((void *)result + 3) = 0LL;
  return result;
}

uint64_t sub_100F530D8(uint64_t result)
{
  if (*(_BYTE *)(result + 40)) {
    *(void *)(result + 8) = 0LL;
  }
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

uint64_t sub_100F530F0( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 16;
  int v6 = (unsigned int *)(a1 + 8);
  int v7 = (unsigned int *)(a1 + 12);
  do
  {
    while (1)
    {
      while (1)
      {
        int v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v8;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v8 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v10 = TagFallback >> 3;
        int v11 = TagFallback & 7;
        unint64_t v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          int v15 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          *int v6 = *v14;
          int v15 = v14 + 1;
          *((void *)this + 1) = v15;
        }

        *(_DWORD *)(a1 + 40) |= 1u;
        if ((unint64_t)v15 < v12 && *v15 == 16)
        {
          int v16 = v15 + 1;
          *((void *)this + 1) = v16;
          goto LABEL_30;
        }
      }

      if (v10 != 2) {
        break;
      }
      int v11 = TagFallback & 7;
      int v16 = (char *)*((void *)this + 1);
      unint64_t v12 = *((void *)this + 2);
LABEL_30:
      if ((unint64_t)v16 >= v12 || *v16 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v7);
        if (!(_DWORD)result) {
          return result;
        }
        int v18 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
      }

      else
      {
        *int v7 = *v16;
        int v18 = v16 + 1;
        *((void *)this + 1) = v18;
      }

      *(_DWORD *)(a1 + 40) |= 2u;
      if ((unint64_t)v18 < v12 && *v18 == 26)
      {
        int v13 = v18 + 1;
        *((void *)this + 1) = v13;
LABEL_38:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v26)) {
            return 0LL;
          }
          unsigned int v19 = v26;
        }

        else
        {
          unsigned int v19 = *v13;
          unsigned int v26 = v19;
          *((void *)this + 1) = v13 + 1;
        }

        int v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v19);
        while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
        {
          uint64_t v21 = (char *)*((void *)this + 1);
          if ((unint64_t)v21 >= *((void *)this + 2) || *v21 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v25)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v25 = *v21;
            *((void *)this + 1) = v21 + 1;
          }

          int v22 = *(_DWORD *)(a1 + 24);
          if (v22 == *(_DWORD *)(a1 + 28))
          {
            sub_10004AAFC(v5, v22 + 1);
            int v22 = *(_DWORD *)(a1 + 24);
          }

          unsigned int v23 = v25;
          uint64_t v24 = *(void *)(a1 + 16);
          *(_DWORD *)(a1 + 24) = v22 + 1;
          *(_DWORD *)(v24 + 4LL * v22) = v23;
        }

        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
LABEL_53:
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (v10 == 3)
    {
      int v11 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t result = sub_100F52B48(1, 0x1Au, this, v5);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_53;
      }

      if (v11 == 2)
      {
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_38;
      }
    }

    else
    {
      int v11 = TagFallback & 7;
    }

uint64_t sub_100F533C8( uint64_t result, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 40);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 40);
  }

  if ((v6 & 2) != 0) {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  if (*(int *)(v5 + 24) >= 1)
  {
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, 0x1Au);
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, *(_DWORD *)(v5 + 32));
    if (*(int *)(v5 + 24) >= 1)
    {
      uint64_t v7 = 0LL;
      do
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32( a2,  *(_DWORD *)(*(void *)(v5 + 16) + 4 * v7++));
      while (v7 < *(int *)(v5 + 24));
    }
  }

  return result;
}

uint64_t sub_100F53474(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 40);
  if (!v3)
  {
    int v4 = 0;
    goto LABEL_14;
  }

  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if (v5 >= 0x80)
    {
      int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      if ((*(_DWORD *)(a1 + 40) & 2) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      int v4 = 2;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 40) & 2) == 0) {
      goto LABEL_14;
    }
  }

  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
  else {
    int v7 = 2;
  }
  v4 += v7;
LABEL_14:
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 < 1)
  {
    LODWORD(v10) = 0;
  }

  else
  {
    uint64_t v9 = 0LL;
    LODWORD(v10) = 0;
    do
    {
      if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11, a2);
        int v8 = *(_DWORD *)(a1 + 24);
      }

      else
      {
        int v12 = 1;
      }

      unsigned int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v12 + (_DWORD)v10);
      ++v9;
    }

    while (v9 < v8);
    if ((int)v10 > 0)
    {
      else {
        int v13 = 2;
      }
      v4 += v13;
    }
  }

  uint64_t result = (v4 + (_DWORD)v10);
  *(_DWORD *)(a1 + 32) = (_DWORD)v10;
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

void sub_100F5357C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100F535C8()
{
  return 1LL;
}

void *sub_100F535D0@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.FacetInterVisibilityData");
}

void sub_100F535E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10188E020;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A4088 != a1)
  {
    uint64_t v2 = *((void *)a1 + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  sub_10008D0EC((uint64_t)a1 + 184);
  sub_10008D0EC((uint64_t)a1 + 160);
  sub_10008D0EC((uint64_t)a1 + 136);
  sub_10008D0EC((uint64_t)a1 + 112);
  sub_10008D0EC((uint64_t)a1 + 88);
  char v3 = (void *)*((void *)a1 + 8);
  if (v3) {
    operator delete[](v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 5);
  if (v4) {
    operator delete[](v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 2);
  if (v5) {
    operator delete[](v5);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100F53694(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100F536A8()
{
  uint64_t result = operator new(0xD8uLL);
  result[5] = 0LL;
  result[6] = 0LL;
  result[8] = 0LL;
  result[9] = 0LL;
  result[11] = 0LL;
  result[12] = 0LL;
  *((_DWORD *)result + 26) = 0;
  result[14] = 0LL;
  result[15] = 0LL;
  *((_DWORD *)result + 32) = 0;
  result[17] = 0LL;
  result[18] = 0LL;
  *((_DWORD *)result + 38) = 0;
  *((_DWORD *)result + 44) = 0;
  result[20] = 0LL;
  result[21] = 0LL;
  *((_DWORD *)result + 50) = 0;
  result[23] = 0LL;
  result[24] = 0LL;
  result[26] = 0LL;
  *uint64_t result = off_10188E020;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100F53704( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 64;
  uint64_t v6 = a1 + 40;
  uint64_t v7 = a1 + 16;
  BOOL v122 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112);
  v123 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88);
  double v120 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 160);
  double v121 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 136);
  int v8 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 184);
LABEL_2:
  while (2)
  {
    uint64_t v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v9;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_33;
        }
        *(_DWORD *)(a1 + 212) |= 1u;
        int v12 = *(char **)(a1 + 8);
        if (!v12)
        {
          int v12 = (char *)operator new(0x50uLL);
          *(void *)int v12 = off_10188DEB8;
          *(_OWORD *)(v12 + 8) = 0u;
          *(_OWORD *)(v12 + 24) = 0u;
          *((_DWORD *)v12 + 10) = 1;
          *((_DWORD *)v12 + 17) = 0;
          *((_DWORD *)v12 + 18) = 0;
          *(void *)(v12 + 44) = 0LL;
          *(void *)(v12 + 60) = 0LL;
          *(void *)(v12 + 52) = 0LL;
          *(void *)(a1 + 8) = v12;
        }

        int v13 = (char *)*((void *)this + 1);
        if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v124)) {
            return 0LL;
          }
        }

        else
        {
          v124[0] = *v13;
          *((void *)this + 1) = v13 + 1;
        }

        int v21 = *((_DWORD *)this + 14);
        int v22 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v21 + 1;
        if (v21 >= v22) {
          return 0LL;
        }
        int v23 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v124[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v23);
        int v25 = *((_DWORD *)this + 14);
        BOOL v26 = __OFSUB__(v25, 1);
        int v27 = v25 - 1;
        if (v27 < 0 == v26) {
          *((_DWORD *)this + 14) = v27;
        }
        uint64_t v28 = (_BYTE *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        unint64_t v14 = v28 + 1;
        *((void *)this + 1) = v14;
        goto LABEL_51;
      case 2u:
        int v11 = TagFallback & 7;
        if ((TagFallback & 7) == 0)
        {
          uint64_t result = sub_1003E13C4(1, 0x12u, this, v7);
          if (!(_DWORD)result) {
            return result;
          }
LABEL_66:
          uint64_t v35 = (_BYTE *)*((void *)this + 1);
          unint64_t v17 = *((void *)this + 2);
          if ((unint64_t)v35 < v17 && *v35 == 26)
          {
            int v16 = v35 + 1;
            *((void *)this + 1) = v16;
LABEL_69:
            if ((unint64_t)v16 >= v17 || *v16 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v124)) {
                return 0LL;
              }
              int v36 = v124[0];
            }

            else
            {
              int v36 = *v16;
              v124[0] = v36;
              *((void *)this + 1) = v16 + 1;
            }

            int v37 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v36);
            while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
            {
              uint64_t v38 = (char *)*((void *)this + 1);
              if ((unint64_t)v38 >= *((void *)this + 2) || *v38 < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v125)) {
                  return 0LL;
                }
              }

              else
              {
                unsigned int v125 = *v38;
                *((void *)this + 1) = v38 + 1;
              }

              int v39 = *(_DWORD *)(a1 + 48);
              if (v39 == *(_DWORD *)(a1 + 52))
              {
                sub_10004AAFC(v6, v39 + 1);
                int v39 = *(_DWORD *)(a1 + 48);
              }

              unsigned int v40 = v125;
              uint64_t v41 = *(void *)(a1 + 40);
              *(_DWORD *)(a1 + 48) = v39 + 1;
              *(_DWORD *)(v41 + 4LL * v39) = v40;
            }

            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v37);
            goto LABEL_84;
          }

          continue;
        }

        if (v11 == 2)
        {
          unint64_t v14 = (char *)*((void *)this + 1);
          unint64_t v15 = *((void *)this + 2);
LABEL_51:
          if ((unint64_t)v14 >= v15 || *v14 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v125)) {
              return 0LL;
            }
            unsigned int v29 = v125;
          }

          else
          {
            unsigned int v29 = *v14;
            unsigned int v125 = v29;
            *((void *)this + 1) = v14 + 1;
          }

          int v30 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v29);
          while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
          {
            uint64_t v31 = (char *)*((void *)this + 1);
            if ((unint64_t)v31 >= *((void *)this + 2) || *v31 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback( this,  (unint64_t *)v124)) {
                return 0LL;
              }
            }

            else
            {
              *(void *)unint64_t v124 = *v31;
              *((void *)this + 1) = v31 + 1;
            }

            int v32 = *(_DWORD *)(a1 + 24);
            if (v32 == *(_DWORD *)(a1 + 28))
            {
              sub_10008D024(v7, v32 + 1);
              int v32 = *(_DWORD *)(a1 + 24);
            }

            uint64_t v33 = *(void *)v124;
            uint64_t v34 = *(void *)(a1 + 16);
            *(_DWORD *)(a1 + 24) = v32 + 1;
            *(void *)(v34 + 8LL * v32) = v33;
          }

          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v30);
          goto LABEL_66;
        }

uint64_t sub_100F542D0( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if ((*(_BYTE *)(result + 212) & 1) != 0)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A4088 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v6,  a2,  a4);
  }

  if (*(int *)(v5 + 24) >= 1)
  {
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, 0x12u);
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, *(_DWORD *)(v5 + 32));
    if (*(int *)(v5 + 24) >= 1)
    {
      uint64_t v7 = 0LL;
      do
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint64( a2,  *(void *)(*(void *)(v5 + 16) + 8 * v7++));
      while (v7 < *(int *)(v5 + 24));
    }
  }

  if (*(int *)(v5 + 48) > 0)
  {
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, 0x1Au);
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, *(_DWORD *)(v5 + 56));
    if (*(int *)(v5 + 48) >= 1)
    {
      uint64_t v8 = 0LL;
      do
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32( a2,  *(_DWORD *)(*(void *)(v5 + 40) + 4 * v8++));
      while (v8 < *(int *)(v5 + 48));
    }
  }

  if (*(int *)(v5 + 72) > 0)
  {
    wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, 0x22u);
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32(a2, *(_DWORD *)(v5 + 80));
    if (*(int *)(v5 + 72) >= 1)
    {
      uint64_t v9 = 0LL;
      do
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::WriteVarint32( a2,  *(_DWORD *)(*(void *)(v5 + 64) + 4 * v9++));
      while (v9 < *(int *)(v5 + 72));
    }
  }

  if (*(int *)(v5 + 96) >= 1)
  {
    uint64_t v10 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5,  *(void *)(*(void *)(v5 + 88) + 8 * v10++),  a2,  a4);
    while (v10 < *(int *)(v5 + 96));
  }

  if (*(int *)(v5 + 120) >= 1)
  {
    uint64_t v11 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6,  *(void *)(*(void *)(v5 + 112) + 8 * v11++),  a2,  a4);
    while (v11 < *(int *)(v5 + 120));
  }

  if (*(int *)(v5 + 144) >= 1)
  {
    uint64_t v12 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7,  *(void *)(*(void *)(v5 + 136) + 8 * v12++),  a2,  a4);
    while (v12 < *(int *)(v5 + 144));
  }

  if (*(int *)(v5 + 168) >= 1)
  {
    uint64_t v13 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8,  *(void *)(*(void *)(v5 + 160) + 8 * v13++),  a2,  a4);
    while (v13 < *(int *)(v5 + 168));
  }

  if (*(int *)(v5 + 192) >= 1)
  {
    uint64_t v14 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9,  *(void *)(*(void *)(v5 + 184) + 8 * v14++),  a2,  a4);
    while (v14 < *(int *)(v5 + 192));
  }

  return result;
}

uint64_t sub_100F54520(uint64_t a1, unint64_t a2)
{
  if ((*(_BYTE *)(a1 + 212) & 1) != 0)
  {
    uint64_t v4 = *(unsigned int **)(a1 + 8);
    if (!v4) {
      uint64_t v4 = *(unsigned int **)(qword_1019A4088 + 8);
    }
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F5248C(v4, a2);
    int v6 = (int)v5;
    else {
      int v7 = 1;
    }
    int v3 = v6 + v7 + 1;
  }

  else
  {
    int v3 = 0;
  }

  if (*(int *)(a1 + 24) < 1)
  {
    LODWORD(v9) = 0;
  }

  else
  {
    uint64_t v8 = 0LL;
    LODWORD(v9) = 0;
    do
      uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(*(void *)(a1 + 16) + 8 * v8++),  a2)
                                                                           + v9);
    while (v8 < *(int *)(a1 + 24));
    if ((int)v9 > 0)
    {
      else {
        int v10 = 1;
      }
      v3 += v10 + 1;
    }
  }

  *(_DWORD *)(a1 + 32) = (_DWORD)v9;
  int v11 = v3 + (_DWORD)v9;
  int v12 = *(_DWORD *)(a1 + 48);
  if (v12 < 1)
  {
    LODWORD(v14) = 0;
  }

  else
  {
    uint64_t v13 = 0LL;
    LODWORD(v14) = 0;
    do
    {
      if (v15 >= 0x80)
      {
        int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15, a2);
        int v12 = *(_DWORD *)(a1 + 48);
      }

      else
      {
        int v16 = 1;
      }

      uint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v16 + (_DWORD)v14);
      ++v13;
    }

    while (v13 < v12);
    if ((int)v14 > 0)
    {
      else {
        int v17 = 1;
      }
      v11 += v17 + 1;
    }
  }

  *(_DWORD *)(a1 + 56) = (_DWORD)v14;
  int v18 = v11 + (_DWORD)v14;
  int v19 = *(_DWORD *)(a1 + 72);
  if (v19 < 1)
  {
    LODWORD(v21) = 0;
  }

  else
  {
    uint64_t v20 = 0LL;
    LODWORD(v21) = 0;
    do
    {
      if (v22 >= 0x80)
      {
        int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, a2);
        int v19 = *(_DWORD *)(a1 + 72);
      }

      else
      {
        int v23 = 1;
      }

      int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v23 + (_DWORD)v21);
      ++v20;
    }

    while (v20 < v19);
    if ((int)v21 > 0)
    {
      else {
        int v24 = 2;
      }
      v18 += v24;
    }
  }

  *(_DWORD *)(a1 + 80) = (_DWORD)v21;
  int v25 = *(_DWORD *)(a1 + 96);
  int v26 = v18 + (_DWORD)v21 + v25;
  if (v25 >= 1)
  {
    uint64_t v27 = 0LL;
    do
    {
      uint64_t v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F53474( *(void *)(*(void *)(a1 + 88) + 8 * v27),  a2);
      int v29 = (int)v28;
      else {
        int v30 = 1;
      }
      v26 += v29 + v30;
      ++v27;
    }

    while (v27 < *(int *)(a1 + 96));
  }

  int v31 = *(_DWORD *)(a1 + 120);
  int v32 = v31 + v26;
  if (v31 >= 1)
  {
    uint64_t v33 = 0LL;
    do
    {
      uint64_t v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F52DE4( *(void *)(*(void *)(a1 + 112)
                                                                                         + 8 * v33),
                                                                               a2);
      int v35 = (int)v34;
      else {
        int v36 = 1;
      }
      v32 += v35 + v36;
      ++v33;
    }

    while (v33 < *(int *)(a1 + 120));
  }

  int v37 = *(_DWORD *)(a1 + 144);
  int v38 = v37 + v32;
  if (v37 >= 1)
  {
    uint64_t v39 = 0LL;
    do
    {
      unsigned int v40 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F52DE4( *(void *)(*(void *)(a1 + 136)
                                                                                         + 8 * v39),
                                                                               a2);
      int v41 = (int)v40;
      else {
        int v42 = 1;
      }
      v38 += v41 + v42;
      ++v39;
    }

    while (v39 < *(int *)(a1 + 144));
  }

  int v43 = *(_DWORD *)(a1 + 168);
  int v44 = v43 + v38;
  if (v43 >= 1)
  {
    uint64_t v45 = 0LL;
    do
    {
      int v46 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F52DE4( *(void *)(*(void *)(a1 + 160)
                                                                                         + 8 * v45),
                                                                               a2);
      int v47 = (int)v46;
      else {
        int v48 = 1;
      }
      v44 += v47 + v48;
      ++v45;
    }

    while (v45 < *(int *)(a1 + 168));
  }

  int v49 = *(_DWORD *)(a1 + 192);
  uint64_t v50 = (v49 + v44);
  if (v49 >= 1)
  {
    uint64_t v51 = 0LL;
    do
    {
      uint64_t v52 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100F52DE4( *(void *)(*(void *)(a1 + 184)
                                                                                         + 8 * v51),
                                                                               a2);
      int v53 = (int)v52;
      else {
        int v54 = 1;
      }
      uint64_t v50 = (v53 + v50 + v54);
      ++v51;
    }

    while (v51 < *(int *)(a1 + 192));
  }

  *(_DWORD *)(a1 + 208) = v50;
  return v50;
}

void sub_100F548A0(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100F548EC()
{
  return 1LL;
}

void *sub_100F548F4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RayTracingTileData.RayTracingTilePayload");
}

uint64_t sub_100F54904(uint64_t a1)
{
  return *(unsigned int *)(a1 + 208);
}

void sub_100F55110( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

void sub_100F55148(id a1)
{
  uint64_t v2 = v1;
  objc_opt_class(&OBJC_CLASS___CLEEDMitigation);
  uint64_t v4 = v3;
  objc_opt_class(&OBJC_CLASS___CLEEDUploadServiceConfig);
  uint64_t v6 = v5;
  objc_opt_class(&OBJC_CLASS___NSArray);
  uint64_t v8 = v7;
  *(void *)&double v9 = objc_opt_class(&OBJC_CLASS___NSSet).n128_u64[0];
  int v11 = +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v2, v9, v4, v6, v8, v10, 0LL);
  qword_10199F6A0 =  +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___CLEEDMediaServiceProtocol);
  [(id)qword_10199F6A0 setClasses:v11 forSelector:"processMediaServicesForRequestID:callUUID:uploadURL:sharedInfoPrefix:combinedSecret:token:mediaList:mitigation:completion:" argumentIndex:6 ofReply:0];
  [(id)qword_10199F6A0 setClasses:v11 forSelector:"processMediaServicesMitigations:" argumentIndex:0 ofReply:0];
  [(id)qword_10199F6A0 setClasses:v11 forSelector:"connectToMediaService:uploadConfig:" argumentIndex:0 ofReply:0];
  qword_10199F6A8 =  +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___CLEEDMediaServiceDelegate);
}

void sub_100F55270(id a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10188E198);
  }
  uint64_t v1 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v10 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke_2";
    __int16 v11 = 2114;
    int v12 = +[NSXPCConnection currentConnection](&OBJC_CLASS___NSXPCConnection, "currentConnection");
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#EED2FWK,%{public}s, Connection[%{public}@] invalidated",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10188E198);
    }
    uint64_t v2 = qword_101934898;
    int v5 = 136446466;
    uint64_t v6 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke";
    __int16 v7 = 2114;
    uint64_t v8 = +[NSXPCConnection currentConnection](&OBJC_CLASS___NSXPCConnection, "currentConnection");
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v2,  0LL,  "#EED2FWK,%{public}s, Connection[%{public}@] invalidated",  &v5,  22);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

void sub_100F5544C(uint64_t a1)
{
  Weak = objc_loadWeak((id *)(a1 + 40));
  if (Weak)
  {
    uint64_t v3 = Weak;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10188E198);
    }
    uint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      int v18 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke_2";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#EED2FWK,%{public}s, Connection interrupted",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10188E198);
      }
      int v15 = 136446210;
      int v16 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2FWK,%{public}s, Connection interrupted",  &v15,  12);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 32LL) + 16LL))();
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40LL) + 16LL))();
    __int16 v7 = (void *)v3[6];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_100F557D4;
    v14[3] = &unk_101830628;
    v14[4] = v3;
    objc_msgSend( objc_msgSend(v7, "remoteObjectProxyWithErrorHandler:", v14),  "connectToMediaService:uploadConfig:",  v5,  v6);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10188E198);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      int v18 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2FWK,%{public}s, reconnecting to EEDMediaService",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10188E198);
      }
      int v15 = 136446210;
      int v16 = "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke";
      LODWORD(v13) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2FWK,%{public}s, reconnecting to EEDMediaService",  &v15,  v13);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLEEDMediaServiceHandler connectToMediaService]_block_invoke",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

id sub_100F557D4(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( *(id *)(a1 + 32),  "handleRemoteProxyError:forProcessIdentifier:",  a2,  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "processIdentifier"));
}

id sub_100F55808(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( *(id *)(a1 + 32),  "handleRemoteProxyError:forProcessIdentifier:",  a2,  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "processIdentifier"));
}

id sub_100F56138(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( *(id *)(a1 + 32),  "handleRemoteProxyError:forProcessIdentifier:",  a2,  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "processIdentifier"));
}

uint64_t sub_100F5616C(uint64_t a1, uint64_t a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10188E198);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v13 = "-[CLEEDMediaServiceHandler processMediaForRequestID:callUUID:uploadURL:sharedInfoPrefix:combinedSecret:token:m"
          "ediaList:mitigation:completion:]_block_invoke_2";
    __int16 v14 = 2114;
    uint64_t v15 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EED2FWK,%{public}s, CompletionBlock, error:%{public}@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10188E198);
    }
    int v8 = 136446466;
    double v9 = "-[CLEEDMediaServiceHandler processMediaForRequestID:callUUID:uploadURL:sharedInfoPrefix:combinedSecret:token:me"
         "diaList:mitigation:completion:]_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2FWK,%{public}s, CompletionBlock, error:%{public}@",  &v8,  22);
    __int16 v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLEEDMediaServiceHandler processMediaForRequestID:callUUID:uploadURL:sharedInfoPrefix:combinedSecret:token:media List:mitigation:completion:]_block_invoke",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

id sub_100F56880(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( *(id *)(a1 + 32),  "handleRemoteProxyError:forProcessIdentifier:",  a2,  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "processIdentifier"));
}

id sub_100F56C04(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( *(id *)(a1 + 32),  "handleRemoteProxyError:forProcessIdentifier:",  a2,  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "processIdentifier"));
}

void sub_100F56C38(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

uint64_t sub_100F56C64(uint64_t a1)
{
  *(void *)(a1 + 1856) = 0LL;
  *(void *)(a1 + 1888) = 0LL;
  sub_10040A1C4(a1 + 912);
  sub_10040B314(a1 + 912, (uint64_t)sub_100F56D84, a1);
  *(void *)(a1 + 1824) = 0LL;
  *(void *)(a1 + 1832) = 0LL;
  *(_BYTE *)(a1 + 1848) = 0;
  *(void *)(a1 + 1840) = 0LL;
  sub_1007951AC((uint64_t *)(a1 + 1776), a1 + 1824);
  sub_100808B24((_DWORD *)a1, 0x2710u);
  sub_10040B320(a1 + 912, 0);
  return a1;
}

void sub_100F56D14(_Unwind_Exception *exception_object)
{
  *uint64_t v2 = &off_101837718;
  void *v1 = &off_101858AA8;
  _Unwind_Resume(exception_object);
}

float sub_100F56D84(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 468)) {
    return sub_1008093D4(a4, a1, a2);
  }
  return result;
}

void *sub_100F56DA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float result = sub_100F56DD0((void *)(a1 + 1864), a2);
  *(void *)(a1 + 1896) = a3;
  return result;
}

void *sub_100F56DD0(void *a1, uint64_t a2)
{
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_100F56E68(uint64_t a1, float32x2_t *a2, double a3)
{
  unint64_t v4 = (unint64_t)(a3 * 1000000.0);
  unint64_t v9 = v4;
  float v5 = a2[1].f32[0];
  float32x2_t v7 = vmul_f32(*a2, (float32x2_t)vdup_n_s32(0x3C8EFA35u));
  float v8 = v5 * 0.017453;
  uint64_t v6 = *(void *)(a1 + 1856);
  if (v6 && v6 + 1000000 < v4)
  {
    sub_10040A1F4(a1 + 912, v4 - v6);
    sub_1007951AC((uint64_t *)(a1 + 1776), a1 + 1824);
  }

  *(void *)(a1 + 1856) = v4;
  sub_100795364(a1 + 1776, 29.0);
  sub_10040A7B0(a1 + 912, (uint64_t)&v7, &v9);
  sub_100B0DC48(a1 + 824, &v7, v9);
  sub_1008090E8(a1, &v7, v9);
  if (*(_BYTE *)(a1 + 1656)) {
    sub_100F56F50((void *)a1, v9);
  }
}

void *sub_100F56F50(void *result, unint64_t a2)
{
  if (result[236])
  {
    uint64_t v2 = result[237];
    if (v2)
    {
      double v3 = (double)a2 / 1000000.0;
      uint64_t v4 = (uint64_t)(result + 233);
      uint64_t v5 = (uint64_t)result + 836;
      uint64_t v6 = result[110] + 432LL;
      sub_100B0D900((uint64_t)(result + 103));
      v10[0] = v7;
      v10[1] = v8;
      _DWORD v10[2] = v9;
      return (void *)sub_100F57058(v4, v2, v5, v6, (uint64_t)v10, v3);
    }
  }

  return result;
}

uint64_t sub_100F56FE0(float32x2_t *a1, float32x2_t *a2, double a3)
{
  uint64_t v8 = (unint64_t)(a3 * 1000000.0);
  __int32 v4 = a2[1].i32[0];
  float32x2_t v6 = *a2;
  __int32 v7 = v4;
  sub_10040A77C((uint64_t)&a1[114], (uint64_t)&v6);
  sub_100808D7C((uint64_t)a1, &v6, v8);
  return sub_100B0E16C(a1 + 103, (uint64_t)&v6, v8);
}

uint64_t sub_100F57058(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v9 = a2;
  double v8 = a6;
  uint64_t v6 = *(void *)(a1 + 24);
  if (!v6) {
    sub_100008BDC();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, double *))(*(void *)v6 + 48LL))( v6,  &v9,  a3,  a4,  a5,  &v8);
}

void *sub_100F57098(void *result, void *a2)
{
  if (a2 != result)
  {
    double v3 = result;
    __int32 v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        float result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        float result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      float result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_100F57200(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_100F5720C(uint64_t a1, __int128 *a2, int a3)
{
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = a3;
  __int128 v4 = *a2;
  *(_OWORD *)(a1 + 28) = a2[1];
  *(_OWORD *)(a1 + 12) = v4;
  *(void *)&__int128 v4 = -1LL;
  *((void *)&v4 + 1) = -1LL;
  *(_OWORD *)(a1 + 44) = v4;
  *(_OWORD *)(a1 + 60) = v4;
  sub_100313598(a1 + 80);
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  if (v5 > 7 || ((1 << v5) & 0x87) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188E1B8);
    }
    __int32 v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_100F57510((unsigned int *)a1, __p);
      double v8 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? __p
         : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "bad RAT for GSM: %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188E1B8);
      }
      uint64_t v9 = qword_101934A78;
      sub_100F57510((unsigned int *)a1, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::stringbuf::string_type buf = &buf;
      }
      else {
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      uint64_t v15 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "bad RAT for GSM: %{public}s",  &v14,  12);
      int v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCell::CLCell(const CLTelephonyService_Type::Cell &, CLTelephonyService_Type::RadioAccessTechnology)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }

    *(_BYTE *)a1 = 0;
  }

  return a1;
}

void sub_100F574F0(_Unwind_Exception *a1)
{
}

uint64_t sub_100F57510@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v25, (uint64_t)"Cell, RAT, ", 11LL);
  unsigned int v5 = (void *)std::ostream::operator<<(v4, a1[2]);
  uint64_t v6 = sub_10000CF44(v5, (uint64_t)", ", 2LL);
  __int32 v7 = sub_1003D32AC(a1[2]);
  size_t v8 = strlen(v7);
  uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
  __int16 v10 = sub_10000CF44(v9, (uint64_t)", valid , ", 10LL);
  uint64_t v11 = (void *)std::ostream::operator<<(v10, *(unsigned __int8 *)a1);
  int v12 = sub_10000CF44(v11, (uint64_t)", cellType , ", 13LL);
  uint64_t v13 = sub_1003D0400(a1[1]);
  size_t v14 = strlen(v13);
  sub_10000CF44(v12, (uint64_t)v13, v14);
  unsigned int v15 = a1[2];
  if (v15 < 3)
  {
LABEL_4:
    int v16 = sub_10000CF44(&v25, (uint64_t)", ", 2LL);
    sub_1003D1A48(a1 + 3, &__p);
    if ((v23 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v23 & 0x80u) == 0) {
      uint64_t v18 = v23;
    }
    else {
      uint64_t v18 = v22;
    }
    goto LABEL_37;
  }

  if (v15 == 9)
  {
    int v16 = sub_10000CF44(&v25, (uint64_t)", ", 2LL);
    sub_1003D1A48(a1 + 11, &__p);
    if ((v23 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v23 & 0x80u) == 0) {
      uint64_t v18 = v23;
    }
    else {
      uint64_t v18 = v22;
    }
  }

  else
  {
    if (v15 == 7) {
      goto LABEL_4;
    }
    if (v15 - 3 > 2)
    {
      if (v15 == 10)
      {
        int v16 = sub_10000CF44(&v25, (uint64_t)", ", 2LL);
        sub_1003D2C58(a1 + 150, &__p);
        if ((v23 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if ((v23 & 0x80u) == 0) {
          uint64_t v18 = v23;
        }
        else {
          uint64_t v18 = v22;
        }
      }

      else
      {
        if (v15 != 6)
        {
          sub_10000CF44(&v25, (uint64_t)", Unknow / Invalid Cell", 23LL);
          goto LABEL_39;
        }

        int v16 = sub_10000CF44(&v25, (uint64_t)", ", 2LL);
        sub_1003D2324(a1 + 128, &__p);
        if ((v23 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if ((v23 & 0x80u) == 0) {
          uint64_t v18 = v23;
        }
        else {
          uint64_t v18 = v22;
        }
      }
    }

    else
    {
      int v16 = sub_10000CF44(&v25, (uint64_t)", ", 2LL);
      sub_1003D13B8(a1 + 20, &__p);
      if ((v23 & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if ((v23 & 0x80u) == 0) {
        uint64_t v18 = v23;
      }
      else {
        uint64_t v18 = v22;
      }
    }
  }

void sub_100F57838( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100F5788C(uint64_t a1, __int128 *a2, int a3)
{
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)&__int128 v4 = -1LL;
  *((void *)&v4 + 1) = -1LL;
  *(_OWORD *)(a1 + 12) = v4;
  *(_OWORD *)(a1 + 28) = v4;
  __int128 v5 = *a2;
  *(_OWORD *)(a1 + 60) = a2[1];
  *(_OWORD *)(a1 + 44) = v5;
  sub_100313598(a1 + 80);
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  if (*(_DWORD *)(a1 + 8) != 9)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188E1B8);
    }
    uint64_t v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_100F57510((unsigned int *)a1, __p);
      __int32 v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? __p
         : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "bad RAT for SCDMA: %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188E1B8);
      }
      uint64_t v9 = qword_101934A78;
      sub_100F57510((unsigned int *)a1, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::stringbuf::string_type buf = &buf;
      }
      else {
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      unsigned int v15 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "bad RAT for SCDMA: %{public}s",  &v14,  12);
      int v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCell::CLCell(const CLTelephonyService_Type::ScdmaCell &, CLTelephonyService_Type::RadioAccessTechnology)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }

    *(_BYTE *)a1 = 0;
  }

  return a1;
}

void sub_100F57B5C(_Unwind_Exception *a1)
{
}

uint64_t sub_100F57B80(uint64_t a1, uint64_t a2, int a3)
{
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 224);
  *(void *)&__int128 v6 = -1LL;
  *((void *)&v6 + 1) = -1LL;
  *(_OWORD *)(a1 + 60) = v6;
  *(_OWORD *)(a1 + 44) = v6;
  *(_OWORD *)(a1 + 28) = v6;
  *(_OWORD *)(a1 + 12) = v6;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)a2;
  uint64_t v7 = a1 + 80;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  sub_10001B72C( (void *)(a1 + 88),  *(const void **)(a2 + 8),  *(void *)(a2 + 16),  (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 32);
  __int128 v8 = *(_OWORD *)(a2 + 48);
  __int128 v9 = *(_OWORD *)(a2 + 64);
  __int128 v10 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 128) = v8;
  *(_OWORD *)(a1 + 144) = v9;
  __int128 v11 = *(_OWORD *)(a2 + 112);
  __int128 v12 = *(_OWORD *)(a2 + 128);
  __int128 v13 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 240) = v13;
  *(_OWORD *)(a1 + 192) = v11;
  *(_OWORD *)(a1 + 208) = v12;
  __int128 v14 = *(_OWORD *)(a2 + 176);
  __int128 v15 = *(_OWORD *)(a2 + 192);
  __int128 v16 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(v7 + 220) = *(_OWORD *)(a2 + 220);
  *(_OWORD *)(a1 + 272) = v15;
  *(_OWORD *)(a1 + 288) = v16;
  *(_OWORD *)(a1 + 256) = v14;
  int v17 = (_BYTE *)(a1 + 320);
  if (*(char *)(a2 + 263) < 0)
  {
    sub_1010DD48C(v17, *(void **)(a2 + 240), *(void *)(a2 + 248));
  }

  else
  {
    __int128 v18 = *(_OWORD *)(a2 + 240);
    *(void *)(a1 + 336) = *(void *)(a2 + 256);
    *(_OWORD *)int v17 = v18;
  }

  __int128 v19 = *(_OWORD *)(a2 + 264);
  __int128 v20 = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 360) = *(_OWORD *)(a2 + 280);
  *(_OWORD *)(a1 + 376) = v20;
  *(_OWORD *)(a1 + 344) = v19;
  __int128 v21 = *(_OWORD *)(a2 + 312);
  __int128 v22 = *(_OWORD *)(a2 + 328);
  __int128 v23 = *(_OWORD *)(a2 + 360);
  *(_OWORD *)(a1 + 424) = *(_OWORD *)(a2 + 344);
  *(_OWORD *)(a1 + 440) = v23;
  *(_OWORD *)(a1 + 392) = v21;
  *(_OWORD *)(a1 + 408) = v22;
  __int128 v24 = *(_OWORD *)(a2 + 376);
  __int128 v25 = *(_OWORD *)(a2 + 392);
  __int128 v26 = *(_OWORD *)(a2 + 408);
  *(_DWORD *)(a1 + 504) = *(_DWORD *)(a2 + 424);
  *(_OWORD *)(a1 + 472) = v25;
  *(_OWORD *)(a1 + 488) = v26;
  *(_OWORD *)(a1 + 456) = v24;
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  int v27 = *(_DWORD *)(a2 + 224);
  if (v27 < 0 || v27 == 11)
  {
    *(_DWORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 304) = a3;
  }

  else
  {
    a3 = *(_DWORD *)(a1 + 8);
  }

  if ((a3 - 3) >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188E1B8);
    }
    uint64_t v28 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_100F57510((unsigned int *)a1, __p);
      int v29 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? __p
          : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "bad RAT for CDMA: %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188E1B8);
      }
      uint64_t v31 = qword_101934A78;
      sub_100F57510((unsigned int *)a1, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::stringbuf::string_type buf = &buf;
      }
      else {
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      int v36 = 136446210;
      int v37 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v31,  17LL,  "bad RAT for CDMA: %{public}s",  &v36,  12);
      uint64_t v34 = v33;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCell::CLCell(const CLTelephonyService_Type::CdmaCell &, CLTelephonyService_Type::RadioAccessTechnology)",  "%s\n",  (const char *)v34);
      if (v34 != __p) {
        free(v34);
      }
    }
  }

  return a1;
}

void sub_100F57F48(_Unwind_Exception *a1)
{
}

uint64_t sub_100F57F84(uint64_t a1, uint64_t a2, int a3)
{
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)&__int128 v5 = -1LL;
  *((void *)&v5 + 1) = -1LL;
  *(_OWORD *)(a1 + 12) = v5;
  *(_OWORD *)(a1 + 28) = v5;
  *(_OWORD *)(a1 + 44) = v5;
  *(_OWORD *)(a1 + 60) = v5;
  sub_100313598(a1 + 80);
  __int128 v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 512) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 528) = v6;
  __int128 v7 = *(_OWORD *)(a2 + 32);
  __int128 v8 = *(_OWORD *)(a2 + 48);
  __int128 v9 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 592) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 560) = v8;
  *(_OWORD *)(a1 + 576) = v9;
  *(_OWORD *)(a1 + 544) = v7;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  if (*(_DWORD *)(a1 + 8) != 6)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188E1B8);
    }
    __int128 v10 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_100F57510((unsigned int *)a1, __p);
      __int128 v11 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? __p
          : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "bad RAT for LTE: %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188E1B8);
      }
      uint64_t v13 = qword_101934A78;
      sub_100F57510((unsigned int *)a1, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::stringbuf::string_type buf = &buf;
      }
      else {
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      int v18 = 136446210;
      __int128 v19 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v13,  17LL,  "bad RAT for LTE: %{public}s",  &v18,  12);
      __int128 v16 = v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCell::CLCell(const CLTelephonyService_Type::LteCell &, CLTelephonyService_Type::RadioAccessTechnology)",  "%s\n",  (const char *)v16);
      if (v16 != __p) {
        free(v16);
      }
    }

    *(_BYTE *)a1 = 0;
  }

  return a1;
}

void sub_100F58240(_Unwind_Exception *a1)
{
}

uint64_t sub_100F58264(uint64_t a1, _OWORD *a2, int a3)
{
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)&__int128 v5 = -1LL;
  *((void *)&v5 + 1) = -1LL;
  *(_OWORD *)(a1 + 12) = v5;
  *(_OWORD *)(a1 + 28) = v5;
  *(_OWORD *)(a1 + 44) = v5;
  *(_OWORD *)(a1 + 60) = v5;
  sub_100313598(a1 + 80);
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  __int128 v6 = a2[1];
  *(_OWORD *)(a1 + 600) = *a2;
  *(_OWORD *)(a1 + 616) = v6;
  __int128 v7 = a2[2];
  __int128 v8 = a2[3];
  __int128 v9 = a2[5];
  *(_OWORD *)(a1 + 664) = a2[4];
  *(_OWORD *)(a1 + 680) = v9;
  *(_OWORD *)(a1 + 632) = v7;
  *(_OWORD *)(a1 + 648) = v8;
  if (*(_DWORD *)(a1 + 8) != 10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188E1B8);
    }
    __int128 v10 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_100F57510((unsigned int *)a1, __p);
      __int128 v11 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? __p
          : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "bad RAT for NR: %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188E1B8);
      }
      uint64_t v13 = qword_101934A78;
      sub_100F57510((unsigned int *)a1, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::stringbuf::string_type buf = &buf;
      }
      else {
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      int v18 = 136446210;
      __int128 v19 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v13,  17LL,  "bad RAT for NR: %{public}s",  &v18,  12);
      __int128 v16 = v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCell::CLCell(const CLTelephonyService_Type::NrCell &, CLTelephonyService_Type::RadioAccessTechnology)",  "%s\n",  (const char *)v16);
      if (v16 != __p) {
        free(v16);
      }
    }

    *(_BYTE *)a1 = 0;
  }

  return a1;
}

void sub_100F58514(_Unwind_Exception *a1)
{
}

uint64_t sub_100F58538(uint64_t a1)
{
  *(_BYTE *)a1 = 0;
  *(void *)(a1 + 4) = 0xB00000003LL;
  *(void *)&__int128 v2 = -1LL;
  *((void *)&v2 + 1) = -1LL;
  *(_OWORD *)(a1 + 12) = v2;
  *(_OWORD *)(a1 + 28) = v2;
  *(_OWORD *)(a1 + 44) = v2;
  *(_OWORD *)(a1 + 60) = v2;
  sub_100313598(a1 + 80);
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  return a1;
}

uint64_t sub_100F585FC(uint64_t a1, CFDictionaryRef *a2)
{
  *(_BYTE *)a1 = 0;
  *(void *)(a1 + 4) = 0xB00000003LL;
  *(void *)&__int128 v4 = -1LL;
  *((void *)&v4 + 1) = -1LL;
  *(_OWORD *)(a1 + 12) = v4;
  __int128 v5 = (_DWORD *)(a1 + 12);
  *(_OWORD *)(a1 + 44) = v4;
  __int128 v6 = (_DWORD *)(a1 + 44);
  uint64_t v7 = a1 + 80;
  *(_OWORD *)(a1 + 28) = v4;
  *(_OWORD *)(a1 + 60) = v4;
  sub_100313598(a1 + 80);
  *(_DWORD *)(a1 + 536) = -1;
  *(void *)(a1 + 528) = -1LL;
  *(void *)(a1 + 520) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 560) = -1LL;
  *(void *)(a1 + 568) = -1LL;
  *(_DWORD *)(a1 + 576) = -1;
  *(_OWORD *)(a1 + 580) = xmmword_1012E6420;
  *(void *)(a1 + 600) = -1LL;
  *(_DWORD *)(a1 + 608) = -1;
  *(void *)(a1 + 616) = -1LL;
  *(void *)(a1 + 624) = -1LL;
  *(_DWORD *)(a1 + 632) = -1;
  *(void *)(a1 + 648) = 0LL;
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 672) = -1LL;
  *(void *)(a1 + 664) = -1LL;
  *(void *)(a1 + 656) = -1LL;
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000LL;
  *(_DWORD *)(a1 + 688) = -1;
  sub_1002A5550((int)v23, *a2);
  CFTypeRef v22 = 0LL;
  int v8 = sub_1002A8874((uint64_t)v23, kCTCellMonitorCellRadioAccessTechnology, &v22);
  if (!v22) {
    int v8 = 0;
  }
  if (v8 == 1) {
    *(_DWORD *)(a1 + 8) = sub_1003D0424(v22);
  }
  CFTypeRef v21 = 0LL;
  int v9 = sub_1002A8874((uint64_t)v23, kCTCellMonitorCellType, &v21);
  if (!v21) {
    int v9 = 0;
  }
  if (v9 == 1) {
    *(_DWORD *)(a1 + 4) = sub_1003D055C(v21);
  }
  int v10 = *(_DWORD *)(a1 + 8);
  if ((v10 - 3) > 2)
  {
    switch(v10)
    {
      case 0:
      case 1:
      case 2:
      case 7:
        BOOL v11 = sub_1003D1640(a2, v5);
        goto LABEL_42;
      case 6:
        BOOL v11 = sub_1003D1C34(a2, a1 + 512);
        goto LABEL_42;
      case 9:
        BOOL v11 = sub_1003D2EA4(a2, v6);
        goto LABEL_42;
      case 10:
        *(_BYTE *)a1 = sub_1003D2558(a2, a1 + 600);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10188E1D8);
        }
        int v18 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "nrCell dictionary received from CT",  (uint8_t *)__p,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_10188E1D8);
          }
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "nrCell dictionary received from CT",  &buf,  2);
          int v17 = (std::stringbuf::string_type *)v19;
          sub_10029211C("Generic", 1LL, 0, 2LL, "CLCell::CLCell(const CFDictionaryRef &)", "%s\n", v19);
          if (v17 != __p) {
            goto LABEL_40;
          }
        }

        break;
      default:
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10188E1B8);
        }
        __int128 v12 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          sub_100F57510((unsigned int *)a1, __p);
          uint64_t v13 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
              ? __p
              : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "CELL_LOC: Invalid cell rat: %{public}s",  (uint8_t *)&buf,  0xCu);
        }

        if (!sub_1002921D0(115, 0)) {
          break;
        }
        bzero(__p, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10188E1B8);
        }
        uint64_t v14 = qword_101934A78;
        sub_100F57510((unsigned int *)a1, &buf);
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_std::stringbuf::string_type buf = &buf;
        }
        else {
          p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        }
        int v25 = 136446210;
        __int128 v26 = p_buf;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v14,  17LL,  "CELL_LOC: Invalid cell rat: %{public}s",  &v25,  12);
        int v17 = v16;
        sub_10029211C("Generic", 1LL, 0, 0LL, "CLCell::CLCell(const CFDictionaryRef &)", "%s\n", (const char *)v17);
        if (v17 == __p) {
          break;
        }
LABEL_40:
        free(v17);
        break;
    }
  }

  else
  {
    BOOL v11 = sub_1003D05D4(a2, v7);
LABEL_42:
    *(_BYTE *)a1 = v11;
  }

  sub_1002A5590(v23);
  return a1;
}

void sub_100F58B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100F58B68@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = *(int *)(a1 + 8);
  if (v4 < 0xA && ((0x287u >> v4) & 1) != 0)
  {
    uint64_t v5 = off_10188E1F8[v4];
    uint64_t v6 = qword_1013B8EC8[v4];
  }

  else if ((v4 - 3) >= 3)
  {
    if ((_DWORD)v4 == 10)
    {
      uint64_t v5 = "NR";
      uint64_t v6 = 2LL;
    }

    else
    {
      if ((_DWORD)v4 == 6)
      {
        int v7 = *(_DWORD *)(a1 + 568);
        if ((v7 & 4) == 0 || v7 < 1) {
          int v9 = "LTE";
        }
        else {
          int v9 = "NSA";
        }
        sub_10000CF44(&v13, (uint64_t)v9, 3LL);
        goto LABEL_18;
      }

      uint64_t v5 = "Unknown";
      uint64_t v6 = 7LL;
    }
  }

  else
  {
    uint64_t v5 = "CDMA";
    uint64_t v6 = 4LL;
  }

  sub_10000CF44(&v13, (uint64_t)v5, v6);
LABEL_18:
  std::stringbuf::str(a2, &v14);
  *(void *)((char *)v12
  uint64_t v13 = v10;
  std::streambuf::~streambuf(&v14);
  return std::ios::~ios(&v15);
}

void sub_100F58CCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F58CE4@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = *(int *)(a1 + 4);
  if (v4 >= 3)
  {
    uint64_t v5 = "Unknown";
    uint64_t v6 = 7LL;
  }

  else
  {
    uint64_t v5 = off_10188E248[v4];
    uint64_t v6 = qword_1013B8F18[v4];
  }

  sub_10000CF44(&v10, (uint64_t)v5, v6);
  std::stringbuf::str(a2, &v11);
  *(void *)((char *)v9
  uint64_t v10 = v7;
  std::streambuf::~streambuf(&v11);
  return std::ios::~ios(&v12);
}

void sub_100F58DCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL sub_100F58DE0(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 3) {
    goto LABEL_6;
  }
  if (v2 == 9)
  {
    if (*(_DWORD *)(a1 + 44) == *(_DWORD *)(a2 + 44)
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 48)
      && *(_DWORD *)(a1 + 52) == *(_DWORD *)(a2 + 52))
    {
      int v3 = *(_DWORD *)(a1 + 56);
      int v4 = *(_DWORD *)(a2 + 56);
      return v3 == v4;
    }

    return 0LL;
  }

  if (v2 == 7)
  {
LABEL_6:
    if (*(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
      && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20))
    {
      int v3 = *(_DWORD *)(a1 + 24);
      int v4 = *(_DWORD *)(a2 + 24);
      return v3 == v4;
    }

    return 0LL;
  }

  if (v2 - 3 <= 2) {
    return sub_1004C20FC(a1 + 80, a2 + 80);
  }
  if (v2 != 10)
  {
    if (v2 == 6
      && *(_DWORD *)(a1 + 512) == *(_DWORD *)(a2 + 512)
      && *(_DWORD *)(a1 + 516) == *(_DWORD *)(a2 + 516)
      && *(_DWORD *)(a1 + 520) == *(_DWORD *)(a2 + 520))
    {
      int v3 = *(_DWORD *)(a1 + 524);
      int v4 = *(_DWORD *)(a2 + 524);
      return v3 == v4;
    }

    return 0LL;
  }

  if (*(_DWORD *)(a1 + 600) != *(_DWORD *)(a2 + 600)
    || *(_DWORD *)(a1 + 604) != *(_DWORD *)(a2 + 604)
    || *(_DWORD *)(a1 + 608) != *(_DWORD *)(a2 + 608))
  {
    return 0LL;
  }

  return *(void *)(a1 + 616) == *(void *)(a2 + 616);
}

BOOL sub_100F58F24(uint64_t a1, uint64_t a2)
{
  return !sub_100F58DE0(a1, a2);
}

void sub_100F58F3C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 < 3) {
    goto LABEL_4;
  }
  if (v6 == 9)
  {
    *(_DWORD *)(a1 + 60) = a2;
    *(_DWORD *)(a1 + 64) = a3;
    *(_DWORD *)(a1 + 68) = a4;
    *(_DWORD *)(a1 + 72) = a5;
  }

  else
  {
    if (v6 == 7)
    {
LABEL_4:
      *(_DWORD *)(a1 + 28) = a2;
      *(_DWORD *)(a1 + 32) = a3;
      *(_DWORD *)(a1 + 36) = a4;
      *(_DWORD *)(a1 + 40) = a5;
      goto LABEL_5;
    }

    if (v6 - 3 > 2)
    {
      if (v6 == 10)
      {
        *(_DWORD *)(a1 + 624) = a2;
        *(_DWORD *)(a1 + 628) = a3;
        *(_DWORD *)(a1 + 656) = a4;
        *(_DWORD *)(a1 + 660) = a5;
        *(_DWORD *)(a1 + 632) = -1;
        *(void *)(a1 + 648) = 0LL;
        *(void *)(a1 + 640) = 0LL;
      }

      else if (v6 == 6)
      {
        *(_DWORD *)(a1 + 528) = a2;
        *(_DWORD *)(a1 + 532) = a3;
        *(_DWORD *)(a1 + 560) = a4;
        *(_DWORD *)(a1 + 564) = a5;
        *(_DWORD *)(a1 + 536) = -1;
        *(void *)(a1 + 552) = 0LL;
        *(void *)(a1 + 544) = 0LL;
      }
    }

    else
    {
      *(void *)(a1 + 128) = -1LL;
      *(_DWORD *)(a1 + 136) = -1;
      *(_DWORD *)(a1 + 140) = a4;
      *(_DWORD *)(a1 + 144) = a5;
    }
  }

void *sub_100F591F4@<X0>(unsigned int *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unsigned int v2 = a1[2];
  if (v2 < 3) {
    goto LABEL_4;
  }
  if (v2 == 9)
  {
    int v3 = a1 + 11;
    return (void *)sub_1003E4C04(v3, a2);
  }

  if (v2 == 7)
  {
LABEL_4:
    int v3 = a1 + 3;
    return (void *)sub_1003E4C04(v3, a2);
  }

  if (v2 - 3 <= 2) {
    return (void *)sub_1003E411C((uint64_t)(a1 + 20), a2);
  }
  if (v2 == 10) {
    return (void *)sub_1003E56CC(a1 + 150, a2);
  }
  if (v2 == 6)
  {
    int v3 = a1 + 128;
    return (void *)sub_1003E4C04(v3, a2);
  }

  return sub_1010DDBC0(a2, "bad-key");
}

void sub_100F59260(uint64_t a1, uint64_t a2)
{
  int v3 = (char *)(a1 + 88);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10188E1B8);
  }
  int v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v6 = *(int **)(a1 + 88);
    uint64_t v5 = *(int **)(a1 + 96);
    unint64_t v7 = (char *)v5 - (char *)v6;
    if (v5 == v6)
    {
      int v8 = -1;
    }

    else
    {
      int v8 = *v6;
      if (v7 >= 5)
      {
        int v9 = v6[1];
LABEL_11:
        *(_DWORD *)std::stringbuf::string_type buf = 67109376;
        int v20 = v8;
        __int16 v21 = 1024;
        int v22 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: set derivedMcc, derivedMcc, %d, %d",  buf,  0xEu);
        goto LABEL_12;
      }
    }

    int v9 = -1;
    goto LABEL_11;
  }

uint64_t sub_100F59490(uint64_t a1)
{
  if (!*(_BYTE *)a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 3) {
    return *(unsigned int *)(a1 + 12);
  }
  if (v1 == 9) {
    return *(unsigned int *)(a1 + 44);
  }
  if (v1 == 7) {
    return *(unsigned int *)(a1 + 12);
  }
  if (v1 - 3 <= 2)
  {
    int v3 = *(unsigned int **)(a1 + 88);
    return 0xFFFFFFFFLL;
  }

  if (v1 != 10)
  {
    if (v1 == 6) {
      return *(unsigned int *)(a1 + 512);
    }
    return 0xFFFFFFFFLL;
  }

  return *(unsigned int *)(a1 + 600);
}

uint64_t sub_100F59508(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 3) {
    goto LABEL_4;
  }
  if (v2 == 9)
  {
    int v3 = *(_DWORD *)(a1 + 44);
    int v4 = *(unsigned __int16 *)(a1 + 48);
  }

  else
  {
    if (v2 == 7)
    {
LABEL_4:
      int v3 = *(_DWORD *)(a1 + 12);
      int v4 = *(unsigned __int16 *)(a1 + 16);
      goto LABEL_25;
    }

    if (v2 - 3 > 2)
    {
      if (v2 == 10)
      {
        int v3 = *(_DWORD *)(a1 + 600);
        int v4 = *(unsigned __int16 *)(a1 + 604);
      }

      else if (v2 == 6)
      {
        int v3 = *(_DWORD *)(a1 + 512);
        int v4 = *(unsigned __int16 *)(a1 + 516);
      }

      else
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10188E1B8);
        }
        unsigned int v6 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          sub_100F57510((unsigned int *)a1, __p);
          unint64_t v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
             ? __p
             : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: which cell is that, %s",  (uint8_t *)&buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10188E1B8);
          }
          uint64_t v13 = qword_101934A78;
          sub_100F57510((unsigned int *)a1, &buf);
          if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_std::stringbuf::string_type buf = &buf;
          }
          else {
            p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
          }
          int v18 = 136315138;
          __int128 v19 = p_buf;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v13,  2LL,  "CELL_LOC: which cell is that, %s",  (const char *)&v18);
          __int128 v16 = v15;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "unsigned long long CLCell::getSecKey() const",  "%s\n",  (const char *)v16);
          if (v16 != __p) {
            free(v16);
          }
        }

        int v4 = 0;
        int v3 = 0;
      }
    }

    else
    {
      uint64_t v5 = *(int **)(a1 + 88);
      else {
        int v3 = *v5;
      }
      int v4 = *(unsigned __int16 *)(a1 + 116);
    }
  }

void sub_100F598F0(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100F5991C(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

uint64_t sub_100F59948(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 166080;
  *(void *)sub_1006AABA8(a1, a2) = &off_10188E270;
  *(_OWORD *)uint64_t v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(void *)(v3 + 80) = 0LL;
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10188E2A8);
  }
  int v4 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "CLSwimOpenWaterSessionSimulator Instantiated",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10188E2A8);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "CLSwimOpenWaterSessionSimulator Instantiated",  v8,  2);
    unint64_t v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSwimOpenWaterSessionSimulator::CLSwimOpenWaterSessionSimulator(CLSwimDataStore *, float)",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  __int128 v19 = xmmword_1013B8FD0;
  __int128 v20 = unk_1013B8FE0;
  __int128 v21 = xmmword_1013B8FF0;
  uint64_t v22 = 0x404E000000000000LL;
  __int128 v15 = xmmword_1013B8F90;
  __int128 v16 = unk_1013B8FA0;
  __int128 v17 = xmmword_1013B8FB0;
  __int128 v18 = unk_1013B8FC0;
  __int128 v11 = xmmword_1013B8F50;
  __int128 v12 = unk_1013B8F60;
  __int128 v13 = xmmword_1013B8F70;
  __int128 v14 = unk_1013B8F80;
  *(_OWORD *)std::stringbuf::string_type buf = xmmword_1013B8F30;
  __int128 v10 = unk_1013B8F40;
  sub_1000C7020((char *)v3, (char *)buf, (uint64_t)&v23, 9uLL);
  sub_100F59BB8(a1, v3);
  return a1;
}

void sub_100F59B74(_Unwind_Exception *exception_object)
{
  int v4 = *(void **)(v2 + 24);
  if (v4)
  {
    *(void *)(v2 + 32) = v4;
    operator delete(v4);
  }

  uint64_t v5 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v5;
    operator delete(v5);
  }

  void *v1 = &off_101849000;
  _Unwind_Resume(exception_object);
}

char *sub_100F59BB8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 166104;
  int v4 = (_OWORD *)(a1 + 166136);
  float result = (char *)(a1 + 166080);
  *int v4 = 0u;
  v4[1] = 0u;
  if (result != (char *)a2) {
    float result = sub_1000C7020( result,  *(char **)a2,  *(void *)(a2 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
  *(void *)(v3 + 24) = 0LL;
  unsigned int v6 = *(char **)a2;
  unint64_t v7 = *(char **)(a2 + 8);
  if (*(char **)a2 != v7)
  {
    int v8 = 0;
    int v9 = 0;
    do
    {
      int v9 = (int)(*((double *)v6 + 2) + (double)v9);
      v8 += *((_DWORD *)v6 + 1);
      v6 += 24;
    }

    while (v6 != v7);
    *(_DWORD *)(v3 + 24) = v8;
    *(_DWORD *)(v3 + 28) = v9;
  }

  *(void *)(v3 + 8) = *(void *)v3;
  return result;
}

uint64_t sub_100F59C64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_10020EBD8(*(void *)(a1 + 8));
  if ((_DWORD)result)
  {
    unint64_t v7 = (char **)(a1 + 166104);
    uint64_t v8 = *(void *)(a1 + 166080);
    if (*(void *)(a1 + 166112) - *(void *)(a1 + 166104) != *(void *)(a1 + 166088) - v8)
    {
      uint64_t v9 = *(void *)(a1 + 166160);
      __int128 v10 = (__int128 *)(v8 + 24 * v9);
      int v11 = *((_DWORD *)v10 + 1);
      if (v11 <= 0)
      {
        uint64_t v19 = v8 + 24 * v9;
        double v20 = *(double *)(v19 + 16);
        __int128 v13 = (double *)(v19 + 16);
        double v17 = v20 / *(v13 - 1);
      }

      else
      {
        uint64_t v12 = v8 + 24 * v9;
        double v14 = *(double *)(v12 + 16);
        __int128 v13 = (double *)(v12 + 16);
        double v15 = *(v13 - 1);
        double v16 = v15 / (double)v11;
        double v17 = v14 / v15;
        if (v16 > 0.0)
        {
          double v18 = *(double *)(a2 + 56);
          if (vabdd_f64(v18, *(double *)(a1 + 166144)) > v16)
          {
            sub_10020D6B8(*(void *)(a1 + 8), *(_DWORD *)v10, 1, v18);
            *(void *)(a1 + 166144) = *(void *)(a2 + 56);
          }
        }
      }

      if (vabdd_f64(*(double *)(a2 + 56), *(double *)(a1 + 166152)) >= 1.0)
      {
        sub_10020FB78(*(void *)(a1 + 8), v17);
        double v21 = v17 + *(double *)(a1 + 166136);
        *(double *)(a1 + 166136) = v21;
        *(void *)(a1 + 166152) = *(void *)(a2 + 56);
        if (v21 >= *v13)
        {
          unint64_t v22 = *(void *)(a1 + 166120);
          unint64_t v23 = *(void *)(a1 + 166112);
          if (v23 >= v22)
          {
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)*v7) >> 3);
            unint64_t v27 = v26 + 1;
            if (v26 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_100007008();
            }
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (void)*v7) >> 3);
            if (2 * v28 > v27) {
              unint64_t v27 = 2 * v28;
            }
            if (v28 >= 0x555555555555555LL) {
              unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v29 = v27;
            }
            if (v29) {
              int v30 = (char *)sub_10000701C(a1 + 166120, v29);
            }
            else {
              int v30 = 0LL;
            }
            uint64_t v31 = &v30[24 * v26];
            int v32 = &v30[24 * v29];
            __int128 v33 = *v10;
            *((void *)v31 + 2) = *((void *)v10 + 2);
            *(_OWORD *)uint64_t v31 = v33;
            int v25 = v31 + 24;
            int v35 = *(char **)(a1 + 166104);
            uint64_t v34 = *(char **)(a1 + 166112);
            if (v34 != v35)
            {
              do
              {
                __int128 v36 = *(_OWORD *)(v34 - 24);
                *((void *)v31 - 1) = *((void *)v34 - 1);
                *(_OWORD *)(v31 - 24) = v36;
                v31 -= 24;
                v34 -= 24;
              }

              while (v34 != v35);
              uint64_t v34 = *v7;
            }

            *(void *)(a1 + 166104) = v31;
            *(void *)(a1 + 166112) = v25;
            *(void *)(a1 + 166120) = v32;
            if (v34) {
              operator delete(v34);
            }
          }

          else
          {
            __int128 v24 = *v10;
            *(void *)(v23 + 16) = *((void *)v10 + 2);
            *(_OWORD *)unint64_t v23 = v24;
            int v25 = (char *)(v23 + 24);
          }

          *(void *)(a1 + 166112) = v25;
          ++*(void *)(a1 + 166160);
          *(void *)(a1 + 166136) = 0LL;
        }
      }
    }

    sub_10020FB80(*(void *)(a1 + 8), *(double *)(a2 + 64), *(double *)(a2 + 56));
    if (vabdd_f64(*(double *)(a2 + 56), *(double *)(a1 + 720)) <= 2.56)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = sub_1006AC0F4(a1, a3);
      if ((_DWORD)result)
      {
        *(void *)(a1 + 720) = *(void *)(a2 + 56);
        return 1LL;
      }
    }
  }

  return result;
}

void *sub_100F59EFC(void *a1)
{
  uint64_t v2 = (void **)(a1 + 20760);
  *a1 = &off_10188E270;
  uint64_t v3 = (void *)a1[20763];
  if (v3)
  {
    v2[4] = v3;
    operator delete(v3);
  }

  int v4 = *v2;
  if (*v2)
  {
    v2[1] = v4;
    operator delete(v4);
  }

  *a1 = &off_101849000;
  return a1;
}

void sub_100F59F60(char *__p)
{
  uint64_t v2 = __p + 166080;
  *(void *)std::string __p = &off_10188E270;
  uint64_t v3 = (void *)*((void *)__p + 20763);
  if (v3)
  {
    *((void *)v2 + 4) = v3;
    operator delete(v3);
  }

  int v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *((void *)v2 + 1) = v4;
    operator delete(v4);
  }

  operator delete(__p);
}

void sub_100F59FB4(id a1)
{
  qword_1019344E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Swimming");
}

double sub_100F59FE0(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  if (*(double *)&qword_101992B60 == 1.79769313e308 || result - *(double *)&qword_101992B60 >= 0.850000024)
  {
    qword_101992B60 = *(void *)(a1 + 8);
    if (qword_10199F6B8 != -1) {
      dispatch_once(&qword_10199F6B8, &stru_10188E2C8);
    }
    __int128 v3 = *(_OWORD *)(a1 + 16);
    v4[0] = *(_OWORD *)a1;
    v4[1] = v3;
    double v4[2] = *(_OWORD *)(a1 + 32);
    *(void *)&double result = sub_100F5A0C0(qword_1019A4090, v4).n128_u64[0];
  }

  return result;
}

uint64_t sub_100F5A080()
{
  if (qword_10199F6B8 != -1) {
    dispatch_once(&qword_10199F6B8, &stru_10188E2C8);
  }
  return qword_1019A4090;
}

__n128 sub_100F5A0C0(uint64_t a1, __int128 *a2)
{
  block[1] = 3221225472LL;
  __int128 v4 = a2[1];
  __int128 v9 = *a2;
  uint64_t v5 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[2] = sub_100F5DB34;
  block[3] = &unk_10188E328;
  block[4] = a1;
  __int128 v6 = a2[2];
  __int128 v10 = v4;
  __int128 v11 = v6;
  dispatch_async(v5, block);
  return result;
}

void *sub_100F5A13C(void *a1)
{
  *((_OWORD *)a1 + 24) = 0u;
  *((_OWORD *)a1 + 25) = 0u;
  *((_OWORD *)a1 + 22) = 0u;
  *((_OWORD *)a1 + 23) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 21) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 19) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + 17) = 0u;
  *((_OWORD *)a1 + 14) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  a1[1] = 0xBFF0000000000000LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  *(void *)((char *)a1 + 37) = 0LL;
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  a1[9] = 0xFFFFFFFF00000000LL;
  *((_DWORD *)a1 + 21) = 300;
  *((_BYTE *)a1 + 92) = 0;
  *(void *)((char *)a1 + 100) = 0xFFFFFFFF00000000LL;
  *((_DWORD *)a1 + 27) = -1;
  a1[14] = 0LL;
  *(void *)((char *)a1 + 118) = 0LL;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *(_OWORD *)((char *)a1 + 185) = 0u;
  *(_OWORD *)(a1 + 29) = 0u;
  uint64_t v2 = a1 + 29;
  *(void *)((char *)a1 + 209) = 0LL;
  *(void *)((char *)a1 + 204) = 0LL;
  a1[28] = 0x7FFFFFFFFFFFFFFFLL;
  *((_DWORD *)a1 + 75) = 0;
  *(_OWORD *)(a1 + 31) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *(_OWORD *)((char *)a1 + 277) = 0u;
  *(_OWORD *)(a1 + 39) = 0u;
  *(_OWORD *)(a1 + 41) = 0u;
  *(_OWORD *)(a1 + 43) = 0u;
  *(_OWORD *)(a1 + 45) = 0u;
  *(_OWORD *)(a1 + 47) = 0u;
  *(_OWORD *)(a1 + 49) = 0u;
  *((_DWORD *)a1 + 102) = 0;
  *((_WORD *)a1 + 206) = 257;
  *((_OWORD *)a1 + 26) = 0u;
  *((_OWORD *)a1 + 27) = 0u;
  *((_OWORD *)a1 + 28) = 0u;
  *((_OWORD *)a1 + 29) = 0u;
  a1[60] = dispatch_queue_create("com.apple.CLFitnessTrackingAWD", 0LL);
  v2[32] = 0x10000000000000LL;
  *(_OWORD *)(v2 + 33) = xmmword_1012ED960;
  v2[35] = 0x7FEFFFFFFFFFFFFFLL;
  *((_DWORD *)v2 + 72) = 0;
  v2[37] = 0x4072C00000000000LL;
  *((_DWORD *)v2 + 76) = 0;
  *((_BYTE *)v2 + 308) = 0;
  sub_1010DDBC0(v2 + 39, "");
  *(_OWORD *)((char *)a1 + 673) = 0u;
  *(_OWORD *)(a1 + 81) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  *(_OWORD *)(a1 + 77) = 0u;
  *(_OWORD *)(a1 + 79) = 0u;
  *(_OWORD *)(a1 + 73) = 0u;
  *(_OWORD *)(a1 + 75) = 0u;
  *(_OWORD *)(a1 + 71) = 0u;
  *(_OWORD *)(a1 + 87) = 0u;
  *(_OWORD *)(a1 + 89) = 0u;
  *(_OWORD *)(a1 + 91) = 0u;
  *(_OWORD *)(a1 + 93) = 0u;
  *(_OWORD *)(a1 + 95) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_OWORD *)(a1 + 99) = 0u;
  *(_OWORD *)(a1 + 101) = 0u;
  *(_OWORD *)(a1 + 103) = 0u;
  *(_OWORD *)(a1 + 105) = 0u;
  *(_OWORD *)(a1 + 107) = 0u;
  *(_OWORD *)(a1 + 109) = 0u;
  *(_OWORD *)(a1 + 111) = 0u;
  *(_OWORD *)(a1 + 113) = 0u;
  *(_OWORD *)(a1 + 115) = 0u;
  *(_OWORD *)(a1 + 117) = 0u;
  *(_OWORD *)(a1 + 119) = 0u;
  *(_OWORD *)(a1 + 121) = 0u;
  *(_OWORD *)(a1 + 123) = 0u;
  *(_OWORD *)(a1 + 125) = 0u;
  *(_OWORD *)(a1 + 127) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  *(_OWORD *)(a1 + 131) = 0u;
  *(_OWORD *)(a1 + 133) = 0u;
  *(_OWORD *)(a1 + 135) = 0u;
  *(_OWORD *)(a1 + 137) = 0u;
  *(_OWORD *)(a1 + 139) = 0u;
  *(_OWORD *)(a1 + 141) = 0u;
  *(_OWORD *)(a1 + 143) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(_OWORD *)(a1 + 147) = 0u;
  *(_DWORD *)((char *)a1 + 1191) = 0;
  sub_1006B3704((uint64_t)(a1 + 150), 0, 0.0);
  *((_DWORD *)a1 + 324) = 0;
  a1[195] = 0LL;
  *(_OWORD *)(a1 + 191) = 0u;
  *(_OWORD *)(a1 + 193) = 0u;
  *(_OWORD *)(a1 + 187) = 0u;
  *(_OWORD *)(a1 + 189) = 0u;
  *(_OWORD *)(a1 + 183) = 0u;
  *(_OWORD *)(a1 + 185) = 0u;
  *(_OWORD *)(a1 + 179) = 0u;
  *(_OWORD *)(a1 + 181) = 0u;
  *(_OWORD *)(a1 + 175) = 0u;
  *(_OWORD *)(a1 + 177) = 0u;
  *(_OWORD *)(a1 + 171) = 0u;
  *(_OWORD *)(a1 + 173) = 0u;
  *(_OWORD *)(a1 + 167) = 0u;
  *(_OWORD *)(a1 + 169) = 0u;
  *(_OWORD *)(a1 + 165) = 0u;
  *((_DWORD *)a1 + 331) = -1082130432;
  __asm { FMOV            V0.4S, #-1.0 }

  *(_OWORD *)((char *)v2 + 1100) = _Q0;
  *(_OWORD *)((char *)v2 + 1116) = _Q0;
  *(_OWORD *)((char *)v2 + 1132) = _Q0;
  *(_OWORD *)((char *)v2 + 1148) = _Q0;
  *(_OWORD *)((char *)v2 + 1164) = _Q0;
  *(_OWORD *)((char *)v2 + 1180) = _Q0;
  *(_OWORD *)((char *)v2 + 1196) = _Q0;
  *((_DWORD *)a1 + 361) = -1082130432;
  a1[182] = -1LL;
  a1[181] = -1LL;
  *((_OWORD *)v2 + 77) = _Q0;
  *((_OWORD *)v2 + 78) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }

  a1[187] = _Q0;
  a1[188] = 66LL;
  *(void *)((char *)a1 + 1525) = 0LL;
  a1[190] = 0LL;
  a1[193] = 0LL;
  a1[192] = 0LL;
  a1[194] = 0LL;
  *((_DWORD *)a1 + 390) = -1082130432;
  a1[196] = _Q0;
  a1[197] = 0LL;
  *((_BYTE *)a1 + 1584) = 1;
  a1[199] = 0x7FEFFFFFFFFFFFFFLL;
  int64x2_t v8 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *((int64x2_t *)a1 + 100) = v8;
  *((int64x2_t *)a1 + 101) = v8;
  a1[204] = 0x7FEFFFFFFFFFFFFFLL;
  *(int32x2_t *)v8.i8 = vdup_n_s32(0x7F7FFFFFu);
  a1[205] = v8.i64[0];
  a1[206] = 0LL;
  a1[207] = v8.i64[0];
  a1[208] = 0LL;
  uint64_t v9 = sub_1006E27E8();
  sub_100413284(v9, &block);
  __int128 v10 = v2 + 37;
  char v11 = sub_1002A82BC((uint64_t)block, "MinSessionLengthAWD", v10);
  char v12 = v11;
  __int128 v13 = (std::__shared_weak_count *)v22;
  if (!v22) {
    goto LABEL_5;
  }
  double v14 = (unint64_t *)(v22 + 8);
  do
    unint64_t v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (v15)
  {
LABEL_5:
    if ((v11 & 1) != 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
  std::__shared_weak_count::__release_weak(v13);
  if ((v12 & 1) == 0) {
LABEL_6:
  }
    *__int128 v10 = 0x4072C00000000000LL;
LABEL_7:
  if (&MCEffectiveSettingsChangedNotification)
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_100F5A59C,  MCEffectiveSettingsChangedNotification,  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

  double v17 = (dispatch_queue_s *)a1[60];
  block = _NSConcreteStackBlock;
  uint64_t v22 = 3221225472LL;
  unint64_t v23 = sub_100F5D51C;
  __int128 v24 = &unk_10181D3D0;
  int v25 = a1;
  dispatch_async(v17, &block);
  sub_100F5A5F0(a1);
  double v18 = operator new(0x20uLL);
  *double v18 = off_1018A2210;
  *double v18 = &off_10188E378;
  v18[1] = 0LL;
  v18[2] = sub_100F59FE0;
  v18[3] = 0LL;
  uint64_t v19 = a1[206];
  a1[206] = v18;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  return a1;
}

void sub_100F5A528( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v14 = *(void *)(v10 + 1648);
  *(void *)(v10 + 1648) = 0LL;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
  }
  sub_100F5A62C(v10);
  _Unwind_Resume(a1);
}

void sub_100F5A59C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(dispatch_queue_s **)(a2 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5D51C;
  block[3] = &unk_10181D3D0;
  block[4] = a2;
  dispatch_async(v2, block);
}

void *sub_100F5A5F0(void *a1)
{
  a1[145] = sub_100F5D2EC();
  a1[147] = sub_100F5D2EC();
  a1[146] = sub_100F5D2EC();
  __n128 result = sub_100F5D2EC();
  a1[148] = result;
  return result;
}

uint64_t sub_100F5A62C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {
    *(void *)(a1 + 320) = v2;
    operator delete(v2);
  }

  return a1;
}

void *sub_100F5A67C()
{
  unsigned __int8 v0 = operator new(0x688uLL);
  __n128 result = sub_100F5A13C(v0);
  qword_1019A4090 = (uint64_t)v0;
  return result;
}

void sub_100F5A6AC(_Unwind_Exception *a1)
{
}

void sub_100F5A6C4(uint64_t a1, char a2, uint64_t a3, char a4)
{
  int64x2_t v8 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5A748;
  block[3] = &unk_10188E2E8;
  char v10 = a2;
  char v11 = a4;
  block[4] = a1;
  void block[5] = a3;
  dispatch_sync(v8, block);
}

double sub_100F5A748(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  double Current = CFAbsoluteTimeGetCurrent();
  double v4 = *(double *)(v2 + 504);
  if (v4 >= Current)
  {
    int v5 = *(unsigned __int8 *)(a1 + 48);
  }

  else
  {
    int v5 = *(unsigned __int8 *)(v2 + 537);
    if (*(_BYTE *)(v2 + 537))
    {
      double v6 = *(double *)(v2 + 488);
      if (v4 >= v6) {
        double v6 = *(double *)(v2 + 504);
      }
      *(double *)(v2 + 496) = *(double *)(v2 + 496) + Current - v6;
    }

    int v7 = *(unsigned __int8 *)(a1 + 48);
    if (v5 != v7)
    {
      ++*(_DWORD *)(v2 + 520);
      int v5 = v7;
    }
  }

  if (v5) {
    LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a1 + 49) != 0;
  }
  *(_BYTE *)(v2 + 538) = v5;
  if (v4 != 1.79769313e308)
  {
    if (*(_BYTE *)(v2 + 540)) {
      LOBYTE(sub_1012279C0(0LL, v4, v5) = 1;
    }
    *(_BYTE *)(v2 + 540) = v5;
  }

  *(_BYTE *)(v2 + 537) = *(_BYTE *)(a1 + 48);
  sub_1010DDBC0(&v10, *(char **)(a1 + 40));
  int64x2_t v8 = (void **)(v2 + 544);
  double result = *(double *)&v10;
  *(_OWORD *)int64x2_t v8 = v10;
  *(void *)(v2 + 560) = v11;
  *(double *)(v2 + 488) = Current;
  return result;
}

double sub_100F5A840(uint64_t a1)
{
  double v2 = *(double *)(a1 + 504);
  double v1 = *(double *)(a1 + 512);
  if (*(_BYTE *)(a1 + 537))
  {
    double v3 = *(double *)(a1 + 488);
    if (v2 >= v3) {
      double v3 = *(double *)(a1 + 504);
    }
    double v4 = *(double *)(a1 + 496) + v1 - v3;
    *(double *)(a1 + 496) = v4;
  }

  else
  {
    double v4 = *(double *)(a1 + 496);
  }

  double result = v4 / (v1 - v2) * 100.0;
  *(_DWORD *)(a1 + 76) = (int)result;
  return result;
}

int32x2_t sub_100F5A88C(uint64_t a1)
{
  LOWORD(v28) = 0;
  BYTE2(v28) = 0;
  memset(v29, 0, 17);
  *(void *)((char *)&v28 + 3) = 0LL;
  *((void *)&v28 + 1) = 0LL;
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0xBFF0000000000000LL;
  double v2 = (void **)(a1 + 16);
  double v3 = (void **)(a1 + 48);
  *double v2 = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 37) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *double v3 = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 76) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 84) = 300;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = -1LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 118) = 0LL;
  *(_WORD *)(a1 + 126) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = v29[0];
  *(_OWORD *)(a1 + 185) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  __int128 v4 = 0uLL;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 201) = v28;
  *(_DWORD *)(a1 + 217) = 0;
  *(_DWORD *)(a1 + 220) = 0;
  *(void *)(a1 + 224) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 292) = 0u;
  int v5 = *(void **)(a1 + 312);
  if (v5)
  {
    *(void *)(a1 + 320) = v5;
    operator delete(v5);
    __int128 v4 = 0uLL;
  }

  *(_DWORD *)(a1 + 408) = 0;
  *(_OWORD *)(a1 + 376) = v4;
  *(_OWORD *)(a1 + 392) = v4;
  *(_OWORD *)(a1 + 344) = v4;
  *(_OWORD *)(a1 + 360) = v4;
  *(_OWORD *)(a1 + 312) = v4;
  *(_OWORD *)(a1 + 328) = v4;
  *(_DWORD *)(a1 + 412) = 257;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 512) = 0x7FEFFFFFFFFFFFFFLL;
  *(_WORD *)(a1 + 1192) = 0;
  *(_BYTE *)(a1 + 1194) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_OWORD *)(a1 + 496) = xmmword_1012ED960;
  *(_DWORD *)(a1 + 1296) = 0;
  *(_OWORD *)(a1 + 568) = v4;
  *(_OWORD *)(a1 + 584) = v4;
  *(_OWORD *)(a1 + 600) = v4;
  *(_OWORD *)(a1 + 616) = v4;
  *(_OWORD *)(a1 + 648) = v4;
  *(_OWORD *)(a1 + 664) = v4;
  *(void *)(a1 + 680) = 0LL;
  *(_OWORD *)(a1 + 696) = v4;
  *(_OWORD *)(a1 + 712) = v4;
  *(_OWORD *)(a1 + 728) = v4;
  *(_OWORD *)(a1 + 744) = v4;
  *(_OWORD *)(a1 + 760) = v4;
  *(_OWORD *)(a1 + 776) = v4;
  *(_OWORD *)(a1 + 792) = v4;
  *(_OWORD *)(a1 + 808) = v4;
  *(_OWORD *)(a1 + 824) = v4;
  *(_OWORD *)(a1 + 840) = v4;
  *(_OWORD *)(a1 + 856) = v4;
  *(_OWORD *)(a1 + 872) = v4;
  *(_OWORD *)(a1 + 888) = v4;
  *(_OWORD *)(a1 + 904) = v4;
  *(void *)(a1 + 920) = 0LL;
  *(void *)(a1 + 1152) = 0LL;
  *(_OWORD *)(a1 + 1136) = v4;
  *(_OWORD *)(a1 + 1120) = v4;
  *(_OWORD *)(a1 + 1104) = v4;
  *(_OWORD *)(a1 + 1088) = v4;
  *(_OWORD *)(a1 + 1072) = v4;
  *(_OWORD *)(a1 + 1056) = v4;
  *(_OWORD *)(a1 + 1040) = v4;
  *(_OWORD *)(a1 + 1008) = v4;
  *(_OWORD *)(a1 + 1024) = v4;
  *(_OWORD *)(a1 + 976) = v4;
  *(_OWORD *)(a1 + 992) = v4;
  *(_OWORD *)(a1 + 944) = v4;
  *(_OWORD *)(a1 + 960) = v4;
  *(_OWORD *)(a1 + 928) = v4;
  double v6 = *(void **)(a1 + 1160);
  if (v6)
  {
    int v7 = (void *)v6[14];
    if (v7)
    {
      v6[15] = v7;
      operator delete(v7);
    }

    int64x2_t v8 = (void *)v6[11];
    if (v8)
    {
      v6[12] = v8;
      operator delete(v8);
    }

    uint64_t v9 = (void *)v6[8];
    if (v9)
    {
      v6[9] = v9;
      operator delete(v9);
    }

    __int128 v10 = (void *)v6[4];
    if (v10)
    {
      v6[5] = v10;
      operator delete(v10);
    }

    operator delete(v6);
  }

  *(void *)(a1 + 1160) = 0LL;
  uint64_t v11 = *(void **)(a1 + 1176);
  if (v11)
  {
    char v12 = (void *)v11[14];
    if (v12)
    {
      v11[15] = v12;
      operator delete(v12);
    }

    __int128 v13 = (void *)v11[11];
    if (v13)
    {
      v11[12] = v13;
      operator delete(v13);
    }

    uint64_t v14 = (void *)v11[8];
    if (v14)
    {
      v11[9] = v14;
      operator delete(v14);
    }

    unint64_t v15 = (void *)v11[4];
    if (v15)
    {
      v11[5] = v15;
      operator delete(v15);
    }

    operator delete(v11);
  }

  *(void *)(a1 + 1176) = 0LL;
  double v16 = *(void **)(a1 + 1168);
  if (v16)
  {
    double v17 = (void *)v16[14];
    if (v17)
    {
      v16[15] = v17;
      operator delete(v17);
    }

    double v18 = (void *)v16[11];
    if (v18)
    {
      v16[12] = v18;
      operator delete(v18);
    }

    uint64_t v19 = (void *)v16[8];
    if (v19)
    {
      v16[9] = v19;
      operator delete(v19);
    }

    double v20 = (void *)v16[4];
    if (v20)
    {
      v16[5] = v20;
      operator delete(v20);
    }

    operator delete(v16);
  }

  *(void *)(a1 + 1168) = 0LL;
  double v21 = *(void **)(a1 + 1184);
  if (v21)
  {
    uint64_t v22 = (void *)v21[14];
    if (v22)
    {
      v21[15] = v22;
      operator delete(v22);
    }

    unint64_t v23 = (void *)v21[11];
    if (v23)
    {
      v21[12] = v23;
      operator delete(v23);
    }

    __int128 v24 = (void *)v21[8];
    if (v24)
    {
      v21[9] = v24;
      operator delete(v24);
    }

    int v25 = (void *)v21[4];
    if (v25)
    {
      v21[5] = v25;
      operator delete(v25);
    }

    operator delete(v21);
  }

  *(void *)(a1 + 1184) = 0LL;
  sub_100F5A5F0((void *)a1);
  *(void *)(a1 + 1592) = 0x7FEFFFFFFFFFFFFFLL;
  int64x2_t v26 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(int64x2_t *)(a1 + 1600) = v26;
  *(int64x2_t *)(a1 + 1616) = v26;
  *(void *)(a1 + 1632) = 0x7FEFFFFFFFFFFFFFLL;
  int32x2_t result = vdup_n_s32(0x7F7FFFFFu);
  *(int32x2_t *)(a1 + 1640) = result;
  *(int32x2_t *)(a1 + 1656) = result;
  *(void *)(a1 + 1664) = 0LL;
  *(_BYTE *)(a1 + 540) = 0;
  return result;
}

void sub_100F5AC28(uint64_t a1)
{
  if (qword_101934620 != -1) {
    dispatch_once(&qword_101934620, &stru_10188E348);
  }
  double v2 = (os_log_s *)qword_101934628;
  if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *(unsigned __int8 *)(a1 + 44);
    __int128 v4 = (void *)(a1 + 48);
    int v160 = *(_DWORD *)(a1 + 40);
    int v5 = *(_DWORD *)(a1 + 80);
    int v6 = *(_DWORD *)(a1 + 84);
    int v162 = v3;
    __int16 v163 = 2080;
    *(void *)BOOL v164 = v4;
    int v7 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)v165 = *(_DWORD *)(a1 + 72);
    int v8 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)&v165[6] = v5;
    int v9 = *(unsigned __int8 *)(a1 + 92);
    *(_DWORD *)__int128 v166 = v6;
    *(_DWORD *)&v166[6] = v8;
    int v10 = *(_DWORD *)(a1 + 96);
    int v11 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)&v166[12] = v9;
    *(_DWORD *)uint64_t v167 = v10;
    int v12 = *(_DWORD *)(a1 + 112);
    int v13 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)v168 = v11;
    int v14 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)__int128 v169 = v12;
    int v15 = *(unsigned __int8 *)(a1 + 124);
    *(_DWORD *)v170 = v13;
    *(_DWORD *)v171 = v14;
    int v16 = *(_DWORD *)(a1 + 140);
    int v172 = *(_DWORD *)(a1 + 136);
    int v17 = *(unsigned __int8 *)(a1 + 125);
    int v174 = v15;
    int v176 = v17;
    int v18 = *(_DWORD *)(a1 + 132);
    int v178 = *(_DWORD *)(a1 + 128);
    int v180 = v18;
    int v182 = v16;
    int v184 = v7;
    int v19 = *(_DWORD *)(a1 + 108);
    int v186 = *(_DWORD *)(a1 + 104);
    int v188 = v19;
    int v20 = *(_DWORD *)(a1 + 148);
    int v190 = *(_DWORD *)(a1 + 144);
    int v192 = v20;
    int v21 = *(_DWORD *)(a1 + 156);
    int v194 = *(_DWORD *)(a1 + 152);
    int v196 = v21;
    int v22 = *(_DWORD *)(a1 + 164);
    int v198 = *(_DWORD *)(a1 + 160);
    int v200 = v22;
    int v23 = *(_DWORD *)(a1 + 172);
    int v202 = *(_DWORD *)(a1 + 168);
    int v24 = *(_DWORD *)(a1 + 176);
    int v204 = v23;
    int v25 = *(unsigned __int8 *)(a1 + 200);
    int v206 = v24;
    int v212 = v25;
    int v26 = *(_DWORD *)(a1 + 208);
    int v214 = *(_DWORD *)(a1 + 204);
    int v216 = v26;
    int v218 = *(_DWORD *)(a1 + 212);
    int v228 = *(_DWORD *)(a1 + 340);
    int v232 = *(_DWORD *)(a1 + 348);
    int v236 = *(_DWORD *)(a1 + 356);
    int v27 = *(_DWORD *)(a1 + 196);
    int v220 = *(_DWORD *)(a1 + 192);
    int v222 = v27;
    __int16 v207 = 2048;
    __int16 v209 = 2048;
    __int16 v223 = 2048;
    uint64_t v224 = *(void *)(a1 + 224);
    int v226 = *(_DWORD *)(a1 + 336);
    int v230 = *(_DWORD *)(a1 + 344);
    int v234 = *(_DWORD *)(a1 + 352);
    __int16 v161 = 1024;
    *(_WORD *)&v164[8] = 1024;
    *(_WORD *)&v165[4] = 1024;
    *(_WORD *)&v165[10] = 1024;
    *(_WORD *)&v166[4] = 1024;
    *(_WORD *)&v166[10] = 1024;
    *(_WORD *)&v166[16] = 1024;
    *(_WORD *)&v167[4] = 1024;
    *(_WORD *)&v168[4] = 1024;
    *(_WORD *)&v169[4] = 1024;
    *(_WORD *)&v170[4] = 1024;
    *(_WORD *)&v171[4] = 1024;
    __int16 v173 = 1024;
    __int16 v175 = 1024;
    __int16 v177 = 1024;
    __int16 v179 = 1024;
    __int16 v181 = 1024;
    __int16 v183 = 1024;
    __int16 v185 = 1024;
    __int16 v187 = 1024;
    __int16 v189 = 1024;
    __int16 v191 = 1024;
    __int16 v193 = 1024;
    __int16 v195 = 1024;
    __int16 v197 = 1024;
    __int16 v199 = 1024;
    __int16 v201 = 1024;
    __int16 v203 = 1024;
    __int16 v205 = 1024;
    __int16 v211 = 1024;
    __int16 v213 = 1024;
    __int16 v215 = 1024;
    __int16 v217 = 1024;
    __int16 v219 = 1024;
    __int16 v221 = 1024;
    __int16 v225 = 1024;
    __int16 v227 = 1024;
    __int16 v229 = 1024;
    __int16 v231 = 1024;
    __int16 v233 = 1024;
    __int16 v235 = 1024;
    double v28 = *(float *)(a1 + 180);
    double v29 = *(float *)(a1 + 184);
    *(_DWORD *)std::stringbuf::string_type buf = 67120642;
    double v208 = v28;
    double v210 = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "AWD: workout:%d, companion:%d, %s, GPS:%u, HR:%u, Onset:%d, HRUtil:%u, VO2Avail:%d, HRSrc:%d, VO2Cons:%u, PALStat: %d, VO2Stat:%d, loadUtil:%u, strideAvail:%u, walkAvail:%d, runAvail:%d, walkStat:%d, runStat:%d, VO2Grade:%d, idsA vail:%d, defaultUtil:%d, WRHR:%d, PedGPSAvailable:%d, DistTrackUsed:%d, DistTrackInvalidGradient:%d, DistTrackInva lidGain:%d, DistTrackInvalidSpeed:%d, DistTrackInvalidLength:%d, SeshDuration:%d, PedCalibrated:%d, PaceFail:%d, P edMetSourceDiff:%f, PedMetSourceDiff:%f, HrBoundsFail:%d, SeshUp:%d, SeshDown:%d, SeshCaloriesFromGrade:%d, SeshGP SSourcePhone:%d, SeshGPSSourceWatch:%d, ElevationError:%lld, HRSamplesValidMin: %d, HRSamplesValidMax: %d, METSamp lesWithRecentHR: %d, METSamplesValidDelta: %d, VO2DeltaPercentage: %d, HRMetPairs: %d",  buf,  0x126u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934620 != -1) {
      dispatch_once(&qword_101934620, &stru_10188E348);
    }
    int v70 = *(unsigned __int8 *)(a1 + 44);
    int v71 = (void *)(a1 + 48);
    HIDWORD(v118) = *(_DWORD *)(a1 + 40);
    int v72 = *(_DWORD *)(a1 + 80);
    int v73 = *(_DWORD *)(a1 + 84);
    *(_DWORD *)&v119[2] = v70;
    __int16 v120 = 2080;
    *(void *)double v121 = v71;
    int v74 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)&v121[10] = *(_DWORD *)(a1 + 72);
    int v75 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)&v121[16] = v72;
    int v76 = *(unsigned __int8 *)(a1 + 92);
    *(_DWORD *)&v121[22] = v73;
    int v122 = v75;
    int v77 = *(_DWORD *)(a1 + 96);
    int v78 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)((char *)&v123 + 2) = v76;
    int v124 = v77;
    int v79 = *(_DWORD *)(a1 + 112);
    int v80 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)unsigned int v125 = v78;
    int v81 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)double v126 = v79;
    int v82 = *(unsigned __int8 *)(a1 + 124);
    *(_DWORD *)&v126[6] = v80;
    int v127 = v81;
    int v83 = *(_DWORD *)(a1 + 140);
    *(_DWORD *)BOOL v128 = *(_DWORD *)(a1 + 136);
    int v84 = *(unsigned __int8 *)(a1 + 125);
    int v129 = v82;
    *(_DWORD *)&v130[2] = v84;
    int v85 = *(_DWORD *)(a1 + 132);
    int v131 = *(_DWORD *)(a1 + 128);
    *(_DWORD *)v132 = v85;
    int v133 = v83;
    *(_DWORD *)&v134[2] = v74;
    int v86 = *(_DWORD *)(a1 + 108);
    int v135 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)uint64_t v136 = v86;
    int v87 = *(_DWORD *)(a1 + 148);
    int v137 = *(_DWORD *)(a1 + 144);
    *(_DWORD *)&v138[2] = v87;
    int v88 = *(_DWORD *)(a1 + 156);
    int v139 = *(_DWORD *)(a1 + 152);
    *(_DWORD *)double v140 = v88;
    int v89 = *(_DWORD *)(a1 + 164);
    int v141 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)&v142[2] = v89;
    int v90 = *(_DWORD *)(a1 + 172);
    int v143 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)double v144 = v90;
    int v145 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)v148 = *(unsigned __int8 *)(a1 + 200);
    *(_DWORD *)&v150[2] = *(_DWORD *)(a1 + 208);
    *(_DWORD *)&v154[2] = *(_DWORD *)(a1 + 340);
    *(_DWORD *)uint64_t v156 = *(_DWORD *)(a1 + 348);
    *(_DWORD *)((char *)v157 + 2) = *(_DWORD *)(a1 + 356);
    int v91 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)((char *)&v151 + 6) = *(_DWORD *)(a1 + 192);
    *(void *)&v152[2] = *(void *)(a1 + 224);
    double v92 = *(float *)(a1 + 184);
    *(double *)&v146[2] = *(float *)(a1 + 180);
    double v147 = v92;
    int v149 = *(_DWORD *)(a1 + 204);
    LODWORD(v151) = *(_DWORD *)(a1 + 212);
    HIDWORD(v151) = v91;
    *(_WORD *)__int128 v146 = 2048;
    *(_WORD *)&v146[10] = 2048;
    *(_WORD *)uint64_t v152 = 2048;
    int v153 = *(_DWORD *)(a1 + 336);
    int v155 = *(_DWORD *)(a1 + 344);
    *(_WORD *)uint64_t v119 = 1024;
    *(_WORD *)&v121[8] = 1024;
    *(_WORD *)&v121[26] = 1024;
    LOWORD(v123) = 1024;
    *(_WORD *)&v125[4] = 1024;
    *(_WORD *)&v126[4] = 1024;
    *(_WORD *)&v128[4] = 1024;
    *(_WORD *)unint64_t v130 = 1024;
    *(_WORD *)&v132[4] = 1024;
    *(_WORD *)__int128 v134 = 1024;
    *(_WORD *)&v136[4] = 1024;
    *(_WORD *)unint64_t v138 = 1024;
    *(_WORD *)&v140[4] = 1024;
    *(_WORD *)BOOL v142 = 1024;
    *(_WORD *)&v144[4] = 1024;
    *(_WORD *)&v148[4] = 1024;
    *(_WORD *)uint64_t v150 = 1024;
    WORD2(v151) = 1024;
    WORD5(v151) = 1024;
    *(_WORD *)&v152[10] = 1024;
    *(_WORD *)__int128 v154 = 1024;
    *(_WORD *)&v156[4] = 1024;
    LOWORD(v157[0]) = 1024;
    LODWORD(v118) = 67120642;
    uint64_t v93 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "AWD: workout:%d, companion:%d, %s, GPS:%u, HR:%u, Onset:%d, HRUtil:%u, VO2Avail:%d, HRSrc:%d, VO2Con s:%u, PALStat:%d, VO2Stat:%d, loadUtil:%u, strideAvail:%u, walkAvail:%d, runAvail:%d, walkStat:%d, r unStat:%d, VO2Grade:%d, idsAvail:%d, defaultUtil:%d, WRHR:%d, PedGPSAvailable:%d, DistTrackUsed:%d, DistTrackInvalidGradient:%d, DistTrackInvalidGain:%d, DistTrackInvalidSpeed:%d, DistTrackInvalidLeng th:%d, SeshDuration:%d, PedCalibrated:%d, PaceFail:%d, PedMetSourceDiff:%f, PedMetSourceDiff:%f, HrB oundsFail:%d, SeshUp:%d, SeshDown:%d, SeshCaloriesFromGrade:%d, SeshGPSSourcePhone:%d, SeshGPSSource Watch:%d, ElevationError:%lld, HRSamplesValidMin: %d, HRSamplesValidMax: %d, METSamplesWithRecentHR: %d, METSamplesValidDelta: %d, VO2DeltaPercentage: %d, HRMetPairs: %d",  &v118,  294,  v118,  *(_DWORD *)v119,  *(_DWORD *)v121,  *(_DWORD *)&v121[8],  *(_DWORD *)&v121[16],  *(_DWORD *)&v121[24],  v123,  v124,  *(_DWORD *)&v125[2],  *(_DWORD *)&v126[4],  v127,  *(_DWORD *)&v128[2],  *(_DWORD *)v130,  v131,  *(_DWORD *)&v132[2],  *(_DWORD *)v134,  v135,  *(_DWORD *)&v136[2],  *(_DWORD *)v138,  v139,  *(_DWORD *)&v140[2],  *(_DWORD *)v142,  v143,  *(_DWORD *)&v144[2],  *(_DWORD *)v146,  *(_DWORD *)&v146[8],  HIDWORD(v92),  *(_DWORD *)&v148[2],  *(_DWORD *)v150,  *(double *)&v151,  *((double *)&v151 + 1),  *(_DWORD *)v152,
                    *(_DWORD *)&v152[8],
                    *(_DWORD *)v154,
                    v155,
                    *(_DWORD *)&v156[2],
                    v157[0],
                    v158);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFitnessTrackingAWD::describe()", "%s\n", v93);
  }

  if (qword_101934620 != -1) {
    dispatch_once(&qword_101934620, &stru_10188E348);
  }
  int v30 = (os_log_s *)qword_101934628;
  if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
  {
    int v31 = *(_DWORD *)(a1 + 40);
    int v32 = *(_DWORD *)(a1 + 360);
    int v33 = *(_DWORD *)(a1 + 364);
    int v34 = *(_DWORD *)(a1 + 368);
    int v35 = *(_DWORD *)(a1 + 372);
    int v36 = *(_DWORD *)(a1 + 376);
    int v37 = *(_DWORD *)(a1 + 380);
    int v38 = *(_DWORD *)(a1 + 384);
    int v39 = *(_DWORD *)(a1 + 388);
    int v40 = *(_DWORD *)(a1 + 392);
    int v41 = *(_DWORD *)(a1 + 396);
    int v42 = *(_DWORD *)(a1 + 400);
    int v43 = *(_DWORD *)(a1 + 404);
    int v44 = *(_DWORD *)(a1 + 408);
    *(_DWORD *)std::stringbuf::string_type buf = 67112448;
    int v160 = v31;
    __int16 v161 = 1024;
    int v162 = v32;
    __int16 v163 = 1024;
    *(_DWORD *)BOOL v164 = v33;
    *(_WORD *)&v164[4] = 1024;
    *(_DWORD *)&v164[6] = v34;
    *(_WORD *)v165 = 1024;
    *(_DWORD *)&v165[2] = v35;
    *(_WORD *)&v165[6] = 1024;
    *(_DWORD *)&v165[8] = v36;
    *(_WORD *)__int128 v166 = 1024;
    *(_DWORD *)&v166[2] = v37;
    *(_WORD *)&v166[6] = 1024;
    *(_DWORD *)&v166[8] = v38;
    *(_WORD *)&v166[12] = 1024;
    *(_DWORD *)&v166[14] = v39;
    *(_WORD *)uint64_t v167 = 1024;
    *(_DWORD *)&v167[2] = v40;
    *(_WORD *)v168 = 1024;
    *(_DWORD *)&v168[2] = v41;
    *(_WORD *)__int128 v169 = 1024;
    *(_DWORD *)&v169[2] = v42;
    *(_WORD *)v170 = 1024;
    *(_DWORD *)&v170[2] = v43;
    *(_WORD *)v171 = 1024;
    *(_DWORD *)&v171[2] = v44;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagree,%d,BaroUnkNo DEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBaroGood,%d,GPSUnvailBaroUnk,%d,G PSUnvailBaroBad,%d",  buf,  0x56u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934620 != -1) {
      dispatch_once(&qword_101934620, &stru_10188E348);
    }
    int v94 = *(_DWORD *)(a1 + 360);
    int v95 = *(_DWORD *)(a1 + 364);
    int v96 = *(_DWORD *)(a1 + 368);
    int v97 = *(_DWORD *)(a1 + 376);
    int v98 = *(_DWORD *)(a1 + 380);
    int v99 = *(_DWORD *)(a1 + 384);
    int v100 = *(_DWORD *)(a1 + 392);
    int v101 = *(_DWORD *)(a1 + 396);
    int v102 = *(_DWORD *)(a1 + 400);
    int v103 = *(_DWORD *)(a1 + 408);
    *(_WORD *)uint64_t v119 = 1024;
    *(_WORD *)&v119[2] = v94;
    *(_WORD *)&v121[8] = HIWORD(v96);
    *(_WORD *)&v121[10] = 1024;
    *(_WORD *)&v121[16] = 1024;
    *(_WORD *)&v121[18] = v97;
    LOWORD(v123) = HIWORD(v99);
    WORD1(v123) = 1024;
    LOWORD(v124) = 1024;
    HIWORD(v124) = v100;
    *(_WORD *)&v126[4] = HIWORD(v102);
    *(_WORD *)&v126[6] = 1024;
    LOWORD(v127) = 1024;
    HIWORD(v127) = v103;
    int v104 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagr ee,%d,BaroUnkNoDEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBar oGood,%d,GPSUnvailBaroUnk,%d,GPSUnvailBaroBad,%d",  &v118,  86,  67112448,  *(_DWORD *)v119,  v95,  *(_DWORD *)&v121[8],  *(_DWORD *)&v121[16],  v98,  v123,  v124,  v101,  *(_DWORD *)&v126[4],  v127,  *(_DWORD *)&v128[2]);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFitnessTrackingAWD::describe()", "%s\n", v104);
  }

  int v45 = *(_DWORD *)(a1 + 40);
  if ((v45 - 4) >= 2)
  {
    if (v45 == 11)
    {
      if (qword_101934620 != -1) {
        dispatch_once(&qword_101934620, &stru_10188E348);
      }
      uint64_t v52 = (os_log_s *)qword_101934628;
      if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
      {
        int v53 = *(_DWORD *)(a1 + 232);
        int v54 = *(_DWORD *)(a1 + 236);
        int v55 = *(_DWORD *)(a1 + 240);
        int v56 = *(_DWORD *)(a1 + 244);
        int v57 = *(_DWORD *)(a1 + 248);
        int v58 = *(_DWORD *)(a1 + 252);
        *(_DWORD *)std::stringbuf::string_type buf = 67110400;
        int v160 = v53;
        __int16 v161 = 1024;
        int v162 = v54;
        __int16 v163 = 1024;
        *(_DWORD *)BOOL v164 = v55;
        *(_WORD *)&v164[4] = 1024;
        *(_DWORD *)&v164[6] = v56;
        *(_WORD *)v165 = 1024;
        *(_DWORD *)&v165[2] = v57;
        *(_WORD *)&v165[6] = 1024;
        *(_DWORD *)&v165[8] = v58;
        _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEBUG,  "Swimmming: Free:%d, Breast:%d, Butter:%d, Back:%d, Other:%d, Swimming:%d",  buf,  0x26u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934620 != -1) {
          dispatch_once(&qword_101934620, &stru_10188E348);
        }
        int v115 = *(_DWORD *)(a1 + 232);
        LODWORD(v118) = 67110400;
        HIDWORD(v118) = v115;
        LODWORD(v117) = 38;
        uint64_t v51 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "Swimmming: Free:%d, Breast:%d, Butter:%d, Back:%d, Other:%d, Swimming:%d",  &v118,  v117,  v118);
        goto LABEL_51;
      }
    }
  }

  else
  {
    if (qword_101934620 != -1) {
      dispatch_once(&qword_101934620, &stru_10188E348);
    }
    int v46 = (os_log_s *)qword_101934628;
    if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
    {
      int v47 = *(unsigned __int8 *)(a1 + 292);
      int v48 = *(_DWORD *)(a1 + 296);
      int v49 = *(_DWORD *)(a1 + 300);
      int v50 = *(_DWORD *)(a1 + 304);
      *(_DWORD *)std::stringbuf::string_type buf = 67109888;
      int v160 = v47;
      __int16 v161 = 1024;
      int v162 = v48;
      __int16 v163 = 1024;
      *(_DWORD *)BOOL v164 = v49;
      *(_WORD *)&v164[4] = 1024;
      *(_DWORD *)&v164[6] = v50;
      _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEBUG,  "Auto-pause: Enabled:%d, WillResume:%d, WillPause:%d, ResumeFalse:%d",  buf,  0x1Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934620 != -1) {
        dispatch_once(&qword_101934620, &stru_10188E348);
      }
      LODWORD(v117) = 26;
      uint64_t v51 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "Auto-pause: Enabled:%d, WillResume:%d, WillPause:%d, ResumeFalse:%d",  &v118,  v117);
LABEL_51:
      unsigned int v116 = (uint8_t *)v51;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFitnessTrackingAWD::describe()", "%s\n", v51);
      if (v116 != buf) {
        free(v116);
      }
    }
  }

  if (qword_101934620 != -1) {
    dispatch_once(&qword_101934620, &stru_10188E348);
  }
  int v59 = (os_log_s *)qword_101934628;
  if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
  {
    int v60 = *(unsigned __int8 *)(a1 + 412);
    int v61 = *(unsigned __int8 *)(a1 + 413);
    int v62 = *(_DWORD *)(a1 + 416);
    int v63 = *(_DWORD *)(a1 + 420);
    uint64_t v64 = *(void *)(a1 + 424);
    uint64_t v65 = *(void *)(a1 + 432);
    uint64_t v66 = *(void *)(a1 + 440);
    int v67 = *(_DWORD *)(a1 + 448);
    int v68 = *(_DWORD *)(a1 + 452);
    int v69 = *(_DWORD *)(a1 + 456);
    *(_DWORD *)std::stringbuf::string_type buf = 67111424;
    int v160 = v60;
    __int16 v161 = 1024;
    int v162 = v61;
    __int16 v163 = 1024;
    *(_DWORD *)BOOL v164 = v62;
    *(_WORD *)&v164[4] = 1024;
    *(_DWORD *)&v164[6] = v63;
    *(_WORD *)v165 = 2048;
    *(void *)&v165[2] = v64;
    *(_WORD *)&v165[10] = 2048;
    *(void *)__int128 v166 = v65;
    *(_WORD *)&v166[8] = 2048;
    *(void *)&v166[10] = v66;
    *(_WORD *)uint64_t v167 = 1024;
    *(_DWORD *)&v167[2] = v67;
    *(_WORD *)v168 = 1024;
    *(_DWORD *)&v168[2] = v68;
    *(_WORD *)__int128 v169 = 1024;
    *(_DWORD *)&v169[2] = v69;
    _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "WorkoutSessionStatistics,isStopAlertEnabled,%d,isStartAlertEnabled,%d,activtyTypeWhenStopDisabled,%d,activityTypeW henStartDisabled,%d,coarseLocationLat,%lld,coarseLocationLong,%lld,timeSinceLastDetectedStopToWorkoutEnd,%f,numAle rtsDetectedStops,%d,numStopAlertRetractions,%d,indoorOutdoorState,%d",  buf,  0x4Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934620 != -1) {
      dispatch_once(&qword_101934620, &stru_10188E348);
    }
    __int16 v105 = *(unsigned __int8 *)(a1 + 413);
    int v106 = *(_DWORD *)(a1 + 416);
    int v107 = *(_DWORD *)(a1 + 420);
    uint64_t v108 = *(void *)(a1 + 424);
    unint64_t v109 = *(void *)(a1 + 432);
    uint64_t v110 = *(void *)(a1 + 440);
    int v111 = *(_DWORD *)(a1 + 448);
    int v112 = *(_DWORD *)(a1 + 452);
    int v113 = *(_DWORD *)(a1 + 456);
    *(_WORD *)uint64_t v119 = 1024;
    *(_WORD *)&v119[2] = v105;
    *(_DWORD *)double v121 = v106;
    *(_WORD *)&v121[4] = 1024;
    *(_DWORD *)&v121[6] = v107;
    *(_WORD *)&v121[10] = 2048;
    *(void *)&v121[12] = v108;
    *(_WORD *)&v121[20] = 2048;
    *(_WORD *)&v121[22] = v109;
    LOWORD(v124) = 1024;
    HIWORD(v124) = v111;
    *(_DWORD *)&v125[2] = v112;
    *(_WORD *)double v126 = 1024;
    *(_DWORD *)&v126[2] = v113;
    int v114 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "WorkoutSessionStatistics,isStopAlertEnabled,%d,isStartAlertEnabled,%d,activtyTypeWhenStopDisabled,% d,activityTypeWhenStartDisabled,%d,coarseLocationLat,%lld,coarseLocationLong,%lld,timeSinceLastDete ctedStopToWorkoutEnd,%f,numAlertsDetectedStops,%d,numStopAlertRetractions,%d,indoorOutdoorState,%d",  &v118,  74,  67111424,  *(_DWORD *)v119,  *(void *)v121,  *(void *)&v121[8],  *(double *)&v121[16],  v109 >> 16,  v110,  v124);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFitnessTrackingAWD::describe()", "%s\n", v114);
  }

void sub_100F5B9B0(uint64_t a1)
{
  *(_BYTE *)a1 = 1;
  *(CFAbsoluteTime *)(a1 + 8) = CFAbsoluteTimeGetCurrent();
  sub_100F5A840(a1);
  *(_DWORD *)(a1 + 520) = 0;
  *(void *)(a1 + 496) = 0LL;
  *(_BYTE *)(a1 + 44) = *(_BYTE *)(a1 + 537);
  std::string::operator=((std::string *)(a1 + 48), (const std::string *)(a1 + 544));
  int v2 = *(_DWORD *)(a1 + 596);
  if (v2 >= 1)
  {
    float v3 = (float)v2;
    int v4 = llroundf((float)((float)*(int *)(a1 + 584) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 72) = llroundf((float)((float)*(int *)(a1 + 568) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 88) = v4;
    *(_DWORD *)(a1 + 120) = llroundf((float)((float)*(int *)(a1 + 592) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 144) = llroundf((float)((float)*(int *)(a1 + 572) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 172) = llroundf((float)((float)*(int *)(a1 + 576) * 100.0) / (float)v2);
    int v5 = llroundf((float)((float)*(int *)(a1 + 612) * 100.0) / (float)v2);
    unsigned int v6 = llroundf((float)((float)*(int *)(a1 + 588) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 204) = llroundf((float)((float)*(int *)(a1 + 608) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 208) = v5;
    *(_DWORD *)(a1 + 104) = v6;
    float v7 = (float)((float)*(int *)(a1 + 624) * 100.0) / (float)v2;
    *(_DWORD *)(a1 + 192) = llroundf((float)((float)*(int *)(a1 + 628) * 100.0) / (float)v2);
    *(_DWORD *)(a1 + 196) = llroundf(v7);
    if (*(_DWORD *)(a1 + 40) == 11)
    {
      int v8 = llroundf((float)((float)*(int *)(a1 + 668) * 100.0) / v3);
      int v9 = llroundf((float)((float)*(int *)(a1 + 672) * 100.0) / v3);
      int v10 = llroundf((float)((float)*(int *)(a1 + 676) * 100.0) / v3);
      float v11 = (float)*(int *)(a1 + 680) * 100.0;
      float v12 = (float)*(int *)(a1 + 684);
      *(_DWORD *)(a1 + 232) = llroundf((float)((float)*(int *)(a1 + 664) * 100.0) / v3);
      *(_DWORD *)(a1 + 236) = v8;
      *(_DWORD *)(a1 + 240) = v9;
      *(_DWORD *)(a1 + 244) = v10;
      *(_DWORD *)(a1 + 248) = llroundf(v11 / v3);
      *(_DWORD *)(a1 + 252) = 100 - llroundf((float)(v12 * 100.0) / v3);
    }
  }

  *(_BYTE *)(a1 + 124) = -[CMPedometerTableRawSpeedToKValue isWalkCalibrationAvailable]( +[CMPedometerTableRawSpeedToKValue sharedInstance]( &OBJC_CLASS___CMPedometerTableRawSpeedToKValue,  "sharedInstance"),  "isWalkCalibrationAvailable");
  uint64_t v13 = -[CMPedometerTableRawSpeedToKValue isRunCalibrationAvailable]( +[CMPedometerTableRawSpeedToKValue sharedInstance]( &OBJC_CLASS___CMPedometerTableRawSpeedToKValue,  "sharedInstance"),  "isRunCalibrationAvailable");
  *(_BYTE *)(a1 + 125) = v13;
  *(_OWORD *)(a1 + 336) = *(_OWORD *)(a1 + 1536);
  *(void *)(a1 + 352) = *(void *)(a1 + 1552);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a1 + 1564);
  int v14 = sub_100F5C08C(v13, *(_DWORD *)(a1 + 1516));
  int v15 = llroundf(*(float *)(a1 + 1560));
  *(_DWORD *)(a1 + 116) = v14;
  *(_DWORD *)(a1 + 100) = v15;
  int v16 = llroundf(*(float *)(a1 + 1568));
  *(_DWORD *)(a1 + 136) = llroundf(*(float *)(a1 + 1572));
  *(_DWORD *)(a1 + 140) = v16;
  float v17 = *(float *)(a1 + 600);
  if (v17 <= 0.0) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = llroundf((float)((float)(*(float *)(a1 + 604) - v17) * 100.0) / v17);
  }
  *(_DWORD *)(a1 + 108) = v18;
  double v19 = *(double *)(a1 + 1288);
  if (v19 > 0.0)
  {
    int v20 = llround(*(double *)(a1 + 1256) * 100.0 / v19);
    *(_DWORD *)(a1 + 148) = llround(*(double *)(a1 + 1224) * 100.0 / v19);
    *(_DWORD *)(a1 + 152) = v20;
    int v21 = llround(*(double *)(a1 + 1272) * 100.0 / v19);
    *(_DWORD *)(a1 + 156) = llround(*(double *)(a1 + 1264) * 100.0 / v19);
    *(_DWORD *)(a1 + 160) = v21;
    *(_DWORD *)(a1 + 164) = llround(*(double *)(a1 + 1280) * 100.0 / v19);
  }

  *(_DWORD *)(a1 + 168) = sub_100F5C0B0(a1);
  int v22 = *(_DWORD *)(a1 + 1296);
  if (v22 <= 0)
  {
    *(_DWORD *)(a1 + 180) = 0;
    double v24 = 0.0;
  }

  else
  {
    float v23 = *(double *)(a1 + 1304);
    *(float *)(a1 + 180) = v23;
    double v24 = 0.0;
    int v25 = v22 - 1;
    if (v25) {
      double v24 = *(double *)(a1 + 1312) / (double)v25;
    }
  }

  float v26 = sqrt(v24);
  *(float *)(a1 + 184) = v26;
  int v27 = *(_DWORD *)(a1 + 616);
  if (v27 >= 1) {
    *(_DWORD *)(a1 + 212) = llroundf((float)((float)*(int *)(a1 + 620) * 100.0) / (float)v27);
  }
  *(_BYTE *)(a1 + 292) = *(_BYTE *)(a1 + 688);
  sub_100F5C12C(a1);
  double v28 = *(double *)(a1 + 512) - *(double *)(a1 + 504);
  *(_BYTE *)(a1 + 216) = v28 > 1200.0;
  if (*(_BYTE *)(a1 + 1584)) {
    uint64_t v29 = (*(void *)(a1 + 656) - *(void *)(a1 + 648)) / 100LL;
  }
  else {
    uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
  }
  *(void *)(a1 + 224) = v29;
  *(_DWORD *)(a1 + 460) = (int)(float)((float)(*(float *)(a1 + 1644) - *(float *)(a1 + 1640)) / 10.0);
  if (*(_BYTE *)(a1 + 539) || *(_BYTE *)(a1 + 540))
  {
    int v30 = 0x80000000;
  }

  else
  {
    double v37 = *(double *)(a1 + 1632);
    else {
      int v30 = (int)(v37 - v38);
    }
  }

  *(_DWORD *)(a1 + 464) = v30;
  float v31 = *(float *)(a1 + 1660);
  else {
    int v33 = (int)(float)((float)(v31 - v32) / 10.0);
  }
  *(_DWORD *)(a1 + 468) = v33;
  *(_DWORD *)(a1 + 472) = sub_100D2EC74( *(double *)(a1 + 1600),  *(double *)(a1 + 1616),  *(double *)(a1 + 1592),  *(double *)(a1 + 1608));
  *(_DWORD *)(a1 + 476) = (float)(*(float *)(a1 + 1664) / 10.0);
  if (*(_DWORD *)(a1 + 40) == 12 && !*(_BYTE *)(a1 + 536) || v28 <= *(double *)(a1 + 528))
  {
    int v34 = 0;
  }

  else
  {
    sub_100F5AC28(a1);
    int v34 = 1;
  }

  if (qword_101934620 != -1) {
    dispatch_once(&qword_101934620, &stru_10188E348);
  }
  int v35 = (os_log_s *)qword_101934628;
  if (os_log_type_enabled((os_log_t)qword_101934628, OS_LOG_TYPE_DEBUG))
  {
    int v36 = "NOT ";
    if (v34) {
      int v36 = "";
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136315394;
    int v47 = v36;
    __int16 v48 = 2048;
    double v49 = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "%sSubmitted session stats; session length, %f",
      buf,
      0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934620 != -1) {
      dispatch_once(&qword_101934620, &stru_10188E348);
    }
    int v39 = "NOT ";
    if (v34) {
      int v39 = "";
    }
    int v42 = 136315394;
    int v43 = v39;
    __int16 v44 = 2048;
    double v45 = v28;
    LODWORD(v41) = 22;
    int v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934628,  2LL,  "%sSubmitted session stats; session length, %f",
                    (const char *)&v42,
                    v41);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFitnessTrackingAWD::submitSessionStats()", "%s\n", v40);
  }

uint64_t sub_100F5C08C(uint64_t a1, unsigned int a2)
{
  if (a2 < 0xFFFFFFF3) {
    return 1LL;
  }
  else {
    return dword_1013B9118[a2 + 13];
  }
}

uint64_t sub_100F5C0B0(uint64_t a1)
{
  uint64_t result = ((double)(uint64_t)llround(*(double *)(a1 + 512) - *(double *)(a1 + 504)) / 60.0);
  if ((_DWORD)result)
  {
    if (result <= 0x3C)
    {
      unsigned int v2 = (unsigned __int16)result % 0xAu;
      if (v2) {
        return result - v2 + 10;
      }
    }

    else
    {
      return 70LL;
    }
  }

  return result;
}

void sub_100F5C12C(uint64_t a1)
{
}

void sub_100F5C170(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 496) = 0LL;
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 40) = sub_100F5C1E4(v6, a2, a3);
}

uint64_t sub_100F5C1E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 7LL;
  switch(a2)
  {
    case 0LL:
    case 8LL:
    case 10LL:
    case 13LL:
    case 25LL:
    case 26LL:
    case 33LL:
    case 34LL:
    case 36LL:
    case 37LL:
    case 38LL:
    case 39LL:
    case 40LL:
    case 41LL:
    case 42LL:
    case 43LL:
    case 44LL:
    case 45LL:
    case 46LL:
    case 47LL:
    case 48LL:
    case 49LL:
    case 50LL:
    case 51LL:
    case 52LL:
    case 53LL:
    case 54LL:
    case 55LL:
    case 56LL:
    case 57LL:
    case 58LL:
    case 59LL:
    case 60LL:
    case 61LL:
    case 62LL:
    case 63LL:
    case 64LL:
    case 65LL:
    case 66LL:
      return 0LL;
    case 1LL:
      if (a3 == 2) {
        unsigned int v4 = 3;
      }
      else {
        unsigned int v4 = 0;
      }
      BOOL v5 = a3 == 1;
      unsigned int v6 = 2;
      goto LABEL_28;
    case 2LL:
      if (a3 == 2) {
        unsigned int v4 = 5;
      }
      else {
        unsigned int v4 = 0;
      }
      BOOL v5 = a3 == 1;
      unsigned int v6 = 4;
      goto LABEL_28;
    case 3LL:
      if (a3 == 2) {
        unsigned int v4 = 7;
      }
      else {
        unsigned int v4 = 0;
      }
      BOOL v5 = a3 == 1;
      unsigned int v6 = 6;
      goto LABEL_28;
    case 5LL:
      return 6LL;
    case 6LL:
      return 14LL;
    case 7LL:
      return 19LL;
    case 9LL:
      return 8LL;
    case 11LL:
      return 10LL;
    case 12LL:
    case 35LL:
      return 9LL;
    case 14LL:
      return 1LL;
    case 15LL:
      return 3LL;
    case 16LL:
      return 2LL;
    case 17LL:
      return 5LL;
    case 18LL:
      return 4LL;
    case 19LL:
      BOOL v5 = a3 == 2;
      unsigned int v4 = 11;
      unsigned int v6 = 13;
LABEL_28:
      if (v5) {
        uint64_t result = v6;
      }
      else {
        uint64_t result = v4;
      }
      break;
    case 20LL:
    case 21LL:
      uint64_t result = 12LL;
      break;
    case 22LL:
      uint64_t result = 15LL;
      break;
    case 23LL:
      uint64_t result = 18LL;
      break;
    case 24LL:
      uint64_t result = 16LL;
      break;
    case 27LL:
      uint64_t result = 17LL;
      break;
    case 28LL:
      uint64_t result = 20LL;
      break;
    case 29LL:
      uint64_t result = 21LL;
      break;
    case 30LL:
      uint64_t result = 22LL;
      break;
    case 31LL:
      uint64_t result = 23LL;
      break;
    case 32LL:
      uint64_t result = 24LL;
      break;
    default:
      return result;
  }

  return result;
}

void sub_100F5C314(uint64_t a1)
{
  unsigned int v2 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5CD74;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_async(v2, block);
}

void sub_100F5C37C( uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, __int128 a11, int a12)
{
  int v22 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5C45C;
  block[3] = &unk_10188A2D0;
  block[4] = a1;
  int v24 = a2;
  int v25 = a3;
  int v26 = a4;
  int v27 = a5;
  int v28 = a6;
  int v29 = a7;
  float v30 = a9;
  float v31 = a10;
  int v32 = a8;
  __int128 v33 = a11;
  int v34 = a12;
  dispatch_sync(v22, block);
}

float sub_100F5C45C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 596) += *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v1 + 568) += *(_DWORD *)(a1 + 44);
  *(_DWORD *)(v1 + 572) += *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v1 + 584) += *(_DWORD *)(a1 + 52);
  *(_DWORD *)(v1 + 592) += *(_DWORD *)(a1 + 56);
  *(_DWORD *)(v1 + 588) += *(_DWORD *)(a1 + 60);
  *(float *)(v1 + 600) = *(float *)(a1 + 64) + *(float *)(v1 + 600);
  float result = *(float *)(a1 + 68) + *(float *)(v1 + 604);
  *(float *)(v1 + 604) = result;
  *(_DWORD *)(v1 + 576) += *(_DWORD *)(a1 + 72);
  *(_DWORD *)(v1 + 580) += *(_DWORD *)(a1 + 76);
  *(_DWORD *)(v1 + 608) += *(_DWORD *)(a1 + 80);
  *(_DWORD *)(v1 + 612) += *(_DWORD *)(a1 + 84);
  *(_DWORD *)(v1 + 624) += *(_DWORD *)(a1 + 88);
  *(_DWORD *)(v1 + 628) += *(_DWORD *)(a1 + 92);
  return result;
}

void sub_100F5C544(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5C5B4;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5C5B4(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 96LL) = *(_DWORD *)(result + 40);
  return result;
}

void sub_100F5C5C4(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5C634;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5C634(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 112LL) = *(_DWORD *)(result + 40);
  return result;
}

void sub_100F5C644(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5C6B4;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5C6B4(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 128LL) = *(_DWORD *)(result + 40);
  return result;
}

void sub_100F5C6C4(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5C734;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5C734(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 132LL) = *(_DWORD *)(result + 40);
  return result;
}

int32x2_t sub_100F5C744(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1192) && *(_BYTE *)(a1 + 1193) && *(_BYTE *)(a1 + 1194))
  {
    if (*(_DWORD *)(a1 + 40) == 1)
    {
      sub_100F5C7B4(a1);
    }

    else
    {
      sub_100F5B9B0(a1);
      return sub_100F5A88C(a1);
    }
  }

  return result;
}

void sub_100F5C7B4(uint64_t a1)
{
  unsigned int v2 = *(dispatch_source_s **)(a1 + 1576);
  if (!v2)
  {
    float v3 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(a1 + 480));
    *(void *)(a1 + 1576) = v3;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = nullsub_1180;
    handler[3] = &unk_10181D3D0;
    handler[4] = a1;
    dispatch_source_set_event_handler(v3, handler);
    unsigned int v2 = *(dispatch_source_s **)(a1 + 1576);
  }

  dispatch_time_t v4 = dispatch_time(0LL, 30000000000LL);
  dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  dispatch_resume(*(dispatch_object_t *)(a1 + 1576));
}

void sub_100F5C878(uint64_t a1)
{
  unsigned int v2 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5C8E0;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_sync(v2, block);
}

int32x2_t sub_100F5C8E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_BYTE *)(v1 + 1192) = 1;
  return sub_100F5C744(v1);
}

void sub_100F5C8F0(uint64_t a1)
{
  unsigned int v2 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5C958;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_sync(v2, block);
}

int32x2_t sub_100F5C958(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_BYTE *)(v1 + 1193) = 1;
  return sub_100F5C744(v1);
}

void sub_100F5C968(uint64_t a1)
{
  unsigned int v2 = *(dispatch_source_s **)(a1 + 1576);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 1576));
    *(void *)(a1 + 1576) = 0LL;
  }

void sub_100F5C9A8(uint64_t a1, __int128 *a2)
{
  block[1] = 3221225472LL;
  __int128 v4 = a2[3];
  __int128 v11 = a2[2];
  __int128 v12 = v4;
  __int128 v5 = a2[5];
  __int128 v13 = a2[4];
  __int128 v14 = v5;
  __int128 v6 = a2[1];
  __int128 v9 = *a2;
  float v7 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[2] = sub_100F5CA30;
  block[3] = &unk_101879548;
  block[4] = a1;
  __int128 v10 = v6;
  dispatch_sync(v7, block);
}

__n128 sub_100F5CA30(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  __int128 v2 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v1 + 1216) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v1 + 1200) = v2;
  __n128 result = *(__n128 *)(a1 + 72);
  __int128 v4 = *(_OWORD *)(a1 + 88);
  __int128 v5 = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(v1 + 1280) = *(_OWORD *)(a1 + 120);
  *(_OWORD *)(v1 + 1264) = v5;
  *(_OWORD *)(v1 + 1248) = v4;
  *(__n128 *)(v1 + 1232) = result;
  return result;
}

void sub_100F5CA68(uint64_t a1, float a2)
{
  __int128 v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5CAE0;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  float v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5CAE0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  double v2 = *(float *)(result + 40);
  int v3 = *(_DWORD *)(v1 + 1296);
  *(_DWORD *)(v1 + 1296) = v3 + 1;
  if (v3)
  {
    double v4 = *(double *)(v1 + 1304);
    double v5 = v2 - v4;
    double v6 = v4 + (v2 - v4) / (double)(v3 + 1);
    double v7 = *(double *)(v1 + 1312) + v5 * (v2 - v6);
    *(double *)(v1 + 1304) = v6;
    *(double *)(v1 + 1312) = v7;
  }

  else
  {
    *(double *)(v1 + 1304) = v2;
    *(void *)(v1 + 1312) = 0LL;
  }

  return result;
}

void sub_100F5CB34(uint64_t a1, int a2)
{
  double v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5CBA4;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5CBA4(uint64_t result)
{
  uint64_t v1 = *(_DWORD **)(result + 32);
  switch(*(_DWORD *)(result + 40))
  {
    case 1:
      ++v1[166];
      break;
    case 2:
      ++v1[169];
      break;
    case 3:
      ++v1[167];
      break;
    case 4:
      ++v1[168];
      break;
    case 5:
      ++v1[170];
      break;
    default:
      return result;
  }

  return result;
}

void sub_100F5CC20(uint64_t a1, uint64_t a2)
{
  double v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5CC8C;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  void v5[5] = a2;
  dispatch_sync(v4, v5);
}

__n128 sub_100F5CC8C(uint64_t a1)
{
  uint64_t v1 = *(__n128 **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  v1[16].n128_u64[0] = *(void *)(v2 + 16);
  v1[16].n128_u32[2] = *(_DWORD *)(v2 + 24);
  v1[16].n128_u32[3] = *(_DWORD *)(v2 + 28);
  __n128 result = *(__n128 *)(v2 + 36);
  v1[17] = result;
  v1[18].n128_u32[0] = *(_DWORD *)(v2 + 52);
  return result;
}

void sub_100F5CCBC(uint64_t a1, uint64_t a2)
{
  double v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5CD28;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  void v5[5] = a2;
  dispatch_sync(v4, v5);
}

__n128 sub_100F5CD28(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 32) + 1320LL;
  __int128 v3 = *(_OWORD *)(v1 + 112);
  __int128 v5 = *(_OWORD *)(v1 + 64);
  __int128 v4 = *(_OWORD *)(v1 + 80);
  *(_OWORD *)(v2 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(v2 + 112) = v3;
  *(_OWORD *)(v2 + 64) = v5;
  *(_OWORD *)(v2 + 80) = v4;
  __int128 v6 = *(_OWORD *)(v1 + 176);
  __int128 v8 = *(_OWORD *)(v1 + 128);
  __int128 v7 = *(_OWORD *)(v1 + 144);
  *(_OWORD *)(v2 + 160) = *(_OWORD *)(v1 + 160);
  *(_OWORD *)(v2 + 176) = v6;
  *(_OWORD *)(v2 + 128) = v8;
  *(_OWORD *)(v2 + 144) = v7;
  __int128 v9 = *(_OWORD *)(v1 + 240);
  __int128 v11 = *(_OWORD *)(v1 + 192);
  __int128 v10 = *(_OWORD *)(v1 + 208);
  *(_OWORD *)(v2 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(v2 + 240) = v9;
  *(_OWORD *)(v2 + 192) = v11;
  *(_OWORD *)(v2 + 208) = v10;
  __n128 result = *(__n128 *)v1;
  __int128 v13 = *(_OWORD *)(v1 + 16);
  __int128 v14 = *(_OWORD *)(v1 + 48);
  *(_OWORD *)(v2 + 32) = *(_OWORD *)(v1 + 32);
  *(_OWORD *)(v2 + 48) = v14;
  *(__n128 *)uint64_t v2 = result;
  *(_OWORD *)(v2 + 16) = v13;
  return result;
}

void sub_100F5CD74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (const __CFBoolean *)CFPreferencesCopyValue( @"EnableAutoPause",  @"com.apple.nanolifestyle.sessiontrackerapp",  @"mobile",  kCFPreferencesAnyHost);
  if (v2)
  {
    __int128 v3 = v2;
    *(_BYTE *)(v1 + 688) = CFBooleanGetValue(v2) != 0;
    CFRelease(v3);
  }

void sub_100F5CDE0(uint64_t a1, __int128 *a2)
{
  block[1] = 3221225472LL;
  __int128 v4 = a2[10];
  __int128 v25 = a2[11];
  __int128 v5 = a2[13];
  __int128 v26 = a2[12];
  __int128 v27 = v5;
  __int128 v6 = a2[6];
  __int128 v21 = a2[7];
  __int128 v7 = a2[9];
  __int128 v22 = a2[8];
  __int128 v23 = v7;
  __int128 v24 = v4;
  __int128 v8 = a2[2];
  __int128 v9 = a2[4];
  __int128 v10 = a2[5];
  __int128 v17 = a2[3];
  __int128 v18 = v9;
  __int128 v19 = v10;
  __int128 v20 = v6;
  __int128 v11 = a2[1];
  __int128 v14 = *a2;
  __int128 v15 = v11;
  __int128 v12 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[2] = sub_100F5CED8;
  block[3] = &unk_1018598D8;
  block[4] = a1;
  uint64_t v28 = *((void *)a2 + 28);
  __int128 v16 = v8;
  dispatch_sync(v12, block);
}

void sub_100F5CED8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 56);
  if ((v4 & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    uint64_t v5 = *(void *)(v3 + 944);
    double v1 = *(double *)(v3 + 952);
    __int128 v6 = *(_OWORD *)(a1 + 56);
    __int128 v7 = *(_OWORD *)(a1 + 72);
    *(_OWORD *)(v3 + 928) = *(_OWORD *)(a1 + 40);
    *(_OWORD *)(v3 + 960) = v7;
    __int128 v8 = *(_OWORD *)(a1 + 104);
    __int128 v9 = *(_OWORD *)(a1 + 136);
    __int128 v10 = *(_OWORD *)(a1 + 88);
    *(_OWORD *)(v3 + 1008) = *(_OWORD *)(a1 + 120);
    *(_OWORD *)(v3 + 1024) = v9;
    *(_OWORD *)(v3 + 976) = v10;
    *(_OWORD *)(v3 + 992) = v8;
    __int128 v11 = *(_OWORD *)(a1 + 168);
    __int128 v12 = *(_OWORD *)(a1 + 184);
    __int128 v13 = *(_OWORD *)(a1 + 200);
    *(_OWORD *)(v3 + 1040) = *(_OWORD *)(a1 + 152);
    *(_OWORD *)(v3 + 1088) = v13;
    *(_OWORD *)(v3 + 1072) = v12;
    *(_OWORD *)(v3 + 1056) = v11;
    __int128 v14 = *(_OWORD *)(a1 + 232);
    __int128 v15 = *(_OWORD *)(a1 + 248);
    uint64_t v16 = *(void *)(a1 + 264);
    *(_OWORD *)(v3 + 1104) = *(_OWORD *)(a1 + 216);
    *(void *)(v3 + 1152) = v16;
    *(_OWORD *)(v3 + 1136) = v15;
    *(_OWORD *)(v3 + 1120) = v14;
    *(_OWORD *)(v3 + 944) = v6;
  }

  else
  {
    uint64_t v5 = 23LL;
  }

  switch(v4)
  {
    case 0LL:
      if (uuid_is_null((const unsigned __int8 *)(v3 + 632))
        || uuid_compare((const unsigned __int8 *)(v3 + 632), (const unsigned __int8 *)(a1 + 104)))
      {
        if (sub_1008FA854(0))
        {
          uint64_t v17 = sub_1008FA854(0);
          sub_1006DCB40(v17, 30, *(void *)(v3 + 1648), -1.0);
        }

        sub_100F5C968(v3);
        sub_100F5C744(v3);
        uuid_copy((unsigned __int8 *)(v3 + 632), (const unsigned __int8 *)(a1 + 104));
        *(void *)(v3 + 504) = *(void *)(a1 + 64);
        *(_BYTE *)(v3 + 539) = *(_BYTE *)(v3 + 538);
        sub_100F5C170(v3, *(void *)(a1 + 152), *(void *)(a1 + 160));
      }

      break;
    case 1LL:
      if (!uuid_compare((const unsigned __int8 *)(v3 + 632), (const unsigned __int8 *)(a1 + 104)))
      {
        if (sub_1008FA854(0))
        {
          uint64_t v18 = sub_1008FA854(0);
          sub_1006DD2A0(v18, 30, *(void *)(v3 + 1648));
        }

        *(_BYTE *)(v3 + 1194) = 1;
        *(void *)(v3 + 512) = *(void *)(a1 + 64);
        sub_100F5C744(v3);
      }

      break;
    case 2LL:
      ++*(_DWORD *)(v3 + 300);
      if (v5 == 3)
      {
        uint64_t v20 = *(void *)(v3 + 1168);
        double v21 = *(double *)(a1 + 64) - v1;
        __int128 v22 = &v21;
        uint64_t v23 = v20;
        __int128 v24 = &v22;
        sub_100F5DD84(v20, &v24);
      }

      else if (v5 == 2)
      {
        uint64_t v19 = *(void *)(v3 + 1160);
        goto LABEL_23;
      }

      break;
    case 3LL:
      ++*(_DWORD *)(v3 + 296);
      if (v5 == 3)
      {
        uint64_t v19 = *(void *)(v3 + 1184);
      }

      else
      {
        if (v5 != 2) {
          return;
        }
        uint64_t v19 = *(void *)(v3 + 1176);
      }

void sub_100F5D168(uint64_t a1)
{
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5D1D0;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_sync(v2, block);
}

uint64_t sub_100F5D1D0(uint64_t result)
{
  return result;
}

void sub_100F5D1E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5D250;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  void v5[5] = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5D250(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 616LL) += *(_DWORD *)(result + 40);
  return result;
}

void sub_100F5D268(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5D2D4;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  void v5[5] = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5D2D4(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 620LL) += *(_DWORD *)(result + 40);
  return result;
}

void *sub_100F5D2EC()
{
  unsigned __int8 v0 = operator new(0x98uLL);
  LODWORD(v6) = 18;
  int v2 = 2;
  uint64_t v3 = (double ***)&v6;
  uint64_t v4 = v0;
  uint64_t v5 = &v2;
  sub_100F5DFE8((int **)&v3, (uint64_t)v0);
  uint64_t v3 = (double ***)&unk_1013B90A0;
  uint64_t v4 = v0;
  __int128 v6 = &v3;
  sub_100F5DD84((uint64_t)v0, (double ***)&v6);
  uint64_t v3 = (double ***)&unk_1013B90A8;
  uint64_t v4 = v0;
  __int128 v6 = &v3;
  sub_100F5DD84((uint64_t)v0, (double ***)&v6);
  return v0;
}

void sub_100F5D38C(_Unwind_Exception *a1)
{
}

void sub_100F5D3A0(void *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v20 = a2;
  uint64_t v20 = (unint64_t *)sub_100F5E54C((uint64_t)(a2 + 3), &v20);
  double v21 = v4;
  if (v20 != v4)
  {
    unint64_t v5 = 0LL;
    double v6 = (double)v3;
    __int128 v7 = (void **)(a1 + 39);
    do
    {
      unsigned int v8 = (*(double *)(sub_100F5D4EC(&v20, v5) + 8) * v6);
      __int128 v10 = (unsigned int *)a1[40];
      unint64_t v9 = a1[41];
      if ((unint64_t)v10 >= v9)
      {
        __int128 v12 = (unsigned int *)*v7;
        uint64_t v13 = ((char *)v10 - (_BYTE *)*v7) >> 2;
        unint64_t v14 = v13 + 1;
        uint64_t v15 = v9 - (void)v12;
        if (v15 >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          uint64_t v17 = (char *)sub_10000956C((uint64_t)(a1 + 41), v16);
          __int128 v12 = (unsigned int *)a1[39];
          __int128 v10 = (unsigned int *)a1[40];
        }

        else
        {
          uint64_t v17 = 0LL;
        }

        uint64_t v18 = (unsigned int *)&v17[4 * v13];
        *uint64_t v18 = v8;
        __int128 v11 = v18 + 1;
        while (v10 != v12)
        {
          unsigned int v19 = *--v10;
          *--uint64_t v18 = v19;
        }

        a1[39] = v18;
        a1[40] = v11;
        a1[41] = &v17[4 * v16];
        if (v12) {
          operator delete(v12);
        }
      }

      else
      {
        *__int128 v10 = v8;
        __int128 v11 = v10 + 1;
      }

      a1[40] = v11;
      ++v5;
    }

    while (v5 < ((char *)v21 - (char *)v20) >> 4);
  }

uint64_t sub_100F5D4EC(void *a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000LL) != 0) {
    sub_101279660();
  }
  return *a1 + 16 * a2;
}

void sub_100F5D51C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(void *)&double v2 = objc_opt_class(&OBJC_CLASS___MCProfileConnection).n128_u64[0];
  if (v3)
  {
    unsigned int v4 = objc_msgSend( +[MCProfileConnection sharedConnection]( MCProfileConnection,  "sharedConnection",  v2),  "isWheelchairDataSubmissionAllowed");
    *(_BYTE *)(v1 + 536) = v4;
    if (v4) {
      return;
    }
  }

  else if (*(_BYTE *)(v1 + 536))
  {
    return;
  }

  uint64_t v5 = sub_1006E27E8();
  sub_100413284(v5, &v9);
  sub_1002A6F64(v9, "EnableWheelchairAWDCollection", (BOOL *)(v1 + 536));
  double v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100F5D5D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F5D5E4(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5D654;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5D654(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 648LL) = *(unsigned int *)(result + 40);
  return result;
}

void sub_100F5D664(uint64_t a1, int a2)
{
  unsigned int v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5D6D4;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  int v6 = a2;
  dispatch_sync(v4, v5);
}

uint64_t sub_100F5D6D4(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 656LL) = *(unsigned int *)(result + 40);
  return result;
}

void sub_100F5D6E4(uint64_t a1, __int128 *a2)
{
  block[1] = 3221225472LL;
  __int128 v4 = a2[1];
  __int128 v8 = *a2;
  __int128 v9 = v4;
  __int128 v5 = a2[3];
  __int128 v10 = a2[2];
  int v6 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[2] = sub_100F5D764;
  block[3] = &unk_10184DA38;
  block[4] = a1;
  __int128 v11 = v5;
  dispatch_sync(v6, block);
}

__n128 sub_100F5D764(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_OWORD *)(v1 + 360) = *(_OWORD *)(a1 + 44);
  *(_OWORD *)(v1 + 376) = *(_OWORD *)(a1 + 60);
  __n128 result = *(__n128 *)(a1 + 76);
  *(__n128 *)(v1 + 392) = result;
  *(_DWORD *)(v1 + 408) = *(_DWORD *)(a1 + 92);
  return result;
}

void sub_100F5D790(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4)
{
  block[1] = 3221225472LL;
  __int128 v8 = a3[10];
  __int128 v39 = a3[11];
  __int128 v9 = a3[13];
  __int128 v40 = a3[12];
  __int128 v41 = v9;
  __int128 v10 = a3[6];
  __int128 v35 = a3[7];
  __int128 v11 = a3[9];
  __int128 v36 = a3[8];
  __int128 v37 = v11;
  __int128 v38 = v8;
  __int128 v12 = a3[2];
  __int128 v13 = a3[4];
  __int128 v14 = a3[5];
  __int128 v31 = a3[3];
  __int128 v32 = v13;
  __int128 v33 = v14;
  __int128 v34 = v10;
  __int128 v15 = a3[1];
  __int128 v28 = *a3;
  unint64_t v16 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[2] = sub_100F5D940;
  block[3] = &unk_10188E308;
  block[4] = a1;
  uint64_t v42 = *((void *)a3 + 28);
  __int128 v29 = v15;
  __int128 v30 = v12;
  __int128 v17 = a4[13];
  __int128 v55 = a4[12];
  __int128 v56 = v17;
  uint64_t v18 = *((void *)a4 + 28);
  __int128 v19 = a4[9];
  __int128 v51 = a4[8];
  __int128 v52 = v19;
  __int128 v20 = a4[10];
  __int128 v54 = a4[11];
  __int128 v53 = v20;
  __int128 v21 = a4[5];
  __int128 v47 = a4[4];
  __int128 v48 = v21;
  __int128 v22 = a4[6];
  __int128 v50 = a4[7];
  __int128 v49 = v22;
  __int128 v23 = a4[1];
  __int128 v43 = *a4;
  __int128 v44 = v23;
  __int128 v24 = a4[2];
  __int128 v46 = a4[3];
  __int128 v45 = v24;
  __int128 v25 = a2[1];
  __int128 v58 = *a2;
  __int128 v59 = v25;
  uint64_t v26 = *((void *)a2 + 4);
  uint64_t v57 = v18;
  uint64_t v60 = v26;
  dispatch_sync(v16, block);
}

double sub_100F5D940(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = sub_100F5C1E4(a1, *(void *)(a1 + 152), *(void *)(a1 + 160));
  *(_DWORD *)(v2 + 416) = v3;
  *(_DWORD *)(v2 + 420) = sub_100F5C1E4(v3, *(void *)(a1 + 384), *(void *)(a1 + 392));
  *(_WORD *)(v2 + 412) = *(_WORD *)(a1 + 504);
  double result = *(double *)(a1 + 520);
  uint64_t v5 = *(void *)(a1 + 528);
  *(double *)(v2 + 440) = result;
  *(void *)(v2 + 448) = v5;
  *(_DWORD *)(v2 + 456) = *(_DWORD *)(a1 + 536);
  return result;
}

void sub_100F5D994(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5DA10;
  block[3] = &unk_101830558;
  block[4] = a1;
  void block[5] = a2;
  void block[6] = a3;
  dispatch_sync(v6, block);
}

void *sub_100F5DA10(void *result)
{
  uint64_t v1 = result[4];
  *(void *)(v1 + 424) = result[5];
  *(void *)(v1 + 432) = result[6];
  return result;
}

void sub_100F5DA24(uint64_t a1, double a2, double a3, double a4, double a5)
{
  __int128 v10 = *(dispatch_queue_s **)(a1 + 480);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100F5DAB4;
  block[3] = &unk_10182D1B8;
  block[4] = a1;
  *(double *)&void block[5] = a2;
  *(double *)&void block[6] = a3;
  *(double *)&void block[7] = a5;
  *(double *)&block[8] = a4;
  dispatch_async(v10, block);
}

double sub_100F5DAB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double result = *(double *)(v1 + 504);
  if (result != 1.79769313e308)
  {
    if (*(double *)(v1 + 1592) == 1.79769313e308)
    {
      *(void *)(v1 + 1592) = *(void *)(a1 + 40);
      *(void *)(v1 + 1608) = *(void *)(a1 + 48);
    }

    *(void *)(v1 + 1600) = *(void *)(a1 + 40);
    *(void *)(v1 + 1616) = *(void *)(a1 + 48);
    double result = *(double *)(a1 + 56);
    if (result > -1.0)
    {
      double result = *(double *)(a1 + 64);
      *(double *)(v1 + 1632) = result;
    }
  }

  return result;
}

float sub_100F5DB34(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  float v2 = *(float *)(a1 + 40);
  *(float *)(v1 + 1644) = v2;
  unsigned int v3 = *(_DWORD *)(v1 + 1668);
  float v4 = v2 + (float)(*(float *)(v1 + 1664) * (float)v3++);
  float result = v4 / (float)v3;
  *(float *)(v1 + 1664) = result;
  *(_DWORD *)(v1 + 1668) = v3;
  return result;
}

void sub_100F5DB94(uint64_t a1, float a2)
{
  float v4 = *(dispatch_queue_s **)(a1 + 480);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F5DC0C;
  v5[3] = &unk_10182B540;
  v5[4] = a1;
  float v6 = a2;
  dispatch_async(v4, v5);
}

uint64_t sub_100F5DC0C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  int v2 = *(_DWORD *)(result + 40);
  else {
    *(_DWORD *)(v1 + 1660) = v2;
  }
  return result;
}

void *sub_100F5DC38(void *a1)
{
  int v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }

  unsigned int v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }

  float v4 = (void *)a1[7];
  if (v4)
  {
    a1[8] = v4;
    operator delete(v4);
  }

  uint64_t v5 = (void *)a1[3];
  if (v5)
  {
    a1[4] = v5;
    operator delete(v5);
  }

  return a1;
}

void *sub_100F5DC98(void *a1)
{
  int v2 = (void *)a1[12];
  if (v2)
  {
    a1[13] = v2;
    operator delete(v2);
  }

  unsigned int v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }

  float v4 = (void *)a1[6];
  if (v4)
  {
    a1[7] = v4;
    operator delete(v4);
  }

  uint64_t v5 = (void *)a1[2];
  if (v5)
  {
    a1[3] = v5;
    operator delete(v5);
  }

  return a1;
}

void *sub_100F5DCF8(void *a1)
{
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }

  unsigned int v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }

  float v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }

  uint64_t v5 = (void *)a1[1];
  if (v5)
  {
    a1[2] = v5;
    operator delete(v5);
  }

  return a1;
}

void sub_100F5DD58(id a1)
{
  qword_101934628 = (uint64_t)os_log_create("com.apple.locationd.Motion", "AWD");
}

double sub_100F5DD84(uint64_t a1, double ***a2)
{
  int v2 = *a2;
  ++*(void *)a1;
  unsigned int v3 = *v2;
  double v4 = **v2;
  if (v4 < *(double *)(a1 + 8))
  {
    *(double *)(a1 + 8) = v4;
    double v4 = *v3;
  }

  return sub_100F5DDC8((uint64_t *)(a1 + 24), (uint64_t)v2);
}

double sub_100F5DDC8(uint64_t *a1, uint64_t a2)
{
  *((_BYTE *)a1 + 112) = 1;
  int v2 = *(double **)(a2 + 8);
  double v3 = *v2;
  uint64_t v4 = *a1;
  v5.i64[0] = **(void **)a2;
  if (*(void *)v2 <= (unint64_t)*a1)
  {
    __int128 v8 = (double *)a1[1];
    v8[*(void *)&v3 - 1] = *(double *)v5.i64;
    if (*(void *)&v3 == v4)
    {
      unint64_t v9 = a1[4];
      if (v9 != -2LL)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = *((uint64_t *)v2 + 1);
        *(double *)&uint64_t v12 = (v2[2] - *(double *)&v11) / (double)v9;
        uint64_t v13 = a1[8];
        uint64x2_t v5 = (uint64x2_t)vdupq_n_s64(v9 + 1);
        int64x2_t v14 = (int64x2_t)xmmword_1012CB1D0;
        int64x2_t v15 = vdupq_n_s64(2uLL);
        float64x2_t v16 = (float64x2_t)vdupq_lane_s64(v12, 0);
        float64x2_t v17 = (float64x2_t)vdupq_lane_s64(v11, 0);
        __asm { FMOV            V5.2D, #-1.0 }

        do
        {
          uint64_t v23 = v10 + 1;
          v24.i64[0] = v10;
          v24.i64[1] = v10 + 1;
          int32x2_t v25 = vmovn_s64((int64x2_t)vcgeq_u64(v5, (uint64x2_t)v14));
          float64x2_t v26 = vmlaq_f64(v17, v16, vaddq_f64(vcvtq_f64_u64(v24), _Q5));
          if ((v25.i8[0] & 1) != 0) {
            *(float64_t *)(v13 + 8 * v10) = v26.f64[0];
          }
          if ((v25.i8[4] & 1) != 0) {
            *(float64_t *)(v13 + 8 * v10 + 8) = v26.f64[1];
          }
          int64x2_t v14 = vaddq_s64(v14, v15);
          v10 += 2LL;
        }

        while (v23 + 1 != ((v9 + 3) & 0xFFFFFFFFFFFFFFFELL));
      }

      __int128 v27 = (double *)a1[2];
      if (v8 != v27)
      {
        __int128 v28 = (double *)a1[8];
        unint64_t v29 = v9 + 1;
        v5.i64[0] = 1.0;
        do
        {
          double v30 = *v8;
          if (*v8 >= v28[1])
          {
            if (v30 >= v28[v29])
            {
              __int128 v31 = (double *)(a1[5] + 8 * v29);
            }

            else
            {
              __int128 v32 = (double *)a1[9];
              if (v32 != v28)
              {
                unint64_t v33 = v32 - v28;
                __int128 v32 = v28;
                do
                {
                  unint64_t v34 = v33 >> 1;
                  __int128 v35 = &v32[v33 >> 1];
                  double v37 = *v35;
                  __int128 v36 = v35 + 1;
                  v33 += ~(v33 >> 1);
                  if (v30 < v37) {
                    unint64_t v33 = v34;
                  }
                  else {
                    __int128 v32 = v36;
                  }
                }

                while (v33);
              }

              __int128 v31 = (double *)((char *)v32 - (char *)v28 + a1[5] - 8);
            }
          }

          else
          {
            __int128 v31 = (double *)a1[5];
          }

          *__int128 v31 = *v31 + 1.0;
          ++v8;
        }

        while (v8 != v27);
      }
    }
  }

  else
  {
    float v6 = (double *)a1[8];
    if (*(double *)v5.i64 >= v6[1])
    {
      uint64_t v38 = a1[4] + 1;
      if (*(double *)v5.i64 >= v6[v38])
      {
        __int128 v7 = (double *)(a1[5] + 8 * v38);
      }

      else
      {
        __int128 v39 = (double *)a1[9];
        if (v39 != v6)
        {
          unint64_t v40 = v39 - v6;
          __int128 v39 = (double *)a1[8];
          do
          {
            unint64_t v41 = v40 >> 1;
            uint64_t v42 = &v39[v40 >> 1];
            double v44 = *v42;
            __int128 v43 = v42 + 1;
            v40 += ~(v40 >> 1);
            else {
              __int128 v39 = v43;
            }
          }

          while (v40);
        }

        __int128 v7 = (double *)((char *)v39 - (char *)v6 + a1[5] - 8);
      }
    }

    else
    {
      __int128 v7 = (double *)a1[5];
    }

    *(double *)v5.i64 = *v7 + 1.0;
    *__int128 v7 = *(double *)v5.i64;
  }

  return *(double *)v5.i64;
}

void sub_100F5DFE8(int **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(_OWORD *)(a2 + 8) = v3;
  sub_100F5E3C4(a2 + 24, (uint64_t)&v4);
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }

  if (v9)
  {
    uint64_t v10 = v9;
    operator delete(v9);
  }

  if (v7)
  {
    __int128 v8 = v7;
    operator delete(v7);
  }

  if (v5)
  {
    float v6 = v5;
    operator delete(v5);
  }

void sub_100F5E074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F5E088(int **a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = v4;
  *a2 = 0x7FEFFFFFFFFFFFFFLL;
  a2[1] = v3;
  sub_100F5E3C4((uint64_t)(a2 + 2), (uint64_t)&v5);
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }

  if (v10)
  {
    uint64_t v11 = v10;
    operator delete(v10);
  }

  if (v8)
  {
    unint64_t v9 = v8;
    operator delete(v8);
  }

  if (v6)
  {
    __int128 v7 = v6;
    operator delete(v6);
  }

void sub_100F5E114(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F5E128(int **a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xFFEFFFFFFFFFFFFFLL;
  sub_100F5E3C4((uint64_t)(a2 + 1), (uint64_t)v3);
  if (__p)
  {
    uint64_t v11 = __p;
    operator delete(__p);
  }

  if (v8)
  {
    unint64_t v9 = v8;
    operator delete(v8);
  }

  if (v6)
  {
    __int128 v7 = v6;
    operator delete(v6);
  }

  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }

void sub_100F5E1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F5E1C0(int **a1@<X0>, uint64_t a2@<X8>)
{
  if (__p)
  {
    uint64_t v11 = __p;
    operator delete(__p);
  }

  if (v8)
  {
    unint64_t v9 = v8;
    operator delete(v8);
  }

  if (v6)
  {
    __int128 v7 = v6;
    operator delete(v6);
  }

  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }

void sub_100F5E23C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F5E250(uint64_t a1, int **a2)
{
  unint64_t v4 = *a2[2];
  *(void *)a1 = v4;
  sub_1000071F0((void *)(a1 + 8), v4);
  uint64_t v5 = **a2;
  *(void *)(a1 + 32) = v5;
  *(void *)&__int128 v8 = 0LL;
  sub_1000070FC((void *)(a1 + 40), v5 + 2, &v8);
  sub_1000071F0((void *)(a1 + 64), *(void *)(a1 + 32) + 2LL);
  unint64_t v6 = *(void *)(a1 + 32) + 2LL;
  __int128 v8 = 0uLL;
  sub_100F5E344((void *)(a1 + 88), v6, &v8);
  *(_BYTE *)(a1 + 112) = 1;
  return a1;
}

void sub_100F5E2F4(_Unwind_Exception *exception_object)
{
  uint64_t v5 = v4;
  __int128 v7 = *v5;
  if (*v5)
  {
    v1[9] = v7;
    operator delete(v7);
  }

  __int128 v8 = *v3;
  if (*v3)
  {
    _OWORD v1[6] = v8;
    operator delete(v8);
  }

  unint64_t v9 = *v2;
  if (*v2)
  {
    v1[2] = v9;
    operator delete(v9);
  }

  _Unwind_Resume(exception_object);
}

void *sub_100F5E344(void *a1, unint64_t a2, _OWORD *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10005782C(a1, a2);
    unint64_t v6 = (_OWORD *)a1[1];
    __int128 v7 = &v6[a2];
    uint64_t v8 = 16 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 16LL;
    }

    while (v8);
    a1[1] = v7;
  }

  return a1;
}

void sub_100F5E3A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100F5E3C4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  sub_100007590( (void *)(a1 + 8),  *(const void **)(a2 + 8),  *(void *)(a2 + 16),  (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  sub_100007590( (void *)(a1 + 40),  *(const void **)(a2 + 40),  *(void *)(a2 + 48),  (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3);
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  sub_100007590( (void *)(a1 + 64),  *(const void **)(a2 + 64),  *(void *)(a2 + 72),  (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3);
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  sub_100F5E4DC( (char *)(a1 + 88),  *(__int128 **)(a2 + 88),  *(__int128 **)(a2 + 96),  (uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 4);
  *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
  return a1;
}

void sub_100F5E490(_Unwind_Exception *exception_object)
{
  unint64_t v6 = *v4;
  if (*v4)
  {
    v1[9] = v6;
    operator delete(v6);
  }

  __int128 v7 = *v3;
  if (*v3)
  {
    _OWORD v1[6] = v7;
    operator delete(v7);
  }

  uint64_t v8 = *v2;
  if (*v2)
  {
    v1[2] = v8;
    operator delete(v8);
  }

  _Unwind_Resume(exception_object);
}

char *sub_100F5E4DC(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    float result = sub_10005782C(result, a4);
    __int128 v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int128 v8 = *a2++;
      *v7++ = v8;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_100F5E530(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100F5E54C(uint64_t a1, unint64_t **a2)
{
  if (*(_BYTE *)(a1 + 112))
  {
    *(_BYTE *)(a1 + 112) = 0;
    uint64_t v2 = *(void *)(a1 + 32) + 2LL;
    if (*(void *)(a1 + 32) != -2LL)
    {
      uint64_t v3 = *(uint64_t **)(a1 + 64);
      uint64_t v4 = *(double **)(a1 + 40);
      double v5 = (double)**a2;
      unint64_t v6 = (double *)(*(void *)(a1 + 88) + 8LL);
      do
      {
        double v7 = *v4++;
        double v8 = v7;
        uint64_t v9 = *v3++;
        *((void *)v6 - 1) = v9;
        *unint64_t v6 = v8 / v5;
        v6 += 2;
        --v2;
      }

      while (v2);
    }
  }

  return *(void *)(a1 + 88);
}

uint64_t sub_100F5E5A8(uint64_t a1, int a2, __int128 *a3)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 16) = 2139095039;
  *(void *)(a1 + 24) = 0LL;
  *(_DWORD *)(a1 + 32) = 2139095039;
  *(_DWORD *)(a1 + 40) = -1;
  *(_DWORD *)(a1 + 44) = a2;
  uint64_t v4 = a1 + 48;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)v4, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v5 = *a3;
    *(void *)(v4 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }

  return a1;
}

uint64_t sub_100F5E614()
{
  qword_10199F6C0 = 0LL;
  qword_10199F6C8 = 0LL;
  qword_10199F6D0 = 0LL;
  unsigned __int8 v0 = operator new(0x5CuLL);
  qword_10199F6C8 = (uint64_t)v0 + 92;
  qword_10199F6D0 = (uint64_t)v0 + 92;
  v0[2] = xmmword_1013B916C;
  v0[3] = unk_1013B917C;
  v0[4] = xmmword_1013B918C;
  *(_OWORD *)((char *)v0 + 76) = *(__int128 *)((char *)&xmmword_1013B918C + 12);
  *unsigned __int8 v0 = xmmword_1013B914C;
  v0[1] = unk_1013B915C;
  qword_10199F6C0 = (uint64_t)v0;
  return __cxa_atexit((void (*)(void *))sub_1001B4198, &qword_10199F6C0, (void *)&_mh_execute_header);
}

void *sub_100F5E690(void *a1, uint64_t *a2)
{
  uint64_t v3 = sub_10101B9AC(a1, a2);
  *uint64_t v3 = off_10188E3C8;
  v3[11] = 0LL;
  v3[12] = 0LL;
  int64x2_t v4 = vdupq_n_s64(0x7FF8000000000000uLL);
  *(int64x2_t *)(v3 + 13) = v4;
  v3[15] = 0xBFF0000000000000LL;
  v3[16] = 0LL;
  *(int64x2_t *)(v3 + 17) = v4;
  v3[19] = 0xBFF0000000000000LL;
  v3[20] = 0LL;
  *(int64x2_t *)(v3 + 21) = v4;
  v3[23] = 0xBFF0000000000000LL;
  v3[24] = 0LL;
  *(int64x2_t *)(v3 + 25) = v4;
  v3[27] = 0xBFF0000000000000LL;
  v3[28] = 0LL;
  sub_100F60AD4(v3 + 29);
  a1[31] = 0x4334000042820000LL;
  return a1;
}

void sub_100F5E734(_Unwind_Exception *a1)
{
  void *v1 = off_101868780;
  sub_10000AE14((uint64_t)(v1 + 1));
  _Unwind_Resume(a1);
}

uint64_t sub_100F5E764()
{
  return 1LL;
}

uint64_t sub_100F5E76C(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[1];
  __int128 v5 = (std::__shared_weak_count *)a1[2];
  uint64_t v18 = v4;
  __int128 v19 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t *__return_ptr, uint64_t, void *))(*(void *)v4 + 16LL))(&buf, v4, a1);
  sub_1000F2F30(a1 + 11, &buf);
  double v8 = v21;
  if (v21)
  {
    uint64_t v9 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v19)
  {
    uint64_t v11 = &v19->__shared_owners_;
    do
      unint64_t v12 = __ldaxr((unint64_t *)v11);
    while (__stlxr(v12 - 1, (unint64_t *)v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  uint64_t v13 = sub_100748210(a1[29], a1 + 11, a2);
  if ((v13 & 1) == 0)
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    int64x2_t v14 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Bouts FTP Estimator failed to setup cache",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10188E428);
      }
      LOWORD(v18) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Bouts FTP Estimator failed to setup cache",  &v18,  2);
      float64x2_t v17 = (char *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLCyclingFTPBoutBasedEstimateModel::setupFTP(const double, const double, const CLBodyMetrics &)",  "%s\n",  v16);
    }
  }

  return v13;
}

void sub_100F5E9D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100F5E9F0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    sub_100AE5528(v1);
  }
  return 1LL;
}

void sub_100F5EA10(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0x7FF8000000000000LL;
  *(_DWORD *)(a3 + 24) = 0;
  sub_100F5ED50(a2, 13, 0, (uint64_t)&v25);
  int v6 = (int)(v26 / 2.56);
  int v7 = v25;
  if (v25 <= v6) {
    int v8 = (int)(v26 / 2.56);
  }
  else {
    int v8 = v25;
  }
  int v9 = v28;
  BOOL v10 = v8 <= 0 || v28 <= 0;
  int v11 = !v10;
  if (v10)
  {
    *(void *)a3 = 0LL;
    *(_DWORD *)(a3 + 28) = 4;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    double v12 = v27 / (double)v8;
    *(double *)a3 = v12;
    *(_DWORD *)(a3 + 28) = 4;
    *(void *)(a3 + 16) = 0LL;
    if (v12 > 0.0)
    {
      if (v30 <= 0)
      {
        double v14 = 0.0;
      }

      else
      {
        float v13 = v29 / (double)v30;
        double v14 = v13;
      }

      double v20 = 0.0;
      if ((double)v30 / (double)v8 > 0.5)
      {
        float v21 = (*(float *)(a1 + 252) - v14) / (*(float *)(a1 + 252) - *(float *)(a1 + 248));
        float v22 = 1.0 - v21;
        if (v22 >= 1.0) {
          float v22 = 1.0;
        }
        double v20 = v22;
        if (v20 < 0.0) {
          double v20 = 0.0;
        }
      }

      *(double *)(a3 + 16) = v20;
      goto LABEL_35;
    }
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10188E428);
  }
  int64x2_t v15 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    double v16 = 0.0;
    if (v11) {
      double v16 = v27 / (double)v8;
    }
    *(_DWORD *)uint64_t buf = 134218752;
    double v40 = v16;
    __int16 v41 = 1024;
    int v42 = v6;
    __int16 v43 = 1024;
    int v44 = v7;
    __int16 v45 = 1024;
    int v46 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Not able to compute FTP for 60 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d, maxAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  buf,  0x1Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    double v17 = 0.0;
    if (v11) {
      double v17 = v27 / (double)v8;
    }
    int v31 = 134218752;
    double v32 = v17;
    __int16 v33 = 1024;
    int v34 = v6;
    __int16 v35 = 1024;
    int v36 = v7;
    __int16 v37 = 1024;
    int v38 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Not able to compute FTP for 60 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d, maxAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  COERCE_DOUBLE(&v31),  30,  v25,  LODWORD(v26));
    __int128 v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getFTPEstimateFor60Min(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void *sub_100F5ED50@<X0>(void *a1@<X1>, int a2@<W2>, int a3@<W3>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 56) = 0LL;
  *(_DWORD *)(a4 + 64) = 0;
  *(void *)(a4 + 8) = 0LL;
  *(void *)(a4 + 16) = 0LL;
  *(_DWORD *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0LL;
  *(void *)(a4 + 40) = 0LL;
  *(_DWORD *)(a4 + 48) = 0;
  *(void *)(a4 + 80) = 0LL;
  *(void *)(a4 + 88) = 0LL;
  *(void *)(a4 + 72) = 0LL;
  if (a3)
  {
    __int128 v5 = (char *)a1[8];
    int v6 = (char *)a1[9];
    if (v5 != v6)
    {
      int v7 = 0;
      int v8 = (double *)&v30[6 * a2];
      do
      {
        float result = memcpy(v30, v5, sizeof(v30));
        int v10 = (int)(*(double *)(a4 + 8) / 2.56);
        if (v7 > v10) {
          int v10 = v7;
        }
        double v11 = 0.0;
        BOOL v12 = v10 < 1 || *(_DWORD *)(a4 + 24) < 1;
        double v13 = 0.0;
        if (!v12) {
          double v13 = *(double *)(a4 + 16) / (double)v10;
        }
        int v14 = (int)(v8[1] / 2.56);
        if (*(_DWORD *)v8 > v14) {
          int v14 = *(_DWORD *)v8;
        }
        if (v13 < v11)
        {
          __int128 v15 = *((_OWORD *)v8 + 3);
          *(_OWORD *)(a4 + 32) = *((_OWORD *)v8 + 2);
          *(_OWORD *)(a4 + 48) = v15;
          __int128 v16 = *((_OWORD *)v8 + 5);
          *(_OWORD *)(a4 + 64) = *((_OWORD *)v8 + 4);
          *(_OWORD *)(a4 + 80) = v16;
          __int128 v17 = *((_OWORD *)v8 + 1);
          *(_OWORD *)a4 = *(_OWORD *)v8;
          *(_OWORD *)(a4 + 16) = v17;
          int v7 = *(_DWORD *)a4;
        }

        v5 += 1344;
      }

      while (v5 != v6);
    }
  }

  else
  {
    uint64_t v18 = (char *)a1[5];
    __int128 v19 = (char *)a1[6];
    if (v18 != v19)
    {
      int v20 = 0;
      float v21 = (double *)&v30[6 * a2];
      do
      {
        float result = memcpy(v30, v18, sizeof(v30));
        int v22 = (int)(*(double *)(a4 + 8) / 2.56);
        if (v20 > v22) {
          int v22 = v20;
        }
        double v23 = 0.0;
        BOOL v24 = v22 < 1 || *(_DWORD *)(a4 + 24) < 1;
        double v25 = 0.0;
        if (!v24) {
          double v25 = *(double *)(a4 + 16) / (double)v22;
        }
        int v26 = (int)(v21[1] / 2.56);
        if (*(_DWORD *)v21 > v26) {
          int v26 = *(_DWORD *)v21;
        }
        if (v25 < v23)
        {
          __int128 v27 = *((_OWORD *)v21 + 3);
          *(_OWORD *)(a4 + 32) = *((_OWORD *)v21 + 2);
          *(_OWORD *)(a4 + 48) = v27;
          __int128 v28 = *((_OWORD *)v21 + 5);
          *(_OWORD *)(a4 + 64) = *((_OWORD *)v21 + 4);
          *(_OWORD *)(a4 + 80) = v28;
          __int128 v29 = *((_OWORD *)v21 + 1);
          *(_OWORD *)a4 = *(_OWORD *)v21;
          *(_OWORD *)(a4 + 16) = v29;
          int v20 = *(_DWORD *)a4;
        }

        v18 += 1344;
      }

      while (v18 != v19);
    }
  }

  return result;
}

double sub_100F5EF88(void *a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = sub_100781F1C(a1, &v4);
  if (!v2) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return *((float *)v2 + 5) * 0.953066667;
}

void sub_100F5EFD0(double a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10188E428);
  }
  int v7 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = (int)(*(double *)(a3 + 8) / 2.56);
    int v9 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 <= v8) {
      int v10 = (int)(*(double *)(a3 + 8) / 2.56);
    }
    else {
      int v10 = *(_DWORD *)a3;
    }
    int v11 = *(_DWORD *)(a3 + 24);
    if (v10 <= 0)
    {
      int v13 = *(_DWORD *)(a3 + 48);
      double v12 = 0.0;
      double v14 = 0.0;
    }

    else
    {
      if (v11 <= 0) {
        double v12 = 0.0;
      }
      else {
        double v12 = *(double *)(a3 + 16) / (double)v10;
      }
      int v13 = *(_DWORD *)(a3 + 48);
      double v14 = (double)v13 / (double)v10;
    }

    uint64_t v15 = *a4;
    uint64_t v16 = a4[2];
    if (v13 < 1) {
      double v17 = 0.0;
    }
    else {
      double v17 = *(double *)(a3 + 32) / (double)v13;
    }
    uint64_t v18 = *(void *)(a3 + 80);
    uint64_t v19 = *(void *)(a3 + 88);
    *(_DWORD *)uint64_t buf = 134220544;
    double v58 = a1;
    __int16 v59 = 2048;
    uint64_t v60 = v15;
    __int16 v61 = 2048;
    uint64_t v62 = v16;
    __int16 v63 = 2048;
    double v64 = v12;
    __int16 v65 = 1024;
    int v66 = v8;
    __int16 v67 = 1024;
    int v68 = v9;
    __int16 v69 = 1024;
    int v70 = v11;
    __int16 v71 = 2048;
    double v72 = v14;
    __int16 v73 = 2048;
    double v74 = v17;
    __int16 v75 = 2048;
    uint64_t v76 = v18;
    __int16 v77 = 2048;
    uint64_t v78 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "boutDuration,%f,ftp,%f,confidence,%f,averagePower,%f,numExpectedSamples,%d,numObservedSamples,%d,observevalidPower SampleCount,%d,fractionValidHR,%f,averageHR,%f,startTime,%f,endTime,%f",  buf,  0x64u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    int v20 = (int)(*(double *)(a3 + 8) / 2.56);
    int v21 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 <= v20) {
      int v22 = (int)(*(double *)(a3 + 8) / 2.56);
    }
    else {
      int v22 = *(_DWORD *)a3;
    }
    int v23 = *(_DWORD *)(a3 + 24);
    if (v22 <= 0)
    {
      int v25 = *(_DWORD *)(a3 + 48);
      double v24 = 0.0;
      double v26 = 0.0;
    }

    else
    {
      if (v23 <= 0) {
        double v24 = 0.0;
      }
      else {
        double v24 = *(double *)(a3 + 16) / (double)v22;
      }
      int v25 = *(_DWORD *)(a3 + 48);
      double v26 = (double)v25 / (double)v22;
    }

    uint64_t v27 = *a4;
    uint64_t v28 = a4[2];
    if (v25 < 1) {
      double v29 = 0.0;
    }
    else {
      double v29 = *(double *)(a3 + 32) / (double)v25;
    }
    uint64_t v30 = *(void *)(a3 + 80);
    uint64_t v31 = *(void *)(a3 + 88);
    int v35 = 134220544;
    double v36 = a1;
    __int16 v37 = 2048;
    uint64_t v38 = v27;
    __int16 v39 = 2048;
    uint64_t v40 = v28;
    __int16 v41 = 2048;
    double v42 = v24;
    __int16 v43 = 1024;
    int v44 = v20;
    __int16 v45 = 1024;
    int v46 = v21;
    __int16 v47 = 1024;
    int v48 = v23;
    __int16 v49 = 2048;
    double v50 = v26;
    __int16 v51 = 2048;
    double v52 = v29;
    __int16 v53 = 2048;
    uint64_t v54 = v30;
    __int16 v55 = 2048;
    uint64_t v56 = v31;
    LODWORD(v34) = 100;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "boutDuration,%f,ftp,%f,confidence,%f,averagePower,%f,numExpectedSamples,%d,numObservedSamples,%d,observevalidPower SampleCount,%d,fractionValidHR,%f,averageHR,%f,startTime,%f,endTime,%f",  COERCE_DOUBLE(&v35),  v34);
    __int16 v33 = (uint8_t *)v32;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCyclingFTPBoutBasedEstimateModel::logMaxBoutFTPEstimate(const CFTimeInterval, const CLCyclingFTPBoutStatist ics::Bout &, const CLCyclingFTPValue &) const",  "%s\n",  v32);
    if (v33 != buf) {
      free(v33);
    }
  }

void sub_100F5F35C(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0x7FF8000000000000LL;
  *(_DWORD *)(a3 + 24) = 0;
  sub_100F5ED50(a2, 12, 0, (uint64_t)&v25);
  int v6 = (int)(v26 / 2.56);
  int v7 = v25;
  if (v25 <= v6) {
    int v8 = (int)(v26 / 2.56);
  }
  else {
    int v8 = v25;
  }
  int v9 = v28;
  BOOL v10 = v8 <= 0 || v28 <= 0;
  int v11 = !v10;
  if (v10)
  {
    *(void *)a3 = 0LL;
    *(_DWORD *)(a3 + 28) = 3;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    double v12 = v27 / (double)v8;
    *(double *)a3 = v12;
    *(_DWORD *)(a3 + 28) = 3;
    *(void *)(a3 + 16) = 0LL;
    if (v12 > 0.0)
    {
      if (v30 <= 0)
      {
        double v14 = 0.0;
      }

      else
      {
        float v13 = v29 / (double)v30;
        double v14 = v13;
      }

      double v20 = 0.0;
      if ((double)v30 / (double)v8 > 0.5)
      {
        float v21 = (*(float *)(a1 + 252) - v14) / (*(float *)(a1 + 252) - *(float *)(a1 + 248));
        float v22 = 1.0 - v21;
        if (v22 >= 1.0) {
          float v22 = 1.0;
        }
        double v20 = v22;
        if (v20 < 0.0) {
          double v20 = 0.0;
        }
      }

      *(double *)(a3 + 16) = v20;
      goto LABEL_35;
    }
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10188E428);
  }
  uint64_t v15 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    double v16 = 0.0;
    if (v11) {
      double v16 = v27 / (double)v8;
    }
    *(_DWORD *)uint64_t buf = 134218752;
    double v40 = v16;
    __int16 v41 = 1024;
    int v42 = v6;
    __int16 v43 = 1024;
    int v44 = v7;
    __int16 v45 = 1024;
    int v46 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Not able to compute FTP for 20 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d, maxAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  buf,  0x1Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    double v17 = 0.0;
    if (v11) {
      double v17 = v27 / (double)v8;
    }
    int v31 = 134218752;
    double v32 = v17;
    __int16 v33 = 1024;
    int v34 = v6;
    __int16 v35 = 1024;
    int v36 = v7;
    __int16 v37 = 1024;
    int v38 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Not able to compute FTP for 20 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d, maxAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  COERCE_DOUBLE(&v31),  30,  v25,  LODWORD(v26));
    uint64_t v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getFTPEstimateFor20Min(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void sub_100F5F69C(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0x7FF8000000000000LL;
  *(_DWORD *)(a3 + 24) = 0;
  sub_100F5ED50(a2, 7, 0, (uint64_t)&v25);
  int v6 = (int)(v26 / 2.56);
  int v7 = v25;
  if (v25 <= v6) {
    int v8 = (int)(v26 / 2.56);
  }
  else {
    int v8 = v25;
  }
  int v9 = v28;
  BOOL v10 = v8 <= 0 || v28 <= 0;
  int v11 = !v10;
  if (v10)
  {
    *(void *)a3 = 0LL;
    *(_DWORD *)(a3 + 28) = 8;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    double v12 = v27 / (double)v8;
    *(double *)a3 = v12;
    *(_DWORD *)(a3 + 28) = 8;
    *(void *)(a3 + 16) = 0LL;
    if (v12 > 0.0)
    {
      if (v30 <= 0)
      {
        double v14 = 0.0;
      }

      else
      {
        float v13 = v29 / (double)v30;
        double v14 = v13;
      }

      double v20 = 0.0;
      if ((double)v30 / (double)v8 > 0.5)
      {
        float v21 = (*(float *)(a1 + 252) - v14) / (*(float *)(a1 + 252) - *(float *)(a1 + 248));
        float v22 = 1.0 - v21;
        if (v22 >= 1.0) {
          float v22 = 1.0;
        }
        double v20 = v22;
        if (v20 < 0.0) {
          double v20 = 0.0;
        }
      }

      *(double *)(a3 + 16) = v20;
      goto LABEL_35;
    }
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10188E428);
  }
  uint64_t v15 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    double v16 = 0.0;
    if (v11) {
      double v16 = v27 / (double)v8;
    }
    *(_DWORD *)uint64_t buf = 134218752;
    double v40 = v16;
    __int16 v41 = 1024;
    int v42 = v6;
    __int16 v43 = 1024;
    int v44 = v7;
    __int16 v45 = 1024;
    int v46 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Not able to compute FTP for 8 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d,m axAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  buf,  0x1Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    double v17 = 0.0;
    if (v11) {
      double v17 = v27 / (double)v8;
    }
    int v31 = 134218752;
    double v32 = v17;
    __int16 v33 = 1024;
    int v34 = v6;
    __int16 v35 = 1024;
    int v36 = v7;
    __int16 v37 = 1024;
    int v38 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Not able to compute FTP for 8 Mins estimates. maxAvePower.averagePower, %f,maxAvePowerBout.numExpectedSamples,%d,m axAvePowerBout.numObservedSamples,%d,maxAvePowerBout.numValidPowerSamples,%d",  COERCE_DOUBLE(&v31),  30,  v25,  LODWORD(v26));
    uint64_t v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getFTPEstimateFor8Min(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void sub_100F5F9DC(uint64_t a1@<X0>, void *a2@<X1>, int64x2_t *a3@<X8>)
{
  *a3 = vdupq_n_s64(0x7FF8000000000000uLL);
  a3[1].i64[0] = 0xBFF0000000000000LL;
  a3[1].i64[1] = 0LL;
  std::string __p = 0LL;
  uint64_t v57 = 0LL;
  double v58 = 0.0;
  int v6 = &dword_1013B91B8;
  double v55 = 0.0;
  double v7 = 0.0;
  double v53 = 0.0;
  double v54 = 0.0;
  do
  {
    int v8 = *v6;
    sub_100F5ED50(a2, *v6, 1, (uint64_t)buf);
    double v9 = 0.0;
    if (SHIDWORD(v84) >= 1) {
      double v9 = *(double *)v82 / (double)SHIDWORD(v84);
    }
    float v10 = *(float *)(a1 + 248);
    float v11 = *(float *)(a1 + 252);
    int v12 = (int)(*(double *)&v80[4] / 2.56);
    double v13 = 0.0;
    if (v12 >= 1 && SLODWORD(v81) >= 1) {
      double v13 = *(double *)&v80[12] / (double)v12;
    }
    double v15 = sub_100F601FC(a2, v8);
    if (v13 > 0.0)
    {
      float v16 = v9;
      float v17 = (v11 - v16) / (v11 - v10);
      double v18 = (float)(1.0 - v17);
      if (v18 > 0.7)
      {
        float v19 = v15;
        double v20 = (float)(1.0 / v19);
        float v21 = v57;
        if ((unint64_t)v57 >= *(void *)&v58)
        {
          double v23 = (double *)__p;
          uint64_t v24 = ((char *)v57 - (_BYTE *)__p) >> 4;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = *(void *)&v58 - (void)__p;
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            int v28 = (char *)sub_100037038((uint64_t)&v58, v27);
            double v23 = (double *)__p;
            float v21 = v57;
          }

          else
          {
            int v28 = 0LL;
          }

          double v29 = (double *)&v28[16 * v24];
          *double v29 = v20;
          v29[1] = v13;
          int v30 = v29;
          if (v21 != v23)
          {
            do
            {
              *((_OWORD *)v30 - 1) = *((_OWORD *)v21 - 1);
              v30 -= 2;
              v21 -= 2;
            }

            while (v21 != v23);
            double v23 = (double *)__p;
          }

          float v22 = v29 + 2;
          std::string __p = v30;
          uint64_t v57 = v29 + 2;
          *(void *)&double v58 = &v28[16 * v27];
          if (v23) {
            operator delete(v23);
          }
        }

        else
        {
          *uint64_t v57 = v20;
          v21[1] = v13;
          float v22 = v21 + 2;
        }

        uint64_t v57 = v22;
        double v32 = v54;
        double v31 = v55;
        double v33 = v53;
        if (v19 > 450.0) {
          double v33 = v53 + v18;
        }
        else {
          double v32 = v54 + v18;
        }
        double v53 = v33;
        double v54 = v32;
        if (v19 > 450.0) {
          double v31 = v55 + 1.0;
        }
        else {
          double v7 = v7 + 1.0;
        }
        double v55 = v31;
      }
    }

    ++v6;
  }

  while (v6 != (int *)"34CLCyclingFTPBoutBasedEstimateModel");
  if ((unint64_t)((char *)v57 - (_BYTE *)__p) <= 0x20)
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    __int16 v39 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Not enough points for Critical Power Computation",  buf,  2u);
    }

    double v35 = 0.0;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10188E428);
      }
      LOWORD(v59) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Not enough points for Critical Power Computation",  &v59,  2);
      __int16 v49 = (uint8_t *)v48;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getCriticalPowerEstimate(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v48);
      if (v49 != buf) {
        free(v49);
      }
    }

    double v36 = 0.0;
    goto LABEL_59;
  }

  double v35 = sub_100DEA334((double **)&__p, 0);
  if (v35 <= 0.0)
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    double v40 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Unable to make CP estimate, first Point of Critical Power curve is <= 0.",  buf,  2u);
    }

    double v36 = 0.0;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10188E428);
      }
      LOWORD(v59) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Unable to make CP estimate, first Point of Critical Power curve is <= 0.",  &v59,  2);
      __int16 v51 = (uint8_t *)v50;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getCriticalPowerEstimate(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v50);
      if (v51 != buf) {
        free(v51);
      }
    }

    goto LABEL_59;
  }

  a3->i64[0] = v34;
  a3[1].i64[0] = 0LL;
  double v36 = 0.0;
  if (v55 <= 0.0)
  {
LABEL_59:
    double v37 = 0.0;
    goto LABEL_60;
  }

  double v37 = v53 / v55;
  if (v7 <= 0.0) {
    double v36 = 0.0;
  }
  else {
    double v36 = v54 / v7;
  }
  double v38 = (v37 + v36) * 0.5;
  if (v38 > 1.0) {
    double v38 = 1.0;
  }
  if (v38 < 0.0) {
    double v38 = 0.0;
  }
  *(double *)a3[1].i64 = v38;
LABEL_60:
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10188E428);
  }
  __int16 v41 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v42 = a3->i64[0];
    uint64_t v43 = a3[1].i64[0];
    *(_DWORD *)uint64_t buf = 134220288;
    *(void *)int v80 = v42;
    *(_WORD *)&v80[8] = 2048;
    *(void *)&v80[10] = v43;
    *(_WORD *)&v80[18] = 2048;
    double v81 = v55;
    *(_WORD *)int v82 = 2048;
    *(double *)&v82[2] = v7;
    __int16 v83 = 2048;
    double v84 = v53;
    __int16 v85 = 2048;
    double v86 = v54;
    __int16 v87 = 2048;
    double v88 = v37;
    __int16 v89 = 2048;
    double v90 = v36;
    __int16 v91 = 2048;
    uint64_t v92 = ((char *)v57 - (_BYTE *)__p) >> 4;
    __int16 v93 = 2048;
    double v94 = v35;
    _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "criticalPower,%f,confidence,%f,longBoutsCount,%f,shortBoutsCount,%f,longBoutsFHRSum,%f,shortBoutsFHRSum,%f,longBou tsAverageFHR,%f,shortBoutsAverageFHR,%f,totalPoints,%zu,slope,%f",  buf,  0x66u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10188E428);
    }
    uint64_t v44 = a3->i64[0];
    uint64_t v45 = a3[1].i64[0];
    int v59 = 134220288;
    uint64_t v60 = v44;
    __int16 v61 = 2048;
    uint64_t v62 = v45;
    __int16 v63 = 2048;
    double v64 = v55;
    __int16 v65 = 2048;
    double v66 = v7;
    __int16 v67 = 2048;
    double v68 = v53;
    __int16 v69 = 2048;
    double v70 = v54;
    __int16 v71 = 2048;
    double v72 = v37;
    __int16 v73 = 2048;
    double v74 = v36;
    __int16 v75 = 2048;
    uint64_t v76 = ((char *)v57 - (_BYTE *)__p) >> 4;
    __int16 v77 = 2048;
    double v78 = v35;
    LODWORD(v52) = 102;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "criticalPower,%f,confidence,%f,longBoutsCount,%f,shortBoutsCount,%f,longBoutsFHRSum,%f,shortBoutsFHRSum,%f,longBou tsAverageFHR,%f,shortBoutsAverageFHR,%f,totalPoints,%zu,slope,%f",  COERCE_DOUBLE(&v59),  v52,  v53,  v54,  v55,  *(double *)&__p,  *(double *)&v57,  v58);
    __int16 v47 = (uint8_t *)v46;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPValue CLCyclingFTPBoutBasedEstimateModel::getCriticalPowerEstimate(const CLCyclingFTPBoutStatistics &)",  "%s\n",  v46);
    if (v47 != buf) {
      free(v47);
    }
  }

  a3[1].i32[3] = 9;
  if (__p)
  {
    uint64_t v57 = (double *)__p;
    operator delete(__p);
  }

void sub_100F601C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100F601FC(void *a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = sub_100781F1C(a1, &v4);
  if (!v2) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return *((float *)v2 + 5) * 57.184;
}

uint64_t sub_100F60244(uint64_t a1)
{
  int64x2_t v2 = vdupq_n_s64(0x7FF8000000000000uLL);
  *(int64x2_t *)(a1 + 104) = v2;
  *(void *)(a1 + 120) = 0xBFF0000000000000LL;
  *(void *)(a1 + 128) = 0LL;
  *(int64x2_t *)(a1 + 136) = v2;
  *(void *)(a1 + 152) = 0xBFF0000000000000LL;
  *(void *)(a1 + 160) = 0LL;
  *(int64x2_t *)(a1 + 168) = v2;
  *(void *)(a1 + 184) = 0xBFF0000000000000LL;
  *(void *)(a1 + 192) = 0LL;
  *(int64x2_t *)(a1 + 200) = v2;
  *(void *)(a1 + 216) = 0xBFF0000000000000LL;
  *(void *)(a1 + 224) = 0LL;
  return 1LL;
}

uint64_t sub_100F602AC(uint64_t a1, float64x2_t *a2)
{
  *(float32x2_t *)(a1 + 248) = vcvt_f32_f64(a2[4]);
  return 1LL;
}

uint64_t sub_100F602E4(uint64_t a1)
{
  __int128 v2 = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 136) = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 152) = v2;
  sub_100F5EA10(a1, &v72, (uint64_t)buf);
  __int128 v3 = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 104) = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 120) = v3;
  sub_100F5F69C(a1, &v72, (uint64_t)buf);
  __int128 v4 = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 168) = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 184) = v4;
  sub_100F5F9DC(a1, &v72, (int64x2_t *)buf);
  *((void *)&v5 + 1) = *(void *)&buf[8];
  __int128 v6 = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 200) = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 216) = v6;
  double v7 = v84;
  if (v84 != v83)
  {
    unint64_t v8 = 0LL;
    *(void *)&__int128 v5 = 134222592LL;
    __int128 v67 = v5;
    double v7 = v83;
    do
    {
      double v9 = v74;
      if (v74 != 0.0)
      {
        float v10 = &v7[40 * v8];
        double v70 = (uint64_t *)(v10 + 24);
        __int16 v71 = (uint64_t *)(v10 + 16);
        __int16 v69 = (uint64_t *)(v10 + 32);
        do
        {
          uint64_t v11 = *(int *)(*(void *)&v9 + 16LL);
          int v12 = (char *)v77;
          double v13 = (char *)__p;
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10188E428);
          }
          double v14 = &v12[1344 * v8];
          double v15 = (int *)&v14[96 * v11];
          float v16 = &v13[1344 * v8];
          float v17 = (int *)&v16[96 * v11];
          double v18 = (os_log_s *)qword_1019347A8;
          if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
          {
            int v19 = *(_DWORD *)&v14[96 * (int)v11 + 48];
            double v20 = 0.0;
            double v21 = 0.0;
            double v22 = 0.0;
            if (v19 >= 1)
            {
              double v23 = &v14[96 * (int)v11];
              double v21 = *((double *)v23 + 4) / (double)v19;
              double v22 = *((double *)v23 + 5) / (double)v19;
            }

            int v24 = *v15;
            int v25 = (int)(*(double *)&v14[96 * (int)v11 + 8] / 2.56);
            if (*v15 <= v25) {
              int v26 = (int)(*(double *)&v14[96 * (int)v11 + 8] / 2.56);
            }
            else {
              int v26 = *v15;
            }
            if (v26 < 1)
            {
              double v27 = 0.0;
            }

            else
            {
              double v27 = (double)v19 / (double)v26;
            }

            int v28 = *(_DWORD *)&v16[96 * (int)v11 + 48];
            double v29 = 0.0;
            double v30 = 0.0;
            double v31 = 0.0;
            if (v28 >= 1)
            {
              double v32 = &v16[96 * (int)v11];
              double v30 = *((double *)v32 + 4) / (double)v28;
              double v31 = *((double *)v32 + 5) / (double)v28;
            }

            int v33 = *v17;
            int v34 = (int)(*(double *)&v16[96 * (int)v11 + 8] / 2.56);
            if (*v17 <= v34) {
              int v35 = (int)(*(double *)&v16[96 * (int)v11 + 8] / 2.56);
            }
            else {
              int v35 = *v17;
            }
            if (v35 < 1)
            {
              double v36 = 0.0;
            }

            else
            {
              double v36 = (double)v28 / (double)v35;
            }

            uint64_t v37 = *v71;
            uint64_t v38 = *v70;
            uint64_t v39 = *v69;
            double v40 = *(float *)(*(void *)&v9 + 20LL);
            *(_DWORD *)uint64_t buf = v67;
            *(void *)&uint8_t buf[4] = v8;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v37;
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = v38;
            __int16 v124 = 2048;
            uint64_t v125 = v39;
            __int16 v126 = 2048;
            double v127 = v40;
            __int16 v128 = 1024;
            int v129 = v24;
            __int16 v130 = 2048;
            double v131 = v21;
            __int16 v132 = 2048;
            double v133 = v22;
            __int16 v134 = 1024;
            int v135 = v25;
            __int16 v136 = 1024;
            int v137 = v26;
            __int16 v138 = 2048;
            double v139 = v27;
            __int16 v140 = 2048;
            double v141 = v20;
            __int16 v142 = 1024;
            int v143 = v33;
            __int16 v144 = 2048;
            double v145 = v30;
            __int16 v146 = 2048;
            double v147 = v31;
            __int16 v148 = 1024;
            int v149 = v34;
            __int16 v150 = 1024;
            int v151 = v35;
            __int16 v152 = 2048;
            double v153 = v36;
            __int16 v154 = 2048;
            double v155 = v29;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "sessionId,%zu,sessionStart,%f,sessionEnd,%f,workoutType,%ld,durationMin,%f,n,%d,hr,%f,hrConf,%f,nexpected, %d,nMax,%d,validHRFraction,%f,power,%f,goodHR_n,%d,goodHR_hr,%f,goodHR_hrConf,%f,goodHR_nexpected,%d,goodH R_nMax,%d,goodHR_validHRFraction,%f,goodHR_power,%f",  buf,  0xA8u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019347A0 != -1) {
              dispatch_once(&qword_1019347A0, &stru_10188E428);
            }
            uint64_t v41 = *v71;
            uint64_t v42 = *v70;
            uint64_t v43 = *v69;
            int v44 = *v15;
            int v45 = *(_DWORD *)&v14[96 * (int)v11 + 48];
            double v46 = 0.0;
            double v47 = 0.0;
            double v48 = 0.0;
            if (v45 >= 1)
            {
              __int16 v49 = &v14[96 * (int)v11];
              double v47 = *((double *)v49 + 4) / (double)v45;
              double v48 = *((double *)v49 + 5) / (double)v45;
            }

            int v50 = (int)(*(double *)&v14[96 * (int)v11 + 8] / 2.56);
            if (v44 <= v50) {
              int v51 = (int)(*(double *)&v14[96 * (int)v11 + 8] / 2.56);
            }
            else {
              int v51 = *v15;
            }
            if (v51 < 1)
            {
              double v52 = 0.0;
            }

            else
            {
              double v52 = (double)v45 / (double)v51;
            }

            int v53 = *v17;
            int v54 = *(_DWORD *)&v16[96 * (int)v11 + 48];
            double v55 = 0.0;
            double v56 = 0.0;
            double v57 = 0.0;
            if (v54 >= 1)
            {
              double v58 = &v16[96 * (int)v11];
              double v56 = *((double *)v58 + 4) / (double)v54;
              double v57 = *((double *)v58 + 5) / (double)v54;
            }

            int v59 = (int)(*(double *)&v16[96 * (int)v11 + 8] / 2.56);
            if (v53 <= v59) {
              int v60 = (int)(*(double *)&v16[96 * (int)v11 + 8] / 2.56);
            }
            else {
              int v60 = *v17;
            }
            if (v60 < 1)
            {
              double v61 = 0.0;
            }

            else
            {
              double v61 = (double)v54 / (double)v60;
            }

            double v62 = *(float *)(*(void *)&v9 + 20LL);
            int v85 = v67;
            unint64_t v86 = v8;
            __int16 v87 = 2048;
            uint64_t v88 = v41;
            __int16 v89 = 2048;
            uint64_t v90 = v42;
            __int16 v91 = 2048;
            uint64_t v92 = v43;
            __int16 v93 = 2048;
            double v94 = v62;
            __int16 v95 = 1024;
            int v96 = v44;
            __int16 v97 = 2048;
            double v98 = v47;
            __int16 v99 = 2048;
            double v100 = v48;
            __int16 v101 = 1024;
            int v102 = v50;
            __int16 v103 = 1024;
            int v104 = v51;
            __int16 v105 = 2048;
            double v106 = v52;
            __int16 v107 = 2048;
            double v108 = v46;
            __int16 v109 = 1024;
            int v110 = v53;
            __int16 v111 = 2048;
            double v112 = v56;
            __int16 v113 = 2048;
            double v114 = v57;
            __int16 v115 = 1024;
            int v116 = v59;
            __int16 v117 = 1024;
            int v118 = v60;
            __int16 v119 = 2048;
            double v120 = v61;
            __int16 v121 = 2048;
            double v122 = v55;
            LODWORD(v66) = 168;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "sessionId,%zu,sessionStart,%f,sessionEnd,%f,workoutType,%ld,durationMin,%f,n,%d,hr,%f,hrConf,%f,nexpected, %d,nMax,%d,validHRFraction,%f,power,%f,goodHR_n,%d,goodHR_hr,%f,goodHR_hrConf,%f,goodHR_nexpected,%d,goodH R_nMax,%d,goodHR_validHRFraction,%f,goodHR_power,%f",  (size_t)&v85,  v66,  *(double *)&v67,  *((void *)&v67 + 1),  v68,  (_DWORD)v69,  *(double *)&v70,  *(double *)&v71,  v72,  v73,  v74,  v75,  v76,  *(double *)&v77,  *(double *)&v78,  v79,  (_DWORD)__p,  *(double *)&v81,  v82);
            double v64 = (char *)v63;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLCyclingFTPBoutBasedEstimateModel::execute()",  "%s\n",  v63);
            if (v64 != buf) {
              free(v64);
            }
          }

          double v9 = **(double **)&v9;
        }

        while (v9 != 0.0);
      }

      ++v8;
      double v7 = v83;
    }

    while (v8 < 0xCCCCCCCCCCCCCCCDLL * ((v84 - v83) >> 3));
  }

  if (v7)
  {
    double v84 = v7;
    operator delete(v7);
  }

  if (__p)
  {
    double v81 = __p;
    operator delete(__p);
  }

  if (v77)
  {
    double v78 = v77;
    operator delete(v77);
  }

  sub_100019CEC((uint64_t)&v72);
  return 1LL;
}

void sub_100F60984( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100F609B4(void *a1)
{
  __int128 v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }

  __int128 v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }

  __int128 v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }

  return sub_100019CEC((uint64_t)a1);
}

__n128 sub_100F60A04@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 184);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 168);
  *(_OWORD *)(a2 + 80) = v2;
  __int128 v3 = *(_OWORD *)(a1 + 216);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 200);
  *(_OWORD *)(a2 + 112) = v3;
  __int128 v4 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(a2 + 16) = v4;
  __n128 result = *(__n128 *)(a1 + 136);
  __int128 v6 = *(_OWORD *)(a1 + 152);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v6;
  return result;
}

void sub_100F60A3C(void *a1)
{
  uint64_t v1 = sub_100F60A7C(a1);
  operator delete(v1);
}

void sub_100F60A50(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

void *sub_100F60A7C(void *a1)
{
  *a1 = off_10188E3C8;
  uint64_t v2 = (uint64_t)(a1 + 11);
  sub_10000AE14((uint64_t)(a1 + 29));
  sub_10000AE14(v2);
  *a1 = off_101868780;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

uint64_t sub_100F60AD4@<X0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xD8uLL);
  uint64_t result = sub_100F60B1C((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_100F60B08(_Unwind_Exception *a1)
{
}

uint64_t sub_100F60B1C(uint64_t a1)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_10188E458;
  *(void *)(a1 + 8) = 0LL;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  sub_100F60BFC(a1 + 24);
  return a1;
}

void sub_100F60B88(_Unwind_Exception *a1)
{
}

void sub_100F60B9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10188E458;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F60BB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10188E458;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100F60BD4(uint64_t a1)
{
  return sub_100F60D28((uint64_t)&v2, (void *)(a1 + 24));
}

uint64_t sub_100F60BFC(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  v3[4] = xmmword_1013B92A4;
  v3[5] = unk_1013B92B4;
  v3[6] = xmmword_1013B92C4;
  v3[0] = xmmword_1013B9264;
  v3[1] = unk_1013B9274;
  v3[2] = xmmword_1013B9284;
  v3[3] = unk_1013B9294;
  sub_100F60CB4(a1 + 16, (int *)v3, 14LL);
  *(void *)(a1 + 120) = 0LL;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  return a1;
}

void sub_100F60CA0(_Unwind_Exception *a1)
{
}

uint64_t sub_100F60CB4(uint64_t a1, int *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 8 * a3;
    do
    {
      sub_100246788(a1, a2, a2);
      a2 += 2;
      v5 -= 8LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100F60D14(_Unwind_Exception *a1)
{
}

uint64_t sub_100F60D28(uint64_t a1, void *a2)
{
  __int128 v3 = (void *)a2[13];
  if (v3)
  {
    a2[14] = v3;
    operator delete(v3);
  }

  __int128 v4 = (void *)a2[10];
  if (v4)
  {
    a2[11] = v4;
    operator delete(v4);
  }

  uint64_t v5 = (void *)a2[7];
  if (v5)
  {
    a2[8] = v5;
    operator delete(v5);
  }

  sub_100019CEC((uint64_t)(a2 + 2));
  return sub_10000AE14((uint64_t)a2);
}

void *sub_100F60D80(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10188E4A8;
  a1[9] = off_10188E570;
  a1[42] = off_10188E5C0;
  sub_100F61784((uint64_t)a1);
  return a1;
}

void sub_100F60E10( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_100F60E3C(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  int v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *int v12 = &off_101826EF8;
  *(void *)a1 = off_10188E7A0;
  *(void *)(a1 + 72) = off_10188E848;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10188E7A0;
  *(void *)(a1 + 72) = off_10188E848;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 256) = 12000;
  *(void *)(a1 + 264) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 272));
  *(void *)(a1 + 272) = &off_101826EF8;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  double v15 = (int *)(a1 + 256);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 256));
  float v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10188E888);
  }
  double v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188E888);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    int v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = HRRecoveryInputHR, D ataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100F611E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[33] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_1000EAA04(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100F6128C()
{
}

void *sub_100F61294(void *a1)
{
  a1[9] = off_10188E848;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10188E7A0;
  a1[33] = off_101826EC8;
  sub_1001B9C98(a1 + 34);
  sub_1000EAA04(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100F61314(uint64_t a1)
{
  return sub_100F61294((void *)(a1 - 72));
}

void *sub_100F6131C(uint64_t a1)
{
  return sub_100F61294((void *)(a1 - 336));
}

void sub_100F61324(void *a1)
{
  uint64_t v1 = sub_100F61294(a1);
  operator delete(v1);
}

void sub_100F61338(uint64_t a1)
{
  uint64_t v1 = sub_100F61294((void *)(a1 - 72));
  operator delete(v1);
}

void sub_100F61350(uint64_t a1)
{
  uint64_t v1 = sub_100F61294((void *)(a1 - 336));
  operator delete(v1);
}

uint64_t sub_100F61368(uint64_t *a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(a1[10], "DELETE FROM HRRecoveryInputHRHistory WHERE startTime < ?", &v13);
  uint64_t v5 = v13;
  char v6 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v7 = a1[10];
    unint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
    sub_1003BB2BC(v7, v8);
    uint64_t v9 = (*(int (**)(uint64_t *))(*a1 + 152))(a1);
  }

  else
  {
    uint64_t v9 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v10 = a1[10];
  else {
    uint64_t v11 = *(void *)(v10 + 88);
  }
  sub_1003C1EC0(v10, v11);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v9;
}

void sub_100F61480(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F614A0(uint64_t a1, uint64_t a2)
{
  return sub_100F61368((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_100F614A8(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from HRRecoveryInputHRHistory ORDER BY startTime ASC", &v19);
    uint64_t v5 = v19;
    uint64_t v21 = v19;
    sub_1003C0454(*(void *)(a1 + 80));
    __int128 v19 = 0uLL;
    while (!sub_100F6165C(&v21, (uint64_t)&v19))
    {
      char v6 = a2[1];
      unint64_t v7 = (unint64_t)a2[2];
      if ((unint64_t)v6 >= v7)
      {
        uint64_t v9 = (v6 - *a2) >> 5;
        unint64_t v10 = v9 + 1;
        uint64_t v11 = v7 - (void)*a2;
        if (v11 >> 4 > v10) {
          unint64_t v10 = v11 >> 4;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12) {
          uint64_t v13 = (char *)sub_10000835C((uint64_t)(a2 + 2), v12);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = &v13[32 * v9];
        *(_OWORD *)uint64_t v14 = v19;
        *((_OWORD *)v14 + 1) = v20;
        char v16 = *a2;
        double v15 = a2[1];
        float v17 = v14;
        if (v15 != *a2)
        {
          do
          {
            __int128 v18 = *((_OWORD *)v15 - 1);
            *((_OWORD *)v17 - 2) = *((_OWORD *)v15 - 2);
            *((_OWORD *)v17 - 1) = v18;
            v17 -= 32;
            v15 -= 32;
          }

          while (v15 != v16);
          double v15 = *a2;
        }

        unint64_t v8 = v14 + 32;
        *a2 = v17;
        a2[1] = v14 + 32;
        a2[2] = &v13[32 * v12];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *(_OWORD *)char v6 = v19;
        *((_OWORD *)v6 + 1) = v20;
        unint64_t v8 = v6 + 32;
      }

      a2[1] = v8;
    }

    uint64_t result = sub_1003C05BC(*(void *)(a1 + 80));
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100F61634(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F6165C(uint64_t *a1, uint64_t a2)
{
  __int128 v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  sub_100F619D4(a1, a2);
  return 0LL;
}

uint64_t sub_100F616B8(uint64_t a1)
{
  uint64_t v3 = v8;
  __int128 v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    char v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100F61758(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F6177C(uint64_t a1)
{
  return sub_100F616B8(a1 - 72);
}

uint64_t sub_100F61784(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result) {
    return sub_1003B59A0( *(void *)(a1 + 80),  "HRRecoveryInputHRHistory",  (const char **)&off_10188E660,  (const std::string::value_type **)&off_101992B68,  0);
  }
  return result;
}

void *sub_100F617D8@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "HRRecoveryInputHRHistory");
}

void *sub_100F617E8@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "HRRecoveryInputHRHistory");
}

uint64_t sub_100F617F8(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM HRRecoveryInputHRHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100F6188C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F618AC(uint64_t a1)
{
  return sub_100F617F8(a1 - 72);
}

id *sub_100F618B4(uint64_t a1, double *a2)
{
  uint64_t result = (id *)sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100222B94(v12, (uint64_t)"CLHRRecoveryInputHRRecorderDb.insertRecord", 0);
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO HRRecoveryInputHRHistory (startTime, hr, hrConfidence) VALUES (?, ?, ?)",  &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v6, 1, a2[1]))
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      if (sub_1003B7480(v7, 2, a2[2]))
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
        if (sub_1003B7480(v8, 3, a2[3]))
        {
          uint64_t v9 = *(void *)(a1 + 80);
          unint64_t v10 = (sqlite3_stmt *)sub_100019240(v5);
          sub_1003BB2BC(v9, v10);
        }
      }
    }

    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    return sub_1001BA1BC(v12);
  }

  return result;
}

void sub_100F61998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100F619C8(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void sub_100F619D4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v4, 0);
  uint64_t v5 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 8) = sqlite3_column_double(v5, 1);
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 16) = sqlite3_column_double(v6, 2);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 24) = sqlite3_column_double(v7, 3);
}

uint64_t sub_100F61A48(uint64_t a1, int a2, void **a3, double a4, double a5)
{
  uint64_t v11 = a1 + 112;
  uint64_t v10 = *(void *)(a1 + 112);
  uint64_t v12 = a1 + 72;
  v35[1] = a1 + 112;
  (*(void (**)(uint64_t))(v10 + 16))(a1 + 112);
  __int16 v36 = 256;
  if ((sub_100D8A92C(v12) & 1) != 0)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM HRRecoveryInputHRHistory WHERE startTime > ? and startTime < ? ORDER BY startTime ASC LIMIT ?",  buf);
    uint64_t v13 = *(void *)buf;
    v35[0] = *(void *)buf;
    memset(buf, 0, sizeof(buf));
    if (a5 >= a4)
    {
      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v13);
      if (sub_1003B7480(v14, 1, a4))
      {
        double v15 = (sqlite3_stmt *)sub_100019240(v13);
        if (sub_1003B7480(v15, 2, a5))
        {
          char v16 = (sqlite3_stmt *)sub_100019240(v13);
          if (sub_1003C28BC(v16, 3, a2))
          {
            while (!sub_100F6165C(v35, (uint64_t)buf))
            {
              float v17 = a3[1];
              unint64_t v18 = (unint64_t)a3[2];
              if ((unint64_t)v17 >= v18)
              {
                uint64_t v20 = ((char *)v17 - (_BYTE *)*a3) >> 5;
                unint64_t v21 = v20 + 1;
                uint64_t v22 = v18 - (void)*a3;
                if (v22 >> 4 > v21) {
                  unint64_t v21 = v22 >> 4;
                }
                else {
                  unint64_t v23 = v21;
                }
                if (v23) {
                  int v24 = (char *)sub_10000835C((uint64_t)(a3 + 2), v23);
                }
                else {
                  int v24 = 0LL;
                }
                int v25 = &v24[32 * v20];
                *(_OWORD *)int v25 = *(_OWORD *)buf;
                *((_OWORD *)v25 + 1) = v38;
                double v27 = (char *)*a3;
                int v26 = (char *)a3[1];
                uint64_t v28 = v25;
                if (v26 != *a3)
                {
                  do
                  {
                    __int128 v29 = *((_OWORD *)v26 - 1);
                    *((_OWORD *)v28 - 2) = *((_OWORD *)v26 - 2);
                    *((_OWORD *)v28 - 1) = v29;
                    v28 -= 32;
                    v26 -= 32;
                  }

                  while (v26 != v27);
                  int v26 = (char *)*a3;
                }

                __int128 v19 = v25 + 32;
                *a3 = v28;
                a3[1] = v25 + 32;
                a3[2] = &v24[32 * v23];
                if (v26) {
                  operator delete(v26);
                }
              }

              else
              {
                _OWORD *v17 = *(_OWORD *)buf;
                v17[1] = v38;
                __int128 v19 = v17 + 2;
              }

              a3[1] = v19;
            }
          }
        }
      }
    }

    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
    uint64_t v31 = 100LL;
  }

  else
  {
    if (qword_101934770 != -1) {
      dispatch_once(&qword_101934770, &stru_10188E750);
    }
    double v30 = (os_log_s *)qword_101934778;
    if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "HRRecoveryInputHRHistory not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934770 != -1) {
        dispatch_once(&qword_101934770, &stru_10188E750);
      }
      LOWORD(v35[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934778,  2LL,  "HRRecoveryInputHRHistory not accessible",  v35,  2);
      int v34 = (uint8_t *)v33;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CMError CLHRRecoveryInputHRRecorderDb::queryHRRecoveryInputHRInTimeRange(CFAbsoluteTime, CFAbsoluteTime, int, std::vector<HRRecoveryInputHR> &) const",  "%s\n",  v33);
      if (v34 != buf) {
        free(v34);
      }
    }

    uint64_t v31 = 109LL;
  }

  (*(void (**)(uint64_t))(*(void *)v11 + 24LL))(v11);
  return v31;
}

void sub_100F61DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F61E0C(uint64_t a1, int a2, void **a3, double a4, double a5)
{
  return sub_100F61A48(a1 - 336, a2, a3, a4, a5);
}

uint64_t sub_100F61E14(uint64_t a1, void **a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v26[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v27 = 256;
  if ((sub_100D8A92C(v6) & 1) != 0)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from HRRecoveryInputHRHistory ORDER BY startTime ASC", buf);
    uint64_t v7 = *(void *)buf;
    v26[0] = *(void *)buf;
    sub_1003C0454(*(void *)(a1 + 80));
    memset(buf, 0, sizeof(buf));
    while (!sub_100F6165C(v26, (uint64_t)buf))
    {
      uint64_t v8 = a2[1];
      unint64_t v9 = (unint64_t)a2[2];
      if ((unint64_t)v8 >= v9)
      {
        uint64_t v11 = ((char *)v8 - (_BYTE *)*a2) >> 5;
        unint64_t v12 = v11 + 1;
        uint64_t v13 = v9 - (void)*a2;
        if (v13 >> 4 > v12) {
          unint64_t v12 = v13 >> 4;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          double v15 = (char *)sub_10000835C((uint64_t)(a2 + 2), v14);
        }
        else {
          double v15 = 0LL;
        }
        char v16 = &v15[32 * v11];
        *(_OWORD *)char v16 = *(_OWORD *)buf;
        *((_OWORD *)v16 + 1) = v29;
        unint64_t v18 = (char *)*a2;
        float v17 = (char *)a2[1];
        __int128 v19 = v16;
        if (v17 != *a2)
        {
          do
          {
            __int128 v20 = *((_OWORD *)v17 - 1);
            *((_OWORD *)v19 - 2) = *((_OWORD *)v17 - 2);
            *((_OWORD *)v19 - 1) = v20;
            v19 -= 32;
            v17 -= 32;
          }

          while (v17 != v18);
          float v17 = (char *)*a2;
        }

        uint64_t v10 = v16 + 32;
        *a2 = v19;
        a2[1] = v16 + 32;
        a2[2] = &v15[32 * v14];
        if (v17) {
          operator delete(v17);
        }
      }

      else
      {
        _OWORD *v8 = *(_OWORD *)buf;
        v8[1] = v29;
        uint64_t v10 = v8 + 2;
      }

      a2[1] = v10;
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    uint64_t v22 = 100LL;
  }

  else
  {
    if (qword_101934510 != -1) {
      dispatch_once(&qword_101934510, &stru_10188E770);
    }
    unint64_t v21 = (os_log_s *)qword_101934518;
    if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "HRRecoveryInputHRHistory not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10188E770);
      }
      LOWORD(v26[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "HRRecoveryInputHRHistory not accessible",  v26,  2);
      int v25 = (uint8_t *)v24;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CMError CLHRRecoveryInputHRRecorderDb::queryHRRecoveryInputHRAllRecords(std::vector<HRRecoveryInputHR> &) const",  "%s\n",  v24);
      if (v25 != buf) {
        free(v25);
      }
    }

    uint64_t v22 = 109LL;
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v22;
}

void sub_100F62140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F62190(uint64_t a1, void **a2)
{
  return sub_100F61E14(a1 - 336, a2);
}

uint64_t sub_100F62198(void *a1, void **a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v41);
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if (HIBYTE(v42)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_1012796B0(v10);
    goto LABEL_41;
  }

  uint64_t v4 = (std::stringbuf *)v41[1];
  operator delete(v41[0]);
  if (!v4) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v41);
  uint64_t v11 = sub_10000CF44(&v42, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(void **__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    unint64_t v12 = __p;
  }
  else {
    unint64_t v12 = (void **)__p[0];
  }
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v13 = BYTE7(v38);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  unint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = a1[10];
  uint64_t v4 = &v43;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v43);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    char v16 = (char *)__p;
  }
  else {
    char v16 = (char *)__p[0];
  }
  sub_1003C0D54(v15, v16, &v39);
  uint64_t v5 = v39;
  uint64_t v39 = 0LL;
  uint64_t v40 = v5;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  float v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    unint64_t v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      __p[0] = 0LL;
      __p[1] = 0LL;
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v40, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        __int128 v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v24 = ((char *)v20 - (_BYTE *)*a2) >> 5;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = v21 - (void)*a2;
          if (v26 >> 4 > v25) {
            unint64_t v25 = v26 >> 4;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            uint64_t v28 = (char *)sub_10000835C((uint64_t)(a2 + 2), v27);
          }
          else {
            uint64_t v28 = 0LL;
          }
          __int128 v29 = &v28[32 * v24];
          __int128 v30 = v38;
          *(_OWORD *)__int128 v29 = *(_OWORD *)__p;
          *((_OWORD *)v29 + 1) = v30;
          double v32 = (char *)*a2;
          uint64_t v31 = (char *)a2[1];
          int v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *((_OWORD *)v31 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 32;
              v31 -= 32;
            }

            while (v31 != v32);
            uint64_t v31 = (char *)*a2;
          }

          unint64_t v23 = v29 + 32;
          *a2 = v33;
          a2[1] = v29 + 32;
          a2[2] = &v28[32 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = v38;
          *__int128 v20 = *(_OWORD *)__p;
          v20[1] = v22;
          unint64_t v23 = v20 + 2;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v40;
      goto LABEL_43;
    }
  }

void sub_100F624A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100F62508(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188E888);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188E888);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)uint64_t buf = 134349056;
        *(void *)uint64_t v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188E888);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        __int16 v36 = (uint8_t *)v35;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAcc essible() [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v35);
        if (v36 != buf) {
          free(v36);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188E888);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    uint64_t v13 = *(void *)(a1 + 184);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = (void *)(v13 + 8LL * (*(void *)(a1 + 208) >> 7));
    if (v14 == v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *v15 + 32 * (*(void *)(a1 + 208) & 0x7FLL);
    }
    while (1)
    {
      if (v14 == v13)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        unint64_t v21 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v22 = *(void *)(v13 + ((v21 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v21 & 0x7F);
      }

      if (v16 == v22) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10188E770);
      }
      unint64_t v23 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10188E770);
        }
        LOWORD(v39) = 0;
        LODWORD(v37) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v37);
        uint64_t v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAcc essible() [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v16, 1LL);
      v16 += 32LL;
      if (v16 - *v15 == 4096)
      {
        uint64_t v24 = v15[1];
        ++v15;
        uint64_t v16 = v24;
      }

      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v14 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188E888);
    }
    float v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      unint64_t v18 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188E888);
      }
    }

    uint64_t v19 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v20 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 128) = 1;
  }

  unint64_t v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      unint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 64LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 128LL;
  }

  *(void *)(a1 + 208) = v31;
LABEL_61:
  double v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100F62C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id *sub_100F62C44(uint64_t a1, uint64_t a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  uint64_t v32 = 0LL;
  double v33 = 0.0;
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 104LL))(a1, &v32);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188E888);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188E888);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndSto reRecordUL(const T &, BOOL) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = v33;
    double v9 = v7 - v33;
    if (v7 - v33 < 0.0) {
      double v9 = -(v7 - v33);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188E888);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)uint64_t buf = 134349312;
        double v40 = v33;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188E888);
        }
        uint64_t v23 = *(void *)(a2 + 8);
        int v35 = 134349312;
        double v36 = v33;
        __int16 v37 = 2050;
        uint64_t v38 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        unint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndSto reRecordUL(const T &, BOOL) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = v33;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188E888);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)uint64_t buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10188E888);
          }
          double v26 = *(double *)(a2 + 8);
          int v35 = 134217984;
          double v36 = v26;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          uint64_t v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndS toreRecordUL(const T &, BOOL) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v31 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10188E888);
        double v18 = v31;
      }

      double v19 = v17 - v18;
      __int128 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        double v40 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188E888);
        }
        int v35 = 134217984;
        double v36 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        uint64_t v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndSto reRecordUL(const T &, BOOL) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, &v32, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100F63384( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100F633B0(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_10127981C(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  double v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100F63610(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101279988(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100F63848(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101279AF4(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

uint64_t sub_100F63A70(uint64_t a1)
{
  return sub_100F62508(a1 - 72);
}

void sub_100F63A78(id a1)
{
  qword_101934778 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HRRecovery");
}

void sub_100F63AA4(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_100F63AD0(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_101279C60(v4);
LABEL_44:
    sub_100007008();
  }

  uint64_t v30 = v35[1];
  operator delete(v35[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v35);
    int v6 = sub_10000CF44(&v36, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(void **__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      double v7 = __p;
    }
    else {
      double v7 = (void **)__p[0];
    }
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v32);
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v37);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v11 = (char *)__p;
    }
    else {
      uint64_t v11 = (char *)__p[0];
    }
    sub_1003C0D54(v10, v11, &v33);
    uint64_t v12 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v12;
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_1003C0454(a1[10]);
    __p[0] = 0LL;
    __p[1] = 0LL;
    while (!sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)__p))
    {
      uint64_t v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v17 = (v13 - *a2) >> 5;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v14 - (void)*a2;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          uint64_t v21 = (char *)sub_10000835C((uint64_t)(a2 + 2), v20);
        }
        else {
          uint64_t v21 = 0LL;
        }
        uint64_t v22 = &v21[32 * v17];
        __int128 v23 = v32;
        *(_OWORD *)uint64_t v22 = *(_OWORD *)__p;
        *((_OWORD *)v22 + 1) = v23;
        uint64_t v25 = *a2;
        std::stringbuf v24 = a2[1];
        uint64_t v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *((_OWORD *)v24 - 1);
            *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v24 -= 32;
          }

          while (v24 != v25);
          std::stringbuf v24 = *a2;
        }

        uint64_t v16 = v22 + 32;
        *a2 = v26;
        a2[1] = v22 + 32;
        a2[2] = &v21[32 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = v32;
        *(_OWORD *)uint64_t v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        uint64_t v16 = v13 + 32;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v34;
    uint64_t v34 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v35
    uint64_t v36 = v29;
    std::streambuf::~streambuf(&v37);
    return std::ios::~ios(&v38);
  }

  return result;
}

void sub_100F63D94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_100F63DFC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100F63E28@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v3 = *(double *)(a2 + 1024);
  if (*(double *)(a2 + 112) >= v3)
  {
    double v4 = *(double *)(result + 24);
    if (v3 > v4)
    {
      uint64_t v5 = *(void *)(a2 + 1032);
      if ((!*(_BYTE *)(a2 + 352) || *(_BYTE *)(result + 48)) && (v5 - *(_DWORD *)(result + 32)) >= 0xC8)
      {
        double v6 = v3 - v4;
        double v7 = *(double *)(result + 40);
        if (v6 <= 180.0)
        {
          if (v7 >= v6) {
            double v7 = v6;
          }
          *(double *)uint64_t result = *(double *)result + v7;
        }

        else
        {
          *(double *)(result + 8) = v7 + *(double *)(result + 8);
          *(double *)(result + 16) = v3;
        }
      }

      *(double *)(result + 24) = v3;
      *(void *)(result + 32) = v5;
    }
  }

  double v8 = *(double *)result;
  if (*(double *)result <= 0.0)
  {
    double v9 = *(double *)(result + 8);
    if (v9 <= 0.0)
    {
      char v10 = 0;
      goto LABEL_21;
    }

    if (*(double *)(a2 + 112) - *(double *)(result + 16) > 900.0)
    {
      char v10 = 0;
      *(void *)(result + 8) = 0LL;
      double v9 = 0.0;
      goto LABEL_21;
    }

    double v9 = v9 - (*(double *)(a2 + 128) - *(double *)(a2 + 120));
    if (v9 < 0.0) {
      double v9 = 0.0;
    }
    *(double *)(result + 8) = v9;
  }

  else
  {
    double v8 = v8 - (*(double *)(a2 + 128) - *(double *)(a2 + 120));
    if (v8 < 0.0) {
      double v8 = 0.0;
    }
    *(double *)uint64_t result = v8;
    double v9 = *(double *)(result + 8);
  }

  char v10 = 1;
LABEL_21:
  *(_BYTE *)a3 = v10;
  *(double *)(a3 + 8) = v9;
  *(double *)(a3 + 16) = v8;
  return result;
}

void *sub_100F63F48(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10188E8B8;
  a1[9] = off_10188E970;
  sub_100B14CF0(a1 + 42, 0LL, 0LL);
  sub_100B14CF0(a1 + 44, 0LL, 0LL);
  sub_100B14CF0(a1 + 46, 0LL, 0LL);
  sub_100B14CF0(a1 + 48, 0LL, 0LL);
  sub_100B14CF0(a1 + 50, 0LL, 0LL);
  sub_100B14CF0(a1 + 52, 0LL, 0LL);
  sub_100B14CF0(a1 + 54, 0LL, 0LL);
  sub_100B14CF0(a1 + 56, 0LL, 0LL);
  sub_100B14CF0(a1 + 58, 0LL, 0LL);
  sub_100B14CF0(a1 + 60, 0LL, 0LL);
  a1[62] = 0LL;
  a1[63] = 0LL;
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_100F6407C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F640A8(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_10182BDA0;
  *(void *)a1 = off_10188EA30;
  *(void *)(a1 + 72) = off_10188EAD8;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10188EA30;
  *(void *)(a1 + 72) = off_10188EAD8;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 256) = 12000;
  *(void *)(a1 + 264) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 272));
  *(void *)(a1 + 272) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 224) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  __int128 v15 = (int *)(a1 + 256);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 256));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10188EA00);
  }
  unint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    uint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLSedentaryAlarmData>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, c onst CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB:: ClassCDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 224) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100F64450( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[33] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_1000EAA04(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100F644F4()
{
}

void *sub_100F644FC(void *a1)
{
  a1[9] = off_10188EAD8;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10188EA30;
  a1[33] = off_10182BD58;
  sub_1001B9C98(a1 + 34);
  sub_1000EAA04(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100F64578(void *a1)
{
  *a1 = off_10188E8B8;
  a1[9] = off_10188E970;
  sub_100F645BC((uint64_t)a1, 0LL, 0LL);
  return sub_100F644FC(a1);
}

void sub_100F645BC(uint64_t a1, void *a2, const void *a3)
{
  if ((a2 != 0LL) == (a3 != 0LL))
  {

    *(void *)(a1 + 496) = a2;
    char v6 = *(const void **)(a1 + 504);
    if (v6) {
      _Block_release(v6);
    }
    if (a3) {
      *(void *)(a1 + 504) = _Block_copy(a3);
    }
  }

  else
  {
    uint64_t v7 = sub_101279DCC();
    sub_100F64630(v7);
  }

void *sub_100F64634(uint64_t a1)
{
  return sub_100F64578((void *)(a1 - 72));
}

void sub_100F6463C(void *a1)
{
  uint64_t v1 = sub_100F64578(a1);
  operator delete(v1);
}

void sub_100F64650(uint64_t a1)
{
  uint64_t v1 = sub_100F64578((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100F64668(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  v16[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v17 = 256;
  if (*(double *)(*(void *)(a2 + 8) - 16LL) == 1.79769313e308 && sub_100D8A92C(a1 + 72))
  {
    sub_100B14CF8((uint64_t *)(a1 + 384), v16);
    char v6 = (sqlite3_stmt *)sub_100019240(v16[0]);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
    {
      uint64_t v8 = *(void *)(a1 + 80);
      double v9 = (sqlite3_stmt *)sub_100019240(v16[0]);
      sub_1003BB2BC(v8, v9);
      uint64_t v10 = *(void *)(a1 + 80);
      else {
        uint64_t v11 = *(void *)(v10 + 88);
      }
      sub_1003C1EC0(v10, v11);
      int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152LL))(a1);
      *(_DWORD *)(a1 + 132) = v12;
      uint64_t v13 = v12;
    }

    else
    {
      uint64_t v13 = -1LL;
    }

    uint64_t v14 = v16[0];
    v16[0] = 0LL;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    }
  }

  else
  {
    uint64_t v13 = -1LL;
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v13;
}

void sub_100F64798(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F647D4(uint64_t a1, uint64_t a2)
{
  return sub_100F64668(a1 - 72, a2);
}

uint64_t sub_100F647DC(uint64_t a1, void **a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v31[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v32 = 256;
  if (sub_100D8A92C(v6))
  {
    sub_100B14CF8((uint64_t *)(a1 + 352), v31);
    while (!sub_100F649C4(v31, (uint64_t)&v26))
    {
      uint64_t v8 = v27;
      uint64_t v7 = v28;
      int v9 = v29;
      BOOL v10 = v30 != 0;
      uint64_t v11 = (char *)a2[1];
      int v12 = (char *)a2[2];
      if (v11 >= v12)
      {
        uint64_t v14 = (v11 - (_BYTE *)*a2) >> 5;
        unint64_t v15 = v14 + 1;
        uint64_t v16 = v12 - (_BYTE *)*a2;
        if (v16 >> 4 > v15) {
          unint64_t v15 = v16 >> 4;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17) {
          unint64_t v18 = (char *)sub_10000835C((uint64_t)(a2 + 2), v17);
        }
        else {
          unint64_t v18 = 0LL;
        }
        unint64_t v19 = &v18[32 * v14];
        *(void *)unint64_t v19 = v8;
        *((void *)v19 + 1) = v7;
        *((_DWORD *)v19 + 4) = v9;
        v19[20] = v10;
        int v21 = (char *)*a2;
        unint64_t v20 = (char *)a2[1];
        int v22 = v19;
        if (v20 != *a2)
        {
          do
          {
            __int128 v23 = *((_OWORD *)v20 - 1);
            *((_OWORD *)v22 - 2) = *((_OWORD *)v20 - 2);
            *((_OWORD *)v22 - 1) = v23;
            v22 -= 32;
            v20 -= 32;
          }

          while (v20 != v21);
          unint64_t v20 = (char *)*a2;
        }

        uint64_t v13 = v19 + 32;
        *a2 = v22;
        a2[1] = v19 + 32;
        a2[2] = &v18[32 * v17];
        if (v20) {
          operator delete(v20);
        }
      }

      else
      {
        *(void *)uint64_t v11 = v27;
        *((void *)v11 + 1) = v7;
        *((_DWORD *)v11 + 4) = v9;
        uint64_t v13 = v11 + 32;
        void v11[20] = v10;
      }

      a2[1] = v13;
    }

    uint64_t v24 = v31[0];
    v31[0] = 0LL;
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
}

void sub_100F64984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_100F649C4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)a2 = sqlite3_column_int(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 8) = sqlite3_column_double(v7, 1);
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 16) = sqlite3_column_double(v8, 2);
  int v9 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 24) = sqlite3_column_int(v9, 3);
  BOOL v10 = (sqlite3_stmt *)sub_100019240(*a1);
  int v11 = sqlite3_column_int(v10, 4);
  uint64_t result = 0LL;
  *(_DWORD *)(a2 + 28) = v11;
  return result;
}

uint64_t sub_100F64A7C(uint64_t a1, void **a2, double a3)
{
  uint64_t v7 = a1 + 112;
  uint64_t v6 = *(void *)(a1 + 112);
  v37[2] = (id)(a1 + 112);
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 112);
  __int16 v38 = 256;
  sub_100222B94(v37, (uint64_t)"CLSedentaryAlarmRecorderDb.querySedentaryAlarmDataSince", 0);
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    sub_100B14CF8((uint64_t *)(a1 + 480), &v36);
    uint64_t v8 = (sqlite3_stmt *)sub_100019240(v36);
    if (sub_1003B7480(v8, 1, a3))
    {
      int v9 = (sqlite3_stmt *)sub_100019240(v36);
      double Current = CFAbsoluteTimeGetCurrent();
      if (sub_1003B7480(v9, 2, Current))
      {
        while (!sub_100F649C4(&v36, (uint64_t)&v31))
        {
          uint64_t v12 = v32;
          uint64_t v11 = v33;
          int v13 = v34;
          BOOL v14 = v35 != 0;
          unint64_t v15 = (char *)a2[1];
          uint64_t v16 = (char *)a2[2];
          if (v15 >= v16)
          {
            uint64_t v18 = (v15 - (_BYTE *)*a2) >> 5;
            unint64_t v19 = v18 + 1;
            uint64_t v20 = v16 - (_BYTE *)*a2;
            if (v20 >> 4 > v19) {
              unint64_t v19 = v20 >> 4;
            }
            else {
              unint64_t v21 = v19;
            }
            if (v21) {
              int v22 = (char *)sub_10000835C((uint64_t)(a2 + 2), v21);
            }
            else {
              int v22 = 0LL;
            }
            __int128 v23 = &v22[32 * v18];
            *(void *)__int128 v23 = v12;
            *((void *)v23 + 1) = v11;
            *((_DWORD *)v23 + 4) = v13;
            v23[20] = v14;
            uint64_t v25 = (char *)*a2;
            uint64_t v24 = (char *)a2[1];
            uint64_t v26 = v23;
            if (v24 != *a2)
            {
              do
              {
                __int128 v27 = *((_OWORD *)v24 - 1);
                *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
                *((_OWORD *)v26 - 1) = v27;
                v26 -= 32;
                v24 -= 32;
              }

              while (v24 != v25);
              uint64_t v24 = (char *)*a2;
            }

            unint64_t v17 = v23 + 32;
            *a2 = v26;
            a2[1] = v23 + 32;
            a2[2] = &v22[32 * v21];
            if (v24) {
              operator delete(v24);
            }
          }

          else
          {
            *(void *)unint64_t v15 = v32;
            *((void *)v15 + 1) = v11;
            *((_DWORD *)v15 + 4) = v13;
            unint64_t v17 = v15 + 32;
            v15[20] = v14;
          }

          a2[1] = v17;
        }
      }
    }

    uint64_t v29 = v36;
    uint64_t v36 = 0LL;
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
    }
    uint64_t v28 = 100LL;
  }

  else
  {
    uint64_t v28 = 109LL;
  }

  sub_1001BA1BC(v37);
  (*(void (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
  return v28;
}

void sub_100F64C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  id v7 = va_arg(va1, id);
  uint64_t v9 = va_arg(va1, void);
  sub_1001BA1BC((id *)va);
  sub_1011C52D0((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F64CDC(uint64_t a1)
{
  double v3 = (sqlite3_stmt *)sub_100019240(v8);
  int v4 = sqlite3_step(v3);
  if (v4 == 100)
  {
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    uint64_t v1 = sqlite3_column_int(v5, 0);
  }

  uint64_t v6 = v8;
  uint64_t v8 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  if (v4 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100F64D6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F64D94(uint64_t a1)
{
  return sub_100F64CDC(a1 - 72);
}

uint64_t sub_100F64D9C(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result)
  {
    sub_1003B59A0( *(void *)(a1 + 80),  "SedentaryAlarmHistory",  (const char **)&qword_10199F6D8,  (const std::string::value_type **)&qword_10199F7F8,  0);
    *(void *)(a1 + 336) = sub_1003BF158(*(void *)(a1 + 80), "SELECT COUNT(*) FROM SedentaryAlarmHistory");
    *(void *)(a1 + 344) = v3;
    *(void *)(a1 + 352) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM SedentaryAlarmHistory ORDER BY startTime ASC");
    *(void *)(a1 + 360) = v4;
    *(void *)(a1 + 384) = sub_1003BF158(*(void *)(a1 + 80), "DELETE FROM SedentaryAlarmHistory WHERE startTime < ?");
    *(void *)(a1 + 392) = v5;
    *(void *)(a1 + 400) = sub_1003BF158(*(void *)(a1 + 80), "DELETE FROM SedentaryAlarmHistory WHERE startTime > ?");
    *(void *)(a1 + 408) = v6;
    *(void *)(a1 + 416) = sub_1003BF158(*(void *)(a1 + 80), "DELETE FROM SedentaryAlarmHistory");
    *(void *)(a1 + 424) = v7;
    *(void *)(a1 + 432) = sub_1003BF158( *(void *)(a1 + 80),  "INSERT INTO SedentaryAlarmHistory (startTime, firedTime, alarmType, didWake) VALUES (?, ?, ?, ?)");
    *(void *)(a1 + 440) = v8;
    *(void *)(a1 + 464) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM SedentaryAlarmHistory ORDER BY startTime DESC LIMIT 1");
    *(void *)(a1 + 472) = v9;
    *(void *)(a1 + 480) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM SedentaryAlarmHistory WHERE startTime >= ? and startTime < ? ORDER BY startTime ASC");
    *(void *)(a1 + 488) = v10;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152LL))(a1);
    *(_DWORD *)(a1 + 132) = result;
  }

  return result;
}

uint64_t sub_100F64E9C(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 416), &v7);
    uint64_t v3 = *(void *)(a1 + 80);
    uint64_t v4 = (sqlite3_stmt *)sub_100019240(v7);
    sub_1003BB2BC(v3, v4);
    uint64_t v5 = *(void *)(a1 + 80);
    else {
      uint64_t v6 = *(void *)(v5 + 88);
    }
    sub_1003C1EC0(v5, v6);
    *(_DWORD *)(a1 + 132) = 0;
    uint64_t result = v7;
    uint64_t v7 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100F64F24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F64F48(uint64_t a1)
{
  return sub_100F64E9C(a1 - 72);
}

uint64_t sub_100F64F50(uint64_t a1, double *a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, double *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
    sub_100B14CF8((uint64_t *)(a1 + 400), &v14);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v14);
    if (sub_1003B7480(v5, 1, *a2))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v14);
      sub_1003BB2BC(v6, v7);
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152LL))(a1);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      uint64_t v8 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "SedentaryAlarm, Failed to delete records",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        __int16 v13 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "SedentaryAlarm, Failed to delete records",  &v13,  2);
        uint64_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryAlarmRecorderDb::deleteRecordsAfterInsertUL(const CLSedentaryAlarmData &)",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }
    }

    uint64_t v9 = *(void *)(a1 + 80);
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    sub_1003C1EC0(v9, v10);
    uint64_t result = v14;
    uint64_t v14 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100F6518C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F651BC(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if (a2 < 0.0 && (_DWORD)result != 0)
  {
    sub_100B14CF8((uint64_t *)(a1 + 400), &v19);
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v19);
    double Current = CFAbsoluteTimeGetCurrent();
    if (sub_1003B7480(v6, 1, Current))
    {
      uint64_t v8 = *(void *)(a1 + 80);
      uint64_t v9 = (sqlite3_stmt *)sub_100019240(v19);
      sub_1003BB2BC(v8, v9);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning SedentaryAlarm, Time rolled back, deleting records in the future",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        __int16 v18 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning SedentaryAlarm, Time rolled back, deleting records in the future",  &v18,  2);
        unint64_t v17 = (uint8_t *)v16;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSedentaryAlarmRecorderDb::shiftRecordsByUL(CFTimeInterval)",  "%s\n",  v16);
        if (v17 != buf) {
          free(v17);
        }
      }

      uint64_t v11 = *(void *)(a1 + 80);
      else {
        uint64_t v12 = *(void *)(v11 + 88);
      }
      sub_1003C1EC0(v11, v12);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      __int16 v13 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "SedentaryAlarm, Failed to shift records",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        __int16 v18 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "SedentaryAlarm, Failed to shift records",  &v18,  2);
        unint64_t v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryAlarmRecorderDb::shiftRecordsByUL(CFTimeInterval)",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }
    }

    uint64_t result = v19;
    uint64_t v19 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100F65514( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F65548(uint64_t a1, __int128 *a2)
{
  if (sub_100D8A92C(a1 + 72))
  {
    sub_100B14CF8((uint64_t *)(a1 + 432), buf);
    uint64_t v4 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003B7480(v4, 1, *(double *)a2))
    {
      uint64_t v5 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
      if (sub_1003B7480(v5, 2, *((double *)a2 + 1)))
      {
        uint64_t v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
        if (sub_1003C28BC(v6, 3, *((_DWORD *)a2 + 4)))
        {
          uint64_t v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
          if (sub_1003C28BC(v7, 4, *((unsigned __int8 *)a2 + 20)))
          {
            uint64_t v8 = *(void *)(a1 + 80);
            uint64_t v9 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
            sub_1003BB2BC(v8, v9);
            ++*(_DWORD *)(a1 + 132);
            uint64_t v10 = *(void **)(a1 + 496);
            if (v10)
            {
              if (*(void *)(a1 + 504))
              {
                __int128 v11 = a2[1];
                __int128 v18 = *a2;
                __int128 v19 = v11;
                v17[0] = _NSConcreteStackBlock;
                v17[1] = 3221225472LL;
                v17[2] = sub_100F65810;
                v17[3] = &unk_10182D1B8;
                v17[4] = a1;
                [v10 async:v17];
              }
            }
          }
        }
      }
    }

    uint64_t v12 = *(void *)buf;
    *(void *)uint64_t buf = 0LL;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    __int16 v13 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "SedentaryAlarm, Failed to insert record",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      __int16 v16 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "SedentaryAlarm, Failed to insert record",  &v16,  2);
      unint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryAlarmRecorderDb::insertRecordUL(const CLSedentaryAlarmData &, BOOL)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

void sub_100F657E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a21) {
    (*(void (**)(uint64_t))(*(void *)a21 + 8LL))(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F65810(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 504LL);
  __int128 v2 = *(_OWORD *)(a1 + 56);
  v4[0] = *(_OWORD *)(a1 + 40);
  v4[1] = v2;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(v1 + 16))(v1, v4);
}

uint64_t sub_100F6584C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100F649C4(&v12, (uint64_t)v8);
  if (!(_DWORD)v4)
  {
    *(_OWORD *)a2 = v9;
    int v5 = v11;
    *(_DWORD *)(a2 + 16) = v10;
    *(_BYTE *)(a2 + 20) = v5 != 0;
  }

  uint64_t v6 = v12;
  uint64_t v12 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  return v4;
}

void sub_100F658E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 24);
  *(void *)(v1 - 24) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F65904(uint64_t a1, unint64_t *a2)
{
  int v4 = (*(uint64_t (**)(uint64_t, double *))(*(void *)a1 + 104LL))(a1, v10);
  if (v4 == 1) {
    goto LABEL_5;
  }
  if (!v4)
  {
    v5.n128_u64[0] = *a2;
LABEL_5:
    (*(void (**)(uint64_t, unint64_t *, void, __n128))(*(void *)a1 + 120LL))(a1, a2, 0LL, v5);
    return;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10188EA00);
  }
  uint64_t v6 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "SedentaryAlarm, Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    v9[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "SedentaryAlarm, Failed to insert record due to failure from reading the most recent entry.",  v9,  2);
    uint64_t v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryAlarmRecorderDb::sanitizeAndStoreRecordUL(const CLSedentaryAlarmData &, BOOL)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

uint64_t sub_100F65AF8(void *a1, void **a2, double a3, double a4)
{
  int v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v41);
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if (HIBYTE(v42)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_101279F2C(v10);
    goto LABEL_40;
  }

  int v4 = (std::stringbuf *)v41[1];
  operator delete(v41[0]);
  if (!v4) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v41);
  int v11 = sub_10000CF44(&v42, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(void **__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v13 = BYTE7(v38);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = a1[10];
  int v4 = &v43;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v43);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    __int16 v16 = (char *)__p;
  }
  else {
    __int16 v16 = (char *)__p[0];
  }
  sub_1003C0D54(v15, v16, &v39);
  uint64_t v5 = v39;
  uint64_t v39 = 0LL;
  uint64_t v40 = v5;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    __int128 v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v40, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        uint64_t v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v24 = ((char *)v20 - (_BYTE *)*a2) >> 5;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = v21 - (void)*a2;
          if (v26 >> 4 > v25) {
            unint64_t v25 = v26 >> 4;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            uint64_t v28 = (char *)sub_10000835C((uint64_t)(a2 + 2), v27);
          }
          else {
            uint64_t v28 = 0LL;
          }
          uint64_t v29 = &v28[32 * v24];
          __int128 v30 = v38;
          *(_OWORD *)uint64_t v29 = *(_OWORD *)__p;
          *((_OWORD *)v29 + 1) = v30;
          uint64_t v32 = (char *)*a2;
          uint64_t v31 = (char *)a2[1];
          uint64_t v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *((_OWORD *)v31 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 32;
              v31 -= 32;
            }

            while (v31 != v32);
            uint64_t v31 = (char *)*a2;
          }

          __int128 v23 = v29 + 32;
          *a2 = v33;
          a2[1] = v29 + 32;
          a2[2] = &v28[32 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = v38;
          *uint64_t v20 = *(_OWORD *)__p;
          v20[1] = v22;
          __int128 v23 = v20 + 2;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v40;
      goto LABEL_42;
    }
  }

void sub_100F65DFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100F65E64(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)uint64_t buf = 134349056;
        *(void *)uint64_t v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        uint64_t v36 = (uint8_t *)v35;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLSedentaryAlarmData>::setDatabaseAccessible() [T = CLSedentaryAlarmData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v35);
        if (v36 != buf) {
          free(v36);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    int v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      int v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    uint64_t v13 = *(void *)(a1 + 184);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = (void *)(v13 + 8LL * (*(void *)(a1 + 208) >> 7));
    if (v14 == v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *v15 + 32 * (*(void *)(a1 + 208) & 0x7FLL);
    }
    while (1)
    {
      if (v14 == v13)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        unint64_t v21 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v22 = *(void *)(v13 + ((v21 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v21 & 0x7F);
      }

      if (v16 == v22) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10188EB18);
      }
      __int128 v23 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10188EB18);
        }
        LOWORD(v39) = 0;
        LODWORD(v37) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v37);
        uint64_t v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLSedentaryAlarmData>::setDatabaseAccessible() [T = CLSedentaryAlarmData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v16, 1LL);
      v16 += 32LL;
      if (v16 - *v15 == 4096)
      {
        uint64_t v24 = v15[1];
        ++v15;
        uint64_t v16 = v24;
      }

      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v14 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EA00);
    }
    unint64_t v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      __int128 v18 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
    }

    uint64_t v19 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v20 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 128) = 1;
  }

  unint64_t v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      unint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 64LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 128LL;
  }

  *(void *)(a1 + 208) = v31;
LABEL_61:
  uint64_t v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100F6656C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F665A0(uint64_t a1)
{
  return sub_100F65E64(a1 - 72);
}

void sub_100F665A8(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100F665D4(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10127A094(v4);
LABEL_44:
    sub_100007008();
  }

  uint64_t v30 = v35[1];
  operator delete(v35[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v35);
    uint64_t v6 = sub_10000CF44(&v36, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(void **__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v32);
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v37);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      int v11 = (char *)__p;
    }
    else {
      int v11 = (char *)__p[0];
    }
    sub_1003C0D54(v10, v11, &v33);
    uint64_t v12 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v12;
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)__p))
    {
      uint64_t v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v17 = (v13 - *a2) >> 5;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v14 - (void)*a2;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          unint64_t v21 = (char *)sub_10000835C((uint64_t)(a2 + 2), v20);
        }
        else {
          unint64_t v21 = 0LL;
        }
        uint64_t v22 = &v21[32 * v17];
        __int128 v23 = v32;
        *(_OWORD *)uint64_t v22 = *(_OWORD *)__p;
        *((_OWORD *)v22 + 1) = v23;
        unint64_t v25 = *a2;
        uint64_t v24 = a2[1];
        uint64_t v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *((_OWORD *)v24 - 1);
            *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v24 -= 32;
          }

          while (v24 != v25);
          uint64_t v24 = *a2;
        }

        uint64_t v16 = v22 + 32;
        *a2 = v26;
        a2[1] = v22 + 32;
        a2[2] = &v21[32 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = v32;
        *(_OWORD *)uint64_t v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        uint64_t v16 = v13 + 32;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v34;
    uint64_t v34 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v35
    uint64_t v36 = v29;
    std::streambuf::~streambuf(&v37);
    return std::ios::~ios(&v38);
  }

  return result;
}

void sub_100F66894( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

id *sub_100F668FC(uint64_t a1, uint64_t a2, char a3)
{
  v33[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v33[1] = 0LL;
  if (*(double *)(a1 + 224) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v33);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, double *))(*(void *)a1 + 104LL))(a1, v32);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      unint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        LOWORD(v34) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v34,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLSedentaryAlarmData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSede ntaryAlarmData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)a2;
    double v8 = v32[0];
    double v9 = *(double *)a2 - v32[0];
    if (v9 < 0.0) {
      double v9 = -v9;
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        double v11 = *(double *)a2;
        *(_DWORD *)uint64_t buf = 134349312;
        double v39 = v32[0];
        __int16 v40 = 2050;
        double v41 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        double v23 = *(double *)a2;
        int v34 = 134349312;
        double v35 = v32[0];
        __int16 v36 = 2050;
        double v37 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v34,  22);
        unint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSedentaryAlarmData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSede ntaryAlarmData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)a2;
      double v8 = v32[0];
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)a2;
          *(_DWORD *)uint64_t buf = 134217984;
          double v39 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10188EA00);
          }
          double v26 = *(double *)a2;
          int v34 = 134217984;
          double v35 = v26;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v34));
          uint64_t v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSedentaryAlarmData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSe dentaryAlarmData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v31 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10188EA00);
        double v18 = v31;
      }

      double v19 = v17 - v18;
      unint64_t v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        double v39 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188EA00);
        }
        int v34 = 134217984;
        double v35 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v34));
        uint64_t v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSedentaryAlarmData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSede ntaryAlarmData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, double *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, v32, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100F67038( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100F67064(void *a1, double *a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_10127A1FC(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  double v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, double *, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v11 = &__p;
    }
    else {
      double v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100F672C4(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10127A364(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v11 = &__p;
    }
    else {
      double v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100F674FC(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10127A4CC(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_100F67724(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_100F67750()
{
  qword_10199F6D8 = (uint64_t)"id";
  dword_10199F6E0 = 1;
  word_10199F6E4 = 1;
  byte_10199F6E8 = 0;
  byte_10199F700 = 0;
  qword_10199F708 = (uint64_t)"startTime";
  dword_10199F710 = 2;
  word_10199F714 = 0;
  byte_10199F718 = 0;
  byte_10199F730 = 0;
  qword_10199F738 = (uint64_t)"firedTime";
  dword_10199F740 = 2;
  word_10199F744 = 0;
  byte_10199F748 = 0;
  byte_10199F760 = 0;
  qword_10199F768 = (uint64_t)"alarmType";
  dword_10199F770 = 1;
  word_10199F774 = 0;
  byte_10199F778 = 0;
  byte_10199F790 = 0;
  qword_10199F798 = (uint64_t)"didWake";
  dword_10199F7A0 = 1;
  word_10199F7A4 = 0;
  byte_10199F7A8 = 0;
  byte_10199F7C0 = 0;
  qword_10199F7C8 = 0LL;
  dword_10199F7D0 = 5;
  word_10199F7D4 = 0;
  byte_10199F7D8 = 0;
  byte_10199F7F0 = 0;
  qword_10199F7F8 = (uint64_t)"startTime";
  unk_10199F800 = 0LL;
}

void *sub_100F67828(void *a1, uint64_t a2, void *a3)
{
  a1[2] = a3;
  *a1 = off_10188EB48;
  a1[1] = a2;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_100F67914;
  v8[3] = &unk_10182B3E0;
  v8[4] = a1;
  CLConnection::setDefaultMessageHandler(a2, v8);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___CLDaemonSpringTrackingClientAdapter);
  a1[4] = v5;
  -[CLDaemonSpringTrackingClientAdapter setValid:](v5, "setValid:", 1LL);
  id v6 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLSpringTrackingNotifier");
  a1[3] = v6;
  objc_msgSend(v6, "registerDelegate:inSilo:", a1[4], objc_msgSend(a3, "silo"));
  return a1;
}

void sub_100F67900(_Unwind_Exception *a1)
{
}

void sub_100F67914(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    double v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100F679A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100F679B8(uint64_t a1)
{
  *(void *)a1 = off_10188EB48;

  [*(id *)(a1 + 32) setValid:0];
  *(void *)(a1 + 32) = 0LL;
  return sub_100213E60((void *)a1);
}

void sub_100F67A0C(uint64_t a1)
{
  uint64_t v1 = sub_100F679B8(a1);
  operator delete(v1);
}

void sub_100F67A20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)CLConnectionMessage::name(*(CLConnectionMessage **)a2);
  int v5 = *((char *)v4 + 23);
  if (v5 < 0)
  {
    if (v4[1] != 58LL) {
      goto LABEL_7;
    }
    uint64_t v4 = (void *)*v4;
  }

  else if (v5 != 58)
  {
    goto LABEL_7;
  }

  if (!memcmp(v4, "SpringTracking/kCLConnectionMessageSpringTrackerIsTracking", 0x3AuLL))
  {
    uint64_t v20 = *(CLConnectionMessage **)a2;
    uint64_t v21 = *(std::__shared_weak_count **)(a2 + 8);
    v41[0] = (uint64_t)v20;
    v41[1] = (uint64_t)v21;
    if (v21)
    {
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v23 = __ldxr(p_shared_owners);
      while (__stxr(v23 + 1, p_shared_owners));
    }

    sub_100F67EA4(a1, v41);
    if (!v21) {
      return;
    }
    std::stringbuf v24 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    goto LABEL_67;
  }

void sub_100F67E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id *sub_100F67EA4(uint64_t a1, uint64_t *a2)
{
  if ((sub_100F68AA4(a1, (int *)&v9) & 1) != 0)
  {
    sub_100222B94(v8, (uint64_t)"CLDaemonClient.SpringTrackingNotifierIsTracking", 0);
    id v4 = [*(id *)(a1 + 24) syncgetIsTracking];
    uint64_t v5 = *a2;
    uint64_t v10 = CMReturnCode;
    int v11 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v4);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v11,  &v10,  1LL);
    CLConnectionMessage::sendReply(v5);
    return sub_1001BA1BC(v8);
  }

  else
  {
    uint64_t v7 = *a2;
    uint64_t v12 = CMErrorMessage;
    uint64_t v13 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v9);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v13,  &v12,  1LL);
    return (id *)CLConnectionMessage::sendReply(v7);
  }

void sub_100F67FC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

id *sub_100F67FE0(uint64_t a1, uint64_t *a2)
{
  if ((sub_100F68AA4(a1, (int *)&v22) & 1) != 0)
  {
    sub_100222B94(v21, (uint64_t)"CLDaemonClient.SpringTrackingNotifierStart", 0);
    id v4 = [*(id *)(a1 + 24) syncgetStartTracking];
    uint64_t v5 = *a2;
    uint64_t v38 = CMErrorMessage;
    double v39 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v4);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL);
    CLConnectionMessage::sendReply(v5);
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_10188EBB8);
    }
    id v6 = (os_log_s *)qword_101934828;
    if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_DEFAULT))
    {
      CLConnection::getName(*(CLConnection **)(a1 + 8));
      int v7 = SBYTE3(v27);
      unint64_t v8 = *(_BYTE **)__p;
      int RemotePid = CLConnection::getRemotePid(*(CLConnection **)(a1 + 8));
      uint64_t v10 = __p;
      *(_DWORD *)uint64_t buf = 136315906;
      if (v7 < 0) {
        uint64_t v10 = v8;
      }
      double v31 = v10;
      __int16 v32 = 1024;
      int v33 = RemotePid;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 1024;
      int v37 = (int)v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Tracking START, %s, %d, %p, %d", buf, 0x22u);
      if (SBYTE3(v27) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188EBB8);
      }
      uint64_t v13 = qword_101934828;
      CLConnection::getName(*(CLConnection **)(a1 + 8));
      int v14 = CLConnection::getRemotePid(*(CLConnection **)(a1 + 8));
      uint64_t v15 = &v18;
      *(_DWORD *)std::stringbuf::string_type __p = 136315906;
      if (v20 < 0) {
        uint64_t v15 = v18;
      }
      *(void *)&__p[4] = v15;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 1024;
      int v29 = (int)v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  0LL,  "Tracking START, %s, %d, %p, %d",  __p,  34,  v18,  v19);
      uint64_t v17 = v16;
      if (v20 < 0) {
        operator delete(v18);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLDaemonSpringTrackingClient::handleMessageSpringTrackerStart(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v17);
    }

    return sub_1001BA1BC(v21);
  }

  else
  {
    uint64_t v12 = *a2;
    uint64_t v40 = CMErrorMessage;
    double v41 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v22);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL);
    return (id *)CLConnectionMessage::sendReply(v12);
  }

void sub_100F68318( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, id a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
}

id *sub_100F6836C(uint64_t a1, uint64_t *a2)
{
  if ((sub_100F68AA4(a1, (int *)&v22) & 1) != 0)
  {
    sub_100222B94(v21, (uint64_t)"CLDaemonClient.SpringTrackingNotifierStop", 0);
    id v4 = [*(id *)(a1 + 24) syncgetStopTracking];
    uint64_t v5 = *a2;
    uint64_t v38 = CMErrorMessage;
    double v39 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v4);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL);
    CLConnectionMessage::sendReply(v5);
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_10188EBB8);
    }
    id v6 = (os_log_s *)qword_101934828;
    if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_DEFAULT))
    {
      CLConnection::getName(*(CLConnection **)(a1 + 8));
      int v7 = SBYTE3(v27);
      unint64_t v8 = *(_BYTE **)__p;
      int RemotePid = CLConnection::getRemotePid(*(CLConnection **)(a1 + 8));
      uint64_t v10 = __p;
      *(_DWORD *)uint64_t buf = 136315906;
      if (v7 < 0) {
        uint64_t v10 = v8;
      }
      double v31 = v10;
      __int16 v32 = 1024;
      int v33 = RemotePid;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 1024;
      int v37 = (int)v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Tracking STOP, %s, %d, %p, %d", buf, 0x22u);
      if (SBYTE3(v27) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188EBB8);
      }
      uint64_t v13 = qword_101934828;
      CLConnection::getName(*(CLConnection **)(a1 + 8));
      int v14 = CLConnection::getRemotePid(*(CLConnection **)(a1 + 8));
      uint64_t v15 = &v18;
      *(_DWORD *)std::stringbuf::string_type __p = 136315906;
      if (v20 < 0) {
        uint64_t v15 = v18;
      }
      *(void *)&__p[4] = v15;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 1024;
      int v29 = (int)v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  0LL,  "Tracking STOP, %s, %d, %p, %d",  __p,  34,  v18,  v19);
      uint64_t v17 = v16;
      if (v20 < 0) {
        operator delete(v18);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLDaemonSpringTrackingClient::handleMessageSpringTrackerStop(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v17);
    }

    return sub_1001BA1BC(v21);
  }

  else
  {
    uint64_t v12 = *a2;
    uint64_t v40 = CMErrorMessage;
    double v41 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v22);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL);
    return (id *)CLConnectionMessage::sendReply(v12);
  }

void sub_100F686A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, id a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
}

id *sub_100F686F8(uint64_t a1, uint64_t a2)
{
  if ((sub_100F68AA4(a1, (int *)&v29) & 1) != 0)
  {
    objc_opt_class(&OBJC_CLASS___CMSleepData);
    uint64_t v5 = v4;
    *(void *)&double v6 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses( *(CLConnectionMessage **)a2,  +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v5, v6, v7, 0LL));
    if (DictionaryOfClasses
      && (unsigned int v9 = DictionaryOfClasses,
          uint64_t v10 = CMSpringKeyDataRecord,
          [DictionaryOfClasses objectForKeyedSubscript:CMSpringKeyDataRecord]))
    {
      sub_100222B94(v28, (uint64_t)"CLDaemonClient.SpringTrackingNotifierQuery", 0);
      objc_msgSend(objc_msgSend(v9, "objectForKeyedSubscript:", v10), "convertToSpringTrackerEntry:", buf);
      int v11 = *(void **)(a1 + 24);
      v30[0] = buf[0];
      v30[1] = buf[1];
      unsigned int v30[2] = buf[2];
      uint64_t v31 = v35;
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3321888768LL;
      v26[2] = sub_100F68B54;
      uint64_t v26[3] = &unk_10188EB70;
      uint64_t v13 = *(CLConnectionMessage **)a2;
      uint64_t v12 = *(std::__shared_weak_count **)(a2 + 8);
      v26[4] = a1;
      v26[5] = v13;
      uint64_t v27 = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }

      [v11 querySinceRecord:v30 withReply:v26];
      uint64_t v16 = v27;
      if (v27)
      {
        uint64_t v17 = (unint64_t *)&v27->__shared_owners_;
        do
          unint64_t v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }

      return sub_1001BA1BC(v28);
    }

    else
    {
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188EBB8);
      }
      uint64_t v21 = (os_log_s *)qword_101934828;
      if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Error in query request.", (uint8_t *)buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934820 != -1) {
          dispatch_once(&qword_101934820, &stru_10188EBB8);
        }
        LOWORD(v28[0]) = 0;
        LODWORD(v25) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  17LL,  "Error in query request.",  v28,  v25);
        __int16 v24 = (char *)v23;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLDaemonSpringTrackingClient::handleMessageSpringTrackerQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v23);
      }

      unsigned int v22 = *(CLConnectionMessage **)a2;
      uint64_t v32 = CMErrorMessage;
      int v33 = &off_1018D5078;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL);
      return (id *)CLConnectionMessage::sendReply(v22);
    }
  }

  else
  {
    char v20 = *(CLConnectionMessage **)a2;
    uint64_t v36 = CMErrorMessage;
    int v37 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v29);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v37,  &v36,  1LL);
    return (id *)CLConnectionMessage::sendReply(v20);
  }

void sub_100F68A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100F68AA4(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  sub_1010DDBC0(__p, "com.apple.locationd.activity");
  char isEntitled = CLConnection::isEntitled(v4, __p);
  char v6 = isEntitled;
  if (v10 < 0)
  {
    operator delete(__p[0]);
    if ((v6 & 1) != 0) {
      goto LABEL_3;
    }
LABEL_6:
    int v8 = 105;
    goto LABEL_8;
  }

  if ((isEntitled & 1) == 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((sub_100E96D94(*(void *)(a1 + 16)) & 1) != 0) {
    return 1LL;
  }
  int v8 = 104;
LABEL_8:
  uint64_t result = 0LL;
  *a2 = v8;
  return result;
}

void sub_100F68B38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F68B54(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = &__NSArray0__struct;
  }
  uint64_t v34 = CMSpringKeyDataArray;
  uint64_t v35 = v5;
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v35,  &v34,  1LL);
  sub_1004F2598();
  if (sub_1004F8A40() && [a2 count])
  {
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_10188EBB8);
    }
    char v6 = (os_log_s *)qword_101934828;
    if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_INFO))
    {
      id v7 = [a2 lastObject];
      CLConnection::getName(*(CLConnection **)(v4 + 8));
      int RemotePid = CLConnection::getRemotePid(*(CLConnection **)(v4 + 8));
      unsigned int v9 = __p;
      *(_DWORD *)uint64_t buf = 138413058;
      if (v22 < 0) {
        unsigned int v9 = *(_BYTE **)__p;
      }
      id v27 = v7;
      __int16 v28 = 2080;
      unsigned int v29 = v9;
      __int16 v30 = 1024;
      int v31 = RemotePid;
      __int16 v32 = 2048;
      uint64_t v33 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%@, %s, %d, %p", buf, 0x26u);
      if (SHIBYTE(v22) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188EBB8);
      }
      uint64_t v11 = qword_101934828;
      id v12 = [a2 lastObject];
      CLConnection::getName(*(CLConnection **)(v4 + 8));
      int v13 = CLConnection::getRemotePid(*(CLConnection **)(v4 + 8));
      int v14 = &v17;
      *(_DWORD *)std::stringbuf::string_type __p = 138413058;
      if (v18 < 0) {
        int v14 = v17;
      }
      *(void *)&__p[4] = v12;
      __int16 v20 = 2080;
      uint64_t v21 = v14;
      __int16 v22 = 1024;
      int v23 = v13;
      __int16 v24 = 2048;
      uint64_t v25 = v4;
      _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v11, 1LL, "%@, %s, %d, %p", __p, 38);
      uint64_t v16 = v15;
      if (v18 < 0) {
        operator delete(v17);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLDaemonSpringTrackingClient::handleMessageSpringTrackerQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke",  "%s\n",  v16);
    }
  }

  return CLConnectionMessage::sendReply(*(void *)(a1 + 40));
}

void sub_100F68E54( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F68E8C(id a1)
{
  qword_101934828 = (uint64_t)os_log_create("com.apple.locationd.Position", "Spring");
}

uint64_t sub_100F68EB8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_1003070C0(a1, a3);
  *(void *)uint64_t v5 = off_10188EBE8;
  *(void *)(v5 + 200) = off_10188EC50;
  sub_100A3ECDC(v5 + 200, *(unsigned __int8 *)(v5 + 8), 0);
  *(void *)a1 = off_10188EBE8;
  *(void *)(a1 + 200) = off_10188EC50;
  *(void *)(a1 + 280) = 0LL;
  *(void *)(a1 + 288) = 0LL;
  uint64_t v6 = sub_1006FE6A0();
  double v12 = sub_1006FE6E4(v6, a1 + 24);
  sub_1007BFD18(a1 + 296, &v12, a1 + 16, a2);
  sub_1004F2598();
  int v7 = sub_1004F75F8();
  double v8 = 0.25;
  if (v7) {
    double v8 = 0.5;
  }
  *(double *)(a1 + 920) = v8;
  *(_OWORD *)(a1 + 928) = xmmword_1013B9420;
  sub_1004F2598();
  int v9 = sub_1004F75F8();
  float v10 = 0.00035;
  if (v9) {
    float v10 = 0.00015;
  }
  *(float *)(a1 + 944) = v10;
  return a1;
}

void sub_100F68FA4(_Unwind_Exception *a1)
{
}

uint64_t sub_100F68FDC(void *a1)
{
  *a1 = off_10188EBE8;
  a1[25] = off_10188EC50;
  uint64_t v2 = a1 + 25;
  sub_100F693AC(a1);
  sub_1007BFD74(a1 + 37);
  sub_100A3ED0C(v2);
  return sub_100307A9C((uint64_t)a1);
}

uint64_t sub_100F69030(uint64_t a1)
{
  return sub_100F68FDC((void *)(a1 - 200));
}

void sub_100F69038(void *a1)
{
  uint64_t v1 = (void *)sub_100F68FDC(a1);
  operator delete(v1);
}

void sub_100F6904C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100F68FDC((void *)(a1 - 200));
  operator delete(v1);
}

uint64_t sub_100F69064(uint64_t a1)
{
  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_10188ECB8);
  }
  uint64_t v2 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
  {
    sub_1006E27E8();
    *(_DWORD *)uint64_t buf = 136446210;
    *(void *)&uint8_t buf[4] = sub_1006E30E0();
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "%{public}s is enabling power conservative device motion for parallax.",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10188ECB8);
    }
    uint64_t v7 = qword_101934568;
    sub_1006E27E8();
    *(_DWORD *)double v12 = 136446210;
    *(void *)&v12[4] = sub_1006E30E0();
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  1LL,  "%{public}s is enabling power conservative device motion for parallax.",  v12,  12);
    int v9 = (char *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLSensorFusionService3AxisDynamicGyro::start()", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  sub_1007BFD94(a1 + 296);
  *(void *)uint64_t buf = 0LL;
  unint64_t v11 = 0xBFF0000000000000LL;
  *(void *)double v12 = 0LL;
  double v10 = sub_101171D38();
  sub_1007C1678(a1 + 296, (double *)buf, (double *)v12, (double *)&v11, &v10);
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_1018A2210;
  *uint64_t v3 = &off_10185EBF0;
  v3[1] = 0LL;
  v3[2] = nullsub_1181;
  v3[3] = a1;
  *(void *)(a1 + 288) = v3;
  uint64_t v4 = sub_1006FE6A0();
  sub_1006DCB40(v4, 0, *(void *)(a1 + 288), 1.0);
  sub_100A3EE64(a1 + 200, *(double *)(a1 + 24));
  sub_100A3EF20(a1 + 200);
  uint64_t v5 = (char *)operator new(0xE8uLL);
  *((void *)v5 + 2) = off_10184DB98;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((void *)v5 + 10) = 0LL;
  *((void *)v5 + 11) = off_10184DB98;
  *((void *)v5 + 20) = off_10184DB98;
  *((void *)v5 + 12) = 8LL;
  *(_OWORD *)(v5 + 104) = 0u;
  *(_OWORD *)(v5 + 120) = 0u;
  *(_OWORD *)(v5 + 136) = 0u;
  *((void *)v5 + 19) = 0LL;
  *((void *)v5 + 21) = 8LL;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((void *)v5 + 28) = 0LL;
  *(void *)(a1 + 280) = v5;
  *(void *)uint64_t v5 = off_10184DB68;
  *((void *)v5 + 1) = 8LL;
  *((void *)v5 + 3) = 8LL;
  sub_10074DFF8((void *)v5 + 2);
  *((void *)v5 + 12) = 8LL;
  sub_10074DFF8((void *)v5 + 11);
  *((void *)v5 + 21) = 8LL;
  sub_10074DFF8((void *)v5 + 20);
  sub_100A3F004(a1 + 200, 0.02);
  *(void *)uint64_t buf = 2LL;
  return sub_10030867C(a1, buf);
}

void sub_100F6938C(_Unwind_Exception *a1)
{
}

uint64_t sub_100F693AC(void *a1)
{
  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_10188ECB8);
  }
  uint64_t v2 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
  {
    sub_1006E27E8();
    *(_DWORD *)uint64_t buf = 136446210;
    uint64_t v12 = sub_1006E30E0();
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "%{public}s is disabling power conservation for parallax.",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10188ECB8);
    }
    uint64_t v6 = qword_101934568;
    sub_1006E27E8();
    int v9 = 136446210;
    uint64_t v10 = sub_1006E30E0();
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  1LL,  "%{public}s is disabling power conservation for parallax.",  &v9,  12);
    double v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLSensorFusionService3AxisDynamicGyro::stop()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  sub_100A3EFD4((uint64_t)(a1 + 25));
  sub_100A3ED50(a1 + 25);
  if (a1[36])
  {
    uint64_t v3 = sub_1006FE6A0();
    sub_1006DD2A0(v3, 0, a1[36]);
    uint64_t v4 = a1[36];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    a1[36] = 0LL;
  }

  sub_100A3ED9C(a1 + 25);
  uint64_t result = a1[35];
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    a1[35] = 0LL;
  }

  return result;
}

BOOL sub_100F695CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 280);
  unint64_t v2 = *(void *)(v1 + 80);
  if (v2 < *(void *)(v1 + 24)) {
    return 1LL;
  }
  float v4 = 0.0;
  float v5 = 0.0;
  if (v2 >= 2)
  {
    float v6 = (float)((float)v2 * *(float *)(v1 + 36)) - (float)(*(float *)(v1 + 32) * *(float *)(v1 + 32));
    float v5 = 0.0;
    if (v6 >= 0.0) {
      float v5 = v6 / (float)((v2 - 1) * v2);
    }
  }

  unint64_t v7 = *(void *)(v1 + 152);
  if (v7 >= 2)
  {
    float v8 = (float)((float)v7 * *(float *)(v1 + 108)) - (float)(*(float *)(v1 + 104) * *(float *)(v1 + 104));
    if (v8 >= 0.0) {
      float v4 = v8 / (float)((v7 - 1) * v7);
    }
  }

  unint64_t v9 = *(void *)(v1 + 224);
  float v10 = 0.0;
  if (v9 >= 2)
  {
    float v11 = (float)((float)v9 * *(float *)(v1 + 180)) - (float)(*(float *)(v1 + 176) * *(float *)(v1 + 176));
    if (v11 >= 0.0) {
      float v10 = v11 / (float)((v9 - 1) * v9);
    }
  }

  if (v5 >= v4) {
    float v4 = v5;
  }
  if (v4 < v10) {
    float v4 = v10;
  }
  return v4 > *(float *)(a1 + 944);
}

void sub_100F696B0(float32x2_t *a1, uint64_t a2)
{
  double v4 = *(float *)(a2 + 8);
  float v5 = a1 + 39;
  uint64_t v6 = (uint64_t)&a1[37];
  *(double *)v15.i64 = *(float *)(a2 + 12);
  double v16 = *(float *)(a2 + 16);
  *(double *)uint64_t v17 = v4;
  sub_1007BFE90((uint64_t)&a1[37], (float64x2_t *)v17, (uint64_t)&v15, &v16, (void *)a2);
  *(float32x2_t *)v7.f32 = a1[59];
  if (*(double *)v7.i64 <= 0.0)
  {
    float32x2_t v8 = 0LL;
    float v9 = 0.0;
  }

  else
  {
    sub_1007C0D6C((double *)v17, (double *)v5);
    float32x4_t v7 = (float32x4_t)vsubq_f64(vcvtq_f64_f32(a1[60]), *(float64x2_t *)v17);
    float32x2_t v8 = vcvt_f32_f64((float64x2_t)v7);
    *(double *)v7.i64 = a1[61].f32[0] - *(double *)&v17[16];
    float v9 = *(double *)v7.i64;
  }

  __int32 v10 = a1[57].i32[1];
  *(void *)&v17[16] = 0LL;
  *(_OWORD *)uint64_t v17 = 0xBFF0000000000000LL;
  uint64_t v11 = *(uint64_t *)((char *)&v5[17] + 4);
  sub_100833700((float32x4_t *)&v17[8], v7);
  memset(&v17[24], 0, 36);
  *(_OWORD *)&v17[60] = xmmword_1012E2F40;
  uint64_t v18 = 0x1FF00000000LL;
  int v19 = 0;
  char v20 = 0;
  uint64_t v21 = 0LL;
  *(void *)uint64_t v17 = *(void *)a2;
  float32x4_t v12 = *(float32x4_t *)v5[2].f32;
  float32x4_t v15 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v5->f32), (float64x2_t)v12);
  sub_100833700(&v15, v12);
  *(float32x4_t *)&v17[8] = v15;
  *(float32x2_t *)&v17[24] = v8;
  *(float *)&v17[32] = v9;
  *(void *)&v17[36] = v11;
  *(_DWORD *)&v17[44] = v10;
  BYTE4(v18) = -1;
  *(_OWORD *)&v17[48] = xmmword_1012E2F50;
  *(_DWORD *)&v17[64] = -1082130432;
  __int16 v13 = HIWORD(v18) & 0xFFE7;
  if (a1[31].i8[4]) {
    __int16 v13 = HIWORD(v18) & 0xFFE7 | 0x10;
  }
  HIWORD(v18) = v13;
  else {
    __int16 v14 = 0;
  }
  HIWORD(v18) = HIWORD(v18) & 0xFEFF | v14;
  int v19 = 2;
  uint64_t v21 = 0LL;
  char v20 = 0;
  sub_100307D50((uint64_t)a1, (uint64_t)v17);
}

void sub_100F698AC(uint64_t a1, uint64_t a2)
{
}

double sub_100F698B4(uint64_t a1, float32x2_t *a2, float *a3)
{
  return sub_1007C095C(a1 + 296, a2, a3);
}

double sub_100F698BC(uint64_t a1, float32x2_t *a2, float *a3)
{
  return sub_1007C095C(a1 + 96, a2, a3);
}

void sub_100F698C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 280);
  sub_10074DC40(v4 + 16, (float *)(a2 + 8));
  sub_10074DC40(v4 + 88, (float *)(a2 + 12));
  sub_10074DC40(v4 + 160, (float *)(a2 + 16));
  if (sub_100F695CC(a1))
  {
    *(void *)(a1 + 936) = *(void *)a2;
    if (*(void *)(a1 + 48) == 2LL) {
      return;
    }
    uint64_t v5 = sub_1006E27E8();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_100F69A44;
    _DWORD v10[3] = &unk_10181D3D0;
    double v10[4] = a1;
    uint64_t v6 = v10;
    goto LABEL_10;
  }

  uint64_t v7 = *(void *)(a1 + 48);
  if (v7 == 1)
  {
    uint64_t v5 = sub_1006E27E8();
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    id v8[2] = sub_100F69B4C;
    v8[3] = &unk_10181D3D0;
    v8[4] = a1;
    uint64_t v6 = v8;
    goto LABEL_10;
  }

  if (v7 == 2 && *(double *)a2 > *(double *)(a1 + 936) + *(double *)(a1 + 920))
  {
    uint64_t v5 = sub_1006E27E8();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_100F69B0C;
    void v9[3] = &unk_10181D3D0;
    v9[4] = a1;
    uint64_t v6 = v9;
LABEL_10:
    sub_1006E2970(v5, (uint64_t)v6);
  }

uint64_t sub_100F69A44(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100A3EE64(v1 + 200, *(double *)(v1 + 24));
  if (!*(void *)(v1 + 288))
  {
    unint64_t v2 = operator new(0x20uLL);
    *unint64_t v2 = off_1018A2210;
    *unint64_t v2 = &off_10185EBF0;
    v2[1] = 0LL;
    v2[2] = nullsub_1181;
    v2[3] = v1;
    *(void *)(v1 + 288) = v2;
    uint64_t v3 = sub_1006FE6A0();
    sub_1006DCB40(v3, 0, *(void *)(v1 + 288), 1.0);
  }

  sub_100A3EF20(v1 + 200);
  uint64_t v5 = 2LL;
  return sub_10030867C(v1, &v5);
}

void sub_100F69AF8(_Unwind_Exception *a1)
{
}

uint64_t sub_100F69B0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100A3ED50((void *)(v1 + 200));
  uint64_t v3 = 1LL;
  return sub_10030867C(v1, &v3);
}

uint64_t sub_100F69B4C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_10188ECB8);
  }
  unint64_t v2 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10188ECB8);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.",  v8,  2);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionService3AxisDynamicGyro::feedAccelerometerData(const CLAccelerometer::Sample *)_block_invoke",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  if (*(void *)(v1 + 288))
  {
    uint64_t v3 = sub_1006FE6A0();
    sub_1006DD2A0(v3, 0, *(void *)(v1 + 288));
    uint64_t v4 = *(void *)(v1 + 288);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    *(void *)(v1 + 288) = 0LL;
  }

  sub_100A3EFD4(v1 + 200);
  *(void *)uint64_t buf = 0LL;
  return sub_10030867C(v1, buf);
}

void sub_100F69D24(uint64_t a1, uint64_t a2)
{
}

void sub_100F69D2C(id a1)
{
  qword_101934568 = (uint64_t)os_log_create("com.apple.locationd.Motion", "DeviceMotion");
}

double sub_100F69D58(uint64_t a1, double a2, double a3)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0LL;
  *(double *)(a1 + 32) = a2;
  *(double *)(a1 + 40) = a3;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 48) = 0LL;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = (unint64_t)(a2 * 100.0 + 1.0);
  *(void *)&double result = 0x26200000000LL;
  *(void *)(a1 + 88) = 0x26200000000LL;
  *(void *)(a1 + 7416) = 0x26200000000LL;
  *(void *)(a1 + 14744) = 0x26200000000LL;
  *(void *)(a1 + 22072) = 0x5100000000LL;
  *(void *)(a1 + 23052) = 0x5100000000LL;
  *(void *)(a1 + 24032) = 0x26200000000LL;
  return result;
}

uint64_t sub_100F69DC0(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v7 = (unsigned __int16 *)(a1 + 22072);
  sub_10040B364((unsigned __int16 *)(a1 + 22072), a2);
  sub_10040B364((unsigned __int16 *)(a1 + 23052), a2 + 12);
  float32x2_t v8 = sub_10040B364((unsigned __int16 *)(a1 + 24032), a2 + 12);
  unsigned __int32 v9 = sub_100F69F44((uint64_t)v8, v7).u32[0];
  unsigned int v21 = v10;
  unsigned __int32 v22 = v9;
  float v12 = v11;
  unint64_t v26 = __PAIR64__(v10, v9);
  float v27 = v11;
  v25[0] = sub_100F69F44(v13, (unsigned __int16 *)(a1 + 23052)).u32[0];
  v25[1] = v14;
  v25[2] = v15;
  double v16 = vabdd_f64(*(double *)(a2 + 56), *(double *)(a1 + 48));
  if (v16 < 0.001) {
    double v16 = 0.001;
  }
  *(float *)&double v16 = v16;
  float v17 = (float)(v12 - *(float *)(a1 + 72)) / *(float *)&v16;
  float32x2_t v23 = vdiv_f32( vsub_f32((float32x2_t)__PAIR64__(v21, v22), *(float32x2_t *)(a1 + 64)),  (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v16, 0));
  float v24 = v17;
  sub_10040B364((unsigned __int16 *)(a1 + 88), (uint64_t)&v26);
  sub_10040B364((unsigned __int16 *)(a1 + 7416), (uint64_t)v25);
  sub_10040B364((unsigned __int16 *)(a1 + 14744), (uint64_t)&v23);
  *(void *)(a1 + 64) = v26;
  *(float *)(a1 + 72) = v27;
  double v18 = *(double *)(a2 + 56);
  *(double *)(a1 + 48) = v18;
  if (*(void *)(a1 + 80) < (unint64_t)*(unsigned __int16 *)(a1 + 90)
    && v18 - *(double *)(a1 + 56) > *(double *)(a1 + 40))
  {
    sub_100F6A018(a1);
    *(_DWORD *)a1 = v19;
    *(void *)(a1 + 56) = *(void *)(a1 + 48);
    *(float *)(a1 + 16) = sub_100F6A328(a1);
  }

  *(double *)(a1 + 8) = a4;
  *(double *)(a1 + 24) = a4;
  return 1LL;
}

float32x2_t sub_100F69F44(uint64_t a1, unsigned __int16 *a2)
{
  unint64_t v3 = 0LL;
  float32x2_t v4 = 0LL;
  float v5 = 0.0;
  unint64_t v6 = 80LL;
  do
  {
    uint64_t v7 = (float32x2_t *)sub_10040B624(a2, v3);
    float32x2_t v8 = (float32x2_t *)sub_10040B624(a2, v6);
    float v9 = flt_1013B9488[v6];
    float32x2_t v4 = vadd_f32(v4, vmul_n_f32(vadd_f32(*v7, *v8), v9));
    float v5 = v5 + (float)((float)(v7[1].f32[0] + v8[1].f32[0]) * v9);
    ++v3;
    --v6;
  }

  while (v3 != 40);
  return vadd_f32(v4, vmul_f32(*(float32x2_t *)sub_10040B624(a2, 0x28uLL), 0LL));
}

void sub_100F6A018(uint64_t a1)
{
  int v68 = 0;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  unint64_t v64 = 0LL;
  float v65 = 0.0;
  unint64_t v1 = *(unsigned __int16 *)(a1 + 90);
  unint64_t v2 = v1 - 1;
  unint64_t v3 = *(void *)(a1 + 80);
  BOOL v5 = v1 >= v3;
  unint64_t v4 = v1 - v3;
  BOOL v5 = v5 && v2 >= v4;
  if (v5)
  {
    uint64_t v7 = (unsigned __int16 *)(a1 + 88);
    float32x2_t v8 = (unsigned __int16 *)(a1 + 14744);
    float v9 = (unsigned __int16 *)(a1 + 7416);
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
    do
    {
      uint64_t v13 = sub_10040B624(v7, v2);
      float v15 = *(float *)(v13 + 4);
      float v14 = *(float *)(v13 + 8);
      float v16 = *(float *)v13;
      float v17 = -*(float *)v13;
      LODWORD(v61) = 0;
      *((float *)&v61 + 1) = v14;
      *((float *)&v61 + 2) = -v15;
      *((float *)&v61 + 3) = -v14;
      LODWORD(v62) = 0;
      *(void *)((char *)&v62 + 4) = __PAIR64__(LODWORD(v15), LODWORD(v16));
      *((float *)&v62 + 3) = v17;
      int v63 = 0;
      uint64_t v18 = sub_10040B624(v8, v2);
      float v20 = *(float *)(v18 + 4);
      float v19 = *(float *)(v18 + 8);
      float v21 = *(float *)v18;
      float v22 = -*(float *)v18;
      v60[0] = 0;
      *(float *)&v60[1] = v19;
      *(float *)&v60[2] = -v20;
      *(float *)&v60[3] = -v19;
      v60[4] = 0;
      *(float *)&v60[5] = v21;
      *(float *)&v60[6] = v20;
      *(float *)&v60[7] = v22;
      v60[8] = 0;
      sub_100809A4C((uint64_t)&v61, (uint64_t)&v61, (uint64_t)&v55);
      for (unint64_t i = 0LL; i != 9; ++i)
        *((float *)&v55 + i) = sub_1005AAEAC((uint64_t)v60, i) + *((float *)&v55 + i);
      v58[0] = v55;
      v58[1] = v56;
      int v59 = v57;
      v50[0] = v55;
      v50[1] = v56;
      int v51 = v57;
      sub_1002B89B4((uint64_t)v50, (uint64_t)&v52);
      sub_100809A4C((uint64_t)&v52, (uint64_t)v58, (uint64_t)v49);
      for (unint64_t j = 0LL; j != 9; ++j)
        *((float *)&v66 + j) = sub_1005AAEAC((uint64_t)v49, j) + *((float *)&v66 + j);
      uint64_t v25 = (float *)sub_10040B624(v9, v2);
      float v12 = v12 + sub_1002B8A2C((uint64_t)&v52, v25);
      float v11 = v11 + v26;
      float v10 = v27 + v10;
      unint64_t v64 = __PAIR64__(LODWORD(v11), LODWORD(v12));
      float v65 = v10;
      --v2;
      unint64_t v28 = *(unsigned __int16 *)(a1 + 90);
      unint64_t v29 = *(void *)(a1 + 80);
      BOOL v5 = v28 >= v29;
      unint64_t v30 = v28 - v29;
    }

    while (v5 && v2 >= v30);
  }

  v47[0] = v66;
  v47[1] = v67;
  int v48 = v68;
  sub_1005AB084((uint64_t)v47, (uint64_t)&v61);
  *(void *)&v58[0] = __PAIR64__(LODWORD(v32), LODWORD(v34));
  *((float *)v58 + 2) = v33;
  if (fabsf(v34) >= 0.001 && fabsf(v32) >= 0.001 && fabsf(v33) >= 0.001)
  {
    v45[0] = v61;
    v45[1] = v62;
    int v46 = v63;
    sub_1002B89B4((uint64_t)v45, (uint64_t)v60);
    unint64_t v35 = 0LL;
    float v52 = sub_1002B8A2C((uint64_t)v60, (float *)&v64);
    int v53 = v36;
    int v54 = v37;
    do
    {
      float v38 = sub_1002B8AF0((uint64_t)v58, v35);
      double v39 = (float *)sub_1002BA24C((uint64_t)&v52, v35);
      *double v39 = *v39 / v38;
      ++v35;
    }

    while (v35 != 3);
    float v40 = sub_1002B8A2C((uint64_t)&v61, &v52);
    uint64_t v41 = 0LL;
    float v52 = v40;
    int v53 = v42;
    int v54 = v43;
    float v44 = 0.0;
    do
    {
      float v44 = v44 + (float)(*(float *)((char *)&v52 + v41) * *(float *)((char *)&v52 + v41));
      v41 += 4LL;
    }

    while (v41 != 12);
  }

float sub_100F6A328(uint64_t a1)
{
  unint64_t v1 = (unsigned __int16 *)(a1 + 24032);
  uint64_t v2 = *(unsigned int *)(a1 + 24036);
  if ((_DWORD)v2)
  {
    unint64_t v3 = 0LL;
    float v5 = 0.0;
    float v6 = 0.0;
    float v7 = 0.0;
    float v8 = 0.0;
    do
    {
      float v9 = (float *)sub_10040B624(v1, v3);
      float v11 = *v9;
      float v10 = v9[1];
      float v12 = v9[2];
      float v4 = 6.28318531 / (double)(unint64_t)(v2 - 1);
      float v13 = cosf(v4 * (float)(int)v3) * -0.46 + 0.54;
      float v5 = v5 + (float)((float)(v11 * v13) * (float)(v11 * v13));
      float v8 = v8 + (float)((float)(v10 * v13) * (float)(v10 * v13));
      float v7 = v7 + (float)((float)(v12 * v13) * (float)(v12 * v13));
      float v6 = v6 + v13;
      ++v3;
    }

    while (v2 != v3);
    float v14 = v7 + (float)(v8 + v5);
  }

  else
  {
    float v6 = 0.0;
    float v14 = 0.0;
  }

  return sqrtf(v14) / v6;
}

uint64_t sub_100F6A438(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  *(void *)a1 = off_10188ECE8;
  *(void *)(a1 + 8) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 16) = v6;
  if (v6)
  {
    float v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  *(void *)(a1 + 24) = *a3;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 32) = v9;
  if (v9)
  {
    float v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  *(void *)(a1 + 40) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 48) = v12;
  if (v12)
  {
    float v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(void *)(a1 + 56) = *a5;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 64) = v15;
  if (v15)
  {
    float v16 = (unint64_t *)(v15 + 8);
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  *(void *)(a1 + 72) = 0x40C5180000000000LL;
  uint64_t v18 = (uint64_t *)(a1 + 72);
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_BYTE *)(a1 + 592) = 0;
  *(_BYTE *)(a1 + 616) = 0;
  *(void *)(a1 + 624) = 0xBFF0000000000000LL;
  *(_BYTE *)(a1 + 632) = 0;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  sub_1002F0B04(buf);
  char v19 = sub_1002A82BC(*(uint64_t *)&buf[0], "MaxTripDuration", (void *)(a1 + 72));
  char v20 = v19;
  float v21 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_17;
  }
  float v22 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (v23)
  {
LABEL_17:
    if ((v19 & 1) != 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
  std::__shared_weak_count::__release_weak(v21);
  if ((v20 & 1) == 0) {
LABEL_18:
  }
    *uint64_t v18 = 0x40C5180000000000LL;
LABEL_19:
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10188ED90);
  }
  float v24 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *v18;
    LODWORD(buf[0]) = 134217984;
    *(void *)((char *)buf + 4) = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "CLPolicyTrip: duration,%.2fs",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188ED90);
    }
    uint64_t v27 = *v18;
    int v30 = 134217984;
    uint64_t v31 = v27;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "CLPolicyTrip: duration,%.2fs",  COERCE_DOUBLE(&v30));
    unint64_t v29 = (char *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLPolicyTrip::CLPolicyTrip(std::shared_ptr<CLPolicyTripInterface::External>, std::shared_ptr<CLHarvestSystemInterf ace::Controller>, std::shared_ptr<CLHarvestMonitorInterface::Gps>, std::shared_ptr<CLHarvestPolicyInterface::Proactive>)",  "%s\n",  v28);
  }

  return a1;
}

void sub_100F6A780(_Unwind_Exception *a1)
{
}

uint64_t sub_100F6A7D8(uint64_t a1)
{
  return a1;
}

void sub_100F6A82C(uint64_t a1)
{
  uint64_t v2 = CFUUIDCreate(0LL);
  uint64_t v3 = CFUUIDCreateString(0LL, v2);
  sub_1002A6C50(v3, &buf);
  uint64_t v4 = (void **)(a1 + 88);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  *(void *)(a1 + 104) = buf.__r_.__value_.__l.__cap_;
  CFRelease(v2);
  CFRelease(v3);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 56LL))(*(void *)(a1 + 40));
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10188ED90);
  }
  uint64_t v6 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
  {
    float v7 = (void *)(a1 + 88);
    double v8 = *(double *)(v5 + 76);
    double v9 = v8 - *(double *)(a1 + 80);
    double v10 = v8 - *(double *)(a1 + 600);
    int v11 = *(unsigned __int8 *)(a1 + 632);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
    *(double *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v8;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
    double v33 = v9;
    __int16 v34 = 2048;
    double v35 = v10;
    __int16 v36 = 1024;
    int v37 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "using trip id %s at time %.2fs (previous trip duration %.3fs and gap %.3fs) or triggerNewTripIdByProactive,%d",  (uint8_t *)&buf,  0x30u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188ED90);
    }
    double v16 = *(double *)(v5 + 76);
    double v17 = v16 - *(double *)(a1 + 80);
    double v18 = v16 - *(double *)(a1 + 600);
    int v19 = *(unsigned __int8 *)(a1 + 632);
    *(_DWORD *)unint64_t v23 = 136316162;
    *(void *)&v23[4] = v4;
    __int16 v24 = 2048;
    double v25 = v16;
    __int16 v26 = 2048;
    double v27 = v17;
    __int16 v28 = 2048;
    double v29 = v18;
    __int16 v30 = 1024;
    int v31 = v19;
    LODWORD(v22) = 48;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "using trip id %s at time %.2fs (previous trip duration %.3fs and gap %.3fs) or triggerNewTripIdByProactive,%d",  v23,  v22);
    float v21 = (std::string *)v20;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLPolicyTrip::createNewTripId()", "%s\n", v20);
    if (v21 != &buf) {
      free(v21);
    }
  }

  *(void *)(a1 + sub_100F6A7D8(v1 + 80) = *(void *)(v5 + 76);
  if (*(_BYTE *)(a1 + 632)) {
    *(_BYTE *)(a1 + 632) = 0;
  }
  memset(&buf, 0, sizeof(buf));
  if ((*(unsigned int (**)(void, std::string *, void))(**(void **)(a1 + 8) + 40LL))( *(void *)(a1 + 8),  &buf,  0LL))
  {
    uint64_t v12 = buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0] != buf.__r_.__value_.__l.__size_)
    {
      if (*buf.__r_.__value_.__l.__data_)
      {
        unsigned int v13 = *(_DWORD *)(buf.__r_.__value_.__r.__words[0] + 8);
        *(_DWORD *)(a1 + 112) = v13;
        if (v13 < 3) {
          goto LABEL_18;
        }
        if (v13 == 9)
        {
          *(_DWORD *)(a1 + 116) = *(_DWORD *)sub_1004AA0E0(v12);
          uint64_t v14 = sub_1004AA0E0((uint64_t)buf.__r_.__value_.__l.__data_);
          goto LABEL_20;
        }

        if (v13 == 7)
        {
LABEL_18:
          *(_DWORD *)(a1 + 116) = *(_DWORD *)sub_1004A932C(v12);
          uint64_t v14 = sub_1004A932C((uint64_t)buf.__r_.__value_.__l.__data_);
        }

        else
        {
          if (v13 - 3 <= 2)
          {
            *(_DWORD *)(a1 + 116) = *(_DWORD *)(sub_1004A8578(v12) + 32);
            int v15 = *(_DWORD *)(sub_1004A8578((uint64_t)buf.__r_.__value_.__l.__data_) + 36);
            goto LABEL_21;
          }

          if (v13 == 10)
          {
            *(_DWORD *)(a1 + 116) = *(_DWORD *)sub_1004ABD0C(v12);
            uint64_t v14 = sub_1004ABD0C((uint64_t)buf.__r_.__value_.__l.__data_);
          }

          else
          {
            if (v13 != 6)
            {
              int v15 = -1;
              *(_DWORD *)(a1 + 116) = -1;
              goto LABEL_21;
            }

            *(_DWORD *)(a1 + 116) = *(_DWORD *)sub_100450CD0(v12);
            uint64_t v14 = sub_100450CD0((uint64_t)buf.__r_.__value_.__l.__data_);
          }
        }

void sub_100F6AC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

char *sub_100F6AC30@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[111] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 11), *((void *)result + 12));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 88);
  *(void *)(a2 + 16) = *((void *)result + 13);
  return result;
}

BOOL sub_100F6AC5C(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (*(char *)(a1 + 111) < 0)
  {
    if (!*(void *)(a1 + 96)) {
      return 1LL;
    }
  }

  else if (!*(_BYTE *)(a1 + 111))
  {
    return 1LL;
  }

  if (*(_BYTE *)(a1 + 632)) {
    return 1LL;
  }
  double v4 = *(double *)(a2 + 76);
  if (v4 - a3 > 900.0 && v4 - a4 > 900.0) {
    return 1LL;
  }
  return v4 - *(double *)(a1 + 80) > *(double *)(a1 + 72);
}

uint64_t sub_100F6ACC0(uint64_t result, double a2)
{
  *(double *)(result + 600) = a2;
  return result;
}

uint64_t sub_100F6ACC8(uint64_t result, double a2)
{
  *(double *)(result + 608) = a2;
  return result;
}

__n128 sub_100F6ACD0(uint64_t a1)
{
  *(_BYTE *)(a1 + 181) = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 208LL))(*(void *)(a1 + 24));
  *(_BYTE *)(a1 + 182) = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 216LL))(*(void *)(a1 + 24));
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24));
  *(_OWORD *)(a1 + 184) = *(_OWORD *)v2;
  __int128 v3 = *(_OWORD *)(v2 + 48);
  __int128 v4 = *(_OWORD *)(v2 + 64);
  __int128 v5 = *(_OWORD *)(v2 + 32);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(v2 + 16);
  *(_OWORD *)(a1 + 248) = v4;
  *(_OWORD *)(a1 + 232) = v3;
  *(_OWORD *)(a1 + 216) = v5;
  __int128 v7 = *(_OWORD *)(v2 + 96);
  __int128 v6 = *(_OWORD *)(v2 + 112);
  uint64_t v8 = *(void *)(v2 + 128);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)(v2 + 80);
  *(void *)(a1 + 312) = v8;
  *(_OWORD *)(a1 + 296) = v6;
  *(_OWORD *)(a1 + 2sub_100F6A7D8(v1 + 80) = v7;
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 88LL))(*(void *)(a1 + 24));
  *(_OWORD *)(a1 + 320) = *(_OWORD *)v9;
  __int128 v10 = *(_OWORD *)(v9 + 64);
  __int128 v12 = *(_OWORD *)(v9 + 16);
  __int128 v11 = *(_OWORD *)(v9 + 32);
  *(_OWORD *)(a1 + 368) = *(_OWORD *)(v9 + 48);
  *(_OWORD *)(a1 + 384) = v10;
  *(_OWORD *)(a1 + 336) = v12;
  *(_OWORD *)(a1 + 352) = v11;
  __int128 v14 = *(_OWORD *)(v9 + 96);
  __int128 v13 = *(_OWORD *)(v9 + 112);
  __int128 v15 = *(_OWORD *)(v9 + 80);
  *(void *)(a1 + 448) = *(void *)(v9 + 128);
  *(_OWORD *)(a1 + 416) = v14;
  *(_OWORD *)(a1 + 432) = v13;
  *(_OWORD *)(a1 + 400) = v15;
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 96LL))(*(void *)(a1 + 24));
  *(_OWORD *)(a1 + 456) = *(_OWORD *)v16;
  __int128 v17 = *(_OWORD *)(v16 + 64);
  __int128 v19 = *(_OWORD *)(v16 + 16);
  __int128 v18 = *(_OWORD *)(v16 + 32);
  *(_OWORD *)(a1 + 504) = *(_OWORD *)(v16 + 48);
  *(_OWORD *)(a1 + 520) = v17;
  *(_OWORD *)(a1 + 472) = v19;
  *(_OWORD *)(a1 + 488) = v18;
  __int128 v21 = *(_OWORD *)(v16 + 96);
  __n128 result = *(__n128 *)(v16 + 112);
  __int128 v22 = *(_OWORD *)(v16 + 80);
  *(void *)(a1 + 584) = *(void *)(v16 + 128);
  *(_OWORD *)(a1 + 552) = v21;
  *(__n128 *)(a1 + 568) = result;
  *(_OWORD *)(a1 + 536) = v22;
  return result;
}

uint64_t sub_100F6ADE8(uint64_t a1)
{
  uint64_t v2 = sub_100C383D8();
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 40) + 104LL))(*(void *)(a1 + 40)) & 1) != 0
    || ((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128LL))(*(void *)(a1 + 24)) & 1) != 0
    || v2[1] && ((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 120LL))(*(void *)(a1 + 24)) & 1) != 0
    || v2[2] && ((*(uint64_t (**)(void))(**(void **)(a1 + 24) + 136LL))(*(void *)(a1 + 24)) & 1) != 0)
  {
    return 1LL;
  }

  if (v2[3]) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 144LL))(*(void *)(a1 + 24));
  }
  return 0LL;
}

BOOL sub_100F6AE98(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 16LL))(a1)
      && (*(_BYTE *)sub_100C383D8() || !*(_BYTE *)(a1 + 616))
      && *(double *)(a2 + 44) >= 0.0
      && ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 64LL))(*(void *)(a1 + 56)) & 1) != 0;
}

BOOL sub_100F6AF1C(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(void))(**(void **)(a1 + 24) + 112LL))(*(void *)(a1 + 24))
      && (*(_BYTE *)sub_100C38504() || !*(_BYTE *)(a1 + 616))
      && *(double *)(a2 + 44) >= 0.0
      && ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 64LL))(*(void *)(a1 + 56)) & 1) != 0;
}

void sub_100F6AFA4(uint64_t a1, double *a2)
{
  if (*(_DWORD *)a2 == 1)
  {
    *(_BYTE *)(a1 + 616) = 0;
    *(void *)(a1 + 624) = 0xBFF0000000000000LL;
    double Current = CFAbsoluteTimeGetCurrent();
    double v12 = Current;
    double v13 = Current - a2[1] + -3.0;
    uint64_t v14 = *(void *)(a1 + 648);
    if (*(void *)(a1 + 656) == v14
      || (unint64_t v15 = *(void *)(a1 + 672),
          uint64_t v16 = (void *)(v14 + 8 * (v15 >> 8)),
          uint64_t v17 = *v16 + 16LL * v15,
          uint64_t v18 = *(void *)(v14 + (((*(void *)(a1 + 680) + v15) >> 5) & 0x7FFFFFFFFFFFFF8LL))
              + 16LL * (*(_BYTE *)(a1 + 680) + v15),
          v17 == v18))
    {
      double v20 = *(double *)(a1 + 80);
LABEL_30:
      double v21 = -1.0;
    }

    else
    {
      double v19 = Current + 0.001;
      double v20 = *(double *)(a1 + 80);
      while (1)
      {
        double v21 = *(double *)v17;
        BOOL v23 = v21 > v20 && v21 < v13;
        if (v23 && *(_BYTE *)(v17 + 8)) {
          break;
        }
        v17 += 16LL;
        if (v17 - *v16 == 4096)
        {
          uint64_t v24 = v16[1];
          ++v16;
          uint64_t v17 = v24;
        }

        if (v17 == v18) {
          goto LABEL_30;
        }
      }
    }

    double v25 = vabdd_f64(v12, v20);
    double v26 = vabdd_f64(v12, v21);
    if (v21 <= 0.0) {
      double v27 = v25;
    }
    else {
      double v27 = v26;
    }
    if (v25 > 900.0 && v27 > 900.0) {
      *(_BYTE *)(a1 + 632) = 1;
    }
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188ED90);
    }
    __int16 v28 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      uint64_t v29 = *(void *)(a1 + 80);
      int v30 = *(unsigned __int8 *)(a1 + 632);
      uint64_t v31 = *((void *)a2 + 1);
      *(_DWORD *)std::string buf = 134350848;
      *(double *)int v51 = v13;
      *(_WORD *)&v51[8] = 2050;
      *(double *)&v51[10] = v12;
      __int16 v52 = 2050;
      uint64_t v53 = v29;
      __int16 v54 = 2050;
      double v55 = v21;
      __int16 v56 = 2050;
      double v57 = v25;
      __int16 v58 = 2050;
      double v59 = v27;
      __int16 v60 = 1026;
      int v61 = v30;
      __int16 v62 = 2050;
      uint64_t v63 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "MapsHarvest,proactiveSessionEnd,start,%{public}.2fs,end,%{public}.2fs,tripTime,%{public}.2fs,lastRegularTime,%{p ublic}.2fs,tripInterval,%{public}.2fs,lastRegularInterval,%{public}.2fs,TriggerId,%{public}d,sessionSec,%{public}.2lf",  buf,  0x4Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188ED90);
      }
      uint64_t v32 = *(void *)(a1 + 80);
      int v33 = *(unsigned __int8 *)(a1 + 632);
      uint64_t v34 = *((void *)a2 + 1);
      int v36 = 134350848;
      *(double *)int v37 = v13;
      *(_WORD *)&v37[8] = 2050;
      *(double *)&v37[10] = v12;
      __int16 v38 = 2050;
      uint64_t v39 = v32;
      __int16 v40 = 2050;
      double v41 = v21;
      __int16 v42 = 2050;
      double v43 = v25;
      __int16 v44 = 2050;
      double v45 = v27;
      __int16 v46 = 1026;
      int v47 = v33;
      __int16 v48 = 2050;
      uint64_t v49 = v34;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "MapsHarvest,proactiveSessionEnd,start,%{public}.2fs,end,%{public}.2fs,tripTime,%{public}.2fs,lastRegularTime,%{p ublic}.2fs,tripInterval,%{public}.2fs,lastRegularInterval,%{public}.2fs,TriggerId,%{public}d,sessionSec,%{public}.2lf",  &v36,  78);
      __int128 v10 = (uint8_t *)v35;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLPolicyTrip::updateProactiveLocationSession(const CLLocationProvider_Type::ProactiveLocationSessionStats &)",  "%s\n",  v35);
      goto LABEL_46;
    }
  }

  else if (!*(_DWORD *)a2)
  {
    *(_BYTE *)(a1 + 616) = 1;
    *(CFAbsoluteTime *)(a1 + 624) = CFAbsoluteTimeGetCurrent();
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188ED90);
    }
    __int128 v4 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      int v5 = *(_DWORD *)a2;
      uint64_t v6 = *(void *)(a1 + 624);
      *(_DWORD *)std::string buf = 67240448;
      *(_DWORD *)int v51 = v5;
      *(_WORD *)&v51[4] = 2050;
      *(void *)&v51[6] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "MapsHarvest,proactiveSessionStart,state,%{public}d,state,%{public}.2fs",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188ED90);
      }
      int v7 = *(_DWORD *)a2;
      uint64_t v8 = *(void *)(a1 + 624);
      int v36 = 67240448;
      *(_DWORD *)int v37 = v7;
      *(_WORD *)&id v37[4] = 2050;
      *(void *)&v37[6] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "MapsHarvest,proactiveSessionStart,state,%{public}d,state,%{public}.2fs",  &v36,  18);
      __int128 v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLPolicyTrip::updateProactiveLocationSession(const CLLocationProvider_Type::ProactiveLocationSessionStats &)",  "%s\n",  v9);
LABEL_46:
      if (v10 != buf) {
        free(v10);
      }
    }
  }

void *sub_100F6B484(void *result, double a2)
{
  uint64_t v2 = result;
  double v6 = a2;
  __int128 v3 = result + 80;
  unint64_t v4 = result[85];
  if (!v4
    || *(double *)(*(void *)(result[81] + ((result[84] >> 5) & 0x7FFFFFFFFFFFFF8LL))
                 + 16LL * result[84]) < a2)
  {
    char v5 = 1;
    __n128 result = (void *)sub_100F6B524((uint64_t)(result + 80), &v6, &v5);
    unint64_t v4 = v2[85];
  }

  if (v4 >= 0xB5)
  {
    do
    {
      v2[85] = v4 - 1;
      __n128 result = (void *)sub_100232D9C(v3, 1);
      unint64_t v4 = v2[85];
    }

    while (v4 > 0xB4);
  }

  return result;
}

uint64_t sub_100F6B524(uint64_t a1, void *a2, char *a3)
{
  unint64_t v6 = *(void *)(a1 + 32);
  if (!v6)
  {
    sub_100F6B828((void **)a1);
    unint64_t v6 = *(void *)(a1 + 32);
  }

  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (void *)(v7 + 8 * (v6 >> 8));
  uint64_t v10 = *v9 + 16LL * v6;
  if (v8 == v7) {
    uint64_t v10 = 0LL;
  }
  if (v10 == *v9) {
    uint64_t v10 = *(v9 - 1) + 4096LL;
  }
  char v11 = *a3;
  *(void *)(v10 - 16) = *a2;
  *(_BYTE *)(v10 - 8) = v11;
  unint64_t v12 = v6 - 1;
  uint64_t v13 = *(void *)(a1 + 40) + 1LL;
  *(void *)(a1 + 32) = v12;
  *(void *)(a1 + 40) = v13;
  if (v8 == v7) {
    return 0LL;
  }
  else {
    return *(void *)(v7 + ((v12 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v12;
  }
}

uint64_t sub_100F6B5D0(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 616))
  {
    double v4 = *(double *)(a1 + 624);
    if (v4 > 0.0 && *(double *)(a2 + 76) > v4 + 300.0)
    {
      *(_BYTE *)(a1 + 616) = 0;
      *(void *)(a1 + 624) = 0xBFF0000000000000LL;
    }
  }

  sub_100F6B484((void *)a1, *(double *)(a2 + 76));
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, a2) & 1) != 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, a2), (_DWORD)result))
  {
    __n128 v6 = sub_100F6ACD0(a1);
    uint64_t result = (*(uint64_t (**)(void, uint64_t, __n128))(**(void **)(a1 + 8) + 16LL))( *(void *)(a1 + 8),  a1 + 80,  v6);
    *(_BYTE *)(a1 + 1sub_100F6A7D8(v1 + 80) = *(_BYTE *)(a1 + 616);
  }

  return result;
}

uint64_t sub_100F6B6A8(uint64_t a1)
{
  *(void *)a1 = off_10188ECE8;
  sub_100231C10((void *)(a1 + 640));
  sub_10000AE14(a1 + 56);
  sub_10000AE14(a1 + 40);
  sub_10000AE14(a1 + 24);
  sub_10000AE14(a1 + 8);
  return a1;
}

void sub_100F6B72C(char *a1)
{
  *(void *)a1 = off_10188ECE8;
  sub_100231C10((void *)a1 + 80);
  if (a1[175] < 0) {
    operator delete(*((void **)a1 + 19));
  }
  if (a1[151] < 0) {
    operator delete(*((void **)a1 + 16));
  }
  if (a1[111] < 0) {
    operator delete(*((void **)a1 + 11));
  }
  sub_10000AE14((uint64_t)(a1 + 56));
  sub_10000AE14((uint64_t)(a1 + 40));
  sub_10000AE14((uint64_t)(a1 + 24));
  sub_10000AE14((uint64_t)(a1 + 8));
  operator delete(a1);
}

uint64_t sub_100F6B7B0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 592);
}

uint64_t sub_100F6B7B8(uint64_t a1)
{
  return a1 + 80;
}

uint64_t sub_100F6B7C0(uint64_t result)
{
  if (*(char *)(result + 111) < 0)
  {
    **(_BYTE **)(result + 88) = 0;
    *(void *)(result + 96) = 0LL;
  }

  else
  {
    *(_BYTE *)(result + 88) = 0;
    *(_BYTE *)(result + 111) = 0;
  }

  return result;
}

uint64_t sub_100F6B7E4(uint64_t a1)
{
  return a1 + 600;
}

uint64_t sub_100F6B7EC(uint64_t a1)
{
  return a1 + 608;
}

uint64_t sub_100F6B7F4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 616);
}

void sub_100F6B7FC(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

void sub_100F6B828(void **a1)
{
  uint64_t v2 = a1[1];
  __int128 v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 32 * (v3 - v2) - 1;
  }
  __n128 v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x100)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      __int16 v46 = a1 + 3;
      std::stringbuf::string_type __p = sub_1000071BC(v7, v11);
      double v43 = (char *)__p;
      __int16 v44 = (char *)__p;
      double v45 = (char *)__p + 8 * v12;
      double v41 = operator new(0x1000uLL);
      sub_1000ECB90(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        int v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              double v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                uint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)uint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              uint64_t v31 = __p;
              std::stringbuf::string_type __p = v24;
              double v43 = &v24[8 * (v23 >> 2)];
              __int16 v44 = v14;
              double v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              double v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }

              __int128 v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              double v43 = v22;
              __int16 v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        int v33 = (char *)a1[1];
      }

      int v36 = *a1;
      int v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::stringbuf::string_type __p = v36;
      double v43 = v33;
      __int16 v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      __int16 v44 = v13;
      double v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 128LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 256;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        __int16 v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        std::stringbuf::string_type __p = operator new(0x1000uLL);
        sub_1000EC960(a1, &__p);
        uint64_t v34 = a1[2];
        std::stringbuf::string_type __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        std::stringbuf::string_type __p = operator new(0x1000uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 128LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 256;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 256;
    std::stringbuf::string_type __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_100F6BAEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F6BBD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 26LL;
  uint64_t v5 = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a3;
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = 0LL;
  *(_DWORD *)(a1 + 56) = 0;
  sub_10001A504(a1 + 64, a4);
  return a1;
}

void sub_100F6BC1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F6BC44(uint64_t result, __int128 *a2)
{
  uint64_t v2 = (uint64_t *)result;
  if (*((_BYTE *)a2 + 9) && !*(_BYTE *)(result + 33))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EDB0);
    }
    unint64_t v4 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = v2[2];
      *(_DWORD *)std::string buf = 134217984;
      uint64_t v28 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "WorkoutStopDetected,charging,type,%ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EDB0);
      }
      uint64_t v7 = v2[2];
      int v25 = 134217984;
      uint64_t v26 = v7;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "WorkoutStopDetected,charging,type,%ld",  &v25);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutStopDetector::updateChargingState(const CLWorkoutPredictorCharging &)",  "%s\n",  v8);
    }

    sub_100F6D174(v2, 0LL, 0LL, 0);
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    uint64_t v24 = 0LL;
    int v9 = 4;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)std::string buf = 1;
    uint64_t v6 = v2[11];
    if (!v6) {
      sub_100008BDC();
    }
    return (*(uint64_t (**)(uint64_t, uint8_t *, int *))(*(void *)v6 + 48LL))(v6, buf, &v9);
  }

  else
  {
    __int128 v3 = *a2;
    *(void *)(result + 40) = *((void *)a2 + 2);
    *(_OWORD *)(result + 24) = v3;
  }

  return result;
}

void *sub_100F6BEA4(void *result, _DWORD *a2)
{
  uint64_t v2 = result[2];
  if (v2) {
    BOOL v3 = v2 == 26;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = 0LL;
    if (*a2 != 1) {
      uint64_t v4 = *(void *)(result[1] + 296LL);
    }
    result[6] = v4;
  }

  return result;
}

uint64_t sub_100F6BED8(uint64_t *a1)
{
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10188EDD0);
  }
  uint64_t v2 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = a1[2];
    *(_DWORD *)std::string buf = 134217984;
    uint64_t v28 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "WorkoutStopDetected,geoFence,type,%ld", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    uint64_t v7 = a1[2];
    int v25 = 134217984;
    uint64_t v26 = v7;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "WorkoutStopDetected,geoFence,type,%ld",  &v25);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutStopDetector::didExitGeoFence()", "%s\n", v8);
  }

  sub_100F6D174(a1, 0LL, 0LL, 0);
  uint64_t v4 = *(void *)(a1[1] + 296);
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  uint64_t v24 = 0LL;
  int v9 = 10;
  uint64_t v10 = v4;
  *(_DWORD *)std::string buf = 1;
  uint64_t v5 = a1[11];
  if (!v5) {
    sub_100008BDC();
  }
  return (*(uint64_t (**)(uint64_t, uint8_t *, int *))(*(void *)v5 + 48LL))(v5, buf, &v9);
}

BOOL sub_100F6C118(double *a1)
{
  unint64_t v2 = *((void *)a1 + 2);
  BOOL v3 = v2 > 0x25;
  uint64_t v4 = (1LL << v2) & 0x3000800000LL;
  if (!v3 && v4 != 0)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EDB0);
    }
    uint64_t v6 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(*((void *)a1 + 1) + 296LL);
      uint64_t v8 = *((void *)a1 + 6);
      *(_DWORD *)std::string buf = 134218240;
      uint64_t v26 = v7;
      __int16 v27 = 2048;
      uint64_t v28 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Confirmed offWrist, Not triggering WorkoutStopDetected for snowsports, currentTime %f, fLastUnknownOrOffTime %f",  buf,  0x16u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EDB0);
    }
    uint64_t v14 = *(void *)(*((void *)a1 + 1) + 296LL);
    uint64_t v15 = *((void *)a1 + 6);
    int v21 = 134218240;
    uint64_t v22 = v14;
    __int16 v23 = 2048;
    uint64_t v24 = v15;
    LODWORD(v20) = 22;
    __int128 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Confirmed offWrist, Not triggering WorkoutStopDetected for snowsports, currentTime %f, fLastUnknownOrOffTime %f",  COERCE_DOUBLE(&v21),  v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLWorkoutStopDetector::isConfirmedOffWrist() const", "%s\n", v16);
    return 0LL;
  }

  double v10 = a1[6];
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10188EDB0);
  }
  __int128 v11 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
  {
    uint64_t v12 = *(void *)(*((void *)a1 + 1) + 296LL);
    uint64_t v13 = *((void *)a1 + 6);
    *(_DWORD *)std::string buf = 134218240;
    uint64_t v26 = v12;
    __int16 v27 = 2048;
    uint64_t v28 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Triggering WorkoutStopDetected, currentTime %f, fLastUnknownOrOffTime %f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EDB0);
    }
    uint64_t v17 = *(void *)(*((void *)a1 + 1) + 296LL);
    uint64_t v18 = *((void *)a1 + 6);
    int v21 = 134218240;
    uint64_t v22 = v17;
    __int16 v23 = 2048;
    uint64_t v24 = v18;
    LODWORD(v20) = 22;
    __int128 v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Triggering WorkoutStopDetected, currentTime %f, fLastUnknownOrOffTime %f",  COERCE_DOUBLE(&v21),  v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLWorkoutStopDetector::isConfirmedOffWrist() const", "%s\n", v19);
  }

  return 1LL;
}

uint64_t sub_100F6C4BC(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 56) = v2;
  if (v2 == 4)
  {
    BOOL v3 = (uint64_t *)result;
    if (*(void *)(result + 16) != 27LL)
    {
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10188EDD0);
      }
      uint64_t v4 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = v3[2];
        *(_DWORD *)std::string buf = 134217984;
        uint64_t v29 = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "WorkoutStopDetected,connectedVehicle,type,%ld",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10188EDD0);
        }
        uint64_t v8 = v3[2];
        int v26 = 134217984;
        uint64_t v27 = v8;
        int v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "WorkoutStopDetected,connectedVehicle,type,%ld",  &v26);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutStopDetector::updateVehicularState(const CLWorkoutPredictorVehicular &)",  "%s\n",  v9);
      }

      sub_100F6D174(v3, 0LL, 0LL, 0);
      uint64_t v6 = *(void *)(v3[1] + 296);
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      uint64_t v25 = 0LL;
      int v10 = 8;
      uint64_t v11 = v6;
      *(_DWORD *)std::string buf = 1;
      uint64_t v7 = v3[11];
      if (!v7) {
        sub_100008BDC();
      }
      return (*(uint64_t (**)(uint64_t, uint8_t *, int *))(*(void *)v7 + 48LL))(v7, buf, &v10);
    }
  }

  return result;
}

uint64_t sub_100F6C718(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1) {
    BOOL v2 = v1 == 26;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return result;
  }
  uint64_t v3 = result;
  if (sub_100F6C118((double *)result))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188EDB0);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v3 + 16);
      *(_DWORD *)std::string buf = 134217984;
      uint64_t v192 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "WorkoutStopDetected,wrist,type,%ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188EDB0);
      }
      uint64_t v27 = *(void *)(v3 + 16);
      *(_DWORD *)int v68 = 134217984;
      *(void *)&v68[4] = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "WorkoutStopDetected,wrist,type,%ld",  v68);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutStopDetector::update()", "%s\n", v28);
    }

    sub_100F6D174((uint64_t *)v3, 0LL, 0LL, 0);
    *(void *)(v3 + 48) = 0LL;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    uint64_t v190 = 0LL;
    __int128 v188 = 0u;
    __int128 v189 = 0u;
    __int128 v186 = 0u;
    __int128 v187 = 0u;
    __int128 v184 = 0u;
    __int128 v185 = 0u;
    __int128 v182 = 0u;
    __int128 v183 = 0u;
    __int128 v180 = 0u;
    __int128 v181 = 0u;
    __int128 v178 = 0u;
    __int128 v179 = 0u;
    __int128 v177 = 0u;
    int v175 = 3;
    CFAbsoluteTime v176 = Current;
    *(_DWORD *)std::string buf = 1;
    uint64_t v8 = *(void *)(v3 + 88);
    if (!v8) {
      sub_100008BDC();
    }
    *(double *)&BOOL result = COERCE_DOUBLE((*(uint64_t (**)(uint64_t, uint8_t *, int *))(*(void *)v8 + 48LL))(v8, buf, &v175));
    return result;
  }

  if (*(_DWORD *)(v3 + 56) != 2) {
    goto LABEL_20;
  }
  unint64_t v9 = *(void *)(v3 + 16);
  BOOL v10 = v9 > 0x31;
  uint64_t v11 = (1LL << v9) & 0x2407808800010LL;
  if (!v10 && v11 != 0) {
    goto LABEL_20;
  }
  unsigned __int8 v19 = atomic_load((unsigned __int8 *)&qword_10199F838);
  if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_10199F838))
  {
    *(_DWORD *)std::string buf = 8;
    sub_1002C72A8(qword_10199F820, buf, 1uLL);
    __cxa_atexit((void (*)(void *))sub_1002C7328, qword_10199F820, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199F838);
  }

  __int16 v76 = 0;
  *(_OWORD *)int v68 = xmmword_1012E1E90;
  *(_OWORD *)&v68[16] = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  memset(v75, 0, sizeof(v75));
  __int128 v77 = xmmword_1012E1E90;
  uint64_t v78 = 0LL;
  int v79 = 0;
  v81[0] = 0LL;
  uint64_t v80 = 0LL;
  *(void *)((char *)v81 + 5) = 0LL;
  *(void *)((char *)&v81[1] + 6) = 0LL;
  char v82 = 0;
  memset(&v81[3], 0, 24);
  __int128 v83 = xmmword_1012E1E90;
  uint64_t v84 = 0LL;
  int v85 = 0;
  unint64_t v86 = 0xFFEFFFFFFFFFFFFFLL;
  int v97 = 0;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  int v92 = 0;
  __int128 v93 = 0u;
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  memset(v96, 0, sizeof(v96));
  uint64_t v98 = 0LL;
  uint64_t v99 = 0LL;
  unint64_t v100 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v101 = 0LL;
  int v102 = 0;
  uint64_t v108 = 0LL;
  __int16 v109 = 0;
  int v114 = 0;
  int v107 = 0;
  __int128 v106 = 0u;
  __int128 v105 = 0u;
  __int128 v104 = 0u;
  __int128 v103 = 0u;
  __int128 v111 = 0u;
  __int128 v110 = 0u;
  char v112 = 0;
  memset(v113, 0, sizeof(v113));
  unint64_t v115 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v134 = 0u;
  __int128 v133 = 0u;
  __int128 v132 = 0u;
  __int128 v131 = 0u;
  __int128 v130 = 0u;
  __int128 v129 = 0u;
  __int128 v128 = 0u;
  __int128 v127 = 0u;
  __int128 v126 = 0u;
  __int128 v125 = 0u;
  __int128 v124 = 0u;
  __int128 v123 = 0u;
  __int128 v122 = 0u;
  __int128 v121 = 0u;
  __int128 v120 = 0u;
  __int128 v119 = 0u;
  __int128 v118 = 0u;
  __int128 v117 = 0u;
  __int128 v116 = 0u;
  uint64_t v135 = 0LL;
  unint64_t v136 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v137 = 0u;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  __int128 v140 = 0u;
  unint64_t v141 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v142 = 0LL;
  int v143 = 0;
  uint64_t v144 = 0LL;
  char v145 = 0;
  unint64_t v146 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v148 = 0LL;
  uint64_t v147 = 0LL;
  uint64_t v149 = 0x80000000800000LL;
  uint64_t v151 = 0LL;
  uint64_t v150 = 0LL;
  __int128 v152 = xmmword_1012E1EA0;
  uint64_t v153 = 0x80000000800000LL;
  __int128 v154 = 0u;
  __int128 v155 = 0u;
  uint64_t v156 = 0LL;
  unint64_t v157 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v158 = 0u;
  __int128 v159 = 0u;
  __int128 v160 = 0u;
  __int128 v161 = 0u;
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  int v164 = 0;
  unint64_t v165 = 0xFFEFFFFFFFFFFFFFLL;
  __int16 v166 = 0;
  int v167 = 0;
  unint64_t v168 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v169 = 7LL;
  unint64_t v170 = 0xFFEFFFFFFFFFFFFFLL;
  char v171 = 0;
  uint64_t v173 = 0LL;
  uint64_t v172 = 0LL;
  uint64_t v174 = 0LL;
  if (!sub_100CDB578(*(double **)(v3 + 8), qword_10199F820, (uint64_t)v68))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    uint64_t v25 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Failed to get constrainedArm state", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10188EDD0);
      }
      LOWORD(v64) = 0;
      int v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "Failed to get constrainedArm state",  &v64,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutStopDetector::update()", "%s\n", v26);
    }

    goto LABEL_20;
  }

  int v20 = BYTE8(v125);
  if (!BYTE8(v125))
  {
LABEL_20:
    BOOL result = *(uint64_t *)v3;
    if (*(void *)v3)
    {
      *(double *)&BOOL result = COERCE_DOUBLE((**(uint64_t (***)(uint64_t, void))result)(result, *(void *)(v3 + 8)));
      double v14 = *(double *)&result;
      if ((_DWORD)result)
      {
        double v15 = v13;
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10188EDD0);
        }
        __int128 v16 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = *(void *)(v3 + 16);
          *(_DWORD *)std::string buf = 134218496;
          uint64_t v192 = v17;
          __int16 v193 = 1024;
          int v194 = LODWORD(v14);
          __int16 v195 = 2048;
          double v196 = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "WorkoutStopDetected,type,%ld,stopReason,%d,stopTimestamp,%f",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10188EDD0);
          }
          uint64_t v29 = *(void *)(v3 + 16);
          *(_DWORD *)int v68 = 134218496;
          *(void *)&v68[4] = v29;
          *(_WORD *)&v68[12] = 1024;
          *(_DWORD *)&v68[14] = LODWORD(v14);
          *(_WORD *)&v68[18] = 2048;
          *(double *)&v68[20] = v15;
          uint64_t v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "WorkoutStopDetected,type,%ld,stopReason,%d,stopTimestamp,%f",  v68,  28,  v33[0]);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutStopDetector::update()", "%s\n", v30);
        }

        sub_100F6D174((uint64_t *)v3, 0LL, 0LL, 0);
        uint64_t v47 = 0LL;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v34 = 0u;
        v33[0] = v14;
        v33[1] = v15;
        *(_DWORD *)std::string buf = 1;
        uint64_t v18 = *(void *)(v3 + 88);
        if (!v18) {
          sub_100008BDC();
        }
        *(double *)&BOOL result = COERCE_DOUBLE( (*(uint64_t (**)(uint64_t, uint8_t *, double *))(*(void *)v18 + 48LL))( v18,  buf,  v33));
      }
    }

    return result;
  }

  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10188EDD0);
  }
  __int128 v21 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = *(void *)(v3 + 16);
    *(_DWORD *)std::string buf = 134218240;
    uint64_t v192 = v22;
    __int16 v193 = 1024;
    int v194 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "WorkoutStopDetected,vehicleSpeedConstrainedArm,type,%ld,constrainedState,%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    uint64_t v31 = *(void *)(v3 + 16);
    int v64 = 134218240;
    uint64_t v65 = v31;
    __int16 v66 = 1024;
    int v67 = v20;
    uint64_t v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "WorkoutStopDetected,vehicleSpeedConstrainedArm,type,%ld,constrainedState,%d",  &v64,  18);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutStopDetector::update()", "%s\n", v32);
  }

  sub_100F6D174((uint64_t *)v3, 0LL, 0LL, 0);
  uint64_t v23 = *(void *)(*(void *)(v3 + 8) + 296LL);
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  uint64_t v63 = 0LL;
  int v48 = 11;
  uint64_t v49 = v23;
  *(_DWORD *)std::string buf = 1;
  uint64_t v24 = *(void *)(v3 + 88);
  if (!v24) {
    sub_100008BDC();
  }
  *(double *)&BOOL result = COERCE_DOUBLE((*(uint64_t (**)(uint64_t, uint8_t *, int *))(*(void *)v24 + 48LL))(v24, buf, &v48));
  return result;
}

void sub_100F6D150(_Unwind_Exception *a1)
{
}

void sub_100F6D174(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v29 = a2;
  int v28 = a4;
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10188EDD0);
  }
  uint64_t v8 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134349568;
    *(void *)&uint8_t buf[4] = a2;
    __int16 v37 = 2050;
    uint64_t v38 = a3;
    __int16 v39 = 2050;
    uint64_t v40 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutStopDetector::selectModel,type,%{public}ld,location,%{public}ld,startType,%{public}ld",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    int v30 = 134349568;
    uint64_t v31 = a2;
    __int16 v32 = 2050;
    uint64_t v33 = a3;
    __int16 v34 = 2050;
    uint64_t v35 = v28;
    uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutStopDetector::selectModel,type,%{public}ld,location,%{public}ld,startType,%{public}ld",  &v30,  32);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutStopDetector::selectModel(CMWorkoutType, CMWorkoutLocationType, CLWorkoutStopModel::StartType)",  "%s\n",  v23);
    if (v23 != buf) {
      free(v23);
    }
  }

  uint64_t v9 = sub_100BEF6EC(a2, a3);
  uint64_t v27 = v9;
  if (a1[2] == v9)
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    BOOL v10 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = a1[2];
      *(_DWORD *)std::string buf = 134349312;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v37 = 2050;
      uint64_t v38 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutStopDetector,workout type did not change,not updating models,currentTypeWithLocation,%{public}ld,newTyp eWithLocation,%{public}ld",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10188EDD0);
      }
      uint64_t v12 = a1[2];
      int v30 = 134349312;
      uint64_t v31 = v12;
      __int16 v32 = 2050;
      uint64_t v33 = v9;
      LODWORD(v25) = 22;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutStopDetector,workout type did not change,not updating models,currentTypeWithLocation,%{pu blic}ld,newTypeWithLocation,%{public}ld",  &v30,  v25);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutStopDetector::selectModel(CMWorkoutType, CMWorkoutLocationType, CLWorkoutStopModel::StartType)",  "%s\n",  v13);
      if (v13 != buf) {
        free(v13);
      }
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10188EDD0);
    }
    double v14 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134218496;
      *(void *)&uint8_t buf[4] = a2;
      __int16 v37 = 2048;
      uint64_t v38 = a3;
      __int16 v39 = 2048;
      uint64_t v40 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutStopDetector::selectModel,workoutType,%ld,locationType,%ld,typeWithLocation,%ld",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10188EDD0);
      }
      int v30 = 134218496;
      uint64_t v31 = a2;
      __int16 v32 = 2048;
      uint64_t v33 = a3;
      __int16 v34 = 2048;
      uint64_t v35 = v9;
      LODWORD(v25) = 32;
      uint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutStopDetector::selectModel,workoutType,%ld,locationType,%ld,typeWithLocation,%ld",  &v30,  v25,  v26);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutStopDetector::selectModel(CMWorkoutType, CMWorkoutLocationType, CLWorkoutStopModel::StartType)",  "%s\n",  v24);
      if (v24 != buf) {
        free(v24);
      }
    }

    a1[2] = v9;
    switch(v9)
    {
      case 0LL:
      case 66LL:
        uint64_t v17 = *a1;
        *a1 = 0LL;
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 24LL))(v17);
        }
        a1[2] = 0LL;
        return;
      case 1LL:
      case 2LL:
        sub_100F6D8F4(&v29, buf);
        goto LABEL_41;
      case 3LL:
      case 7LL:
      case 8LL:
      case 10LL:
      case 13LL:
      case 20LL:
      case 21LL:
      case 23LL:
      case 25LL:
      case 26LL:
      case 27LL:
      case 28LL:
      case 29LL:
      case 30LL:
      case 31LL:
      case 32LL:
      case 33LL:
      case 34LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 38LL:
      case 39LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
      case 44LL:
      case 45LL:
      case 46LL:
      case 47LL:
      case 48LL:
      case 49LL:
      case 50LL:
      case 51LL:
      case 52LL:
      case 53LL:
      case 54LL:
      case 55LL:
      case 56LL:
      case 57LL:
      case 58LL:
      case 59LL:
      case 60LL:
      case 61LL:
      case 62LL:
      case 63LL:
      case 64LL:
      case 65LL:
        uint64_t v15 = *a1;
        *a1 = 0LL;
        if (v15) {
          goto LABEL_23;
        }
        return;
      case 4LL:
        sub_100F6DABC(buf);
        goto LABEL_41;
      case 5LL:
        sub_100F6DA34(buf);
        goto LABEL_41;
      case 6LL:
        unsigned __int8 v19 = operator new(0x10uLL);
        *unsigned __int8 v19 = off_10182F8D0;
        v19[1] = 0LL;
        uint64_t v20 = *a1;
        *a1 = (uint64_t)v19;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 24LL))(v20);
        }
        return;
      case 9LL:
        sub_100F6D99C(&v28, buf);
        goto LABEL_41;
      case 11LL:
        sub_100F6DA78(buf);
        goto LABEL_41;
      case 12LL:
        sub_100F6D948((unsigned int *)&v28, buf);
        goto LABEL_41;
      case 14LL:
      case 22LL:
        sub_100F6DB34(&v27, buf);
        goto LABEL_41;
      case 15LL:
      case 17LL:
      case 24LL:
        __int128 v16 = operator new(0x58uLL);
        sub_100507980(v16, a2);
        uint64_t v15 = *a1;
        *a1 = (uint64_t)v16;
        if (!v15) {
          return;
        }
        goto LABEL_23;
      case 16LL:
      case 18LL:
        sub_100F6D9F0(buf);
        goto LABEL_41;
      case 19LL:
        __n128 v18 = sub_100F6DB88((__n128 **)buf);
LABEL_41:
        uint64_t v21 = *(void *)buf;
        *(void *)std::string buf = 0LL;
        uint64_t v22 = *a1;
        *a1 = v21;
        if (v22)
        {
          (*(void (**)(uint64_t, __n128))(*(void *)v22 + 24LL))(v22, v18);
          uint64_t v15 = *(void *)buf;
          *(void *)std::string buf = 0LL;
          if (v15) {
LABEL_23:
          }
            (*(void (**)(uint64_t))(*(void *)v15 + 24LL))(v15);
        }

        break;
      default:
        return;
    }
  }

void sub_100F6D7AC(_Unwind_Exception *a1)
{
}

double sub_100F6D8D4(uint64_t a1)
{
  double result = -1.0;
  return result;
}

uint64_t sub_100F6D8F4@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x58uLL);
  uint64_t result = sub_100507980(v4, *a1);
  *a2 = v4;
  return result;
}

void sub_100F6D934(_Unwind_Exception *a1)
{
}

uint64_t sub_100F6D948@<X0>(unsigned int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x300uLL);
  uint64_t result = sub_100789650(v4, *a1);
  *a2 = v4;
  return result;
}

void sub_100F6D988(_Unwind_Exception *a1)
{
}

uint64_t sub_100F6D99C@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x3A0uLL);
  uint64_t result = sub_100F6DC54((uint64_t)v4, *a1);
  *a2 = v4;
  return result;
}

void sub_100F6D9DC(_Unwind_Exception *a1)
{
}

void sub_100F6D9F0(void *a1@<X8>)
{
  BOOL v2 = operator new(0x3A0uLL);
  sub_10032CE50((uint64_t)v2);
  *a1 = v2;
}

void sub_100F6DA20(_Unwind_Exception *a1)
{
}

void sub_100F6DA34(void *a1@<X8>)
{
  BOOL v2 = operator new(0x460uLL);
  sub_100207AA4((uint64_t)v2);
  *a1 = v2;
}

void sub_100F6DA64(_Unwind_Exception *a1)
{
}

void sub_100F6DA78(void *a1@<X8>)
{
  BOOL v2 = operator new(0x510uLL);
  sub_100A2095C((uint64_t)v2);
  *a1 = v2;
}

void sub_100F6DAA8(_Unwind_Exception *a1)
{
}

void sub_100F6DABC(void *a1@<X8>)
{
  BOOL v2 = operator new(0xE8uLL);
  *BOOL v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  v2[3] = 0u;
  v2[4] = 0u;
  v2[5] = 0u;
  v2[6] = 0u;
  v2[7] = 0u;
  v2[8] = 0u;
  v2[9] = 0u;
  v2[10] = 0u;
  v2[11] = 0u;
  v2[12] = 0u;
  v2[13] = 0u;
  *(void *)BOOL v2 = off_101861398;
  *((void *)v2 + 28) = 0LL;
  sub_100C7E27C((uint64_t)v2 + 8);
  *a1 = v2;
}

void sub_100F6DB20(_Unwind_Exception *a1)
{
}

uint64_t sub_100F6DB34@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x1C0uLL);
  uint64_t result = sub_100F6DD88((uint64_t)v4, *a1);
  *a2 = v4;
  return result;
}

void sub_100F6DB74(_Unwind_Exception *a1)
{
}

__n128 sub_100F6DB88@<Q0>(__n128 **a1@<X8>)
{
  BOOL v2 = (__n128 *)operator new(0x3F0uLL);
  bzero(&v2[3], 0x3C0uLL);
  v2->n128_u64[0] = (unint64_t)off_101883370;
  v2->n128_u64[1] = 0xFFFFFFFFLL;
  __asm { FMOV            V0.2D, #-1.0 }

  v2[1] = result;
  v2[2] = (__n128)xmmword_1013B9600;
  v2[57].n128_u8[0] = 1;
  v2[58].n128_u32[1] = 18;
  v2[57].n128_u32[3] = 0;
  *a1 = v2;
  return result;
}

void sub_100F6DBFC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100F6DC28(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

uint64_t sub_100F6DC54(uint64_t a1, int a2)
{
  *uint64_t v4 = off_10188EE00;
  if (a2 == 1) {
    sub_100CCCC8C(a1 + 8, 1, (uint64_t)&v6);
  }
  return a1;
}

void sub_100F6DCAC(_Unwind_Exception *exception_object)
{
  void *v1 = off_101833168;
  v1[56] = off_101848F08;
  uint64_t v3 = (void *)v1[61];
  if (v3)
  {
    v1[62] = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_100F6DCE8(void *a1)
{
  *a1 = off_101833168;
  a1[56] = off_101848F08;
  BOOL v2 = (void *)a1[61];
  if (v2)
  {
    a1[62] = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_100F6DD38(void *__p)
{
  void *__p = off_101833168;
  __p[56] = off_101848F08;
  BOOL v2 = (void *)__p[61];
  if (v2)
  {
    __p[62] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_100F6DD88(uint64_t result, uint64_t a2)
{
  *(void *)__n128 result = off_101848F08;
  *(_OWORD *)(result + 8) = xmmword_1012E1E80;
  *(void *)(result + 24) = 0xFFEFFFFFFFFFFFFFLL;
  *(_DWORD *)(result + 32) = 0;
  *(void *)(result + 48) = 0LL;
  *(void *)(result + 56) = 0LL;
  *(void *)(result + 40) = 0LL;
  *(_BYTE *)(result + 64) = 1;
  *(_DWORD *)(result + sub_100F6A7D8(v1 + 80) = 0;
  *(_DWORD *)(result + 84) = 75;
  *(_DWORD *)(result + 76) = 0;
  *(void *)(result + 392) = 0LL;
  *(void *)(result + 400) = 0LL;
  *(void *)(result + 408) = 0xC08F380000000000LL;
  *(void *)(result + 416) = 0xC08F380000000000LL;
  *(_BYTE *)(result + 424) = 0;
  *(void *)(result + 432) = 0LL;
  *(_BYTE *)(result + 440) = 0;
  if (a2 == 22 || a2 == 11) {
    *(void *)(result + 8) = 0x4049000000000000LL;
  }
  return result;
}

uint64_t sub_100F6DE04()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199F808, (void *)&_mh_execute_header);
}

uint64_t sub_100F6DE50()
{
  v0.n128_u64[0] = 0x5A5A5A5A5A5A5A5ALL;
  v0.n128_u64[1] = 0x5A5A5A5A5A5A5A5ALL;
  v1.n128_u64[0] = 0x5555555555555555LL;
  v1.n128_u64[1] = 0x5555555555555555LL;
  v2.n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
  v2.n128_u64[1] = 0xAAAAAAAAAAAAAAAALL;
  v3.n128_u64[0] = 0x5555555555555555LL;
  v3.n128_u64[1] = 0x5555555555555555LL;
  v4.n128_u64[0] = 0x1111111111111111LL;
  v4.n128_u64[1] = 0x1111111111111111LL;
  v5.n128_u64[0] = 0x2222222222222222LL;
  v5.n128_u64[1] = 0x2222222222222222LL;
  v6.n128_u64[0] = 0x3333333333333333LL;
  v6.n128_u64[1] = 0x3333333333333333LL;
  return sub_100F6DF24(v0, v1, v2, v3, (__n128)0, v4, v5, v6);
}

float64x2_t *sub_100F6DF24@<X0>( float64x2_t *result@<X0>, float64x2_t *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, unsigned int a7@<W7>, unsigned int a8@<W8>, float64x2_t a9@<Q1>, float64x2_t a10@<Q4>, float64x2_t a11@<Q5>, float64x2_t a12@<Q6>, float64x2_t a13@<Q7>)
{
  do
  {
    float64x2_t v43 = *result;
    float64x2_t v44 = result[1];
    float64x2_t v45 = vmlaq_f64(a10, a9, v33);
    float64x2_t v46 = vmlaq_f64(a11, a9, v34);
    float64x2_t v47 = result[2];
    float64x2_t v48 = result[3];
    float64x2_t v49 = vmlaq_f64(a12, v35, a9);
    float64x2_t v50 = vmlaq_f64(a13, v36, a9);
    float64x2_t v51 = result[4];
    float64x2_t v52 = result[5];
    float64x2_t v53 = vmlaq_f64(v23, a9, v37);
    float64x2_t v54 = vmlaq_f64(v24, a9, v38);
    float64x2_t v55 = result[6];
    float64x2_t v56 = result[7];
    float64x2_t v57 = vmlaq_f64(v25, v39, a9);
    float64x2_t v58 = vmlaq_f64(v26, v40, a9);
    float64x2_t v59 = result[8];
    float64x2_t v60 = result[9];
    float64x2_t v61 = vmlaq_f64(v27, a9, v41);
    float64x2_t v62 = vmlaq_f64(v28, a9, v42);
    *a2 = *result;
    a2[1] = v44;
    float64x2_t v63 = vmlaq_f64(v31, a9, v44);
    float64x2_t v64 = vmlaq_f64(v32, v41, a9);
    uint64_t v65 = a4 - 64;
    float64x2_t v66 = result[10];
    float64x2_t v67 = result[11];
    float64x2_t v68 = vmlaq_f64(v29, v43, a9);
    float64x2_t v69 = vmlaq_f64(v30, v44, a9);
    float64x2_t v70 = *result;
    float64x2_t v71 = result[1];
    float64x2_t v72 = vmlaq_f64(v45, a9, v47);
    float64x2_t v73 = vmlaq_f64(v46, a9, v48);
    float64x2_t v74 = result[2];
    float64x2_t v75 = result[3];
    float64x2_t v76 = vmlaq_f64(v49, v51, a9);
    float64x2_t v77 = vmlaq_f64(v50, v52, a9);
    float64x2_t v78 = result[4];
    float64x2_t v79 = result[5];
    float64x2_t v80 = vmlaq_f64(v53, a9, v55);
    float64x2_t v81 = vmlaq_f64(v54, a9, v56);
    float64x2_t v82 = result[6];
    float64x2_t v83 = result[7];
    float64x2_t v84 = vmlaq_f64(v57, v59, a9);
    float64x2_t v85 = vmlaq_f64(v58, v60, a9);
    a2[2] = v66;
    a2[3] = v67;
    float64x2_t v86 = vmlaq_f64(v63, v67, a9);
    float64x2_t v87 = vmlaq_f64(v64, a9, v59);
    float64x2_t v88 = result[8];
    float64x2_t v89 = result[9];
    float64x2_t v90 = vmlaq_f64(v61, a9, v66);
    float64x2_t v91 = vmlaq_f64(v62, a9, v67);
    float64x2_t v92 = result[10];
    float64x2_t v93 = result[11];
    float64x2_t v94 = vmlaq_f64(v68, v70, a9);
    for (float64x2_t i = vmlaq_f64(v69, v71, a9); v65 >= 0; float64x2_t i = vmlaq_f64(v253, v255, a9))
    {
      float64x2_t v96 = *result;
      float64x2_t v97 = result[1];
      float64x2_t v98 = vmlaq_f64(v72, a9, v74);
      float64x2_t v99 = vmlaq_f64(v73, a9, v75);
      float64x2_t v100 = result[2];
      float64x2_t v101 = result[3];
      float64x2_t v102 = vmlaq_f64(v76, v78, a9);
      float64x2_t v103 = vmlaq_f64(v77, v79, a9);
      float64x2_t v104 = result[4];
      float64x2_t v105 = result[5];
      float64x2_t v106 = vmlaq_f64(v80, a9, v82);
      float64x2_t v107 = vmlaq_f64(v81, a9, v83);
      a2[4] = v88;
      a2[5] = v89;
      float64x2_t v108 = vmlaq_f64(v86, a9, v89);
      float64x2_t v109 = vmlaq_f64(v87, v82, a9);
      float64x2_t v110 = result[6];
      float64x2_t v111 = result[7];
      float64x2_t v112 = vmlaq_f64(v84, v88, a9);
      float64x2_t v113 = vmlaq_f64(v85, v89, a9);
      float64x2_t v114 = result[8];
      float64x2_t v115 = result[9];
      float64x2_t v116 = vmlaq_f64(v90, a9, v92);
      float64x2_t v117 = vmlaq_f64(v91, a9, v93);
      float64x2_t v118 = result[10];
      float64x2_t v119 = result[11];
      float64x2_t v120 = vmlaq_f64(v94, v96, a9);
      float64x2_t v121 = vmlaq_f64(i, v97, a9);
      float64x2_t v122 = *result;
      float64x2_t v123 = result[1];
      float64x2_t v124 = vmlaq_f64(v98, a9, v100);
      float64x2_t v125 = vmlaq_f64(v99, a9, v101);
      float64x2_t v126 = result[2];
      float64x2_t v127 = result[3];
      float64x2_t v128 = vmlaq_f64(v102, v104, a9);
      float64x2_t v129 = vmlaq_f64(v103, v105, a9);
      a2[6] = v110;
      a2[7] = v111;
      float64x2_t v130 = vmlaq_f64(v108, v111, a9);
      float64x2_t v131 = vmlaq_f64(v109, a9, v104);
      float64x2_t v132 = result[4];
      float64x2_t v133 = result[5];
      float64x2_t v134 = vmlaq_f64(v106, a9, v110);
      float64x2_t v135 = vmlaq_f64(v107, a9, v111);
      float64x2_t v136 = result[6];
      float64x2_t v137 = result[7];
      float64x2_t v138 = vmlaq_f64(v112, v114, a9);
      float64x2_t v139 = vmlaq_f64(v113, v115, a9);
      float64x2_t v140 = result[8];
      float64x2_t v141 = result[9];
      float64x2_t v142 = vmlaq_f64(v116, a9, v118);
      float64x2_t v143 = vmlaq_f64(v117, a9, v119);
      float64x2_t v144 = result[10];
      float64x2_t v145 = result[11];
      float64x2_t v146 = vmlaq_f64(v120, v122, a9);
      float64x2_t v147 = vmlaq_f64(v121, v123, a9);
      float64x2_t v148 = *result;
      float64x2_t v149 = result[1];
      float64x2_t v150 = vmlaq_f64(v124, a9, v126);
      float64x2_t v151 = vmlaq_f64(v125, a9, v127);
      a2[8] = v132;
      a2[9] = v133;
      float64x2_t v152 = vmlaq_f64(v130, a9, v133);
      float64x2_t v153 = vmlaq_f64(v131, v126, a9);
      float64x2_t v154 = result[2];
      float64x2_t v155 = result[3];
      float64x2_t v156 = vmlaq_f64(v128, v132, a9);
      float64x2_t v157 = vmlaq_f64(v129, v133, a9);
      float64x2_t v158 = result[4];
      float64x2_t v159 = result[5];
      float64x2_t v160 = vmlaq_f64(v134, a9, v136);
      float64x2_t v161 = vmlaq_f64(v135, a9, v137);
      float64x2_t v162 = result[6];
      float64x2_t v163 = result[7];
      float64x2_t v164 = vmlaq_f64(v138, v140, a9);
      float64x2_t v165 = vmlaq_f64(v139, v141, a9);
      float64x2_t v166 = result[8];
      float64x2_t v167 = result[9];
      float64x2_t v168 = vmlaq_f64(v142, a9, v144);
      float64x2_t v169 = vmlaq_f64(v143, a9, v145);
      float64x2_t v170 = result[10];
      float64x2_t v171 = result[11];
      float64x2_t v172 = vmlaq_f64(v146, v148, a9);
      float64x2_t v173 = vmlaq_f64(v147, v149, a9);
      a2[10] = v154;
      a2[11] = v155;
      float64x2_t v174 = vmlaq_f64(v152, v155, a9);
      float64x2_t v175 = vmlaq_f64(v153, a9, v148);
      float64x2_t v176 = result[12];
      float64x2_t v177 = result[13];
      float64x2_t v178 = vmlaq_f64(v150, a9, v154);
      float64x2_t v179 = vmlaq_f64(v151, a9, v155);
      float64x2_t v180 = result[2];
      float64x2_t v181 = result[3];
      float64x2_t v182 = vmlaq_f64(v156, v158, a9);
      float64x2_t v183 = vmlaq_f64(v157, v159, a9);
      float64x2_t v184 = result[4];
      float64x2_t v185 = result[5];
      float64x2_t v186 = vmlaq_f64(v160, a9, v162);
      float64x2_t v187 = vmlaq_f64(v161, a9, v163);
      float64x2_t v188 = result[6];
      float64x2_t v189 = result[7];
      float64x2_t v190 = vmlaq_f64(v164, v166, a9);
      float64x2_t v191 = vmlaq_f64(v165, v167, a9);
      float64x2_t v192 = result[8];
      float64x2_t v193 = result[9];
      float64x2_t v194 = vmlaq_f64(v168, a9, v170);
      float64x2_t v195 = vmlaq_f64(v169, a9, v171);
      a2[12] = v176;
      a2[13] = v177;
      float64x2_t v196 = vmlaq_f64(v174, a9, v177);
      float64x2_t v197 = vmlaq_f64(v175, v170, a9);
      float64x2_t v198 = result[14];
      float64x2_t v199 = result[15];
      float64x2_t v200 = vmlaq_f64(v172, v176, a9);
      float64x2_t v201 = vmlaq_f64(v173, v177, a9);
      float64x2_t v202 = *result;
      float64x2_t v203 = result[1];
      float64x2_t v204 = vmlaq_f64(v178, a9, v180);
      float64x2_t v205 = vmlaq_f64(v179, a9, v181);
      float64x2_t v206 = result[2];
      float64x2_t v207 = result[3];
      float64x2_t v208 = vmlaq_f64(v182, v184, a9);
      float64x2_t v209 = vmlaq_f64(v183, v185, a9);
      float64x2_t v210 = result[4];
      float64x2_t v211 = result[5];
      float64x2_t v212 = vmlaq_f64(v186, a9, v188);
      float64x2_t v213 = vmlaq_f64(v187, a9, v189);
      float64x2_t v214 = result[6];
      float64x2_t v215 = result[7];
      float64x2_t v216 = vmlaq_f64(v190, v192, a9);
      float64x2_t v217 = vmlaq_f64(v191, v193, a9);
      a2[14] = v198;
      a2[15] = v199;
      float64x2_t v218 = vmlaq_f64(v196, v199, a9);
      float64x2_t v219 = vmlaq_f64(v197, a9, v192);
      a2 += 16;
      float64x2_t v220 = result[8];
      float64x2_t v221 = result[9];
      float64x2_t v222 = vmlaq_f64(v194, a9, v198);
      float64x2_t v223 = vmlaq_f64(v195, a9, v199);
      float64x2_t v224 = result[10];
      float64x2_t v225 = result[11];
      float64x2_t v226 = vmlaq_f64(v200, v202, a9);
      float64x2_t v227 = vmlaq_f64(v201, v203, a9);
      result += 16;
      float64x2_t v228 = *result;
      float64x2_t v229 = result[1];
      float64x2_t v230 = vmlaq_f64(v204, a9, v206);
      float64x2_t v231 = vmlaq_f64(v205, a9, v207);
      float64x2_t v232 = result[2];
      float64x2_t v233 = result[3];
      float64x2_t v234 = vmlaq_f64(v208, v210, a9);
      float64x2_t v235 = vmlaq_f64(v209, v211, a9);
      float64x2_t v236 = result[4];
      float64x2_t v237 = result[5];
      float64x2_t v238 = vmlaq_f64(v212, a9, v214);
      float64x2_t v239 = vmlaq_f64(v213, a9, v215);
      float64x2_t v240 = result[6];
      float64x2_t v241 = result[7];
      float64x2_t v242 = vmlaq_f64(v216, v220, a9);
      float64x2_t v243 = vmlaq_f64(v217, v221, a9);
      float64x2_t v244 = result[8];
      float64x2_t v245 = result[9];
      float64x2_t v246 = vmlaq_f64(v222, a9, v224);
      float64x2_t v247 = vmlaq_f64(v223, a9, v225);
      *a2 = *result;
      a2[1] = v229;
      float64x2_t v248 = vmlaq_f64(v218, a9, v229);
      float64x2_t v249 = vmlaq_f64(v219, v224, a9);
      v65 -= 32LL;
      float64x2_t v250 = result[10];
      float64x2_t v251 = result[11];
      float64x2_t v252 = vmlaq_f64(v226, v228, a9);
      float64x2_t v253 = vmlaq_f64(v227, v229, a9);
      float64x2_t v254 = *result;
      float64x2_t v255 = result[1];
      float64x2_t v72 = vmlaq_f64(v230, a9, v232);
      float64x2_t v73 = vmlaq_f64(v231, a9, v233);
      float64x2_t v74 = result[2];
      float64x2_t v75 = result[3];
      float64x2_t v76 = vmlaq_f64(v234, v236, a9);
      float64x2_t v77 = vmlaq_f64(v235, v237, a9);
      float64x2_t v78 = result[4];
      float64x2_t v79 = result[5];
      float64x2_t v80 = vmlaq_f64(v238, a9, v240);
      float64x2_t v81 = vmlaq_f64(v239, a9, v241);
      float64x2_t v82 = result[6];
      float64x2_t v83 = result[7];
      float64x2_t v84 = vmlaq_f64(v242, v244, a9);
      float64x2_t v85 = vmlaq_f64(v243, v245, a9);
      a2[2] = v250;
      a2[3] = v251;
      float64x2_t v86 = vmlaq_f64(v248, v251, a9);
      float64x2_t v87 = vmlaq_f64(v249, a9, v244);
      float64x2_t v88 = result[8];
      float64x2_t v89 = result[9];
      float64x2_t v90 = vmlaq_f64(v246, a9, v250);
      float64x2_t v91 = vmlaq_f64(v247, a9, v251);
      float64x2_t v92 = result[10];
      float64x2_t v93 = result[11];
      float64x2_t v94 = vmlaq_f64(v252, v254, a9);
    }

    float64x2_t v256 = *result;
    float64x2_t v257 = result[1];
    float64x2_t v258 = vmlaq_f64(v72, a9, v74);
    float64x2_t v259 = vmlaq_f64(v73, a9, v75);
    float64x2_t v260 = result[2];
    float64x2_t v261 = result[3];
    float64x2_t v262 = vmlaq_f64(v76, v78, a9);
    float64x2_t v263 = vmlaq_f64(v77, v79, a9);
    float64x2_t v264 = result[4];
    float64x2_t v265 = result[5];
    float64x2_t v266 = vmlaq_f64(v80, a9, v82);
    float64x2_t v267 = vmlaq_f64(v81, a9, v83);
    a2[4] = v88;
    a2[5] = v89;
    float64x2_t v268 = vmlaq_f64(v86, a9, v89);
    float64x2_t v269 = vmlaq_f64(v87, v82, a9);
    float64x2_t v270 = result[6];
    float64x2_t v271 = result[7];
    float64x2_t v272 = vmlaq_f64(v84, v88, a9);
    float64x2_t v273 = vmlaq_f64(v85, v89, a9);
    float64x2_t v274 = result[8];
    float64x2_t v275 = result[9];
    float64x2_t v276 = vmlaq_f64(v90, a9, v92);
    float64x2_t v277 = vmlaq_f64(v91, a9, v93);
    float64x2_t v278 = result[10];
    float64x2_t v279 = result[11];
    float64x2_t v280 = vmlaq_f64(v94, v256, a9);
    float64x2_t v281 = vmlaq_f64(i, v257, a9);
    float64x2_t v282 = *result;
    float64x2_t v283 = result[1];
    float64x2_t v284 = vmlaq_f64(v258, a9, v260);
    float64x2_t v285 = vmlaq_f64(v259, a9, v261);
    float64x2_t v286 = result[2];
    float64x2_t v287 = result[3];
    float64x2_t v288 = vmlaq_f64(v262, v264, a9);
    float64x2_t v289 = vmlaq_f64(v263, v265, a9);
    a2[6] = v270;
    a2[7] = v271;
    float64x2_t v290 = vmlaq_f64(v268, v271, a9);
    float64x2_t v291 = vmlaq_f64(v269, a9, v264);
    float64x2_t v292 = result[4];
    float64x2_t v293 = result[5];
    float64x2_t v294 = vmlaq_f64(v266, a9, v270);
    float64x2_t v295 = vmlaq_f64(v267, a9, v271);
    float64x2_t v296 = result[6];
    float64x2_t v297 = result[7];
    float64x2_t v298 = vmlaq_f64(v272, v274, a9);
    float64x2_t v299 = vmlaq_f64(v273, v275, a9);
    float64x2_t v300 = result[8];
    float64x2_t v301 = result[9];
    float64x2_t v302 = vmlaq_f64(v276, a9, v278);
    float64x2_t v303 = vmlaq_f64(v277, a9, v279);
    float64x2_t v304 = result[10];
    float64x2_t v305 = result[11];
    float64x2_t v306 = vmlaq_f64(v280, v282, a9);
    float64x2_t v307 = vmlaq_f64(v281, v283, a9);
    float64x2_t v308 = *result;
    float64x2_t v309 = result[1];
    float64x2_t v310 = vmlaq_f64(v284, a9, v286);
    float64x2_t v311 = vmlaq_f64(v285, a9, v287);
    a2[8] = v292;
    a2[9] = v293;
    float64x2_t v312 = vmlaq_f64(v290, a9, v293);
    float64x2_t v313 = vmlaq_f64(v291, v286, a9);
    float64x2_t v314 = result[2];
    float64x2_t v315 = result[3];
    float64x2_t v316 = vmlaq_f64(v288, v292, a9);
    float64x2_t v317 = vmlaq_f64(v289, v293, a9);
    float64x2_t v318 = result[4];
    float64x2_t v319 = result[5];
    float64x2_t v320 = vmlaq_f64(v294, a9, v296);
    float64x2_t v321 = vmlaq_f64(v295, a9, v297);
    float64x2_t v322 = result[6];
    float64x2_t v323 = result[7];
    float64x2_t v324 = vmlaq_f64(v298, v300, a9);
    float64x2_t v325 = vmlaq_f64(v299, v301, a9);
    float64x2_t v326 = result[8];
    float64x2_t v327 = result[9];
    float64x2_t v328 = vmlaq_f64(v302, a9, v304);
    float64x2_t v329 = vmlaq_f64(v303, a9, v305);
    float64x2_t v330 = result[10];
    float64x2_t v331 = result[11];
    float64x2_t v332 = vmlaq_f64(v306, v308, a9);
    float64x2_t v333 = vmlaq_f64(v307, v309, a9);
    a2[10] = v314;
    a2[11] = v315;
    float64x2_t v334 = vmlaq_f64(v312, v315, a9);
    float64x2_t v335 = vmlaq_f64(v313, a9, v308);
    float64x2_t v336 = result[12];
    float64x2_t v337 = result[13];
    float64x2_t v338 = vmlaq_f64(v310, a9, v314);
    float64x2_t v339 = vmlaq_f64(v311, a9, v315);
    float64x2_t v340 = result[2];
    float64x2_t v341 = result[3];
    float64x2_t v342 = vmlaq_f64(v316, v318, a9);
    float64x2_t v343 = vmlaq_f64(v317, v319, a9);
    float64x2_t v344 = result[4];
    float64x2_t v345 = result[5];
    float64x2_t v346 = vmlaq_f64(v320, a9, v322);
    float64x2_t v347 = vmlaq_f64(v321, a9, v323);
    float64x2_t v348 = result[6];
    float64x2_t v349 = result[7];
    float64x2_t v350 = vmlaq_f64(v324, v326, a9);
    float64x2_t v351 = vmlaq_f64(v325, v327, a9);
    float64x2_t v352 = result[8];
    float64x2_t v353 = result[9];
    float64x2_t v354 = vmlaq_f64(v328, a9, v330);
    float64x2_t v355 = vmlaq_f64(v329, a9, v331);
    v15 += a7 * (unint64_t)v19;
    a2[12] = v336;
    a2[13] = v337;
    float64x2_t v356 = vmlaq_f64(v334, a9, v337);
    float64x2_t v357 = vmlaq_f64(v335, v330, a9);
    a4 = a6;
    v16 += a8 * (unint64_t)v20;
    float64x2_t v358 = result[14];
    float64x2_t v359 = result[15];
    float64x2_t v360 = vmlaq_f64(v332, v336, a9);
    float64x2_t v361 = vmlaq_f64(v333, v337, a9);
    float64x2_t v362 = *result;
    float64x2_t v363 = result[1];
    v17 += v20 * (unint64_t)a7;
    a10 = vmlaq_f64(v338, a9, v340);
    a11 = vmlaq_f64(v339, a9, v341);
    float64x2_t v33 = result[2];
    float64x2_t v34 = result[3];
    BOOL v364 = a5-- <= 1;
    a12 = vmlaq_f64(v342, v344, a9);
    a13 = vmlaq_f64(v343, v345, a9);
    float64x2_t v35 = result[4];
    float64x2_t v36 = result[5];
    float64x2_t v23 = vmlaq_f64(v346, a9, v348);
    float64x2_t v24 = vmlaq_f64(v347, a9, v349);
    float64x2_t v37 = result[6];
    float64x2_t v38 = result[7];
    float64x2_t v25 = vmlaq_f64(v350, v352, a9);
    float64x2_t v26 = vmlaq_f64(v351, v353, a9);
    a2[14] = v358;
    a2[15] = v359;
    float64x2_t v31 = vmlaq_f64(v356, v359, a9);
    float64x2_t v32 = vmlaq_f64(v357, a9, v352);
    float64x2_t v39 = result[8];
    float64x2_t v40 = result[9];
    float64x2_t v27 = vmlaq_f64(v354, a9, v358);
    float64x2_t v28 = vmlaq_f64(v355, a9, v359);
    a2 = v22;
    float64x2_t v41 = result[10];
    float64x2_t v42 = result[11];
    float64x2_t v29 = vmlaq_f64(v360, v362, a9);
    float64x2_t v30 = vmlaq_f64(v361, v363, a9);
    __n128 result = v21;
  }

  while (!v364);
  if (a3)
  {
    *(float64x2_t *)a3 = a10;
    *(float64x2_t *)(a3 + 16) = a11;
    *(float64x2_t *)(a3 + 32) = a12;
    *(float64x2_t *)(a3 + 48) = a13;
    *(float64x2_t *)(a3 + 64) = v23;
    *(float64x2_t *)(a3 + sub_100F6A7D8(v1 + 80) = v24;
    *(float64x2_t *)(a3 + 96) = v25;
    *(float64x2_t *)(a3 + 112) = v26;
    *(float64x2_t *)(a3 + 128) = v27;
    *(float64x2_t *)(a3 + 144) = v28;
    *(float64x2_t *)(a3 + 160) = v29;
    *(float64x2_t *)(a3 + 176) = v30;
    *(float64x2_t *)(a3 + 192) = v31;
    *(float64x2_t *)(a3 + 208) = v32;
    *(float64x2_t *)(a3 + 224) = v362;
    *(float64x2_t *)(a3 + 240) = v363;
    *(float64x2_t *)(a3 + 256) = vmlaq_f64(v363, v363, a9);
    *(float64x2_t *)(a3 + 272) = v33;
    *(float64x2_t *)(a3 + 288) = v34;
    *(float64x2_t *)(a3 + 304) = v35;
    *(float64x2_t *)(a3 + 320) = v36;
    *(float64x2_t *)(a3 + 336) = v37;
    *(float64x2_t *)(a3 + 352) = v39;
    *(float64x2_t *)(a3 + 368) = v40;
    *(float64x2_t *)(a3 + 384) = v41;
    *(float64x2_t *)(a3 + 400) = v42;
    *(void *)(a3 + 416) = v13;
    *(void *)(a3 + 424) = v14;
    *(void *)(a3 + 432) = v15;
    *(void *)(a3 + 440) = v16;
    *(void *)(a3 + 448) = v17;
    *(void *)(a3 + 456) = v18;
  }

  return result;
}

BOOL sub_100F6E950(void *a1, void *a2)
{
  double v5 = v4;
  [a2 longitude];
  double v7 = v6;
  objc_msgSend(objc_msgSend(a1, "location"), "latitude");
  double v9 = v8;
  objc_msgSend(objc_msgSend(a1, "location"), "longitude");
  double v11 = sub_100957814(v5, v7, v9, v10);
  objc_msgSend(objc_msgSend(a1, "location"), "horizontalUncertainty");
  return v12 + 50.0 >= v11;
}

void sub_100F6EE50(_Unwind_Exception *a1)
{
}

void sub_100F6EE70(uint64_t a1, uint64_t a2)
{
}

void sub_100F6EE80(uint64_t a1)
{
}

void sub_100F6EE8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(_BYTE **)(a1 + 32);
  if (a3)
  {
    v4[32] = 1;
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    double v6 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:error fetching home locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188EE80);
      }
    }

    double v7 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "error fetching home locations of interest",  "{msg%{public}.0s:error fetching home locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

  else
  {
    [v4 setHomeLocations:a2];
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }

void sub_100F6F068(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(_BYTE **)(a1 + 32);
  if (a3)
  {
    v4[32] = 1;
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    double v6 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:error fetching work locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188EE80);
      }
    }

    double v7 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "error fetching work locations of interest",  "{msg%{public}.0s:error fetching work locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

  else
  {
    [v4 setWorkLocations:a2];
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }

void sub_100F6F244(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(_BYTE **)(a1 + 32);
  if (a3)
  {
    v4[32] = 1;
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    double v6 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:error fetching school locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188EE80);
      }
    }

    double v7 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "error fetching school locations of interest",  "{msg%{public}.0s:error fetching school locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

  else
  {
    [v4 setSchoolLocations:a2];
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }

void sub_100F6F420(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(_BYTE **)(a1 + 32);
  if (a3)
  {
    v4[32] = 1;
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    double v6 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:error fetching gym locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10188EE80);
      }
    }

    double v7 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      double v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "error fetching gym locations of interest",  "{msg%{public}.0s:error fetching gym locations of interest, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

  else
  {
    [v4 setGymLocations:a2];
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }

void sub_100F6F5FC(void *a1)
{
  uint64_t v2 = a1[4];
  if (*(_BYTE *)(v2 + 32))
  {
    ++*(_DWORD *)(v2 + 36);
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    __n128 v3 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      int v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:error fetching locations of interest}",  (uint8_t *)&v5,  0x12u);
    }
  }

  else
  {
    *(_DWORD *)(v2 + 36) = 0;
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10188EE80);
    }
    double v4 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      int v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:finished fetching locations of interest}",  (uint8_t *)&v5,  0x12u);
    }

    (*(void (**)(void))(a1[5] + 16LL))();
  }

  dispatch_release(*(dispatch_object_t *)(*(void *)(a1[6] + 8LL) + 40LL));
}

void sub_100F6FB68(id a1)
{
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10188EE80);
  }
  uint64_t v1 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 68289026;
    v2[1] = 0;
    __int16 v3 = 2082;
    double v4 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:locations of interest have been fetched}",  (uint8_t *)v2,  0x12u);
  }

NSDictionary *sub_100F70000(void *a1)
{
  v3[0] = @"loiType";
  v4[0] = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [a1 type]);
  v3[1] = @"loiTypeSource";
  v4[1] = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [a1 typeSource]);
  v3[2] = @"lat";
  objc_msgSend(objc_msgSend(a1, "location"), "latitude");
  _OWORD v4[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v3[3] = @"lon";
  objc_msgSend(objc_msgSend(a1, "location"), "longitude");
  __int128 v4[3] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v3[4] = @"uncertainty";
  objc_msgSend(objc_msgSend(a1, "location"), "horizontalUncertainty");
  v4[4] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v3[5] = @"confidence";
  [a1 confidence];
  v4[5] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  6LL);
}

void sub_100F701AC(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

uint64_t sub_100F701D8(uint64_t a1)
{
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v2 = (void *)(a1 + 40);
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  __int16 v3 = (void *)(a1 + 88);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  v5.n128_u64[0] = CFAbsoluteTimeGetCurrent();
  v5.n128_u64[1] = 0x7FEFFFFFFFFFFFFFLL;
  int v6 = 0;
  sub_100F70298(v2, &v5);
  v5.n128_u64[0] = CFAbsoluteTimeGetCurrent();
  v5.n128_u64[1] = 0x7FEFFFFFFFFFFFFFLL;
  int v6 = 1;
  sub_100F70344(v3, &v5);
  return a1;
}

void sub_100F70278(_Unwind_Exception *a1)
{
}

__n128 sub_100F70298(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F70FC8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  int v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v8 = result;
  ++a1[5];
  return result;
}

__n128 sub_100F70344(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F712DC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  int v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v8 = result;
  ++a1[5];
  return result;
}

void sub_100F703F4(uint64_t a1, int a2, int a3, double a4)
{
  int v23 = a2;
  int v7 = sub_1005FCD00(&v23);
  int v8 = v7;
  if (*(_DWORD *)(a1 + 32) == v7 && *(_BYTE *)a1)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10188EEA0);
    }
    int v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)float64x2_t v25 = 2082;
      *(void *)&v25[2] = "";
      *(_WORD *)&v25[10] = 1025;
      int v26 = v10;
      double v11 = "{msg%{public}.0s:On wrist status did not change, status:%{private}d}";
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, v11, buf, 0x18u);
    }
  }

  else
  {
    *(double *)(a1 + 16) = a4;
    *(_DWORD *)(a1 + 32) = v7;
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10188EEA0);
    }
    int v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)float64x2_t v25 = 2082;
      *(void *)&v25[2] = "";
      *(_WORD *)&v25[10] = 1025;
      int v26 = v12;
      double v11 = "{msg%{public}.0s:On wrist status changed, status:%{private}d}";
      goto LABEL_11;
    }
  }

  unint64_t v13 = *(void *)(a1 + 80);
  if (!v13) {
    sub_10127A808();
  }
  uint64_t v14 = *(void *)(a1 + 72);
  unint64_t v15 = v14 + v13 - 1;
  uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8 * (v15 / 0xAA));
  unint64_t v17 = v15 % 0xAA;
  if (v8 != *(_DWORD *)(v16 + 24 * v17 + 16))
  {
    *(double *)(v16 + 24 * v17 + _Block_object_dispose((const void *)(v1 - 128), 8) = a4;
    if (v13 >= 0x3C)
    {
      *(void *)(a1 + 72) = v14 + 1;
      *(void *)(a1 + sub_100F6A7D8(v1 + 80) = v13 - 1;
      sub_100211164(a1 + 40, 1);
    }

    *(double *)std::string buf = a4;
    *(void *)float64x2_t v25 = 0x7FEFFFFFFFFFFFFFLL;
    *(_DWORD *)&v25[8] = v8;
    sub_100F70778((void *)(a1 + 40), (__int128 *)buf);
  }

  if (*(unsigned __int8 *)(a1 + 3) == a3)
  {
    uint64_t v18 = qword_1019345D0;
    if (*(_BYTE *)(a1 + 1))
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10188EEA0);
      }
      unsigned int v19 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        int v20 = *(unsigned __int8 *)(a1 + 3);
        *(_DWORD *)std::string buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)float64x2_t v25 = 2082;
        *(void *)&v25[2] = "";
        *(_WORD *)&v25[10] = 1025;
        int v26 = v20;
        uint64_t v21 = "{msg%{public}.0s:On charger status did not change, status:%{private}d}";
LABEL_28:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, v21, buf, 0x18u);
        goto LABEL_29;
      }

      goto LABEL_29;
    }
  }

  else
  {
    uint64_t v18 = qword_1019345D0;
  }

  *(double *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = a4;
  *(_BYTE *)(a1 + 3) = a3;
  *(_BYTE *)(a1 + 1) = 1;
  if (v18 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10188EEA0);
  }
  unsigned int v19 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v22 = *(unsigned __int8 *)(a1 + 3);
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)float64x2_t v25 = 2082;
    *(void *)&v25[2] = "";
    *(_WORD *)&v25[10] = 1025;
    int v26 = v22;
    uint64_t v21 = "{msg%{public}.0s:On charger status changed, status:%{private}d}";
    goto LABEL_28;
  }

uint64_t sub_100F70778(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F70FC8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA);
  __int128 v9 = *a2;
  *(void *)(v8 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v8 = v9;
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5] + 1LL;
  a1[5] = v11;
  unint64_t v12 = v10 + v11;
  uint64_t v13 = a1[1];
  uint64_t v14 = (void *)(v13 + 8 * (v12 / 0xAA));
  uint64_t v15 = *v14 + 24 * (v12 % 0xAA);
  if (a1[2] == v13) {
    uint64_t v15 = 0LL;
  }
  if (v15 == *v14) {
    uint64_t v15 = *(v14 - 1) + 4080LL;
  }
  return v15 - 24;
}

uint64_t sub_100F70860(uint64_t result, int a2, double a3)
{
  unint64_t v3 = *(void *)(result + 128);
  if (!v3) {
    sub_10127A974();
  }
  uint64_t v5 = *(void *)(result + 120);
  unint64_t v6 = v5 + v3 - 1;
  uint64_t v7 = *(void *)(*(void *)(result + 96) + 8 * (v6 / 0xAA));
  unint64_t v8 = v6 % 0xAA;
  if (*(_DWORD *)(v7 + 24 * v8 + 16) != a2)
  {
    uint64_t v10 = (void *)(result + 88);
    *(double *)(result + 24) = a3;
    *(double *)(v7 + 24 * v8 + _Block_object_dispose((const void *)(v1 - 128), 8) = a3;
    if (v3 >= 0xA)
    {
      *(void *)(result + 120) = v5 + 1;
      *(void *)(result + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v3 - 1;
      sub_100211164(result + 88, 1);
    }

    *(double *)&__int128 v11 = a3;
    *((void *)&v11 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    int v12 = a2;
    return sub_100F70928(v10, &v11);
  }

  return result;
}

uint64_t sub_100F70928(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F712DC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA);
  __int128 v9 = *a2;
  *(void *)(v8 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v8 = v9;
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5] + 1LL;
  a1[5] = v11;
  unint64_t v12 = v10 + v11;
  uint64_t v13 = a1[1];
  uint64_t v14 = (void *)(v13 + 8 * (v12 / 0xAA));
  uint64_t v15 = *v14 + 24 * (v12 % 0xAA);
  if (a1[2] == v13) {
    uint64_t v15 = 0LL;
  }
  if (v15 == *v14) {
    uint64_t v15 = *(v14 - 1) + 4080LL;
  }
  return v15 - 24;
}

uint64_t sub_100F70A10( uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (CFAbsoluteTimeGetCurrent() <= *(double *)(a1 + 16)
    || ((v31 = 2, int v19 = sub_100F70D2C(a3 + a6, a3 + a7, v18, a1 + 40, &v31), *(_BYTE *)(a1 + 2))
      ? (BOOL v20 = v19 == 0)
      : (BOOL v20 = 1),
        v20))
  {
    uint64_t v21 = 0LL;
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10188EEA0);
    }
    int v22 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = 68289283;
      int v32 = 0;
      __int16 v33 = 2082;
      float64x2_t v34 = "";
      __int16 v35 = 2049;
      double v36 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Canceling alert because watch goes off-wrist after impact, timeOfImpact:%{private}f}",  (uint8_t *)&v31,  0x1Cu);
    }

    uint64_t v21 = 2LL;
  }

  if (CFAbsoluteTimeGetCurrent() > *(double *)(a1 + 16))
  {
    int v31 = 2;
    int v24 = sub_100F70DCC(a3 + a4, a3 + a5, v23, a1 + 40, &v31);
    if (*(_BYTE *)(a1 + 2))
    {
      if (v24)
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10188EEA0);
        }
        float64x2_t v25 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          int v31 = 68289283;
          int v32 = 0;
          __int16 v33 = 2082;
          float64x2_t v34 = "";
          __int16 v35 = 2049;
          double v36 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Canceling alert because watch was off-wrist before impact, timeOfImpact:%{private}f}",  (uint8_t *)&v31,  0x1Cu);
        }

        uint64_t v21 = 1LL;
      }
    }
  }

  int v26 = *(unsigned __int8 *)(a2 + 147);
  if (CFAbsoluteTimeGetCurrent() > *(double *)(a1 + 24))
  {
    int v31 = 0;
    int v28 = sub_100F70DCC(a3 + a8, a3 + a9, v27, a1 + 88, &v31);
    if (!v26 && *(_BYTE *)(a1 + 2) && v28)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10188EEA0);
      }
      float64x2_t v29 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = 68289283;
        int v32 = 0;
        __int16 v33 = 2082;
        float64x2_t v34 = "";
        __int16 v35 = 2049;
        double v36 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Canceling alert because watch was locked and had no motion before impact, timeOfImp act:%{private}f}",  (uint8_t *)&v31,  0x1Cu);
      }

      return 3LL;
    }
  }

  return v21;
}

uint64_t sub_100F70D2C(double a1, double a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5 = *(unsigned int *)(a4 + 40);
  uint64_t v6 = *(void *)(a4 + 32) - 1LL;
  while (1)
  {
    uint64_t v7 = *(void *)(*(void *)(a4 + 8) + 8 * ((v6 + v5) / 0xAAuLL));
    unint64_t v8 = (v6 + v5) % 0xAAuLL;
    __int128 v9 = (double *)(v7 + 24 * v8);
    double v10 = *v9;
    double v11 = v9[1];
    if (*v9 > v11) {
      return 0LL;
    }
    BOOL v12 = v10 > a1 || v11 < a1;
    if (!v12 || (v10 <= a2 ? (BOOL v13 = v11 < a2) : (BOOL v13 = 1), !v13 || (v10 >= a1 ? (v14 = v11 > a2) : (v14 = 1), !v14)))
    {
      if (*(_DWORD *)(v7 + 24 * v8 + 16) == *a5) {
        break;
      }
    }

    --v5;
    if (v10 < a1) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_100F70DCC(double a1, double a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5 = *(unsigned int *)(a4 + 40);
  uint64_t v6 = *(void *)(a4 + 32) - 1LL;
  while (1)
  {
    uint64_t v7 = *(void *)(*(void *)(a4 + 8) + 8 * ((v6 + v5) / 0xAAuLL));
    unint64_t v8 = (v6 + v5) % 0xAAuLL;
    __int128 v9 = (double *)(v7 + 24 * v8);
    double v10 = *v9;
    double v11 = v9[1];
    if (*v9 > v11) {
      return 0LL;
    }
    BOOL v12 = v11 < a2 || v10 > a2;
    BOOL v13 = v12 || v10 > a1;
    BOOL v14 = v13 || v11 < a1;
    if (!v14 && *(_DWORD *)(v7 + 24 * v8 + 16) == *a5) {
      break;
    }
    --v5;
    if (v10 < a1) {
      return 0LL;
    }
  }

  return 1LL;
}

BOOL sub_100F70E5C(uint64_t a1, int a2)
{
  double v4 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 8);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10188EEA0);
  }
  double v5 = fmax(v4, 0.0);
  uint64_t v6 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(unsigned __int8 *)(a1 + 3);
    v10[0] = 68289539;
    v10[1] = 0;
    __int16 v11 = 2082;
    BOOL v12 = "";
    __int16 v13 = 1025;
    int v14 = v7;
    __int16 v15 = 2049;
    double v16 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Checking impact against charger status, status:%{private}d, duration:%{private}f}",  (uint8_t *)v10,  0x22u);
  }

  if (*(_BYTE *)(a1 + 3)) {
    return 1LL;
  }
  return v5 < (double)a2 && *(_BYTE *)(a1 + 2) != 0;
}

void sub_100F70F9C(id a1)
{
  qword_1019345D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fall");
}

void sub_100F70FC8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float64x2_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      float64x2_t v37 = &v34[8 * v36];
      float64x2_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        float64x2_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)float64x2_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100F71290( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F712DC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float64x2_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      float64x2_t v37 = &v34[8 * v36];
      float64x2_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        float64x2_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)float64x2_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100F715A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100F715F0()
{
  return os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT);
}

BOOL sub_100F71604()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 1496), OS_LOG_TYPE_INFO);
}

BOOL sub_100F71614()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 1496));
}

double sub_100F71620(uint64_t a1, uint64_t a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10188EF48);
  }
  unint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(void *)(a2 + 40);
    int v8 = *(_DWORD *)a2;
    int v9 = *(_DWORD *)(a2 + 4);
    uint64_t v10 = *(void *)(a1 + 8);
    *(_DWORD *)std::string buf = 134219266;
    uint64_t v34 = v5;
    __int16 v35 = 2048;
    uint64_t v36 = v6;
    __int16 v37 = 2048;
    uint64_t v38 = v7;
    __int16 v39 = 1024;
    int v40 = v8;
    __int16 v41 = 1024;
    int v42 = v9;
    __int16 v43 = 2080;
    uint64_t v44 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Input, HR = %.8f, timestamp = %.8lf, starttime = %.8lf, source = %d, interpolation = %d, srcName = %s",  buf,  0x36u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v13 = *(void *)(a2 + 32);
    uint64_t v14 = *(void *)(a2 + 40);
    int v15 = *(_DWORD *)a2;
    int v16 = *(_DWORD *)(a2 + 4);
    uint64_t v17 = *(void *)(a1 + 8);
    int v21 = 134219266;
    uint64_t v22 = v12;
    __int16 v23 = 2048;
    uint64_t v24 = v13;
    __int16 v25 = 2048;
    uint64_t v26 = v14;
    __int16 v27 = 1024;
    int v28 = v15;
    __int16 v29 = 1024;
    int v30 = v16;
    __int16 v31 = 2080;
    uint64_t v32 = v17;
    LODWORD(v20) = 54;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Input, HR = %.8f, timestamp = %.8lf, starttime = %.8lf, source = %d, interpolation = %d, srcName = %s",  COERCE_DOUBLE(&v21),  v20);
    int v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInputBuffer<CLCatherineData>::add(const CLCatherineData &) [Data_T = CLCatherineData]",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

  *(void *)&double result = sub_1002D6A78((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

double sub_100F71860(uint64_t a1, __int128 *a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10188EF48);
  }
  unint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)a2;
    uint64_t v6 = *((void *)a2 + 1);
    uint64_t v8 = *((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 3);
    uint64_t v9 = *((void *)a2 + 6);
    uint64_t v10 = *((void *)a2 + 7);
    uint64_t v11 = *((void *)a2 + 8);
    uint64_t v12 = *((void *)a2 + 4);
    uint64_t v13 = *((void *)a2 + 5);
    uint64_t v14 = *(void *)(a1 + 8);
    int v15 = *((unsigned __int8 *)a2 + 168);
    *(_DWORD *)std::string buf = 134220546;
    uint64_t v53 = v5;
    __int16 v54 = 2048;
    uint64_t v55 = v6;
    __int16 v56 = 2048;
    uint64_t v57 = v7;
    __int16 v58 = 2048;
    uint64_t v59 = v12;
    __int16 v60 = 2048;
    uint64_t v61 = v9;
    __int16 v62 = 2048;
    uint64_t v63 = v8;
    __int16 v64 = 2048;
    uint64_t v65 = v10;
    __int16 v66 = 2048;
    uint64_t v67 = v11;
    __int16 v68 = 2048;
    uint64_t v69 = v13;
    __int16 v70 = 2080;
    uint64_t v71 = v14;
    __int16 v72 = 1026;
    int v73 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Input, Odometer, time stamp, %.8lf, distance, %.8f, GPS altitude, %.8lf, estimated speed(m/s), %.8lf, odometer, %. 8lf, accuracy, %.8lf, speed accuracy, %.8lf, timestampGps, %.8lf, rawSpeed, %.8f, srcName, %s, trackRunOdometerHas BeenCorrected, %{public}d",  buf,  0x6Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    uint64_t v17 = *(void *)a2;
    uint64_t v18 = *((void *)a2 + 1);
    uint64_t v20 = *((void *)a2 + 2);
    uint64_t v19 = *((void *)a2 + 3);
    uint64_t v21 = *((void *)a2 + 6);
    uint64_t v22 = *((void *)a2 + 7);
    uint64_t v23 = *((void *)a2 + 8);
    uint64_t v24 = *((void *)a2 + 4);
    uint64_t v25 = *((void *)a2 + 5);
    uint64_t v26 = *(void *)(a1 + 8);
    int v27 = *((unsigned __int8 *)a2 + 168);
    int v30 = 134220546;
    uint64_t v31 = v17;
    __int16 v32 = 2048;
    uint64_t v33 = v18;
    __int16 v34 = 2048;
    uint64_t v35 = v19;
    __int16 v36 = 2048;
    uint64_t v37 = v24;
    __int16 v38 = 2048;
    uint64_t v39 = v21;
    __int16 v40 = 2048;
    uint64_t v41 = v20;
    __int16 v42 = 2048;
    uint64_t v43 = v22;
    __int16 v44 = 2048;
    uint64_t v45 = v23;
    __int16 v46 = 2048;
    uint64_t v47 = v25;
    __int16 v48 = 2080;
    uint64_t v49 = v26;
    __int16 v50 = 1026;
    int v51 = v27;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Input, Odometer, time stamp, %.8lf, distance, %.8f, GPS altitude, %.8lf, estimated speed(m/s), %.8lf, odometer, %. 8lf, accuracy, %.8lf, speed accuracy, %.8lf, timestampGps, %.8lf, rawSpeed, %.8f, srcName, %s, trackRunOdometerHas BeenCorrected, %{public}d",  &v30,  108);
    __int16 v29 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInputBuffer<CLOdometerEntry>::add(const CLOdometerEntry &) [Data_T = CLOdometerEntry]",  "%s\n",  v28);
    if (v29 != buf) {
      free(v29);
    }
  }

  *(void *)&double result = sub_100477DFC((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

double sub_100F71B0C(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 144);
  __int128 v22 = *(_OWORD *)(a2 + 128);
  __int128 v23 = v2;
  uint64_t v3 = *(void *)(a2 + 160);
  __int128 v4 = *(_OWORD *)(a2 + 80);
  __int128 v18 = *(_OWORD *)(a2 + 64);
  __int128 v19 = v4;
  __int128 v5 = *(_OWORD *)(a2 + 112);
  __int128 v20 = *(_OWORD *)(a2 + 96);
  __int128 v21 = v5;
  __int128 v6 = *(_OWORD *)(a2 + 16);
  __int128 v14 = *(_OWORD *)a2;
  __int128 v15 = v6;
  __int128 v7 = *(_OWORD *)(a2 + 48);
  __int128 v16 = *(_OWORD *)(a2 + 32);
  __int128 v17 = v7;
  *((void *)&v23 + 1) = 0LL;
  uint64_t v24 = v3;
  uint64_t v8 = *(void *)(a1 + 64);
  if (v8)
  {
    double v10 = v9[19];
    double v11 = *((double *)&v14 + 1) - v9[1];
    *((double *)&v23 + 1) = v10;
  }

  uint64_t v12 = (void *)(a1 + 24);
  sub_100F71BFC((uint64_t *)&v14);
  *(void *)&double result = sub_100F71ECC(v12, &v14).n128_u64[0];
  return result;
}

void sub_100F71BFC(uint64_t *a1)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10188EF48);
  }
  __int128 v2 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *a1;
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
    uint64_t v6 = a1[3];
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v9 = a1[6];
    uint64_t v10 = a1[7];
    uint64_t v11 = a1[8];
    uint64_t v12 = a1[11];
    uint64_t v13 = a1[14];
    uint64_t v14 = a1[17];
    uint64_t v15 = a1[18];
    uint64_t v16 = a1[19];
    *(_DWORD *)std::string buf = 134221312;
    uint64_t v63 = v3;
    __int16 v64 = 2048;
    uint64_t v65 = v4;
    __int16 v66 = 2048;
    uint64_t v67 = v5;
    __int16 v68 = 2048;
    uint64_t v69 = v6;
    __int16 v70 = 2048;
    uint64_t v71 = v7;
    __int16 v72 = 2048;
    uint64_t v73 = v8;
    __int16 v74 = 2048;
    uint64_t v75 = v9;
    __int16 v76 = 2048;
    uint64_t v77 = v10;
    __int16 v78 = 2048;
    uint64_t v79 = v11;
    __int16 v80 = 2048;
    uint64_t v81 = v12;
    __int16 v82 = 2048;
    uint64_t v83 = v13;
    __int16 v84 = 2048;
    uint64_t v85 = v14;
    __int16 v86 = 2048;
    uint64_t v87 = v15;
    __int16 v88 = 2048;
    uint64_t v89 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Fitness Machine datum,startTime,%.3f,elapsedTime,%.3f,calories,%f,distance,%f,elevationAscended,%f,strideCount,%ld ,strokeCount,%ld,floors,%ld,speed,%f,cadence,%f,power,%f,incline,%f,resistance,%f,verticalSpeed,%f",  buf,  0x8Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    uint64_t v17 = *a1;
    uint64_t v18 = a1[1];
    uint64_t v19 = a1[2];
    uint64_t v20 = a1[3];
    uint64_t v21 = a1[4];
    uint64_t v22 = a1[5];
    uint64_t v23 = a1[6];
    uint64_t v24 = a1[7];
    uint64_t v25 = a1[8];
    uint64_t v26 = a1[11];
    uint64_t v27 = a1[14];
    uint64_t v28 = a1[17];
    uint64_t v29 = a1[18];
    uint64_t v30 = a1[19];
    int v34 = 134221312;
    uint64_t v35 = v17;
    __int16 v36 = 2048;
    uint64_t v37 = v18;
    __int16 v38 = 2048;
    uint64_t v39 = v19;
    __int16 v40 = 2048;
    uint64_t v41 = v20;
    __int16 v42 = 2048;
    uint64_t v43 = v21;
    __int16 v44 = 2048;
    uint64_t v45 = v22;
    __int16 v46 = 2048;
    uint64_t v47 = v23;
    __int16 v48 = 2048;
    uint64_t v49 = v24;
    __int16 v50 = 2048;
    uint64_t v51 = v25;
    __int16 v52 = 2048;
    uint64_t v53 = v26;
    __int16 v54 = 2048;
    uint64_t v55 = v27;
    __int16 v56 = 2048;
    uint64_t v57 = v28;
    __int16 v58 = 2048;
    uint64_t v59 = v29;
    __int16 v60 = 2048;
    uint64_t v61 = v30;
    LODWORD(v33) = 142;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Fitness Machine datum,startTime,%.3f,elapsedTime,%.3f,calories,%f,distance,%f,elevationAscended,%f,strideCount,%ld ,strokeCount,%ld,floors,%ld,speed,%f,cadence,%f,power,%f,incline,%f,resistance,%f,verticalSpeed,%f",  COERCE_DOUBLE(&v34),  v33);
    __int16 v32 = (uint8_t *)v31;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void _CLFitnessMachineData::log() const", "%s\n", v31);
    if (v32 != buf) {
      free(v32);
    }
  }

__n128 sub_100F71ECC(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 24 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F72794(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x18)) + 168 * (v7 % 0x18);
  __int128 v9 = *a2;
  __int128 v10 = a2[2];
  *(_OWORD *)(v8 + 16) = a2[1];
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)unint64_t v8 = v9;
  __int128 v11 = a2[3];
  __int128 v12 = a2[4];
  __int128 v13 = a2[6];
  *(_OWORD *)(v8 + sub_100F6A7D8(v1 + 80) = a2[5];
  *(_OWORD *)(v8 + 96) = v13;
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  __n128 result = (__n128)a2[7];
  __int128 v15 = a2[8];
  __int128 v16 = a2[9];
  *(void *)(v8 + 160) = *((void *)a2 + 20);
  *(_OWORD *)(v8 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v15;
  *(_OWORD *)(v8 + 144) = v16;
  *(__n128 *)(v8 + 112) = result;
  ++a1[5];
  return result;
}

uint64_t sub_100F71FA0(uint64_t a1, const char *a2, char a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885B20;
  if (a2) {
    __int128 v11 = a2;
  }
  else {
    __int128 v11 = "NatalieInputSrc";
  }
  __int128 v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_10188EED0;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + sub_100F6A7D8(v1 + 80) = 0;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 121) = a3;
  sub_100470F48(a1 + 128);
  if (*(_BYTE *)(a1 + 121))
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + sub_100F6A7D8(v1 + 80) = 1;
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

void sub_100F72068(_Unwind_Exception *a1)
{
}

double sub_100F72080(uint64_t a1, __int128 *a2)
{
  return result;
}

BOOL sub_100F720C0(uint64_t a1, double a2)
{
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  memset(v22, 0, sizeof(v22));
  if (sub_100E1E78C(a1, (uint64_t)&v23, v22, a2))
  {
    uint64_t v4 = *((void *)&v24 + 1);
    if (*((void *)&v24 + 1) == *(void *)v24) {
      uint64_t v4 = *(void *)(v24 - 8) + 4096LL;
    }
    if (!*(_DWORD *)(v4 - 40) && *(double *)(a1 + 104) - *(double *)(a1 + 96) < a2)
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188EF48);
      }
      uint64_t v5 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v30 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Input, Elevation, not ready at time, %.2f ",  buf,  0xCu);
      }

      BOOL result = sub_1002921D0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 == -1) {
          goto LABEL_39;
        }
        goto LABEL_54;
      }

      return result;
    }

    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    __int128 v9 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v10 = *((void *)&v24 + 1);
      if (*((void *)&v24 + 1) == *(void *)v24) {
        uint64_t v10 = *(void *)(v24 - 8) + 4096LL;
      }
      uint64_t v11 = *(void *)(v10 - 56);
      *(_DWORD *)std::string buf = 134218240;
      double v30 = a2;
      __int16 v31 = 2048;
      uint64_t v32 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Input, Elevation, ready at time, %.2f, nearest data point at time, %.2f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    uint64_t v12 = *((void *)&v24 + 1);
    if (*((void *)&v24 + 1) == *(void *)v24) {
      uint64_t v12 = *(void *)(v24 - 8) + 4096LL;
    }
    uint64_t v13 = *(void *)(v12 - 56);
    int v25 = 134218240;
    double v26 = a2;
    __int16 v27 = 2048;
    uint64_t v28 = v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Input, Elevation, ready at time, %.2f, nearest data point at time, %.2f");
LABEL_52:
    uint64_t v21 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieInput<CLElevationChangeEntry>::isReady(CFAbsoluteTime)",  "%s\n",  v14);
    if (v21 != buf) {
      free(v21);
    }
    return 1LL;
  }

  uint64_t v7 = *(void *)(a1 + 64);
  if (v7) {
    double v8 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
                               + (((unint64_t)(v7 + *(void *)(a1 + 56) - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL))
                   + (((v7 + *(void *)(a1 + 56) - 1) & 0x3F) << 6)
                   + 8);
  else {
    double v8 = -1.79769313e308;
  }
  if (!*(_BYTE *)(a1 + 80)
    || v8 >= a2
    || (double v15 = *(double *)(a1 + 16), *(double *)(a1 + 72) - v15 >= a2)
    || v15 + *(double *)(a1 + 88) <= a2
    || (double v16 = *(double *)(a1 + 104),
        v16 - (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2) >= a2))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    uint64_t v20 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 134217984;
      double v30 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "Input, Elevation, ready at time, %.2f, no data point",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188EF48);
    }
    int v25 = 134217984;
    double v26 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Input, Elevation, ready at time, %.2f, no data point");
    goto LABEL_52;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10188EF48);
  }
  uint64_t v17 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 134217984;
    double v30 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Input, Elevation, not ready at time, %.2f ",  buf,  0xCu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 == -1)
    {
LABEL_39:
      int v25 = 134217984;
      double v26 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Input, Elevation, not ready at time, %.2f ");
      uint64_t v19 = (uint8_t *)v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieInput<CLElevationChangeEntry>::isReady(CFAbsoluteTime)",  "%s\n",  v18);
      if (v19 != buf) {
        free(v19);
      }
      return 0LL;
    }

uint64_t sub_100F726C8(uint64_t a1)
{
  *(void *)a1 = off_10188EED0;
  sub_10046E138((void *)(a1 + 128));
  *(void *)a1 = off_101885B20;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

void sub_100F72718(void *a1)
{
  *(void *)a1 = off_10188EED0;
  sub_10046E138((void *)a1 + 16);
  *(void *)a1 = off_101885B20;
  free(*((void **)a1 + 1));
  sub_1002D62D8((void *)a1 + 3);
  operator delete(a1);
}

void sub_100F72768(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_100F72794(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x18;
  unint64_t v4 = v2 - 24;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    double v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)double v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)sub_1000071BC(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      __int16 v38 = (uint64_t *)a1[1];
      double v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        double v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100F72A5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F72AC8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_10188EF68;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 19LL;
  *(_WORD *)(a1 + 16) = 512;
  *(void *)(a1 + 24) = 0x5000000000LL;
  BOOL v3 = (unsigned __int8 *)(a1 + 1952);
  *(_OWORD *)(a1 + 1952) = 0u;
  for (uint64_t i = 1992LL; i != 2184; i += 32LL)
    *(void *)(a1 + i) = 0LL;
  *(_BYTE *)(a1 + 2240) = 0;
  *(_OWORD *)(a1 + 2224) = 0u;
  *(_OWORD *)(a1 + 220_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 2192) = 0u;
  *(_OWORD *)(a1 + 2176) = 0u;
  *(_OWORD *)(a1 + 2160) = 0u;
  *(void *)(a1 + 2296) = 0LL;
  *(_OWORD *)(a1 + 224_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 2264) = 0u;
  *(_OWORD *)(a1 + 22sub_100F6A7D8(v1 + 80) = 0u;
  *(void *)(a1 + 2304) = &off_10188F160;
  *(void *)(a1 + 232_Block_object_dispose((const void *)(v1 - 128), 8) = a1 + 2304;
  *(_OWORD *)(a1 + 2336) = 0u;
  *(_OWORD *)(a1 + 2352) = xmmword_1012CFB80;
  *(void *)(a1 + 236_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 2384) = 0LL;
  *(void *)(a1 + 2376) = 0LL;
  *(void *)(a1 + 2392) = a2;
  *(_OWORD *)(a1 + 2400) = 0u;
  *(_OWORD *)(a1 + 2416) = 0u;
  *(_OWORD *)(a1 + 2432) = 0u;
  *(_OWORD *)(a1 + 244_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(void *)(a1 + 2464) = 0LL;
  *(void *)(a1 + 2472) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 24sub_100F6A7D8(v1 + 80) = 0x7FEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 248_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 2496) = 0LL;
  *(_DWORD *)(a1 + 2504) = 0x80000000;
  *(_OWORD *)(a1 + 250_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 2524) = 0u;
  *(_OWORD *)(a1 + 2540) = 0u;
  *(_OWORD *)(a1 + 2556) = 0u;
  *(_DWORD *)(a1 + 2572) = 0;
  sub_100F72CC4((void *)a1);
  sub_100F72E20((void *)a1, v3);
  return a1;
}

void sub_100F72C04(_Unwind_Exception *a1)
{
  uint64_t v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 2376) = v6;
    operator delete(v6);
  }

  uint64_t v7 = *(void **)(v1 + 2328);
  if (v7 == v3)
  {
    uint64_t v8 = 4LL;
  }

  else
  {
    if (!v7) {
      goto LABEL_8;
    }
    uint64_t v8 = 5LL;
    BOOL v3 = *(void **)(v1 + 2328);
  }

  (*(void (**)(void *))(*v3 + 8 * v8))(v3);
LABEL_8:
  sub_1001B9D48(v2);
  uint64_t v9 = 0LL;
  uint64_t v10 = v1 + 2216;
  do
  {
    uint64_t v11 = *(void **)(v10 + v9);
    *(void *)(v10 + v9) = 0LL;
    if (v11) {
      sub_100F754D0(v10 + v9, v11);
    }
    v9 -= 8LL;
  }

  while (v9 != -64);
  uint64_t v12 = 0LL;
  while (1)
  {
    uint64_t v13 = *(void **)(v1 + v12 + 2152);
    if ((void *)(v1 + v12 + 2128) == v13) {
      break;
    }
    if (v13)
    {
      uint64_t v14 = 5LL;
LABEL_17:
      (*(void (**)(void))(*v13 + 8 * v14))();
    }

    v12 -= 32LL;
    if (v12 == -192) {
      _Unwind_Resume(a1);
    }
  }

  uint64_t v13 = (void *)(v1 + v12 + 2128);
  uint64_t v14 = 4LL;
  goto LABEL_17;
}

void *sub_100F72CC4(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = 0LL;
  *((_DWORD *)result + 48_Block_object_dispose((const void *)(v1 - 128), 8) = 67371265;
  *((_DWORD *)result + 489) = 16843009;
  BOOL v3 = result + 246;
  *((_DWORD *)result + 490) = 1178289687;
  *((_DWORD *)result + 491) = 134744072;
  while (2)
  {
    switch((char)v2)
    {
      case 0:
      case 3:
      case 5:
        v5[0] = &off_10188F1F0;
        goto LABEL_8;
      case 1:
        v5[0] = &off_10188F2F0;
        goto LABEL_7;
      case 2:
        v5[0] = &off_10188F270;
        goto LABEL_7;
      case 4:
        v5[0] = &off_10188F370;
LABEL_7:
        v5[1] = v1;
LABEL_8:
        uint64_t v6 = v5;
        sub_100F7535C(v5, v3);
        BOOL result = v6;
        if (v6 == v5)
        {
          BOOL result = v5;
          uint64_t v4 = 4LL;
        }

        else
        {
          if (!v6) {
            goto LABEL_13;
          }
          uint64_t v4 = 5LL;
        }

        BOOL result = (void *)(*(uint64_t (**)(void))(*result + 8 * v4))();
LABEL_13:
        ++v2;
        v3 += 4;
        if (v2 != 6) {
          continue;
        }
        return result;
      default:
        goto LABEL_13;
    }
  }

void sub_100F72E20(void *a1, unsigned __int8 *a2)
{
  uint64_t v4 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F480;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F3F0;
  sub_100F74F3C((uint64_t)v4, a2, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v4;
  uint64_t v5 = v67;
  if (v67 == &v65)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_6;
    }
    uint64_t v6 = 5LL;
  }

  (*v5)[v6]();
LABEL_6:
  uint64_t v7 = v69;
  if (v69 == v68)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v68;
    goto LABEL_10;
  }

  if (v69)
  {
    uint64_t v8 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  uint64_t v9 = __p;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v10 = (void *)a1[270];
  a1[270] = v9;
  if (v10)
  {
    sub_100F754D0((_DWORD)a1 + 2160, v10);
    uint64_t v11 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v11) {
      sub_100F754D0((int)&__p, v11);
    }
  }

  uint64_t v12 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F580;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F500;
  sub_100F74F3C((uint64_t)v12, a2 + 2, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v12;
  uint64_t v13 = v67;
  if (v67 == &v65)
  {
    uint64_t v14 = 4LL;
    uint64_t v13 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_19;
    }
    uint64_t v14 = 5LL;
  }

  (*v13)[v14]();
LABEL_19:
  uint64_t v15 = v69;
  if (v69 == v68)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = v68;
    goto LABEL_23;
  }

  if (v69)
  {
    uint64_t v16 = 5LL;
LABEL_23:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }

  uint64_t v17 = __p;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v18 = (void *)a1[271];
  a1[271] = v17;
  if (v18)
  {
    sub_100F754D0((_DWORD)a1 + 2168, v18);
    uint64_t v19 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v19) {
      sub_100F754D0((int)&__p, v19);
    }
  }

  int64_t v20 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F680;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F600;
  sub_100F74F3C((uint64_t)v20, a2 + 4, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v20;
  uint64_t v21 = v67;
  if (v67 == &v65)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_32;
    }
    uint64_t v22 = 5LL;
  }

  (*v21)[v22]();
LABEL_32:
  uint64_t v23 = v69;
  if (v69 == v68)
  {
    uint64_t v24 = 4LL;
    uint64_t v23 = v68;
    goto LABEL_36;
  }

  if (v69)
  {
    uint64_t v24 = 5LL;
LABEL_36:
    (*(void (**)(void))(*v23 + 8 * v24))();
  }

  unint64_t v25 = __p;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v26 = (void *)a1[272];
  a1[272] = v25;
  if (v26)
  {
    sub_100F754D0((_DWORD)a1 + 2176, v26);
    __int16 v27 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v27) {
      sub_100F754D0((int)&__p, v27);
    }
  }

  uint64_t v28 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F780;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F700;
  sub_100F74F3C((uint64_t)v28, a2 + 6, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v28;
  uint64_t v29 = v67;
  if (v67 == &v65)
  {
    uint64_t v30 = 4LL;
    uint64_t v29 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_45;
    }
    uint64_t v30 = 5LL;
  }

  (*v29)[v30]();
LABEL_45:
  __int128 v31 = v69;
  if (v69 == v68)
  {
    uint64_t v32 = 4LL;
    __int128 v31 = v68;
    goto LABEL_49;
  }

  if (v69)
  {
    uint64_t v32 = 5LL;
LABEL_49:
    (*(void (**)(void))(*v31 + 8 * v32))();
  }

  unint64_t v33 = __p;
  std::stringbuf::string_type __p = 0LL;
  int v34 = (void *)a1[273];
  a1[273] = v33;
  if (v34)
  {
    sub_100F754D0((_DWORD)a1 + 2184, v34);
    uint64_t v35 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v35) {
      sub_100F754D0((int)&__p, v35);
    }
  }

  uint64_t v36 = operator new(0x50uLL);
  v68[0] = &off_10188F3F0;
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F800;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  sub_100F74F3C((uint64_t)v36, a2 + 8, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v36;
  uint64_t v37 = v67;
  if (v67 == &v65)
  {
    uint64_t v38 = 4LL;
    uint64_t v37 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_58;
    }
    uint64_t v38 = 5LL;
  }

  (*v37)[v38]();
LABEL_58:
  uint64_t v39 = v69;
  if (v69 == v68)
  {
    uint64_t v40 = 4LL;
    uint64_t v39 = v68;
    goto LABEL_62;
  }

  if (v69)
  {
    uint64_t v40 = 5LL;
LABEL_62:
    (*(void (**)(void))(*v39 + 8 * v40))();
  }

  uint64_t v41 = __p;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v42 = (void *)a1[274];
  a1[274] = v41;
  if (v42)
  {
    sub_100F754D0((_DWORD)a1 + 2192, v42);
    uint64_t v43 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v43) {
      sub_100F754D0((int)&__p, v43);
    }
  }

  __int16 v44 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F880;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F500;
  sub_100F74F3C((uint64_t)v44, a2 + 10, (uint64_t)v68, (uint64_t)&v65);
  std::stringbuf::string_type __p = v44;
  uint64_t v45 = v67;
  if (v67 == &v65)
  {
    uint64_t v46 = 4LL;
    uint64_t v45 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_71;
    }
    uint64_t v46 = 5LL;
  }

  (*v45)[v46]();
LABEL_71:
  uint64_t v47 = v69;
  if (v69 == v68)
  {
    uint64_t v48 = 4LL;
    uint64_t v47 = v68;
    goto LABEL_75;
  }

  if (v69)
  {
    uint64_t v48 = 5LL;
LABEL_75:
    (*(void (**)(void))(*v47 + 8 * v48))();
  }

  uint64_t v49 = __p;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v50 = (void *)a1[275];
  a1[275] = v49;
  if (v50)
  {
    sub_100F754D0((_DWORD)a1 + 2200, v50);
    uint64_t v51 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v51) {
      sub_100F754D0((int)&__p, v51);
    }
  }

  uint64_t v52 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188F980;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188F900;
  sub_100F74F3C((uint64_t)v52, a2 + 12, (uint64_t)v68, (uint64_t)&v65);
  uint64_t v53 = v67;
  if (v67 == &v65)
  {
    uint64_t v54 = 4LL;
    uint64_t v53 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_84;
    }
    uint64_t v54 = 5LL;
  }

  (*v53)[v54]();
LABEL_84:
  __int128 v55 = v69;
  if (v69 == v68)
  {
    uint64_t v56 = 4LL;
    __int128 v55 = v68;
  }

  else
  {
    if (!v69) {
      goto LABEL_89;
    }
    uint64_t v56 = 5LL;
  }

  (*(void (**)(void))(*v55 + 8 * v56))();
LABEL_89:
  uint64_t v57 = (void *)a1[276];
  a1[276] = v52;
  if (v57) {
    sub_100F754D0((_DWORD)a1 + 2208, v57);
  }
  __int16 v58 = operator new(0x50uLL);
  uint64_t v69 = v68;
  uint64_t v65 = &off_10188FA80;
  __int16 v66 = a1;
  uint64_t v67 = &v65;
  v68[0] = &off_10188FA00;
  sub_100F74F3C((uint64_t)v58, a2 + 14, (uint64_t)v68, (uint64_t)&v65);
  uint64_t v59 = v67;
  if (v67 == &v65)
  {
    uint64_t v60 = 4LL;
    uint64_t v59 = &v65;
  }

  else
  {
    if (!v67) {
      goto LABEL_96;
    }
    uint64_t v60 = 5LL;
  }

  (*v59)[v60]();
LABEL_96:
  uint64_t v61 = v69;
  if (v69 == v68)
  {
    uint64_t v62 = 4LL;
    uint64_t v61 = v68;
  }

  else
  {
    if (!v69) {
      goto LABEL_101;
    }
    uint64_t v62 = 5LL;
  }

  (*(void (**)(void))(*v61 + 8 * v62))();
LABEL_101:
  uint64_t v63 = (void *)a1[277];
  a1[277] = v58;
  if (v63) {
    sub_100F754D0((_DWORD)a1 + 2216, v63);
  }
}

void sub_100F734B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  int64_t v20 = a13;
  if (a13 == v17)
  {
    uint64_t v21 = 4LL;
    int64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_6:
  uint64_t v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    uint64_t v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_11:
  operator delete(v18);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7357C(uint64_t a1)
{
  if (*(_WORD *)(a1 + 26))
  {
    unint64_t v2 = *(unsigned __int16 *)(a1 + 26) + (unint64_t)*(unsigned __int16 *)(a1 + 24) - 1;
    unint64_t v3 = *(unsigned int *)(a1 + 28);
    if (v2 < v3) {
      unint64_t v3 = 0LL;
    }
    uint64_t v4 = *(void *)(a1 + 24 + 24 * (v2 - v3) + 8);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  uint64_t v14 = v4;
  sub_100CCCC8C(a1, 7, (uint64_t)&v14);
  uint64_t v5 = *(void **)(a1 + 2368);
  if (v5)
  {
    *(void *)(a1 + 2376) = v5;
    operator delete(v5);
  }

  uint64_t v6 = *(void **)(a1 + 2328);
  if (v6 == (void *)(a1 + 2304))
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = (void *)(a1 + 2304);
  }

  else
  {
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_13:
  sub_1001B9D48((void *)(a1 + 2248));
  for (uint64_t i = 2216LL; i != 2152; i -= 8LL)
  {
    uint64_t v9 = *(void **)(a1 + i);
    *(void *)(a1 + i) = 0LL;
    if (v9) {
      sub_100F754D0(a1 + i, v9);
    }
  }

  for (uint64_t j = 0LL; j != -192; j -= 32LL)
  {
    uint64_t v11 = *(void **)(a1 + j + 2152);
    if ((void *)(a1 + j + 2128) == v11)
    {
      uint64_t v11 = (void *)(a1 + j + 2128);
      uint64_t v12 = 4LL;
    }

    else
    {
      if (!v11) {
        continue;
      }
      uint64_t v12 = 5LL;
    }

    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  return a1;
}

void sub_100F736AC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  double v6 = *(double *)a2;
  *(void *)(a1 + 2224) = *(void *)a2;
  double v112 = v6;
  int v113 = *(_DWORD *)(a2 + 52);
  uint64_t v114 = *(void *)(a2 + 40);
  uint64_t v115 = *(void *)(a2 + 32);
  char v116 = *(_BYTE *)(a2 + 48);
  sub_100F73CEC((void *)(a1 + 2248), (uint64_t)&v112);
  *(void *)(a1 + 2376) = *(void *)(a1 + 2368);
  unsigned int v7 = *(unsigned __int16 *)(a1 + 26);
  if (*(_DWORD *)(a1 + 28) == v7)
  {
    sub_100F73DA0(a1, *(double *)(a1 + 24 + 24LL * *(unsigned __int16 *)(a1 + 24) + 8));
    unsigned int v7 = *(unsigned __int16 *)(a1 + 26);
  }

  float64x2_t v110 = 0LL;
  float64x2_t v109 = 0LL;
  uint64_t v111 = 0LL;
  uint64_t v35 = a3;
  if (v7)
  {
    unint64_t v8 = *(unsigned __int16 *)(a1 + 24) + (unint64_t)v7 - 1;
    unint64_t v9 = *(unsigned int *)(a1 + 28);
    if (v8 < v9) {
      unint64_t v9 = 0LL;
    }
    double v10 = *(double *)(a1 + 24 + 24 * (v8 - v9) + 8);
  }

  else
  {
    double v10 = 0.0;
  }

  uint64_t v11 = (void *)(*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 2392) + 24LL) + 32LL))(*(void *)(*(void *)(a1 + 2392) + 24LL));
  sub_100F73FE8(v11, (char **)&v109, v10, *(double *)a2);
  uint64_t v12 = v109;
  uint64_t v13 = v110;
  if (v109 != v110)
  {
    uint64_t v14 = (unsigned __int16 *)(a1 + 24);
    uint64_t v15 = v96;
    uint64_t v16 = a1 + 32;
    __asm { FMOV            V0.2D, #-1.0 }

    __int128 v38 = _Q0;
    uint64_t v36 = v110;
    do
    {
      *((void *)&v106 + 1) = v12[3];
      int v107 = *((_DWORD *)v12 + 54);
      *(void *)&__int128 v106 = *v12;
      __int128 v39 = xmmword_1012EA5D0;
      __int16 v48 = 0;
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      memset(v47, 0, sizeof(v47));
      unint64_t v49 = 0xBFF0000000000000LL;
      int v50 = 0;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v57 = 0u;
      __int128 v58 = 0u;
      __int128 v59 = 0u;
      __int128 v60 = 0u;
      __int128 v61 = 0u;
      __int128 v62 = 0u;
      __int128 v63 = 0u;
      __int128 v64 = 0u;
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      __int128 v67 = 0u;
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      __int128 v70 = 0u;
      uint64_t v71 = 0LL;
      unint64_t v51 = 0xBFF0000000000000LL;
      unint64_t v72 = 0xBFF0000000000000LL;
      uint64_t v73 = 0LL;
      unint64_t v74 = 0xBFF0000000000000LL;
      int v85 = 0;
      uint64_t v86 = 0LL;
      __int128 v75 = 0u;
      __int128 v76 = 0u;
      __int128 v77 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      int v80 = 0;
      __int128 v81 = 0u;
      __int128 v82 = 0u;
      __int128 v83 = 0u;
      memset(v84, 0, sizeof(v84));
      unint64_t v87 = 0xBFF0000000000000LL;
      uint64_t v88 = 0LL;
      uint64_t v89 = 0LL;
      uint64_t v90 = 0x80000000800000LL;
      uint64_t v91 = 0LL;
      uint64_t v92 = 0LL;
      __int128 v93 = xmmword_1012E1EA0;
      uint64_t v94 = 0x80000000800000LL;
      unint64_t v95 = 0xBFF0000000000000LL;
      v15[1] = 0LL;
      v15[2] = 0LL;
      void *v15 = 0LL;
      uint64_t v22 = v15;
      v96[3] = 0xBFF0000000000000LL;
      memset(&v96[4], 0, 24);
      v96[7] = 0xBFF0000000000000LL;
      __int128 v97 = 0u;
      __int128 v98 = 0u;
      uint64_t v99 = 0LL;
      unint64_t v100 = 0xBFF0000000000000LL;
      uint64_t v101 = 0x600000006LL;
      std::stringbuf::string_type __p = 0LL;
      float64x2_t v103 = 0LL;
      uint64_t v104 = 0LL;
      __int128 v105 = v38;
      uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 2392) + 24LL) + 16LL))(*(void *)(*(void *)(a1 + 2392) + 24LL));
      sub_10079897C(v23, &v39, *(double *)v12);
      int v108 = DWORD2(v40);
      sub_1002E5BC0((unsigned __int16 *)(a1 + 24), &v106);
      if (*(_DWORD *)(a1 + 28) == *(unsigned __int16 *)(a1 + 26))
      {
        for (uint64_t i = 2160LL; i != 2224; i += 8LL)
        {
          if ((sub_100F7421C(*(uint64_t **)(a1 + i), (unsigned __int16 *)(a1 + 24)) & 1) != 0
            && *(double *)(v16 + 24LL * *v14) >= v25)
          {
            uint64_t v26 = *(void *)(*(void *)(a1 + i) + 72LL);
            if (v26)
            {
              *(double *)std::string buf = v25;
              (*(void (**)(uint64_t, uint8_t *))(*(void *)v26 + 48LL))(v26, buf);
            }
          }
        }

        double v27 = *(double *)(a1 + 2296);
        double v28 = *(double *)(v16 + 24LL * *(unsigned __int16 *)(a1 + 24));
        if (v27 > v28 && *(void *)(a1 + 2368) == *(void *)(a1 + 2376))
        {
          *(void *)std::string buf = *(void *)(a1 + 2336);
          v121[0] = v27;
          sub_100F742F0((double *)a1, (double *)buf, v28);
        }

        int v37 = *(unsigned __int8 *)(a1 + 16);
        if (qword_101934940 != -1) {
          dispatch_once(&qword_101934940, &stru_10188F130);
        }
        uint64_t v29 = (os_log_s *)qword_101934948;
        if (os_log_type_enabled((os_log_t)qword_101934948, OS_LOG_TYPE_INFO))
        {
          uint64_t v30 = *(void *)(v16 + 24LL * *v14);
          *(_DWORD *)std::string buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v37;
          LOWORD(v121[0]) = 2048;
          *(void *)((char *)v121 + 2) = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "DaylightEstimator,state,%d,startTime,%f",  buf,  0x12u);
        }

        uint64_t v13 = v36;
        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934940 != -1) {
            dispatch_once(&qword_101934940, &stru_10188F130);
          }
          uint64_t v31 = *(void *)(v16 + 24LL * *v14);
          v117[0] = 67109376;
          v117[1] = v37;
          __int16 v118 = 2048;
          uint64_t v119 = v31;
          LODWORD(v34) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934948,  1LL,  "DaylightEstimator,state,%d,startTime,%f",  v117,  v34);
          unint64_t v33 = (uint8_t *)v32;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLDaylightEstimator::Result> CLDaylightEstimator::update(const CLOutdoor_Type::OutdoorUpdate &)",  "%s\n",  v32);
          if (v33 != buf) {
            free(v33);
          }
          uint64_t v13 = v36;
        }
      }

      if (__p)
      {
        float64x2_t v103 = __p;
        operator delete(__p);
      }

      if ((void)v98)
      {
        *((void *)&v98 + 1) = v98;
        operator delete((void *)v98);
      }

      *(void *)std::string buf = v22;
      sub_100023498((void ***)buf);
      uint64_t v15 = v22;
      v12 += 40;
    }

    while (v12 != v13);
  }

  *uint64_t v35 = 0LL;
  v35[1] = 0LL;
  v35[2] = 0LL;
  sub_1000577B4( v35,  *(const void **)(a1 + 2368),  *(void *)(a1 + 2376),  (uint64_t)(*(void *)(a1 + 2376) - *(void *)(a1 + 2368)) >> 4);
  if (v109)
  {
    float64x2_t v110 = v109;
    operator delete(v109);
  }

void sub_100F73CA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  uint64_t v30 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v30;
    operator delete(v30);
  }

  _Unwind_Resume(a1);
}

__n128 sub_100F73CEC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 102 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100F75A10(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *(void *)(v8 + 32) = *(void *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

unint64_t sub_100F73DA0(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 2344);
  if (v4 < a2) {
    double v4 = a2;
  }
  *(double *)(a1 + 2344) = v4;
  uint64_t v5 = *(void *)(a1 + 2256);
  unint64_t v6 = *(void *)(a1 + 2280);
  unint64_t v7 = (void *)(v5 + 8 * (v6 / 0x66));
  if (*(void *)(a1 + 2264) == v5)
  {
    unint64_t v9 = 0LL;
  }

  else
  {
    unint64_t v8 = *(void *)(v5 + 8 * (v6 / 0x66)) + 40 * (v6 % 0x66);
    if ((char *)v8 != v9)
    {
      while (*(double *)v8 > a2)
      {
        v8 += 40LL;
        if (v8 - *v7 == 4080)
        {
          unint64_t v10 = v7[1];
          ++v7;
          unint64_t v8 = v10;
        }
      }

      sub_100F747E0(a1, (uint64_t *)v8);
      uint64_t v11 = *(void *)(a1 + 2328);
      if (!v11) {
LABEL_28:
      }
        sub_100008BDC();
      uint64_t v12 = *(void *)v8;
      double v28 = (*(double (**)(uint64_t, unint64_t))(*(void *)v11 + 48LL))(v11, v8);
      uint64_t v29 = v13;
      sub_100F742F0((double *)a1, &v28, *(double *)&v12);
    }

    if ((char *)v8 != v9)
    {
      unint64_t v14 = v8;
      uint64_t v15 = v7;
      while (1)
      {
        v14 += 40LL;
        if (v14 - *v15 == 4080)
        {
          unint64_t v16 = v15[1];
          ++v15;
          unint64_t v14 = v16;
        }

        if (*(double *)v14 > a2)
        {
          __int128 v20 = *(_OWORD *)v14;
          __int128 v21 = *(_OWORD *)(v14 + 16);
          *(void *)(v8 + 32) = *(void *)(v14 + 32);
          *(_OWORD *)unint64_t v8 = v20;
          *(_OWORD *)(v8 + 16) = v21;
          v8 += 40LL;
          if (v8 - *v7 == 4080)
          {
            unint64_t v22 = v7[1];
            ++v7;
            unint64_t v8 = v22;
          }
        }

        else
        {
          sub_100F747E0(a1, (uint64_t *)v14);
          uint64_t v17 = *(void *)(a1 + 2328);
          if (!v17) {
            goto LABEL_28;
          }
          uint64_t v18 = *(void *)v14;
          double v28 = (*(double (**)(uint64_t, unint64_t))(*(void *)v17 + 48LL))(v17, v14);
          uint64_t v29 = v19;
          sub_100F742F0((double *)a1, &v28, *(double *)&v18);
        }
      }

      unint64_t v9 = (char *)v8;
    }
  }

void sub_100F73FE8(void *a1, char **a2, double a3, double a4)
{
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  unint64_t v9 = (void *)(v7 + 8LL * (a1[6] >> 4));
  if (v8 == v7) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = (double *)(*v9 + 320 * (a1[6] & 0xFLL));
  }
  uint64_t v30 = (uint64_t)(a2 + 2);
  double v11 = a4 + 1.0e-13;
  while (1)
  {
    if (v8 == v7)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      unint64_t v12 = a1[7] + a1[6];
      uint64_t v13 = *(void *)(v7 + ((v12 >> 1) & 0x7FFFFFFFFFFFFFF8LL)) + 320 * (v12 & 0xF);
    }

    if (*v10 <= v11 && *v10 + 1.0e-13 > a3)
    {
      unint64_t v16 = a2[1];
      uint64_t v15 = a2[2];
      if (v16 >= v15)
      {
        unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((v16 - *a2) >> 6);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0xCCCCCCCCCCCCCCLL) {
          sub_100007008();
        }
        unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * ((v15 - *a2) >> 6);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x66666666666666LL) {
          unint64_t v21 = 0xCCCCCCCCCCCCCCLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          unint64_t v22 = (char *)sub_100F75D24(v30, v21);
          uint64_t v24 = v23;
        }

        else
        {
          unint64_t v22 = 0LL;
          uint64_t v24 = 0LL;
        }

        double v25 = &v22[320 * v18];
        memcpy(v25, v10, 0x140uLL);
        uint64_t v26 = *a2;
        double v27 = a2[1];
        double v28 = v25;
        if (v27 != *a2)
        {
          do
          {
            v27 -= 320;
            v28 -= 320;
            memcpy(v28, v27, 0x140uLL);
          }

          while (v27 != v26);
          double v27 = *a2;
        }

        uint64_t v17 = v25 + 320;
        *a2 = v28;
        a2[1] = v25 + 320;
        a2[2] = &v22[320 * v24];
        if (v27) {
          operator delete(v27);
        }
      }

      else
      {
        memcpy(a2[1], v10, 0x140uLL);
        uint64_t v17 = v16 + 320;
      }

      a2[1] = v17;
    }

    v10 += 40;
    if ((double *)((char *)v10 - *v9) == (double *)5120)
    {
      uint64_t v29 = (double *)v9[1];
      ++v9;
      unint64_t v10 = v29;
    }

    uint64_t v7 = a1[3];
    uint64_t v8 = a1[4];
  }

uint64_t sub_100F7421C(uint64_t *a1, unsigned __int16 *a2)
{
  else {
    uint64_t v2 = *a1;
  }
  if (!v2) {
    return 0LL;
  }
  int v5 = 0;
  unint64_t v6 = 0LL;
  uint64_t v7 = 1LL;
  double v8 = -1.0;
  while (1)
  {
    uint64_t v9 = sub_100F74FD4(a2, v6);
    uint64_t v10 = a1[5];
    if (!v10) {
      sub_100008BDC();
    }
    if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48LL))(v10, v9) & 1) != 0)
    {
      if (v8 == -1.0) {
        double v8 = v11;
      }
    }

    if (v2 == ++v6) {
      return 0LL;
    }
  }

  return v7;
}

void sub_100F742F0(double *a1, double *a2, double a3)
{
  double v4 = *a2;
  double v5 = a2[1];
  if (v5 > *a2)
  {
    double v6 = a1[279];
    if (v6 < a1[292]) {
      double v6 = a1[292];
    }
    if (v4 < v6) {
      double v4 = v6;
    }
    if (v5 < a1[287]) {
      double v5 = a1[287];
    }
    a1[287] = v5;
    sub_100F74510((uint64_t)a1, v4, a3);
  }

double sub_100F74330(uint64_t a1, uint64_t a2)
{
  int v4 = sub_100BEF640(a2);
  if (v4 == 1)
  {
    unint64_t v6 = sub_100BEF6EC(*(void *)(a2 + 112), *(void *)(a2 + 120));
    if (v6 <= 0x1B && ((1LL << v6) & 0x9B28010) != 0)
    {
      double result = *(double *)a2;
      *(void *)(a1 + 2352) = *(void *)a2;
      *(void *)(a1 + 2360) = 0x7FEFFFFFFFFFFFFFLL;
    }
  }

  else if (v4 == 2)
  {
    double result = *(double *)(a1 + 2360);
    if (result == 1.79769313e308)
    {
      double result = *(double *)(a2 + 24);
      *(double *)(a1 + 2360) = result;
    }
  }

  return result;
}

uint64_t sub_100F743C0(uint64_t result, double a2, double a3)
{
  if (*(_WORD *)(result + 26))
  {
    uint64_t v5 = result;
    unint64_t v6 = 0LL;
    uint64_t v7 = (unsigned __int16 *)(result + 24);
    double v8 = (int32x2_t *)(result + 2452);
    do
    {
      double result = sub_100F74FD4(v7, v6);
      if (*(double *)result >= a2)
      {
        double result = sub_100F74FD4(v7, v6);
        if (*(double *)result <= a3)
        {
          if (*(_DWORD *)(sub_100F74FD4(v7, v6) + 16)) {
            int v9 = *(_DWORD *)(v5 + 2444) + 1;
          }
          else {
            int v9 = *(_DWORD *)(v5 + 2444);
          }
          *(_DWORD *)(v5 + 2444) = v9;
          ++*(_DWORD *)(v5 + 2440);
          unsigned int v10 = *(_DWORD *)(sub_100F74FD4(v7, v6) + 20);
          int32x2_t *v8 = vsub_s32(*v8, vceq_s32(vdup_n_s32(v10), (int32x2_t)0x100000080LL));
          int v11 = 1;
          if (v10 != 256 && v10 != 512) {
            int v11 = v10 == 4096;
          }
          *(_DWORD *)(v5 + 2448) += v11;
          double result = sub_100F74FD4(v7, v6);
          int v12 = *(double *)result >= *(double *)(v5 + 2352) && *(double *)result <= *(double *)(v5 + 2360);
          *(_DWORD *)(v5 + 2460) += v12;
        }
      }

      ++v6;
    }

    while (v6 < *(unsigned __int16 *)(v5 + 26));
  }

  return result;
}

void sub_100F74510(uint64_t a1, double a2, double a3)
{
  if (a2 >= a3) {
    double v4 = a2;
  }
  else {
    double v4 = a3;
  }
  if (a2 <= a3) {
    double v5 = a2;
  }
  else {
    double v5 = v4;
  }
  if (a2 <= a3) {
    double v6 = a3;
  }
  else {
    double v6 = v4;
  }
  if (qword_101934940 != -1) {
    dispatch_once(&qword_101934940, &stru_10188F130);
  }
  uint64_t v7 = (os_log_s *)qword_101934948;
  if (os_log_type_enabled((os_log_t)qword_101934948, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 134218240;
    double v28 = v5;
    __int16 v29 = 2048;
    double v30 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "daylightTimeEstimate,startTime,%f,endTime,%f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934940 != -1) {
      dispatch_once(&qword_101934940, &stru_10188F130);
    }
    int v23 = 134218240;
    double v24 = v5;
    __int16 v25 = 2048;
    double v26 = v6;
    LODWORD(v22) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934948,  1LL,  "daylightTimeEstimate,startTime,%f,endTime,%f",  COERCE_DOUBLE(&v23),  v22);
    unint64_t v21 = (uint8_t *)v20;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLDaylightEstimator::enqueueResult(Result)", "%s\n", v20);
    if (v21 != buf) {
      free(v21);
    }
  }

  double v8 = *(double *)(a1 + 2336);
  if (v8 < v6) {
    double v8 = v6;
  }
  *(double *)(a1 + 2336) = v8;
  *(double *)(a1 + 2464) = v6 - v5 + *(double *)(a1 + 2464);
  int v9 = *(double **)(a1 + 2376);
  unint64_t v10 = *(void *)(a1 + 2384);
  if ((unint64_t)v9 >= v10)
  {
    int v12 = *(double **)(a1 + 2368);
    uint64_t v13 = ((char *)v9 - (char *)v12) >> 4;
    unint64_t v14 = v13 + 1;
    uint64_t v15 = v10 - (void)v12;
    if (v15 >> 3 > v14) {
      unint64_t v14 = v15 >> 3;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      uint64_t v17 = (char *)sub_100037038(a1 + 2384, v16);
      int v9 = *(double **)(a1 + 2376);
      int v12 = *(double **)(a1 + 2368);
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    unint64_t v18 = (double *)&v17[16 * v13];
    unint64_t v19 = &v17[16 * v16];
    *unint64_t v18 = v5;
    v18[1] = v6;
    int v11 = v18 + 2;
    if (v9 != v12)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v9 - 1);
        v18 -= 2;
        v9 -= 2;
      }

      while (v9 != v12);
      int v12 = *(double **)(a1 + 2368);
    }

    *(void *)(a1 + 236_Block_object_dispose((const void *)(v1 - 128), 8) = v18;
    *(void *)(a1 + 2376) = v11;
    *(void *)(a1 + 2384) = v19;
    if (v12) {
      operator delete(v12);
    }
  }

  else
  {
    double *v9 = v5;
    v9[1] = v6;
    int v11 = v9 + 2;
  }

  *(void *)(a1 + 2376) = v11;
}

uint64_t sub_100F747E0(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = a2[2];
  if (v2 == 3)
  {
    double v4 = *(double *)a2;
    *(double *)(result + 2424) = v4;
    ++*(_DWORD *)(result + 2432);
  }

  else if (v2 == 2)
  {
    double v3 = *(double *)a2;
    *(double *)(result + 240_Block_object_dispose((const void *)(v1 - 128), 8) = v3;
    ++*(_DWORD *)(result + 2436);
  }

  double v5 = *((double *)a2 + 3);
  *(double *)(result + 248_Block_object_dispose((const void *)(v1 - 128), 8) = v5 + *(double *)(result + 2488);
  ++*(void *)(result + 2496);
  float v6 = *((float *)a2 + 2);
  if (v6 >= 0.0)
  {
    for (uint64_t i = 0LL; i != 17; ++i)
    {
      if (v6 <= dword_1013B9890[i]) {
        break;
      }
    }

    ++*(_DWORD *)(result + 4LL * i + 2508);
  }

  return result;
}

void sub_100F748E0(uint64_t a1, int a2, int a3, double a4, double a5)
{
  HIDWORD(v6_Block_object_dispose((const void *)(v1 - 128), 8) = a2;
  uint64_t v9 = 0LL;
  memset(&v69, 0, sizeof(v69));
  uint64_t v10 = a1 + 2508;
  do
  {
    std::string::append(&v69, "bin");
    std::to_string(&v124, (int)dword_1013B9890[v9]);
    if ((v124.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v11 = &v124;
    }
    else {
      int v11 = (std::string *)v124.__r_.__value_.__r.__words[0];
    }
    if ((v124.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v124.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v124.__r_.__value_.__l.__size_;
    }
    std::string::append(&v69, (const std::string::value_type *)v11, size);
    std::string::append(&v69, ",");
    std::to_string(&v124, *(_DWORD *)(v10 + v9 * 4));
    if ((v124.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v13 = &v124;
    }
    else {
      uint64_t v13 = (std::string *)v124.__r_.__value_.__r.__words[0];
    }
    if ((v124.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v14 = v124.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v14 = v124.__r_.__value_.__l.__size_;
    }
    std::string::append(&v69, (const std::string::value_type *)v13, v14);
    std::string::append(&v69, ",");
    ++v9;
  }

  while (v9 != 17);
  uint64_t v15 = *(void *)(a1 + 2496);
  if (qword_101934940 != -1) {
    dispatch_once(&qword_101934940, &stru_10188F130);
  }
  unint64_t v16 = (os_log_s *)qword_101934948;
  if (os_log_type_enabled((os_log_t)qword_101934948, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v17 = *(void *)(a1 + 2496);
    std::string::size_type v18 = *(void *)(a1 + 2400);
    uint64_t v19 = *(void *)(a1 + 2408);
    uint64_t v20 = *(void *)(a1 + 2416);
    uint64_t v21 = *(void *)(a1 + 2424);
    int v22 = *(_DWORD *)(a1 + 2436);
    int v23 = *(_DWORD *)(a1 + 2432);
    if (v15)
    {
      uint64_t v24 = *(void *)(a1 + 2472);
      uint64_t v25 = *(void *)(a1 + 2480);
      if (v17) {
        double v26 = *(double *)(a1 + 2488) / (double)v17;
      }
      else {
        double v26 = 0.0;
      }
      int v27 = *(_DWORD *)(a1 + 2504);
    }

    else
    {
      uint64_t v24 = 0LL;
      uint64_t v25 = 0LL;
      int v27 = 0;
      double v26 = 0.0;
    }

    double v28 = &v69;
    if ((v69.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v28 = (std::string *)v69.__r_.__value_.__r.__words[0];
    }
    uint64_t v29 = *(void *)(a1 + 32 + 24LL * *(unsigned __int16 *)(a1 + 24));
    unint64_t v30 = *(unsigned __int16 *)(a1 + 24) + (unint64_t)*(unsigned __int16 *)(a1 + 26) - 1;
    unint64_t v31 = *(unsigned int *)(a1 + 28);
    if (v30 < v31) {
      unint64_t v31 = 0LL;
    }
    uint64_t v32 = *(void *)(a1 + 32 + 24 * (v30 - v31));
    uint64_t v33 = *(void *)(a1 + 2224);
    uint64_t v34 = *(void *)(a1 + 2464);
    int v35 = *(_DWORD *)(a1 + 2440);
    int v36 = *(_DWORD *)(a1 + 2444);
    int v37 = *(_DWORD *)(a1 + 2448);
    int v38 = *(_DWORD *)(a1 + 2452);
    int v39 = *(_DWORD *)(a1 + 2456);
    int v40 = *(_DWORD *)(a1 + 2460);
    LODWORD(v124.__r_.__value_.__l.__data_) = 134224642;
    *(std::string::size_type *)((char *)v124.__r_.__value_.__r.__words + 4) = v17;
    WORD2(v124.__r_.__value_.__r.__words[1]) = 2048;
    *(std::string::size_type *)((char *)&v124.__r_.__value_.__r.__words[1] + 6) = v18;
    HIWORD(v124.__r_.__value_.__r.__words[2]) = 2048;
    uint64_t v125 = v19;
    __int16 v126 = 2048;
    uint64_t v127 = v20;
    __int16 v128 = 2048;
    uint64_t v129 = v21;
    __int16 v130 = 1024;
    int v131 = v22;
    __int16 v132 = 1024;
    int v133 = v23;
    __int16 v134 = 2048;
    uint64_t v135 = v24;
    __int16 v136 = 2048;
    uint64_t v137 = v25;
    __int16 v138 = 2048;
    double v139 = v26;
    __int16 v140 = 1024;
    int v141 = v27;
    __int16 v142 = 2080;
    float64x2_t v143 = v28;
    __int16 v144 = 2048;
    uint64_t v145 = v29;
    __int16 v146 = 2048;
    uint64_t v147 = v32;
    __int16 v148 = 2048;
    uint64_t v149 = v33;
    __int16 v150 = 2048;
    double v151 = a4;
    __int16 v152 = 2048;
    double v153 = a5;
    __int16 v154 = 2048;
    double v155 = a5 - a4;
    __int16 v156 = 2048;
    uint64_t v157 = v34;
    __int16 v158 = 1024;
    int v159 = HIDWORD(v68);
    __int16 v160 = 1024;
    int v161 = a3;
    __int16 v162 = 1024;
    int v163 = v35;
    __int16 v164 = 1024;
    int v165 = v36;
    __int16 v166 = 1024;
    int v167 = v37;
    __int16 v168 = 1024;
    int v169 = v38;
    __int16 v170 = 1024;
    int v171 = v39;
    __int16 v172 = 1024;
    int v173 = v40;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "DaylightEstimatorStateChange,numOutdoorUpdates,%lu,firstMedConf,%.2f,lastMedConf,%.2f,firstHighConf,%.2f,lastHighC onf,%.2f,numMedConf,%d,numHighConf,%d,maxOutdoor,%.2f,minOutdoor,%.2f,meanOutdoor,%.2f,maxLux,%d,%sfrontOfBuffer,% .2f,endOfBuffer,%.2f,currentTime,%.2f,stateStart,%.2f,stateEnd,%.2f,duration,%.2f,daylight,%.2f,from,%d,to,%d,tota lEpochs,%d,totalStepEpochs,%d,totalDriving,%d,totalCycling,%d,totalFrozen,%d,totalInWorkout,%d",  (uint8_t *)&v124,  0xE4u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v124, 0x65CuLL);
    if (qword_101934940 != -1) {
      dispatch_once(&qword_101934940, &stru_10188F130);
    }
    unint64_t v41 = *(void *)(a1 + 2496);
    uint64_t v42 = *(void *)(a1 + 2400);
    uint64_t v43 = *(void *)(a1 + 2408);
    uint64_t v44 = *(void *)(a1 + 2416);
    uint64_t v45 = *(void *)(a1 + 2424);
    int v46 = *(_DWORD *)(a1 + 2436);
    int v47 = *(_DWORD *)(a1 + 2432);
    if (v15)
    {
      uint64_t v48 = *(void *)(a1 + 2472);
      uint64_t v49 = *(void *)(a1 + 2480);
      if (v41) {
        double v50 = *(double *)(a1 + 2488) / (double)v41;
      }
      else {
        double v50 = 0.0;
      }
      int v51 = *(_DWORD *)(a1 + 2504);
    }

    else
    {
      uint64_t v48 = 0LL;
      uint64_t v49 = 0LL;
      int v51 = 0;
      double v50 = 0.0;
    }

    __int128 v52 = &v69;
    if ((v69.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v52 = (std::string *)v69.__r_.__value_.__r.__words[0];
    }
    uint64_t v53 = *(void *)(a1 + 32 + 24LL * *(unsigned __int16 *)(a1 + 24));
    unint64_t v54 = *(unsigned __int16 *)(a1 + 24) + (unint64_t)*(unsigned __int16 *)(a1 + 26) - 1;
    unint64_t v55 = *(unsigned int *)(a1 + 28);
    if (v54 < v55) {
      unint64_t v55 = 0LL;
    }
    uint64_t v56 = *(void *)(a1 + 32 + 24 * (v54 - v55));
    uint64_t v57 = *(void *)(a1 + 2224);
    uint64_t v58 = *(void *)(a1 + 2464);
    int v59 = *(_DWORD *)(a1 + 2440);
    int v60 = *(_DWORD *)(a1 + 2444);
    int v61 = *(_DWORD *)(a1 + 2448);
    int v62 = *(_DWORD *)(a1 + 2452);
    int v63 = *(_DWORD *)(a1 + 2456);
    int v64 = *(_DWORD *)(a1 + 2460);
    int v70 = 134224642;
    unint64_t v71 = v41;
    __int16 v72 = 2048;
    uint64_t v73 = v42;
    __int16 v74 = 2048;
    uint64_t v75 = v43;
    __int16 v76 = 2048;
    uint64_t v77 = v44;
    __int16 v78 = 2048;
    uint64_t v79 = v45;
    __int16 v80 = 1024;
    int v81 = v46;
    __int16 v82 = 1024;
    int v83 = v47;
    __int16 v84 = 2048;
    uint64_t v85 = v48;
    __int16 v86 = 2048;
    uint64_t v87 = v49;
    __int16 v88 = 2048;
    double v89 = v50;
    __int16 v90 = 1024;
    int v91 = v51;
    __int16 v92 = 2080;
    __int128 v93 = v52;
    __int16 v94 = 2048;
    uint64_t v95 = v53;
    __int16 v96 = 2048;
    uint64_t v97 = v56;
    __int16 v98 = 2048;
    uint64_t v99 = v57;
    __int16 v100 = 2048;
    double v101 = a4;
    __int16 v102 = 2048;
    double v103 = a5;
    __int16 v104 = 2048;
    double v105 = a5 - a4;
    __int16 v106 = 2048;
    uint64_t v107 = v58;
    __int16 v108 = 1024;
    int v109 = HIDWORD(v68);
    __int16 v110 = 1024;
    int v111 = a3;
    __int16 v112 = 1024;
    int v113 = v59;
    __int16 v114 = 1024;
    int v115 = v60;
    __int16 v116 = 1024;
    int v117 = v61;
    __int16 v118 = 1024;
    int v119 = v62;
    __int16 v120 = 1024;
    int v121 = v63;
    __int16 v122 = 1024;
    int v123 = v64;
    LODWORD(v67) = 228;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v124,  1628LL,  &_mh_execute_header,  qword_101934948,  0LL,  "DaylightEstimatorStateChange,numOutdoorUpdates,%lu,firstMedConf,%.2f,lastMedConf,%.2f,firstHighConf,%.2f,lastHighC onf,%.2f,numMedConf,%d,numHighConf,%d,maxOutdoor,%.2f,minOutdoor,%.2f,meanOutdoor,%.2f,maxLux,%d,%sfrontOfBuffer,% .2f,endOfBuffer,%.2f,currentTime,%.2f,stateStart,%.2f,stateEnd,%.2f,duration,%.2f,daylight,%.2f,from,%d,to,%d,tota lEpochs,%d,totalStepEpochs,%d,totalDriving,%d,totalCycling,%d,totalFrozen,%d,totalInWorkout,%d",  &v70,  v67,  v68,  *(double *)&v69.__r_.__value_.__l.__data_,  *(double *)&v69.__r_.__value_.__l.__size_,  LODWORD(v69.__r_.__value_.__r.__words[2]));
    __int128 v66 = (std::string *)v65;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLDaylightEstimator::logStateChange(CFAbsoluteTime, CFAbsoluteTime, State, State) const",  "%s\n",  v65);
    if (v66 != &v124) {
      free(v66);
    }
  }

void sub_100F74EF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, void *a48, uint64_t a49, int a50,__int16 a51,char a52,char a53)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F74F3C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = a2[1];
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = *a2;
  sub_10001A504(a1 + 16, a3);
  sub_10001A504(a1 + 48, a4);
  return a1;
}

void sub_100F74F94(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  double v5 = *(void **)(v3 + 40);
  if (v5 == v1)
  {
    uint64_t v6 = 4LL;
  }

  else
  {
    if (!v5) {
      goto LABEL_6;
    }
    uint64_t v6 = 5LL;
    uint64_t v1 = v5;
  }

  (*(void (**)(void *))(*v1 + 8 * v6))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F74FD4(unsigned __int16 *a1, unint64_t a2)
{
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188FAF0);
    }
    uint64_t v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v17 = a2;
      __int16 v18 = 1024;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMQueue.h, line 2 33,i,%zu,capacity,%u.",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188FAF0);
      }
      int v9 = *((_DWORD *)a1 + 1);
      int v12 = 134218240;
      unint64_t v13 = a2;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMQueue.h, line 2 33,i,%zu,capacity,%u.",  (size_t)&v12,  18);
      int v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "const T &CMQueue<CLDaylightEstimator::StepsAndActivity>::operator[](const size_t) const [T = CLDaylightEstimator ::StepsAndActivity]",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0LL;
  }
  return (uint64_t)&a1[12 * (v4 - v5) + 4];
}

void sub_100F751D0(id a1)
{
  qword_101934948 = (uint64_t)os_log_create("com.apple.locationd.Position", "Outdoor");
}

void *sub_100F751FC(uint64_t a1, double *a2)
{
  uint64_t v4 = *(unsigned __int8 *)(a1 + 16);
  sub_100F748E0(a1, *(unsigned __int8 *)(a1 + 2240), *(unsigned __int8 *)(a1 + 16), *(double *)(a1 + 2232), *a2);
  *(void *)(a1 + 2296) = 0LL;
  *(double *)(a1 + 2232) = *a2;
  *(_BYTE *)(a1 + 2240) = v4;
  *(void *)(a1 + 2464) = 0LL;
  *(_OWORD *)(a1 + 244_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 2432) = 0u;
  *(_OWORD *)(a1 + 2416) = 0u;
  *(_OWORD *)(a1 + 2400) = 0u;
  *(void *)(a1 + 2472) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 24sub_100F6A7D8(v1 + 80) = 0x7FEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 248_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 2496) = 0LL;
  *(_DWORD *)(a1 + 2504) = 0x80000000;
  *(_DWORD *)(a1 + 2572) = 0;
  *(_OWORD *)(a1 + 2556) = 0u;
  *(_OWORD *)(a1 + 2540) = 0u;
  *(_OWORD *)(a1 + 2524) = 0u;
  *(_OWORD *)(a1 + 250_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  return sub_100F752C4((void *)(a1 + 2304), a1 + 32 * v4 + 1968);
}

void *sub_100F752C4(void *a1, uint64_t a2)
{
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void *sub_100F7535C(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    unint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_100F754C4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100F754D0(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v3 = (void *)__p[9];
    if (v3 == __p + 6)
    {
      uint64_t v4 = 4LL;
      uint64_t v3 = __p + 6;
    }

    else
    {
      if (!v3) {
        goto LABEL_8;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
    unint64_t v5 = (void *)__p[5];
    if (v5 == __p + 2)
    {
      uint64_t v6 = 4LL;
      unint64_t v5 = __p + 2;
    }

    else
    {
      if (!v5)
      {
LABEL_13:
        operator delete(__p);
        return;
      }

      uint64_t v6 = 5LL;
    }

    (*(void (**)(void))(*v5 + 8 * v6))();
    goto LABEL_13;
  }

void *sub_100F75558()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F160;
  return result;
}

void sub_100F75580(uint64_t a1, void *a2)
{
  *a2 = &off_10188F160;
}

double sub_100F7559C()
{
  return 1.79769313e308;
}

uint64_t sub_100F755B0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100F755EC()
{
  return &off_10188F1D0;
}

void *sub_100F75600()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F1F0;
  return result;
}

void sub_100F75624(uint64_t a1, void *a2)
{
  *a2 = &off_10188F1F0;
}

double sub_100F7563C()
{
  return 1.79769313e308;
}

uint64_t sub_100F75650(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100F7568C()
{
}

void *sub_100F756A0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F270;
  result[1] = v3;
  return result;
}

uint64_t sub_100F756D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F270;
  a2[1] = v2;
  return result;
}

double sub_100F756F0(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)a2;
  if ((*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFELL) == 2) {
    return v2 + -150.0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  double result = *(double *)(v4 + 2352);
  if (v2 < result) {
    return 1.79769313e308;
  }
  return result;
}

uint64_t sub_100F75778(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100F757B4()
{
}

void *sub_100F757C8(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F2F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F757FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F2F0;
  a2[1] = v2;
  return result;
}

double sub_100F75818(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)a2;
  if ((*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFELL) == 2) {
    return v2 + -450.0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  double result = *(double *)(v4 + 2352);
  if (v2 < result) {
    return 1.79769313e308;
  }
  return result;
}

uint64_t sub_100F758A0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100F758DC()
{
}

void *sub_100F758F0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F370;
  result[1] = v3;
  return result;
}

uint64_t sub_100F75924(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F370;
  a2[1] = v2;
  return result;
}

double sub_100F75940(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)a2;
  if ((*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFELL) == 2) {
    return v2 + -900.0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  double result = *(double *)(v4 + 2352);
  if (v2 < result) {
    return 1.79769313e308;
  }
  return result;
}

uint64_t sub_100F759C8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100F75A04()
{
}

void sub_100F75A10(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    int v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100F75CD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100F75D24(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCDLL) {
    sub_1000070D4();
  }
  return operator new(320 * a2);
}

void *sub_100F75D70()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F3F0;
  return result;
}

void sub_100F75D94(uint64_t a1, void *a2)
{
  *a2 = &off_10188F3F0;
}

BOOL sub_100F75DAC(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 16) || *(_DWORD *)(a2 + 20) == 128;
}

uint64_t sub_100F75DE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F75E1C()
{
}

void *sub_100F75E30(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F480;
  result[1] = v3;
  return result;
}

uint64_t sub_100F75E64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F480;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F75E80(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 1, (uint64_t)&v4);
}

uint64_t sub_100F75EB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F75EEC()
{
}

void *sub_100F75F00()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F500;
  return result;
}

void sub_100F75F24(uint64_t a1, void *a2)
{
  *a2 = &off_10188F500;
}

uint64_t sub_100F75F3C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)(a2 + 20) == 128;
  }
  int v3 = v2;
  return v3 ^ 1u;
}

uint64_t sub_100F75F60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F75F9C()
{
}

void *sub_100F75FB0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F580;
  result[1] = v3;
  return result;
}

uint64_t sub_100F75FE4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F580;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F76000(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 2, (uint64_t)&v4);
}

uint64_t sub_100F76030(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F7606C()
{
}

void *sub_100F76080()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F600;
  return result;
}

void sub_100F760A4(uint64_t a1, void *a2)
{
  *a2 = &off_10188F600;
}

BOOL sub_100F760BC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 20);
  return v2 == 256 || v2 == 4096 || v2 == 512;
}

uint64_t sub_100F760F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F7612C()
{
}

void *sub_100F76140(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10188F680;
  result[1] = v3;
  return result;
}

uint64_t sub_100F76174(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F680;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F76190(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 3, (uint64_t)&v4);
}

uint64_t sub_100F761C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F761FC()
{
}

void *sub_100F76210()
{
  double result = operator new(0x10uLL);
  *double result = &off_10188F700;
  return result;
}

void sub_100F76234(uint64_t a1, void *a2)
{
  *a2 = &off_10188F700;
}

BOOL sub_100F7624C(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  int v3 = *(_DWORD *)(a2 + 20);
  if (v3 != 256 && v3 != 512) {
    return v3 != 4096;
  }
  return result;
}

uint64_t sub_100F76288(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F762C4()
{
}

void *sub_100F762D8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_10188F780;
  result[1] = v3;
  return result;
}

uint64_t sub_100F7630C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F780;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F76328(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 4, (uint64_t)&v4);
}

uint64_t sub_100F76358(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F76394()
{
}

void *sub_100F763A8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_10188F800;
  result[1] = v3;
  return result;
}

uint64_t sub_100F763DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F800;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F763F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 5, (uint64_t)&v4);
}

uint64_t sub_100F76428(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F76464()
{
}

void *sub_100F76478(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_10188F880;
  result[1] = v3;
  return result;
}

uint64_t sub_100F764AC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F880;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F764C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 6, (uint64_t)&v4);
}

uint64_t sub_100F764F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F76534()
{
}

void *sub_100F76548()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &off_10188F900;
  return result;
}

void sub_100F7656C(uint64_t a1, void *a2)
{
  *a2 = &off_10188F900;
}

BOOL sub_100F76584(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) == 1;
}

uint64_t sub_100F7659C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F765D8()
{
}

void *sub_100F765EC(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_10188F980;
  result[1] = v3;
  return result;
}

uint64_t sub_100F76620(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188F980;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F7663C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 7, (uint64_t)&v4);
}

uint64_t sub_100F7666C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F766A8()
{
}

void *sub_100F766BC()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &off_10188FA00;
  return result;
}

void sub_100F766E0(uint64_t a1, void *a2)
{
  *a2 = &off_10188FA00;
}

BOOL sub_100F766F8(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) != 1;
}

uint64_t sub_100F76710(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F7674C()
{
}

void *sub_100F76760(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_10188FA80;
  result[1] = v3;
  return result;
}

uint64_t sub_100F76794(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10188FA80;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F767B0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  return sub_100CCCC8C(v2, 8, (uint64_t)&v4);
}

uint64_t sub_100F767E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F7681C()
{
}

void sub_100F76828(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100F76854(void *a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199F860);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199F860))
  {
    __cxa_atexit((void (*)(void *))sub_100F7690C, &qword_10199F850, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199F860);
  }

  if (qword_10199F868 != -1) {
    dispatch_once(&qword_10199F868, &stru_10188FB10);
  }
  uint64_t v3 = *(void *)algn_10199F858;
  *a1 = qword_10199F850;
  a1[1] = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

void sub_100F76910(id a1)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)&v4 + 1);
  if (*((void *)&v4 + 1))
  {
    unsigned __int8 v2 = (unint64_t *)(*((void *)&v4 + 1) + 8LL);
    do
      unint64_t v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

  sub_100A1F6A8(*(void *)(qword_10199F850 + 88));
}

uint64_t sub_100F76994(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  *(void *)a1 = off_10188FB40;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = off_10188FB98;
  uint64_t v8 = qword_10199F848;
  *(void *)(a1 + 16) = qword_10199F840;
  *(void *)(a1 + 24) = v8;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = -1LL;
  *(_DWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 200;
  *(_WORD *)(a1 + 52) = 0;
  sub_1002E4C3C(a1 + 56, "CLWifiAccessPointLocationService", 1LL, 1LL);
  *(_DWORD *)(a1 + 72) = 0;
  int v9 = operator new(0x2CuLL);
  sub_1003CF318(v9);
  *(void *)(a1 + sub_100F6A7D8(v1 + 80) = v9;
  uint64_t v10 = *a2;
  *a2 = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = v10;
  uint64_t v11 = operator new(0x28uLL);
  uint64_t v12 = *a3;
  *a3 = 0LL;
  *(void *)std::string buf = v12;
  sub_100F7F5BC(v11, (uint64_t *)buf);
  *(void *)(a1 + 96) = v11;
  uint64_t v13 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  if (v13)
  {
    BOOL v14 = (void *)sub_10052D288(v13);
    operator delete(v14);
  }

  sub_100ECC8D0((uint64_t *)(a1 + 104));
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 112) = a1 + 120;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  uint64_t v15 = *a4;
  *(void *)(a1 + 136) = *a4;
  if (v15)
  {
    uint64_t v16 = operator new(0x20uLL);
    uint64_t v17 = *a4;
    *uint64_t v16 = &off_10188FCC8;
    v16[1] = 0LL;
    _DWORD v16[2] = 0LL;
    uint64_t v16[3] = v17;
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  *(void *)(a1 + 144) = v16;
  *a4 = 0LL;
  uint64_t v18 = operator new(0x18uLL);
  sub_1002FA758((uint64_t)v18);
  *(void *)(a1 + 152) = v18;
  *(void *)(a1 + 160) = 0LL;
  sub_100F77174(a1);
  if (!*(_BYTE *)sub_100F4BF38())
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    uint64_t v24 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "MovingApDetector got disabled by CLWifi1Settings!",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      v37[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "MovingApDetector got disabled by CLWifi1Settings!",  v37,  2);
      int v35 = (uint8_t *)v34;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWifiAccessPointLocationService::CLWifiAccessPointLocationService(std::unique_ptr<CLWifiAccessPointLocationRepo sitory>, std::unique_ptr<CLWifiTileHeaderDatabase>, std::unique_ptr<CLMovingApDetector>)",  "%s\n",  v34);
      if (v35 != buf) {
        free(v35);
      }
    }

    *(void *)std::string buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    sub_10005F550(a1 + 136, (__int128 *)buf);
    unint64_t v25 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v26 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }

  if (sub_1007EC584())
  {
    int v19 = objc_alloc_init(&OBJC_CLASS___CLWifiAssociatedApCentroidSyncedDataStore);
  }

  else
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    int64_t v20 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Not initializing WifiAssociatedApCentroidStore as it got disabled by CLWifi1Settings!",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      v37[0] = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "Not initializing WifiAssociatedApCentroidStore as it got disabled by CLWifi1Settings!",  v37,  v36);
      __int128 v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWifiAccessPointLocationService::CLWifiAccessPointLocationService(std::unique_ptr<CLWifiAccessPointLocationRepo sitory>, std::unique_ptr<CLWifiTileHeaderDatabase>, std::unique_ptr<CLMovingApDetector>)",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }

    int v19 = 0LL;
  }

  *(void *)(a1 + 160) = v19;
  if ((sub_10068D0F0() & 1) == 0)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    uint64_t v21 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "CLWifiTilesManager is disabled by settings. Deleting all tile data in wifi tile database",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      v37[0] = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "CLWifiTilesManager is disabled by settings. Deleting all tile data in wifi tile database",  v37,  v36);
      unint64_t v33 = (uint8_t *)v32;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWifiAccessPointLocationService::CLWifiAccessPointLocationService(std::unique_ptr<CLWifiAccessPointLocationRepo sitory>, std::unique_ptr<CLWifiTileHeaderDatabase>, std::unique_ptr<CLMovingApDetector>)",  "%s\n",  v32);
      if (v33 != buf) {
        free(v33);
      }
    }

    sub_100DAACDC(*(uint64_t **)(a1 + 96));
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188FC08);
  }
  unint64_t v22 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Deleting CoreData store file from disk for WifiAssociatedApCentroidStore",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    v37[0] = 0;
    LODWORD(v36) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "Deleting CoreData store file from disk for WifiAssociatedApCentroidStore",  v37,  v36);
    uint64_t v29 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWifiAccessPointLocationService::CLWifiAccessPointLocationService(std::unique_ptr<CLWifiAccessPointLocationReposi tory>, std::unique_ptr<CLWifiTileHeaderDatabase>, std::unique_ptr<CLMovingApDetector>)",  "%s\n",  v28);
    if (v29 != buf) {
      free(v29);
    }
  }

  +[CLPersistenceManager deleteDefaultStoreFileFromDisk]( &OBJC_CLASS___CLPersistenceManager,  "deleteDefaultStoreFileFromDisk");
  return a1;
}

void sub_100F77088( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v20 = *v13;
  *uint64_t v13 = 0LL;
  if (v20) {
    sub_100F7F77C((uint64_t)v13, v20);
  }
  uint64_t v21 = *(void **)(v12 + 80);
  *(void *)(v12 + sub_100F6A7D8(v1 + 80) = 0LL;
  if (v21) {
    operator delete(v21);
  }
  sub_1002E4CB0(a12);
  _Unwind_Resume(a1);
}

void sub_100F77174(uint64_t a1)
{
  int v2 = sub_1002A82BC(*(uint64_t *)buf, "MaxTileAge", &v20);
  int v3 = v2;
  __int128 v4 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v5 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      if (!v3) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }

  if (v2) {
LABEL_6:
  }
    *(void *)(a1 + 16) = v20;
LABEL_7:
  sub_1002F0B04(buf);
  sub_1002A775C(*(uint64_t *)buf, "MaxNumOfTiles", (_DWORD *)(a1 + 48));
  uint64_t v7 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v8 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  sub_1002F0B04(buf);
  sub_1002A7A0C(*(uint64_t *)buf, "WifiLocationSizeLimit", (void *)(a1 + 40));
  uint64_t v10 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v11 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10188FC28);
  }
  uint64_t v13 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *(void *)(a1 + 16);
    int v15 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)std::string buf = 134218240;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "tiles defaults applied, maxTileAccessAge, %.0f, maxTileCount, %du",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v16 = *(void *)(a1 + 16);
    int v17 = *(_DWORD *)(a1 + 48);
    int v21 = 134218240;
    uint64_t v22 = v16;
    __int16 v23 = 1024;
    int v24 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  2LL,  "tiles defaults applied, maxTileAccessAge, %.0f, maxTileCount, %du",  COERCE_DOUBLE(&v21),  18);
    int v19 = (char *)v18;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWifiAccessPointLocationService::processDefaultsWrites()", "%s\n", v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void sub_100F77464( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100F77488(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *a3;
  *a3 = 0LL;
  uint64_t v12 = v5;
  uint64_t v13 = v4;
  unint64_t v6 = operator new(0x168uLL);
  sub_1010DDBC0(&__p, "");
  sub_10067AE00(v6);
  uint64_t v11 = (uint64_t)v6;
  if (v15 < 0) {
    operator delete(__p);
  }
  sub_100F76994(a1, &v13, &v12, &v11);
  uint64_t v7 = v11;
  uint64_t v11 = 0LL;
  if (v7) {
    sub_100F7F68C((uint64_t)&v11, v7);
  }
  if (v12)
  {
    uint64_t v8 = (void *)sub_10052D288(v12);
    operator delete(v8);
  }

  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  if (v9) {
    sub_100F7F77C((uint64_t)&v13, v9);
  }
  return a1;
}

void sub_100F77554( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v18 = a9;
  a9 = 0LL;
  if (v18) {
    sub_100F7F68C((uint64_t)&a9, v18);
  }
  if (a10)
  {
    int v19 = (void *)sub_10052D288(a10);
    operator delete(v19);
  }

  uint64_t v20 = a11;
  a11 = 0LL;
  if (v20) {
    sub_100F7F77C((uint64_t)&a11, v20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F775CC(char *a1@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x40uLL);
  sub_1010DDBC0(v9, a1);
  LODWORD(a2) = *a2;
  sub_1010DDBC0(__p, "");
  sub_100A1F014((uint64_t)v6, (char *)v9, (_DWORD)a2 != 0, (uint64_t)__p);
  *a3 = v6;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (v10 < 0) {
    operator delete(v9[0]);
  }
}

void sub_100F77668( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  operator delete(v20);
  _Unwind_Resume(a1);
}

void sub_100F776AC(char *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  sub_1010DDBC0(&v7, a1);
  sub_1010DDBC0(&__p, "");
  sub_10052D660(v4);
  *a2 = v4;
  if (v6 < 0) {
    operator delete(__p);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
}

void sub_100F77738( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  operator delete(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7777C(uint64_t a1)
{
  unsigned __int8 v7 = 1;
  sub_100F775CC("WifiLocation", &v7, &v8);
  sub_100F776AC("WifiTileHeader", &v6);
  sub_100F77488(a1, &v8, &v6);
  uint64_t v2 = v6;
  uint64_t v6 = 0LL;
  if (v2)
  {
    int v3 = (void *)sub_10052D288(v2);
    operator delete(v3);
  }

  uint64_t v4 = v8;
  uint64_t v8 = 0LL;
  if (v4) {
    sub_100F7F77C((uint64_t)&v8, v4);
  }
  return a1;
}

void sub_100F77808( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10)
  {
    uint64_t v13 = (void *)sub_10052D288(a10);
    operator delete(v13);
  }

  uint64_t v14 = a12;
  a12 = 0LL;
  if (v14) {
    sub_100F7F77C((uint64_t)&a12, v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F77844(uint64_t a1)
{
  *(void *)a1 = off_10188FB40;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = off_10188FB98;
  uint64_t v2 = *(void **)(a1 + 160);
  if (v2)
  {

    *(void *)(a1 + 160) = 0LL;
  }

  sub_100F7F73C((void ***)(a1 + 152), 0LL);
  sub_10000AE14(a1 + 136);
  sub_1004C1CC0(a1 + 112, *(void **)(a1 + 120));
  sub_100ECC8D8((uint64_t *)(a1 + 104));
  sub_100F7F618((uint64_t **)(a1 + 96), 0LL);
  uint64_t v3 = *(void *)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  if (v3) {
    sub_100F7F77C(a1 + 88, v3);
  }
  uint64_t v4 = *(void **)(a1 + 80);
  *(void *)(a1 + sub_100F6A7D8(v1 + 80) = 0LL;
  if (v4) {
    operator delete(v4);
  }
  sub_1002E4CB0(a1 + 56);
  return a1;
}

uint64_t sub_100F778EC(uint64_t a1)
{
  return sub_100F77844(a1 - 8);
}

void sub_100F778F4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100F77844(a1);
  operator delete(v1);
}

void sub_100F77908(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100F77844(a1 - 8);
  operator delete(v1);
}

void sub_100F77920(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = a1[7];
  uint64_t v36 = a1 + 7;
  (*(void (**)(void))(v10 + 16))();
  __int16 v38 = 256;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v34 = 0LL;
  int v35 = 0LL;
  memset(v31, 0, sizeof(v31));
  int v32 = 1065353216;
  uint64_t v11 = *(void **)a2;
  uint64_t v12 = *(void **)(a2 + 8);
  if (*(void **)a2 != v12)
  {
    do
    {
      uint64_t v13 = (void **)*v11;
      uint64_t v14 = v34;
      if (v34 >= v35)
      {
        uint64_t v16 = (char *)__p;
        uint64_t v17 = (v34 - (_BYTE *)__p) >> 3;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v35 - (_BYTE *)__p;
        if ((v35 - (_BYTE *)__p) >> 2 > v18) {
          unint64_t v18 = v19 >> 2;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20)
        {
          int v21 = (char *)sub_1000071BC((uint64_t)&v35, v20);
          uint64_t v16 = (char *)__p;
          uint64_t v14 = v34;
        }

        else
        {
          int v21 = 0LL;
        }

        uint64_t v22 = &v21[8 * v17];
        *(void *)uint64_t v22 = v13;
        char v15 = v22 + 8;
        while (v14 != v16)
        {
          uint64_t v23 = *((void *)v14 - 1);
          v14 -= 8;
          *((void *)v22 - 1) = v23;
          v22 -= 8;
        }

        std::stringbuf::string_type __p = v22;
        uint64_t v34 = v15;
        int v35 = &v21[8 * v20];
        if (v16) {
          operator delete(v16);
        }
      }

      else
      {
        *(void *)uint64_t v34 = v13;
        char v15 = v14 + 8;
      }

      uint64_t v34 = v15;
      uint64_t v29 = (void **)*v11;
      sub_100BCD0E0((uint64_t)v31, &v29, &v29, (uint64_t)v11);
      v11 += 11;
    }

    while (v11 != v12);
  }

  (*(void (**)(void ***__return_ptr, void *, void **, uint64_t, double))(*a1 + 16LL))( &v29,  a1,  &__p,  a3,  a5);
  *(void *)(a4 + 16) = 0LL;
  *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)a4 = a4 + 8;
  int v24 = v29;
  if (v29 != v30)
  {
    do
    {
      unint64_t v25 = sub_100353A18(v31, v24 + 4);
      if (!v25) {
        sub_10000C918("unordered_map::at: key not found");
      }
      sub_100F7F7D8((uint64_t **)a4, v25 + 3, (uint64_t)(v25 + 3), (__int128 *)(v24 + 5));
      uint64_t v26 = v24[1];
      if (v26)
      {
        do
        {
          unint64_t v27 = (void **)v26;
          uint64_t v26 = (void *)*v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          unint64_t v27 = (void **)v24[2];
          BOOL v28 = *v27 == v24;
          int v24 = v27;
        }

        while (!v28);
      }

      int v24 = v27;
    }

    while (v27 != v30);
  }

  sub_100008390((uint64_t)&v29, v30[0]);
  sub_1002E0644((uint64_t)v31);
  if (__p)
  {
    uint64_t v34 = (char *)__p;
    operator delete(__p);
  }

  if (HIBYTE(v38))
  {
    if ((_BYTE)v38) {
      pthread_mutex_unlock(v37);
    }
    else {
      (*(void (**)(void *))(*v36 + 24LL))(v36);
    }
  }

void sub_100F77BA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, uint64_t a21, char a22)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_1011C52D0((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_100F77BFC(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  __int16 v90 = 0LL;
  uint64_t v91 = 0LL;
  double v89 = (uint64_t *)&v90;
  uint64_t v9 = *(void **)a3;
  uint64_t v8 = *(void **)(a3 + 8);
  if (*(void **)a3 != v8)
  {
    do
    {
      *(void *)std::string buf = v9;
      uint64_t v10 = sub_100F7F980(&v89, v9, (uint64_t)&unk_1012CF090, (void **)buf);
      if (*((_BYTE *)v10 + 60)) {
        *((_BYTE *)v10 + 60) = 0;
      }
      ++v9;
    }

    while (v9 != v8);
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_10188FC48);
  }
  uint64_t v11 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v12 = -1431655765 * ((unint64_t)(a2[1] - *a2) >> 4);
    *(_DWORD *)std::string buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "#tilesearch, num tiles, %{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_10188FC48);
    }
    int v65 = -1431655765 * ((unint64_t)(a2[1] - *a2) >> 4);
    LODWORD(__p) = 67240192;
    HIDWORD(__p) = v65;
    LODWORD(vsub_100F6A7D8(v1 + 80) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "#tilesearch, num tiles, %{public}d",  &__p);
    double v67 = (char *)v66;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiAccessPointLocatio nService::_searchTilesForMacs(const std::vector<TileId> &, const std::vector<CLMacAddress> &) const",  "%s\n",  v66);
    if (v67 != buf) {
      free(v67);
    }
  }

  uint64_t v13 = *a2;
  uint64_t v83 = a2[1];
  uint64_t v84 = a1;
  if (*a2 != v83)
  {
    while (1)
    {
      std::stringbuf::string_type __p = 0LL;
      uint64_t v95 = 0LL;
      unint64_t v96 = 0LL;
      char v15 = *(void **)a3;
      uint64_t v14 = *(void **)(a3 + 8);
      if (*(void **)a3 == v14) {
        goto LABEL_51;
      }
      do
      {
        uint64_t v16 = sub_1002FB09C((uint64_t)&v89, v15);
        if (&v90 == v16)
        {
          sub_10127AAE0( (uint64_t)v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v79,  v80,  v81,  v82,  v83,  v84,  (uint64_t)v85,  (uint64_t)v86,  v87,  v88,  (uint64_t)v89,  (uint64_t)v90,  v91,  v92,  *(uint64_t *)v93,  *(uint64_t *)&v93[8]);
          abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm",  201,  "_searchTilesForMacs");
          goto LABEL_84;
        }

        if (!*(_BYTE *)(sub_1002FAEF4((uint64_t)&v89, v15) + 20))
        {
          int v24 = v95;
          if ((unint64_t)v95 >= v96)
          {
            uint64_t v26 = __p;
            int64_t v27 = (v95 - (_BYTE *)__p) >> 3;
            unint64_t v28 = v27 + 1;
            uint64_t v29 = v96 - (void)__p;
            else {
              unint64_t v30 = v28;
            }
            if (v30)
            {
              __int128 v31 = (char *)sub_1000071BC((uint64_t)&v96, v30);
              uint64_t v26 = __p;
              int v24 = v95;
            }

            else
            {
              __int128 v31 = 0LL;
            }

            int v32 = &v31[8 * v27];
            *(void *)int v32 = *v15;
            unint64_t v25 = v32 + 8;
            while (v24 != v26)
            {
              uint64_t v33 = *((void *)v24 - 1);
              v24 -= 8;
              *((void *)v32 - 1) = v33;
              v32 -= 8;
            }

            std::stringbuf::string_type __p = v32;
            uint64_t v95 = v25;
            unint64_t v96 = (unint64_t)&v31[8 * v30];
            if (v26) {
              operator delete(v26);
            }
          }

          else
          {
            *(void *)uint64_t v95 = *v15;
            unint64_t v25 = v24 + 8;
          }

          uint64_t v95 = v25;
        }

        ++v15;
      }

      while (v15 != v14);
      if (__p == v95) {
        break;
      }
      uint64_t v88 = *(void *)(v13 + 4);
      unint64_t v34 = sub_100DABB14(*(uint64_t **)(v84 + 96), (int *)&v88);
      sub_100DABB30(*(uint64_t **)(v84 + 96), &__p, v34, SHIDWORD(v34), v35, &v85);
      uint64_t v36 = v85;
      __int16 v38 = __p;
      int v37 = v95;
      if (0x2E8BA2E8BA2E8BA3LL * (v86 - v85) != (v95 - (_BYTE *)__p) >> 3)
      {
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_10188FC48);
        }
        double v68 = (os_log_s *)qword_101934838;
        if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134349312;
          *(void *)&uint8_t buf[4] = (v95 - (_BYTE *)__p) >> 3;
          __int16 v98 = 2050;
          uint64_t v99 = 0x2E8BA2E8BA2E8BA3LL * (v86 - v85);
          _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_ERROR,  "expecting equal length, input, %{public}lu, output, %{public}lu",  buf,  0x16u);
        }

        uint64_t v69 = sub_1002921D0(115, 0);
        if ((_DWORD)v69)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934830 != -1) {
            dispatch_once(&qword_101934830, &stru_10188FC48);
          }
          *(_DWORD *)__int128 v93 = 134349312;
          *(void *)&v93[4] = (v95 - (_BYTE *)__p) >> 3;
          *(_WORD *)&v93[12] = 2050;
          *(void *)&v93[14] = 0x2E8BA2E8BA2E8BA3LL * (v86 - v85);
          LODWORD(vsub_100F6A7D8(v1 + 80) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  16LL,  "expecting equal length, input, %{public}lu, output, %{public}lu",  v93);
          __int16 v78 = (char *)v77;
          uint64_t v69 = sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiAccess PointLocationService::_searchTilesForMacs(const std::vector<TileId> &, const std::vector<CLMacAddress> &) const",  "%s\n",  v77);
          if (v78 != buf) {
            free(v78);
          }
        }

        sub_10127AC38( v69,  v70,  v71,  v72,  v73,  v74,  v75,  v76,  v79,  v80,  v81,  v82,  v83,  v84,  (uint64_t)v85,  (uint64_t)v86,  v87,  v88,  (uint64_t)v89,  (uint64_t)v90,  v91,  v92,  *(uint64_t *)v93,  *(uint64_t *)&v93[8]);
        abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm",  225,  "_searchTilesForMacs");
LABEL_84:
        __break(1u);
      }

      if (v95 != __p)
      {
        uint64_t v39 = 0LL;
        uint64_t v40 = 0LL;
        unint64_t v41 = 0LL;
        do
        {
          uint64_t v42 = &v85[v40];
          if (v85[v40 + 10])
          {
            *(void *)std::string buf = *(void *)v42;
            *(_WORD *)&uint8_t buf[8] = *((_WORD *)v42 + 4);
            uint64_t v43 = v88;
            *(void *)__int128 v93 = &v38[v39];
            uint64_t v44 = sub_100F7F980(&v89, &v38[v39], (uint64_t)&unk_1012CF090, (void **)v93);
            uint64_t v45 = v44 + 5;
            if (*((_BYTE *)v44 + 60))
            {
              void *v45 = *(void *)buf;
              *((_WORD *)v44 + 24) = *(_WORD *)&buf[8];
            }

            else
            {
              void *v45 = *(void *)buf;
              *((_DWORD *)v44 + 12) = *(_DWORD *)&buf[8];
              *((_BYTE *)v44 + 60) = 1;
            }

            *(void *)((char *)v44 + 52) = v43;
            __int16 v38 = __p;
            int v37 = v95;
          }

          ++v41;
          v40 += 11LL;
          v39 += 8LL;
        }

        while (v41 < (v37 - v38) >> 3);
        uint64_t v36 = v85;
        int v37 = v38;
      }

      if (v36)
      {
        __int16 v86 = v36;
        operator delete(v36);
        int v37 = __p;
      }

      if (v37)
      {
        uint64_t v95 = v37;
        operator delete(v37);
      }

      v13 += 48LL;
      if (v13 == v83) {
        goto LABEL_51;
      }
    }

    if (v95) {
      operator delete(v95);
    }
  }

void sub_100F78434( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28)
{
}

void sub_100F784BC(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v89 = a1 + 56;
  (*(void (**)(void))(v10 + 16))();
  *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  uint64_t v11 = (double *)(a4 + 8);
  __int16 v91 = 256;
  *(void *)(a4 + 16) = 0LL;
  *(void *)a4 = a4 + 8;
  if (*a2 == a2[1])
  {
LABEL_58:
    if ((_BYTE)v91) {
      pthread_mutex_unlock(v90);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v89 + 24LL))(v89);
    }
    return;
  }

  (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 32LL))(buf, a1, a2);
  sub_100008390(a4, *(void **)(a4 + 8));
  int v12 = *(void **)&buf[8];
  *(void *)a4 = *(void *)buf;
  *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 128), 8) = v12;
  uint64_t v13 = *(void *)&buf[16];
  *(void *)(a4 + 16) = *(void *)&buf[16];
  if (v13)
  {
    id v12[2] = v11;
    *(void *)std::string buf = &buf[8];
    *(void *)&uint8_t buf[8] = 0LL;
    *(void *)&uint8_t buf[16] = 0LL;
    int v12 = 0LL;
  }

  else
  {
    *(void *)a4 = v11;
  }

  sub_100008390((uint64_t)buf, v12);
  HIDWORD(v70) = *(_DWORD *)(a4 + 16);
  __int128 v14 = *(_OWORD *)(a3 + 112);
  __int128 v86 = *(_OWORD *)(a3 + 96);
  __int128 v87 = v14;
  *(_OWORD *)uint64_t v88 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)&v88[12] = *(_OWORD *)(a3 + 140);
  __int128 v15 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)&v85[32] = *(_OWORD *)(a3 + 32);
  *(_OWORD *)&v85[48] = v15;
  __int128 v16 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)&v85[64] = *(_OWORD *)(a3 + 64);
  *(_OWORD *)&v85[80] = v16;
  __int128 v17 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)uint64_t v85 = *(_OWORD *)a3;
  *(_OWORD *)&v85[16] = v17;
  double v18 = (double)((unint64_t)3600.0 >> 1);
  if (*(double *)(a3 + 20) <= 0.0 || a5 - *(double *)(a3 + 76) >= v18)
  {
    uint64_t v19 = *(double **)a4;
    if (*(double **)a4 != v11)
    {
      while (1)
      {
        if (!sub_100C3A408((uint64_t)(v19 + 5)))
        {
          double v20 = v19[9];
          if (v20 > 0.0 && a5 - a5 < v18) {
            break;
          }
        }

        uint64_t v22 = (double *)*((void *)v19 + 1);
        if (v22)
        {
          do
          {
            uint64_t v23 = v22;
            uint64_t v22 = *(double **)v22;
          }

          while (v22);
        }

        else
        {
          do
          {
            uint64_t v23 = (double *)*((void *)v19 + 2);
            _ZF = *(void *)v23 == (void)v19;
            uint64_t v19 = v23;
          }

          while (!_ZF);
        }

        uint64_t v19 = v23;
        if (v23 == v11) {
          goto LABEL_25;
        }
      }

      __int128 v25 = *((_OWORD *)v19 + 3);
      __int128 v86 = 0uLL;
      memset(v88, 0, 25);
      *(_OWORD *)&v85[4] = v25;
      *(double *)&v85[20] = v20;
      *(_OWORD *)&v85[28] = xmmword_1012EA5D0;
      __asm { FMOV            V0.2D, #-1.0 }

      *(_OWORD *)&_BYTE v85[44] = _Q0;
      *(_OWORD *)&v85[60] = _Q0;
      *(double *)&v85[76] = a5;
      *(_DWORD *)uint64_t v85 = 0xFFFF;
      *(_DWORD *)&v85[84] = 0;
      *(void *)&v85[88] = 0xBFF0000000000000LL;
      *(void *)((char *)&v87 + 4) = 0xBFF0000000000000LL;
      LODWORD(v87) = 0;
      HIDWORD(v87) = 0x7FFFFFFF;
      *(_WORD *)&v88[25] = v95;
      v88[27] = BYTE2(v95);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      a3 = qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)a3,  OS_LOG_TYPE_INFO,  "@TileSearch, wifi, use ALS results for location hint",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10188FC08);
        }
        LOWORD(v75[0]) = 0;
        LODWORD(v65) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "@TileSearch, wifi, use ALS results for location hint",  v75);
        a3 = (uint64_t)v52;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual std::map<CLMacAddress, CLWifiAPLocation> CLWifiAccessPointLocationService::findLocationsOfMacAddresses (const std::vector<CLMacAddress> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point) const",  "%s\n",  v52);
        if ((_BYTE *)a3 != buf) {
          free((void *)a3);
        }
      }
    }
  }

void sub_100F78FBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, void *__p, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

uint64_t sub_100F7907C(uint64_t a1, int *a2)
{
  uint64_t v2 = *sub_100F7FB44(a1, &v4, a2);
  if (!v2) {
    sub_10000C918("map::at:  key not found");
  }
  return v2 + 40;
}

uint64_t sub_100F790B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = sub_100BEC304(a2);
  double v7 = sub_100924308(a1);
  double v8 = sub_1007C37E8(a1);
  double v9 = v7 + (double)v6 * 0.000244140625 * v8 + v8 * 0.000244140625 * 0.5;
  unsigned int v10 = sub_100BEC2FC(a2);
  double v11 = sub_1007C37E0(a1);
  double v12 = sub_1007C37F0(a1);
  double v13 = v11 + (double)v10 * 0.000244140625 * v12 + v12 * 0.000244140625 * 0.5;
  double v14 = sub_100496E38(a1);
  unsigned int v15 = sub_100BEC2E4(a2);
  double v16 = sub_100C74FB0(v15);
  double v17 = sub_10067FEA0(a1);
  double v18 = vabdd_f64(v17, sub_100924310(a1));
  unsigned int v19 = sub_100BEC2EC(a2);
  double v20 = sub_100C74FCC(v19);
  double v21 = sub_100924318(a1);
  uint64_t v22 = sub_100BEC2F4(a2);
  uint64_t result = sub_100C39CB0(a3, v22, (int)v20, -1, 0, 64, -1, v9, v13, v14, v16, v18, v21);
  *(_BYTE *)(a3 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 1;
  return result;
}

uint64_t sub_100F79220@<X0>( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v27 = a1 + 56;
  (*(void (**)(void))(v10 + 16))();
  __int16 v29 = 256;
  a4[1] = 0LL;
  a4[2] = 0LL;
  *a4 = 0LL;
  sub_100F7C678(a4, a2[2]);
  sub_100DAB540(*(uint64_t **)(a1 + 96), (uint64_t)v26);
  double v13 = (void *)*a2;
  double v11 = a2 + 1;
  double v12 = v13;
  if (v13 != v11)
  {
    while (1)
    {
      if (*((_DWORD *)v12 + 8))
      {
        sub_10127AD90();
        abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm",  674,  "updateAccessTimestampsIfNecessary");
        __break(1u);
      }

      uint64_t v25 = *(void *)((char *)v12 + 36);
      double v14 = COERCE_DOUBLE(sub_100DABB60(*(uint64_t **)(a1 + 96), (int *)&v25));
      if (!v15) {
        break;
      }
      char v16 = sub_100DABB50(*(uint64_t **)(a1 + 96), (int *)&v25, a5);
LABEL_12:
      *(_OWORD *)std::string buf = *((_OWORD *)v12 + 2);
      uint64_t v34 = v12[6];
      if (*((char *)v12 + 79) < 0)
      {
        sub_1010DD48C(&__p, (void *)v12[7], v12[8]);
      }

      else
      {
        __int128 __p = *(_OWORD *)(v12 + 7);
        uint64_t v36 = v12[9];
      }

      char v37 = v16;
      sub_100F7C734(a4, (__int128 *)buf);
      if (SHIBYTE(v36) < 0) {
        operator delete((void *)__p);
      }
      double v18 = (void *)v12[1];
      if (v18)
      {
        do
        {
          unsigned int v19 = v18;
          double v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          unsigned int v19 = (void *)v12[2];
          BOOL v20 = *v19 == (void)v12;
          double v12 = v19;
        }

        while (!v20);
      }

      double v12 = v19;
      if (v19 == v11) {
        goto LABEL_28;
      }
    }

    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    double v17 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67174913;
      *(_DWORD *)&uint8_t buf[4] = v25;
      *(_WORD *)&uint8_t buf[8] = 1025;
      *(_DWORD *)&buf[10] = HIDWORD(v25);
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "attempted to update timestamp for tile that does not exist, x, %{private}d, y, %{private}d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      v30[0] = 67174913;
      v30[1] = v25;
      __int16 v31 = 1025;
      int v32 = HIDWORD(v25);
      LODWORD(v24) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  16LL,  "attempted to update timestamp for tile that does not exist, x, %{private}d, y, %{private}d",  v30,  v24);
      uint64_t v22 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::vector<std::pair<TileId, BOOL>> CLWifiAccessPointLocationService::updateAccessTimestampsIfNecessary(const s td::set<TileId> &, cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::seconds) const",  "%s\n",  v21);
      if (v22 != buf) {
        free(v22);
      }
    }

void sub_100F795B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t buf, __int16 a28, __int16 a29, uint64_t a30, __int16 __p_4)
{
  if (a2 == 3)
  {
    unint64_t v33 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v34 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = (*(uint64_t (**)(void *))(*(void *)v33 + 16LL))(v33);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:sqlite error updating access timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    uint64_t v36 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v37 = (*(uint64_t (**)(void *))(*(void *)v33 + 16LL))(v33);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v37;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v36,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "sqlite error updating access timestamps",  "{msg%{public}.0s:sqlite error updating access timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  else if (a2 == 2)
  {
    uint64_t v38 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v39 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v40 = (*(uint64_t (**)(void *))(*(void *)v38 + 16LL))(v38);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:no database connection while updating timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    unint64_t v41 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v42 = (*(uint64_t (**)(void *))(*(void *)v38 + 16LL))(v38);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v42;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v41,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "no database connection while updating timestamps",  "{msg%{public}.0s:no database connection while updating timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  else
  {
    if (a2 != 1)
    {
      sub_100E002BC((void ***)&buf);
      sub_1011C52D0((uint64_t)&a22);
      _Unwind_Resume(a1);
    }

    uint64_t v43 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v44 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v45 = (*(uint64_t (**)(void *))(*(void *)v43 + 16LL))(v43);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v45;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:runtime error while updating access timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    unint64_t v46 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v47 = (*(uint64_t (**)(void *))(*(void *)v43 + 16LL))(v43);
      std::string buf = 68289283LL;
      a28 = 2082;
      *(void *)(&a28 + 1) = "";
      WORD1(a30) = 2081;
      *(uint64_t *)((char *)&a30 + 4) = v47;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v46,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "runtime error while updating access timestamps",  "{msg%{public}.0s:runtime error while updating access timestamps, error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  __cxa_end_catch();
  JUMPOUT(0x100F79518LL);
}

void sub_100F79A84( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>, double a6@<D0>)
{
  uint8_t v64 = 0LL;
  uint64_t v65 = 0LL;
  int v63 = (uint64_t *)&v64;
  memset(v62, 0, sizeof(v62));
  memset(v61, 0, sizeof(v61));
  memset(v60, 0, sizeof(v60));
  sub_100F7A104(a1, (uint64_t *)v59);
  sub_100F7A17C((int *)(a1 + 72), (double **)v59, a3, buf, a6);
  __int128 v52 = (int *)(a1 + 72);
  uint64_t v56 = v62;
  uint64_t v57 = v61;
  uint64_t v58 = v60;
  sub_100F7FBC4((uint64_t **)&v56, (uint64_t)buf);
  uint64_t v56 = &v70;
  sub_100222DE8((void ***)&v56);
  uint64_t v56 = &v69;
  sub_100222DE8((void ***)&v56);
  uint64_t v56 = buf;
  sub_100222DE8((void ***)&v56);
  uint64_t v51 = a1;
  sub_100F77BFC(a1, v62, (uint64_t)a2, &v56);
  __int128 __p = 0LL;
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v12 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v13 = 0LL;
    do
    {
      double v14 = (void *)(v12 + 8 * v13);
      char v15 = (char *)v56 + 24 * v13;
      if (v15[20])
      {
        v66[0] = (uint64_t *)(v12 + 8 * v13);
        char v16 = sub_100ECD78C(&v63, v14, (uint64_t)&unk_1012CF090, v66);
        uint64_t v17 = *(void *)v15;
        v16[24] = *((_WORD *)v15 + 4);
        *((void *)v16 + 5) = v17;
        *(void *)(v16 + 26) = *(void *)(v15 + 12);
      }

      else
      {
        double v18 = v54;
        if (v54 >= v55)
        {
          BOOL v20 = (char *)__p;
          uint64_t v21 = (v54 - (_BYTE *)__p) >> 3;
          unint64_t v22 = v21 + 1;
          uint64_t v23 = v55 - (_BYTE *)__p;
          if ((v55 - (_BYTE *)__p) >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            uint64_t v25 = (char *)sub_1000071BC((uint64_t)&v55, v24);
            BOOL v20 = (char *)__p;
            double v18 = v54;
          }

          else
          {
            uint64_t v25 = 0LL;
          }

          uint64_t v26 = &v25[8 * v21];
          *(void *)uint64_t v26 = *v14;
          unsigned int v19 = v26 + 8;
          while (v18 != v20)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v26 - 1) = v27;
            v26 -= 8;
          }

          __int128 __p = v26;
          uint64_t v54 = v19;
          uint64_t v55 = &v25[8 * v24];
          if (v20) {
            operator delete(v20);
          }
        }

        else
        {
          *(void *)uint64_t v54 = *v14;
          unsigned int v19 = v18 + 8;
        }

        uint64_t v54 = v19;
      }

      ++v13;
      uint64_t v12 = *a2;
    }

    while (v13 < (a2[1] - *a2) >> 3);
  }

  uint64_t v28 = v65;
  if (a4)
  {
    __int16 v29 = v52;
    if (v65)
    {
LABEL_39:
      sub_100F7AFAC(v29, (uint64_t)"Hit");
      goto LABEL_42;
    }
  }

  else
  {
    __int16 v29 = v52;
    if (!v65)
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      uint64_t v30 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "No Mac addresses found in neighbor list, will search remaining tiles",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10188FC28);
        }
        LOWORD(v66[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "No Mac addresses found in neighbor list, will search remaining tiles",  v66,  2);
        uint64_t v50 = (uint8_t *)v49;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiAccess PointLocationService::findCentroidsInTiles(const std::vector<CLMacAddress> &, const CLDaemonLocation &, uint32 _t, cl::chrono::CFAbsoluteTimeClock::time_point) const",  "%s\n",  v49);
        if (v50 != buf) {
          free(v50);
        }
      }

      sub_100F7ADD4(v52);
      sub_100F77BFC(v51, v61, (uint64_t)&__p, (void **)buf);
      int v32 = (char *)__p;
      __int16 v31 = v54;
      if (v54 != __p)
      {
        uint64_t v33 = 0LL;
        uint64_t v34 = 0LL;
        unint64_t v35 = 0LL;
        do
        {
          uint64_t v36 = *(char **)buf;
          uint64_t v37 = (uint64_t *)(*(void *)buf + v34);
          if (*(_BYTE *)(*(void *)buf + v34 + 20))
          {
            v66[0] = (uint64_t *)&v32[v33];
            uint64_t v38 = sub_100ECD78C(&v63, &v32[v33], (uint64_t)&unk_1012CF090, v66);
            uint64_t v39 = *v37;
            v38[24] = *((_WORD *)v37 + 4);
            *((void *)v38 + 5) = v39;
            *(void *)(v38 + 26) = *(void *)&v36[v34 + 12];
            int v32 = (char *)__p;
            __int16 v31 = v54;
          }

          ++v35;
          v34 += 24LL;
          v33 += 8LL;
        }

        while (v35 < (v31 - v32) >> 3);
      }

      if (*(void *)buf)
      {
        uint64_t v68 = *(char **)buf;
        operator delete(*(void **)buf);
      }

      uint64_t v28 = v65;
    }

    if (v28) {
      goto LABEL_39;
    }
  }

  sub_100F7ADD4(v29);
LABEL_42:
  sub_100ECD714(a5, (a2[1] - *a2) >> 3);
  uint64_t v40 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v41 = 0LL;
    uint64_t v42 = 0LL;
    unint64_t v43 = 0LL;
    do
    {
      uint64_t v44 = sub_1002FB09C((uint64_t)&v63, (void *)(v40 + v41));
      if (&v64 != v44)
      {
        uint64_t v45 = v44 + 5;
        uint64_t v46 = *a5 + v42;
        if (*(_BYTE *)(v46 + 20))
        {
          uint64_t v47 = *v45;
          *(_WORD *)(v46 + _Block_object_dispose((const void *)(v1 - 128), 8) = *((_WORD *)v44 + 24);
          *(void *)uint64_t v46 = v47;
          *(void *)(v46 + 12) = *(void *)((char *)v44 + 52);
        }

        else
        {
          __int128 v48 = *(_OWORD *)v45;
          *(_DWORD *)(v46 + 16) = *((_DWORD *)v44 + 14);
          *(_OWORD *)uint64_t v46 = v48;
          *(_BYTE *)(v46 + 20) = 1;
        }
      }

      ++v43;
      uint64_t v40 = *a2;
      v42 += 24LL;
      v41 += 8LL;
    }

    while (v43 < (a2[1] - *a2) >> 3);
  }

  if (__p)
  {
    uint64_t v54 = (char *)__p;
    operator delete(__p);
  }

  if (v56)
  {
    uint64_t v57 = (uint64_t *)v56;
    operator delete(v56);
  }

  if (v59[0])
  {
    v59[1] = v59[0];
    operator delete(v59[0]);
  }

  *(void *)std::string buf = v60;
  sub_100222DE8((void ***)buf);
  *(void *)std::string buf = v61;
  sub_100222DE8((void ***)buf);
  *(void *)std::string buf = v62;
  sub_100222DE8((void ***)buf);
  sub_100008390((uint64_t)&v63, v64);
}

void sub_100F7A03C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, char a33, void *a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char *a39, uint64_t a40)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  if (a21) {
    operator delete(a21);
  }
  a39 = &a24;
  sub_100222DE8((void ***)&a39);
  a39 = &a27;
  sub_100222DE8((void ***)&a39);
  a39 = &a30;
  sub_100222DE8((void ***)&a39);
  sub_100008390((uint64_t)&a33, a34);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7A104@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = (uint64_t **)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100DAAFDC(v3[5], a2);
  return ((uint64_t (*)(uint64_t **))(*v3)[3])(v3);
}

void sub_100F7A168(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F7A17C(int *a1@<X0>, double **a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  v72[0] = 0LL;
  v72[1] = 0LL;
  uint64_t v71 = v72;
  uint64_t v10 = *a2;
  double v11 = a2[1];
  while (v10 != v11)
  {
    sub_100924340(v10, (uint64_t)buf);
    sub_100F81980((uint64_t **)&v71, (uint64_t)buf, (uint64_t)buf, (__int128 *)v10);
    if (SHIBYTE(v88) < 0) {
      operator delete((void *)__p);
    }
    v10 += 18;
  }

  uint64_t v68 = 0LL;
  unint64_t v69 = 0LL;
  unint64_t v70 = 0LL;
  uint64_t v65 = 0LL;
  unint64_t v66 = 0LL;
  unint64_t v67 = 0LL;
  uint64_t v62 = 0LL;
  unint64_t v63 = 0LL;
  unint64_t v64 = 0LL;
  v61[0] = 0LL;
  v61[1] = 0LL;
  double v12 = *(double *)(a3 + 20);
  uint64_t v60 = v61;
  if (v12 <= 0.0 || a5 - *(double *)(a3 + 76) >= (double)((unint64_t)3600.0 >> 1))
  {
    if (*a1 <= 25)
    {
      BOOL v20 = *a2;
      uint64_t v21 = a2[1];
      while (v20 != v21)
      {
        sub_100924340(v20, (uint64_t)buf);
        sub_100F7ED8C(&v65, (__int128 *)buf);
        if (SHIBYTE(v88) < 0) {
          operator delete((void *)__p);
        }
        v20 += 18;
      }
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      uint64_t v17 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "invalid location provided and complete miss, will not return any tiles to search",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10188FC28);
        }
        *(_WORD *)uint64_t v83 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "invalid location provided and complete miss, will not return any tiles to search",  v83,  2);
        uint64_t v53 = (char *)v52;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSear ch(const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)",  "%s\n",  v52);
        if (v53 != buf) {
          free(v53);
        }
      }
    }

    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    double v18 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v19 = *a1 > 25;
      *(_DWORD *)std::string buf = 134349824;
      *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - v68) >> 4);
      *(_WORD *)&_BYTE buf[12] = 2050;
      *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v66 - v65) >> 4);
      *(_WORD *)&buf[22] = 2050;
      *(void *)&__int128 __p = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - v62) >> 4);
      WORD4(__p) = 1026;
      *(_DWORD *)((char *)&__p + 10) = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, 0, completemiss, %{public}d",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      BOOL v46 = *a1 > 25;
      *(_DWORD *)uint64_t v83 = 134349824;
      *(void *)&v83[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - v68) >> 4);
      *(_WORD *)&v83[12] = 2050;
      *(void *)&v83[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v66 - v65) >> 4);
      *(_WORD *)&v83[22] = 2050;
      *(void *)&__int128 v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - v62) >> 4);
      WORD4(v84) = 1026;
      *(_DWORD *)((char *)&v84 + 10) = v46;
      LODWORD(v54) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, 0, completemiss, %{public}d",  v83,  v54);
      __int128 v48 = (char *)v47;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch (const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)",  "%s\n",  v47);
      if (v48 != buf) {
        free(v48);
      }
    }

    sub_100F7F260(a4, &v68, &v65, &v62);
  }

  else
  {
    *(_DWORD *)std::string buf = 0;
    sub_1008ACE9C((uint64_t)v83, buf);
    sub_100C11F48((uint64_t)v83, -1LL, *(double *)(a3 + 4), *(double *)(a3 + 12), 0.05, 0.05);
    if (v72 != sub_100603554((uint64_t)&v71, (uint64_t)v83))
    {
      unint64_t v13 = v69;
      if (v69 >= v70)
      {
        uint64_t v22 = sub_10022358C(&v68, (__int128 *)v83);
      }

      else
      {
        __int128 v14 = *(_OWORD *)v83;
        *(void *)(v69 + 16) = *(void *)&v83[16];
        *(_OWORD *)unint64_t v13 = v14;
        char v15 = (_BYTE *)(v13 + 24);
        if (SHIBYTE(v85) < 0)
        {
          sub_1010DD48C(v15, (void *)v84, *((unint64_t *)&v84 + 1));
        }

        else
        {
          __int128 v16 = v84;
          *(void *)(v13 + 40) = v85;
          *(_OWORD *)char v15 = v16;
        }

        uint64_t v22 = v13 + 48;
      }

      unint64_t v69 = v22;
      sub_1006036B0((uint64_t **)&v60, (uint64_t)v83, (uint64_t)v83);
    }

    __int128 v56 = *(_OWORD *)v83;
    uint64_t v57 = *(void *)&v83[16];
    if (SHIBYTE(v85) < 0)
    {
      sub_1010DD48C(&v58, (void *)v84, *((unint64_t *)&v84 + 1));
    }

    else
    {
      __int128 v58 = v84;
      uint64_t v59 = v85;
    }

    uint64_t v55 = (char **)sub_100603554((uint64_t)&v71, (uint64_t)v83);
    uint64_t v24 = 8LL;
    uint64_t v25 = &byte_10135E92D;
    do
    {
      unsigned int v26 = *v25;
      unsigned int v27 = *(v25 - 1);
      *(_OWORD *)std::string buf = v56;
      *(void *)&uint8_t buf[16] = v57;
      if (SHIBYTE(v59) < 0)
      {
        sub_1010DD48C(&__p, (void *)v58, *((unint64_t *)&v58 + 1));
      }

      else
      {
        __int128 __p = v58;
        uint64_t v88 = v59;
      }

      v23.i32[0] = 1028443341;
      sub_1008AE784((uint64_t)buf, v26, v27, 0.05, v23);
      if (v72 == sub_100603554((uint64_t)&v71, (uint64_t)buf))
      {
        unint64_t v32 = v63;
        if (v63 >= v64)
        {
          uint64_t v37 = sub_10022358C(&v62, (__int128 *)buf);
        }

        else
        {
          __int128 v33 = *(_OWORD *)buf;
          *(void *)(v63 + 16) = *(void *)&buf[16];
          *(_OWORD *)unint64_t v32 = v33;
          uint64_t v34 = (_BYTE *)(v32 + 24);
          if (SHIBYTE(v88) < 0)
          {
            sub_1010DD48C(v34, (void *)__p, *((unint64_t *)&__p + 1));
          }

          else
          {
            __int128 v35 = __p;
            *(void *)(v32 + 40) = v88;
            *(_OWORD *)uint64_t v34 = v35;
          }

          uint64_t v37 = v32 + 48;
        }

        unint64_t v63 = v37;
      }

      else if (v61 != sub_100603554((uint64_t)&v60, (uint64_t)&v56))
      {
        unint64_t v28 = v69;
        if (v69 >= v70)
        {
          uint64_t v36 = sub_10022358C(&v68, (__int128 *)buf);
        }

        else
        {
          __int128 v29 = *(_OWORD *)buf;
          *(void *)(v69 + 16) = *(void *)&buf[16];
          *(_OWORD *)unint64_t v28 = v29;
          uint64_t v30 = (_BYTE *)(v28 + 24);
          if (SHIBYTE(v88) < 0)
          {
            sub_1010DD48C(v30, (void *)__p, *((unint64_t *)&__p + 1));
          }

          else
          {
            __int128 v31 = __p;
            *(void *)(v28 + 40) = v88;
            *(_OWORD *)uint64_t v30 = v31;
          }

          uint64_t v36 = v28 + 48;
        }

        unint64_t v69 = v36;
        sub_1006036B0((uint64_t **)&v60, (uint64_t)buf, (uint64_t)buf);
      }

      if (SHIBYTE(v88) < 0) {
        operator delete((void *)__p);
      }
      v25 += 2;
      --v24;
    }

    while (v24);
    if (*a1 <= 25)
    {
      uint64_t v38 = (uint64_t *)v71;
      if (v71 != v72)
      {
        do
        {
          if (v61 == sub_100603554((uint64_t)&v60, (uint64_t)(v38 + 4)))
          {
            sub_1006036B0((uint64_t **)&v60, (uint64_t)(v38 + 4), (uint64_t)(v38 + 4));
            unint64_t v39 = v66;
            if (v66 >= v67)
            {
              uint64_t v40 = sub_10022358C(&v65, (__int128 *)v38 + 2);
            }

            else
            {
              sub_100222F00((uint64_t)&v65, (__int128 *)v38 + 2);
              uint64_t v40 = v39 + 48;
            }

            unint64_t v66 = v40;
          }

          uint64_t v41 = (char *)v38[1];
          if (v41)
          {
            do
            {
              uint64_t v42 = (char **)v41;
              uint64_t v41 = *(char **)v41;
            }

            while (v41);
          }

          else
          {
            do
            {
              uint64_t v42 = (char **)v38[2];
              BOOL v43 = *v42 == (char *)v38;
              uint64_t v38 = (uint64_t *)v42;
            }

            while (!v43);
          }

          uint64_t v38 = (uint64_t *)v42;
        }

        while (v42 != v72);
      }
    }

    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    uint64_t v44 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v45 = *a1 > 25;
      *(_DWORD *)std::string buf = 134350080;
      *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - v68) >> 4);
      *(_WORD *)&_BYTE buf[12] = 2050;
      *(void *)&buf[14] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v66 - v65) >> 4);
      *(_WORD *)&buf[22] = 2050;
      *(void *)&__int128 __p = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - v62) >> 4);
      WORD4(__p) = 1026;
      *(_DWORD *)((char *)&__p + 10) = v72 != v55;
      HIWORD(__p) = 1026;
      LODWORD(v8_Block_object_dispose((const void *)(v1 - 128), 8) = v45;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, %{public}d, completemiss, %{public}d",  buf,  0x2Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      BOOL v49 = *a1 > 25;
      int v73 = 134350080;
      unint64_t v74 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - v68) >> 4);
      __int16 v75 = 2050;
      unint64_t v76 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v66 - v65) >> 4);
      __int16 v77 = 2050;
      unint64_t v78 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - v62) >> 4);
      __int16 v79 = 1026;
      BOOL v80 = v72 != v55;
      __int16 v81 = 1026;
      BOOL v82 = v49;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, %{public}d, completemiss, %{public}d",  &v73,  44);
      uint64_t v51 = (char *)v50;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch (const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)",  "%s\n",  v50);
      if (v51 != buf) {
        free(v51);
      }
    }

    sub_100F7F260(a4, &v68, &v65, &v62);
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    if (SHIBYTE(v85) < 0) {
      operator delete((void *)v84);
    }
  }

  sub_100603B94((uint64_t)&v60, v61[0]);
  *(void *)std::string buf = &v62;
  sub_100222DE8((void ***)buf);
  *(void *)std::string buf = &v65;
  sub_100222DE8((void ***)buf);
  *(void *)std::string buf = &v68;
  sub_100222DE8((void ***)buf);
  sub_100603B94((uint64_t)&v71, v72[0]);
}

void sub_100F7AC58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, char a23, char *a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, char a35, char *a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, int a49, __int16 a50,char a51,char a52,char *a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  a53 = &a26;
  sub_100222DE8((void ***)&a53);
  a53 = &a29;
  sub_100222DE8((void ***)&a53);
  a53 = &a32;
  sub_100222DE8((void ***)&a53);
  sub_100603B94((uint64_t)&a35, a36);
  _Unwind_Resume(a1);
}

void **sub_100F7AD80(void **a1)
{
  uint64_t v3 = a1 + 6;
  sub_100222DE8(&v3);
  uint64_t v3 = a1 + 3;
  sub_100222DE8(&v3);
  uint64_t v3 = a1;
  sub_100222DE8(&v3);
  return a1;
}

void sub_100F7ADD4(int *a1)
{
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188FC08);
  }
  uint64_t v2 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
  {
    int v3 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "@TileSearch, wifi, misscount, %{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    int v4 = *a1;
    v7[0] = 67240192;
    v7[1] = v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "@TileSearch, wifi, misscount, %{public}d",  v7,  8);
    unsigned int v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWifiTileQueryLogic::incrementScanMisses()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  if (*a1 >= 255) {
    sub_100F7AFAC(a1, (uint64_t)"Rollover");
  }
}

void sub_100F7AFAC(_DWORD *a1, uint64_t a2)
{
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_10188FC08);
  }
  int v4 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v9 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "@TileSearch, wifi, missreset, %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    int v6 = 136446210;
    uint64_t v7 = a2;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  1LL,  "@TileSearch, wifi, missreset, %{public}s",  &v6,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWifiTileQueryLogic::resetScanMisses(const char *)", "%s\n", v5);
  }

  *a1 = 0;
}

void sub_100F7B15C( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>, double a6@<D0>)
{
}

void sub_100F7B164(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = a1 + 56;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v16 = a1 + 56;
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 56);
  __int16 v18 = 256;
  sub_100A1F020(*(void *)(v7 + 32), a2, (uint64_t)&v14);
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)a3 = a3 + 8;
  double v8 = v14;
  if (v14 != v15)
  {
    do
    {
      sub_100F7B2D4((uint64_t)(v8 + 5), (uint64_t)v13);
      sub_1002FAF5C((uint64_t **)a3, v8 + 4, v8 + 4, v13);
      uint64_t v9 = (void *)v8[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = (void **)v9;
          uint64_t v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          uint64_t v10 = (void **)v8[2];
          BOOL v11 = *v10 == v8;
          double v8 = v10;
        }

        while (!v11);
      }

      double v8 = v10;
    }

    while (v10 != v15);
  }

  uint64_t v12 = *(void *)(a1 + 152);
  if (v12) {
    sub_1002FABE0(v12, (void *)a3);
  }
  sub_100008390((uint64_t)&v14, v15[0]);
  if (HIBYTE(v18))
  {
    if ((_BYTE)v18) {
      pthread_mutex_unlock(v17);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v16 + 24LL))(v16);
    }
  }

void sub_100F7B298( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, void *a22)
{
}

uint64_t sub_100F7B2D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_100C39CB0( a2,  *(void *)a1,  *(_DWORD *)(a1 + 172),  *(_DWORD *)(a1 + 168),  *(_DWORD *)(a1 + 180),  *(_DWORD *)(a1 + 164),  *(_DWORD *)(a1 + 184),  *(double *)(a1 + 12),  *(double *)(a1 + 20),  *(double *)(a1 + 36),  *(double *)(a1 + 28),  *(double *)(a1 + 44),  *(double *)(a1 + 84));
  *(_BYTE *)(a2 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  return result;
}

uint64_t sub_100F7B324@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v7 = a1 + 56;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v18 = a1 + 56;
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 56);
  __int16 v19 = 256;
  uint64_t v10 = *(void *)(a1 + 120);
  uint64_t v9 = a1 + 120;
  uint64_t v8 = v10;
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = v9;
  do
  {
    int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      __int128 v14 = (uint64_t *)v8;
    }
    else {
      __int128 v14 = (uint64_t *)(v8 + 8);
    }
    if (!v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }

  while (*v14);
  if (v11 != v9 && *(_DWORD *)(v11 + 32) <= a2)
  {
    __int128 v16 = 0uLL;
    uint64_t v17 = 0LL;
    sub_10001B72C( &v16,  *(const void **)(v11 + 40),  *(void *)(v11 + 48),  (uint64_t)(*(void *)(v11 + 48) - *(void *)(v11 + 40)) >> 2);
    *(_OWORD *)a3 = v16;
    *(void *)(a3 + 16) = v17;
    *(_BYTE *)(a3 + 24) = 1;
  }

  else
  {
LABEL_11:
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 24) = 0;
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
}

void sub_100F7B404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F7B41C@<X0>( uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, char **a5@<X8>, double a6@<D0>, double a7@<D1>, double a8@<D2>, double a9@<D3>)
{
  uint64_t v17 = (uint64_t *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100A1F018(v17[4], a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(uint64_t (**)(uint64_t *))(*v17 + 24))(v17);
}

void sub_100F7B4D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7B4EC(uint64_t a1, uint64_t *a2, int **a3, int a4, double a5)
{
  int v71 = a4;
  if (a3[1] == *a3) {
    sub_10127AEEC();
  }
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v68 = a1 + 56;
  (*(void (**)(void))(v9 + 16))();
  __int16 v70 = 256;
  __int128 __p = 0LL;
  unint64_t v66 = 0LL;
  unint64_t v67 = 0LL;
  uint64_t v10 = *a2;
  uint64_t v11 = a2[1];
  if (*a2 == v11)
  {
    uint64_t v22 = 0LL;
  }

  else
  {
    int v12 = 0LL;
    do
    {
      if (v12 >= v67)
      {
        BOOL v13 = (char *)__p;
        uint64_t v14 = (v12 - (_BYTE *)__p) >> 2;
        unint64_t v15 = v14 + 1;
        uint64_t v16 = v67 - (_BYTE *)__p;
        if ((v67 - (_BYTE *)__p) >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)sub_10000956C((uint64_t)&v67, v17);
          BOOL v13 = (char *)__p;
          int v12 = (char *)v66;
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        __int16 v19 = &v18[4 * v14];
        *(_DWORD *)__int16 v19 = *(_DWORD *)(v10 + 160);
        BOOL v20 = (int *)(v19 + 4);
        while (v12 != v13)
        {
          int v21 = *((_DWORD *)v12 - 1);
          v12 -= 4;
          *((_DWORD *)v19 - 1) = v21;
          v19 -= 4;
        }

        __int128 __p = v19;
        unint64_t v66 = v20;
        unint64_t v67 = &v18[4 * v17];
        if (v13) {
          operator delete(v13);
        }
        int v12 = (char *)v20;
      }

      else
      {
        *(_DWORD *)int v12 = *(_DWORD *)(v10 + 160);
        v12 += 4;
      }

      unint64_t v66 = (int *)v12;
      v10 += 184LL;
    }

    while (v10 != v11);
    uint64_t v22 = (int *)__p;
    if (__p == v12)
    {
LABEL_34:
      uint64_t v22 = (int *)v12;
    }

    else
    {
      int v23 = v71;
      if ((v71 - 1) <= 2)
      {
        while (1)
        {
          int v24 = *v22;
          if (v23 == 3)
          {
            if (v24 < 1) {
              break;
            }
          }

          else if (v23 == 1)
          {
            if (v24 < 1 || !sub_10099EDC8(v24)) {
              break;
            }
          }

          else if (v24 <= 0 || sub_10099EDC8(v24))
          {
            break;
          }
        }
      }

      if (v22 != (int *)v12)
      {
        for (uint64_t i = v22 + 1; ; ++i)
        {
          int v51 = *i;
          if (v23 == 3) {
            break;
          }
          if (v23 == 2)
          {
            if (v51 > 0 && !sub_10099EDC8(v51)) {
              goto LABEL_75;
            }
          }

          else if (v23 == 1 && v51 >= 1 && sub_10099EDC8(v51))
          {
            goto LABEL_75;
          }

#error "100F7BEAC: call analysis failed (funcsize=109)"
uint64_t sub_100F7BF04@<X0>(uint64_t a1@<X0>, const std::string *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  id v14[2];
  void v15[5];
  uint64_t v16[2];
  uint64_t v17;
  pthread_mutex_t *v18;
  __int16 v19;
  _OWORD v20[102];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v17 = a1 + 56;
  (*(void (**)(void))(v8 + 16))();
  __int16 v19 = 256;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_100F7C53C;
  v15[3] = &unk_101862770;
  *(double *)&v15[4] = a4;
  v16[0] = mach_absolute_time();
  v16[1] = (uint64_t)v15;
  sub_100222B94(v14, (uint64_t)"upgrade-wifi-tiles-schema", 0);
  sub_100DAB764(*(uint64_t **)(a1 + 96), a2, v20, a4);
  sub_100F7AFAC((_DWORD *)(a1 + 72), (uint64_t)"NewTile");
  sub_100ECD548((void *)(a1 + 104));
  uint64_t v9 = v20[7];
  *(_OWORD *)(a3 + 96) = v20[6];
  *(_OWORD *)(a3 + 112) = v9;
  *(_OWORD *)(a3 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v20[8];
  uint64_t v10 = v20[3];
  *(_OWORD *)(a3 + 32) = v20[2];
  *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v10;
  uint64_t v11 = v20[5];
  *(_OWORD *)(a3 + 64) = v20[4];
  *(_OWORD *)(a3 + sub_100F6A7D8(v1 + 80) = v11;
  int v12 = v20[1];
  *(_OWORD *)a3 = v20[0];
  *(_OWORD *)(a3 + 16) = v12;
  *(_BYTE *)(a3 + 144) = 1;
  sub_1001BA1BC(v14);
  sub_1011F6BE4(v16);
  if ((_BYTE)v19) {
    return pthread_mutex_unlock(v18);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(*(void *)v17 + 24LL))(v17);
  }
}

void sub_100F7C070( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7C53C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6 = sub_101171C7C(a3 - a2);
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10188FC28);
  }
  uint64_t v7 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    v9[0] = 68290306;
    v9[1] = 0;
    __int16 v10 = 2082;
    uint64_t v11 = "";
    __int16 v12 = 2082;
    BOOL v13 = "elapsed";
    __int16 v14 = 2050;
    uint64_t v15 = a2;
    __int16 v16 = 2050;
    uint64_t v17 = a3;
    __int16 v18 = 2050;
    double v19 = v6;
    __int16 v20 = 2050;
    uint64_t v21 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CLWifiAccessPointLocationService::saveWifiTileAccessPointEntries, event:%{public, loc ation:escape_only}s, begin_mach:%{public}llu, end_mach:%{public}llu, elapsed_s:%{public}.09f, no w_s:%{public}.09f}",  (uint8_t *)v9,  0x44u);
  }

uint64_t sub_100F7C670(uint64_t a1, uint64_t a2)
{
  return sub_100DAAFEC(*(uint64_t **)(a1 + 96), a2);
}

uint64_t sub_100F7C678(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7LL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493LL) {
      sub_100007008();
    }
    uint64_t v5 = a1[1] - *a1;
    _DWORD v7[4] = result;
    v7[0] = sub_1000AC8F0(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 56 * v6;
    sub_100F7FC90(a1, v7);
    return sub_100F7FE38((uint64_t)v7);
  }

  return result;
}

void sub_100F7C720(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7C734(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v11 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v12 = v11 + 1;
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x249249249249249LL) {
      unint64_t v14 = 0x492492492492492LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v21[4] = v4;
    uint64_t v15 = (char *)sub_1000AC8F0(v4, v14);
    __int16 v16 = &v15[56 * v11];
    v21[0] = v15;
    v21[1] = v16;
    v21[3] = &v15[56 * v17];
    uint64_t v18 = *((void *)a2 + 2);
    *(_OWORD *)__int16 v16 = *a2;
    *((void *)v16 + 2) = v18;
    uint64_t v19 = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = v19;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    v16[48] = *((_BYTE *)a2 + 48);
    id v21[2] = v16 + 56;
    sub_100F7FC90(a1, v21);
    uint64_t v10 = a1[1];
    sub_100F7FE38((uint64_t)v21);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    *(_BYTE *)(v7 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = *((_BYTE *)a2 + 48);
    uint64_t v10 = v7 + 56;
    a1[1] = v7 + 56;
  }

  a1[1] = v10;
  return v10 - 56;
}

void sub_100F7C898(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F7C8AC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>, double a5@<D0>)
{
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v65 = a1 + 56;
  (*(void (**)(void))(v10 + 16))();
  __int16 v67 = 256;
  sub_100F7A104(a1, (uint64_t *)v64);
  sub_100F7A17C((int *)(a1 + 72), v64, a2, v61, a5);
  sub_100F7FEC0((uint64_t)v60, v61[0], v61[1]);
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  sub_100F79220(a1, v60, a3, &v58, a5);
  uint64_t v11 = v58;
  for (uint64_t i = v59; v11 != i; v11 += 56LL)
  {
    __int128 v13 = *(_OWORD *)v11;
    uint64_t v55 = *(void *)(v11 + 16);
    __int128 v54 = v13;
    if (*(char *)(v11 + 47) < 0)
    {
      sub_1010DD48C(&__p, *(void **)(v11 + 24), *(void *)(v11 + 32));
    }

    else
    {
      __int128 v14 = *(_OWORD *)(v11 + 24);
      uint64_t v57 = *(void *)(v11 + 40);
      __int128 __p = v14;
    }

    if (*(_BYTE *)(v11 + 48))
    {
      sub_100F7CCB4(a1, (uint64_t)&v54, (uint64_t)&v45);
      __int16 v16 = a4[1];
      unint64_t v15 = (unint64_t)a4[2];
      if ((unint64_t)v16 >= v15)
      {
        int v24 = *a4;
        unint64_t v25 = 0x8E38E38E38E38E39LL * ((v16 - *a4) >> 4);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x1C71C71C71C71C7LL) {
          sub_100007008();
        }
        unint64_t v27 = 0x8E38E38E38E38E39LL * ((uint64_t)(v15 - (void)v24) >> 4);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0xE38E38E38E38E3LL) {
          unint64_t v28 = 0x1C71C71C71C71C7LL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          __int128 v29 = (char *)sub_1002B4F00((uint64_t)(a4 + 2), v28);
          int v24 = *a4;
          __int16 v16 = a4[1];
        }

        else
        {
          __int128 v29 = 0LL;
        }

        uint64_t v30 = &v29[144 * v25];
        *(_OWORD *)uint64_t v30 = v45;
        __int128 v31 = v46;
        __int128 v32 = v47;
        __int128 v33 = v49;
        *((_OWORD *)v30 + 3) = v48;
        *((_OWORD *)v30 + 4) = v33;
        *((_OWORD *)v30 + 1) = v31;
        *((_OWORD *)v30 + 2) = v32;
        __int128 v34 = v50;
        __int128 v35 = v51;
        __int128 v36 = v53;
        *((_OWORD *)v30 + 7) = v52;
        *((_OWORD *)v30 + _Block_object_dispose((const void *)(v1 - 128), 8) = v36;
        *((_OWORD *)v30 + 5) = v34;
        *((_OWORD *)v30 + 6) = v35;
        if (v16 == v24)
        {
          uint64_t v44 = &v29[144 * v25];
        }

        else
        {
          __int128 v37 = &v29[144 * v25];
          do
          {
            *((_OWORD *)v37 - 9) = *((_OWORD *)v16 - 9);
            __int128 v38 = *((_OWORD *)v16 - 8);
            __int128 v39 = *((_OWORD *)v16 - 7);
            __int128 v40 = *((_OWORD *)v16 - 5);
            *((_OWORD *)v37 - 6) = *((_OWORD *)v16 - 6);
            *((_OWORD *)v37 - 5) = v40;
            *((_OWORD *)v37 - _Block_object_dispose((const void *)(v1 - 128), 8) = v38;
            *((_OWORD *)v37 - 7) = v39;
            __int128 v41 = *((_OWORD *)v16 - 4);
            __int128 v42 = *((_OWORD *)v16 - 3);
            __int128 v43 = *((_OWORD *)v16 - 2);
            uint64_t v44 = v37 - 144;
            *(_OWORD *)(v37 - 20) = *(_OWORD *)(v16 - 20);
            *((_OWORD *)v37 - 3) = v42;
            *((_OWORD *)v37 - 2) = v43;
            *((_OWORD *)v37 - 4) = v41;
            v16 -= 144;
            v37 -= 144;
          }

          while (v16 != v24);
        }

        int v23 = v30 + 144;
        *a4 = v44;
        a4[1] = v30 + 144;
        a4[2] = &v29[144 * v28];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        *(_OWORD *)__int16 v16 = v45;
        __int128 v17 = v46;
        __int128 v18 = v47;
        __int128 v19 = v49;
        *((_OWORD *)v16 + 3) = v48;
        *((_OWORD *)v16 + 4) = v19;
        *((_OWORD *)v16 + 1) = v17;
        *((_OWORD *)v16 + 2) = v18;
        __int128 v20 = v50;
        __int128 v21 = v51;
        __int128 v22 = v53;
        *((_OWORD *)v16 + 7) = v52;
        *((_OWORD *)v16 + _Block_object_dispose((const void *)(v1 - 128), 8) = v22;
        *((_OWORD *)v16 + 5) = v20;
        *((_OWORD *)v16 + 6) = v21;
        int v23 = v16 + 144;
      }

      a4[1] = v23;
    }

    if (SHIBYTE(v57) < 0) {
      operator delete((void *)__p);
    }
  }

  *(void *)&__int128 v45 = &v58;
  sub_100E002BC((void ***)&v45);
  sub_100603B94((uint64_t)v60, (char *)v60[1]);
  *(void *)&__int128 v45 = &v63;
  sub_100222DE8((void ***)&v45);
  *(void *)&__int128 v45 = &v62;
  sub_100222DE8((void ***)&v45);
  *(void *)&__int128 v45 = v61;
  sub_100222DE8((void ***)&v45);
  if (v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }

  if (HIBYTE(v67))
  {
    if ((_BYTE)v67) {
      pthread_mutex_unlock(v66);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v65 + 24LL))(v65);
    }
  }

void sub_100F7CC20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *__p, uint64_t a33, int a34, __int16 a35, char a36, char a37, char a38, uint64_t a39, uint64_t a40, char a41, char *a42)
{
  __int128 v45 = *(void **)v42;
  if (*(void *)v42)
  {
    *(void *)(v42 + _Block_object_dispose((const void *)(v1 - 128), 8) = v45;
    operator delete(v45);
  }

  sub_100603B94((uint64_t)&a41, a42);
  sub_100F7AD80((void **)(v43 - 224));
  __int128 v46 = *(void **)(v43 - 152);
  if (v46)
  {
    *(void *)(v43 - 144) = v46;
    operator delete(v46);
  }

  sub_1011C52D0(v43 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7CCB4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t **)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 56);
  v8[1] = a1 + 56;
  (*(void (**)(uint64_t))(v5 + 16))(a1 + 56);
  __int16 v9 = 256;
  v8[0] = *(void *)(a2 + 4);
  sub_100DABB40(v6[5], (int *)v8, a3);
  return ((uint64_t (*)(uint64_t **))(*v6)[3])(v6);
}

void sub_100F7CD30(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F7CD44(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v7 = a1 + 56;
  uint64_t v6 = *(void *)(a1 + 56);
  v8[1] = a1 + 56;
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 56);
  __int16 v9 = 256;
  if (*(_DWORD *)a2)
  {
    sub_10127AD90();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm",  731,  "updateGizmoSyncTimestampForTile");
    __break(1u);
  }

  else
  {
    v8[0] = *(void *)(a2 + 4);
    sub_100DABB58(*(uint64_t **)(a1 + 96), (int *)v8, a3);
    (*(void (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
  }

void sub_100F7CE10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

BOOL sub_100F7CE28(uint64_t a1, uint64_t a2)
{
  int v3 = (uint64_t *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  BOOL v4 = sub_100A1F14C(v3[4], a2);
  (*(void (**)(uint64_t *))(*v3 + 24))(v3);
  return v4;
}

void sub_100F7CE94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7CEA8(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100A1F1B4(v1[4]);
  return (*(uint64_t (**)(uint64_t *))(*v1 + 24))(v1);
}

void sub_100F7CF04(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7CF18(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100A1F174(v1[4]);
  return (*(uint64_t (**)(uint64_t *))(*v1 + 24))(v1);
}

void sub_100F7CF74(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F7CF88(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  if (v1) {
    sub_10067B52C(v1);
  }
}

uint64_t sub_100F7CF98(uint64_t a1, double a2)
{
  int v3 = (uint64_t *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100A1F180(v3[4], a2);
  return (*(uint64_t (**)(uint64_t *))(*v3 + 24))(v3);
}

void sub_100F7D004(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7D018(uint64_t a1, double *a2)
{
  uint64_t v5 = a1 + 56;
  uint64_t v4 = *(void *)(a1 + 56);
  v12[1] = a1 + 56;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 56);
  __int16 v13 = 256;
  v12[0] = sub_100DAAC24(a2);
  sub_100DABB40(*(uint64_t **)(a1 + 96), (int *)v12, (uint64_t)v11);
  if (v11[144])
  {
    uint64_t v6 = sub_100207690((uint64_t)v11);
  }

  else
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v7 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 67174913;
      int v18 = v12[0];
      __int16 v19 = 1025;
      int v20 = HIDWORD(v12[0]);
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#warning, tile does not exists to query num inputs, x, %{private}d, y, %{private}d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      v14[0] = 67174913;
      v14[1] = v12[0];
      __int16 v15 = 1025;
      int v16 = HIDWORD(v12[0]);
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  2LL,  "#warning, tile does not exists to query num inputs, x, %{private}d, y, %{private}d",  v14,  14);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLWifiAccessPointLocationService::numberOfInputApsUsedInWifiTileForCoordinate(const CLClientLocationCoordinate &) const",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint64_t v6 = 0xFFFFFFFFLL;
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v6;
}

void sub_100F7D254( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
}

uint64_t sub_100F7D280@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string::size_type *a3@<X8>)
{
  uint64_t v7 = (uint64_t **)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 56);
  v12[1] = a1 + 56;
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 56);
  __int16 v13 = 256;
  v12[0] = 0LL;
  uint64_t v11 = *(void *)(a2 + 4);
  sub_100DABB40(v7[5], (int *)&v11, (uint64_t)v10);
  if (v10[144])
  {
    sub_100DABB68(*(uint64_t **)(a1 + 96), (int *)&v11, a3);
    __int128 v8 = (void **)v12[0];
    v12[0] = 0LL;
    if (v8) {
      sub_100223734((int)v12, v8);
    }
  }

  else
  {
    *a3 = v12[0];
  }

  return ((uint64_t (*)(uint64_t **))(*v7)[3])(v7);
}

void sub_100F7D340(_Unwind_Exception *a1)
{
  int v3 = *(void ***)(v1 - 64);
  *(void *)(v1 - 64) = 0LL;
  if (v3) {
    sub_100223734(v1 - 64, v3);
  }
  sub_1011C52D0(v1 - 56);
  _Unwind_Resume(a1);
}

void sub_100F7D368(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 80);
  if (v1)
  {
    sub_1003CF5B4(v1);
  }

  else
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_10188FC08);
    }
    uint64_t v2 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "fWifiApLocationLookupMetrics is null.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      v4[0] = 0;
      int v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  17LL,  "fWifiApLocationLookupMetrics is null.",  v4,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWifiAccessPointLocationService::submitWifiApLocationLookupMetrics() const",  "%s\n",  v3);
    }
  }

uint64_t sub_100F7D520(uint64_t a1, uint64_t a2)
{
  int v3 = (_DWORD *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)(a1 + 56) + 16LL))(a1 + 56);
  sub_100F7AFAC(v3 + 4, a2);
  return (*(uint64_t (**)(_DWORD *))(*(void *)v3 + 24LL))(v3);
}

void sub_100F7D584(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7D598(uint64_t a1)
{
  int v3 = (uint64_t **)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v9 = a1 + 56;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 56);
  __int16 v10 = 256;
  sub_100DAACD4(v3[5]);
  if ((sub_100DABB38(*(uint64_t **)(a1 + 96)) & 1) != 0)
  {
    sub_100F7D7A0(a1);
  }

  else
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v4 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "failed to establish a valid database connection, expect wifi positioning accuracy to be significantly degraded",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      __int16 v8 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  16LL,  "failed to establish a valid database connection, expect wifi positioning accuracy to be significantly degraded",  &v8,  2);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWifiAccessPointLocationService::establishWifiTileDatabaseConnectionsIfNecessary()",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  return ((uint64_t (*)(uint64_t **))(*v3)[3])(v3);
}

void sub_100F7D778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F7D7A0(uint64_t a1)
{
  uint64_t v6 = a1 + 56;
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v30 = a1 + 56;
  (*(void (**)(uint64_t))(v5 + 16))(a1 + 56);
  LOWORD(v32) = 256;
  if (*(_BYTE *)(v6 - 3)) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  }
  uint64_t v7 = sub_100DABB38(*(uint64_t **)(a1 + 96));
  if ((v7 & 1) == 0)
  {
    sub_10127B130( v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  buf,  v34,  *((uint64_t *)&v34 + 1),  v35,  v36,  v37,  v38,  v39);
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm",  888,  "dropTilesIfWifiTilesHeaderSchemaChanged");
    __break(1u);
    goto LABEL_24;
  }

  uint64_t v1 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "upgrade-wifi-tiles-schema");
  int v2 = sub_100DABB48(*(uint64_t **)(a1 + 96));
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934860 != -1) {
LABEL_24:
  }
    dispatch_once(&qword_101934860, &stru_10188FC28);
  __int16 v15 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "unconditionally removing all #tile tables in favor of new schema",  (uint8_t *)&buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    LOWORD(v29) = 0;
    LODWORD(v26) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "unconditionally removing all #tile tables in favor of new schema",  &v29,  v26);
    __int128 v22 = (uint64_t *)v21;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAccessPointLocationService::dropTilesIfWifiTilesHeaderSchemaChanged()",  "%s\n",  v21);
    if (v22 != &buf) {
      free(v22);
    }
  }

  if ((int)sub_100DAAFE4(*(uint64_t **)(a1 + 96)) >= 1)
  {
    int v16 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Detected that we had legacy tile tables. Unconditionally dropping all tile headers as well",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      LOWORD(v29) = 0;
      LODWORD(v26) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "Detected that we had legacy tile tables. Unconditionally dropping all tile headers as well",  &v29,  v26);
      int v24 = (uint64_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAccessPointLocationService::dropTilesIfWifiTilesHeaderSchemaChanged()",  "%s\n",  v23);
      if (v24 != &buf) {
        free(v24);
      }
    }

    int v17 = sub_100DAACDC(*(uint64_t **)(a1 + 96));
    if (v17 != v2)
    {
      int v18 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
      {
        uint64_t buf = 68289538LL;
        LOWORD(v34) = 2082;
        *(void *)((char *)&v34 + 2) = "";
        WORD5(v34) = 1026;
        HIDWORD(v34) = v2;
        LOWORD(v35) = 1026;
        *(_DWORD *)((char *)&v35 + 2) = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:@TileHeader, wifi, failed to remove some headers, existing:%{public}d, removed:%{public}d}",  (uint8_t *)&buf,  0x1Eu);
      }

      __int16 v19 = (os_log_s *)qword_101934868;
      if (os_signpost_enabled((os_log_t)qword_101934868))
      {
        uint64_t buf = 68289538LL;
        LOWORD(v34) = 2082;
        *(void *)((char *)&v34 + 2) = "";
        WORD5(v34) = 1026;
        HIDWORD(v34) = v2;
        LOWORD(v35) = 1026;
        *(_DWORD *)((char *)&v35 + 2) = v17;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "@TileHeader, wifi, failed to remove some headers",  "{msg%{public}.0s:@TileHeader, wifi, failed to remove some headers, existing:%{public}d, removed:%{public}d}",  (uint8_t *)&buf,  0x1Eu);
      }
    }
  }

  *(_BYTE *)(a1 + 53) = 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
}

void sub_100F7DC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_100F7DCB0(uint64_t a1)
{
  uint64_t v3 = a1 + 56;
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v12 = a1 + 56;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 56);
  __int16 v14 = 256;
  sub_100DAB540(*(uint64_t **)(v3 + 40), (uint64_t)v11);
  unsigned int v4 = sub_100DAACDC(*(uint64_t **)(a1 + 96));
  uint64_t v5 = sub_100A1F6A0(*(void *)(a1 + 88));
  if ((_DWORD)v5)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v6 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67174657;
      int v17 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "remaining entries in als db, deleting, %{private}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
      v15[0] = 67174657;
      v15[1] = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "remaining entries in als db, deleting, %{private}d",  v15,  8);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<int, int> CLWifiAccessPointLocationService::errorOnRemainingAndDelete()",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    sub_100A1F174(*(void *)(a1 + 88));
  }

  sub_100A112B4(v11);
  uint64_t v7 = v5 << 32;
  if (HIBYTE(v14))
  {
    if ((_BYTE)v14) {
      pthread_mutex_unlock(v13);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v12 + 24LL))(v12);
    }
  }

  return v7 | v4;
}

void sub_100F7DEF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, int buf, int a22, __int128 a23)
{
  if (a2 == 3)
  {
    uint8_t v25 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v26 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = (*(uint64_t (**)(void *))(*(void *)v25 + 16LL))(v25);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:sqlite error deleting remaining tiles., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    uint64_t v28 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v29 = (*(uint64_t (**)(void *))(*(void *)v25 + 16LL))(v25);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v29;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "sqlite error deleting remaining tiles.",  "{msg%{public}.0s:sqlite error deleting remaining tiles., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  else if (a2 == 2)
  {
    uint64_t v30 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v31 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v32 = (*(uint64_t (**)(void *))(*(void *)v30 + 16LL))(v30);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:no database connection., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    __int128 v33 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v34 = (*(uint64_t (**)(void *))(*(void *)v30 + 16LL))(v30);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v34;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v33,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "no database connection.",  "{msg%{public}.0s:no database connection., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  else
  {
    if (a2 != 1)
    {
      sub_1011C52D0((uint64_t)&a16);
      _Unwind_Resume(a1);
    }

    uint64_t v35 = __cxa_begin_catch(a1);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10188FC28);
    }
    uint64_t v36 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
    {
      uint64_t v37 = (*(uint64_t (**)(void *))(*(void *)v35 + 16LL))(v35);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:runtime error deleting tile., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10188FC28);
      }
    }

    uint64_t v38 = (os_log_s *)qword_101934868;
    if (os_signpost_enabled((os_log_t)qword_101934868))
    {
      uint64_t v39 = (*(uint64_t (**)(void *))(*(void *)v35 + 16LL))(v35);
      uint64_t buf = 68289283;
      a22 = 0;
      LOWORD(a23) = 2082;
      *(void *)((char *)&a23 + 2) = "";
      WORD5(a23) = 2081;
      *(void *)((char *)&a23 + 12) = v39;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v38,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "runtime error deleting tile.",  "{msg%{public}.0s:runtime error deleting tile., error:%{private, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  __cxa_end_catch();
  JUMPOUT(0x100F7DDACLL);
}

void sub_100F7E394(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  __int128 __p = 0LL;
  __int16 v120 = 0LL;
  unint64_t v121 = 0LL;
  uint64_t v6 = (char *)v122;
  uint64_t v7 = v123;
  if (v122 != v123)
  {
    while (*(double *)(a1 + 16) >= vabdd_f64(a3, sub_100924330((uint64_t)v6)))
    {
      v6 += 144;
      if (v6 == v7)
      {
        uint64_t v6 = v7;
        goto LABEL_38;
      }
    }

    unint64_t v8 = 0x8E38E38E38E38E39LL * ((v120 - (_BYTE *)__p) >> 4) + 1;
    if (v8 > 0x1C71C71C71C71C7LL) {
LABEL_102:
    }
      sub_100007008();
    else {
      unint64_t v9 = v8;
    }
    if (v9) {
      uint64_t v10 = (char *)sub_1002B4F00((uint64_t)&v121, v9);
    }
    else {
      uint64_t v10 = 0LL;
    }
    uint64_t v11 = &v10[16 * ((v120 - (_BYTE *)__p) >> 4)];
    *(_OWORD *)uint64_t v11 = *(_OWORD *)v6;
    __int128 v12 = *((_OWORD *)v6 + 1);
    __int128 v13 = *((_OWORD *)v6 + 2);
    __int128 v14 = *((_OWORD *)v6 + 4);
    *((_OWORD *)v11 + 3) = *((_OWORD *)v6 + 3);
    *((_OWORD *)v11 + 4) = v14;
    *((_OWORD *)v11 + 1) = v12;
    *((_OWORD *)v11 + 2) = v13;
    __int128 v15 = *((_OWORD *)v6 + 5);
    __int128 v16 = *((_OWORD *)v6 + 6);
    __int128 v17 = *((_OWORD *)v6 + 8);
    *((_OWORD *)v11 + 7) = *((_OWORD *)v6 + 7);
    *((_OWORD *)v11 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
    *((_OWORD *)v11 + 5) = v15;
    *((_OWORD *)v11 + 6) = v16;
    __int128 __p = v11;
    unint64_t v121 = (unint64_t)&v10[144 * v9];
    __int16 v120 = v11 + 144;
    if (v6 != v7)
    {
      int v18 = v6 + 144;
      if (v6 + 144 != v7)
      {
        do
        {
          if (*(double *)(a1 + 16) >= vabdd_f64(a3, sub_100924330((uint64_t)v18)))
          {
            *(_OWORD *)uint64_t v6 = *v18;
            __int128 v26 = v18[1];
            __int128 v27 = v18[2];
            __int128 v28 = v18[4];
            *((_OWORD *)v6 + 3) = v18[3];
            *((_OWORD *)v6 + 4) = v28;
            *((_OWORD *)v6 + 1) = v26;
            *((_OWORD *)v6 + 2) = v27;
            __int128 v29 = v18[5];
            __int128 v30 = v18[6];
            __int128 v31 = v18[7];
            *(_OWORD *)(v6 + 124) = *(_OWORD *)((char *)v18 + 124);
            *((_OWORD *)v6 + 6) = v30;
            *((_OWORD *)v6 + 7) = v31;
            *((_OWORD *)v6 + 5) = v29;
            v6 += 144;
          }

          else
          {
            __int16 v19 = v120;
            if ((unint64_t)v120 >= v121)
            {
              uint64_t v32 = (char *)__p;
              unint64_t v33 = 0x8E38E38E38E38E39LL * ((v120 - (_BYTE *)__p) >> 4);
              unint64_t v34 = v33 + 1;
              if (v33 + 1 > 0x1C71C71C71C71C7LL) {
                goto LABEL_102;
              }
              else {
                unint64_t v35 = v34;
              }
              if (v35)
              {
                uint64_t v36 = (char *)sub_1002B4F00((uint64_t)&v121, v35);
                uint64_t v32 = (char *)__p;
                __int16 v19 = v120;
              }

              else
              {
                uint64_t v36 = 0LL;
              }

              uint64_t v37 = &v36[16 * ((v120 - (_BYTE *)__p) >> 4)];
              *(_OWORD *)uint64_t v37 = *v18;
              __int128 v38 = v18[1];
              __int128 v39 = v18[2];
              __int128 v40 = v18[4];
              *((_OWORD *)v37 + 3) = v18[3];
              *((_OWORD *)v37 + 4) = v40;
              *((_OWORD *)v37 + 1) = v38;
              *((_OWORD *)v37 + 2) = v39;
              __int128 v41 = v18[5];
              __int128 v42 = v18[6];
              __int128 v43 = v18[8];
              *((_OWORD *)v37 + 7) = v18[7];
              *((_OWORD *)v37 + _Block_object_dispose((const void *)(v1 - 128), 8) = v43;
              *((_OWORD *)v37 + 5) = v41;
              *((_OWORD *)v37 + 6) = v42;
              if (v19 == v32)
              {
                __int128 v51 = &v36[144 * v33];
              }

              else
              {
                uint64_t v44 = &v36[144 * v33];
                do
                {
                  *((_OWORD *)v44 - 9) = *((_OWORD *)v19 - 9);
                  __int128 v45 = *((_OWORD *)v19 - 8);
                  __int128 v46 = *((_OWORD *)v19 - 7);
                  __int128 v47 = *((_OWORD *)v19 - 5);
                  *((_OWORD *)v44 - 6) = *((_OWORD *)v19 - 6);
                  *((_OWORD *)v44 - 5) = v47;
                  *((_OWORD *)v44 - _Block_object_dispose((const void *)(v1 - 128), 8) = v45;
                  *((_OWORD *)v44 - 7) = v46;
                  __int128 v48 = *((_OWORD *)v19 - 4);
                  __int128 v49 = *((_OWORD *)v19 - 3);
                  __int128 v50 = *((_OWORD *)v19 - 2);
                  __int128 v51 = v44 - 144;
                  *(_OWORD *)(v44 - 20) = *(_OWORD *)(v19 - 20);
                  *((_OWORD *)v44 - 3) = v49;
                  *((_OWORD *)v44 - 2) = v50;
                  *((_OWORD *)v44 - 4) = v48;
                  v19 -= 144;
                  v44 -= 144;
                }

                while (v19 != v32);
              }

              __int128 v52 = v37 + 144;
              __int128 __p = v51;
              __int16 v120 = v37 + 144;
              unint64_t v121 = (unint64_t)&v36[144 * v35];
              if (v32) {
                operator delete(v32);
              }
              __int16 v120 = v52;
            }

            else
            {
              *(_OWORD *)__int16 v120 = *v18;
              __int128 v20 = v18[1];
              __int128 v21 = v18[2];
              __int128 v22 = v18[4];
              *((_OWORD *)v19 + 3) = v18[3];
              *((_OWORD *)v19 + 4) = v22;
              *((_OWORD *)v19 + 1) = v20;
              *((_OWORD *)v19 + 2) = v21;
              __int128 v23 = v18[5];
              __int128 v24 = v18[6];
              __int128 v25 = v18[8];
              *((_OWORD *)v19 + 7) = v18[7];
              *((_OWORD *)v19 + _Block_object_dispose((const void *)(v1 - 128), 8) = v25;
              *((_OWORD *)v19 + 5) = v23;
              *((_OWORD *)v19 + 6) = v24;
              __int16 v120 = v19 + 144;
            }
          }

          v18 += 9;
        }

        while (v18 != (_OWORD *)v7);
      }
    }
  }

void sub_100F7ECF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  if (a25) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *sub_100F7ED84(uint64_t a1, int a2)
{
  return sub_1003CF598(*(_DWORD **)(a1 + 80), a2);
}

uint64_t sub_100F7ED8C(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555LL) {
      sub_100007008();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v19[4] = result;
    if (v14) {
      __int128 v15 = (char *)sub_1000BB1F4(result, v14);
    }
    else {
      __int128 v15 = 0LL;
    }
    __int128 v16 = &v15[48 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[48 * v14];
    __int128 v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int128 v16 = v17;
    __int128 v18 = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    v19[2] = v16 + 48;
    sub_1002236C0(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_100223504((uint64_t)v19);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v10;
  return result;
}

void sub_100F7EED0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7EEE4(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = a1 + 7;
  (*(void (**)(void *))(a1[7] + 16LL))(a1 + 7);
  sub_100ECD548(v2 + 6);
  uint64_t v3 = (void *)v1[15];
  v1 += 15;
  sub_1004C1CC0((uint64_t)(v1 - 1), v3);
  *(v1 - 1) = v1;
  void *v1 = 0LL;
  v1[1] = 0LL;
  return (*(uint64_t (**)(void *))(*(v1 - 8) + 24LL))(v2);
}

void sub_100F7EF58(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F7EF6C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 136);
  if (result) {
    return sub_10067B554(result, a2);
  }
  return result;
}

void sub_100F7EF7C(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2) {
    sub_10067B9F8(v2, a2);
  }
}

BOOL sub_100F7EF8C(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0LL;
}

uint64_t sub_100F7EF9C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 144);
  *a2 = *(void *)(result + 136);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void sub_100F7EFC0(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 136);
  if (v3) {
    sub_10067F034(v3, a2, a3);
  }
  else {
    sub_1002FB114(a3, (uint64_t)a2);
  }
}

uint64_t sub_100F7EFD4(uint64_t a1)
{
  uint64_t v3 = a1 + 56;
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v9 = a1 + 56;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 56);
  __int16 v10 = 256;
  if ((sub_1007EC584() & 1) != 0)
  {
    unint64_t v4 = *(void **)(a1 + 160);
    if (v4)
    {
      [v4 reInitializeDatabasesAndSyncEngineIfNeeded];
    }

    else
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10188FC08);
      }
      unint64_t v5 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "WifiAssociatedApCentroidStore, did we forget to initialize it in constructor?",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10188FC08);
        }
        __int16 v8 = 0;
        unint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  16LL,  "WifiAssociatedApCentroidStore, did we forget to initialize it in constructor?",  &v8,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWifiAccessPointLocationService::reInitializeWifiAssociatedApCentroidStoreIfInvalid()",  "%s\n",  v7);
      }
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
}

void sub_100F7F1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100F7F1D4(uint64_t a1)
{
  return *(void *)(a1 + 160);
}

void sub_100F7F1DC(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100F7F208(id a1)
{
  qword_101934868 = (uint64_t)os_log_create("com.apple.locationd.Position", "WifiPosition");
}

void sub_100F7F234(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void *sub_100F7F260(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  sub_100F7F338(a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  sub_100F7F338(a1 + 3, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 4));
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  sub_100F7F338(a1 + 6, *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 4));
  return a1;
}

void sub_100F7F30C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100F7F338(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    sub_100F7F3BC(result, a4);
    uint64_t result = (void *)sub_100F7F40C((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_100F7F39C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 128), 8) = v10;
  sub_100222DE8(&a9);
  _Unwind_Resume(a1);
}

char *sub_100F7F3BC(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_100007008();
  }
  uint64_t result = (char *)sub_1000BB1F4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t sub_100F7F40C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v14 = a4;
  uint64_t v15 = a4;
  v12[0] = a1;
  v12[1] = &v14;
  id v12[2] = &v15;
  char v13 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = (__int128 *)(a2 + 24);
    do
    {
      __int128 v7 = *(__int128 *)((char *)v6 - 24);
      *(void *)(v4 + 16) = *((void *)v6 - 1);
      *(_OWORD *)uint64_t v4 = v7;
      __int16 v8 = (_BYTE *)(v4 + 24);
      if (*((char *)v6 + 23) < 0)
      {
        sub_1010DD48C(v8, *(void **)v6, *((void *)v6 + 1));
        uint64_t v4 = v15;
      }

      else
      {
        __int128 v9 = *v6;
        *(void *)(v4 + 40) = *((void *)v6 + 2);
        *(_OWORD *)__int16 v8 = v9;
      }

      uint64_t v10 = (uint64_t)v6 - 24;
      v4 += 48LL;
      uint64_t v15 = v4;
      v6 += 3;
    }

    while (v10 + 48 != a3);
  }

  char v13 = 1;
  sub_10022348C((uint64_t)v12);
  return v4;
}

void sub_100F7F4CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100F7F4E0@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xC0uLL);
  uint64_t result = sub_100F7F528(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_100F7F514(_Unwind_Exception *a1)
{
}

void *sub_100F7F528(void *a1)
{
  a1[2] = 0LL;
  *a1 = off_10188FC78;
  a1[1] = 0LL;
  sub_100F7777C((uint64_t)(a1 + 3));
  return a1;
}

void sub_100F7F560(_Unwind_Exception *a1)
{
}

void sub_100F7F574(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10188FC78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F7F588(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10188FC78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100F7F5AC(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_100F7F5BC(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  *a1 = v3;
  sub_1002E4C3C(a1 + 1, "CLWifiTileDataRepository", 1LL, 1LL);
  a1[4] = 0LL;
  return a1;
}

void sub_100F7F600(_Unwind_Exception *a1)
{
}

void sub_100F7F618(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = sub_100DAACD0(v3);
    operator delete(v4);
  }

void sub_100F7F644(uint64_t a1)
{
}

uint64_t sub_100F7F64C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

void sub_100F7F68C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100F429F8(a2 + 168);
    *(void *)(a2 + sub_1011C52D0(v23 - 72) = &off_10188FD28;
    uint64_t v3 = *(void *)(a2 + 64);
    *(void *)(a2 + 64) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = *(void *)(a2 + 56);
    *(void *)(a2 + 56) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    sub_10000AE14(a2 + 40);
    sub_10000AE14(a2 + 24);
    operator delete((void *)a2);
  }

void sub_100F7F73C(void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_100008390((uint64_t)v2, v2[1]);
    operator delete(v2);
  }

void sub_100F7F77C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1004C1B8C((uint64_t *)(a2 + 56), 0LL);
    uint64_t v3 = *(void *)(a2 + 48);
    *(void *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    operator delete((void *)a2);
  }

uint64_t *sub_100F7F7D8(uint64_t **a1, uint64_t *a2, uint64_t a3, __int128 *a4)
{
  __int128 v7 = (uint64_t **)sub_100950BC4((uint64_t)a1, &v10, a2);
  uint64_t result = *v7;
  if (!*v7)
  {
    sub_100F7F85C((uint64_t)a1, a3, a4, (uint64_t)&v9);
    sub_1000085FC(a1, v10, v7, v9);
    return v9;
  }

  return result;
}

uint64_t sub_100F7F85C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  __int16 v8 = operator new(0xD8uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  uint64_t result = sub_100F7F8E4((uint64_t)v8 + 32, a2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100F7F8C8(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100528808(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7F8E4(uint64_t a1, uint64_t a2, __int128 *a3)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v6 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)v6, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a2 + 8);
    *(void *)(v6 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v6 = v7;
  }

  __int128 v8 = *(_OWORD *)(a2 + 32);
  __int128 v9 = *(_OWORD *)(a2 + 48);
  __int128 v10 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + sub_100F6A7D8(v1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v9;
  *(_OWORD *)(a1 + 64) = v10;
  *(_OWORD *)(a1 + 32) = v8;
  __int128 v11 = a3[4];
  __int128 v12 = a3[5];
  __int128 v13 = a3[3];
  *(_OWORD *)(a1 + 120) = a3[2];
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = v12;
  *(_OWORD *)(a1 + 152) = v11;
  *(_OWORD *)(a1 + 136) = v13;
  __int128 v14 = *a3;
  *(_OWORD *)(a1 + 104) = a3[1];
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = v14;
  return a1;
}

void *sub_100F7F980(uint64_t **a1, void *a2, uint64_t a3, void **a4)
{
  uint64_t v6 = (void **)sub_1002FB00C((uint64_t)a1, &v10, a2);
  __int128 v7 = *v6;
  if (!*v6)
  {
    __int128 v8 = (uint64_t **)v6;
    __int128 v7 = operator new(0x40uLL);
    _DWORD v7[4] = **a4;
    *((_BYTE *)v7 + 40) = 0;
    *((_BYTE *)v7 + 60) = 0;
    sub_1000085FC(a1, v10, v8, v7);
  }

  return v7;
}

uint64_t sub_100F7FA0C(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = *a2;
  int v6 = a2[1];
  uint64_t v7 = v2;
  do
  {
    int v8 = *(_DWORD *)(v3 + 32);
    BOOL v10 = v8 == v5;
    BOOL v9 = v8 < v5;
    if (v10) {
      BOOL v9 = *(_DWORD *)(v3 + 36) < v6;
    }
    BOOL v10 = !v9;
    if (v9) {
      __int128 v11 = (uint64_t *)(v3 + 8);
    }
    else {
      __int128 v11 = (uint64_t *)v3;
    }
    if (v10) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v11;
  }

  while (*v11);
  if (v7 == v2) {
    return v2;
  }
  int v12 = *(_DWORD *)(v7 + 32);
  BOOL v13 = v6 < *(_DWORD *)(v7 + 36);
  BOOL v10 = v5 == v12;
  BOOL v14 = v5 < v12;
  if (v10) {
    BOOL v14 = v13;
  }
  if (v14) {
    return v2;
  }
  return v7;
}

char *sub_100F7FA80(uint64_t **a1, int *a2, void *a3, __int128 *a4)
{
  uint64_t v7 = sub_100F7FB44((uint64_t)a1, &v15, a2);
  int v8 = (char *)*v7;
  if (!*v7)
  {
    BOOL v9 = (uint64_t **)v7;
    int v8 = (char *)operator new(0xB8uLL);
    __int128 v10 = a4[4];
    *(_OWORD *)(v8 + 120) = a4[5];
    __int128 v11 = a4[7];
    *(_OWORD *)(v8 + 136) = a4[6];
    *(_OWORD *)(v8 + 152) = v11;
    *(_OWORD *)(v8 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = a4[8];
    __int128 v12 = *a4;
    *(_OWORD *)(v8 + 56) = a4[1];
    __int128 v13 = a4[3];
    *(_OWORD *)(v8 + sub_1011C52D0(v23 - 72) = a4[2];
    *(_OWORD *)(v8 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = v13;
    *(_OWORD *)(v8 + 104) = v10;
    *((void *)v8 + 4) = *a3;
    *(_OWORD *)(v8 + 40) = v12;
    sub_1000085FC(a1, v15, v9, (uint64_t *)v8);
  }

  return v8;
}

uint64_t *sub_100F7FB44(uint64_t a1, void *a2, int *a3)
{
  int v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    int v6 = *a3;
    int v7 = a3[1];
    do
    {
      while (1)
      {
        int v8 = v4;
        int v9 = *((_DWORD *)v4 + 8);
        int v10 = *((_DWORD *)v8 + 9);
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }

      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      uint64_t result = v8 + 1;
      uint64_t v4 = (uint64_t *)v8[1];
    }

    while (v4);
  }

  else
  {
    int v8 = result;
  }

__n128 sub_100F7FBC4(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  sub_100F7FC58(*a1);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
  _OWORD v4[2] = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  int v5 = a1[1];
  sub_100F7FC58(v5);
  *(_OWORD *)int v5 = *(_OWORD *)(a2 + 24);
  v5[2] = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  int v6 = a1[2];
  sub_100F7FC58(v6);
  __n128 result = *(__n128 *)(a2 + 48);
  *(__n128 *)int v6 = result;
  _OWORD v6[2] = *(void *)(a2 + 64);
  *(void *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  return result;
}

void sub_100F7FC58(uint64_t *a1)
{
  if (*a1)
  {
    sub_100222E28(a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_100F7FC90(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100F7FD04((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100F7FD04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v8 = a7;
    do
    {
      __int128 v9 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      __int128 v10 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      *(void *)(a3 - 24) = 0LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(_BYTE *)(v8 - _Block_object_dispose((const void *)(v1 - 128), 8) = *(_BYTE *)(a3 - 8);
      v8 -= 56LL;
      v7 -= 56LL;
      a3 -= 56LL;
    }

    while (a3 != a5);
    *((void *)&v16 + 1) = v8;
    uint64_t v11 = v16;
  }

  char v14 = 1;
  sub_100F7FDC0((uint64_t)v13);
  return v11;
}

uint64_t sub_100F7FDC0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100F7FDF4(a1);
  }
  return a1;
}

void sub_100F7FDF4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 56LL;
  }

uint64_t sub_100F7FE38(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100F7FE6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 56;
      *(void *)(a1 + 16) = v2 - 56;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v5 = *(void *)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

uint64_t sub_100F7FEC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_100603990((uint64_t **)a1, v4, v6, v6);
      v6 += 48LL;
    }

    while (v6 != a3);
  }

  return a1;
}

void sub_100F7FF28(_Unwind_Exception *a1)
{
}

void sub_100F7FF40(__int128 *a1, __int128 *a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v8 = a2 - 9;
  float64x2_t v288 = a2 - 27;
  float64x2_t v289 = a2 - 18;
  __int128 v9 = a1;
  float64x2_t v290 = a2;
  while (2)
  {
    a1 = v9;
    uint64_t v10 = (char *)a2 - (char *)v9;
    unint64_t v11 = 0x8E38E38E38E38E39LL * (a2 - v9);
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        double v126 = sub_100924330((uint64_t)v8);
        if (v126 < sub_100924330((uint64_t)v9))
        {
          __int128 v299 = *v9;
          __int128 v127 = v9[1];
          __int128 v128 = v9[2];
          __int128 v129 = v9[4];
          __int128 v302 = v9[3];
          __int128 v303 = v129;
          __int128 v300 = v127;
          __int128 v301 = v128;
          __int128 v130 = v9[5];
          __int128 v131 = v9[6];
          __int128 v132 = v9[8];
          *(_OWORD *)float64x2_t v306 = v9[7];
          *(_OWORD *)&v306[16] = v132;
          __int128 v304 = v130;
          __int128 v305 = v131;
          __int128 *v9 = *v8;
          __int128 v133 = v8[1];
          __int128 v134 = v8[2];
          __int128 v135 = v8[4];
          void v9[3] = v8[3];
          v9[4] = v135;
          v9[1] = v133;
          _DWORD v9[2] = v134;
          __int128 v136 = v8[5];
          __int128 v137 = v8[6];
          __int128 v138 = v8[7];
          *(__int128 *)((char *)v9 + 124) = *(__int128 *)((char *)v8 + 124);
          void v9[6] = v137;
          v9[7] = v138;
          void v9[5] = v136;
          __int128 *v8 = v299;
          __int128 v139 = v300;
          __int128 v140 = v301;
          __int128 v141 = v303;
          void v8[3] = v302;
          v8[4] = v141;
          v8[1] = v139;
          id v8[2] = v140;
          __int128 v142 = v304;
          __int128 v143 = v305;
          __int128 v144 = *(_OWORD *)v306;
          *(__int128 *)((char *)v8 + 124) = *(_OWORD *)&v306[12];
          v8[6] = v143;
          v8[7] = v144;
          void v8[5] = v142;
        }

        return;
      case 3uLL:
        sub_100F80F98(v9, v9 + 9, v8);
        return;
      case 4uLL:
        sub_100F81570(v9, v9 + 9, v9 + 18, v8);
        return;
      case 5uLL:
        sub_100F80CD8(v9, v9 + 9, v9 + 18, v9 + 27, v8);
        return;
      default:
        if (v10 <= 3455)
        {
          uint64_t v145 = (uint64_t)(v9 + 9);
          BOOL v146 = v9 == a2 || v145 == (void)a2;
          char v147 = v146;
          if ((a4 & 1) != 0)
          {
            if ((v147 & 1) == 0)
            {
              uint64_t v148 = 0LL;
              uint64_t v149 = v9;
              do
              {
                uint64_t v150 = (uint64_t)v149;
                uint64_t v149 = (__int128 *)v145;
                double v151 = sub_100924330(v145);
                if (v151 < sub_100924330(v150))
                {
                  __int128 v299 = *v149;
                  __int128 v152 = v149[1];
                  __int128 v153 = v149[2];
                  __int128 v154 = v149[4];
                  __int128 v302 = v149[3];
                  __int128 v303 = v154;
                  __int128 v300 = v152;
                  __int128 v301 = v153;
                  __int128 v155 = v149[5];
                  __int128 v156 = v149[6];
                  __int128 v157 = v149[8];
                  *(_OWORD *)float64x2_t v306 = v149[7];
                  *(_OWORD *)&v306[16] = v157;
                  __int128 v304 = v155;
                  __int128 v305 = v156;
                  uint64_t v158 = v148;
                  while (1)
                  {
                    int v159 = (__int128 *)((char *)v9 + v158);
                    __int128 v160 = *(__int128 *)((char *)v9 + v158 + 112);
                    v159[15] = *(__int128 *)((char *)v9 + v158 + 96);
                    v159[16] = v160;
                    *(__int128 *)((char *)v9 + v158 + 26_Block_object_dispose((const void *)(v1 - 128), 8) = *(__int128 *)((char *)v9 + v158 + 124);
                    __int128 v161 = *(__int128 *)((char *)v9 + v158 + 48);
                    v159[11] = *(__int128 *)((char *)v9 + v158 + 32);
                    v159[12] = v161;
                    __int128 v162 = *(__int128 *)((char *)v9 + v158 + 80);
                    v159[13] = *(__int128 *)((char *)v9 + v158 + 64);
                    v159[14] = v162;
                    __int128 v163 = *(__int128 *)((char *)v9 + v158 + 16);
                    v159[9] = *(__int128 *)((char *)v9 + v158);
                    v159[10] = v163;
                    if (!v158) {
                      break;
                    }
                    v158 -= 144LL;
                    double v164 = sub_100924330((uint64_t)&v299);
                    if (v164 >= sub_100924330((uint64_t)v9 + v158))
                    {
                      int v165 = (__int128 *)((char *)v9 + v158 + 144);
                      goto LABEL_73;
                    }
                  }

                  int v165 = v9;
LABEL_73:
                  __int128 *v165 = v299;
                  __int128 v166 = v300;
                  __int128 v167 = v301;
                  __int128 v168 = v303;
                  v165[3] = v302;
                  v165[4] = v168;
                  v165[1] = v166;
                  v165[2] = v167;
                  __int128 v169 = v304;
                  __int128 v170 = v305;
                  __int128 v171 = *(_OWORD *)v306;
                  *(__int128 *)((char *)v165 + 124) = *(_OWORD *)&v306[12];
                  v165[6] = v170;
                  v165[7] = v171;
                  v165[5] = v169;
                  a2 = v290;
                }

                uint64_t v145 = (uint64_t)(v149 + 9);
                v148 += 144LL;
              }

              while (v149 + 9 != a2);
            }
          }

          else if ((v147 & 1) == 0)
          {
            float64x2_t v266 = v9 - 9;
            do
            {
              uint64_t v267 = (uint64_t)a1;
              a1 = (__int128 *)v145;
              double v268 = sub_100924330(v145);
              if (v268 < sub_100924330(v267))
              {
                __int128 v299 = *a1;
                __int128 v269 = a1[1];
                __int128 v270 = a1[2];
                __int128 v271 = a1[4];
                __int128 v302 = a1[3];
                __int128 v303 = v271;
                __int128 v300 = v269;
                __int128 v301 = v270;
                __int128 v272 = a1[5];
                __int128 v273 = a1[6];
                __int128 v274 = a1[8];
                *(_OWORD *)float64x2_t v306 = a1[7];
                *(_OWORD *)&v306[16] = v274;
                __int128 v304 = v272;
                __int128 v305 = v273;
                float64x2_t v275 = v266;
                do
                {
                  __int128 v276 = v275[16];
                  v275[24] = v275[15];
                  v275[25] = v276;
                  __int128 v277 = v275[12];
                  v275[20] = v275[11];
                  v275[21] = v277;
                  __int128 v278 = v275[14];
                  v275[22] = v275[13];
                  v275[23] = v278;
                  __int128 v279 = v275[10];
                  v275[18] = v275[9];
                  v275[19] = v279;
                  *(__int128 *)((char *)v275 + 412) = *(__int128 *)((char *)v275 + 268);
                  double v280 = sub_100924330((uint64_t)&v299);
                  double v281 = sub_100924330((uint64_t)v275);
                  v275 -= 9;
                }

                while (v280 < v281);
                v275[18] = v299;
                __int128 v282 = v300;
                __int128 v283 = v301;
                __int128 v284 = v303;
                v275[21] = v302;
                v275[22] = v284;
                v275[19] = v282;
                v275[20] = v283;
                __int128 v285 = *(_OWORD *)&v306[12];
                __int128 v286 = v304;
                __int128 v287 = *(_OWORD *)v306;
                v275[24] = v305;
                v275[25] = v287;
                v275[23] = v286;
                *(__int128 *)((char *)v275 + 412) = v285;
              }

              uint64_t v145 = (uint64_t)(a1 + 9);
              v266 += 9;
            }

            while (a1 + 9 != a2);
          }

          return;
        }

        if (!a3)
        {
          if (v9 != a2)
          {
            int64_t v172 = (v11 - 2) >> 1;
            int64_t v173 = v172;
            do
            {
              int64_t v174 = v173;
              if (v172 >= v173)
              {
                uint64_t v175 = (2 * v173) | 1;
                float64x2_t v176 = &a1[9 * v175];
                if (2 * v173 + 2 < (uint64_t)v11)
                {
                  double v177 = sub_100924330((uint64_t)&a1[9 * v175]);
                  if (v177 < sub_100924330((uint64_t)(v176 + 9)))
                  {
                    v176 += 9;
                    uint64_t v175 = 2 * v174 + 2;
                  }
                }

                float64x2_t v178 = &a1[9 * v174];
                double v179 = sub_100924330((uint64_t)v176);
                if (v179 >= sub_100924330((uint64_t)v178))
                {
                  __int128 v299 = *v178;
                  __int128 v180 = v178[1];
                  __int128 v181 = v178[2];
                  __int128 v182 = v178[4];
                  __int128 v302 = v178[3];
                  __int128 v303 = v182;
                  __int128 v300 = v180;
                  __int128 v301 = v181;
                  __int128 v183 = v178[5];
                  __int128 v184 = v178[6];
                  __int128 v185 = v178[8];
                  *(_OWORD *)float64x2_t v306 = v178[7];
                  *(_OWORD *)&v306[16] = v185;
                  __int128 v304 = v183;
                  __int128 v305 = v184;
                  do
                  {
                    float64x2_t v186 = v176;
                    *float64x2_t v178 = *v176;
                    __int128 v187 = v176[1];
                    __int128 v188 = v176[2];
                    __int128 v189 = v176[4];
                    v178[3] = v176[3];
                    v178[4] = v189;
                    v178[1] = v187;
                    v178[2] = v188;
                    __int128 v190 = v176[5];
                    __int128 v191 = v176[6];
                    __int128 v192 = v176[7];
                    *(__int128 *)((char *)v178 + 124) = *(__int128 *)((char *)v176 + 124);
                    v178[6] = v191;
                    v178[7] = v192;
                    v178[5] = v190;
                    if (v172 < v175) {
                      break;
                    }
                    uint64_t v193 = (2 * v175) | 1;
                    float64x2_t v176 = &a1[9 * v193];
                    uint64_t v194 = 2 * v175 + 2;
                    if (v194 < (uint64_t)v11)
                    {
                      double v195 = sub_100924330((uint64_t)&a1[9 * v193]);
                      if (v195 < sub_100924330((uint64_t)(v176 + 9)))
                      {
                        v176 += 9;
                        uint64_t v193 = v194;
                      }
                    }

                    double v196 = sub_100924330((uint64_t)v176);
                    float64x2_t v178 = v186;
                    uint64_t v175 = v193;
                  }

                  while (v196 >= sub_100924330((uint64_t)&v299));
                  *float64x2_t v186 = v299;
                  __int128 v197 = v300;
                  __int128 v198 = v301;
                  __int128 v199 = v303;
                  v186[3] = v302;
                  v186[4] = v199;
                  v186[1] = v197;
                  v186[2] = v198;
                  __int128 v200 = v304;
                  __int128 v201 = v305;
                  __int128 v202 = *(_OWORD *)v306;
                  *(__int128 *)((char *)v186 + 124) = *(_OWORD *)&v306[12];
                  v186[6] = v201;
                  v186[7] = v202;
                  v186[5] = v200;
                }
              }

              int64_t v173 = v174 - 1;
            }

            while (v174);
            int64_t v203 = v10 / 0x90uLL;
            float64x2_t v204 = v290;
            do
            {
              uint64_t v205 = 0LL;
              __int128 v291 = *a1;
              __int128 v206 = a1[1];
              __int128 v207 = a1[2];
              __int128 v208 = a1[4];
              __int128 v294 = a1[3];
              __int128 v295 = v208;
              __int128 v292 = v206;
              __int128 v293 = v207;
              __int128 v209 = a1[5];
              __int128 v210 = a1[6];
              __int128 v211 = a1[8];
              *(_OWORD *)float64x2_t v298 = a1[7];
              *(_OWORD *)&v298[16] = v211;
              __int128 v296 = v209;
              __int128 v297 = v210;
              float64x2_t v212 = a1;
              do
              {
                float64x2_t v213 = &v212[9 * v205 + 9];
                uint64_t v214 = (2 * v205) | 1;
                uint64_t v215 = 2 * v205 + 2;
                if (v215 < v203)
                {
                  double v216 = sub_100924330((uint64_t)&v212[9 * v205 + 9]);
                  if (v216 < sub_100924330((uint64_t)(v213 + 9)))
                  {
                    v213 += 9;
                    uint64_t v214 = v215;
                  }
                }

                __int128 *v212 = *v213;
                __int128 v217 = v213[1];
                __int128 v218 = v213[2];
                __int128 v219 = v213[4];
                v212[3] = v213[3];
                v212[4] = v219;
                v212[1] = v217;
                v212[2] = v218;
                __int128 v220 = v213[5];
                __int128 v221 = v213[6];
                __int128 v222 = v213[7];
                *(__int128 *)((char *)v212 + 124) = *(__int128 *)((char *)v213 + 124);
                v212[6] = v221;
                v212[7] = v222;
                v212[5] = v220;
                float64x2_t v212 = v213;
                uint64_t v205 = v214;
              }

              while (v214 <= (uint64_t)((unint64_t)(v203 - 2) >> 1));
              v204 -= 9;
              if (v213 == v204)
              {
                *float64x2_t v213 = v291;
                __int128 v259 = v292;
                __int128 v260 = v293;
                __int128 v261 = v295;
                v213[3] = v294;
                v213[4] = v261;
                v213[1] = v259;
                v213[2] = v260;
                __int128 v262 = v296;
                __int128 v263 = v297;
                __int128 v264 = *(_OWORD *)v298;
                *(__int128 *)((char *)v213 + 124) = *(_OWORD *)&v298[12];
                v213[6] = v263;
                v213[7] = v264;
                v213[5] = v262;
              }

              else
              {
                *float64x2_t v213 = *v204;
                __int128 v223 = v204[1];
                __int128 v224 = v204[2];
                __int128 v225 = v204[4];
                v213[3] = v204[3];
                v213[4] = v225;
                v213[1] = v223;
                v213[2] = v224;
                __int128 v226 = v204[5];
                __int128 v227 = v204[6];
                __int128 v228 = v204[7];
                *(__int128 *)((char *)v213 + 124) = *(__int128 *)((char *)v204 + 124);
                v213[6] = v227;
                v213[7] = v228;
                v213[5] = v226;
                *float64x2_t v204 = v291;
                __int128 v229 = v292;
                __int128 v230 = v293;
                __int128 v231 = v295;
                v204[3] = v294;
                v204[4] = v231;
                v204[1] = v229;
                v204[2] = v230;
                __int128 v232 = v296;
                __int128 v233 = v297;
                __int128 v234 = *(_OWORD *)v298;
                *(__int128 *)((char *)v204 + 124) = *(_OWORD *)&v298[12];
                v204[6] = v233;
                v204[7] = v234;
                v204[5] = v232;
                uint64_t v235 = (char *)v213 - (char *)a1 + 144;
                if (v235 >= 145)
                {
                  unint64_t v236 = (v235 / 0x90uLL - 2) >> 1;
                  float64x2_t v237 = &a1[9 * v236];
                  double v238 = sub_100924330((uint64_t)v237);
                  if (v238 < sub_100924330((uint64_t)v213))
                  {
                    __int128 v299 = *v213;
                    __int128 v239 = v213[1];
                    __int128 v240 = v213[2];
                    __int128 v241 = v213[4];
                    __int128 v302 = v213[3];
                    __int128 v303 = v241;
                    __int128 v300 = v239;
                    __int128 v301 = v240;
                    __int128 v242 = v213[5];
                    __int128 v243 = v213[6];
                    __int128 v244 = v213[8];
                    *(_OWORD *)float64x2_t v306 = v213[7];
                    *(_OWORD *)&v306[16] = v244;
                    __int128 v304 = v242;
                    __int128 v305 = v243;
                    do
                    {
                      float64x2_t v245 = v237;
                      *float64x2_t v213 = *v237;
                      __int128 v246 = v237[1];
                      __int128 v247 = v237[2];
                      __int128 v248 = v237[4];
                      v213[3] = v237[3];
                      v213[4] = v248;
                      v213[1] = v246;
                      v213[2] = v247;
                      __int128 v249 = v237[5];
                      __int128 v250 = v237[6];
                      __int128 v251 = v237[7];
                      *(__int128 *)((char *)v213 + 124) = *(__int128 *)((char *)v237 + 124);
                      v213[6] = v250;
                      v213[7] = v251;
                      v213[5] = v249;
                      if (!v236) {
                        break;
                      }
                      unint64_t v236 = (v236 - 1) >> 1;
                      float64x2_t v237 = &a1[9 * v236];
                      double v252 = sub_100924330((uint64_t)v237);
                      float64x2_t v213 = v245;
                    }

                    while (v252 < sub_100924330((uint64_t)&v299));
                    *float64x2_t v245 = v299;
                    __int128 v253 = v300;
                    __int128 v254 = v301;
                    __int128 v255 = v303;
                    v245[3] = v302;
                    v245[4] = v255;
                    v245[1] = v253;
                    v245[2] = v254;
                    __int128 v256 = v304;
                    __int128 v257 = v305;
                    __int128 v258 = *(_OWORD *)v306;
                    *(__int128 *)((char *)v245 + 124) = *(_OWORD *)&v306[12];
                    v245[6] = v257;
                    v245[7] = v258;
                    v245[5] = v256;
                  }
                }
              }
            }

            while (v203-- > 2);
          }

          return;
        }

        BOOL v12 = &v9[9 * (v11 >> 1)];
        if ((unint64_t)v10 < 0x4801)
        {
          sub_100F80F98(&a1[9 * (v11 >> 1)], a1, v8);
        }

        else
        {
          sub_100F80F98(a1, &a1[9 * (v11 >> 1)], v8);
          sub_100F80F98(a1 + 9, &a1[9 * (v11 >> 1) - 9], v289);
          sub_100F80F98(a1 + 18, &a1[9 * (v11 >> 1) + 9], v288);
          sub_100F80F98(&a1[9 * (v11 >> 1) - 9], &a1[9 * (v11 >> 1)], &a1[9 * (v11 >> 1) + 9]);
          __int128 v299 = *a1;
          __int128 v13 = a1[1];
          __int128 v14 = a1[2];
          __int128 v15 = a1[4];
          __int128 v302 = a1[3];
          __int128 v303 = v15;
          __int128 v300 = v13;
          __int128 v301 = v14;
          __int128 v16 = a1[5];
          __int128 v17 = a1[6];
          __int128 v18 = a1[8];
          *(_OWORD *)float64x2_t v306 = a1[7];
          *(_OWORD *)&v306[16] = v18;
          __int128 v304 = v16;
          __int128 v305 = v17;
          *a1 = *v12;
          __int128 v19 = v12[1];
          __int128 v20 = v12[2];
          __int128 v21 = v12[4];
          a1[3] = v12[3];
          a1[4] = v21;
          a1[1] = v19;
          a1[2] = v20;
          __int128 v22 = v12[5];
          __int128 v23 = v12[6];
          __int128 v24 = v12[7];
          *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)v12 + 124);
          a1[6] = v23;
          a1[7] = v24;
          a1[5] = v22;
          *BOOL v12 = v299;
          __int128 v25 = v300;
          __int128 v26 = v301;
          __int128 v27 = v303;
          void v12[3] = v302;
          v12[4] = v27;
          v12[1] = v25;
          id v12[2] = v26;
          __int128 v28 = v304;
          __int128 v29 = v305;
          __int128 v30 = *(_OWORD *)v306;
          *(__int128 *)((char *)v12 + 124) = *(_OWORD *)&v306[12];
          v12[6] = v29;
          v12[7] = v30;
          v12[5] = v28;
        }

        --a3;
        if ((a4 & 1) == 0)
        {
          double v31 = sub_100924330((uint64_t)(a1 - 9));
          if (v31 >= sub_100924330((uint64_t)a1))
          {
            __int128 v291 = *a1;
            __int128 v80 = a1[1];
            __int128 v81 = a1[2];
            __int128 v82 = a1[4];
            __int128 v294 = a1[3];
            __int128 v295 = v82;
            __int128 v292 = v80;
            __int128 v293 = v81;
            __int128 v83 = a1[5];
            __int128 v84 = a1[6];
            __int128 v85 = a1[8];
            *(_OWORD *)float64x2_t v298 = a1[7];
            *(_OWORD *)&v298[16] = v85;
            __int128 v296 = v83;
            __int128 v297 = v84;
            double v86 = sub_100924330((uint64_t)&v291);
            if (v86 >= sub_100924330((uint64_t)v8))
            {
              __int128 v88 = a1 + 9;
              a2 = v290;
              do
              {
                __int128 v9 = v88;
                if (v88 >= v290) {
                  break;
                }
                double v89 = sub_100924330((uint64_t)&v291);
                double v90 = sub_100924330((uint64_t)v9);
                __int128 v88 = v9 + 9;
              }

              while (v89 >= v90);
            }

            else
            {
              __int128 v9 = a1;
              a2 = v290;
              do
              {
                v9 += 9;
                double v87 = sub_100924330((uint64_t)&v291);
              }

              while (v87 >= sub_100924330((uint64_t)v9));
            }

            unint64_t v91 = a2;
            if (v9 < a2)
            {
              unint64_t v91 = a2;
              do
              {
                v91 -= 9;
                double v92 = sub_100924330((uint64_t)&v291);
              }

              while (v92 < sub_100924330((uint64_t)v91));
            }

            while (v9 < v91)
            {
              __int128 v299 = *v9;
              __int128 v93 = v9[1];
              __int128 v94 = v9[2];
              __int128 v95 = v9[4];
              __int128 v302 = v9[3];
              __int128 v303 = v95;
              __int128 v300 = v93;
              __int128 v301 = v94;
              __int128 v96 = v9[5];
              __int128 v97 = v9[6];
              __int128 v98 = v9[8];
              *(_OWORD *)float64x2_t v306 = v9[7];
              *(_OWORD *)&v306[16] = v98;
              __int128 v304 = v96;
              __int128 v305 = v97;
              __int128 *v9 = *v91;
              __int128 v99 = v91[1];
              __int128 v100 = v91[2];
              __int128 v101 = v91[4];
              void v9[3] = v91[3];
              v9[4] = v101;
              v9[1] = v99;
              _DWORD v9[2] = v100;
              __int128 v102 = v91[5];
              __int128 v103 = v91[6];
              __int128 v104 = v91[7];
              *(__int128 *)((char *)v9 + 124) = *(__int128 *)((char *)v91 + 124);
              void v9[6] = v103;
              v9[7] = v104;
              void v9[5] = v102;
              *unint64_t v91 = v299;
              __int128 v105 = v300;
              __int128 v106 = v301;
              __int128 v107 = v303;
              v91[3] = v302;
              v91[4] = v107;
              v91[1] = v105;
              v91[2] = v106;
              __int128 v108 = v304;
              __int128 v109 = v305;
              __int128 v110 = *(_OWORD *)v306;
              *(__int128 *)((char *)v91 + 124) = *(_OWORD *)&v306[12];
              v91[6] = v109;
              v91[7] = v110;
              v91[5] = v108;
              do
              {
                v9 += 9;
                double v111 = sub_100924330((uint64_t)&v291);
              }

              while (v111 >= sub_100924330((uint64_t)v9));
              do
              {
                v91 -= 9;
                double v112 = sub_100924330((uint64_t)&v291);
              }

              while (v112 < sub_100924330((uint64_t)v91));
            }

            int v113 = v9 - 9;
            if (v9 - 9 != a1)
            {
              *a1 = *v113;
              __int128 v114 = *(v9 - 8);
              __int128 v115 = *(v9 - 7);
              __int128 v116 = *(v9 - 5);
              a1[3] = *(v9 - 6);
              a1[4] = v116;
              a1[1] = v114;
              a1[2] = v115;
              __int128 v117 = *(v9 - 4);
              __int128 v118 = *(v9 - 3);
              __int128 v119 = *(v9 - 2);
              *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)v9 - 20);
              a1[6] = v118;
              a1[7] = v119;
              a1[5] = v117;
            }

            a4 = 0;
            __int128 *v113 = v291;
            __int128 v120 = v292;
            __int128 v121 = v293;
            __int128 v122 = v295;
            *(v9 - 6) = v294;
            *(v9 - 5) = v122;
            *(v9 - _Block_object_dispose((const void *)(v1 - 128), 8) = v120;
            *(v9 - 7) = v121;
            __int128 v123 = v296;
            __int128 v124 = v297;
            __int128 v125 = *(_OWORD *)v298;
            *(__int128 *)((char *)v9 - 20) = *(_OWORD *)&v298[12];
            *(v9 - 3) = v124;
            *(v9 - 2) = v125;
            *(v9 - 4) = v123;
            continue;
          }
        }

        uint64_t v32 = 0LL;
        __int128 v291 = *a1;
        __int128 v33 = a1[1];
        __int128 v34 = a1[2];
        __int128 v35 = a1[4];
        __int128 v294 = a1[3];
        __int128 v295 = v35;
        __int128 v292 = v33;
        __int128 v293 = v34;
        __int128 v36 = a1[5];
        __int128 v37 = a1[6];
        __int128 v38 = a1[8];
        *(_OWORD *)float64x2_t v298 = a1[7];
        *(_OWORD *)&v298[16] = v38;
        __int128 v296 = v36;
        __int128 v297 = v37;
        do
        {
          v32 += 9LL;
          double v39 = sub_100924330((uint64_t)&a1[v32]);
        }

        while (v39 < sub_100924330((uint64_t)&v291));
        __int128 v40 = &a1[v32];
        unint64_t v41 = (unint64_t)v290;
        BOOL v146 = v32 == 9;
        a2 = v290;
        if (v146)
        {
          unint64_t v41 = (unint64_t)v290;
          do
          {
            v41 -= 144LL;
            double v43 = sub_100924330(v41);
          }

          while (v43 >= sub_100924330((uint64_t)&v291));
        }

        else
        {
          do
          {
            v41 -= 144LL;
            double v42 = sub_100924330(v41);
          }

          while (v42 >= sub_100924330((uint64_t)&v291));
        }

        if ((unint64_t)v40 >= v41)
        {
          unint64_t v66 = v40 - 9;
        }

        else
        {
          uint64_t v44 = v40;
          __int128 v45 = (__int128 *)v41;
          do
          {
            __int128 v299 = *v44;
            __int128 v46 = v44[1];
            __int128 v47 = v44[2];
            __int128 v48 = v44[4];
            __int128 v302 = v44[3];
            __int128 v303 = v48;
            __int128 v300 = v46;
            __int128 v301 = v47;
            __int128 v49 = v44[5];
            __int128 v50 = v44[6];
            __int128 v51 = v44[8];
            *(_OWORD *)float64x2_t v306 = v44[7];
            *(_OWORD *)&v306[16] = v51;
            __int128 v304 = v49;
            __int128 v305 = v50;
            __int128 *v44 = *v45;
            __int128 v52 = v45[1];
            __int128 v53 = v45[2];
            __int128 v54 = v45[4];
            v44[3] = v45[3];
            v44[4] = v54;
            v44[1] = v52;
            v44[2] = v53;
            __int128 v55 = v45[5];
            __int128 v56 = v45[6];
            __int128 v57 = v45[7];
            *(__int128 *)((char *)v44 + 124) = *(__int128 *)((char *)v45 + 124);
            v44[6] = v56;
            v44[7] = v57;
            v44[5] = v55;
            __int128 *v45 = v299;
            __int128 v58 = v300;
            __int128 v59 = v301;
            __int128 v60 = v303;
            v45[3] = v302;
            v45[4] = v60;
            v45[1] = v58;
            _OWORD v45[2] = v59;
            __int128 v61 = v304;
            __int128 v62 = v305;
            __int128 v63 = *(_OWORD *)v306;
            *(__int128 *)((char *)v45 + 124) = *(_OWORD *)&v306[12];
            v45[6] = v62;
            v45[7] = v63;
            v45[5] = v61;
            do
            {
              v44 += 9;
              double v64 = sub_100924330((uint64_t)v44);
            }

            while (v64 < sub_100924330((uint64_t)&v291));
            do
            {
              v45 -= 9;
              double v65 = sub_100924330((uint64_t)v45);
            }

            while (v65 >= sub_100924330((uint64_t)&v291));
          }

          while (v44 < v45);
          unint64_t v66 = v44 - 9;
        }

        if (v66 != a1)
        {
          *a1 = *v66;
          __int128 v67 = v66[1];
          __int128 v68 = v66[2];
          __int128 v69 = v66[4];
          a1[3] = v66[3];
          a1[4] = v69;
          a1[1] = v67;
          a1[2] = v68;
          __int128 v70 = v66[5];
          __int128 v71 = v66[6];
          __int128 v72 = v66[7];
          *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)v66 + 124);
          a1[6] = v71;
          a1[7] = v72;
          a1[5] = v70;
        }

        *unint64_t v66 = v291;
        __int128 v73 = v292;
        __int128 v74 = v293;
        __int128 v75 = v295;
        v66[3] = v294;
        v66[4] = v75;
        v66[1] = v73;
        v66[2] = v74;
        __int128 v76 = v296;
        __int128 v77 = v297;
        __int128 v78 = *(_OWORD *)v298;
        *(__int128 *)((char *)v66 + 124) = *(_OWORD *)&v298[12];
        v66[6] = v77;
        v66[7] = v78;
        v66[5] = v76;
        if ((unint64_t)v40 < v41)
        {
LABEL_31:
          sub_100F7FF40(a1, v66, a3, a4 & 1);
          a4 = 0;
          __int128 v9 = v66 + 9;
          continue;
        }

        BOOL v79 = sub_100F812B8(a1, v66);
        __int128 v9 = v66 + 9;
        if (!sub_100F812B8(v66 + 9, v290))
        {
          if (v79) {
            continue;
          }
          goto LABEL_31;
        }

        a2 = v66;
        if (!v79) {
          goto LABEL_1;
        }
        return;
    }
  }

void sub_100F80CD8(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5)
{
  double v10 = sub_100924330((uint64_t)a5);
  if (v10 < sub_100924330((uint64_t)a4))
  {
    __int128 v62 = a4[6];
    *(_OWORD *)unint64_t v66 = a4[7];
    *(_OWORD *)&v66[16] = a4[8];
    __int128 v46 = a4[2];
    __int128 v50 = a4[3];
    __int128 v54 = a4[4];
    __int128 v58 = a4[5];
    __int128 v38 = *a4;
    __int128 v42 = a4[1];
    *a4 = *a5;
    __int128 v11 = a5[1];
    __int128 v12 = a5[2];
    __int128 v13 = a5[4];
    a4[3] = a5[3];
    a4[4] = v13;
    a4[1] = v11;
    a4[2] = v12;
    __int128 v14 = a5[5];
    __int128 v15 = a5[6];
    __int128 v16 = a5[7];
    *(__int128 *)((char *)a4 + 124) = *(__int128 *)((char *)a5 + 124);
    a4[6] = v15;
    a4[7] = v16;
    a4[5] = v14;
    a5[6] = v62;
    a5[7] = *(_OWORD *)v66;
    *(__int128 *)((char *)a5 + 124) = *(_OWORD *)&v66[12];
    a5[2] = v46;
    a5[3] = v50;
    a5[4] = v54;
    a5[5] = v58;
    *a5 = v38;
    a5[1] = v42;
    double v17 = sub_100924330((uint64_t)a4);
    if (v17 < sub_100924330((uint64_t)a3))
    {
      __int128 v63 = a3[6];
      *(_OWORD *)__int128 v67 = a3[7];
      *(_OWORD *)&v67[16] = a3[8];
      __int128 v47 = a3[2];
      __int128 v51 = a3[3];
      __int128 v55 = a3[4];
      __int128 v59 = a3[5];
      __int128 v39 = *a3;
      __int128 v43 = a3[1];
      *a3 = *a4;
      __int128 v18 = a4[1];
      __int128 v19 = a4[2];
      __int128 v20 = a4[4];
      a3[3] = a4[3];
      a3[4] = v20;
      a3[1] = v18;
      a3[2] = v19;
      __int128 v21 = a4[5];
      __int128 v22 = a4[6];
      __int128 v23 = a4[7];
      *(__int128 *)((char *)a3 + 124) = *(__int128 *)((char *)a4 + 124);
      a3[6] = v22;
      a3[7] = v23;
      a3[5] = v21;
      a4[6] = v63;
      a4[7] = *(_OWORD *)v67;
      *(__int128 *)((char *)a4 + 124) = *(_OWORD *)&v67[12];
      a4[2] = v47;
      a4[3] = v51;
      a4[4] = v55;
      a4[5] = v59;
      *a4 = v39;
      a4[1] = v43;
      double v24 = sub_100924330((uint64_t)a3);
      if (v24 < sub_100924330((uint64_t)a2))
      {
        __int128 v64 = a2[6];
        *(_OWORD *)__int128 v68 = a2[7];
        *(_OWORD *)&v68[16] = a2[8];
        __int128 v48 = a2[2];
        __int128 v52 = a2[3];
        __int128 v56 = a2[4];
        __int128 v60 = a2[5];
        __int128 v40 = *a2;
        __int128 v44 = a2[1];
        *a2 = *a3;
        __int128 v25 = a3[1];
        __int128 v26 = a3[2];
        __int128 v27 = a3[4];
        a2[3] = a3[3];
        a2[4] = v27;
        a2[1] = v25;
        a2[2] = v26;
        __int128 v28 = a3[5];
        __int128 v29 = a3[6];
        __int128 v30 = a3[7];
        *(__int128 *)((char *)a2 + 124) = *(__int128 *)((char *)a3 + 124);
        a2[6] = v29;
        a2[7] = v30;
        a2[5] = v28;
        a3[6] = v64;
        a3[7] = *(_OWORD *)v68;
        *(__int128 *)((char *)a3 + 124) = *(_OWORD *)&v68[12];
        a3[2] = v48;
        a3[3] = v52;
        a3[4] = v56;
        a3[5] = v60;
        *a3 = v40;
        a3[1] = v44;
        double v31 = sub_100924330((uint64_t)a2);
        if (v31 < sub_100924330((uint64_t)a1))
        {
          __int128 v65 = a1[6];
          *(_OWORD *)__int128 v69 = a1[7];
          *(_OWORD *)&v69[16] = a1[8];
          __int128 v49 = a1[2];
          __int128 v53 = a1[3];
          __int128 v57 = a1[4];
          __int128 v61 = a1[5];
          __int128 v41 = *a1;
          __int128 v45 = a1[1];
          *a1 = *a2;
          __int128 v32 = a2[1];
          __int128 v33 = a2[2];
          __int128 v34 = a2[4];
          a1[3] = a2[3];
          a1[4] = v34;
          a1[1] = v32;
          a1[2] = v33;
          __int128 v35 = a2[5];
          __int128 v36 = a2[6];
          __int128 v37 = a2[7];
          *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)a2 + 124);
          a1[6] = v36;
          a1[7] = v37;
          a1[5] = v35;
          a2[6] = v65;
          a2[7] = *(_OWORD *)v69;
          *(__int128 *)((char *)a2 + 124) = *(_OWORD *)&v69[12];
          a2[2] = v49;
          a2[3] = v53;
          a2[4] = v57;
          a2[5] = v61;
          *a2 = v41;
          a2[1] = v45;
        }
      }
    }
  }

void sub_100F80F98(__int128 *a1, __int128 *a2, __int128 *a3)
{
  double v6 = sub_100924330((uint64_t)a2);
  double v7 = sub_100924330((uint64_t)a1);
  double v8 = sub_100924330((uint64_t)a3);
  double v9 = sub_100924330((uint64_t)a2);
  if (v6 >= v7)
  {
    if (v8 < v9)
    {
      __int128 v67 = a2[6];
      *(_OWORD *)__int128 v71 = a2[7];
      *(_OWORD *)&v71[16] = a2[8];
      __int128 v51 = a2[2];
      __int128 v55 = a2[3];
      __int128 v59 = a2[4];
      __int128 v63 = a2[5];
      __int128 v43 = *a2;
      __int128 v47 = a2[1];
      *a2 = *a3;
      __int128 v16 = a3[1];
      __int128 v17 = a3[2];
      __int128 v18 = a3[4];
      a2[3] = a3[3];
      a2[4] = v18;
      a2[1] = v16;
      a2[2] = v17;
      __int128 v19 = a3[5];
      __int128 v20 = a3[6];
      __int128 v21 = a3[7];
      *(__int128 *)((char *)a2 + 124) = *(__int128 *)((char *)a3 + 124);
      a2[6] = v20;
      a2[7] = v21;
      a2[5] = v19;
      a3[6] = v67;
      a3[7] = *(_OWORD *)v71;
      *(__int128 *)((char *)a3 + 124) = *(_OWORD *)&v71[12];
      a3[2] = v51;
      a3[3] = v55;
      a3[4] = v59;
      a3[5] = v63;
      *a3 = v43;
      a3[1] = v47;
      double v22 = sub_100924330((uint64_t)a2);
      if (v22 < sub_100924330((uint64_t)a1))
      {
        __int128 v68 = a1[6];
        *(_OWORD *)__int128 v72 = a1[7];
        *(_OWORD *)&v72[16] = a1[8];
        __int128 v52 = a1[2];
        __int128 v56 = a1[3];
        __int128 v60 = a1[4];
        __int128 v64 = a1[5];
        __int128 v44 = *a1;
        __int128 v48 = a1[1];
        *a1 = *a2;
        __int128 v23 = a2[1];
        __int128 v24 = a2[2];
        __int128 v25 = a2[4];
        a1[3] = a2[3];
        a1[4] = v25;
        a1[1] = v23;
        a1[2] = v24;
        __int128 v26 = a2[5];
        __int128 v27 = a2[6];
        __int128 v28 = a2[7];
        *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)a2 + 124);
        a1[6] = v27;
        a1[7] = v28;
        a1[5] = v26;
        a2[6] = v68;
        a2[7] = *(_OWORD *)v72;
        *(__int128 *)((char *)a2 + 124) = *(_OWORD *)&v72[12];
        a2[2] = v52;
        a2[3] = v56;
        a2[4] = v60;
        a2[5] = v64;
        *a2 = v44;
        a2[1] = v48;
      }
    }
  }

  else
  {
    if (v8 >= v9)
    {
      __int128 v69 = a1[6];
      *(_OWORD *)__int128 v73 = a1[7];
      *(_OWORD *)&v73[16] = a1[8];
      __int128 v53 = a1[2];
      __int128 v57 = a1[3];
      __int128 v61 = a1[4];
      __int128 v65 = a1[5];
      __int128 v45 = *a1;
      __int128 v49 = a1[1];
      *a1 = *a2;
      __int128 v29 = a2[1];
      __int128 v30 = a2[2];
      __int128 v31 = a2[4];
      a1[3] = a2[3];
      a1[4] = v31;
      a1[1] = v29;
      a1[2] = v30;
      __int128 v32 = a2[5];
      __int128 v33 = a2[6];
      __int128 v34 = a2[7];
      *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)a2 + 124);
      a1[6] = v33;
      a1[7] = v34;
      a1[5] = v32;
      a2[6] = v69;
      a2[7] = *(_OWORD *)v73;
      *(__int128 *)((char *)a2 + 124) = *(_OWORD *)&v73[12];
      a2[2] = v53;
      a2[3] = v57;
      a2[4] = v61;
      a2[5] = v65;
      *a2 = v45;
      a2[1] = v49;
      double v35 = sub_100924330((uint64_t)a3);
      __int128 v66 = a2[6];
      *(_OWORD *)__int128 v70 = a2[7];
      *(_OWORD *)&v70[16] = a2[8];
      __int128 v50 = a2[2];
      __int128 v54 = a2[3];
      __int128 v58 = a2[4];
      __int128 v62 = a2[5];
      __int128 v42 = *a2;
      __int128 v46 = a2[1];
      *a2 = *a3;
      __int128 v36 = a3[1];
      __int128 v37 = a3[2];
      __int128 v38 = a3[4];
      a2[3] = a3[3];
      a2[4] = v38;
      a2[1] = v36;
      a2[2] = v37;
      __int128 v39 = a3[5];
      __int128 v40 = a3[6];
      __int128 v41 = a3[7];
      *(__int128 *)((char *)a2 + 124) = *(__int128 *)((char *)a3 + 124);
      a2[6] = v40;
      a2[7] = v41;
      a2[5] = v39;
    }

    else
    {
      __int128 v66 = a1[6];
      *(_OWORD *)__int128 v70 = a1[7];
      *(_OWORD *)&v70[16] = a1[8];
      __int128 v50 = a1[2];
      __int128 v54 = a1[3];
      __int128 v58 = a1[4];
      __int128 v62 = a1[5];
      __int128 v42 = *a1;
      __int128 v46 = a1[1];
      *a1 = *a3;
      __int128 v10 = a3[1];
      __int128 v11 = a3[2];
      __int128 v12 = a3[4];
      a1[3] = a3[3];
      a1[4] = v12;
      a1[1] = v10;
      a1[2] = v11;
      __int128 v13 = a3[5];
      __int128 v14 = a3[6];
      __int128 v15 = a3[7];
      *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)a3 + 124);
      a1[6] = v14;
      a1[7] = v15;
      a1[5] = v13;
    }

    a3[6] = v66;
    a3[7] = *(_OWORD *)v70;
    *(__int128 *)((char *)a3 + 124) = *(_OWORD *)&v70[12];
    a3[2] = v50;
    a3[3] = v54;
    a3[4] = v58;
    a3[5] = v62;
    *a3 = v42;
    a3[1] = v46;
  }

BOOL sub_100F812B8(__int128 *a1, __int128 *a2)
{
  unint64_t v4 = 0x8E38E38E38E38E39LL * (a2 - a1);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      double v6 = a2 - 9;
      double v7 = sub_100924330((uint64_t)(a2 - 9));
      __int128 v8 = a1[7];
      __int128 v50 = a1[6];
      *(_OWORD *)__int128 v51 = v8;
      *(_OWORD *)&v51[16] = a1[8];
      __int128 v9 = a1[3];
      __int128 v46 = a1[2];
      __int128 v47 = v9;
      __int128 v10 = a1[5];
      __int128 v48 = a1[4];
      __int128 v49 = v10;
      __int128 v11 = a1[1];
      __int128 v44 = *a1;
      __int128 v45 = v11;
      *a1 = *v6;
      __int128 v12 = v6[1];
      __int128 v13 = v6[2];
      __int128 v14 = v6[4];
      a1[3] = v6[3];
      a1[4] = v14;
      a1[1] = v12;
      a1[2] = v13;
      __int128 v15 = v6[5];
      __int128 v16 = v6[6];
      __int128 v17 = v6[7];
      *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)v6 + 124);
      a1[6] = v16;
      a1[7] = v17;
      a1[5] = v15;
      __int128 v18 = *(_OWORD *)v51;
      v6[6] = v50;
      v6[7] = v18;
      *(__int128 *)((char *)v6 + 124) = *(_OWORD *)&v51[12];
      __int128 v19 = v47;
      _OWORD v6[2] = v46;
      void v6[3] = v19;
      __int128 v20 = v49;
      v6[4] = v48;
      v6[5] = v20;
      __int128 v21 = v45;
      BOOL result = 1LL;
      *double v6 = v44;
      v6[1] = v21;
      return result;
    case 3uLL:
      sub_100F80F98(a1, a1 + 9, a2 - 9);
      return 1LL;
    case 4uLL:
      sub_100F81570(a1, a1 + 9, a1 + 18, a2 - 9);
      return 1LL;
    case 5uLL:
      sub_100F80CD8(a1, a1 + 9, a1 + 18, a1 + 27, a2 - 9);
      return 1LL;
    default:
      uint64_t v22 = (uint64_t)(a1 + 18);
      sub_100F80F98(a1, a1 + 9, a1 + 18);
      __int128 v23 = a1 + 27;
      if (a1 + 27 == a2) {
        return 1LL;
      }
      uint64_t v24 = 0LL;
      int v25 = 0;
      break;
  }

  while (1)
  {
    double v26 = sub_100924330((uint64_t)v23);
    if (v26 < sub_100924330(v22))
    {
      __int128 v27 = v23[7];
      __int128 v50 = v23[6];
      *(_OWORD *)__int128 v51 = v27;
      *(_OWORD *)&v51[16] = v23[8];
      __int128 v28 = v23[3];
      __int128 v46 = v23[2];
      __int128 v47 = v28;
      __int128 v29 = v23[5];
      __int128 v48 = v23[4];
      __int128 v49 = v29;
      __int128 v30 = v23[1];
      uint64_t v31 = v24;
      __int128 v44 = *v23;
      __int128 v45 = v30;
      while (1)
      {
        __int128 v32 = (__int128 *)((char *)a1 + v31);
        __int128 v33 = *(__int128 *)((char *)a1 + v31 + 400);
        v32[33] = *(__int128 *)((char *)a1 + v31 + 384);
        v32[34] = v33;
        __int128 v34 = *(__int128 *)((char *)a1 + v31 + 336);
        v32[29] = *(__int128 *)((char *)a1 + v31 + 320);
        v32[30] = v34;
        __int128 v35 = *(__int128 *)((char *)a1 + v31 + 368);
        v32[31] = *(__int128 *)((char *)a1 + v31 + 352);
        v32[32] = v35;
        __int128 v36 = *(__int128 *)((char *)a1 + v31 + 304);
        v32[27] = *(__int128 *)((char *)a1 + v31 + 288);
        v32[28] = v36;
        *(__int128 *)((char *)a1 + v31 + 556) = *(__int128 *)((char *)a1 + v31 + 412);
        if (v31 == -288) {
          break;
        }
        uint64_t v37 = (uint64_t)(v32 + 9);
        double v38 = sub_100924330((uint64_t)&v44);
        v31 -= 144LL;
        if (v38 >= sub_100924330(v37))
        {
          __int128 v39 = (__int128 *)((char *)a1 + v31 + 432);
          goto LABEL_12;
        }
      }

      __int128 v39 = a1;
LABEL_12:
      __int128 v40 = *(_OWORD *)v51;
      v39[6] = v50;
      v39[7] = v40;
      *(__int128 *)((char *)v39 + 124) = *(_OWORD *)&v51[12];
      __int128 v41 = v47;
      uint64_t v39[2] = v46;
      v39[3] = v41;
      __int128 v42 = v49;
      v39[4] = v48;
      v39[5] = v42;
      __int128 v43 = v45;
      ++v25;
      *__int128 v39 = v44;
      v39[1] = v43;
      if (v25 == 8) {
        return v23 + 9 == a2;
      }
    }

    uint64_t v22 = (uint64_t)v23;
    v24 += 144LL;
    v23 += 9;
    if (v23 == a2) {
      return 1LL;
    }
  }

void sub_100F81570(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4)
{
  double v8 = sub_100924330((uint64_t)a4);
  if (v8 < sub_100924330((uint64_t)a3))
  {
    __int128 v47 = a3[6];
    *(_OWORD *)__int128 v50 = a3[7];
    *(_OWORD *)&v50[16] = a3[8];
    __int128 v35 = a3[2];
    __int128 v38 = a3[3];
    __int128 v41 = a3[4];
    __int128 v44 = a3[5];
    __int128 v29 = *a3;
    __int128 v32 = a3[1];
    *a3 = *a4;
    __int128 v9 = a4[1];
    __int128 v10 = a4[2];
    __int128 v11 = a4[4];
    a3[3] = a4[3];
    a3[4] = v11;
    a3[1] = v9;
    a3[2] = v10;
    __int128 v12 = a4[5];
    __int128 v13 = a4[6];
    __int128 v14 = a4[7];
    *(__int128 *)((char *)a3 + 124) = *(__int128 *)((char *)a4 + 124);
    a3[6] = v13;
    a3[7] = v14;
    a3[5] = v12;
    a4[6] = v47;
    a4[7] = *(_OWORD *)v50;
    *(__int128 *)((char *)a4 + 124) = *(_OWORD *)&v50[12];
    a4[2] = v35;
    a4[3] = v38;
    a4[4] = v41;
    a4[5] = v44;
    *a4 = v29;
    a4[1] = v32;
    double v15 = sub_100924330((uint64_t)a3);
    if (v15 < sub_100924330((uint64_t)a2))
    {
      __int128 v48 = a2[6];
      *(_OWORD *)__int128 v51 = a2[7];
      *(_OWORD *)&v51[16] = a2[8];
      __int128 v36 = a2[2];
      __int128 v39 = a2[3];
      __int128 v42 = a2[4];
      __int128 v45 = a2[5];
      __int128 v30 = *a2;
      __int128 v33 = a2[1];
      *a2 = *a3;
      __int128 v16 = a3[1];
      __int128 v17 = a3[2];
      __int128 v18 = a3[4];
      a2[3] = a3[3];
      a2[4] = v18;
      a2[1] = v16;
      a2[2] = v17;
      __int128 v19 = a3[5];
      __int128 v20 = a3[6];
      __int128 v21 = a3[7];
      *(__int128 *)((char *)a2 + 124) = *(__int128 *)((char *)a3 + 124);
      a2[6] = v20;
      a2[7] = v21;
      a2[5] = v19;
      a3[6] = v48;
      a3[7] = *(_OWORD *)v51;
      *(__int128 *)((char *)a3 + 124) = *(_OWORD *)&v51[12];
      a3[2] = v36;
      a3[3] = v39;
      a3[4] = v42;
      a3[5] = v45;
      *a3 = v30;
      a3[1] = v33;
      double v22 = sub_100924330((uint64_t)a2);
      if (v22 < sub_100924330((uint64_t)a1))
      {
        __int128 v49 = a1[6];
        *(_OWORD *)__int128 v52 = a1[7];
        *(_OWORD *)&v52[16] = a1[8];
        __int128 v37 = a1[2];
        __int128 v40 = a1[3];
        __int128 v43 = a1[4];
        __int128 v46 = a1[5];
        __int128 v31 = *a1;
        __int128 v34 = a1[1];
        *a1 = *a2;
        __int128 v23 = a2[1];
        __int128 v24 = a2[2];
        __int128 v25 = a2[4];
        a1[3] = a2[3];
        a1[4] = v25;
        a1[1] = v23;
        a1[2] = v24;
        __int128 v26 = a2[5];
        __int128 v27 = a2[6];
        __int128 v28 = a2[7];
        *(__int128 *)((char *)a1 + 124) = *(__int128 *)((char *)a2 + 124);
        a1[6] = v27;
        a1[7] = v28;
        a1[5] = v26;
        a2[6] = v49;
        a2[7] = *(_OWORD *)v52;
        *(__int128 *)((char *)a2 + 124) = *(_OWORD *)&v52[12];
        a2[2] = v37;
        a2[3] = v40;
        a2[4] = v43;
        a2[5] = v46;
        *a2 = v31;
        a2[1] = v34;
      }
    }
  }

_OWORD *sub_100F81788(_OWORD *a1, _OWORD *a2, void **a3)
{
  uint64_t v3 = a1;
  double v6 = a3;
  if (a1 == a2) {
    return a1;
  }
  unint64_t v4 = a2;
  do
  {
    sub_100F817E8(&v6, v3);
    v3 += 9;
  }

  while (v3 != v4);
  return v4;
}

void ***sub_100F817E8(void ***a1, _OWORD *a2)
{
  unint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1];
  double v6 = *a1;
  unint64_t v9 = (unint64_t)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    unint64_t v17 = 0x8E38E38E38E38E39LL * (((char *)v5 - (_BYTE *)*v4) >> 4);
    unint64_t v18 = v17 + 1;
    if (v17 + 1 > 0x1C71C71C71C71C7LL) {
      sub_100007008();
    }
    unint64_t v19 = 0x8E38E38E38E38E39LL * ((uint64_t)(v8 - (void)*v4) >> 4);
    if (2 * v19 > v18) {
      unint64_t v18 = 2 * v19;
    }
    if (v19 >= 0xE38E38E38E38E3LL) {
      unint64_t v20 = 0x1C71C71C71C71C7LL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20) {
      __int128 v21 = (char *)sub_1002B4F00(v7, v20);
    }
    else {
      __int128 v21 = 0LL;
    }
    double v22 = &v21[144 * v17];
    __int128 v23 = &v21[144 * v20];
    *(_OWORD *)double v22 = *a2;
    __int128 v24 = a2[1];
    __int128 v25 = a2[2];
    __int128 v26 = a2[4];
    *((_OWORD *)v22 + 3) = a2[3];
    *((_OWORD *)v22 + 4) = v26;
    *((_OWORD *)v22 + 1) = v24;
    *((_OWORD *)v22 + 2) = v25;
    __int128 v27 = a2[5];
    __int128 v28 = a2[6];
    __int128 v29 = a2[8];
    *((_OWORD *)v22 + 7) = a2[7];
    *((_OWORD *)v22 + _Block_object_dispose((const void *)(v1 - 128), 8) = v29;
    *((_OWORD *)v22 + 5) = v27;
    *((_OWORD *)v22 + 6) = v28;
    __int128 v16 = v22 + 144;
    __int128 v31 = (char *)*v4;
    __int128 v30 = (char *)v4[1];
    if (v30 != *v4)
    {
      do
      {
        *((_OWORD *)v22 - 9) = *((_OWORD *)v30 - 9);
        __int128 v32 = *((_OWORD *)v30 - 8);
        __int128 v33 = *((_OWORD *)v30 - 7);
        __int128 v34 = *((_OWORD *)v30 - 5);
        *((_OWORD *)v22 - 6) = *((_OWORD *)v30 - 6);
        *((_OWORD *)v22 - 5) = v34;
        *((_OWORD *)v22 - _Block_object_dispose((const void *)(v1 - 128), 8) = v32;
        *((_OWORD *)v22 - 7) = v33;
        __int128 v35 = *((_OWORD *)v30 - 4);
        __int128 v36 = *((_OWORD *)v30 - 3);
        __int128 v37 = *((_OWORD *)v30 - 2);
        *(_OWORD *)(v22 - 20) = *(_OWORD *)(v30 - 20);
        *((_OWORD *)v22 - 3) = v36;
        *((_OWORD *)v22 - 2) = v37;
        *((_OWORD *)v22 - 4) = v35;
        v22 -= 144;
        v30 -= 144;
      }

      while (v30 != v31);
      __int128 v30 = (char *)*v4;
    }

    *unint64_t v4 = v22;
    v4[1] = v16;
    _OWORD v4[2] = v23;
    if (v30) {
      operator delete(v30);
    }
  }

  else
  {
    *uint64_t v5 = *a2;
    __int128 v10 = a2[1];
    __int128 v11 = a2[2];
    __int128 v12 = a2[4];
    void v5[3] = a2[3];
    v5[4] = v12;
    v5[1] = v10;
    v5[2] = v11;
    __int128 v13 = a2[5];
    __int128 v14 = a2[6];
    __int128 v15 = a2[8];
    v5[7] = a2[7];
    v5[8] = v15;
    void v5[5] = v13;
    void v5[6] = v14;
    __int128 v16 = v5 + 9;
  }

  v4[1] = v16;
  return a1;
}

_OWORD *sub_100F81980(uint64_t **a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  uint64_t v7 = (void **)sub_10060372C((uint64_t)a1, &v18, a2);
  unint64_t v8 = *v7;
  if (!*v7)
  {
    unint64_t v9 = (uint64_t **)v7;
    unint64_t v8 = operator new(0xE0uLL);
    id v8[2] = *(_OWORD *)a3;
    *((void *)v8 + 6) = *(void *)(a3 + 16);
    *(_OWORD *)((char *)v8 + 56) = *(_OWORD *)(a3 + 24);
    *((void *)v8 + 9) = *(void *)(a3 + 40);
    *(void *)(a3 + 24) = 0LL;
    *(void *)(a3 + 32) = 0LL;
    *(void *)(a3 + 40) = 0LL;
    __int128 v10 = *a4;
    __int128 v11 = a4[1];
    __int128 v12 = a4[3];
    v8[7] = a4[2];
    _WORD v8[8] = v12;
    void v8[5] = v10;
    v8[6] = v11;
    __int128 v13 = a4[4];
    __int128 v14 = a4[5];
    __int128 v15 = a4[8];
    v8[12] = a4[7];
    v8[13] = v15;
    __int128 v16 = a4[6];
    v8[10] = v14;
    v8[11] = v16;
    v8[9] = v13;
    sub_1000085FC(a1, v18, v9, (uint64_t *)v8);
  }

  return v8;
}

  ;
}

  ;
}

void sub_100F81A6C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100F81B08(_Unwind_Exception *a1)
{
}

void sub_100F81B20()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      _WORD *v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100F81BAC(_Unwind_Exception *a1)
{
}

void *sub_100F81BC4()
{
  qword_10199F840 = *(void *)sub_100F4CD80();
  BOOL result = sub_100F4CD80();
  qword_10199F848 = result[1];
  return result;
}

uint64_t sub_100F81BF4(uint64_t a1, __int128 *a2, __int128 *a3)
{
  uint64_t v6 = sub_10036E038(a1);
  *(void *)uint64_t v6 = &off_10188FD28;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(v6 + 40), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v7 = *a2;
    *(void *)(v6 + 56) = *((void *)a2 + 2);
    *(_OWORD *)(v6 + 40) = v7;
  }

  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 64), *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v8 = *a3;
    *(void *)(a1 + sub_100F6A7D8(v1 + 80) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 64) = v8;
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  return a1;
}

void sub_100F81C9C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F81CD4(uint64_t result)
{
  *(void *)(result + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  return result;
}

uint64_t sub_100F81CDC(uint64_t result, int a2)
{
  if (a2) {
    ++*(_DWORD *)(result + 88);
  }
  else {
    ++*(_DWORD *)(result + 92);
  }
  return result;
}

double sub_100F81D00(uint64_t a1)
{
  v6[0] = @"databaseNumValid";
  v7[0] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 88));
  v6[1] = @"databaseNumInvalid";
  v7[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 92));
  _OWORD v6[2] = @"databaseName";
  uint64_t v2 = (void *)(a1 + 40);
  v7[2] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v2);
  void v6[3] = @"databaseClient";
  uint64_t v3 = (void *)(a1 + 64);
  v7[3] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100F81E38;
  void v5[3] = &unk_101820740;
  v5[4] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v7,  v6,  4LL);
  *(void *)&double result = AnalyticsSendEventLazy(@"com.apple.clx.wifiloc.database", v5).n128_u64[0];
  return result;
}

uint64_t sub_100F81E38(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_100F81E40(void **__p)
{
  void *__p = &off_10188FD28;
  operator delete(__p);
}

void **sub_100F81E8C(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2) {
    sub_100381E48((int)a1, v2);
  }
  return a1;
}

uint64_t sub_100F81EC0(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    __int128 v10 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    LOWORD(v26) = 0;
    unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "pTimeStamp,Invalid pointer",  &v26,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000LL)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v6 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)uint64_t buf = 134349056;
      double v29 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Mach absolute time cannot be negative or infinite: %{public}lf",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    double v8 = *a1;
    int v26 = 134349056;
    double v27 = v8;
    unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Mach absolute time cannot be negative or infinite: %{public}lf",  &v26,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  *(_DWORD *)(a2 + 36) |= 2u;
  *(double *)(a2 + 16) = v4;
  if ((a3 & 1) != 0) {
    return 1LL;
  }
  __int128 v14 = (_OWORD *)qword_10199F870;
  if (!qword_10199F870)
  {
    __int128 v14 = operator new(0x48uLL);
    *__int128 v14 = 0u;
    v14[1] = 0u;
    _DWORD v14[2] = 0u;
    v14[3] = 0u;
    *((void *)v14 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    qword_10199F870 = (uint64_t)v14;
  }

  unint64_t v25 = 0xBFF0000000000000LL;
  BOOL v11 = sub_1007BA8F0((uint64_t)v14, a1, (double *)&v25);
  if (v11)
  {
    unint64_t v15 = v25;
    *(_DWORD *)(a2 + 36) |= 4u;
    *(void *)(a2 + 24) = v15;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    __int128 v16 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
    {
      double v17 = *a1;
      *(_DWORD *)uint64_t buf = 134217984;
      double v29 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Mach absolute to mach continuous time conversion failed: %lf",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      double v22 = *a1;
      int v26 = 134217984;
      double v27 = v22;
      __int128 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Mach absolute to mach continuous time conversion failed: %lf",  COERCE_DOUBLE(&v26));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v23);
    }
  }

  unint64_t v24 = 0xBFF0000000000000LL;
  if (sub_1007BACC0(qword_10199F870, a1, (double *)&v24))
  {
    unint64_t v18 = v24;
    *(_DWORD *)(a2 + 36) |= 1u;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v18;
    return v11;
  }

  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  unint64_t v19 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    double v20 = *a1;
    *(_DWORD *)uint64_t buf = 134217984;
    double v29 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Mach absolute to CF absolute time conversion failed: %lf",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    double v21 = *a1;
    int v26 = 134217984;
    double v27 = v21;
    unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Mach absolute to CF absolute time conversion failed: %lf",  COERCE_DOUBLE(&v26));
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveMachAbsoluteTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
LABEL_45:
  }

  return 0LL;
}

double sub_100F82504(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v4 = sub_100F8292C((unsigned int *)a1);
    if (!sub_1001D6430(v4)) {
      sub_10122FA04();
    }
    int v5 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    *(_DWORD *)(a2 + 152) = v5 | 3;
    uint64_t v6 = *(char **)(a2 + 8);
    if (!v6)
    {
      uint64_t v6 = (char *)operator new(0x20uLL);
      sub_1001D2424(v6);
      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v6;
    }

    *((_DWORD *)v6 + 7) |= 1u;
    *(_DWORD *)(a2 + 152) |= 2u;
    *((_DWORD *)v6 + 7) |= 2u;
    *(_OWORD *)(v6 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 4);
    int v7 = *(_DWORD *)(a2 + 152);
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 20);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 36);
    *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 152) = v7 | 0x3FC;
    *(_OWORD *)(a2 + sub_1011C52D0(v23 - 72) = *(_OWORD *)(a1 + 68);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 84);
    uint64_t v8 = *(void *)(a1 + 88);
    *(_DWORD *)(a2 + 152) = v7 | 0xFFC;
    *(void *)(a2 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
    unsigned int v9 = sub_100F82B00((unsigned int *)(a1 + 96));
    if (!sub_1001D2F3C(v9)) {
      sub_10122F9DC();
    }
    int v10 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 104) = v9;
    *(_DWORD *)(a2 + 152) = v10 | 0x3000;
    BOOL v11 = *(char **)(a2 + 96);
    if (!v11)
    {
      BOOL v11 = (char *)operator new(0x20uLL);
      sub_1001D2424(v11);
      *(void *)(a2 + 96) = v11;
    }

    *((_DWORD *)v11 + 7) |= 1u;
    *(_DWORD *)(a2 + 152) |= 0x2000u;
    *((_DWORD *)v11 + 7) |= 2u;
    *(_OWORD *)(v11 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 100);
    uint64_t v12 = *(void *)(a1 + 116);
    int v13 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 152) = v13 | 0x4000;
    *(void *)(a2 + 112) = v12;
    int v14 = *(_DWORD *)(a1 + 124);
    *(_DWORD *)(a2 + 152) = v13 | 0xC000;
    *(_DWORD *)(a2 + 10_Block_object_dispose((const void *)(v1 - 128), 8) = v14;
    int v15 = sub_100F82CC8((unsigned int *)(a1 + 128));
    if (!sub_1001D644C(v15)) {
      sub_10122F9B4();
    }
    *(_DWORD *)(a2 + 152) |= 0x10000u;
    *(_DWORD *)(a2 + 120) = v15;
    unsigned int v16 = sub_100F82EAC((unsigned int *)(a1 + 132));
    if (!sub_1000641E0(v16)) {
      sub_10122F98C();
    }
    *(_DWORD *)(a2 + 152) |= 0x20000u;
    *(_DWORD *)(a2 + 124) = v16;
    unsigned int v17 = sub_100F82EAC((unsigned int *)(a1 + 136));
    if (!sub_1000641E0(v17)) {
      sub_10122F964();
    }
    *(_DWORD *)(a2 + 152) |= 0x40000u;
    *(_DWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v17;
    *(_DWORD *)uint64_t buf = 0;
    switch(*(_DWORD *)(a1 + 140))
    {
      case 1:
        int v18 = 1;
        goto LABEL_26;
      case 2:
        int v18 = 2;
        goto LABEL_26;
      case 3:
        int v18 = 3;
        goto LABEL_26;
      case 4:
        int v18 = 4;
        goto LABEL_26;
      case 6:
        int v18 = 6;
LABEL_26:
        *(_DWORD *)uint64_t buf = v18;
        break;
      default:
        break;
    }

    int v22 = sub_100F83074((int *)buf);
    if (!sub_1001D7604(v22)) {
      sub_10122F93C();
    }
    int v23 = *(_DWORD *)(a2 + 152);
    *(_DWORD *)(a2 + 132) = v22;
    double result = *(double *)(a1 + 144);
    *(double *)(a2 + 136) = result;
    char v24 = *(_BYTE *)(a1 + 152);
    *(_DWORD *)(a2 + 152) = v23 | 0x380000;
    *(_BYTE *)(a2 + 144) = v24;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    unint64_t v19 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "pLocation,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v25[0] = 0;
      double v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pLocation,Invalid pointer",  v25,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLDaemonLocationToProtobuf(const CLDaemonLocation &, CLP::LogEntry::PrivateData::DaemonLocation *)",  "%s\n",  v21);
    }
  }

  return result;
}

void sub_100F828F4(_Unwind_Exception *a1)
{
}

uint64_t sub_100F8292C(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result - 1) >= 2 && (_DWORD)result != 0xFFFF)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    unsigned int v4 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v11 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Received unhandled client location suitability type: %{public}d",  buf,  8u);
    }

    BOOL v6 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v6)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v7 = *a1;
      v9[0] = 67240192;
      v9[1] = v7;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled client location suitability type: %{public}d",  v9,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocation_ClientLocationSuitabilityType ConvertCLClientLocationSuitabilityTypeT oProtobuf(const CLClientLocationSuitability &)",  "%s\n",  v8);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F82B00(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 0xE)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled location type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled location type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::LocationType ConvertCLLocationTypeToProtobuf(const CLLocationType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F82CC8(unsigned int *a1)
{
  uint64_t result = *a1;
  if (((result - 25) > 0x32 || ((1LL << (result - 25)) & 0x4000002000001LL) == 0)
    && (_DWORD)result != 0)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    BOOL v5 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v11 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Received unhandled location integrity type: %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v7 = *a1;
      v9[0] = 67240192;
      v9[1] = v7;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled location integrity type: %{public}d",  v9,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocation_LocationIntegrityType ConvertCLLocationIntegrityTypeToProtobuf(const CLLocationIntegrity &)",  "%s\n",  v8);
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t sub_100F82EAC(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled client location reference frame type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled client location reference frame type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::ClientLocationReferenceFrameType ConvertCLClientLocationReferenceTypeToProtobuf(cons t CLClientLocationReferenceFrame &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F83074(int *a1)
{
  uint64_t v2 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  uint64_t v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled signal environment type: %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled signal environment type: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::SignalEnvironment_SignalEnvironmentType ConvertCLSignalEnvironmentTypeToProtobuf(const CLSignalEnvironmentProvider_Type::SignalEnvironmentType &)",  "%s\n",  v7);
  }

  return 0xFFFFFFFFLL;
}

void sub_100F83250(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(a2 + 364);
    *(_OWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)a1;
    *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 16);
    *(void *)(a2 + 40) = *(void *)(a1 + 32);
    *(void *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = *(void *)(a1 + 40);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 48);
    char v5 = *(_BYTE *)(a1 + 52);
    *(_DWORD *)(a2 + 364) = v4 | 0x1FF;
    *(_BYTE *)(a2 + 112) = v5;
    unsigned int v6 = sub_100F839E4((unsigned int *)(a1 + 56));
    if (!sub_10006ED58(v6)) {
      sub_10122FBBC();
    }
    int v7 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 60) = v6;
    *(_DWORD *)(a2 + 364) = v7 | 0x600;
    uint64_t v8 = *(char **)(a2 + 64);
    if (!v8)
    {
      uint64_t v8 = (char *)operator new(0x20uLL);
      sub_1001D2424(v8);
      *(void *)(a2 + 64) = v8;
    }

    *((_DWORD *)v8 + 7) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x400u;
    *((_DWORD *)v8 + 7) |= 2u;
    *(_OWORD *)(v8 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 80);
    int v10 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 364) = v10 | 0x800;
    *(void *)(a2 + sub_1011C52D0(v23 - 72) = v9;
    int v11 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a2 + 364) = v10 | 0x1800;
    *(_DWORD *)(a2 + sub_100F6A7D8(v1 + 80) = v11;
    *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 92);
    *(_BYTE *)(a2 + 113) = *(_BYTE *)(a1 + 96);
    *(_DWORD *)(a2 + 364) = v10 | 0x807800;
    uint64_t v12 = *(char **)(a2 + 136);
    if (!v12)
    {
      uint64_t v12 = (char *)operator new(0x28uLL);
      sub_1001D2480((uint64_t)v12);
      *(void *)(a2 + 136) = v12;
    }

    *((_DWORD *)v12 + 8) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    *((_DWORD *)v12 + 8) |= 2u;
    *(_OWORD *)(v12 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 104);
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    char v13 = *(_BYTE *)(a1 + 120);
    *((_DWORD *)v12 + 8) |= 4u;
    v12[24] = v13;
    *(_DWORD *)(a2 + 364) |= 0x800000u;
    char v14 = *(_BYTE *)(a1 + 121);
    *((_DWORD *)v12 + 8) |= 8u;
    v12[25] = v14;
    *(_DWORD *)(a2 + 364) |= 0x8000u;
    int v15 = *(char **)(a2 + 88);
    if (!v15)
    {
      int v15 = (char *)operator new(0x20uLL);
      sub_1001D249C(v15);
      *(void *)(a2 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = v15;
    }

    *((_DWORD *)v15 + 7) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x8000u;
    *((_DWORD *)v15 + 7) |= 2u;
    *(_OWORD *)(v15 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 296);
    int v16 = sub_100F83BB0((unsigned int *)(a1 + 312));
    if (!sub_1001D8D58(v16)) {
      sub_10122FB94();
    }
    int v17 = *(_DWORD *)(a2 + 364);
    *(_DWORD *)(a2 + 96) = v16;
    *(_DWORD *)(a2 + 100) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a2 + 364) = v17 | 0x70000;
    int v18 = *(char **)(a2 + 104);
    if (!v18)
    {
      int v18 = (char *)operator new(0x20uLL);
      sub_1001D2424(v18);
      *(void *)(a2 + 104) = v18;
    }

    *((_DWORD *)v18 + 7) |= 1u;
    *(_DWORD *)(a2 + 364) |= 0x40000u;
    *((_DWORD *)v18 + 7) |= 2u;
    *(_OWORD *)(v18 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 320);
    *(_DWORD *)(a2 + 364) |= 0x180000u;
    *(_OWORD *)(a2 + 120) = *(_OWORD *)(a1 + 336);
    unsigned int v19 = sub_100F83D7C((unsigned int *)(a1 + 352));
    if (!sub_1000641E0(v19)) {
      sub_10122FB6C();
    }
    *(_DWORD *)(a2 + 116) = v19;
    *(_BYTE *)(a2 + 114) = *(_BYTE *)(a1 + 356);
    *(_OWORD *)(a2 + 144) = *(_OWORD *)(a1 + 360);
    *(_OWORD *)(a2 + 160) = *(_OWORD *)(a1 + 376);
    *(_OWORD *)(a2 + 176) = *(_OWORD *)(a1 + 496);
    *(_BYTE *)(a2 + 115) = *(_BYTE *)(a1 + 512);
    *(void *)(a2 + 192) = *(void *)(a1 + 392);
    *(void *)(a2 + 200) = *(void *)(a1 + 416);
    *(_BYTE *)(a2 + 276) = *(_BYTE *)(a1 + 424);
    *(int8x8_t *)(a2 + 364) = vorr_s8(*(int8x8_t *)(a2 + 364), (int8x8_t)0x7FF600000LL);
    double v20 = *(char **)(a2 + 208);
    if (!v20)
    {
      double v20 = (char *)operator new(0x20uLL);
      sub_1001D2424(v20);
      *(void *)(a2 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v20;
    }

    *((_DWORD *)v20 + 7) |= 1u;
    *(_DWORD *)(a2 + 368) |= 4u;
    *((_DWORD *)v20 + 7) |= 2u;
    *(_OWORD *)(v20 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 432);
    uint64_t v21 = *(void *)(a1 + 448);
    *(_DWORD *)(a2 + 368) |= 8u;
    *(void *)(a2 + 216) = v21;
    unsigned int v22 = sub_100F82EAC((unsigned int *)(a1 + 456));
    if (!sub_1000641E0(v22)) {
      sub_10122FB44();
    }
    int v23 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 2sub_1011C52D0(v23 - 72) = v22;
    *(_OWORD *)(a2 + 224) = *(_OWORD *)(a1 + 480);
    *(void *)(a2 + 240) = *(void *)(a1 + 600);
    *(_OWORD *)(a2 + 24_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 400);
    *(_BYTE *)(a2 + 277) = *(_BYTE *)(a1 + 425);
    *(void *)(a2 + 264) = *(void *)(a1 + 464);
    uint64_t v24 = *(void *)(a1 + 472);
    *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = v23 | 0x1FF0;
    *(void *)(a2 + 2sub_100F6A7D8(v1 + 80) = v24;
    unint64_t v25 = *(uint64_t **)(a1 + 520);
    if (v25)
    {
      uint64_t v26 = *v25;
      uint64_t v27 = v25[1];
      if (*v25 != v27)
      {
        do
        {
          uint64_t v28 = *(int *)(a2 + 296);
          int v29 = *(_DWORD *)(a2 + 300);
          if ((int)v28 >= v29)
          {
            if (v29 == *(_DWORD *)(a2 + 304))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 288),  v29 + 1);
              int v29 = *(_DWORD *)(a2 + 300);
            }

            *(_DWORD *)(a2 + 300) = v29 + 1;
            __int128 v31 = (__n128 *)sub_100F8D858();
            uint64_t v32 = *(void *)(a2 + 288);
            uint64_t v33 = *(int *)(a2 + 296);
            *(_DWORD *)(a2 + 296) = v33 + 1;
            *(void *)(v32 + 8 * v33) = v31;
          }

          else
          {
            uint64_t v30 = *(void *)(a2 + 288);
            *(_DWORD *)(a2 + 296) = v28 + 1;
            __int128 v31 = *(__n128 **)(v30 + 8 * v28);
          }

          sub_100F83F44(v26, v31);
          v26 += 28LL;
        }

        while (v26 != v27);
      }
    }

    unsigned int v34 = sub_100F83FAC((unsigned int *)(a1 + 536));
    if (!sub_1000641E0(v34)) {
      sub_10122FB1C();
    }
    int v35 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 312) = v34;
    *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = v35 | 0xC000;
    __int128 v36 = *(char **)(a2 + 320);
    if (!v36)
    {
      __int128 v36 = (char *)operator new(0x30uLL);
      sub_1001D2554((uint64_t)v36);
      *(void *)(a2 + 320) = v36;
    }

    *((_DWORD *)v36 + 10) |= 1u;
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    *((_DWORD *)v36 + 10) |= 2u;
    *(_OWORD *)(v36 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 544);
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    uint64_t v37 = *(void *)(a1 + 560);
    *((_DWORD *)v36 + 10) |= 4u;
    *((void *)v36 + 3) = v37;
    *(_DWORD *)(a2 + 368) |= 0x8000u;
    int v38 = sub_100F83BB0((unsigned int *)(a1 + 568));
    if (!sub_1001D8D58(v38)) {
      sub_10122FA54();
    }
    *((_DWORD *)v36 + 10) |= 8u;
    *((_DWORD *)v36 + _Block_object_dispose((const void *)(v1 - 128), 8) = v38;
    unsigned int v39 = sub_100F84174((unsigned __int8 *)(a1 + 576));
    if (!sub_1000641E0(v39)) {
      sub_10122FAF4();
    }
    int v40 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 316) = v39;
    *(void *)(a2 + 32_Block_object_dispose((const void *)(v1 - 128), 8) = *(void *)(a1 + 584);
    uint64_t v41 = *(void *)(a1 + 592);
    *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = v40 | 0x70000;
    *(void *)(a2 + 336) = v41;
    unsigned int v42 = sub_100F8433C((unsigned __int8 *)(a1 + 609));
    if (!sub_10006ED58(v42)) {
      sub_10122FACC();
    }
    int v43 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 344) = v42;
    char v44 = *(_BYTE *)(a1 + 610);
    *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = v43 | 0x180000;
    *(_BYTE *)(a2 + 27_Block_object_dispose((const void *)(v1 - 128), 8) = v44;
    unsigned int v45 = sub_100F84504((unsigned int *)(a1 + 612));
    if (!sub_1000641E0(v45)) {
      sub_10122FAA4();
    }
    *(_DWORD *)(a2 + 368) |= 0x200000u;
    *(_DWORD *)(a2 + 34_Block_object_dispose((const void *)(v1 - 128), 8) = v45;
    unsigned int v46 = sub_100F846CC((unsigned int *)(a1 + 616));
    if (!sub_1001D2F54(v46)) {
      sub_10122FA7C();
    }
    int v47 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)(a2 + 352) = v46;
    *(_BYTE *)(a2 + 279) = *(_BYTE *)(a1 + 608);
    char v48 = *(_BYTE *)(a1 + 636);
    *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = v47 | 0x1C00000;
    *(_BYTE *)(a2 + 356) = v48;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    __int128 v49 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "pLocationPrivate,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v51[0] = 0;
      __int128 v50 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pLocationPrivate,Invalid pointer",  v51,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLDaemonLocationPrivateToProtobuf(const CLDaemonLocationPrivate &, CLP::LogEntry::PrivateData::Daemo nLocationPrivate *)",  "%s\n",  v50);
    }
  }

void sub_100F839B4(_Unwind_Exception *a1)
{
}

uint64_t sub_100F839E4(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result - 1) >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled client location match quality type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled client location match quality type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_MatchQualityType ConvertCLClientLocationMatchQualityTypeToProt obuf(const CLClientLocationMatchQuality &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F83BB0(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result + 1) >= 4)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled undulation model type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled undulation model type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_UndulationModelType ConvertCLUndulationModelTypeToProtobuf(con st CLUndulationModelType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F83D7C(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled client location origin device type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled client location origin device type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_ClientLocationOriginDeviceType ConvertCLClientLocationOriginDe viceTypeToProtobuf(const CLClientLocationOriginDevice &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

__n128 sub_100F83F44(uint64_t a1, __n128 *a2)
{
  unsigned int v4 = sub_100F8C79C((int *)a1);
  if (!sub_1001D2F48(v4)) {
    sub_10122FA2C();
  }
  unsigned __int32 v5 = a2[2].n128_u32[2];
  a2[2].n128_u32[2] = v5 | 1;
  unsigned __int32 v6 = *(_DWORD *)(a1 + 4);
  a2->n128_u32[2] = v4;
  a2->n128_u32[3] = v6;
  __n128 result = *(__n128 *)(a1 + 8);
  a2[1] = result;
  a2[2].n128_u16[0] = *(_WORD *)(a1 + 24);
  a2[2].n128_u32[2] = v5 | 0xFF;
  return result;
}

uint64_t sub_100F83FAC(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled daemon location private gnss content type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled daemon location private gnss content type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_GnssContent ConvertCLDaemonLocationPrivateGnssContentTypeToPro tobuf(const CLDaemonLocationPrivate::GnssContent &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F84174(unsigned __int8 *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled daemon location private position context type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled daemon location private position context type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_PositionContextStateType ConvertCLDaemonLocationPrivatePositio nContextStateTypeToProtobuf(const CLDaemonLocationPrivate::PositionContextStateType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F8433C(unsigned __int8 *a1)
{
  uint64_t result = *a1;
  if (result >= 4)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled daemon location private map matcher type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled daemon location private map matcher type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_MapMatcherType ConvertCLDaemonLocationPrivateMapMatcherTypeToP rotobuf(const CLDaemonLocationPrivate::MapMatcherType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F84504(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled daemon location private loi location accuracy type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled daemon location private loi location accuracy type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::DaemonLocationPrivate_LoiLocationSourceAccuracy ConvertCLDaemonLocationPrivateLoiLoc ationSourceAccuracyTypeToProtobuf(const CLDaemonLocationPrivate::LoiLocationSourceAccuracy &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F846CC(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 5)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled client batched location fix type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled client batched location fix type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::BatchedLocationFixType ConvertCLBatchedLocationFixTypeToProtobuf(const CLBatchedLocationFixType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100F84894(uint64_t a1, uint64_t a2)
{
  char v3 = BYTE4(a1);
  uint64_t v7 = a1;
  unsigned int v4 = sub_100F82B00((unsigned int *)&v7);
  BOOL result = sub_1001D2F3C(v4);
  if (!result) {
    sub_10122FBE4();
  }
  int v6 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
  *(_DWORD *)(a2 + 20) = v6 | 3;
  *(_BYTE *)(a2 + 12) = v3;
  return result;
}

uint64_t sub_100F848F8(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v10 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    LOWORD(v24) = 0;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "pTimeStamp,Invalid pointer",  &v24,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000LL)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)uint64_t buf = 134349056;
      double v27 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "CF absolute time cannot be negative or infinite: %{public}lf",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    double v8 = *a1;
    int v24 = 134349056;
    double v25 = v8;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "CF absolute time cannot be negative or infinite: %{public}lf",  &v24,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  *(_DWORD *)(a2 + 36) |= 1u;
  *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
  if ((a3 & 1) != 0) {
    return 1LL;
  }
  char v14 = (_OWORD *)qword_10199F870;
  if (!qword_10199F870)
  {
    char v14 = operator new(0x48uLL);
    *char v14 = 0u;
    v14[1] = 0u;
    _DWORD v14[2] = 0u;
    v14[3] = 0u;
    *((void *)v14 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    qword_10199F870 = (uint64_t)v14;
  }

  *(double *)&unint64_t v23 = -1.0;
  BOOL v11 = sub_1007BAEA8((uint64_t)v14, a1, (double *)&v23);
  if (v11)
  {
    unint64_t v15 = v23;
    *(_DWORD *)(a2 + 36) |= 2u;
    *(void *)(a2 + 16) = v15;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v16 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
    {
      double v17 = *a1;
      *(_DWORD *)uint64_t buf = 134217984;
      double v27 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Error: CF absolute to mach absolute time conversion failed: %lf",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      double v20 = *a1;
      int v24 = 134217984;
      double v25 = v20;
      uint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Error: CF absolute to mach absolute time conversion failed: %lf",  COERCE_DOUBLE(&v24));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v21);
    }
  }

  unint64_t v22 = 0xBFF0000000000000LL;
  if (sub_1007BA8F0(qword_10199F870, (double *)&v23, (double *)&v22))
  {
    unint64_t v18 = v22;
    *(_DWORD *)(a2 + 36) |= 4u;
    *(void *)(a2 + 24) = v18;
    return v11;
  }

  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  unsigned int v19 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    double v27 = *(double *)&v23;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Error: Mach absolute to mach continuous time conversion failed: %lf",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v24 = 134217984;
    double v25 = *(double *)&v23;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Error: Mach absolute to mach continuous time conversion failed: %lf",  COERCE_DOUBLE(&v24));
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveCFAbsoluteTimeToProtobuf(const CFAbsoluteTime &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
LABEL_45:
  }

  return 0LL;
}

uint64_t sub_100F84F3C(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled gnss availability prediction state,%{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    double v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled gnss availability prediction state,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::GnssAvailabilityPrediction_GnssAvailability ConvertCLGnssAvailabilityStateToProtobuf(c onst CLGnssAvailabilityPredictor::PredictionType &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8510C(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled gnss availability meas source,%{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    double v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled gnss availability meas source,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::GnssAvailabilityPrediction_MeasurementSource ConvertCLGnssAvailabilityMeasurementSourc eToProtobuf(const CLGnssAvailabilityPredictor::MeasurementSource &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F852DC(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    char v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled signal quality type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      double v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled signal quality type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::Location_SignalQualityType ConvertCLSignalQualityTypeToProtobuf(const CLLocationProv ider_Type::SignalQuality &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F854A4(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    char v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled motion detected type: %{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      double v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled motion detected type: %{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::Location_MotionDetectedType ConvertCLMotionDetectedTypeToProtobuf(const CLLocationPr ovider_Type::MotionDetected &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

__n128 sub_100F8566C(uint64_t a1, uint64_t a2, uint64_t *a3, double *a4)
{
  if (a2)
  {
    if (sub_100ECF4A4(a1, *a4, 6.0))
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      double v7 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *a3;
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)uint64_t buf = 134218240;
        uint64_t v38 = v8;
        __int16 v39 = 2048;
        uint64_t v40 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%.2lf,RouteHintsInPositionProto,Received stale data,routeHintTime,%.2lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        uint64_t v11 = *a3;
        uint64_t v12 = *(void *)(a1 + 32);
        int v33 = 134218240;
        uint64_t v34 = v11;
        __int16 v35 = 2048;
        uint64_t v36 = v12;
        LODWORD(v32) = 22;
        char v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "%.2lf,RouteHintsInPositionProto,Received stale data,routeHintTime,%.2lf",  COERCE_DOUBLE(&v33),  v32);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void ConvertCLMapMatchingRouteHintToProtobuf(const CLMapsRouteHintData &, CLP::LogEntry::PrivateData::MapMatch ingRouteHint *, const CFAbsoluteTime &, const CFTimeInterval &)",  "%s\n",  v13);
LABEL_19:
      }
    }

    else
    {
      *(_DWORD *)(a2 + 60) |= 1u;
      unint64_t v15 = *(void **)(a2 + 8);
      if (!v15)
      {
        unint64_t v15 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v15);
        *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v15;
      }

      if ((sub_100F848F8((double *)(a1 + 32), (uint64_t)v15, 0) & 1) == 0)
      {
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        int v16 = (os_log_s *)qword_101934918;
        if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert Map matching route hint event receipt CF time to protobuf",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          LOWORD(v33) = 0;
          uint64_t v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert Map matching route hint event receipt CF time to protobuf",  &v33,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMapMatchingRouteHintToProtobuf(const CLMapsRouteHintData &, CLP::LogEntry::PrivateData::MapMat chingRouteHint *, const CFAbsoluteTime &, const CFTimeInterval &)",  "%s\n",  v30);
        }

        (*(void (**)(void *))(*(void *)v15 + 32LL))(v15);
      }

      *(_DWORD *)(a2 + 60) |= 2u;
      double v17 = *(void **)(a2 + 16);
      if (!v17)
      {
        double v17 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v17);
        *(void *)(a2 + 16) = v17;
      }

      if ((sub_100F85D90((double *)(a1 + 40), (uint64_t)v17, 0) & 1) == 0)
      {
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        unint64_t v18 = (os_log_s *)qword_101934918;
        if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert Map matching route hint applicable mach continuous time to protobuf",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          LOWORD(v33) = 0;
          LODWORD(v32) = 2;
          __int128 v31 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert Map matching route hint applicable mach continuous time to protobuf",  &v33,  *(void *)&v32);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMapMatchingRouteHintToProtobuf(const CLMapsRouteHintData &, CLP::LogEntry::PrivateData::MapMat chingRouteHint *, const CFAbsoluteTime &, const CFTimeInterval &)",  "%s\n",  v31);
        }

        (*(void (**)(void *))(*(void *)v17 + 32LL))(v17);
      }

      unsigned int v19 = sub_100F863D4((int *)a1);
      if (!sub_1001D2F48(v19)) {
        sub_10122FF7C();
      }
      *(_DWORD *)(a2 + 60) |= 4u;
      *(_DWORD *)(a2 + 24) = v19;
      unsigned int v20 = sub_100F863D4((int *)(a1 + 4));
      if (!sub_1001D2F48(v20)) {
        sub_10122FF54();
      }
      *(_DWORD *)(a2 + 60) |= 8u;
      *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v20;
      uint64_t v21 = *(void *)(a1 + 8);
      for (uint64_t i = *(void *)(a1 + 16); v21 != i; v21 += 40LL)
      {
        int v23 = *(_DWORD *)(a2 + 44);
        uint64_t v24 = *(int *)(a2 + 40);
        if ((int)v24 >= v23)
        {
          if (v23 == *(_DWORD *)(a2 + 48))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 32),  v23 + 1);
            int v23 = *(_DWORD *)(a2 + 44);
          }

          *(_DWORD *)(a2 + 44) = v23 + 1;
          uint64_t v26 = (__n128 *)sub_100F8D898();
          uint64_t v27 = *(void *)(a2 + 32);
          uint64_t v28 = *(int *)(a2 + 40);
          *(_DWORD *)(a2 + 40) = v28 + 1;
          *(void *)(v27 + 8 * v2_Block_object_dispose((const void *)(v1 - 128), 8) = v26;
        }

        else
        {
          uint64_t v25 = *(void *)(a2 + 32);
          *(_DWORD *)(a2 + 40) = v24 + 1;
          uint64_t v26 = *(__n128 **)(v25 + 8 * v24);
        }

        unsigned __int32 v29 = v26[3].n128_u32[1];
        v26->n128_u64[1] = *(void *)v21;
        v26[1] = *(__n128 *)(v21 + 8);
        v26[3].n128_u32[1] = v29 | 0x1F;
        __n128 result = *(__n128 *)(v21 + 24);
        v26[2] = result;
      }
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    char v14 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "RouteHintsInPositionProto,pRouteHintMsg,Invalid pointer",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      LOWORD(v33) = 0;
      char v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "RouteHintsInPositionProto,pRouteHintMsg,Invalid pointer",  &v33,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMapMatchingRouteHintToProtobuf(const CLMapsRouteHintData &, CLP::LogEntry::PrivateData::MapMatchin gRouteHint *, const CFAbsoluteTime &, const CFTimeInterval &)",  "%s\n",  v13);
      goto LABEL_19;
    }
  }

  return result;
}

void sub_100F85D70(_Unwind_Exception *a1)
{
}

uint64_t sub_100F85D90(double *a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v10 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "pTimeStamp,Invalid pointer", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    LOWORD(v24) = 0;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "pTimeStamp,Invalid pointer",  &v24,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  double v4 = *a1;
  if (*a1 < 0.0 || (*(void *)a1 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000LL)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a1;
      *(_DWORD *)uint64_t buf = 134349056;
      double v27 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Mach continuous time cannot be negative or infinite: %{public}lf",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    double v8 = *a1;
    int v24 = 134349056;
    double v25 = v8;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Mach continuous time cannot be negative or infinite: %{public}lf",  &v24,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
    goto LABEL_45;
  }

  *(_DWORD *)(a2 + 36) |= 4u;
  *(double *)(a2 + 24) = v4;
  if ((a3 & 1) != 0) {
    return 1LL;
  }
  char v14 = (_OWORD *)qword_10199F870;
  if (!qword_10199F870)
  {
    char v14 = operator new(0x48uLL);
    *char v14 = 0u;
    v14[1] = 0u;
    _DWORD v14[2] = 0u;
    v14[3] = 0u;
    *((void *)v14 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    qword_10199F870 = (uint64_t)v14;
  }

  *(double *)&unint64_t v23 = -1.0;
  BOOL v11 = sub_1007BAAD8((uint64_t)v14, a1, (double *)&v23);
  if (v11)
  {
    unint64_t v15 = v23;
    *(_DWORD *)(a2 + 36) |= 2u;
    *(void *)(a2 + 16) = v15;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v16 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
    {
      double v17 = *a1;
      *(_DWORD *)uint64_t buf = 134217984;
      double v27 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Error: mach continuous to mach absolute time conversion failed: %lf",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      double v20 = *a1;
      int v24 = 134217984;
      double v25 = v20;
      uint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Error: mach continuous to mach absolute time conversion failed: %lf",  COERCE_DOUBLE(&v24));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v21);
    }
  }

  unint64_t v22 = 0xBFF0000000000000LL;
  if (sub_1007BACC0(qword_10199F870, (double *)&v23, (double *)&v22))
  {
    unint64_t v18 = v22;
    *(_DWORD *)(a2 + 36) |= 1u;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v18;
    return v11;
  }

  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  unsigned int v19 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134217984;
    double v27 = *(double *)&v23;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Error: Mach absolute to CF absolute time conversion failed: %lf",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v24 = 134217984;
    double v25 = *(double *)&v23;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "Error: Mach absolute to CF absolute time conversion failed: %lf",  COERCE_DOUBLE(&v24));
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL ConvertLiveMachContinousTimeToProtobuf(const CFTimeInterval &, CLP::LogEntry::PrivateData::TimeStamp *, BOOL)",  "%s\n",  v9);
LABEL_45:
  }

  return 0LL;
}

uint64_t sub_100F863D4(int *a1)
{
  uint64_t v1 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  double v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Received unhandled maps route type,%{public}d",  buf,  8u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v7 = *a1;
    v9[0] = 67240192;
    v9[1] = v7;
    double v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled maps route type,%{public}d",  v9,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::MapMatchingRouteHint_RoutingType ConvertCLMapsRouteHintTypeToProtobuf(const CLClientLo cationRouteHintType &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

void sub_100F865AC(uint64_t a1, uint64_t a2, char a3)
{
  if (a2)
  {
    int v6 = sub_100F86BF4((unsigned int *)a1);
    if ((sub_1001D2F60(v6) & 1) == 0) {
      sub_10122FDC4();
    }
    *(_DWORD *)(a2 + 92) |= 1u;
    *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v6;
    unsigned int v7 = sub_100F870BC((int *)(a1 + 4));
    if (!sub_10006ED58(v7)) {
      sub_10122FD9C();
    }
    *(_DWORD *)(a2 + 92) |= 2u;
    *(_DWORD *)(a2 + 12) = v7;
    unsigned int v8 = sub_100F8728C((int *)(a1 + 12));
    if (!sub_1000641E0(v8)) {
      sub_10122FD74();
    }
    *(_DWORD *)(a2 + 92) |= 4u;
    *(_DWORD *)(a2 + 16) = v8;
    unsigned int v9 = sub_100F870BC((int *)(a1 + 16));
    if (!sub_10006ED58(v9)) {
      sub_10122FD4C();
    }
    int v10 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + 20) = v9;
    *(_BYTE *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = *(_BYTE *)(a1 + 32);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 36);
    char v11 = *(_BYTE *)(a1 + 48);
    *(_DWORD *)(a2 + 92) = v10 | 0xB8;
    *(_BYTE *)(a2 + 29) = v11;
    unsigned int v12 = sub_100F87468((int *)(a1 + 52));
    if (!sub_10006ED58(v12)) {
      sub_10122FD24();
    }
    *(_DWORD *)(a2 + 92) |= 0x100u;
    *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v12;
    unsigned int v13 = sub_100F87638((int *)(a1 + 100));
    if (!sub_1000641A8(v13)) {
      sub_10122FCAC();
    }
    int v14 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + 76) = v13;
    uint64_t v15 = *(void *)(a1 + 56);
    *(_DWORD *)(a2 + 92) = v14 | 0x8200;
    *(void *)(a2 + 40) = v15;
    int v16 = sub_100F86BF4((unsigned int *)(a1 + 88));
    if ((sub_1001D2F60(v16) & 1) == 0) {
      sub_10122FCFC();
    }
    *(_DWORD *)(a2 + 92) |= 0x800u;
    *(_DWORD *)(a2 + 52) = v16;
    unsigned int v17 = sub_100F870BC((int *)(a1 + 92));
    if (!sub_10006ED58(v17)) {
      sub_10122FCD4();
    }
    int v18 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(a2 + sub_1011C52D0(v23 - 72) = v17;
    *(_DWORD *)(a2 + 92) = v18 | 0x5000;
    unsigned int v19 = *(void **)(a2 + 80);
    if (!v19)
    {
      unsigned int v19 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v19);
      *(void *)(a2 + sub_100F6A7D8(v1 + 80) = v19;
    }

    if ((sub_100F848F8((double *)(a1 + 80), (uint64_t)v19, 1) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      double v20 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert CLMotionActivity start CF time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v28[0] = 0;
        double v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert CLMotionActivity start CF time to protobuf",  v28,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)",  "%s\n",  v25);
      }

      (*(void (**)(void *))(*(void *)v19 + 32LL))(v19);
    }

    if ((a3 & 1) == 0)
    {
      *(_DWORD *)(a2 + 92) |= 0x2000u;
      uint64_t v21 = *(void **)(a2 + 64);
      if (!v21)
      {
        uint64_t v21 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v21);
        *(void *)(a2 + 64) = v21;
      }

      if ((sub_100F81EC0((double *)(a1 + 40), (uint64_t)v21, 1) & 1) == 0)
      {
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        unint64_t v22 = (os_log_s *)qword_101934918;
        if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert CLMotionActivity mach timestamp to protobuf",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          v28[0] = 0;
          LODWORD(v27) = 2;
          uint64_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert CLMotionActivity mach timestamp to protobuf",  v28,  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)",  "%s\n",  v26);
        }

        (*(void (**)(void *))(*(void *)v21 + 32LL))(v21);
      }
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    unint64_t v23 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "pActivity,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v28[0] = 0;
      int v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pActivity,Invalid pointer",  v28,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLMotionActivityToProtobuf(const CLMotionActivity &, CLP::LogEntry::PrivateData::MotionActivity *, BOOL)",  "%s\n",  v24);
    }
  }

void sub_100F86BCC(_Unwind_Exception *a1)
{
}

uint64_t sub_100F86BF4(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((int)result <= 11804)
  {
    if ((int)result > 2009)
    {
      BOOL v5 = (result - 2010) > 0x3D || ((1LL << (result + 38)) & 0x2488004000005401LL) == 0;
      if (!v5
        || (result - 2101) <= 0x31 && ((1LL << (result - 53)) & 0x2000000000011LL) != 0
        || (result - 3015) < 2)
      {
        return result;
      }
    }

    else
    {
    }

    goto LABEL_71;
  }

  if ((int)result > 15651)
  {
    if ((int)result > 18199)
    {
      if ((int)result <= 19149)
      {
        if ((int)result > 19029)
        {
          if ((_DWORD)result == 19030) {
            return result;
          }
          int v6 = 19090;
        }

        else
        {
          if ((_DWORD)result == 18200) {
            return result;
          }
          int v6 = 18240;
        }
      }

      else
      {
        if ((int)result > 515620)
        {
          if ((_DWORD)result == 515621 || (_DWORD)result == 515652) {
            return result;
          }
          if ((_DWORD)result == 519150) {
            return 19160LL;
          }
          goto LABEL_71;
        }

        if ((_DWORD)result == 19150) {
          return result;
        }
        int v6 = 90603;
      }
    }

    else
    {
      if ((int)result <= 15732)
      {
        uint64_t v4 = (result - 15652);
        if (v4 <= 0x3B)
        {
          if (v4 == 59) {
            return 15710LL;
          }
        }

        goto LABEL_71;
      }

      if ((int)result > 18049)
      {
        if ((_DWORD)result == 18050) {
          return 18070LL;
        }
        if ((_DWORD)result == 18100) {
          return 18225LL;
        }
        goto LABEL_71;
      }

      if ((_DWORD)result == 15733) {
        return result;
      }
      int v6 = 17150;
    }

uint64_t sub_100F870BC(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled confidence type: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled confidence type: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::MotionActivity_ConfidenceType ConvertCLMotionActivityConfidenceTypeToProtobuf(const CL MotionActivity::Confidence &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8728C(int *a1)
{
  if (!*a1) {
    return 1LL;
  }
  if (*a1 == 1) {
    return 2LL;
  }
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled mounted state type: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled mounted state type: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::MotionActivity_MountedStateType ConvertCLMotionActivityMountedStateTypeToProtobuf(cons t CLMotionActivity::MountedState &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F87468(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled vehicle exit state type: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled vehicle exit state type: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::MotionActivity_VehicleExitStateType ConvertCLMotionActivityVehicleExitStateTypeToProto buf(const CLMotionActivity::VehicleExitState &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F87638(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled vehicle confidence type: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled vehicle confidence type: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::MotionActivity_VehicularConfidenceType ConvertCLMotionActivityVehicularConfidenceTypeT oProtobuf(const CLMotionActivity::VehicularConfidence &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

std::string *sub_100F87808(void *a1, uint64_t a2)
{
  if ([a1 preferredName])
  {
    int v4 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "preferredName"), "UTF8String");
    *(_DWORD *)(a2 + 36) |= 4u;
    BOOL v5 = *(std::string **)(a2 + 16);
    if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      BOOL v5 = (std::string *)operator new(0x18uLL);
      v5->__r_.__value_.__l.__size_ = 0LL;
      v5->__r_.__value_.__l.__cap_ = 0LL;
      v5->__r_.__value_.__r.__words[0] = 0LL;
      *(void *)(a2 + 16) = v5;
    }

    std::string::assign(v5, v4);
  }

  id v6 = [a1 userType];
  LODWORD(v7) = (_DWORD)v6;
  if ((unint64_t)v6 >= 5)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v8 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v18 = (int)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "ConvertCLPlaceInferenceUserSpecificPlaceTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v15 = 67240192;
      int v16 = (int)v7;
      unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertCLPlaceInferenceUserSpecificPlaceTypeToProtobuf,unhandled type,%{public}d",  &v15,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::PlaceInference::UserSpecificPlaceType ConvertCLPlaceInferenceUserSpecificPlaceTypeTo Protobuf(const _CLPlaceInferenceUserSpecificPlaceType &)",  "%s\n",  v7);
    }
  }

  *(_DWORD *)(a2 + 36) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)v7;
  id v9 = [a1 placeType];
  LODWORD(v7) = (_DWORD)v9;
  if ((unint64_t)v9 >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v10 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v18 = (int)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "ConvertCLPlaceInferencePlaceTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v15 = 67240192;
      int v16 = (int)v7;
      LODWORD(v14) = 8;
      unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertCLPlaceInferencePlaceTypeToProtobuf,unhandled type,%{public}d",  &v15,  v14);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::PlaceInference::PlaceInferencePlaceType ConvertCLPlaceInferencePlaceTypeToProtobuf(c onst _CLPlaceInferencePlaceType &)",  "%s\n",  v7);
    }
  }

  *(_DWORD *)(a2 + 36) |= 2u;
  *(_DWORD *)(a2 + 12) = (_DWORD)v7;
  uint64_t result = (std::string *)[a1 _loiIdentifier];
  if (result)
  {
    uint64_t result = (std::string *)objc_msgSend(objc_msgSend(a1, "_loiIdentifier"), "UUIDString");
    if (result)
    {
      unsigned int v12 = (const std::string::value_type *)objc_msgSend( objc_msgSend(objc_msgSend(a1, "_loiIdentifier"), "UUIDString"),  "UTF8String");
      *(_DWORD *)(a2 + 36) |= 8u;
      unsigned int v13 = *(std::string **)(a2 + 24);
      if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        unsigned int v13 = (std::string *)operator new(0x18uLL);
        v13->__r_.__value_.__r.__words[0] = 0LL;
        v13->__r_.__value_.__l.__size_ = 0LL;
        v13->__r_.__value_.__l.__cap_ = 0LL;
        *(void *)(a2 + 24) = v13;
      }

      return std::string::assign(v13, v12);
    }
  }

  return result;
}

void sub_100F87C30(void *a1, uint64_t a2)
{
  if (a1)
  {
    [a1 horizontalAccuracy];
    int v4 = *(_DWORD *)(a2 + 68);
    *(void *)(a2 + 56) = v5;
    *(_DWORD *)(a2 + 6_Block_object_dispose((const void *)(v1 - 128), 8) = v4 | 0x60;
    id v6 = *(_DWORD **)(a2 + 48);
    if (!v6)
    {
      id v6 = operator new(0x20uLL);
      sub_1001D2424(v6);
      *(void *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v6;
    }

    [a1 coordinate];
    v6[7] |= 1u;
    *((void *)v6 + 1) = v7;
    *(_DWORD *)(a2 + 68) |= 0x20u;
    int v8 = *(_DWORD **)(a2 + 48);
    if (!v8)
    {
      int v8 = operator new(0x20uLL);
      sub_1001D2424(v8);
      *(void *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
    }

    [a1 coordinate];
    v8[7] |= 2u;
    *((void *)v8 + 2) = v9;
    id v10 = [a1 _placeInference];
    *(_DWORD *)(a2 + 68) |= 0x10u;
    char v11 = *(void **)(a2 + 40);
    if (!v11)
    {
      char v11 = operator new(0x28uLL);
      sub_1001D2ADC(v11);
      *(void *)(a2 + 40) = v11;
    }

    sub_100F87808(v10, (uint64_t)v11);
    if ([a1 hasArrivalDate] && objc_msgSend(a1, "arrivalDate"))
    {
      *(_DWORD *)(a2 + 68) |= 2u;
      unsigned int v12 = *(_DWORD **)(a2 + 16);
      if (!v12)
      {
        unsigned int v12 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v12);
        *(void *)(a2 + 16) = v12;
      }

      objc_msgSend(objc_msgSend(a1, "arrivalDate"), "timeIntervalSinceReferenceDate");
      v12[9] |= 1u;
      *((void *)v12 + 1) = v13;
    }

    if ([a1 hasDepartureDate] && objc_msgSend(a1, "departureDate"))
    {
      *(_DWORD *)(a2 + 68) |= 4u;
      uint64_t v14 = *(_DWORD **)(a2 + 24);
      if (!v14)
      {
        uint64_t v14 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v14);
        *(void *)(a2 + 24) = v14;
      }

      objc_msgSend(objc_msgSend(a1, "departureDate"), "timeIntervalSinceReferenceDate");
      v14[9] |= 1u;
      *((void *)v14 + 1) = v15;
    }

    if ([a1 detectionDate])
    {
      *(_DWORD *)(a2 + 68) |= 8u;
      int v16 = *(_DWORD **)(a2 + 32);
      if (!v16)
      {
        int v16 = operator new(0x28uLL);
        sub_1001D23B4((uint64_t)v16);
        *(void *)(a2 + 32) = v16;
      }

      objc_msgSend(objc_msgSend(a1, "detectionDate"), "timeIntervalSinceReferenceDate");
      v16[9] |= 1u;
      *((void *)v16 + 1) = v17;
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v18 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "ConvertCLVisitToProtobuf,visit is nil",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v20[0] = 0;
      unsigned int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertCLVisitToProtobuf,visit is nil",  v20,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLVisitToProtobuf(const CLVisit *, CLP::LogEntry::PrivateData::RoutineVisit *)",  "%s\n",  v19);
    }
  }

void sub_100F87F9C(_Unwind_Exception *a1)
{
}

float sub_100F87FCC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    buf[0].__r_.__value_.__r.__words[0] = *(void *)a1;
    uint64_t v4 = sub_1005B46E8((uint64_t)buf);
    int v5 = *(_DWORD *)(a2 + 56) | 1;
    *(_DWORD *)(a2 + 56) = v5;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    if (*(char *)(a1 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(a1 + 8), *(void *)(a1 + 16));
      int v5 = *(_DWORD *)(a2 + 56);
    }

    else
    {
      buf[0] = *(std::string *)(a1 + 8);
    }

    *(_DWORD *)(a2 + 56) = v5 | 2;
    uint64_t v9 = *(std::string **)(a2 + 16);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v9 = (std::string *)operator new(0x18uLL);
      v9->__r_.__value_.__r.__words[0] = 0LL;
      v9->__r_.__value_.__l.__size_ = 0LL;
      v9->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a2 + 16) = v9;
    }

    std::string::operator=(v9, buf);
    int v10 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 56) |= 4u;
    *(_DWORD *)(a2 + 24) = v10;
    LODWORD(buf[0].__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 36);
    unsigned int v11 = sub_100F88284((int *)buf);
    if (!sub_10006ED58(v11)) {
      sub_1012301FC();
    }
    int v12 = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 56) = v12 | 8;
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v11;
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 40);
    float result = *(double *)(a1 + 48);
    *(float *)(a2 + 36) = result;
    char v13 = *(_BYTE *)(a1 + 64);
    *(_DWORD *)(a2 + 56) = v12 | 0x78;
    *(_BYTE *)(a2 + 40) = v13;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    id v6 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "pWap,Invalid pointer", (uint8_t *)buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v14[0] = 0;
      int v8 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWap,Invalid pointer",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWifiServiceAccessPointToProtobuf(const CLWifiService_Type::AccessPoint &, CLP::LogEntry::PrivateDa ta::WifiAccessPoint *)",  "%s\n",  (const char *)v8);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  return result;
}

void sub_100F88260( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F88284(int *a1)
{
  int v1 = *a1 + 1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  uint64_t v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Received unhandled wifi access point mode: %{public}d",  buf,  8u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v7 = *a1;
    v9[0] = 67240192;
    v9[1] = v7;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled wifi access point mode: %{public}d",  v9,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WifiAccessPointMode ConvertCLWifiServiceAccessPointModeToProtobuf(const int &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

void sub_100F88460(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_BYTE *)(a1 + 88))
    {
      int v4 = *(_DWORD *)(a1 + 40);
      int v5 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a2 + 24) = v5 | 1;
      *(_BYTE *)(a2 + 16) = v4 > 0;
      if (v4 >= 1)
      {
        *(_DWORD *)(a2 + 24) = v5 | 3;
        BOOL v6 = *(void **)(a2 + 8);
        if (!v6)
        {
          BOOL v6 = operator new(0x40uLL);
          sub_1001D29D4((uint64_t)v6);
          *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v6;
        }

        sub_100F87FCC(a1, (uint64_t)v6);
      }
    }

    else
    {
      *(_DWORD *)(a2 + 24) |= 1u;
      *(_BYTE *)(a2 + 16) = 0;
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v7 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "pWas,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v9[0] = 0;
      int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWas,Invalid pointer",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWifiServiceAssociationStateToProtobuf(const CLWifiService_Type::AssociationState &, CLP::LogEntry: :PrivateData::WifiAssociationState *)",  "%s\n",  v8);
    }
  }

void sub_100F88684(_Unwind_Exception *a1)
{
}

uint64_t sub_100F886A0(int *a1)
{
  uint64_t v1 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Received unhandled wifi service notification type: %{public}d",  buf,  8u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v7 = *a1;
    v9[0] = 67240192;
    v9[1] = v7;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled wifi service notification type: %{public}d",  v9,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WifiNotificationType ConvertCLWifiServiceNotificationTypeToProtobuf(const CLWifiServic e_Type::Notification &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F88878(char *a1)
{
  uint64_t v1 = *a1 + 1LL;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v5 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Received unhandled wifi scan type: %{public}d",  buf,  8u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v7 = *a1;
    v9[0] = 67240192;
    v9[1] = v7;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled wifi scan type: %{public}d",  v9,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WifiScanType ConvertCLWifiServiceScanTypeToProtobuf(const CLWifiService_Type::ScanType &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

void sub_100F88A54(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(_DWORD *)(a2 + 44) |= 1u;
    int v4 = *(void **)(a2 + 8);
    if (!v4)
    {
      int v4 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v4);
      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    }

    if ((sub_100F848F8((double *)a1, (uint64_t)v4, 0) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v5 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        double v6 = *(double *)a1;
        *(_DWORD *)uint64_t buf = 134349056;
        double v24 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert wifi scan result applicable CF time to protobuf,%{public}.3lf",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        double v18 = *(double *)a1;
        int v21 = 134349056;
        double v22 = v18;
        unsigned int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert wifi scan result applicable CF time to protobuf,%{public}.3lf",  &v21,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWifiServiceScanResultToProtobuf(const CLWifiService_Type::ScanResult &, CLP::LogEntry::PrivateDa ta::WifiScanResult *)",  "%s\n",  v19);
      }

      (*(void (**)(void *))(*(void *)v4 + 32LL))(v4);
    }

    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    while (v7 != v8)
    {
      int v9 = *(_DWORD *)(a2 + 28);
      uint64_t v10 = *(int *)(a2 + 24);
      if ((int)v10 >= v9)
      {
        if (v9 == *(_DWORD *)(a2 + 32))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16),  v9 + 1);
          int v9 = *(_DWORD *)(a2 + 28);
        }

        *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v9 + 1;
        int v12 = sub_1006DA1EC();
        uint64_t v13 = *(void *)(a2 + 16);
        uint64_t v14 = *(int *)(a2 + 24);
        *(_DWORD *)(a2 + 24) = v14 + 1;
        *(void *)(v13 + 8 * v14) = v12;
        if (!v12)
        {
LABEL_28:
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          uint64_t v17 = (os_log_s *)qword_101934918;
          if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "pWap,Invalid pointer", buf, 2u);
          }

          if (!sub_1002921D0(115, 0)) {
            return;
          }
          bzero(buf, 0x65CuLL);
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          LOWORD(v21) = 0;
          LODWORD(v20) = 2;
          int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWap,Invalid pointer",  &v21,  v20);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWifiServiceScanResultToProtobuf(const CLWifiService_Type::ScanResult &, CLP::LogEntry::Private Data::WifiScanResult *)",  "%s\n",  v16);
LABEL_41:
          return;
        }
      }

      else
      {
        uint64_t v11 = *(void *)(a2 + 16);
        *(_DWORD *)(a2 + 24) = v10 + 1;
        int v12 = *(void **)(v11 + 8 * v10);
        if (!v12) {
          goto LABEL_28;
        }
      }

      sub_100F87FCC(v7, (uint64_t)v12);
      v7 += 88LL;
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v15 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "pWsr,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      LOWORD(v21) = 0;
      int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWsr,Invalid pointer",  &v21,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWifiServiceScanResultToProtobuf(const CLWifiService_Type::ScanResult &, CLP::LogEntry::PrivateData ::WifiScanResult *)",  "%s\n",  v16);
      goto LABEL_41;
    }
  }

void sub_100F88F44(_Unwind_Exception *a1)
{
}

void sub_100F88F60(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(_DWORD *)(a2 + 48) |= 1u;
    int v4 = *(void **)(a2 + 8);
    if (!v4)
    {
      int v4 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v4);
      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    }

    if ((sub_100F848F8((double *)a1, (uint64_t)v4, 0) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v5 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert WorkoutEvent start CF time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v19[0] = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert WorkoutEvent start CF time to protobuf",  v19,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertWorkoutEventToProtobuf(const CLMotionStateMediator_Type::WorkoutEvent &, CLP::LogEntry::PrivateDat a::WorkoutEvent *)",  "%s\n",  v15);
      }

      (*(void (**)(void *))(*(void *)v4 + 32LL))(v4);
    }

    *(_DWORD *)(a2 + 48) |= 2u;
    double v6 = *(void **)(a2 + 16);
    if (!v6)
    {
      double v6 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v6);
      *(void *)(a2 + 16) = v6;
    }

    if ((sub_100F848F8((double *)(a1 + 8), (uint64_t)v6, 0) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      uint64_t v7 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert WorkoutEvent end CF time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v19[0] = 0;
        LODWORD(v1_Block_object_dispose((const void *)(v1 - 128), 8) = 2;
        int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert WorkoutEvent end CF time to protobuf",  v19,  v18);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertWorkoutEventToProtobuf(const CLMotionStateMediator_Type::WorkoutEvent &, CLP::LogEntry::PrivateDat a::WorkoutEvent *)",  "%s\n",  v16);
      }

      (*(void (**)(void *))(*(void *)v6 + 32LL))(v6);
    }

    *(_DWORD *)(a2 + 48) |= 8u;
    uint64_t v8 = *(void **)(a2 + 24);
    if (!v8)
    {
      uint64_t v8 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v8);
      *(void *)(a2 + 24) = v8;
    }

    if ((sub_100F848F8((double *)(a1 + 24), (uint64_t)v8, 0) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v9 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert WorkoutEvent event CF time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v19[0] = 0;
        LODWORD(v1_Block_object_dispose((const void *)(v1 - 128), 8) = 2;
        uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert WorkoutEvent event CF time to protobuf",  v19,  v18);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertWorkoutEventToProtobuf(const CLMotionStateMediator_Type::WorkoutEvent &, CLP::LogEntry::PrivateDat a::WorkoutEvent *)",  "%s\n",  v17);
      }

      (*(void (**)(void *))(*(void *)v8 + 32LL))(v8);
    }

    unsigned int v10 = sub_100F895F8((uint64_t *)(a1 + 16));
    if (!sub_1001E421C(v10)) {
      sub_10122FEB4();
    }
    int v11 = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(a2 + 40) = v10;
    *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v11 | 0x14;
    int v12 = *(void **)(a2 + 32);
    if (!v12)
    {
      int v12 = operator new(0x30uLL);
      sub_1001D26E0((uint64_t)v12);
      *(void *)(a2 + 32) = v12;
    }

    sub_100F897DC(a1 + 64, (uint64_t)v12);
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v13 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "pWorkoutEvent,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v19[0] = 0;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWorkoutEvent,Invalid pointer",  v19,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertWorkoutEventToProtobuf(const CLMotionStateMediator_Type::WorkoutEvent &, CLP::LogEntry::PrivateData: :WorkoutEvent *)",  "%s\n",  v14);
    }
  }

void sub_100F895D0(_Unwind_Exception *a1)
{
}

uint64_t sub_100F895F8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v11 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled workout event type: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v7 = *a1;
    v9[0] = 67240192;
    v9[1] = v7;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled workout event type: %{public}d",  v9,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WorkoutEvent::EventType ConvertCMWorkoutEventTypeToProtobuf(const CMWorkoutEvent &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

void sub_100F897DC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uuid_unparse((const unsigned __int8 *)a1, (char *)out);
    sub_1010DDBC0(&__str, (char *)out);
    *(_DWORD *)(a2 + 40) |= 1u;
    uint64_t v4 = *(std::string **)(a2 + 8);
    if (v4 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v4 = (std::string *)operator new(0x18uLL);
      v4->__r_.__value_.__r.__words[0] = 0LL;
      v4->__r_.__value_.__l.__size_ = 0LL;
      v4->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    }

    std::string::operator=(v4, &__str);
    uuid_unparse((const unsigned __int8 *)(a1 + 16), __s);
    sub_1010DDBC0(&__str, __s);
    *(_DWORD *)(a2 + 40) |= 2u;
    BOOL v5 = *(std::string **)(a2 + 16);
    if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      BOOL v5 = (std::string *)operator new(0x18uLL);
      v5->__r_.__value_.__r.__words[0] = 0LL;
      v5->__r_.__value_.__l.__size_ = 0LL;
      v5->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a2 + 16) = v5;
    }

    std::string::operator=(v5, &__str);
    unsigned int v6 = sub_100F89AD8((uint64_t *)(a1 + 48));
    if (!sub_1001E3978(v6)) {
      sub_10122FE8C();
    }
    *(_DWORD *)(a2 + 40) |= 4u;
    *(_DWORD *)(a2 + 24) = v6;
    unsigned int v7 = sub_100F89CA0((uint64_t *)(a1 + 56));
    if (!sub_1001D2F54(v7)) {
      sub_10122FE64();
    }
    *(_DWORD *)(a2 + 40) |= 8u;
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7;
    unsigned int v8 = sub_100F89E68((uint64_t *)(a1 + 160));
    if (!sub_1000641E0(v8)) {
      sub_10122FE3C();
    }
    *(_DWORD *)(a2 + 40) |= 0x10u;
    *(_DWORD *)(a2 + 32) = v8;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v9 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)out = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "pWorkoutSettings,Invalid pointer", out, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(out, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      *(_WORD *)__s = 0;
      unsigned int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  out,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWorkoutSettings,Invalid pointer",  __s,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertWorkoutSettingsToProtobuf(const CLMotionStateMediator_Type::WorkoutSettings &, CLP::LogEntry::Privat eData::WorkoutSettings *)",  "%s\n",  v10);
    }
  }

void sub_100F89AB0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F89AD8(uint64_t *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled workout type: %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    unsigned int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled workout type: %{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WorkoutSettings::WorkoutType ConvertCMWorkoutTypeToProtobuf(const CMWorkoutType &)",  "%s\n",  v6);
  }

  return 27LL;
}

uint64_t sub_100F89CA0(uint64_t *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled workout location type: %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    unsigned int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled workout location type: %{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WorkoutSettings::WorkoutLocationType ConvertCMWorkoutLocationTypeToProtobuf(const CMWo rkoutLocationType &)",  "%s\n",  v6);
  }

  return 1LL;
}

uint64_t sub_100F89E68(uint64_t *a1)
{
  if (!*a1) {
    return 1LL;
  }
  if (*a1 == 1) {
    return 2LL;
  }
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  char v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)uint64_t buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Received unhandled workout mode: %{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Received unhandled workout mode: %{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::WorkoutSettings::WorkoutMode ConvertCMWorkoutModeToProtobuf(const CMWorkoutMode &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

void sub_100F8A044(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = sub_100F86BF4((unsigned int *)(a1 + 8));
    if ((sub_1001D2F60(v4) & 1) == 0) {
      sub_10122FE14();
    }
    int v5 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a2 + 16) = v4;
    *(_DWORD *)(a2 + 36) = v5 | 5;
    uint64_t v6 = *(void **)(a2 + 24);
    if (!v6)
    {
      uint64_t v6 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v6);
      *(void *)(a2 + 24) = v6;
    }

    if ((sub_100F848F8((double *)a1, (uint64_t)v6, 0) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      unsigned int v7 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert CLWorkoutUpdate start CF time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v12[0] = 0;
        int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert CLWorkoutUpdate start CF time to protobuf",  v12,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWorkoutUpdateToProtobuf(const CLWorkoutUpdate &, CLP::LogEntry::PrivateData::WorkoutUpdate *)",  "%s\n",  v11);
      }

      (*(void (**)(void *))(*(void *)v6 + 32LL))(v6);
    }

    int v8 = sub_100F86BF4((unsigned int *)(a1 + 12));
    if ((sub_1001D2F60(v8) & 1) == 0) {
      sub_10122FDEC();
    }
    *(_DWORD *)(a2 + 36) |= 8u;
    *(_DWORD *)(a2 + 20) = v8;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v9 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "pWorkoutUpdate,Invalid pointer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v12[0] = 0;
      int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "pWorkoutUpdate,Invalid pointer",  v12,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLWorkoutUpdateToProtobuf(const CLWorkoutUpdate &, CLP::LogEntry::PrivateData::WorkoutUpdate *)",  "%s\n",  v10);
    }
  }

void sub_100F8A3B4(_Unwind_Exception *a1)
{
}

void sub_100F8A3D0(uint64_t a1, char a2)
{
  else {
    unsigned int v4 = 1;
  }
  BOOL v5 = sub_1000641E0(v4);
  if (!v5) {
    sub_10127B2B8(v5, v6, v7);
  }
  *(_DWORD *)(a1 + 52) |= 0x40u;
  *(_DWORD *)(a1 + 44) = v4;
  sub_1004F2598();
  LODWORD(buf.__r_.__value_.__l.__data_) = sub_1004F2690();
  unsigned int v8 = sub_100F8A9E4((int *)&buf, a2);
  if ((sub_100706978(v8) & 1) == 0) {
    sub_101246388();
  }
  *(_DWORD *)(a1 + 52) |= 2u;
  *(_DWORD *)(a1 + 16) = v8;
  if (sub_1001B9A1C())
  {
    int v9 = 3;
    BOOL v10 = sub_10006ED58(3u);
    if (!v10) {
      sub_10127B294(v10, v11, v12);
    }
  }

  else if (sub_1004F7000())
  {
    int v9 = 1;
    BOOL v13 = sub_10006ED58(1u);
    if (!v13) {
      sub_10127B294(v13, v14, v15);
    }
  }

  else if (sub_1004F75F8())
  {
    int v9 = 2;
    BOOL v16 = sub_10006ED58(2u);
    if (!v16) {
      sub_10127B294(v16, v17, v18);
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    unsigned int v19 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "CN platform info creation on unknown category",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      *(_WORD *)uint64_t v41 = 0;
      __int16 v35 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "CN platform info creation on unknown category",  v41,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertCLPlatformInfoToProtobuf(CLP::LogEntry::Raven::RavenPlatformInfo *, const BOOL)",  "%s\n",  (const char *)v35);
      if (v35 != &buf) {
        free(v35);
      }
    }

    BOOL v20 = sub_10006ED58(0);
    if (!v20) {
      sub_10127B294(v20, v21, v22);
    }
    int v9 = 0;
  }

  *(_DWORD *)(a1 + 52) |= 0x20u;
  *(_DWORD *)(a1 + 40) = v9;
  sub_1004F2598();
  char v23 = sub_1004F8A40();
  *(_DWORD *)(a1 + 52) |= 4u;
  *(_BYTE *)(a1 + 20) = v23;
  sub_1004F2598();
  sub_1004F6004((uint64_t)&buf);
  *(_DWORD *)(a1 + 52) |= 8u;
  double v24 = *(std::string **)(a1 + 24);
  if (v24 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    double v24 = (std::string *)operator new(0x18uLL);
    v24->__r_.__value_.__r.__words[0] = 0LL;
    v24->__r_.__value_.__l.__size_ = 0LL;
    v24->__r_.__value_.__l.__cap_ = 0LL;
    *(void *)(a1 + 24) = v24;
  }

  std::string::operator=(v24, &buf);
  sub_1004F2598();
  sub_1004F54FC((uint64_t)&buf);
  *(_DWORD *)(a1 + 52) |= 0x10u;
  double v25 = *(std::string **)(a1 + 32);
  if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    double v25 = (std::string *)operator new(0x18uLL);
    v25->__r_.__value_.__r.__words[0] = 0LL;
    v25->__r_.__value_.__l.__size_ = 0LL;
    v25->__r_.__value_.__l.__cap_ = 0LL;
    *(void *)(a1 + 32) = v25;
  }

  std::string::operator=(v25, &buf);
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  uint64_t v26 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_INFO))
  {
    sub_1004F2598();
    uint64_t v27 = v41;
    sub_1004F54FC((uint64_t)v41);
    if (v44 < 0) {
      uint64_t v27 = *(_BYTE **)v41;
    }
    sub_1004F2598();
    uint64_t v28 = __p;
    sub_1004F6004((uint64_t)__p);
    if (v40 < 0) {
      uint64_t v28 = (void **)__p[0];
    }
    sub_1004F2598();
    int v29 = sub_1004F8A40();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446722;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v28;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1026;
    int v47 = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "convert CN plaform info: system version, %{public}s, serial number, %{public}s, isInternal, %{public}d",  (uint8_t *)&buf,  0x1Cu);
    if (v40 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(*(void **)v41);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v30 = qword_101934918;
    sub_1004F2598();
    __int128 v31 = __p;
    sub_1004F54FC((uint64_t)__p);
    if (v40 < 0) {
      __int128 v31 = (void **)__p[0];
    }
    sub_1004F2598();
    double v32 = v37;
    sub_1004F6004((uint64_t)v37);
    if (v38 < 0) {
      double v32 = (void **)v37[0];
    }
    sub_1004F2598();
    int v33 = sub_1004F8A40();
    *(_DWORD *)uint64_t v41 = 136446722;
    *(void *)&v41[4] = v31;
    __int16 v42 = 2082;
    int v43 = v32;
    __int16 v44 = 1026;
    int v45 = v33;
    LODWORD(v36) = 28;
    uint64_t v34 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v30,  1LL,  "convert CN plaform info: system version, %{public}s, serial number, %{public}s, isInternal, %{public}d",  v41,  v36);
    if (v38 < 0) {
      operator delete(v37[0]);
    }
    if (v40 < 0) {
      operator delete(__p[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void ConvertCLPlatformInfoToProtobuf(CLP::LogEntry::Raven::RavenPlatformInfo *, const BOOL)",  "%s\n",  (const char *)v34);
    if (v34 != &buf) {
      free(v34);
    }
  }

void sub_100F8A964( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F8A9E4(int *a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    int v3 = *a1 - 78;
    uint64_t result = 8LL;
    switch(v3)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = 9LL;
        break;
      case 2:
        uint64_t result = 10LL;
        break;
      case 4:
        uint64_t result = 21LL;
        break;
      case 6:
        uint64_t result = 22LL;
        break;
      case 8:
        uint64_t result = 23LL;
        break;
      case 10:
        uint64_t result = 24LL;
        break;
      case 11:
        uint64_t result = 25LL;
        break;
      case 12:
        uint64_t result = 26LL;
        break;
      case 13:
        uint64_t result = 27LL;
        break;
      case 14:
        uint64_t result = 28LL;
        break;
      case 17:
        uint64_t result = 29LL;
        break;
      case 18:
        uint64_t result = 30LL;
        break;
      case 19:
        uint64_t result = 31LL;
        break;
      case 20:
        uint64_t result = 32LL;
        break;
      case 21:
        uint64_t result = 33LL;
        break;
      case 22:
        uint64_t result = 34LL;
        break;
      case 23:
        uint64_t result = 35LL;
        break;
      case 24:
        uint64_t result = 36LL;
        break;
      case 25:
        uint64_t result = 37LL;
        break;
      case 26:
        uint64_t result = 38LL;
        break;
      case 27:
        uint64_t result = 39LL;
        break;
      case 28:
        uint64_t result = 40LL;
        break;
      case 29:
      case 30:
        uint64_t result = 72LL;
        break;
      case 31:
      case 32:
        uint64_t result = 73LL;
        break;
      case 33:
      case 34:
        uint64_t result = 74LL;
        break;
      case 35:
      case 36:
        uint64_t result = 75LL;
        break;
      case 37:
        uint64_t result = 76LL;
        break;
      case 38:
      case 39:
        uint64_t result = 79LL;
        break;
      case 40:
      case 41:
        uint64_t result = 80LL;
        break;
      case 42:
      case 43:
        uint64_t result = 84LL;
        break;
      case 44:
      case 45:
        uint64_t result = 85LL;
        break;
      case 46:
        uint64_t result = 81LL;
        break;
      case 47:
        uint64_t result = 86LL;
        break;
      case 61:
        uint64_t result = 11LL;
        break;
      case 63:
        uint64_t result = 12LL;
        break;
      case 64:
        uint64_t result = 14LL;
        break;
      case 65:
        uint64_t result = 13LL;
        break;
      case 90:
        uint64_t result = 15LL;
        break;
      case 91:
        uint64_t result = 16LL;
        break;
      case 92:
        uint64_t result = 18LL;
        break;
      case 93:
        uint64_t result = 17LL;
        break;
      case 94:
        uint64_t result = 43LL;
        break;
      case 95:
        uint64_t result = 44LL;
        break;
      case 96:
      case 97:
        uint64_t result = 100LL;
        break;
      case 98:
        uint64_t result = 41LL;
        break;
      case 99:
        uint64_t result = 42LL;
        break;
      case 100:
        uint64_t result = 70LL;
        break;
      case 101:
        uint64_t result = 71LL;
        break;
      case 102:
        uint64_t result = 77LL;
        break;
      case 103:
        uint64_t result = 78LL;
        break;
      case 104:
        uint64_t result = 82LL;
        break;
      case 105:
        uint64_t result = 83LL;
        break;
      case 111:
        uint64_t result = 45LL;
        break;
      case 120:
        uint64_t result = 19LL;
        break;
      case 122:
        uint64_t result = 20LL;
        break;
      case 128:
        uint64_t result = 51LL;
        break;
      case 132:
        uint64_t result = 47LL;
        break;
      case 136:
        uint64_t result = 68LL;
        break;
      case 138:
        uint64_t result = 69LL;
        break;
      case 141:
        uint64_t result = 46LL;
        break;
      case 142:
        uint64_t result = 52LL;
        break;
      case 143:
        uint64_t result = 53LL;
        break;
      case 144:
        uint64_t result = 62LL;
        break;
      case 145:
        uint64_t result = 63LL;
        break;
      case 146:
        uint64_t result = 66LL;
        break;
      case 147:
        uint64_t result = 67LL;
        break;
      case 150:
        uint64_t result = 54LL;
        break;
      case 152:
        uint64_t result = 56LL;
        break;
      case 154:
        uint64_t result = 64LL;
        break;
      case 156:
        uint64_t result = 65LL;
        break;
      case 162:
        uint64_t result = 60LL;
        break;
      case 163:
        uint64_t result = 61LL;
        break;
      case 165:
        uint64_t result = 59LL;
        break;
      default:
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        uint64_t v7 = (os_log_s *)qword_101934918;
        if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
        {
          int v8 = *a1;
          *(_DWORD *)std::string buf = 67240192;
          int v16 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unhandled HW %{public}d", buf, 8u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934910 != -1) {
            dispatch_once(&qword_101934910, &stru_10188FD60);
          }
          int v11 = *a1;
          int v13 = 67240192;
          int v14 = v11;
          uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Unhandled HW %{public}d",  &v13,  8);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::Raven::RavenPlatformInfo::Hardware ConvertCLPlatformInfoHardwareToProtobuf(const CLPlatformIn fo::Hardware &, const BOOL)",  "%s\n",  v12);
        }

        uint64_t result = 2LL;
        break;
    }
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    BOOL v5 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)std::string buf = 67240192;
      int v16 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Unsupported hardware detected, type: %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v9 = *a1;
      int v13 = 67240192;
      int v14 = v9;
      BOOL v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Unsupported hardware detected, type: %{public}d",  &v13,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::Raven::RavenPlatformInfo::Hardware ConvertCLPlatformInfoHardwareToProtobuf(const CLPlatformInfo:: Hardware &, const BOOL)",  "%s\n",  v10);
    }

    return 1LL;
  }

  return result;
}

unint64_t sub_100F8B200(int *a1, int *a2)
{
  unint64_t result = sub_100CBED60(a1);
  if (result)
  {
    for (unint64_t i = 0LL; i < result; ++i)
    {
      sub_100CBE5DC((uint64_t)a1, i, (uint64_t)v23);
      int v6 = a2[5];
      uint64_t v7 = a2[4];
      if ((int)v7 >= v6)
      {
        if (v6 == a2[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 2),  v6 + 1);
          int v6 = a2[5];
        }

        a2[5] = v6 + 1;
        int v9 = sub_100F8D8D8();
        uint64_t v10 = *((void *)a2 + 1);
        uint64_t v11 = a2[4];
        a2[4] = v11 + 1;
        *(void *)(v10 + 8 * v11) = v9;
      }

      else
      {
        uint64_t v8 = *((void *)a2 + 1);
        a2[4] = v7 + 1;
        int v9 = *(void **)(v8 + 8 * v7);
      }

      sub_100F82504((uint64_t)v23, (uint64_t)v9);
      sub_100CBEAEC((uint64_t)a1, i, (uint64_t)v21);
      int v12 = a2[11];
      uint64_t v13 = a2[10];
      if ((int)v13 >= v12)
      {
        if (v12 == a2[12])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8),  v12 + 1);
          int v12 = a2[11];
        }

        a2[11] = v12 + 1;
        uint64_t v15 = sub_100F8D918();
        uint64_t v16 = *((void *)a2 + 4);
        uint64_t v17 = a2[10];
        a2[10] = v17 + 1;
        *(void *)(v16 + 8 * v17) = v15;
      }

      else
      {
        uint64_t v14 = *((void *)a2 + 4);
        a2[10] = v13 + 1;
        uint64_t v15 = *(void **)(v14 + 8 * v13);
      }

      sub_100F83250((uint64_t)v21, (uint64_t)v15);
      uint64_t v18 = v22;
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }

      unint64_t result = sub_100CBED60(a1);
    }
  }

  return result;
}

void sub_100F8B398(_Unwind_Exception *a1)
{
}

uint64_t sub_100F8B3B0(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "ConvertLocationProviderNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  BOOL v5 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v5)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertLocationProviderNotificationTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::LocationProviderNotification_NotificationType ConvertLocationProviderNotificationTypeT oProtobuf(const CLLocationProvider_Type::Notification &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8B580(int *a1)
{
  uint64_t v1 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "ConvertBluetoothServiceNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertBluetoothServiceNotificationTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::BluetoothServiceNotification_NotificationType ConvertBluetoothServiceNotificationTypeT oProtobuf(const CLBluetoothService_Type::Notification &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8B750(int *a1)
{
  uint64_t v2 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertCompanionNotifierNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertCompanionNotifierNotificationTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::CompanionNotifierNotification_NotificationType ConvertCompanionNotifierNotificationTyp eToProtobuf(const CLCompanionNotifier_Type::Notification &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8B928(int *a1)
{
  uint64_t v1 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "ConvertDaemonStatusNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertDaemonStatusNotificationTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::DeviceStatus_NotificationType ConvertDaemonStatusNotificationTypeToProtobuf(const CLDa emonStatus_Type::Notification &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

void sub_100F8BAF8(int *a1, char *a2, uint64_t a3)
{
  unsigned int v6 = sub_100F8B928(a1);
  if (!sub_1001EEAC8(v6)) {
    sub_10125F9A0();
  }
  int v7 = *(_DWORD *)(a3 + 28);
  *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 2;
  *(_DWORD *)(a3 + 12) = v6;
  switch(*a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 9:
    case 12:
    case 16:
    case 17:
    case 18:
    case 19:
      return;
    case 6:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      uint64_t v26 = *(_DWORD **)(a3 + 16);
      if (!v26)
      {
        uint64_t v26 = operator new(0x30uLL);
        sub_100B1FCD8(v26);
        *(void *)(a3 + 16) = v26;
      }

      v26[11] |= 1u;
      uint64_t v27 = (void *)*((void *)v26 + 1);
      if (!v27)
      {
        uint64_t v27 = operator new(0x20uLL);
        sub_1001D285C((uint64_t)v27);
        *((void *)v26 + 1) = v27;
      }

      sub_100F8C004((BOOL)a2, (uint64_t)v27);
      break;
    case 7:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      int v10 = *(_DWORD **)(a3 + 16);
      if (!v10)
      {
        int v10 = operator new(0x30uLL);
        sub_100B1FCD8(v10);
        *(void *)(a3 + 16) = v10;
      }

      v10[11] |= 2u;
      uint64_t v11 = (void *)*((void *)v10 + 2);
      if (!v11)
      {
        uint64_t v11 = operator new(0x28uLL);
        sub_1001D2874((uint64_t)v11);
        *((void *)v10 + 2) = v11;
      }

      sub_100F8C084((uint64_t)a2, (uint64_t)v11);
      break;
    case 8:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      unint64_t v20 = *(_DWORD **)(a3 + 16);
      if (!v20)
      {
        unint64_t v20 = operator new(0x30uLL);
        sub_100B1FCD8(v20);
        *(void *)(a3 + 16) = v20;
      }

      char v21 = *a2;
      v20[11] |= 4u;
      *((_BYTE *)v20 + 24) = v21;
      break;
    case 10:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      uint64_t v8 = *(_DWORD **)(a3 + 16);
      if (!v8)
      {
        uint64_t v8 = operator new(0x30uLL);
        sub_100B1FCD8(v8);
        *(void *)(a3 + 16) = v8;
      }

      char v9 = *a2;
      v8[11] |= 8u;
      *((_BYTE *)v8 + 25) = v9;
      break;
    case 11:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      double v24 = *(_DWORD **)(a3 + 16);
      if (!v24)
      {
        double v24 = operator new(0x30uLL);
        sub_100B1FCD8(v24);
        *(void *)(a3 + 16) = v24;
      }

      char v25 = *a2;
      v24[11] |= 0x10u;
      *((_BYTE *)v24 + 26) = v25;
      break;
    case 13:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      int v12 = *(_DWORD **)(a3 + 16);
      if (!v12)
      {
        int v12 = operator new(0x30uLL);
        sub_100B1FCD8(v12);
        *(void *)(a3 + 16) = v12;
      }

      int v13 = *(_DWORD *)a2;
      v12[11] |= 0x80u;
      _WORD v12[8] = v13;
      break;
    case 14:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      uint64_t v18 = *(_DWORD **)(a3 + 16);
      if (!v18)
      {
        uint64_t v18 = operator new(0x30uLL);
        sub_100B1FCD8(v18);
        *(void *)(a3 + 16) = v18;
      }

      char v19 = *a2;
      v18[11] |= 0x100u;
      *((_BYTE *)v18 + 36) = v19;
      break;
    case 15:
      *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v7 | 6;
      uint64_t v22 = *(_DWORD **)(a3 + 16);
      if (!v22)
      {
        uint64_t v22 = operator new(0x30uLL);
        sub_100B1FCD8(v22);
        *(void *)(a3 + 16) = v22;
      }

      char v23 = *a2;
      v22[11] |= 0x20u;
      *((_BYTE *)v22 + 27) = v23;
      break;
    default:
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      uint64_t v14 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        int v15 = *a1;
        *(_DWORD *)std::string buf = 67240192;
        int v30 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "ConvertDaemonStatusNotificationToProtobuf,unhandled type,%{public}d",  buf,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        int v16 = *a1;
        v28[0] = 67240192;
        v28[1] = v16;
        uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertDaemonStatusNotificationToProtobuf,unhandled type,%{public}d",  v28,  8);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertDaemonStatusNotificationToProtobuf(const CLDaemonStatus_Type::Notification &, const CLDaemonStatus _Type::NotificationData &, CLP::LogEntry::PrivateData::DaemonStatusNotification *)",  "%s\n",  v17);
      }

      break;
  }

void sub_100F8BF6C(_Unwind_Exception *a1)
{
}

BOOL sub_100F8C004(BOOL result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    unsigned int v4 = sub_100F8C964((int *)result);
    if (!sub_1001D3218(v4)) {
      sub_10123001C();
    }
    *(_DWORD *)(a2 + 24) |= 1u;
    *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    unsigned int v5 = sub_100F8C964((int *)(v3 + 4));
    uint64_t result = sub_1001D3218(v5);
    if (!result) {
      sub_10122FFF4();
    }
    int v6 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a2 + 12) = v5;
    *(_WORD *)(a2 + 16) = *(_WORD *)(v3 + 8);
    *(_DWORD *)(a2 + 24) = v6 | 0xE;
  }

  return result;
}

uint64_t sub_100F8C084(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(a2 + 32);
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(void *)result;
    *(_WORD *)(a2 + 16) = *(_WORD *)(result + 8);
    *(_DWORD *)(a2 + 32) = v4 | 7;
    unsigned int v5 = sub_100F8CB60((unsigned int *)(result + 12));
    uint64_t result = sub_1001D2F54(v5);
    if ((result & 1) == 0) {
      sub_101230044();
    }
    int v6 = *(_DWORD *)(a2 + 32);
    char v7 = *(_BYTE *)(v3 + 16);
    *(_DWORD *)(a2 + 32) = v6 | 0x18;
    *(_BYTE *)(a2 + 1_Block_object_dispose((const void *)(v1 - 128), 8) = v7;
    int v8 = *(_DWORD *)(v3 + 20);
    *(_DWORD *)(a2 + 32) = v6 | 0x38;
    *(_DWORD *)(a2 + 20) = v5;
    *(_DWORD *)(a2 + 24) = v8;
  }

  return result;
}

uint64_t sub_100F8C108(int *a1)
{
  uint64_t v1 = *a1;
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "ConvertGnssModeOfOperationToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    char v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertGnssModeOfOperationToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::GnssModeOfOperation ConvertGnssModeOfOperationToProtobuf(const CLLocationProvider_Type ::GnssModeOfOperation &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8C2D8(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  uint64_t v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertGnssRhythmicModeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertGnssRhythmicModeToProtobuf,unhandled type,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::RhythmicGnssWakeMode ConvertGnssRhythmicModeToProtobuf(const CLRhythmicGnssWakeMode &)",  "%s\n",  v6);
    return 0LL;
  }

  return result;
}

BOOL sub_100F8C4A4(BOOL result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    unsigned int v4 = sub_100F8C108((int *)result);
    if (!sub_1000641E0(v4)) {
      sub_10122FC84();
    }
    int v5 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    char v6 = *(_BYTE *)(v3 + 4);
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v5 | 3;
    *(_BYTE *)(a2 + 16) = v6;
    unsigned int v7 = sub_100F8C2D8((int *)(v3 + 8));
    uint64_t result = sub_1001D2F54(v7);
    if (!result) {
      sub_10122FC5C();
    }
    int v8 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 12) = v7;
    *(_DWORD *)(a2 + 20) = *(void *)(v3 + 16);
    char v9 = *(_BYTE *)(v3 + 24);
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v8 | 0x1C;
    *(_BYTE *)(a2 + 17) = v9;
  }

  return result;
}

BOOL sub_100F8C534(BOOL result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    *(_DWORD *)(a2 + 36) |= 1u;
    unsigned int v4 = *(void **)(a2 + 8);
    if (!v4)
    {
      unsigned int v4 = operator new(0x28uLL);
      sub_1001D23B4((uint64_t)v4);
      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v4;
    }

    if ((sub_100F85D90((double *)(v3 + 16), (uint64_t)v4, 1) & 1) == 0)
    {
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v5 = (os_log_s *)qword_101934918;
      if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Error: Failed to convert PredictedGnssAvailability mach continuous time to protobuf",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934910 != -1) {
          dispatch_once(&qword_101934910, &stru_10188FD60);
        }
        v11[0] = 0;
        int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "Error: Failed to convert PredictedGnssAvailability mach continuous time to protobuf",  v11,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertPredictedGnssAvailabilityToProtobuf(const CLLocationProvider_Type::PredictedGnssAvailability &, CL P::LogEntry::PrivateData::GnssAvailabilityPrediction *)",  "%s\n",  v10);
      }

      (*(void (**)(void *))(*(void *)v4 + 32LL))(v4);
    }

    unsigned int v6 = sub_100F84F3C((int *)(v3 + 4));
    if (!sub_10006ED58(v6)) {
      sub_10123029C();
    }
    int v7 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a2 + 24) = v6;
    uint64_t v8 = *(void *)(v3 + 8);
    *(_DWORD *)(a2 + 36) = v7 | 6;
    *(void *)(a2 + 16) = v8;
    unsigned int v9 = sub_100F8510C((int *)v3);
    uint64_t result = sub_10006ED58(v9);
    if (!result) {
      sub_101230274();
    }
    *(_DWORD *)(a2 + 36) |= 8u;
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v9;
  }

  return result;
}

void sub_100F8C780(_Unwind_Exception *a1)
{
}

uint64_t sub_100F8C79C(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  uint64_t v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertClientSatelliteConstellationToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    unsigned int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertClientSatelliteConstellationToProtobuf,unhandled type,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::ClientSatelliteConstellation ConvertClientSatelliteConstellationToProtobuf(const CLCli entSatelliteConstellation &)",  "%s\n",  v6);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8C964(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2 == 2) {
      return 3LL;
    }
    if (v2 == 1000) {
      return 1001LL;
    }
  }

  else
  {
    if (!v2) {
      return 1LL;
    }
    if (v2 == 1) {
      return 2LL;
    }
  }

  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v4 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "ConvertReachabilityTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v6 = *a1;
    v8[0] = 67240192;
    v8[1] = v6;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertReachabilityTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::ReachabilityType ConvertReachabilityTypeToProtobuf(const CLDaemonStatus_Type::Reachability &)",  "%s\n",  v7);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8CB60(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result >= 5)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)std::string buf = 67240192;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "ConvertBatteryChargerTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
    }

    BOOL v5 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      int v6 = *a1;
      v8[0] = 67240192;
      v8[1] = v6;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  16LL,  "ConvertBatteryChargerTypeToProtobuf,unhandled type,%{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLP::LogEntry::PrivateData::BatteryChargerType ConvertBatteryChargerTypeToProtobuf(const CLBatteryChargerType &)",  "%s\n",  v7);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100F8CD28(int *a1)
{
  if (!*a1) {
    return 1LL;
  }
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v2 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "ConvertSignalEnvironmentNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertSignalEnvironmentNotificationTypeToProtobuf,unhandled type,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::SignalEnvironmentNotification_NotificationType ConvertSignalEnvironmentNotificationTyp eToProtobuf(const CLSignalEnvironmentProvider_Type::Notification &)",  "%s\n",  v6);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8CEE8(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertSignalEnvironmentFidelityLevelTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertSignalEnvironmentFidelityLevelTypeToProtobuf,unhandled type,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::SignalEnvironmentFidelityLevel ConvertSignalEnvironmentFidelityLevelTypeToProtobuf(con st CLSignalEnvironmentProvider_Type::SignalEnvironmentFidelityLevel &)",  "%s\n",  v6);
    return 0LL;
  }

  return result;
}

uint64_t sub_100F8D0B0(int *a1)
{
  if (qword_101934910 != -1) {
    dispatch_once(&qword_101934910, &stru_10188FD60);
  }
  int v3 = (os_log_s *)qword_101934918;
  if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertMotionStateNotificationTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
  }

  uint64_t result = sub_1002921D0(115, 2);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v5 = *a1;
    v7[0] = 67240192;
    v7[1] = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertMotionStateNotificationTypeToProtobuf,unhandled type,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::MotionStateNotification_NotificationType ConvertMotionStateNotificationTypeToProtobuf( const CLMotionState_Type::Notification &)",  "%s\n",  v6);
    return 0LL;
  }

  return result;
}

unint64_t sub_100F8D278(unint64_t *a1)
{
  unint64_t result = *a1;
  if (result >= 3)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v4 = *a1;
      *(_DWORD *)std::string buf = 67240192;
      int v9 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertIndoorOutdoorTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
    }

    unint64_t result = sub_1002921D0(115, 2);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      unint64_t v5 = *a1;
      v7[0] = 67240192;
      v7[1] = v5;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertIndoorOutdoorTypeToProtobuf,unhandled type,%{public}d",  v7,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::IndoorOutdoorType ConvertIndoorOutdoorTypeToProtobuf(const CMIndoorOutdoorType &)",  "%s\n",  v6);
      return 0LL;
    }
  }

  return result;
}

unint64_t sub_100F8D438(unint64_t *a1)
{
  unint64_t result = *a1;
  if (result >= 4)
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    int v3 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v4 = *a1;
      *(_DWORD *)std::string buf = 67240192;
      int v9 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "ConvertIndoorOutdoorConfidenceTypeToProtobuf,unhandled type,%{public}d",  buf,  8u);
    }

    unint64_t result = sub_1002921D0(115, 2);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      unint64_t v5 = *a1;
      v7[0] = 67240192;
      v7[1] = v5;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  2LL,  "ConvertIndoorOutdoorConfidenceTypeToProtobuf,unhandled type,%{public}d",  v7,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLP::LogEntry::PrivateData::IndoorOutdoorConfidence ConvertIndoorOutdoorConfidenceTypeToProtobuf(const CMIndoorO utdoorConfidence &)",  "%s\n",  v6);
      return 0LL;
    }
  }

  return result;
}

void sub_100F8D5F8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(_DWORD *)(a2 + 56) |= 3u;
    *(_OWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)a1;
    unsigned int v4 = sub_100F8D278((unint64_t *)(a1 + 16));
    if (!sub_1000641E0(v4)) {
      sub_10123047C();
    }
    *(_DWORD *)(a2 + 56) |= 4u;
    *(_DWORD *)(a2 + 24) = v4;
    unsigned int v5 = sub_100F8D438((unint64_t *)(a1 + 24));
    if (!sub_10006ED58(v5)) {
      sub_101230454();
    }
    int v6 = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v5;
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)(a2 + 56) = v6 | 0x18;
    *(void *)(a2 + 32) = v7;
    unsigned int v8 = sub_100F8D438((unint64_t *)(a1 + 40));
    if (!sub_10006ED58(v8)) {
      sub_10123042C();
    }
    int v9 = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 40) = v8;
    *(_BYTE *)(a2 + 44) = *(_BYTE *)(a1 + 48);
    int v10 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 56) = v9 | 0xE0;
    *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v10;
  }

  else
  {
    if (qword_101934910 != -1) {
      dispatch_once(&qword_101934910, &stru_10188FD60);
    }
    uint64_t v11 = (os_log_s *)qword_101934918;
    if (os_log_type_enabled((os_log_t)qword_101934918, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "ConvertOutdoorUpdateToProtobuf,invalid pMsg pointer",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934910 != -1) {
        dispatch_once(&qword_101934910, &stru_10188FD60);
      }
      v13[0] = 0;
      int v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934918,  17LL,  "ConvertOutdoorUpdateToProtobuf,invalid pMsg pointer",  v13,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void ConvertOutdoorUpdateToProtobuf(const CLOutdoor_Type::OutdoorUpdate &, CLP::LogEntry::PrivateData::OutdoorUpdate *)",  "%s\n",  v12);
    }
  }

void sub_100F8D82C(id a1)
{
  qword_101934918 = (uint64_t)os_log_create("com.apple.locationd.Position", "PositionProto");
}

void *sub_100F8D858()
{
  unsigned __int8 v0 = operator new(0x30uLL);
  sub_1001D24B0((uint64_t)v0);
  return v0;
}

void sub_100F8D884(_Unwind_Exception *a1)
{
}

void *sub_100F8D898()
{
  unsigned __int8 v0 = operator new(0x38uLL);
  sub_1001D27EC((uint64_t)v0);
  return v0;
}

void sub_100F8D8C4(_Unwind_Exception *a1)
{
}

void *sub_100F8D8D8()
{
  unsigned __int8 v0 = operator new(0xA0uLL);
  sub_1001D2438((uint64_t)v0);
  return v0;
}

void sub_100F8D904(_Unwind_Exception *a1)
{
}

void *sub_100F8D918()
{
  unsigned __int8 v0 = operator new(0x178uLL);
  sub_1001D24CC((uint64_t)v0);
  return v0;
}

void sub_100F8D944(_Unwind_Exception *a1)
{
}

void sub_100F8D958(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void sub_100F8D960(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_100F8D968()
{
  return __cxa_atexit((void (*)(void *))sub_100F81E8C, &qword_10199F870, (void *)&_mh_execute_header);
}

uint64_t sub_100F8D984(uint64_t a1)
{
  float v1 = *(float *)(a1 + 20);
  unsigned int v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v7 = 0LL;
  sub_10001B72C(&v7, (const void *)qword_10199F878, qword_10199F880, (qword_10199F880 - qword_10199F878) >> 2);
  uint64_t v2 = (char *)v8 - (char *)v7;
  if (v8 != v7)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = v2 >> 2;
    while (v7[v3] < v1)
    {
      if (v4 == ++v3)
      {
        uint64_t v3 = v4;
        goto LABEL_8;
      }
    }

    goto LABEL_8;
  }

  uint64_t v3 = 0LL;
  uint64_t v5 = 0LL;
  if (v8)
  {
LABEL_8:
    unsigned int v8 = v7;
    operator delete(v7);
    return v3;
  }

  return v5;
}

uint64_t sub_100F8DA2C(uint64_t a1)
{
  float v1 = *(float *)(a1 + 8);
  float v2 = 0.0;
  if (v1 != 0.0) {
    float v2 = *(float *)(a1 + 12) / (float)(v1 * v1);
  }
  unsigned int v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  sub_10001B72C(&v8, (const void *)qword_10199F890, qword_10199F898, (qword_10199F898 - qword_10199F890) >> 2);
  uint64_t v3 = (char *)v9 - (char *)v8;
  if (v9 != v8)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = v3 >> 2;
    while (v8[v4] < v2)
    {
      if (v5 == ++v4)
      {
        uint64_t v4 = v5;
        goto LABEL_10;
      }
    }

    goto LABEL_10;
  }

  uint64_t v4 = 0LL;
  uint64_t v6 = 0LL;
  if (v9)
  {
LABEL_10:
    uint64_t v9 = v8;
    operator delete(v8);
    return v4;
  }

  return v6;
}

uint64_t sub_100F8DAEC(uint64_t a1)
{
  return (int)(*(float *)(a1 + 8) / 0.1);
}

uint64_t sub_100F8DB08()
{
  qword_10199F878 = 0LL;
  qword_10199F880 = 0LL;
  qword_10199F888 = 0LL;
  unsigned __int8 v0 = operator new(0x18uLL);
  qword_10199F880 = (uint64_t)(v0 + 3);
  qword_10199F888 = (uint64_t)(v0 + 3);
  *(_OWORD *)unsigned __int8 v0 = xmmword_1013BADC4;
  v0[2] = 0x4282000042480000LL;
  qword_10199F878 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_1001B4198, &qword_10199F878, (void *)&_mh_execute_header);
  qword_10199F898 = 0LL;
  unk_10199F8A0 = 0LL;
  qword_10199F890 = 0LL;
  float v1 = operator new(0x14uLL);
  qword_10199F898 = (uint64_t)(v1 + 5);
  unk_10199F8A0 = v1 + 5;
  v1[4] = 1108056474;
  *(_OWORD *)float v1 = xmmword_1013BADDC;
  qword_10199F890 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_1001B4198, &qword_10199F890, (void *)&_mh_execute_header);
}

uint64_t sub_100F8DBD0(uint64_t a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_10188FD90;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_10188FE48;
  sub_100B14CF0((void *)(a1 + 392), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 408), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 424), 0LL, 0LL);
  *(void *)(a1 + 440) = 0LL;
  *(void *)(a1 + 44_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(_WORD *)(a1 + 456) = 0;
  *(_OWORD *)(a1 + 460) = xmmword_1013BADF0;
  *(_OWORD *)(a1 + 476) = unk_1013BAE00;
  *(_OWORD *)(a1 + 492) = xmmword_1013BAE10;
  *(_OWORD *)(a1 + 504) = *(__int128 *)((char *)&xmmword_1013BAE10 + 12);
  (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  return a1;
}

void sub_100F8DCC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F8DCEC(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  int v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *int v12 = &off_10182BDA0;
  *(void *)a1 = off_101890138;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_1018901E0;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101890138;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_1018901E0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_DWORD *)(a1 + 312) = 12000;
  *(void *)(a1 + 320) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 328));
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v1 - 128), 8) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 240) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  int v15 = (int *)(a1 + 312);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 312));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101890220);
  }
  unint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890220);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    uint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLNatalieData>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CL SqliteDatabase::SqlitePropertyPersistence) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 240) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100F8E094( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[40] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_100F950A8(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100F8E138()
{
}

void *sub_100F8E140(void *a1)
{
  a1[9] = off_1018901E0;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101890138;
  a1[40] = off_10182BD58;
  sub_1001B9C98(a1 + 41);
  sub_100F950A8(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100F8E1BC(void *a1)
{
  *a1 = off_10188FD90;
  a1[9] = off_10188FE48;
  sub_100F8E200((uint64_t)a1, 0LL, 0LL);
  return sub_100F8E140(a1);
}

void sub_100F8E200(uint64_t a1, void *a2, const void *a3)
{
  if ((a2 != 0LL) == (a3 != 0LL))
  {

    *(void *)(a1 + 440) = a2;
    char v6 = *(const void **)(a1 + 448);
    if (v6) {
      _Block_release(v6);
    }
    if (a3) {
      *(void *)(a1 + 44_Block_object_dispose((const void *)(v1 - 128), 8) = _Block_copy(a3);
    }
  }

  else
  {
    uint64_t v7 = sub_10127B2DC();
    sub_100F8E274(v7);
  }

void *sub_100F8E278(uint64_t a1)
{
  return sub_100F8E1BC((void *)(a1 - 72));
}

void sub_100F8E280(void *a1)
{
  float v1 = sub_100F8E1BC(a1);
  operator delete(v1);
}

void sub_100F8E294(uint64_t a1)
{
  float v1 = sub_100F8E1BC((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100F8E2AC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  v20[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v21 = 256;
  if (*(double *)(*(void *)(a2 + 8) - 16LL) != 1.79769313e308)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    uint64_t v14 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "DB, Error expiring records.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      LOWORD(v20[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, Error expiring records.",  v20,  2);
      unint64_t v19 = (uint8_t *)v18;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual long CLNatalimetryRecorderDb::aggregateRecords(const CLAggregationRules &)",  "%s\n",  v18);
      if (v19 != buf) {
        free(v19);
      }
    }

    goto LABEL_13;
  }

  if (!sub_100D8A92C(a1 + 72))
  {
LABEL_13:
    uint64_t v13 = -1LL;
    goto LABEL_20;
  }

  sub_1003C0454(*(void *)(a1 + 80));
  double Current = CFAbsoluteTimeGetCurrent();
  if (!(*(unsigned int (**)(uint64_t, uint8_t *))(*(void *)a1 + 104LL))(a1, buf))
  {
    double v7 = Current - *(double *)(*(void *)(a2 + 8) - 24LL);
    if (v7 > v23) {
      sub_100F8E5E4((float *)a1, v23, v7);
    }
  }

  sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM NatalieHistory WHERE startTime < ?", v20);
  uint64_t v8 = v20[0];
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(v20[0]);
  if (sub_1003B7480(v9, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v10 = *(void *)(a1 + 80);
    uint64_t v11 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v10, v11);
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    *(_DWORD *)(a1 + 132) = v12;
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = -1LL;
  }

  sub_1003C05BC(*(void *)(a1 + 80));
  uint64_t v15 = *(void *)(a1 + 80);
  else {
    uint64_t v16 = *(void *)(v15 + 88);
  }
  sub_1003C1EC0(v15, v16);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
LABEL_20:
  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v13;
}

void sub_100F8E594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100F8E5E4(float *a1, double a2, double a3)
{
  double v6 = a3 - a2;
  float v7 = sub_100B7E740(a1 + 115, 0LL);
  float v8 = v6 * (float)(v7 * a1[118]) / 3600.0;
  if ((uint64_t)(float)(v8 * 1000.0))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    uint64_t v9 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 134218752;
      *(double *)int v22 = v8;
      *(_WORD *)&v22[8] = 2048;
      *(double *)&v22[10] = a2;
      *(_WORD *)&v22[18] = 2048;
      double v23 = a3;
      LOWORD(v24) = 2048;
      *(double *)((char *)&v24 + 2) = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "DB, Inserting basal calories %f for gap (%lf - %lf, %lfs)",  buf,  0x2Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      int v13 = 134218752;
      double v14 = v8;
      __int16 v15 = 2048;
      double v16 = a2;
      __int16 v17 = 2048;
      double v18 = a3;
      __int16 v19 = 2048;
      double v20 = v6;
      LODWORD(v12) = 42;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, Inserting basal calories %f for gap (%lf - %lf, %lfs)",  COERCE_DOUBLE(&v13),  v12);
      uint64_t v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryRecorderDb::insertNataliesForGap(const CFAbsoluteTime, const CFAbsoluteTime)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    *(_DWORD *)std::string buf = 0;
    *(void *)&v22[4] = 0LL;
    *(double *)&v22[12] = a3;
    LODWORD(v23) = 0;
    WORD2(v23) = 0;
    *(double *)&__int128 v24 = v7;
    *((double *)&v24 + 1) = v7;
    uint64_t v25 = (uint64_t)(float)(v8 * 1000.0);
    uint64_t v26 = v25;
    double v27 = v6;
    v28[0] = 0LL;
    v28[1] = 0LL;
    uuid_clear((unsigned __int8 *)v28);
    (*(void (**)(float *, uint8_t *, void))(*(void *)a1 + 120LL))(a1, buf, 0LL);
  }

uint64_t sub_100F8E880(uint64_t a1, uint64_t a2)
{
  return sub_100F8E2AC(a1 - 72, a2);
}

uint64_t sub_100F8E888(uint64_t a1, void **a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v33[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v34 = 256;
  if (sub_100D8A92C(v6))
  {
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * FROM NatalieHistory ORDER BY startTime ASC", &v35);
    uint64_t v7 = v35;
    v33[0] = v35;
    while (!sub_100F8EB38(v33, (uint64_t)v41))
    {
      sub_100F8ECA4((uint64_t)v41, (uint64_t)&v35);
      float v8 = (char *)a2[1];
      uint64_t v9 = (char *)a2[2];
      if (v8 >= v9)
      {
        uint64_t v15 = 0x2E8BA2E8BA2E8BA3LL * ((v8 - (_BYTE *)*a2) >> 3);
        unint64_t v16 = v15 + 1;
        unint64_t v17 = 0x2E8BA2E8BA2E8BA3LL * ((v9 - (_BYTE *)*a2) >> 3);
        if (2 * v17 > v16) {
          unint64_t v16 = 2 * v17;
        }
        if (v17 >= 0x1745D1745D1745DLL) {
          unint64_t v18 = 0x2E8BA2E8BA2E8BALL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18) {
          __int16 v19 = (char *)sub_100023598((uint64_t)(a2 + 2), v18);
        }
        else {
          __int16 v19 = 0LL;
        }
        double v20 = &v19[88 * v15];
        __int128 v21 = v36;
        *(_OWORD *)double v20 = v35;
        *((_OWORD *)v20 + 1) = v21;
        __int128 v22 = v37;
        __int128 v23 = v38;
        __int128 v24 = v39;
        *((void *)v20 + 10) = v40;
        *((_OWORD *)v20 + 3) = v23;
        *((_OWORD *)v20 + 4) = v24;
        *((_OWORD *)v20 + 2) = v22;
        uint64_t v26 = (char *)*a2;
        uint64_t v25 = (char *)a2[1];
        double v27 = v20;
        if (v25 != *a2)
        {
          do
          {
            __int128 v28 = *(_OWORD *)(v25 - 88);
            *(_OWORD *)(v27 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v25 - 72);
            *(_OWORD *)(v27 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v28;
            __int128 v29 = *(_OWORD *)(v25 - 56);
            __int128 v30 = *(_OWORD *)(v25 - 40);
            __int128 v31 = *(_OWORD *)(v25 - 24);
            *((void *)v27 - 1) = *((void *)v25 - 1);
            *(_OWORD *)(v27 - 24) = v31;
            *(_OWORD *)(v27 - 40) = v30;
            *(_OWORD *)(v27 - 56) = v29;
            v27 -= 88;
            v25 -= 88;
          }

          while (v25 != v26);
          uint64_t v25 = (char *)*a2;
        }

        double v14 = v20 + 88;
        *a2 = v27;
        a2[1] = v20 + 88;
        a2[2] = &v19[88 * v18];
        if (v25) {
          operator delete(v25);
        }
      }

      else
      {
        __int128 v10 = v36;
        *(_OWORD *)float v8 = v35;
        *((_OWORD *)v8 + 1) = v10;
        __int128 v11 = v37;
        __int128 v12 = v38;
        __int128 v13 = v39;
        *((void *)v8 + 10) = v40;
        *((_OWORD *)v8 + 3) = v12;
        *((_OWORD *)v8 + 4) = v13;
        *((_OWORD *)v8 + 2) = v11;
        double v14 = v8 + 88;
      }

      a2[1] = v14;
    }

    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
}

void sub_100F8EAF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F8EB38(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)a2 = sqlite3_column_int(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v7, 1);
  float v8 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 16) = sqlite3_column_int(v8, 2);
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 20) = sqlite3_column_int(v9, 3);
  __int128 v10 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 24) = sqlite3_column_double(v10, 4);
  __int128 v11 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)(a2 + 32) = sqlite3_column_int64(v11, 5);
  __int128 v12 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)(a2 + 40) = sqlite3_column_int64(v12, 6);
  __int128 v13 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_int(v13, 7);
  double v14 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 56) = sqlite3_column_double(v14, 8);
  uint64_t v15 = (sqlite3_stmt *)sub_100019240(*a1);
  unint64_t v16 = sqlite3_column_text(v15, 9);
  int v17 = uuid_parse((const char *)v16, uu);
  unint64_t v18 = (unsigned __int8 *)(a2 + 64);
  if (v17) {
    uuid_clear(v18);
  }
  else {
    uuid_copy(v18, uu);
  }
  return 0LL;
}

void sub_100F8ECA4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  int v2 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 16);
  *(void *)(a2 + 16) = *(void *)(a1 + 8);
  *(_BYTE *)(a2 + 29) = v2 != 0;
  uint64_t v3 = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a1 + 32);
  *(_BYTE *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = *(_DWORD *)(a1 + 48) != 0;
  uint64_t v4 = *(void *)(a1 + 56);
  *(void *)(a2 + 32) = v3;
  *(void *)(a2 + 40) = v4;
  uuid_copy((unsigned __int8 *)(a2 + 72), (const unsigned __int8 *)(a1 + 64));
}

uint64_t sub_100F8ECFC(uint64_t *a1, uint64_t a2, void **a3)
{
  uint64_t v7 = a1 + 14;
  uint64_t v6 = a1[14];
  float v8 = a1 + 9;
  __int128 v131 = a1 + 14;
  (*(void (**)(uint64_t *))(v6 + 16))(a1 + 14);
  __int16 v132 = 256;
  if ((sub_100D8A92C(v8) & 1) != 0)
  {
    uint64_t v9 = (const __CFString *)sub_1003B76B4(a1[10]);
    if (v9)
    {
      sub_1003C0D54(a1[10], "SELECT * FROM NatalieHistory WHERE id >= ? ORDER BY id DESC LIMIT ?", buf);
      uint64_t v10 = *(void *)buf;
      uint64_t v130 = *(void *)buf;
      if (*(double *)(a2 + 16) != 0.0 && vabdd_f64(CFAbsoluteTimeGetCurrent(), *(double *)(a2 + 16)) > 86400.0)
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        __int128 v11 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = *(void *)(a2 + 16);
          *(_DWORD *)std::string buf = 134217984;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "Attempting to request data older than 24 hours with queryNatalieDataSince, start, %f",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_10188FEF8);
          }
          uint64_t v123 = *(void *)(a2 + 16);
          int v133 = 134217984;
          *(void *)__int128 v134 = v123;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Attempting to request data older than 24 hours with queryNatalieDataSince, start, %f",  COERCE_DOUBLE(&v133));
          __int128 v125 = (uint8_t *)v124;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const",  "%s\n",  v124);
          if (v125 != buf) {
            free(v125);
          }
        }
      }

      __int128 v13 = *(const __CFString **)(a2 + 8);
      if (v13 && CFStringCompare(v13, v9, 1uLL))
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        double v14 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "DB, Potential DB reset, returning all records to clients",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_10188FEF8);
          }
          LOWORD(v133) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "DB, Potential DB reset, returning all records to clients",  &v133,  2,  v130);
          __int128 v122 = (uint8_t *)v121;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const",  "%s\n",  v121);
          if (v122 != buf) {
            free(v122);
          }
        }

        uint64_t v15 = (sqlite3_stmt *)sub_100019240(v10);
        if (sub_1003C28BC(v15, 1, 1))
        {
          unint64_t v16 = (sqlite3_stmt *)sub_100019240(v10);
          if (sub_1003C28BC( v16,  2,  (int)objc_msgSend( +[CMNatalieData maxNatalieEntries](CMNatalieData, "maxNatalieEntries"),  "intValue")))
          {
            while (!sub_100F8EB38(&v130, (uint64_t)v151))
            {
              sub_100F8ECA4((uint64_t)v151, (uint64_t)&v145);
              *((void *)&v145 + 1) = v9;
              int v17 = (char *)a3[1];
              unint64_t v18 = (char *)a3[2];
              if (v17 >= v18)
              {
                uint64_t v24 = 0x2E8BA2E8BA2E8BA3LL * ((v17 - (_BYTE *)*a3) >> 3);
                unint64_t v25 = v24 + 1;
                unint64_t v26 = 0x2E8BA2E8BA2E8BA3LL * ((v18 - (_BYTE *)*a3) >> 3);
                if (2 * v26 > v25) {
                  unint64_t v25 = 2 * v26;
                }
                if (v26 >= 0x1745D1745D1745DLL) {
                  unint64_t v27 = 0x2E8BA2E8BA2E8BALL;
                }
                else {
                  unint64_t v27 = v25;
                }
                if (v27) {
                  __int128 v28 = (char *)sub_100023598((uint64_t)(a3 + 2), v27);
                }
                else {
                  __int128 v28 = 0LL;
                }
                __int128 v29 = &v28[88 * v24];
                __int128 v30 = v146;
                *(_OWORD *)__int128 v29 = v145;
                *((_OWORD *)v29 + 1) = v30;
                __int128 v31 = v147;
                __int128 v32 = v148;
                __int128 v33 = v149;
                *((void *)v29 + 10) = v150;
                *((_OWORD *)v29 + 3) = v32;
                *((_OWORD *)v29 + 4) = v33;
                *((_OWORD *)v29 + 2) = v31;
                __int128 v35 = (char *)*a3;
                __int16 v34 = (char *)a3[1];
                __int128 v36 = v29;
                if (v34 != *a3)
                {
                  do
                  {
                    __int128 v37 = *(_OWORD *)(v34 - 88);
                    *(_OWORD *)(v36 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v34 - 72);
                    *(_OWORD *)(v36 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v37;
                    __int128 v38 = *(_OWORD *)(v34 - 56);
                    __int128 v39 = *(_OWORD *)(v34 - 40);
                    __int128 v40 = *(_OWORD *)(v34 - 24);
                    *((void *)v36 - 1) = *((void *)v34 - 1);
                    *(_OWORD *)(v36 - 24) = v40;
                    *(_OWORD *)(v36 - 40) = v39;
                    *(_OWORD *)(v36 - 56) = v38;
                    v36 -= 88;
                    v34 -= 88;
                  }

                  while (v34 != v35);
                  __int16 v34 = (char *)*a3;
                }

                __int128 v23 = v29 + 88;
                *a3 = v36;
                a3[1] = v29 + 88;
                a3[2] = &v28[88 * v27];
                if (v34) {
                  operator delete(v34);
                }
              }

              else
              {
                __int128 v19 = v146;
                *(_OWORD *)int v17 = v145;
                *((_OWORD *)v17 + 1) = v19;
                __int128 v20 = v147;
                __int128 v21 = v148;
                __int128 v22 = v149;
                *((void *)v17 + 10) = v150;
                *((_OWORD *)v17 + 3) = v21;
                *((_OWORD *)v17 + 4) = v22;
                *((_OWORD *)v17 + 2) = v20;
                __int128 v23 = v17 + 88;
              }

              a3[1] = v23;
            }

            double v90 = *a3;
            unint64_t v91 = a3[1];
            unint64_t v92 = (unint64_t)v91 - 88;
            if (*a3 != v91 && v92 > (unint64_t)v90)
            {
              unint64_t v94 = (unint64_t)v90 + 88;
              do
              {
                *(_OWORD *)&v153[16] = *(_OWORD *)(v94 - 56);
                __int128 v154 = *(_OWORD *)(v94 - 40);
                __int128 v155 = *(_OWORD *)(v94 - 24);
                uint64_t v156 = *(void *)(v94 - 8);
                *(_OWORD *)std::string buf = *(_OWORD *)(v94 - 88);
                *(_OWORD *)__int128 v153 = *(_OWORD *)(v94 - 72);
                __int128 v95 = *(_OWORD *)(v92 + 16);
                *(_OWORD *)(v94 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)v92;
                *(_OWORD *)(v94 - sub_1011C52D0(v23 - 72) = v95;
                __int128 v97 = *(_OWORD *)(v92 + 48);
                __int128 v96 = *(_OWORD *)(v92 + 64);
                uint64_t v98 = *(void *)(v92 + 80);
                *(_OWORD *)(v94 - 56) = *(_OWORD *)(v92 + 32);
                *(void *)(v94 - _Block_object_dispose((const void *)(v1 - 128), 8) = v98;
                *(_OWORD *)(v94 - 24) = v96;
                *(_OWORD *)(v94 - 40) = v97;
                *(_OWORD *)unint64_t v92 = *(_OWORD *)buf;
                *(void *)(v92 + sub_100F6A7D8(v1 + 80) = v156;
                *(_OWORD *)(v92 + 64) = v155;
                *(_OWORD *)(v92 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v154;
                *(_OWORD *)(v92 + 32) = *(_OWORD *)&v153[16];
                *(_OWORD *)(v92 + 16) = *(_OWORD *)v153;
                v92 -= 88LL;
                BOOL v89 = v94 >= v92;
                v94 += 88LL;
              }

              while (!v89);
            }
          }
        }
      }

      else if ((*(unsigned int (**)(uint64_t *, __int128 *))(*a1 + 104))(a1, &v139) {
             || (int)v139 >= *(_DWORD *)a2 && (uint64_t)v142 >= *(void *)(a2 + 48))
      }
      {
        int v43 = (sqlite3_stmt *)sub_100019240(v10);
        if (sub_1003C28BC(v43, 1, *(_DWORD *)a2))
        {
          __int16 v44 = (sqlite3_stmt *)sub_100019240(v10);
          if (sub_1003C28BC( v44,  2,  (int)objc_msgSend( +[CMNatalieData maxNatalieEntries](CMNatalieData, "maxNatalieEntries"),  "intValue")))
          {
            while (!sub_100F8EB38(&v130, (uint64_t)v151))
            {
              sub_100F8ECA4((uint64_t)v151, (uint64_t)&v145);
              *((void *)&v145 + 1) = v9;
              int v45 = (char *)a3[1];
              unsigned int v46 = (char *)a3[2];
              if (v45 >= v46)
              {
                uint64_t v52 = 0x2E8BA2E8BA2E8BA3LL * ((v45 - (_BYTE *)*a3) >> 3);
                unint64_t v53 = v52 + 1;
                unint64_t v54 = 0x2E8BA2E8BA2E8BA3LL * ((v46 - (_BYTE *)*a3) >> 3);
                if (2 * v54 > v53) {
                  unint64_t v53 = 2 * v54;
                }
                if (v54 >= 0x1745D1745D1745DLL) {
                  unint64_t v55 = 0x2E8BA2E8BA2E8BALL;
                }
                else {
                  unint64_t v55 = v53;
                }
                if (v55) {
                  __int128 v56 = (char *)sub_100023598((uint64_t)(a3 + 2), v55);
                }
                else {
                  __int128 v56 = 0LL;
                }
                __int128 v57 = &v56[88 * v52];
                __int128 v58 = v146;
                *(_OWORD *)__int128 v57 = v145;
                *((_OWORD *)v57 + 1) = v58;
                __int128 v59 = v147;
                __int128 v60 = v148;
                __int128 v61 = v149;
                *((void *)v57 + 10) = v150;
                *((_OWORD *)v57 + 3) = v60;
                *((_OWORD *)v57 + 4) = v61;
                *((_OWORD *)v57 + 2) = v59;
                __int128 v63 = (char *)*a3;
                __int128 v62 = (char *)a3[1];
                __int128 v64 = v57;
                if (v62 != *a3)
                {
                  do
                  {
                    __int128 v65 = *(_OWORD *)(v62 - 88);
                    *(_OWORD *)(v64 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v62 - 72);
                    *(_OWORD *)(v64 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v65;
                    __int128 v66 = *(_OWORD *)(v62 - 56);
                    __int128 v67 = *(_OWORD *)(v62 - 40);
                    __int128 v68 = *(_OWORD *)(v62 - 24);
                    *((void *)v64 - 1) = *((void *)v62 - 1);
                    *(_OWORD *)(v64 - 24) = v68;
                    *(_OWORD *)(v64 - 40) = v67;
                    *(_OWORD *)(v64 - 56) = v66;
                    v64 -= 88;
                    v62 -= 88;
                  }

                  while (v62 != v63);
                  __int128 v62 = (char *)*a3;
                }

                __int128 v51 = v57 + 88;
                *a3 = v64;
                a3[1] = v57 + 88;
                a3[2] = &v56[88 * v55];
                if (v62) {
                  operator delete(v62);
                }
              }

              else
              {
                __int128 v47 = v146;
                *(_OWORD *)int v45 = v145;
                *((_OWORD *)v45 + 1) = v47;
                __int128 v48 = v147;
                __int128 v49 = v148;
                __int128 v50 = v149;
                *((void *)v45 + 10) = v150;
                *((_OWORD *)v45 + 3) = v49;
                *((_OWORD *)v45 + 4) = v50;
                *((_OWORD *)v45 + 2) = v48;
                __int128 v51 = v45 + 88;
              }

              a3[1] = v51;
            }

            __int128 v80 = *a3;
            __int128 v81 = a3[1];
            unint64_t v82 = (unint64_t)v81 - 88;
            if (*a3 != v81 && v82 > (unint64_t)v80)
            {
              unint64_t v84 = (unint64_t)v80 + 88;
              do
              {
                *(_OWORD *)&v153[16] = *(_OWORD *)(v84 - 56);
                __int128 v154 = *(_OWORD *)(v84 - 40);
                __int128 v155 = *(_OWORD *)(v84 - 24);
                uint64_t v156 = *(void *)(v84 - 8);
                *(_OWORD *)std::string buf = *(_OWORD *)(v84 - 88);
                *(_OWORD *)__int128 v153 = *(_OWORD *)(v84 - 72);
                __int128 v85 = *(_OWORD *)(v82 + 16);
                *(_OWORD *)(v84 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)v82;
                *(_OWORD *)(v84 - sub_1011C52D0(v23 - 72) = v85;
                __int128 v87 = *(_OWORD *)(v82 + 48);
                __int128 v86 = *(_OWORD *)(v82 + 64);
                uint64_t v88 = *(void *)(v82 + 80);
                *(_OWORD *)(v84 - 56) = *(_OWORD *)(v82 + 32);
                *(void *)(v84 - _Block_object_dispose((const void *)(v1 - 128), 8) = v88;
                *(_OWORD *)(v84 - 24) = v86;
                *(_OWORD *)(v84 - 40) = v87;
                *(_OWORD *)unint64_t v82 = *(_OWORD *)buf;
                *(void *)(v82 + sub_100F6A7D8(v1 + 80) = v156;
                *(_OWORD *)(v82 + 64) = v155;
                *(_OWORD *)(v82 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v154;
                *(_OWORD *)(v82 + 32) = *(_OWORD *)&v153[16];
                *(_OWORD *)(v82 + 16) = *(_OWORD *)v153;
                v82 -= 88LL;
                BOOL v89 = v84 >= v82;
                v84 += 88LL;
              }

              while (!v89);
            }
          }
        }
      }

      else
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        __int128 v70 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
        {
          int v71 = *(_DWORD *)a2;
          uint64_t v72 = *(void *)(a2 + 48);
          *(_DWORD *)std::string buf = 67109888;
          *(_DWORD *)&uint8_t buf[4] = v139;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v71;
          *(_WORD *)&buf[14] = 2048;
          *(void *)__int128 v153 = v142;
          *(_WORD *)&v153[8] = 2048;
          *(void *)&v153[10] = v72;
          _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_ERROR,  "DB, CalorimetryHistory has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.nata lies,%lld,record.natalies,%lld",  buf,  0x22u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_10188FEF8);
          }
          int v126 = *(_DWORD *)a2;
          uint64_t v127 = *(void *)(a2 + 48);
          int v133 = 67109888;
          *(_DWORD *)__int128 v134 = v139;
          *(_WORD *)&v134[4] = 1024;
          *(_DWORD *)&_BYTE v134[6] = v126;
          __int16 v135 = 2048;
          uint64_t v136 = v142;
          __int16 v137 = 2048;
          uint64_t v138 = v127;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "DB, CalorimetryHistory has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.nata lies,%lld,record.natalies,%lld",  &v133,  34,  v130,  v131);
          __int128 v129 = (uint8_t *)v128;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const",  "%s\n",  v128);
          if (v129 != buf) {
            free(v129);
          }
        }

        CLWriteStackshot("Calorie history has rolled back!!", 0LL);
        *((void *)&v139 + 1) = v9;
        __int128 v73 = (char *)a3[2];
        __int128 v74 = (char *)a3[1];
        if (v74 >= v73)
        {
          uint64_t v99 = 0x2E8BA2E8BA2E8BA3LL * ((v74 - (_BYTE *)*a3) >> 3);
          unint64_t v100 = v99 + 1;
          if ((unint64_t)(v99 + 1) > 0x2E8BA2E8BA2E8BALL) {
LABEL_136:
          }
            sub_100007008();
          unint64_t v101 = 0x2E8BA2E8BA2E8BA3LL * ((v73 - (_BYTE *)*a3) >> 3);
          if (2 * v101 > v100) {
            unint64_t v100 = 2 * v101;
          }
          if (v101 >= 0x1745D1745D1745DLL) {
            unint64_t v102 = 0x2E8BA2E8BA2E8BALL;
          }
          else {
            unint64_t v102 = v100;
          }
          if (v102) {
            __int128 v103 = (char *)sub_100023598((uint64_t)(a3 + 2), v102);
          }
          else {
            __int128 v103 = 0LL;
          }
          __int128 v104 = &v103[88 * v99];
          __int128 v105 = &v103[88 * v102];
          __int128 v106 = v140;
          *(_OWORD *)__int128 v104 = v139;
          *((_OWORD *)v104 + 1) = v106;
          __int128 v107 = v141;
          __int128 v108 = v142;
          __int128 v109 = v143;
          *((void *)v104 + 10) = v144;
          *((_OWORD *)v104 + 3) = v108;
          *((_OWORD *)v104 + 4) = v109;
          *((_OWORD *)v104 + 2) = v107;
          BOOL v79 = v104 + 88;
          double v111 = (char *)*a3;
          __int128 v110 = (char *)a3[1];
          if (v110 != *a3)
          {
            do
            {
              __int128 v112 = *(_OWORD *)(v110 - 88);
              *(_OWORD *)(v104 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v110 - 72);
              *(_OWORD *)(v104 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v112;
              __int128 v113 = *(_OWORD *)(v110 - 56);
              __int128 v114 = *(_OWORD *)(v110 - 40);
              __int128 v115 = *(_OWORD *)(v110 - 24);
              *((void *)v104 - 1) = *((void *)v110 - 1);
              *(_OWORD *)(v104 - 24) = v115;
              *(_OWORD *)(v104 - 40) = v114;
              *(_OWORD *)(v104 - 56) = v113;
              v104 -= 88;
              v110 -= 88;
            }

            while (v110 != v111);
            __int128 v110 = (char *)*a3;
          }

          *a3 = v104;
          a3[1] = v79;
          a3[2] = v105;
          if (v110) {
            operator delete(v110);
          }
        }

        else
        {
          __int128 v75 = v140;
          *(_OWORD *)__int128 v74 = v139;
          *((_OWORD *)v74 + 1) = v75;
          __int128 v76 = v141;
          __int128 v77 = v142;
          __int128 v78 = v143;
          *((void *)v74 + 10) = v144;
          *((_OWORD *)v74 + 3) = v77;
          *((_OWORD *)v74 + 4) = v78;
          *((_OWORD *)v74 + 2) = v76;
          BOOL v79 = v74 + 88;
        }

        a3[1] = v79;
      }

      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
      }
      uint64_t v42 = 100LL;
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      __int128 v69 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, "DB, UUID un-initialized", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        LOWORD(v145) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, UUID un-initialized",  &v145,  2);
        __int128 v120 = (uint8_t *)v119;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const",  "%s\n",  v119);
        if (v120 != buf) {
          free(v120);
        }
      }

      uint64_t v42 = 103LL;
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    uint64_t v41 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEBUG,  "DB, CalorimetryHistory not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      LOWORD(v145) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, CalorimetryHistory not accessible",  &v145,  2);
      __int128 v118 = (uint8_t *)v117;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const",  "%s\n",  v117);
      if (v118 != buf) {
        free(v118);
      }
    }

    uint64_t v42 = 109LL;
  }

  (*(void (**)(uint64_t *))(*v7 + 24))(v7);
  return v42;
}

void sub_100F8FB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F8FBE8(uint64_t a1, void **a2, double a3, double a4)
{
  uint64_t v9 = a1 + 112;
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v10 = a1 + 72;
  v51[1] = a1 + 112;
  (*(void (**)(uint64_t))(v8 + 16))(a1 + 112);
  __int16 v52 = 256;
  if ((sub_100D8A92C(v10) & 1) != 0)
  {
    uint64_t v11 = sub_1003B76B4(*(void *)(a1 + 80));
    if (v11)
    {
      sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM NatalieHistory WHERE startTime >= ? and startTime < ? ORDER BY startTime ASC",  buf);
      uint64_t v12 = *(void *)buf;
      v51[0] = *(void *)buf;
      if (a4 > a3)
      {
        if (vabdd_f64(CFAbsoluteTimeGetCurrent(), a3) > 86400.0)
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_10188FEF8);
          }
          __int128 v13 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 134218240;
            *(double *)&uint8_t buf[4] = a3;
            __int16 v65 = 2048;
            double v66 = a4;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Attempting to request data older than 24 hours with queryNatalieData, start, %f, end, %f",  buf,  0x16u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_10188FEF8);
            }
            int v53 = 134218240;
            double v54 = a3;
            __int16 v55 = 2048;
            double v56 = a4;
            LODWORD(v50) = 22;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Attempting to request data older than 24 hours with queryNatalieData, start, %f, end, %f",  COERCE_DOUBLE(&v53),  v50);
            __int128 v49 = (char *)v48;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieData(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLNatalieData> &) const",  "%s\n",  v48);
            if (v49 != buf) {
              free(v49);
            }
          }
        }

        double v14 = (sqlite3_stmt *)sub_100019240(v12);
        if (sub_1003B7480(v14, 1, a3))
        {
          uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
          if (sub_1003B7480(v15, 2, a4))
          {
            while (!sub_100F8EB38(v51, (uint64_t)v63))
            {
              sub_100F8ECA4((uint64_t)v63, (uint64_t)&v57);
              *((void *)&v57 + 1) = v11;
              unint64_t v16 = (char *)a2[1];
              int v17 = (char *)a2[2];
              if (v16 >= v17)
              {
                uint64_t v23 = 0x2E8BA2E8BA2E8BA3LL * ((v16 - (_BYTE *)*a2) >> 3);
                unint64_t v24 = v23 + 1;
                unint64_t v25 = 0x2E8BA2E8BA2E8BA3LL * ((v17 - (_BYTE *)*a2) >> 3);
                if (2 * v25 > v24) {
                  unint64_t v24 = 2 * v25;
                }
                if (v25 >= 0x1745D1745D1745DLL) {
                  unint64_t v26 = 0x2E8BA2E8BA2E8BALL;
                }
                else {
                  unint64_t v26 = v24;
                }
                if (v26) {
                  unint64_t v27 = (char *)sub_100023598((uint64_t)(a2 + 2), v26);
                }
                else {
                  unint64_t v27 = 0LL;
                }
                __int128 v28 = &v27[88 * v23];
                __int128 v29 = v58;
                *(_OWORD *)__int128 v28 = v57;
                *((_OWORD *)v28 + 1) = v29;
                __int128 v30 = v59;
                __int128 v31 = v60;
                __int128 v32 = v61;
                *((void *)v28 + 10) = v62;
                *((_OWORD *)v28 + 3) = v31;
                *((_OWORD *)v28 + 4) = v32;
                *((_OWORD *)v28 + 2) = v30;
                __int16 v34 = (char *)*a2;
                __int128 v33 = (char *)a2[1];
                __int128 v35 = v28;
                if (v33 != *a2)
                {
                  do
                  {
                    __int128 v36 = *(_OWORD *)(v33 - 88);
                    *(_OWORD *)(v35 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v33 - 72);
                    *(_OWORD *)(v35 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v36;
                    __int128 v37 = *(_OWORD *)(v33 - 56);
                    __int128 v38 = *(_OWORD *)(v33 - 40);
                    __int128 v39 = *(_OWORD *)(v33 - 24);
                    *((void *)v35 - 1) = *((void *)v33 - 1);
                    *(_OWORD *)(v35 - 24) = v39;
                    *(_OWORD *)(v35 - 40) = v38;
                    *(_OWORD *)(v35 - 56) = v37;
                    v35 -= 88;
                    v33 -= 88;
                  }

                  while (v33 != v34);
                  __int128 v33 = (char *)*a2;
                }

                __int128 v22 = v28 + 88;
                *a2 = v35;
                a2[1] = v28 + 88;
                a2[2] = &v27[88 * v26];
                if (v33) {
                  operator delete(v33);
                }
              }

              else
              {
                __int128 v18 = v58;
                *(_OWORD *)unint64_t v16 = v57;
                *((_OWORD *)v16 + 1) = v18;
                __int128 v19 = v59;
                __int128 v20 = v60;
                __int128 v21 = v61;
                *((void *)v16 + 10) = v62;
                *((_OWORD *)v16 + 3) = v20;
                *((_OWORD *)v16 + 4) = v21;
                *((_OWORD *)v16 + 2) = v19;
                __int128 v22 = v16 + 88;
              }

              a2[1] = v22;
            }
          }
        }
      }

      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      }
      uint64_t v41 = 100LL;
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      uint64_t v42 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, "DB, UUID un-initialized", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        LOWORD(v57) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, UUID un-initialized",  &v57,  2);
        __int128 v47 = (char *)v46;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::queryNatalieData(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLNatalieData> &) const",  "%s\n",  v46);
        if (v47 != buf) {
          free(v47);
        }
      }

      uint64_t v41 = 103LL;
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    __int128 v40 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "DB, not accessible", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      LOWORD(v57) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, not accessible",  &v57,  2);
      int v45 = (char *)v44;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLNatalimetryRecorderDb::queryNatalieData(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLNatalieData> &) const",  "%s\n",  v44);
      if (v45 != buf) {
        free(v45);
      }
    }

    uint64_t v41 = 109LL;
  }

  (*(void (**)(uint64_t))(*(void *)v9 + 24LL))(v9);
  return v41;
}

void sub_100F902A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F902F8(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v7 = a1 + 112;
  uint64_t v6 = *(void *)(a1 + 112);
  v29[1] = a1 + 112;
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 112);
  __int16 v30 = 256;
  uuid_clear((unsigned __int8 *)&v37);
  uuid_clear(v38);
  memset(buf, 0, sizeof(buf));
  __int128 v8 = *(_OWORD *)v38;
  *(void *)(a3 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  __int128 v9 = *(_OWORD *)buf;
  *(_OWORD *)(a3 + 16) = v37;
  *(_OWORD *)(a3 + 32) = v8;
  *(_OWORD *)a3 = v9;
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    uint64_t v10 = (const __CFString *)sub_1003B76B4(*(void *)(a1 + 80));
    if (v10)
    {
      CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
      uuid_parse(CStringPtr, uu);
      uuid_unparse(a2, out);
      sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * from NatalieHistory WHERE sessionUUID = ? ORDER BY startTime ASC",  buf);
      uint64_t v12 = *(void *)buf;
      v29[0] = *(void *)buf;
      __int128 v13 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
      if (sub_1003BC1F0(v13, 1, out))
      {
        if (!sub_100F8EB38(v29, (uint64_t)buf))
        {
          double v14 = 0.0;
          double v15 = *(double *)&buf[8];
          double v16 = 0.0;
          while (!sub_100F8EB38(v29, (uint64_t)&v31))
          {
            double v16 = v16 + *(double *)&v32[4] - v15;
            double v14 = v14 + (*(double *)&v32[4] - v15) * v33;
            double v15 = *(double *)&v32[4];
          }

          if (v16 > 0.0)
          {
            uint64_t v22 = *(void *)&v32[4];
            *(void *)a3 = *(void *)&buf[8];
            *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = v22;
            uuid_copy((unsigned __int8 *)(a3 + 16), a2);
            uuid_copy((unsigned __int8 *)(a3 + 32), uu);
            *(double *)(a3 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v14 / v16;
            uint64_t v18 = 100LL;
            if (!v12) {
              goto LABEL_27;
            }
            goto LABEL_26;
          }
        }
      }

      else
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        __int128 v20 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::string buf = 136446210;
          *(void *)&uint8_t buf[4] = out;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Unable to get entries for uuid %{public}s",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_10188FEF8);
          }
          int v31 = 136446210;
          *(void *)__int128 v32 = out;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "Unable to get entries for uuid %{public}s",  &v31,  12,  v29[0]);
          __int128 v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::getWorkoutMets(unsigned char *, CLWorkoutMets &) const",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }
      }

      uint64_t v18 = 109LL;
      if (v12) {
LABEL_26:
      }
        (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      __int128 v19 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "DB, UUID un-initialized", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        LOWORD(v31) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, UUID un-initialized",  &v31,  2);
        unint64_t v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLNatalimetryRecorderDb::getWorkoutMets(unsigned char *, CLWorkoutMets &) const",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      uint64_t v18 = 103LL;
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    int v17 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "DB, not accessible", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      LOWORD(v31) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, not accessible",  &v31,  2);
      unint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLNatalimetryRecorderDb::getWorkoutMets(unsigned char *, CLWorkoutMets &) const",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }

    uint64_t v18 = 109LL;
  }

void sub_100F9089C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F90904(uint64_t a1)
{
  uint64_t v3 = v8;
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100F909A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F909C8(uint64_t a1)
{
  return sub_100F90904(a1 - 72);
}

void sub_100F909D0(uint64_t a1)
{
  if (sub_1003C1048(*(void *)(a1 + 80)))
  {
    sub_100F90BE4(a1);
    sub_1003B59A0( *(void *)(a1 + 80),  "NatalieHistory",  (const char **)&off_10188FF18,  (const std::string::value_type **)&off_101992B78,  0);
    *(void *)(a1 + 392) = sub_1003BF158( *(void *)(a1 + 80),  "INSERT INTO NatalieHistory (startTime, activityType, isStanding, mets, natalies, basalNata lies, overrideSet, truthMets, sessionUUID) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)");
    *(void *)(a1 + 400) = v2;
    *(void *)(a1 + 40_Block_object_dispose((const void *)(v1 - 128), 8) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM NatalieHistory ORDER BY startTime DESC LIMIT 1");
    *(void *)(a1 + 416) = v3;
    *(void *)(a1 + 424) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM NatalieHistory ORDER BY startTime ASC LIMIT 1");
    *(void *)(a1 + 432) = v4;
    *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    int v5 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "DB, Device is locked and we are unable to open the database",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, Device is locked and we are unable to open the database",  v8,  2);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLNatalimetryRecorderDb::prepareSQLStatements()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

void sub_100F90BE4(uint64_t a1)
{
  if (sub_1003B747C(*(void *)(a1 + 80), "NatalieHistory"))
  {
    uint64_t v2 = 0LL;
    int v3 = 0;
    do
    {
      uint64_t v7 = (&off_10188FF18)[v2 + 12];
      __int128 v37 = v7;
      int v38 = 5;
      __int16 v39 = 0;
      char v40 = 0;
      char v41 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "NatalieHistory", v7, (uint64_t)&v37) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)buf);
        uint64_t v8 = sub_10000CF44(&v43, (uint64_t)"ALTER TABLE NatalieHistory", 26LL);
        __int128 v9 = sub_10000CF44(v8, (uint64_t)" ADD COLUMN ", 12LL);
        size_t v10 = strlen(v7);
        uint64_t v11 = sub_10000CF44(v9, (uint64_t)v7, v10);
        uint64_t v12 = sub_10000CF44(v11, (uint64_t)" ", 1LL);
        __int128 v13 = (const char *)sub_1003BCC40((int)(&off_10188FF18)[v2 + 13]);
        size_t v14 = strlen(v13);
        double v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
        sub_10000CF44(v15, (uint64_t)";", 1LL);
        uint64_t v16 = *(void *)(a1 + 80);
        std::stringbuf::str(&v34, &v44);
        if ((v34.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v17 = &v34;
        }
        else {
          int v17 = (std::stringbuf::string_type *)v34.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v16, (char *)v17, &v32);
        uint64_t v18 = v32.__r_.__value_.__r.__words[0];
        v32.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v19 = *(void *)(a1 + 80);
        __int128 v20 = (sqlite3_stmt *)sub_100019240(v18);
        sub_1003BB2BC(v19, v20);
        sub_10000CE18((uint64_t)&v34);
        __int128 v21 = sub_10000CF44(&v34.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE NatalieHistory SET ", 26LL);
        size_t v22 = strlen(v7);
        uint64_t v23 = sub_10000CF44(v21, (uint64_t)v7, v22);
        sub_10000CF44(v23, (uint64_t)" = 0;", 5LL);
        uint64_t v24 = *(void *)(a1 + 80);
        std::stringbuf::str(&v32, &v35);
        if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          unint64_t v25 = &v32;
        }
        else {
          unint64_t v25 = (std::stringbuf::string_type *)v32.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v24, (char *)v25, &v33);
        uint64_t v26 = v33;
        uint64_t v33 = 0LL;
        uint64_t v27 = *(void *)(a1 + 80);
        __int128 v28 = (sqlite3_stmt *)sub_100019240(v26);
        sub_1003BB2BC(v27, v28);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
        }
        v34.__r_.__value_.__r.__words[0] = v4;
        *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + *(void *)(v4 - 24)) = v6;
        v34.__r_.__value_.__l.__cap_ = v5;
        std::streambuf::~streambuf(&v35);
        std::ios::~ios(&v36);
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }
        *(void *)std::string buf = v4;
        *(void *)&buf[*(void *)(v4 - 24)] = v6;
        std::string::size_type v43 = v5;
        std::streambuf::~streambuf(&v44);
        std::ios::~ios(&v45);
        int v3 = 1;
      }

      v2 += 6LL;
    }

    while (v2 != 48);
    if (((v3 | sub_100F91190( a1,  "NatalieHistory",  (const char **)&off_10188FF18,  (const std::string::value_type **)&off_101992B78)) & 1) != 0) {
      sub_1003BF200(*(void *)(a1 + 80), "NatalieHistory");
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    __int128 v29 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "DB, doesn't exist yet.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      LOWORD(v34.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "DB, doesn't exist yet.",  &v34,  2);
      int v31 = (uint8_t *)v30;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryRecorderDb::alterTableIfNecessary()", "%s\n", v30);
      if (v31 != buf) {
        free(v31);
      }
    }
  }

void sub_100F910F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a24);
  if (v66) {
    (*(void (**)(uint64_t))(*(void *)v66 + 8LL))(v66);
  }
  sub_1011F8850((uint64_t)&a66);
  _Unwind_Resume(a1);
}

uint64_t sub_100F91190(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890220);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      __int16 v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLNatalieData>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    __int128 v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    size_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      size_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      uint64_t v16 = v143;
    }
    else {
      uint64_t v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      __int128 v21 = &__p;
    }
    else {
      __int128 v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    size_t v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      __int128 v28 = v143;
    }
    else {
      __int128 v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    __int16 v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf::string_type v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::stringbuf::string_type v34 = &v139;
    }
    else {
      std::stringbuf::string_type v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    uint64_t v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    int v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v41 = &__p;
    }
    else {
      char v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    uint64_t v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    unsigned int v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      unsigned int v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v47 = &__p;
      }
      else {
        __int128 v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      __int128 v48 = v143;
    }
    else {
      __int128 v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    double v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v54 = buf;
    }
    else {
      double v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    double v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v60 = buf;
    }
    else {
      __int128 v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    uint64_t v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v69 = &__p;
    }
    else {
      __int128 v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    __int128 v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    __int128 v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v75 = &__p;
      }
      else {
        __int128 v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    __int128 v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      BOOL v79 = &__p;
    }
    else {
      BOOL v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    __int128 v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    unint64_t v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      unint64_t v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v85 = &__p;
      }
      else {
        __int128 v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      __int128 v86 = v143;
    }
    else {
      __int128 v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    uint64_t v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    double v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    unint64_t v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v95 = &__p;
    }
    else {
      __int128 v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    __int128 v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      unint64_t v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        unint64_t v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v103 = &__p;
        }
        else {
          __int128 v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        __int128 v104 = v141;
      }
      else {
        __int128 v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      __int128 v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v114 = buf;
      }
      else {
        __int128 v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      __int128 v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v121 = &__p;
      }
      else {
        __int128 v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      __int128 v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      __int128 v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        uint64_t v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLNatalieData>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInf o *, const char **) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      uint64_t v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        __int128 v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<CLNatalieData>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInf o *, const char **) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_100F92328( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F92648(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM NatalieHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    std::string::size_type v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    *(_DWORD *)(a1 + 132) = 0;
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100F926E0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F92700(uint64_t a1)
{
  return sub_100F92648(a1 - 72);
}

uint64_t sub_100F92708(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM NatalieHistory WHERE startTime > ?", buf);
    uint64_t v5 = *(void *)buf;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 16)))
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      __int128 v9 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "DB, Failed to delete records", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        v14[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, Failed to delete records",  v14,  2);
        __int128 v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNatalimetryRecorderDb::deleteRecordsAfterInsertUL(const CLNatalieData &)",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
      }
    }

    uint64_t v10 = *(void *)(a1 + 80);
    else {
      uint64_t v11 = *(void *)(v10 + 88);
    }
    uint64_t result = sub_1003C1EC0(v10, v11);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100F9294C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F92978(uint64_t a1, double a2)
{
  if (sub_100D8A92C(a1 + 72))
  {
    sub_1003C0D54(*(void *)(a1 + 80), "UPDATE NatalieHistory SET startTime = startTime + ?", buf);
    uint64_t v4 = *(void *)buf;
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003B7480(v5, 1, a2))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v4);
      sub_1003BB2BC(v6, v7);
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      uint64_t v8 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "DB, Failed to shift records", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10188FEF8);
        }
        v11[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "DB, Failed to shift records",  v11,  2);
        uint64_t v10 = (uint8_t *)v9;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNatalimetryRecorderDb::shiftRecordsByUL(CFTimeInterval)",  "%s\n",  v9);
        if (v10 != buf) {
          free(v10);
        }
      }
    }

    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

void sub_100F92B80(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F92BAC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    int v5 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 104LL))(a1, out);
    if (v5) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = v59;
    }
    if (v5) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = v58;
    }
    double v8 = *(double *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 24);
    char v10 = *(_BYTE *)(a2 + 28);
    char v11 = *(_BYTE *)(a2 + 29);
    int v34 = *(_DWORD *)(a2 + 4);
    __int16 v35 = *(_WORD *)(a2 + 30);
    double v12 = *(double *)(a2 + 32);
    double v13 = *(double *)(a2 + 40);
    __int128 v55 = *(_OWORD *)(a2 + 64);
    uint64_t v56 = *(void *)(a2 + 80);
    uint64_t v15 = *(void *)(a2 + 48);
    uint64_t v14 = *(void *)(a2 + 56);
    memset(out, 0, 37);
    sub_100B14CF8((uint64_t *)(a1 + 392), &v36);
    uint64_t v16 = (sqlite3_stmt *)sub_100019240(v36);
    if (sub_1003B7480(v16, 1, v8))
    {
      std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v36);
      if (sub_1003C28BC(v17, 2, v9))
      {
        uint64_t v18 = (sqlite3_stmt *)sub_100019240(v36);
        if (sub_1003C28BC(v18, 3, v11 & 1))
        {
          std::string::size_type v19 = (sqlite3_stmt *)sub_100019240(v36);
          if (sub_1003B7480(v19, 4, v12))
          {
            signed __int8 v20 = (sqlite3_stmt *)sub_100019240(v36);
            if (sub_1003C2D24(v20, 5, v15 + v7))
            {
              __int128 v21 = (sqlite3_stmt *)sub_100019240(v36);
              sqlite3_int64 v22 = v14 + v6;
              if (sub_1003C2D24(v21, 6, v22))
              {
                int v23 = (sqlite3_stmt *)sub_100019240(v36);
                if (sub_1003C28BC(v23, 7, v10 & 1))
                {
                  std::string::size_type v24 = (sqlite3_stmt *)sub_100019240(v36);
                  if (sub_1003B7480(v24, 8, v13))
                  {
                    size_t v25 = (sqlite3_stmt *)sub_100019240(v36);
                    if (sub_1003BC1F0(v25, 9, out))
                    {
                      uint64_t v26 = *(void *)(a1 + 80);
                      uint64_t v27 = (sqlite3_stmt *)sub_100019240(v36);
                      sub_1003BB2BC(v26, v27);
                      ++*(_DWORD *)(a1 + 132);
                      if (*(void *)(a1 + 440))
                      {
                        if (*(void *)(a1 + 448))
                        {
                          int v28 = sub_1003C1068(*(void *)(a1 + 80));
                          uint64_t v29 = sub_1003B76B4(*(void *)(a1 + 80));
                          uint64_t v30 = *(void *)(a2 + 56);
                          uint64_t v31 = *(void *)(a2 + 48) - v30;
                          __int16 v32 = *(_WORD *)(a1 + 456);
                          __int128 v33 = *(void **)(a1 + 440);
                          v37[0] = _NSConcreteStackBlock;
                          v37[1] = 3221225472LL;
                          v37[2] = sub_100F92EC8;
                          v37[3] = &unk_10188FE88;
                          id v37[4] = a1;
                          int v38 = v28;
                          int v39 = v34;
                          uint64_t v40 = v29;
                          double v41 = v8;
                          int v42 = v9;
                          char v43 = v10;
                          char v44 = v11;
                          __int16 v45 = v35;
                          double v46 = v12;
                          double v47 = v13;
                          uint64_t v48 = v15 + v7;
                          sqlite3_int64 v49 = v22;
                          __int128 v50 = v55;
                          uint64_t v51 = v56;
                          uint64_t v52 = v31;
                          uint64_t v53 = v30;
                          __int16 v54 = v32;
                          [v33 async:v37];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    uint64_t result = v36;
    uint64_t v36 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100F92E98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8LL))(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F92EC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 448LL);
  __int128 v2 = *(_OWORD *)(a1 + 88);
  _OWORD v6[2] = *(_OWORD *)(a1 + 72);
  void v6[3] = v2;
  void v6[4] = *(_OWORD *)(a1 + 104);
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v7 = *(void *)(a1 + 120);
  __int128 v4 = *(_OWORD *)(a1 + 56);
  v6[0] = *(_OWORD *)(a1 + 40);
  v6[1] = v4;
  return (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, void, void, void))(v1 + 16))( v1,  v6,  v3,  *(void *)(a1 + 136),  *(unsigned __int8 *)(a1 + 144),  *(unsigned __int8 *)(a1 + 145));
}

uint64_t sub_100F92F58()
{
  return 0LL;
}

uint64_t sub_100F92F60(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v12;
  if (v12)
  {
    uint64_t v5 = sub_100F8EB38(&v12, (uint64_t)buf);
    if (!(_DWORD)v5) {
      sub_100F8ECA4((uint64_t)buf, a2);
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10188FEF8);
    }
    uint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "CalorimetryRecorderDb: failed to prepare getMostRecent #InvalidPreparedSQLStatement",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10188FEF8);
      }
      __int16 v11 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "CalorimetryRecorderDb: failed to prepare getMostRecent #InvalidPreparedSQLStatement",  &v11,  2);
      char v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CLActivityDB::ActivityCode CLNatalimetryRecorderDb::getMostRecentRecordUL(CLNatalieData &) const",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint64_t v5 = 2LL;
  }

  uint64_t v7 = v12;
  uint64_t v12 = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  if (!v4) {
    return 2LL;
  }
  return v5;
}

void sub_100F93160( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F93194(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v4 = *(double *)(a4 + 16) - *(double *)(a4 + 64);
  else {
    double v5 = *(double *)(a2 + 16);
  }
  for (double i = v4 - v5; i > 10.24; double i = i + -3600.0)
  {
    if (i <= 3600.0) {
      double v8 = i;
    }
    else {
      double v8 = 3600.0;
    }
    sub_100F8E5E4(a1, v5, v5 + v8);
    double v5 = v5 + 3600.0;
  }

uint64_t sub_100F93244(void *a1, void **a2, double a3, double a4)
{
  double v8 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v48);
  if ((SHIBYTE(v49) & 0x80000000) == 0)
  {
    if (HIBYTE(v49)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_10127B464(v8);
    __break(1u);
  }

  char v43 = v48[1];
  operator delete(v48[0]);
  if (!v43) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v48);
  int v9 = sub_10000CF44(&v49, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(v52, a1);
  if (v52[23] >= 0) {
    char v10 = v52;
  }
  else {
    char v10 = *(_BYTE **)v52;
  }
  if (v52[23] >= 0) {
    uint64_t v11 = v52[23];
  }
  else {
    uint64_t v11 = *(void *)&v52[8];
  }
  uint64_t v12 = sub_10000CF44(v9, (uint64_t)v10, v11);
  sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((v52[23] & 0x80000000) != 0) {
    operator delete(*(void **)v52);
  }
  uint64_t v13 = a1[10];
  std::stringbuf::str((std::stringbuf::string_type *)v52, &v50);
  if (v52[23] >= 0) {
    uint64_t v14 = v52;
  }
  else {
    uint64_t v14 = *(char **)v52;
  }
  sub_1003C0D54(v13, v14, &v46);
  uint64_t v15 = v46;
  uint64_t v46 = 0LL;
  uint64_t v47 = v15;
  if ((v52[23] & 0x80000000) != 0) {
    operator delete(*(void **)v52);
  }
  uint64_t v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (sub_1003B7480(v16, 1, a3) && (std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v15), sub_1003B7480(v17, 2, a4)))
  {
    while (1)
    {
      uint64_t v18 = sub_1001BA11C((uint64_t)a1, &v47, (uint64_t)v52);
      if ((_DWORD)v18) {
        break;
      }
      std::string::size_type v19 = (char *)a2[1];
      signed __int8 v20 = (char *)a2[2];
      if (v19 >= v20)
      {
        uint64_t v26 = 0x2E8BA2E8BA2E8BA3LL * ((v19 - (_BYTE *)*a2) >> 3);
        unint64_t v27 = v26 + 1;
        unint64_t v28 = 0x2E8BA2E8BA2E8BA3LL * ((v20 - (_BYTE *)*a2) >> 3);
        if (2 * v28 > v27) {
          unint64_t v27 = 2 * v28;
        }
        if (v28 >= 0x1745D1745D1745DLL) {
          unint64_t v29 = 0x2E8BA2E8BA2E8BALL;
        }
        else {
          unint64_t v29 = v27;
        }
        if (v29) {
          uint64_t v30 = (char *)sub_100023598((uint64_t)(a2 + 2), v29);
        }
        else {
          uint64_t v30 = 0LL;
        }
        uint64_t v31 = &v30[88 * v26];
        __int128 v32 = *(_OWORD *)&v52[16];
        *(_OWORD *)uint64_t v31 = *(_OWORD *)v52;
        *((_OWORD *)v31 + 1) = v32;
        __int128 v33 = v53;
        __int128 v34 = v54;
        __int128 v35 = v55;
        *((void *)v31 + 10) = v56;
        *((_OWORD *)v31 + 3) = v34;
        *((_OWORD *)v31 + 4) = v35;
        *((_OWORD *)v31 + 2) = v33;
        __int128 v37 = (char *)*a2;
        uint64_t v36 = (char *)a2[1];
        int v38 = v31;
        if (v36 != *a2)
        {
          do
          {
            __int128 v39 = *(_OWORD *)(v36 - 88);
            *(_OWORD *)(v38 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v36 - 72);
            *(_OWORD *)(v38 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v39;
            __int128 v40 = *(_OWORD *)(v36 - 56);
            __int128 v41 = *(_OWORD *)(v36 - 40);
            __int128 v42 = *(_OWORD *)(v36 - 24);
            *((void *)v38 - 1) = *((void *)v36 - 1);
            *(_OWORD *)(v38 - 24) = v42;
            *(_OWORD *)(v38 - 40) = v41;
            *(_OWORD *)(v38 - 56) = v40;
            v38 -= 88;
            v36 -= 88;
          }

          while (v36 != v37);
          uint64_t v36 = (char *)*a2;
        }

        size_t v25 = v31 + 88;
        *a2 = v38;
        a2[1] = v31 + 88;
        a2[2] = &v30[88 * v29];
        if (v36) {
          operator delete(v36);
        }
      }

      else
      {
        __int128 v21 = *(_OWORD *)&v52[16];
        *(_OWORD *)std::string::size_type v19 = *(_OWORD *)v52;
        *((_OWORD *)v19 + 1) = v21;
        __int128 v22 = v53;
        __int128 v23 = v54;
        __int128 v24 = v55;
        *((void *)v19 + 10) = v56;
        *((_OWORD *)v19 + 3) = v23;
        *((_OWORD *)v19 + 4) = v24;
        *((_OWORD *)v19 + 2) = v22;
        size_t v25 = v19 + 88;
      }

      a2[1] = v25;
    }

    uint64_t v15 = v47;
  }

  else
  {
    uint64_t v18 = 2LL;
  }

  uint64_t v47 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  *(void **)((char *)v48
  uint64_t v49 = v44;
  std::streambuf::~streambuf(&v50);
  std::ios::~ios(&v51);
  return v18;
}

void sub_100F93610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100F93680(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890220);
    }
    double v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::string buf = 134349056;
        *(void *)uint64_t v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLNatalieData>::setDatabaseAccessible() [T = CLNatalieData, DataProtectionPo licy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890220);
    }
    char v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x2E));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 88 * (v13 % 0x2E);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x2E)) + 88 * (v22 % 0x2E);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101890240);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101890240);
        }
        LOWORD(v41) = 0;
        LODWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        unint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLNatalieData>::setDatabaseAccessible() [T = CLNatalieData, DataProtectionPo licy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 88LL;
      if (v17 - *v16 == 4048)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890220);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      std::string::size_type v19 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
    }

    signed __int8 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v21 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 1;
  }

  unint64_t v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      unint64_t v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 23LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 46LL;
  }

  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v32;
LABEL_61:
  __int128 v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100F93DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_100F93DF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)(a3 + 32);
  __int128 v5 = *(_OWORD *)(a3 + 48);
  __int128 v6 = *(_OWORD *)(a3 + 64);
  *(void *)(a2 + sub_100F6A7D8(v1 + 80) = *(void *)(a3 + 80);
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v5;
  *(_OWORD *)(a2 + 64) = v6;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

id *sub_100F93E14(uint64_t a1, uint64_t a2, char a3)
{
  v35[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v35[1] = 0LL;
  if (*(double *)(a1 + 240) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v35);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)a1 + 104LL))(a1, v44);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        LOWORD(v36) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v36,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLNatalieData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLNatalieData , DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 16);
    double v8 = v45;
    double v9 = v7 - v45;
    if (v7 - v45 < 0.0) {
      double v9 = -(v7 - v45);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890220);
      }
      char v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 16);
        *(_DWORD *)std::string buf = 134349312;
        double v41 = v45;
        __int16 v42 = 2050;
        uint64_t v43 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        uint64_t v26 = *(void *)(a2 + 16);
        int v36 = 134349312;
        double v37 = v45;
        __int16 v38 = 2050;
        uint64_t v39 = v26;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v36,  22);
        unint64_t v28 = (uint8_t *)v27;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLNatalieData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLNatalieData , DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v27);
        if (v28 != buf) {
          free(v28);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 16);
      double v8 = v45;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 16);
          *(_DWORD *)std::string buf = 134217984;
          double v41 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101890220);
          }
          double v29 = *(double *)(a2 + 16);
          int v36 = 134217984;
          double v37 = v29;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v36));
          uint64_t v31 = (uint8_t *)v30;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLNatalieData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLNatalieDa ta, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v30);
          if (v31 != buf) {
            free(v31);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v34 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101890220);
        double v18 = v34;
      }

      double v19 = v17 - v18;
      signed __int8 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v41 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890220);
        }
        int v36 = 134217984;
        double v37 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v36));
        __int128 v33 = (uint8_t *)v32;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLNatalieData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLNatalieData , DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v32);
        if (v33 != buf) {
          free(v33);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, v44, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100F94568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100F94594(uint64_t a1)
{
  return sub_100F93680(a1 - 72);
}

void sub_100F9459C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100F945C8(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v42);
  if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    if (HIBYTE(v43)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10127B5D0(v4);
    __break(1u);
  }

  uint64_t v39 = v42[1];
  operator delete(v42[0]);
  if (!v39) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v42);
    int v6 = sub_10000CF44(&v43, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 64))(v46, a1);
    if (v46[23] >= 0) {
      double v7 = v46;
    }
    else {
      double v7 = *(_BYTE **)v46;
    }
    if (v46[23] >= 0) {
      uint64_t v8 = v46[23];
    }
    else {
      uint64_t v8 = *(void *)&v46[8];
    }
    double v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if ((v46[23] & 0x80000000) != 0) {
      operator delete(*(void **)v46);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)v46, &v44);
    if (v46[23] >= 0) {
      uint64_t v11 = v46;
    }
    else {
      uint64_t v11 = *(char **)v46;
    }
    sub_1003C0D54(v10, v11, &v40);
    uint64_t v12 = v40;
    uint64_t v40 = 0LL;
    uint64_t v41 = v12;
    if ((v46[23] & 0x80000000) != 0) {
      operator delete(*(void **)v46);
    }
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v41, (uint64_t)v46))
    {
      unint64_t v13 = (unint64_t)a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if (v13 >= v14)
      {
        uint64_t v20 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v13 - (void)*a2) >> 3);
        unint64_t v21 = v20 + 1;
        unint64_t v22 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v14 - (void)*a2) >> 3);
        if (2 * v22 > v21) {
          unint64_t v21 = 2 * v22;
        }
        if (v22 >= 0x1745D1745D1745DLL) {
          unint64_t v23 = 0x2E8BA2E8BA2E8BALL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23) {
          __int128 v24 = (char *)sub_100023598((uint64_t)(a2 + 2), v23);
        }
        else {
          __int128 v24 = 0LL;
        }
        unint64_t v25 = &v24[88 * v20];
        __int128 v26 = *(_OWORD *)&v46[16];
        *(_OWORD *)unint64_t v25 = *(_OWORD *)v46;
        *((_OWORD *)v25 + 1) = v26;
        __int128 v27 = v47;
        __int128 v28 = v48;
        __int128 v29 = v49;
        *((void *)v25 + 10) = v50;
        *((_OWORD *)v25 + 3) = v28;
        *((_OWORD *)v25 + 4) = v29;
        *((_OWORD *)v25 + 2) = v27;
        uint64_t v31 = *a2;
        unint64_t v30 = a2[1];
        uint64_t v32 = v25;
        if (v30 != *a2)
        {
          do
          {
            __int128 v33 = *(_OWORD *)(v30 - 88);
            *(_OWORD *)(v32 - sub_1011C52D0(v23 - 72) = *(_OWORD *)(v30 - 72);
            *(_OWORD *)(v32 - 8_Block_object_dispose((const void *)(v1 - 128), 8) = v33;
            __int128 v34 = *(_OWORD *)(v30 - 56);
            __int128 v35 = *(_OWORD *)(v30 - 40);
            __int128 v36 = *(_OWORD *)(v30 - 24);
            *((void *)v32 - 1) = *((void *)v30 - 1);
            *(_OWORD *)(v32 - 24) = v36;
            *(_OWORD *)(v32 - 40) = v35;
            *(_OWORD *)(v32 - 56) = v34;
            v32 -= 88;
            v30 -= 88;
          }

          while (v30 != v31);
          unint64_t v30 = *a2;
        }

        double v19 = v25 + 88;
        *a2 = v32;
        a2[1] = v25 + 88;
        a2[2] = &v24[88 * v23];
        if (v30) {
          operator delete(v30);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)&v46[16];
        *(_OWORD *)unint64_t v13 = *(_OWORD *)v46;
        *(_OWORD *)(v13 + 16) = v15;
        __int128 v16 = v47;
        __int128 v17 = v48;
        __int128 v18 = v49;
        *(void *)(v13 + sub_100F6A7D8(v1 + 80) = v50;
        *(_OWORD *)(v13 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v17;
        *(_OWORD *)(v13 + 64) = v18;
        *(_OWORD *)(v13 + 32) = v16;
        double v19 = (char *)(v13 + 88);
      }

      a2[1] = v19;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v37 = v41;
    uint64_t v41 = 0LL;
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8LL))(v37);
    }
    *(void **)((char *)v42
    uint64_t v43 = v38;
    std::streambuf::~streambuf(&v44);
    return std::ios::~ios(&v45);
  }

  return result;
}

void sub_100F9494C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_1011F8850((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F949BC(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    uint64_t v20 = (_Unwind_Exception *)sub_10127B73C(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  double v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 16)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100F94C1C(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10127B8A8(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100F94E54(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10127BA14(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  __int128 v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_100F9507C(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100F950A8(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 23LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 46LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    double v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_100F9513C(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_100F95168(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  double v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *double v7 = off_101890270;
  v7[6] = 0LL;
  sub_100E18F18((uint64_t)sub_100F95224, a1, a3, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = v12;
    uint64_t v12 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a1;
}

void sub_100F951F8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_100F95224(uint64_t a1, _DWORD *a2, double *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018902C0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLExerciseMinuteSubscription::onNatalimetryUpdate",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018902C0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int128 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLExerciseMinuteSubscription::onNatalimetryUpdate, event:%{public, location:escape_ only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100F961D4(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F953DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F95400(void *a1)
{
  *a1 = off_101890270;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    uint64_t v3 = a1[6];
    a1[6] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return sub_100C6AB50((uint64_t)a1);
}

void sub_100F95460(void *a1)
{
  uint64_t v1 = (void *)sub_100F95400(a1);
  operator delete(v1);
}

void *sub_100F95474@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_101890330;
  v11[1] = sub_100F956E8;
  uint64_t v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageExerciseMinuteUpdate");
  sub_1008976EC((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_1018903E0;
  v9[1] = sub_100F959BC;
  _DWORD v9[2] = 0LL;
  uint64_t v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageExerciseMinuteQuery");
  sub_1008976EC((uint64_t)v16, (uint64_t)v9);
  sub_100F96F08(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      uint64_t v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  unint64_t v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    unint64_t v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_100F95618( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  uint64_t v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    uint64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  uint64_t v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    uint64_t v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_100F956E8(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101890300);
  }
  unint64_t v5 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)std::string buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
    __int16 v24 = 1024;
    int v25 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "ExerciseMinute, Subscription changed, %@, %p, %d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101890300);
    }
    uint64_t v10 = *(void *)(a1 + 24);
    unsigned int v15 = 138412802;
    uint64_t v16 = v10;
    __int16 v17 = 2048;
    uint64_t v18 = a1;
    __int16 v19 = 1024;
    int v20 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "ExerciseMinute, Subscription changed, %@, %p, %d",  &v15,  28);
    uint64_t v12 = (char *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLExerciseMinuteSubscription::handleRequestExerciseMinuteUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  if ((sub_100F9665C(a1, (int *)&v15) & 1) != 0)
  {
    sub_100C6AC8C(a1);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(v7 + 8);
    uint64_t v8 = *(void **)(v7 + 16);
    if (a2) {
      [v8 register:v9 forNotification:4 registrationInfo:0];
    }
    else {
      [v8 unregister:v9 forNotification:4];
    }
  }

  else
  {
    uint64_t v13 = CMErrorMessage;
    uint64_t v14 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v15);
    *(void *)std::string buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v14,  &v13,  1LL);
    sub_100F966B8(a1, buf);
  }
}

void sub_100F95980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100F959BC(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  char v5 = sub_100F9665C(a1, (int *)&v45);
  uint64_t v6 = *a2;
  if ((v5 & 1) != 0)
  {
    Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
    uint64_t v8 = Dictionary;
    if (Dictionary
      && (uint64_t v9 = CMExerciseMinuteRecordId, [Dictionary objectForKeyedSubscript:CMExerciseMinuteRecordId]))
    {
      sub_100222B94(v44, (uint64_t)"CLDaemonClient.ExerciseMinuteQuery", 0);
      std::stringbuf::string_type __p = 0LL;
      __int16 v42 = 0LL;
      uint64_t v43 = 0LL;
      unsigned int v38 = objc_msgSend(objc_msgSend(v8, "objectForKeyedSubscript:", v9), "intValue");
      uint64_t v10 = CMExerciseMinuteStartDate;
      if ([v8 objectForKeyedSubscript:CMExerciseMinuteStartDate]) {
        objc_msgSend(objc_msgSend(v8, "objectForKeyedSubscript:", v10), "doubleValue");
      }
      else {
        uint64_t v11 = 0LL;
      }
      uint64_t v39 = v11;
      uint64_t v14 = CMExerciseMinuteSourceId;
      id v15 = [v8 objectForKeyedSubscript:CMExerciseMinuteSourceId];
      if (v15) {
        id v15 = [v8 objectForKeyedSubscript:v14];
      }
      id v40 = v15;
      id v16 = objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLNatalimetryNotifier"),  "syncgetQueryExerciseMinuteDataSince:records:",  &v38,  &__p);
      unsigned int v45 = v16;
      if ((_DWORD)v16 == 100)
      {
        __int16 v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v18 = (int *)__p;
        __int16 v19 = v42;
        if (__p != v42)
        {
          do
          {
            if (*((void *)v18 + 2)) {
              int v20 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  *((void *)v18 + 2));
            }
            else {
              int v20 = 0LL;
            }
            id v21 = [[CMExerciseMinuteData alloc] initWithStartDate:*v18 recordId:v20 sourceId:*((double *)v18 + 1)];
            -[NSMutableArray addObject:](v17, "addObject:", v21);

            v18 += 6;
          }

          while (v18 != v19);
        }

        if (-[NSMutableArray count](v17, "count"))
        {
          sub_1004F2598();
          if (sub_1004F8A40())
          {
            if (qword_1019344B0 != -1) {
              dispatch_once(&qword_1019344B0, &stru_101890300);
            }
            __int16 v22 = (os_log_s *)qword_1019344B8;
            if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
            {
              id v23 = -[NSMutableArray lastObject](v17, "lastObject");
              uint64_t v24 = *(void *)(a1 + 24);
              *(_DWORD *)std::string buf = 138412802;
              *(void *)__int128 v55 = v23;
              *(_WORD *)&v55[8] = 2112;
              *(void *)&v55[10] = v24;
              *(_WORD *)&v55[18] = 2048;
              *(void *)&v55[20] = a1;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "%@, %@, %p", buf, 0x20u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019344B0 != -1) {
                dispatch_once(&qword_1019344B0, &stru_101890300);
              }
              uint64_t v33 = qword_1019344B8;
              id v34 = -[NSMutableArray lastObject](v17, "lastObject");
              uint64_t v35 = *(void *)(a1 + 24);
              int v48 = 138412802;
              *(void *)__int128 v49 = v34;
              *(_WORD *)&v49[8] = 2112;
              *(void *)&v49[10] = v35;
              *(_WORD *)&v49[18] = 2048;
              *(void *)&v49[20] = a1;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  1LL,  "%@, %@, %p",  &v48,  32);
              uint64_t v37 = (uint8_t *)v36;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLExerciseMinuteSubscription::handleMessageExerciseMinuteQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v36);
              if (v37 != buf) {
                free(v37);
              }
            }
          }
        }

        uint64_t v46 = CMExerciseMinuteDataArray;
        __int128 v47 = v17;
        +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);

        CLConnectionMessage::sendReply(*a2);
      }

      else
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890300);
        }
        int v25 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v26 = *(void *)(a1 + 24);
          *(_DWORD *)std::string buf = 67240706;
          *(_DWORD *)__int128 v55 = (_DWORD)v16;
          *(_WORD *)&v55[4] = 2112;
          *(void *)&v55[6] = v26;
          *(_WORD *)&v55[14] = 2048;
          *(void *)&v55[16] = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "ExerciseMinute, Error query response, %{public}d, %@, %p",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101890300);
          }
          uint64_t v30 = *(void *)(a1 + 24);
          int v48 = 67240706;
          *(_DWORD *)__int128 v49 = (_DWORD)v16;
          *(_WORD *)&v49[4] = 2112;
          *(void *)&v49[6] = v30;
          *(_WORD *)&v49[14] = 2048;
          *(void *)&v49[16] = a1;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "ExerciseMinute, Error query response, %{public}d, %@, %p",  &v48,  28);
          uint64_t v32 = (uint8_t *)v31;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLExerciseMinuteSubscription::handleMessageExerciseMinuteQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v31);
          if (v32 != buf) {
            free(v32);
          }
        }

        __int128 v27 = *a2;
        uint64_t v50 = CMErrorMessage;
        uint64_t v51 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v16);
        +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v51,  &v50,  1LL);
        CLConnectionMessage::sendReply(v27);
      }

      if (__p)
      {
        __int16 v42 = (int *)__p;
        operator delete(__p);
      }

      sub_1001BA1BC(v44);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101890300);
      }
      uint64_t v12 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "ExerciseMinute, Error in query request.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101890300);
        }
        LOWORD(v4_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "ExerciseMinute, Error in query request.",  &v48,  2);
        __int128 v29 = (uint8_t *)v28;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLExerciseMinuteSubscription::handleMessageExerciseMinuteQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }

      uint64_t v13 = *a2;
      uint64_t v52 = CMErrorMessage;
      __int128 v53 = &off_1018D5090;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v53,  &v52,  1LL);
      CLConnectionMessage::sendReply(v13);
    }
  }

  else
  {
    uint64_t v56 = CMErrorMessage;
    __int128 v57 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v45);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v57,  &v56,  1LL);
    CLConnectionMessage::sendReply(v6);
  }
}

void sub_100F96164( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, id a18)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1001BA1BC(&a18);

  _Unwind_Resume(a1);
}

void sub_100F961D4(uint64_t a1, uint64_t a2, _DWORD *a3, double *a4)
{
  if (*a3 == 4)
  {
    if (*((void *)a4 + 2)
      && (uint64_t v6 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  *((void *)a4 + 2))) != 0LL)
    {
      uint64_t v7 = v6;
      id v8 = [[CMExerciseMinuteData alloc] initWithStartDate:*(int *)a4 recordId:v6 sourceId:a4[1]];
      sub_1004F2598();
      if (sub_1004F8A40())
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_1018902E0);
        }
        uint64_t v9 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)(a1 + 24);
          *(_DWORD *)std::string buf = 138412802;
          *(void *)&uint8_t buf[4] = v8;
          __int16 v27 = 2112;
          uint64_t v28 = v10;
          __int16 v29 = 2048;
          uint64_t v30 = a1;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@, %@, %p", buf, 0x20u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_1018902E0);
          }
          uint64_t v15 = *(void *)(a1 + 24);
          int v20 = 138412802;
          id v21 = v8;
          __int16 v22 = 2112;
          uint64_t v23 = v15;
          __int16 v24 = 2048;
          uint64_t v25 = a1;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "%@, %@, %p",  &v20,  32);
          __int16 v17 = (char *)v16;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLExerciseMinuteSubscription::onNatalimetryUpdate(int, const CLNatalimetryNotifier_Type::Notification & , const CLNatalimetryNotifier_Type::NotificationData &)",  "%s\n",  v16);
          if (v17 != buf) {
            free(v17);
          }
        }
      }

      uint64_t v11 = -[NSMutableArray initWithObjects:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithObjects:", v8, 0LL);
      uint64_t v18 = CMExerciseMinuteDataArray;
      __int16 v19 = v11;
      *(void *)std::string buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v19,  &v18,  1LL);

      sub_100F965B4(a1, buf);
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_1018902E0);
      }
      uint64_t v12 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "ExerciseMinute, error in update", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_1018902E0);
        }
        LOWORD(v20) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "ExerciseMinute, error in update",  &v20,  2);
        uint64_t v14 = (char *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLExerciseMinuteSubscription::onNatalimetryUpdate(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

void sub_100F965B4(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100F96648(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F9665C(uint64_t a1, int *a2)
{
  if (sub_100F96758(a1))
  {
    if (!sub_100E0DFC0(*(void *)(a1 + 8)))
    {
      int v5 = 104;
      goto LABEL_7;
    }

    if ((sub_100C6ADE0(a1) & 1) != 0) {
      return 1LL;
    }
  }

  int v5 = 105;
LABEL_7:
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

void sub_100F966B8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_101890450, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100F96744(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100F96758(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  uint64_t v3 = v2;
  if (v17 < 0)
  {
    operator delete(*(void **)__p);
    if ((v3 & 1) != 0) {
      return v3;
    }
  }

  else if ((v2 & 1) != 0)
  {
    return v3;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_1018902E0);
  }
  uint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 24);
    *(_DWORD *)std::stringbuf::string_type __p = 138412546;
    *(void *)&__p[4] = v5;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning Client failed entitlement check for calorimetry, %@, %p",  __p,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_1018902E0);
    }
    uint64_t v7 = *(void *)(a1 + 24);
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Client failed entitlement check for calorimetry, %@, %p",  &v10,  22);
    uint64_t v9 = (char *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLExerciseMinuteSubscription::isEntitledForNatalimetry()", "%s\n", v8);
    if (v9 != __p) {
      free(v9);
    }
  }

  return v3;
}

void sub_100F96960( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F96984(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100F969B0(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_100F969DC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

__n128 sub_100F96A08(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101890330;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

__n128 sub_100F96A44(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101890330;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

void sub_100F96A68(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_100F96A70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F96AAC()
{
}

void sub_100F96AB8(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_100F96B3C(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100F96B24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F96B3C(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    id v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    int v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      id v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_1018903A0);
    }
    uint64_t v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_1018903A0);
      }
    }

    __int16 v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_100F96D20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100F96D3C(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_100F96D68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_1018903E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

__n128 sub_100F96DA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1018903E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

void sub_100F96DC8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100F96DD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F96E0C()
{
}

void sub_100F96E18(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  __int16 v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  int v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    uint64_t v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100F96EEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100F96F08(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100F96F80(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100F96F6C(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100F96F80(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100F97200(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  __int16 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *__int16 v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100F971E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100F97200@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100F97274(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100F9725C(_Unwind_Exception *a1)
{
}

void *sub_100F97274(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100F972CC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F972E8()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199F8A8, (void *)&_mh_execute_header);
}

uint64_t sub_100F9732C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 24) = 0u;
  uint64_t v5 = a1 + 884;
  *(_WORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 255;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_DWORD *)(a1 + 64) = 0xFFFF;
  *(_OWORD *)(a1 + 6_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 84) = xmmword_1012E0070;
  __asm { FMOV            V1.2D, #-1.0 }

  __int128 v52 = _Q1;
  *(_OWORD *)(a1 + 100) = _Q1;
  *(_OWORD *)(a1 + 116) = _Q1;
  *(_OWORD *)(a1 + 132) = _Q1;
  *(_DWORD *)(a1 + 14_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(void *)(a1 + 152) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 1sub_100F6A7D8(v1 + 80) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 18_Block_object_dispose((const void *)(v1 - 128), 8) = 0x7FFFFFFF;
  *(_BYTE *)(a1 + 216) = 0;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(_OWORD *)(a1 + 192) = 0u;
  sub_100869DC8(a1 + 224);
  *(_DWORD *)(a1 + 864) = 0xFFFF;
  *(_OWORD *)(a1 + 86_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)uint64_t v5 = xmmword_1012E0070;
  *(_OWORD *)(v5 + 16) = v52;
  *(_OWORD *)(v5 + 32) = v52;
  *(_OWORD *)(v5 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v52;
  *(_DWORD *)(a1 + 94_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(void *)(a1 + 952) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_DWORD *)(a1 + 976) = 0;
  *(void *)(v5 + 96) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 98_Block_object_dispose((const void *)(v1 - 128), 8) = 0x7FFFFFFF;
  *(void *)(a1 + 992) = 0LL;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_BYTE *)(a1 + 1016) = 0;
  sub_100869DC8(a1 + 1024);
  *(_OWORD *)(a1 + 16sub_100F6A7D8(v1 + 80) = 0u;
  *(_OWORD *)(a1 + 1664) = 0u;
  *(_DWORD *)(a1 + 1696) = 1065353216;
  *(_OWORD *)(a1 + 1704) = 0u;
  *(_OWORD *)(a1 + 1720) = 0u;
  *(_OWORD *)(a1 + 1736) = 0u;
  *(void *)(a1 + 1752) = 0LL;
  *(_DWORD *)(a1 + 1760) = 1065353216;
  *(_OWORD *)(a1 + 176_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  sub_10001A504(a1 + 1784, a3);
  uint8x8_t v11 = (uint64_t *)(a1 + 1816);
  *(_OWORD *)(a1 + 1816) = 0u;
  sub_100F97D24(a1);
  id v12 = objc_msgSend( objc_msgSend(*(id *)a1, "vendor", a1 + 1768),  "proxyForService:forClient:",  @"CLClientManager",  @"CLEmergencyController");
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v12;
  id v13 = v12;
  *(void *)__int128 v65 = 11LL;
  *(void *)&__int128 v14 = -1LL;
  *((void *)&v14 + 1) = -1LL;
  *(_OWORD *)&v65[8] = v14;
  *(_OWORD *)&v65[24] = v14;
  uint64_t v74 = 0xFFFFFFFFLL;
  LODWORD(v75) = 0;
  __int128 v76 = *(_OWORD *)v65;
  __int128 v77 = *(_OWORD *)&v65[16];
  uint64_t v78 = -1LL;
  BOOL v79 = 0LL;
  uint64_t v80 = 0LL;
  uint64_t v81 = 0LL;
  uint64_t v66 = 0LL;
  __int128 v67 = 0uLL;
  __int128 v68 = 0uLL;
  std::string::size_type v82 = 0LL;
  uint64_t v83 = 0LL;
  __int128 v69 = 0uLL;
  uint64_t v84 = 0LL;
  uint64_t v86 = 0LL;
  __int128 v85 = 0u;
  __int128 v70 = 0uLL;
  __int128 v87 = 0uLL;
  __int128 v71 = 0uLL;
  uint64_t v88 = 0LL;
  uint64_t v90 = 0LL;
  __int128 __p = 0u;
  __int128 v72 = 0uLL;
  __int128 v73 = 0uLL;
  int v91 = -1;
  sub_100F9F564(a1 + 1728, (int *)&v75, (uint64_t)&v75);
  if (SHIBYTE(v90) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v88) < 0) {
    operator delete((void *)v87);
  }
  if (SHIBYTE(v86) < 0) {
    operator delete((void *)v85);
  }
  if (SHIBYTE(v84) < 0) {
    operator delete(v82);
  }
  if (SHIBYTE(v81) < 0) {
    operator delete(v79);
  }
  if (sub_1004FAACC())
  {
    *(void *)__int128 v65 = 11LL;
    *(void *)&__int128 v15 = -1LL;
    *((void *)&v15 + 1) = -1LL;
    *(_OWORD *)&v65[8] = v15;
    *(_OWORD *)&v65[24] = v15;
    uint64_t v74 = 0xFFFFFFFFLL;
    LODWORD(v75) = 1;
    __int128 v77 = *(_OWORD *)&v65[16];
    __int128 v76 = *(_OWORD *)v65;
    uint64_t v78 = -1LL;
    BOOL v79 = 0LL;
    uint64_t v80 = 0LL;
    uint64_t v81 = 0LL;
    uint64_t v66 = 0LL;
    __int128 v67 = 0uLL;
    __int128 v68 = 0uLL;
    std::string::size_type v82 = 0LL;
    uint64_t v83 = 0LL;
    __int128 v69 = 0uLL;
    uint64_t v84 = 0LL;
    uint64_t v86 = 0LL;
    __int128 v85 = 0u;
    __int128 v70 = 0uLL;
    __int128 v87 = 0uLL;
    __int128 v71 = 0uLL;
    uint64_t v88 = 0LL;
    uint64_t v90 = 0LL;
    __int128 __p = 0u;
    __int128 v72 = 0uLL;
    __int128 v73 = 0uLL;
    int v91 = -1;
    sub_100F9F564(a1 + 1728, (int *)&v75, (uint64_t)&v75);
    if (SHIBYTE(v90) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v88) < 0) {
      operator delete((void *)v87);
    }
    if (SHIBYTE(v86) < 0) {
      operator delete((void *)v85);
    }
    if (SHIBYTE(v84) < 0) {
      operator delete(v82);
    }
    if (SHIBYTE(v81) < 0) {
      operator delete(v79);
    }
  }

  __int128 v75 = &off_101890560;
  *(void *)&__int128 v76 = a1;
  *(void *)&__int128 v77 = &v75;
  *(void *)__int128 v65 = &off_1018905F0;
  *(void *)&v65[8] = a1;
  *(void *)&v65[24] = v65;
  float v16 = operator new(0x9D8uLL);
  id v17 = *(id *)a1;
  BOOL v18 = *(void **)(a1 + 8);
  __int128 v64 = v63;
  v63[0] = &off_101890560;
  v63[1] = a1;
  unint64_t v19 = *(std::__shared_weak_count **)(a1 + 1776);
  uint64_t v55 = *(void *)(a1 + 1768);
  uint64_t v56 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
    if (!*(void *)&v65[24])
    {
      uint64_t v62 = 0LL;
      goto LABEL_32;
    }

    if (*(_BYTE **)&v65[24] != v65)
    {
      uint64_t v62 = (void *)(*(uint64_t (**)(void))(**(void **)&v65[24] + 16LL))();
      goto LABEL_32;
    }

    uint64_t v22 = *(void *)&v65[8];
  }

  else
  {
    uint64_t v22 = a1;
  }

  uint64_t v62 = v61;
  v61[0] = &off_1018905F0;
  v61[1] = v22;
LABEL_32:
  sub_100E4AE70((uint64_t)v16, (uint64_t)v17, v18, (uint64_t)v63, &v55, (uint64_t)v61);
  uint64_t v23 = *v11;
  *uint8x8_t v11 = (uint64_t)v16;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
  }
  __int16 v24 = v62;
  if (v62 == v61)
  {
    uint64_t v25 = 4LL;
    __int16 v24 = v61;
    goto LABEL_38;
  }

  if (v62)
  {
    uint64_t v25 = 5LL;
LABEL_38:
    (*(void (**)(void))(*v24 + 8 * v25))();
  }

  uint64_t v26 = v56;
  if (v56)
  {
    __int16 v27 = (unint64_t *)&v56->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  __int16 v29 = v64;
  if (v64 == v63)
  {
    uint64_t v30 = 4LL;
    __int16 v29 = v63;
  }

  else
  {
    if (!v64) {
      goto LABEL_49;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_49:
  uint64_t v31 = (uint64_t (**)())operator new(0x808uLL);
  id v32 = *(id *)a1;
  uint64_t v33 = *(void **)(a1 + 8);
  uint64_t v34 = v77;
  if (!(void)v77)
  {
LABEL_52:
    __int128 v60 = (_BYTE *)v34;
    goto LABEL_54;
  }

  if ((uint64_t (***)())v77 != &v75)
  {
    uint64_t v34 = (*(uint64_t (**)(void))(*(void *)v77 + 16LL))();
    goto LABEL_52;
  }

  __int128 v60 = v59;
  ((void (*)(uint64_t (***)(), _BYTE *))v75[3])(&v75, v59);
LABEL_54:
  uint64_t v35 = *(std::__shared_weak_count **)(a1 + 1776);
  uint64_t v53 = *(void *)(a1 + 1768);
  __int128 v54 = v35;
  if (v35)
  {
    __int128 v36 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }

  uint64_t v38 = *(void *)&v65[24];
  if (!*(void *)&v65[24]) {
    goto LABEL_60;
  }
  if (*(_BYTE **)&v65[24] != v65)
  {
    uint64_t v38 = (*(uint64_t (**)(void))(**(void **)&v65[24] + 16LL))();
LABEL_60:
    uint64_t v58 = (_BYTE *)v38;
    goto LABEL_62;
  }

  uint64_t v58 = v57;
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)v65 + 24LL))(v65, v57);
LABEL_62:
  sub_100762324(v31, (uint64_t)v32, v33, (uint64_t)v59, &v53, (uint64_t)v57);
  uint64_t v39 = *(void *)(a1 + 1824);
  *(void *)(a1 + 1824) = v31;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
  }
  id v40 = v58;
  if (v58 == v57)
  {
    uint64_t v41 = 4LL;
    id v40 = v57;
    goto LABEL_68;
  }

  if (v58)
  {
    uint64_t v41 = 5LL;
LABEL_68:
    (*(void (**)(void))(*v40 + 8 * v41))();
  }

  __int16 v42 = v54;
  if (v54)
  {
    uint64_t v43 = (unint64_t *)&v54->__shared_owners_;
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }

  unsigned int v45 = v60;
  if (v60 == v59)
  {
    uint64_t v46 = 4LL;
    unsigned int v45 = v59;
  }

  else
  {
    if (!v60) {
      goto LABEL_79;
    }
    uint64_t v46 = 5LL;
  }

  (*(void (**)(void))(*v45 + 8 * v46))();
LABEL_79:
  __int128 v47 = *(void **)&v65[24];
  if (*(_BYTE **)&v65[24] == v65)
  {
    uint64_t v48 = 4LL;
    __int128 v47 = v65;
  }

  else
  {
    if (!*(void *)&v65[24]) {
      goto LABEL_84;
    }
    uint64_t v48 = 5LL;
  }

  (*(void (**)(void))(*v47 + 8 * v48))();
LABEL_84:
  __int128 v49 = (uint64_t (***)())v77;
  if ((uint64_t (***)())v77 == &v75)
  {
    uint64_t v50 = 4LL;
    __int128 v49 = &v75;
    goto LABEL_88;
  }

  if ((void)v77)
  {
    uint64_t v50 = 5LL;
LABEL_88:
    (*v49)[v50]();
  }

  return a1;
}

void sub_100F97AB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, char *a32, char a33, uint64_t a34, uint64_t a35, char *a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,char *a57)
{
  __int128 v63 = a32;
  if (a32 == &a29)
  {
    uint64_t v64 = 4LL;
    __int128 v63 = &a29;
  }

  else
  {
    if (!a32) {
      goto LABEL_6;
    }
    uint64_t v64 = 5LL;
  }

  (*(void (**)(void))(*(void *)v63 + 8 * v64))();
LABEL_6:
  operator delete(v59);
  __int128 v65 = a36;
  if (a36 == &a33)
  {
    uint64_t v66 = 4LL;
    __int128 v65 = &a33;
  }

  else
  {
    if (!a36) {
      goto LABEL_11;
    }
    uint64_t v66 = 5LL;
  }

  (*(void (**)(void))(*(void *)v65 + 8 * v66))();
LABEL_11:
  __int128 v67 = a57;
  if (a57 == &a54)
  {
    uint64_t v68 = 4LL;
    __int128 v67 = &a54;
  }

  else
  {
    if (!a57)
    {
LABEL_16:
      uint64_t v69 = 0LL;
      uint64_t v70 = v57 + 1824;
      do
      {
        uint64_t v71 = *(void *)(v70 + v69);
        *(void *)(v70 + v69) = 0LL;
        if (v71) {
          (*(void (**)(uint64_t))(*(void *)v71 + 8LL))(v71);
        }
        v69 -= 8LL;
      }

      while (v69 != -16);
      __int128 v72 = *(void **)(v57 + 1808);
      if (v72 == a11)
      {
        uint64_t v73 = 4LL;
      }

      else
      {
        if (!v72) {
          goto LABEL_25;
        }
        uint64_t v73 = 5LL;
        a11 = *(void **)(v57 + 1808);
      }

      (*(void (**)(void))(*a11 + 8 * v73))();
LABEL_25:
      sub_10000AE14(a9);
      sub_100F9F47C(v58);
      sub_1002DDBC0(v57 + 1664);
      sub_10000AE14(v57 + 1544);
      sub_10000AE14(v57 + 744);
      uint64_t v74 = *(void *)(v57 + 32);
      *(void *)(v57 + 32) = 0LL;
      if (v74) {
        (*(void (**)(uint64_t))(*(void *)v74 + 8LL))(v74);
      }
      uint64_t v75 = *(void *)(v57 + 24);
      *(void *)(v57 + 24) = 0LL;
      if (v75) {
        (*(void (**)(uint64_t))(*(void *)v75 + 8LL))(v75);
      }
      uint64_t v76 = *v60;
      uint64_t *v60 = 0LL;
      if (v76) {
        (*(void (**)(uint64_t))(*(void *)v76 + 8LL))(v76);
      }
      _Unwind_Resume(a1);
    }

    uint64_t v68 = 5LL;
  }

  (*(void (**)(void))(*(void *)v67 + 8 * v68))();
  goto LABEL_16;
}

void sub_100F97D24(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#Actor already registered as client of Location Controller",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor already registered as client of Location Controller",  v30,  2);
      BOOL v18 = (uint8_t *)v17;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v17);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Actor registering as client of Location Controller",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering as client of Location Controller",  v30,  2);
      __int16 v24 = (uint8_t *)v23;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v23);
      if (v24 != buf) {
        free(v24);
      }
    }

    sub_10043AC3C((uint64_t)sub_100F9AA40, a1, *(void **)a1, buf);
    uint64_t v6 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v7 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v6;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
      uint64_t v8 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
      }
    }
  }

  if (*(void *)(a1 + 24))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Actor already registered as client of WiFi location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      LODWORD(v29) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor already registered as client of WiFi location",  v30,  v29);
      unint64_t v20 = (uint8_t *)v19;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v19);
      if (v20 != buf) {
        free(v20);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Actor registering as client of WiFi location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      LODWORD(v29) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering as client of WiFi location",  v30,  v29);
      uint64_t v26 = (uint8_t *)v25;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v25);
      if (v26 != buf) {
        free(v26);
      }
    }

    sub_100445CF0((uint64_t)sub_100F9AC18, a1, *(void **)a1, buf);
    uint64_t v10 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v11 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v10;
    if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
      uint64_t v12 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      }
    }
  }

  if (*(void *)(a1 + 32))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    __int128 v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Actor already registered as client of Cell location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      LODWORD(v29) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor already registered as client of Cell location",  v30,  v29);
      uint64_t v22 = (uint8_t *)v21;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v21);
      if (v22 != buf) {
        free(v22);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    id v13 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#Actor registering as client of Cell location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v30[0] = 0;
      LODWORD(v29) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering as client of Cell location",  v30,  v29);
      unint64_t v28 = (uint8_t *)v27;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::setupLocationClient()", "%s\n", v27);
      if (v28 != buf) {
        free(v28);
      }
    }

    sub_100A315EC((uint64_t)sub_100F9ADE4, a1, *(void **)a1, buf);
    uint64_t v14 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v15 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v14;
    if (v15)
    {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
      uint64_t v16 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
      }
    }
  }

uint64_t sub_100F98578(uint64_t a1)
{
  return a1;
}

uint64_t sub_100F985E8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100F9865C(uint64_t a1)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  for (uint64_t i = 1824LL; i != 1808; i -= 8LL)
  {
    uint64_t v3 = *(void *)(a1 + i);
    *(void *)(a1 + i) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  __int128 v4 = *(void **)(a1 + 1808);
  if (v4 == (void *)(a1 + 1784))
  {
    uint64_t v5 = 4LL;
    __int128 v4 = (void *)(a1 + 1784);
  }

  else
  {
    if (!v4) {
      goto LABEL_10;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  sub_10000AE14(a1 + 1768);
  sub_100F9F47C(a1 + 1728);
  sub_1002DDBC0(a1 + 1664);
  sub_10000AE14(a1 + 1544);
  sub_10000AE14(a1 + 744);
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  return a1;
}

void sub_100F98768(std::string::size_type a1, const std::string *a2)
{
  if ((char)a2->__r_.__value_.__s.__size_ < 0 && (unint64_t v4 = a2->__r_.__value_.__l.__size_, v4 > 0x2BB))
  {
    int v5 = vcvtpd_s64_f64((double)v4 / 700.0);
    if (v5 >= 21)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v6 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        buf.__r_.__value_.__r.__words[0] = 0x1404020100LL;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "#Warning #Actor limiting multi-line string to %{public}d lines",  (uint8_t *)&buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        int v33 = 67240192;
        *(_DWORD *)uint64_t v34 = 20;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #Actor limiting multi-line string to %{public}d lines",  &v33,  8);
        uint64_t v30 = (std::string *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLEmergencyActor::logMultiLineString(const std::string &, const std::string &)",  "%s\n",  v29);
        if (v30 != &buf) {
          free(v30);
        }
      }

      int v5 = 20;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(size) = a2->__r_.__value_.__s.__size_;
      if ((size & 0x80u) != 0LL) {
        std::string::size_type size = a2->__r_.__value_.__l.__size_;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 67240448;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = size;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#Actor splitting string (length %{public}d) into %{public}d parts",  (uint8_t *)&buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      LODWORD(v22) = a2->__r_.__value_.__s.__size_;
      if ((v22 & 0x80u) != 0LL) {
        std::string::size_type v22 = a2->__r_.__value_.__l.__size_;
      }
      int v33 = 67240448;
      *(_DWORD *)uint64_t v34 = v22;
      *(_WORD *)&v34[4] = 1026;
      *(_DWORD *)&v34[6] = v5;
      LODWORD(v31) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor splitting string (length %{public}d) into %{public}d parts",  &v33,  v31);
      __int16 v24 = (std::string *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLEmergencyActor::logMultiLineString(const std::string &, const std::string &)",  "%s\n",  v23);
      if (v24 != &buf) {
        free(v24);
      }
    }

    if (v5 >= 1)
    {
      for (unint64_t i = 0LL; i != v5; ++i)
      {
        memset(&__p, 0, sizeof(__p));
        std::string::size_type v10 = (700 * i);
        if (i >= (v5 - 1))
        {
          std::string::size_type v11 = a2->__r_.__value_.__s.__size_;
          if ((v11 & 0x80u) != 0LL) {
            std::string::size_type v11 = a2->__r_.__value_.__l.__size_;
          }
          std::string::basic_string(&buf, a2, v10, v11 - v10, (std::allocator<char> *)&v33);
        }

        else
        {
          std::string::basic_string(&buf, a2, v10, 0x2BCuLL, (std::allocator<char> *)&v33);
        }

        std::string __p = buf;
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v12 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          else {
            std::string::size_type v13 = *(void *)a1;
          }
          p_p = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446979;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v13;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 1026;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = i + 1;
          WORD1(buf.__r_.__value_.__r.__words[2]) = 1026;
          HIDWORD(buf.__r_.__value_.__r.__words[2]) = v5;
          __int16 v39 = 2081;
          id v40 = p_p;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}d of %{public}d : %{private}s",  (uint8_t *)&buf,  0x22u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          else {
            std::string::size_type v15 = *(void *)a1;
          }
          uint64_t v16 = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            uint64_t v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          int v33 = 136446979;
          *(void *)uint64_t v34 = v15;
          *(_WORD *)&v34[8] = 1026;
          *(_DWORD *)uint64_t v35 = i + 1;
          *(_WORD *)&v35[4] = 1026;
          *(_DWORD *)&v35[6] = v5;
          __int16 v36 = 2081;
          unint64_t v37 = v16;
          LODWORD(v31) = 34;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "%{public}s %{public}d of %{public}d : %{private}s",  &v33,  v31);
          BOOL v18 = (std::string *)v17;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLEmergencyActor::logMultiLineString(const std::string &, const std::string &)",  "%s\n",  v17);
          if (v18 != &buf) {
            free(v18);
          }
        }
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v19 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      else {
        std::string::size_type v20 = *(void *)a1;
      }
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v21 = (std::string::size_type)a2;
      }
      else {
        std::string::size_type v21 = a2->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446467;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v20;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "%{public}s : %{private}s",  (uint8_t *)&buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      else {
        std::string::size_type v25 = *(void *)a1;
      }
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v26 = a2;
      }
      else {
        uint64_t v26 = (const std::string *)a2->__r_.__value_.__r.__words[0];
      }
      int v33 = 136446467;
      *(void *)uint64_t v34 = v25;
      *(_WORD *)&v34[8] = 2081;
      *(void *)uint64_t v35 = v26;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "%{public}s : %{private}s",  &v33,  22);
      unint64_t v28 = (std::string *)v27;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLEmergencyActor::logMultiLineString(const std::string &, const std::string &)",  "%s\n",  v27);
      if (v28 != &buf) {
        free(v28);
      }
    }
  }

void sub_100F98F2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100F98F5C(void *a1, unsigned int a2)
{
  id v2 = a1;
  uint64_t v3 = a2 - 3;
  if (a2 > 3)
  {
    if ([a1 length] > a2)
    {
      id v2 = objc_msgSend(objc_msgSend(v2, "substringWithRange:", 0, v3), "stringByAppendingString:", @"...");
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      unint64_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 67240192;
        unsigned int v15 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#Warning #Actor truncated string to %{public}d characters",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v13[0] = 67240192;
        v13[1] = a2;
        double v11 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #Actor truncated string to %{public}d characters",  v13,  8);
        uint64_t v7 = v12;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static NSString *CLEmergencyActor::getTruncatedString(NSString *, uint32_t)",  "%s\n",  v11);
        goto LABEL_20;
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#Actor truncated string max length is too small, not enforcing",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      LOWORD(v13[0]) = 0;
      double v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor truncated string max length is too small, not enforcing",  v13,  2);
      uint64_t v7 = v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static NSString *CLEmergencyActor::getTruncatedString(NSString *, uint32_t)",  "%s\n",  v5);
LABEL_20:
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  return v2;
}

BOOL sub_100F99260(uint64_t a1)
{
  BOOL v3 = *(double *)(a1 + 36) > 0.0 && *(_DWORD *)(a1 + 472) != -1;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  unint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a1 + 28);
    double v6 = *(float *)(a1 + 476);
    uint64_t v7 = *(void *)(a1 + 36);
    int v8 = *(_DWORD *)(a1 + 472);
    v10[0] = 68290307;
    v10[1] = 0;
    __int16 v11 = 2082;
    uint64_t v12 = "";
    __int16 v13 = 1026;
    BOOL v14 = v3;
    __int16 v15 = 2049;
    uint64_t v16 = v5;
    __int16 v17 = 2049;
    double v18 = v6;
    __int16 v19 = 2050;
    uint64_t v20 = v7;
    __int16 v21 = 1026;
    int v22 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Actor,isAltitudeAvailable, available:%{public}hhd, altitude (MSL):%{private}f , undulation:%{private}f, vunc:%{public}f, undulation model:%{public}d}",  (uint8_t *)v10,  0x3Cu);
  }

  return v3;
}

uint64_t sub_100F993A0(uint64_t a1, double *a2, double *a3)
{
  uint64_t result = sub_100869780(a1);
  if ((result & 1) != 0)
  {
    CLGetUncertaintyScaleFactors(95LL, &v9, &v8);
    *a2 = v9 * *(double *)(a1 + 20);
    uint64_t result = sub_100F99260(a1);
    double v7 = -1.0;
    if ((_DWORD)result) {
      double v7 = v8 * *(double *)(a1 + 36);
    }
  }

  else
  {
    *a2 = -1.0;
    double v7 = -1.0;
  }

  *a3 = v7;
  return result;
}

uint64_t sub_100F99440(uint64_t a1)
{
  uint64_t v1 = sub_1007624D0(*(void *)(a1 + 1824));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  id v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v3 = "not be displayed";
    if ((_DWORD)v1) {
      BOOL v3 = "be displayed";
    }
    *(_DWORD *)std::string buf = 136446210;
    __int16 v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#Actor EED UI should %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v5 = "not be displayed";
    if ((_DWORD)v1) {
      uint64_t v5 = "be displayed";
    }
    int v8 = 136446210;
    double v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor EED UI should %{public}s",  &v8,  12);
    double v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyActor::shouldDisplayEEDUI()", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return v1;
}

void sub_100F99624(uint64_t a1, _DWORD *a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  BOOL v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    sub_100982BDC((_DWORD *)(a1 + 44), &v42);
    int size = (char)v42.__r_.__value_.__s.__size_;
    std::string::size_type v5 = v42.__r_.__value_.__r.__words[0];
    sub_100982BDC(a2, &v41);
    double v6 = &v42;
    if (size < 0) {
      double v6 = (std::string *)v5;
    }
    if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v7 = &v41;
    }
    else {
      double v7 = (std::string *)v41.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v37 = 2082;
    uint64_t v38 = "";
    __int16 v39 = 2082;
    *(void *)id v40 = v6;
    *(_WORD *)&v40[8] = 2082;
    *(void *)&v40[10] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Actor emergency state change, oldState:%{public, location:escape_only}s, newState :%{public, location:escape_only}s}",  buf,  0x26u);
  }

  if (!sub_1009830C8(a1 + 44) && sub_1009830C8((uint64_t)a2))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    int v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(unsigned __int8 *)(a1 + 41);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v37 = 2082;
      uint64_t v38 = "";
      __int16 v39 = 1026;
      *(_DWORD *)id v40 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmgContext #Actor, LS:%{public}d}",  buf,  0x18u);
    }

    std::string::size_type v10 = *(uint64_t **)(a1 + 1744);
    if (v10)
    {
      uint64_t v11 = qword_101934890;
      do
      {
        if (v11 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v12 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = *((_DWORD *)v10 + 4);
          int v14 = *((unsigned __int8 *)v10 + 28);
          *(_DWORD *)std::string buf = 68289539;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v37 = 2082;
          uint64_t v38 = "";
          __int16 v39 = 1026;
          *(_DWORD *)id v40 = v13;
          *(_WORD *)&v40[4] = 1025;
          *(_DWORD *)&v40[6] = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmgContext #Actor, inst:%{public}d, InHomeCountry:%{private}d}",  buf,  0x1Eu);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
        }

        __int16 v15 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = v10 + 20;
          int v17 = *((_DWORD *)v10 + 4);
          *(_DWORD *)std::string buf = 68289539;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v37 = 2082;
          uint64_t v38 = "";
          __int16 v39 = 1026;
          *(_DWORD *)id v40 = v17;
          *(_WORD *)&v40[4] = 2081;
          *(void *)&v40[6] = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmgContext #Actor, inst:%{public}d, PhoneNum:%{private, location:escape_only}s}",  buf,  0x22u);
          uint64_t v11 = qword_101934890;
        }

        else
        {
          uint64_t v11 = -1LL;
        }

        std::string::size_type v10 = (uint64_t *)*v10;
      }

      while (v10);
    }
  }

  uint64_t v18 = 0LL;
  __int128 v19 = *(_OWORD *)a2;
  uint64_t v20 = "UnknownAction";
  char v21 = 1;
  *(_DWORD *)(a1 + 60) = a2[4];
  *(_OWORD *)(a1 + 44) = v19;
  do
  {
    char v22 = v21;
    uint64_t v23 = *(void *)(a1 + 1816 + 8 * v18);
    if (v23)
    {
      __int128 v34 = *(_OWORD *)a2;
      int v35 = a2[4];
      (*(void (**)(uint64_t, __int128 *))(*(void *)v23 + 32LL))(v23, &v34);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      __int16 v24 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        if ((v22 & 1) != 0) {
          std::string::size_type v25 = "AML";
        }
        else {
          std::string::size_type v25 = (char *)v20;
        }
        sub_1010DDBC0(buf, v25);
        uint64_t v26 = buf;
        if (v40[3] < 0) {
          uint64_t v26 = *(uint8_t **)buf;
        }
        LODWORD(v42.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "#Actor,handleEmergencyStateChange,pointer was null for %{public}s",  (uint8_t *)&v42,  0xCu);
        if ((v40[3] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v27 = qword_101934898;
        if ((v22 & 1) != 0) {
          unint64_t v28 = "AML";
        }
        else {
          unint64_t v28 = "EED2";
        }
        sub_1010DDBC0(&v42, v28);
        uint64_t v29 = &v42;
        if ((v42.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v29 = (std::string *)v42.__r_.__value_.__r.__words[0];
        }
        LODWORD(v41.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v41.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
        LODWORD(v32) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v27,  16LL,  "#Actor,handleEmergencyStateChange,pointer was null for %{public}s",  &v41,  v32);
        uint64_t v31 = v30;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyActor::handleEmergencyStateChange(CLEmergencyState)",  "%s\n",  v31);
      }
    }

    char v21 = 0;
    uint64_t v20 = "EED2";
    uint64_t v18 = 1LL;
  }

  while ((v22 & 1) != 0);
  sub_100F99C18(a1);
  sub_100F99F0C(a1);
}

void sub_100F99BF4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F99C18(uint64_t a1)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 1816) + 16LL))(*(void *)(a1 + 1816)))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#Actor sending lockout NILR", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor sending lockout NILR",  v10,  2);
      double v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::modifyNilrHandlingFlags()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    buf[0] = 1;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    BOOL v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Actor sending disable NILR lockout", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor sending disable NILR lockout",  v10,  2);
      int v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::modifyNilrHandlingFlags()", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    buf[0] = 0;
  }

  uint64_t v4 = *(void *)(a1 + 1808);
  if (!v4) {
    sub_100008BDC();
  }
  return (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v4 + 48LL))(v4, buf);
}

void sub_100F99F0C(uint64_t a1)
{
  uint64_t v2 = 0LL;
  BOOL v3 = "UnknownAction";
  uint64_t v4 = a1 + 1816;
  char v5 = 1;
  while (1)
  {
    char v6 = v5;
    uint64_t v7 = *(void *)(v4 + 8 * v2);
    if (!v7)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        if ((v6 & 1) != 0) {
          int v9 = "AML";
        }
        else {
          int v9 = (char *)v3;
        }
        sub_1010DDBC0(__p, v9);
        std::string::size_type v10 = __p;
        if (v22 < 0) {
          std::string::size_type v10 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#Actor,checkLocationRegistration,pointer was null for %{public}s",  buf,  0xCu);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v11 = qword_101934898;
        if ((v6 & 1) != 0) {
          uint64_t v12 = "AML";
        }
        else {
          uint64_t v12 = "EED2";
        }
        sub_1010DDBC0(buf, v12);
        int v13 = buf;
        if (v18 < 0) {
          int v13 = *(_BYTE **)buf;
        }
        int v19 = 136446210;
        uint64_t v20 = v13;
        LODWORD(v16) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v11,  16LL,  "#Actor,checkLocationRegistration,pointer was null for %{public}s",  &v19,  v16);
        __int16 v15 = v14;
        if (v18 < 0) {
          operator delete(*(void **)buf);
        }
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::checkLocationRegistration()", "%s\n", v15);
      }

      goto LABEL_16;
    }

void sub_100F9A1CC(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 41) = a2;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  BOOL v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 41);
    *(_DWORD *)std::string buf = 68289282;
    int v14 = 0;
    __int16 v15 = 2082;
    uint64_t v16 = "";
    __int16 v17 = 1026;
    int v18 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Actor handleLocationServicesStatusChange, fLocationServicesEnabled:%{public}hhd}",  buf,  0x18u);
  }

  if (!*(_BYTE *)(a1 + 41))
  {
    if (sub_1009830FC(a1 + 44))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      char v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Actor clearing cached location due to LS off",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_20;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v12[0] = 0;
      double v6 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor clearing cached location due to LS off",  v12,  2);
      int v8 = v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::handleLocationServicesStatusChange(const BOOL)",  "%s\n",  v6);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "#Actor LS unexpectedly turned off during an emergency, still clearing cached location",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_20;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v12[0] = 0;
      double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor LS unexpectedly turned off during an emergency, still clearing cached location",  v12,  2);
      int v8 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyActor::handleLocationServicesStatusChange(const BOOL)",  "%s\n",  v10);
    }

    if (v8 != buf) {
      free(v8);
    }
LABEL_20:
    sub_100E51908(a1 + 64);
    sub_100E51908(a1 + 864);
  }

void sub_100F9A520(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  int v4 = "UnknownAction";
  uint64_t v5 = a1 + 1816;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8 * v3);
    if (v8)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 88LL))(v8, a2);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        if ((v7 & 1) != 0) {
          double v10 = "AML";
        }
        else {
          double v10 = (char *)v4;
        }
        sub_1010DDBC0(__p, v10);
        uint64_t v11 = __p;
        if (v23 < 0) {
          uint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "#Actor,handleBatteryStatusChange,pointer was null for %{public}s",  buf,  0xCu);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v12 = qword_101934898;
        if ((v7 & 1) != 0) {
          int v13 = "AML";
        }
        else {
          int v13 = "EED2";
        }
        sub_1010DDBC0(buf, v13);
        int v14 = buf;
        if (v19 < 0) {
          int v14 = *(_BYTE **)buf;
        }
        int v20 = 136446210;
        char v21 = v14;
        LODWORD(v17) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v12,  16LL,  "#Actor,handleBatteryStatusChange,pointer was null for %{public}s",  &v20,  v17);
        uint64_t v16 = v15;
        if (v19 < 0) {
          operator delete(*(void **)buf);
        }
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyActor::handleBatteryStatusChange(const Battery &)",  "%s\n",  v16);
      }
    }

    char v6 = 0;
    int v4 = "EED2";
    uint64_t v3 = 1LL;
  }

  while ((v7 & 1) != 0);
}

void sub_100F9A7B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  int v4 = "UnknownAction";
  uint64_t v5 = a1 + 1816;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8 * v3);
    if (v8)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 96LL))(v8, a2);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        if ((v7 & 1) != 0) {
          double v10 = "AML";
        }
        else {
          double v10 = (char *)v4;
        }
        sub_1010DDBC0(__p, v10);
        uint64_t v11 = __p;
        if (v23 < 0) {
          uint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "#Actor,handleReachability,pointer was null for %{public}s",  buf,  0xCu);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v12 = qword_101934898;
        if ((v7 & 1) != 0) {
          int v13 = "AML";
        }
        else {
          int v13 = "EED2";
        }
        sub_1010DDBC0(buf, v13);
        int v14 = buf;
        if (v19 < 0) {
          int v14 = *(_BYTE **)buf;
        }
        int v20 = 136446210;
        char v21 = v14;
        LODWORD(v17) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v12,  16LL,  "#Actor,handleReachability,pointer was null for %{public}s",  &v20,  v17);
        uint64_t v16 = v15;
        if (v19 < 0) {
          operator delete(*(void **)buf);
        }
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyActor::handleReachability(const CLDaemonStatus_Type::Reachability)",  "%s\n",  v16);
      }
    }

    char v6 = 0;
    int v4 = "EED2";
    uint64_t v3 = 1LL;
  }

  while ((v7 & 1) != 0);
}

void sub_100F9AA40(uint64_t a1, int *a2, uint64_t a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101890530);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLEmergencyActor::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101890530);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      char v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLEmergencyActor::onLocationNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100F9BE30((uint64_t)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F9ABF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9AC18(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101890530);
  }
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
  if (v6)
  {
    char v12 = 1;
    int v9 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLEmergencyActor::onWifiLocationProviderNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v9, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101890530);
    }
    double v10 = (os_log_s *)qword_1019349D8;
    BOOL v6 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
    if (v6)
    {
      *(_DWORD *)std::string buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      __int16 v18 = "activity";
      __int16 v19 = 2050;
      int v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLEmergencyActor::onWifiLocationProviderNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v12 = 0;
  }

  sub_100F9DDAC(v6, v7, v8, a3);
  if (v12) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F9ADC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9ADE4(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101890530);
  }
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
  if (v6)
  {
    char v12 = 1;
    int v9 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLEmergencyActor::onCellLocationProviderNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v9, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101890530);
    }
    double v10 = (os_log_s *)qword_1019349D8;
    BOOL v6 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
    if (v6)
    {
      *(_DWORD *)std::string buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      __int16 v18 = "activity";
      __int16 v19 = 2050;
      int v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLEmergencyActor::onCellLocationProviderNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v12 = 0;
  }

  sub_100F9DFB4(v6, v7, v8, a3);
  if (v12) {
    os_activity_scope_leave(&state);
  }
}

void sub_100F9AF90( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9AFB0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(void *)(a1 + 16))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v2 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#Actor unregistering for location notifications",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v18[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor unregistering for location notifications",  v18,  2);
        uint64_t v8 = (uint8_t *)v7;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::unregisterForLocation()", "%s\n", v7);
        if (v8 != buf) {
          free(v8);
        }
      }

      [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:0];
      [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:4];
      [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:33];
    }

    if (*(void *)(a1 + 24))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v3 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Actor unregistering for WiFi location notifications",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v18[0] = 0;
        LODWORD(v17) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor unregistering for WiFi location notifications",  v18,  v17);
        double v10 = (uint8_t *)v9;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::unregisterForLocation()", "%s\n", v9);
        if (v10 != buf) {
          free(v10);
        }
      }

      [*(id *)(*(void *)(a1 + 24) + 16) unregister:*(void *)(*(void *)(a1 + 24) + 8) forNotification:0];
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#Actor unregistering - WiFi client NULL",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v18[0] = 0;
        LODWORD(v17) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor unregistering - WiFi client NULL",  v18,  v17);
        int v14 = (uint8_t *)v13;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::unregisterForLocation()", "%s\n", v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }

    if (*(void *)(a1 + 32))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Actor unregistering for Cell location notifications",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v18[0] = 0;
        LODWORD(v17) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor unregistering for Cell location notifications",  v18,  v17);
        char v12 = (uint8_t *)v11;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::unregisterForLocation()", "%s\n", v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      [*(id *)(*(void *)(a1 + 32) + 16) unregister:*(void *)(*(void *)(a1 + 32) + 8) forNotification:0];
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      BOOL v6 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#Actor unregistering - Cell client NULL",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v18[0] = 0;
        LODWORD(v17) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor unregistering - Cell client NULL",  v18,  v17);
        __int16 v16 = (uint8_t *)v15;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::unregisterForLocation()", "%s\n", v15);
        if (v16 != buf) {
          free(v16);
        }
      }
    }

    *(_BYTE *)(a1 + 40) = 0;
  }

void sub_100F9B64C(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    if (!*(_BYTE *)(a1 + 40))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v2 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#Actor registering for location notifications",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v21[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering for location notifications",  v21,  2);
        char v11 = (uint8_t *)v10;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:0 registrationInfo:0];
      [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:4 registrationInfo:0];
      [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:33 registrationInfo:0];
      if (*(void *)(a1 + 24))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v3 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Actor registering for WiFi location notification",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          v21[0] = 0;
          LODWORD(v20) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering for WiFi location notification",  v21,  v20);
          int v13 = (uint8_t *)v12;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v12);
          if (v13 != buf) {
            free(v13);
          }
        }

        [*(id *)(*(void *)(a1 + 24) + 16) register:*(void *)(*(void *)(a1 + 24) + 8) forNotification:0 registrationInfo:0];
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v7 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "#Actor registering - WiFi client NULL",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          v21[0] = 0;
          LODWORD(v20) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor registering - WiFi client NULL",  v21,  v20);
          uint64_t v17 = (uint8_t *)v16;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v16);
          if (v17 != buf) {
            free(v17);
          }
        }
      }

      if (*(void *)(a1 + 32))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        uint64_t v8 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Actor registering for Cell location notification",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          v21[0] = 0;
          LODWORD(v20) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor registering for Cell location notification",  v21,  v20);
          __int16 v15 = (uint8_t *)v14;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v14);
          if (v15 != buf) {
            free(v15);
          }
        }

        [*(id *)(*(void *)(a1 + 32) + 16) register:*(void *)(*(void *)(a1 + 32) + 8) forNotification:0 registrationInfo:0];
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        int v9 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "#Actor registering - Cell client NULL",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          v21[0] = 0;
          LODWORD(v20) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor registering - Cell client NULL",  v21,  v20);
          __int16 v19 = (uint8_t *)v18;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v18);
          if (v19 != buf) {
            free(v19);
          }
        }
      }

      *(_BYTE *)(a1 + 40) = 1;
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#Actor attempted to register for location notification without a client",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v21[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Actor attempted to register for location notification without a client",  v21,  2);
      BOOL v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyActor::registerForLocation()", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

void sub_100F9BE30(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v7 = *a3;
  if (!*a3) {
    goto LABEL_4;
  }
  if (v7 == 4) {
    return;
  }
  if (v7 != 33)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v28 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = *a3;
      *(_DWORD *)std::string buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#Warning #Actor received unexpected notification %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v32 = *a3;
      v35[0] = 67240192;
      v35[1] = v32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #Actor received unexpected notification %{public}d",  v35,  8);
      __int128 v34 = (char *)v33;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocati onProvider_Type::NotificationData &)",  "%s\n",  v33);
      if (v34 != buf) {
        free(v34);
      }
    }
  }

  else
  {
LABEL_4:
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#Actor received new fix", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      LOWORD(v35[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor received new fix",  v35,  2);
      uint64_t v31 = (char *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocati onProvider_Type::NotificationData &)",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }

    *(_DWORD *)std::string buf = 0xFFFF;
    *(void *)&_BYTE buf[12] = 0LL;
    *(void *)&uint8_t buf[4] = 0LL;
    *(_OWORD *)&buf[20] = xmmword_1012E0070;
    __asm { FMOV            V0.2D, #-1.0 }

    *(_OWORD *)&buf[36] = _Q0;
    *(_OWORD *)&buf[52] = _Q0;
    *(_OWORD *)&std::string buf[68] = _Q0;
    *(_DWORD *)&buf[84] = 0;
    __int128 v37 = 0uLL;
    *(void *)&buf[88] = 0xBFF0000000000000LL;
    *(void *)((char *)&v38 + 4) = 0xBFF0000000000000LL;
    LODWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    HIDWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = 0x7FFFFFFF;
    memset(v39, 0, 25);
    sub_100869DC8(&v40);
    __int128 v14 = *(_OWORD *)(a4 + 112);
    __int128 v37 = *(_OWORD *)(a4 + 96);
    __int128 v38 = v14;
    *(_OWORD *)__int16 v39 = *(_OWORD *)(a4 + 128);
    *(_OWORD *)&v39[12] = *(_OWORD *)(a4 + 140);
    __int128 v15 = *(_OWORD *)(a4 + 48);
    *(_OWORD *)&_BYTE buf[32] = *(_OWORD *)(a4 + 32);
    *(_OWORD *)&buf[48] = v15;
    __int128 v16 = *(_OWORD *)(a4 + 80);
    *(_OWORD *)&buf[64] = *(_OWORD *)(a4 + 64);
    *(_OWORD *)&buf[80] = v16;
    __int128 v17 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)std::string buf = *(_OWORD *)a4;
    *(_OWORD *)&uint8_t buf[16] = v17;
    memcpy(v18, (const void *)(a4 + 160), 0x201uLL);
    sub_1000F2F30(&v41, (uint64_t *)(a4 + 680));
    __int128 v19 = *(_OWORD *)(a4 + 776);
    __int128 v47 = *(_OWORD *)(a4 + 760);
    v48[0] = v19;
    *(void *)((char *)v48 + 13) = *(void *)(a4 + 789);
    __int128 v20 = *(_OWORD *)(a4 + 712);
    __int128 v43 = *(_OWORD *)(a4 + 696);
    __int128 v44 = v20;
    if (*a3) {
      char v21 = &unk_10199F8D8;
    }
    else {
      char v21 = &unk_10199F8C0;
    }
    __int128 v22 = *(_OWORD *)(a4 + 744);
    if (*a3) {
      char v23 = (uint64_t *)&unk_10199F908;
    }
    else {
      char v23 = (uint64_t *)&unk_10199F8F0;
    }
    if (*a3) {
      uint64_t v24 = a1 + 864;
    }
    else {
      uint64_t v24 = a1 + 64;
    }
    __int128 v45 = *(_OWORD *)(a4 + 728);
    __int128 v46 = v22;
    sub_100F9C2B8(a1, (uint64_t)v21, v23, (uint64_t)buf, v24, a3);
    std::string::size_type v25 = v42;
    if (v42)
    {
      p_shared_owners = (unint64_t *)&v42->__shared_owners_;
      do
        unint64_t v27 = __ldaxr(p_shared_owners);
      while (__stlxr(v27 - 1, p_shared_owners));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }

void sub_100F9C29C(_Unwind_Exception *a1)
{
}

void sub_100F9C2B8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  __int128 v104 = *(_OWORD *)(a4 + 96);
  __int128 v105 = *(_OWORD *)(a4 + 112);
  *(_OWORD *)__int128 v106 = *(_OWORD *)(a4 + 128);
  *(_OWORD *)&v106[12] = *(_OWORD *)(a4 + 140);
  *(_OWORD *)&v100[16] = *(_OWORD *)(a4 + 32);
  __int128 v101 = *(_OWORD *)(a4 + 48);
  __int128 v102 = *(_OWORD *)(a4 + 64);
  __int128 v103 = *(_OWORD *)(a4 + 80);
  __int128 v99 = *(_OWORD *)a4;
  *(_OWORD *)unsigned __int8 v100 = *(_OWORD *)(a4 + 16);
  memcpy(v107, (const void *)(a4 + 160), 0x201uLL);
  uint64_t v108 = *(void *)(a4 + 680);
  char v12 = *(std::__shared_weak_count **)(a4 + 688);
  __int128 v109 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  __int128 v15 = *(_OWORD *)(a4 + 776);
  __int128 v114 = *(_OWORD *)(a4 + 760);
  *(_OWORD *)std::string::size_type v115 = v15;
  *(void *)&v115[13] = *(void *)(a4 + 789);
  __int128 v16 = *(_OWORD *)(a4 + 712);
  __int128 v110 = *(_OWORD *)(a4 + 696);
  __int128 v111 = v16;
  __int128 v17 = *(_OWORD *)(a4 + 744);
  __int128 v112 = *(_OWORD *)(a4 + 728);
  __int128 v113 = v17;
  BOOL v18 = sub_100F9CDCC((uint64_t *)a2, a4);
  if (v18)
  {
    if (*a6 != 33 || sub_100F9D524(v18, (uint64_t *)a2, a4))
    {
      uint64_t v19 = sub_100F9CDCC(a3, a5);
      if ((_DWORD)v19) {
        uint64_t v19 = sub_100F9DC24();
      }
      if (!sub_100F9D524(v19, (uint64_t *)a2, a4))
      {
        *(_OWORD *)&v100[12] = xmmword_1012EA5D0;
        v107[39] = 0xFFFFFFFFLL;
      }

      *(_OWORD *)(a5 + 96) = v104;
      *(_OWORD *)(a5 + 112) = v105;
      *(_OWORD *)(a5 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)v106;
      *(_OWORD *)(a5 + 140) = *(_OWORD *)&v106[12];
      *(_OWORD *)(a5 + 32) = *(_OWORD *)&v100[16];
      *(_OWORD *)(a5 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v101;
      *(_OWORD *)(a5 + 64) = v102;
      *(_OWORD *)(a5 + sub_100F6A7D8(v1 + 80) = v103;
      *(_OWORD *)a5 = v99;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)v100;
      memcpy((void *)(a5 + 160), v107, 0x201uLL);
      sub_1000F2F30((void *)(a5 + 680), &v108);
      __int128 v20 = *(_OWORD *)v115;
      *(_OWORD *)(a5 + 760) = v114;
      *(_OWORD *)(a5 + 776) = v20;
      *(void *)(a5 + 789) = *(void *)&v115[13];
      __int128 v21 = v111;
      *(_OWORD *)(a5 + 696) = v110;
      *(_OWORD *)(a5 + 712) = v21;
      __int128 v22 = v113;
      *(_OWORD *)(a5 + 72_Block_object_dispose((const void *)(v1 - 128), 8) = v112;
      *(_OWORD *)(a5 + 744) = v22;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      char v23 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v24 = *(void *)a2;
        }
        uint64_t v25 = *(void *)(a5 + 4);
        uint64_t v26 = *(void *)(a5 + 12);
        uint64_t v27 = *(void *)(a5 + 20);
        uint64_t v28 = *(void *)(a5 + 28);
        uint64_t v29 = *(void *)(a5 + 36);
        uint64_t v30 = *(void *)(a5 + 44);
        uint64_t v31 = *(void *)(a5 + 60);
        int v32 = *(_DWORD *)(a5 + 96);
        *(_DWORD *)std::string buf = 136317187;
        *(void *)&uint8_t buf[4] = v24;
        __int16 v136 = 2049;
        uint64_t v137 = v25;
        __int16 v138 = 2049;
        uint64_t v139 = v26;
        __int16 v140 = 2050;
        uint64_t v141 = v27;
        __int16 v142 = 2049;
        uint64_t v143 = v28;
        __int16 v144 = 2050;
        uint64_t v145 = v29;
        __int16 v146 = 2049;
        uint64_t v147 = v30;
        __int16 v148 = 2049;
        uint64_t v149 = v31;
        __int16 v150 = 1026;
        int v151 = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#Actor cached %s fix,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f, speed,%{private}.1f,course,%{private}.1f,type,%{public}d",  buf,  0x58u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        else {
          uint64_t v87 = *(void *)a2;
        }
        uint64_t v88 = *(void *)(a5 + 4);
        uint64_t v89 = *(void *)(a5 + 12);
        uint64_t v90 = *(void *)(a5 + 20);
        uint64_t v91 = *(void *)(a5 + 28);
        uint64_t v92 = *(void *)(a5 + 36);
        uint64_t v93 = *(void *)(a5 + 44);
        uint64_t v94 = *(void *)(a5 + 60);
        int v95 = *(_DWORD *)(a5 + 96);
        *(_DWORD *)__int128 v118 = 136317187;
        *(void *)&v118[4] = v87;
        __int16 v119 = 2049;
        uint64_t v120 = v88;
        __int16 v121 = 2049;
        uint64_t v122 = v89;
        __int16 v123 = 2050;
        uint64_t v124 = v90;
        __int16 v125 = 2049;
        uint64_t v126 = v91;
        __int16 v127 = 2050;
        uint64_t v128 = v92;
        __int16 v129 = 2049;
        uint64_t v130 = v93;
        __int16 v131 = 2049;
        uint64_t v132 = v94;
        __int16 v133 = 1026;
        int v134 = v95;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor cached %s fix,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f, speed,%{private}.1f,course,%{private}.1f,type,%{public}d",  v118,  88);
        int v97 = (char *)v96;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::updateCachedLocation(const std::string &, const std::string &, const GNSS::DaemonLocati on &, GNSS::DaemonLocation &, const CLLocationProvider_Type::Notification &)",  "%s\n",  v96);
        if (v97 != buf) {
          free(v97);
        }
      }

      uint64_t v33 = 0LL;
      uint64_t v34 = a1 + 1816;
      int v35 = "UnknownAction";
      char v36 = 1;
      do
      {
        char v37 = v36;
        uint64_t v38 = *(void *)(v34 + 8 * v33);
        if (v38)
        {
          (*(void (**)(uint64_t))(*(void *)v38 + 64LL))(v38);
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          __int16 v39 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            if ((v37 & 1) != 0) {
              uint64_t v40 = "AML";
            }
            else {
              uint64_t v40 = (char *)v35;
            }
            sub_1010DDBC0(buf, v40);
            uint64_t v41 = buf;
            if (v138 < 0) {
              uint64_t v41 = *(_BYTE **)buf;
            }
            *(_DWORD *)__int128 v118 = 136446210;
            *(void *)&v118[4] = v41;
            _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "#Actor,updateCachedLocation,pointer was null for %{public}s",  v118,  0xCu);
            if (SHIBYTE(v138) < 0) {
              operator delete(*(void **)buf);
            }
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101890510);
            }
            uint64_t v42 = qword_101934898;
            if ((v37 & 1) != 0) {
              __int128 v43 = "AML";
            }
            else {
              __int128 v43 = "EED2";
            }
            sub_1010DDBC0(v118, v43);
            __int128 v44 = v118;
            if (v121 < 0) {
              __int128 v44 = *(_BYTE **)v118;
            }
            int v116 = 136446210;
            __int128 v117 = v44;
            LODWORD(v9_Block_object_dispose((const void *)(v1 - 128), 8) = 12;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v42,  16LL,  "#Actor,updateCachedLocation,pointer was null for %{public}s",  &v116,  v98);
            __int128 v46 = v45;
            if (SHIBYTE(v121) < 0) {
              operator delete(*(void **)v118);
            }
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyActor::updateCachedLocation(const std::string &, const std::string &, const GNSS::DaemonLo cation &, GNSS::DaemonLocation &, const CLLocationProvider_Type::Notification &)",  "%s\n",  v46);
            if (v46 != buf) {
              free(v46);
            }
          }
        }

        char v36 = 0;
        int v35 = "EED2";
        uint64_t v33 = 1LL;
      }

      while ((v37 & 1) != 0);
      goto LABEL_54;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v58 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v59 = *(void *)a2;
      }
      uint64_t v60 = *(void *)(a4 + 4);
      uint64_t v61 = *(void *)(a4 + 12);
      uint64_t v62 = *(void *)(a4 + 20);
      uint64_t v63 = *(void *)(a4 + 28);
      uint64_t v64 = *(void *)(a4 + 36);
      uint64_t v65 = *(void *)(a4 + 44);
      uint64_t v66 = *(void *)(a4 + 60);
      int v67 = *(_DWORD *)(a4 + 96);
      *(_DWORD *)std::string buf = 136317187;
      *(void *)&uint8_t buf[4] = v59;
      __int16 v136 = 2049;
      uint64_t v137 = v60;
      __int16 v138 = 2049;
      uint64_t v139 = v61;
      __int16 v140 = 2050;
      uint64_t v141 = v62;
      __int16 v142 = 2049;
      uint64_t v143 = v63;
      __int16 v144 = 2050;
      uint64_t v145 = v64;
      __int16 v146 = 2049;
      uint64_t v147 = v65;
      __int16 v148 = 2049;
      uint64_t v149 = v66;
      __int16 v150 = 1026;
      int v151 = v67;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "#Actor rejected %s location fix as altitude is not usable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,a lt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d",  buf,  0x58u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      else {
        uint64_t v68 = *(void *)a2;
      }
      uint64_t v69 = *(void *)(a4 + 4);
      uint64_t v70 = *(void *)(a4 + 12);
      uint64_t v71 = *(void *)(a4 + 20);
      uint64_t v72 = *(void *)(a4 + 28);
      uint64_t v73 = *(void *)(a4 + 36);
      uint64_t v74 = *(void *)(a4 + 44);
      uint64_t v75 = *(void *)(a4 + 60);
      int v76 = *(_DWORD *)(a4 + 96);
      *(_DWORD *)__int128 v118 = 136317187;
      *(void *)&v118[4] = v68;
      __int16 v119 = 2049;
      uint64_t v120 = v69;
      __int16 v121 = 2049;
      uint64_t v122 = v70;
      __int16 v123 = 2050;
      uint64_t v124 = v71;
      __int16 v125 = 2049;
      uint64_t v126 = v72;
      __int16 v127 = 2050;
      uint64_t v128 = v73;
      __int16 v129 = 2049;
      uint64_t v130 = v74;
      __int16 v131 = 2049;
      uint64_t v132 = v75;
      __int16 v133 = 1026;
      int v134 = v76;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor rejected %s location fix as altitude is not usable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,a lt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d",  v118,  88);
      uint64_t v78 = (char *)v77;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::updateCachedLocation(const std::string &, const std::string &, const GNSS::DaemonLocation &, GNSS::DaemonLocation &, const CLLocationProvider_Type::Notification &)",  "%s\n",  v77);
LABEL_80:
      if (v78 != buf) {
        free(v78);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    __int128 v47 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v48 = *(void *)a2;
      }
      uint64_t v49 = *(void *)(a4 + 4);
      uint64_t v50 = *(void *)(a4 + 12);
      uint64_t v51 = *(void *)(a4 + 20);
      uint64_t v52 = *(void *)(a4 + 44);
      uint64_t v53 = *(void *)(a4 + 60);
      int v54 = *(_DWORD *)(a4 + 96);
      *(_DWORD *)std::string buf = 136316675;
      *(void *)&uint8_t buf[4] = v48;
      __int16 v136 = 2049;
      uint64_t v137 = v49;
      __int16 v138 = 2049;
      uint64_t v139 = v50;
      __int16 v140 = 2050;
      uint64_t v141 = v51;
      __int16 v142 = 2049;
      uint64_t v143 = v52;
      __int16 v144 = 2049;
      uint64_t v145 = v53;
      __int16 v146 = 1026;
      LODWORD(v147) = v54;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "#Actor rejected %s location fix as unusable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,speed,%{private }.1f,course,%{private}.1f,type,%{public}d",  buf,  0x44u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      else {
        uint64_t v79 = *(void *)a2;
      }
      uint64_t v80 = *(void *)(a4 + 4);
      uint64_t v81 = *(void *)(a4 + 12);
      uint64_t v82 = *(void *)(a4 + 20);
      uint64_t v83 = *(void *)(a4 + 44);
      uint64_t v84 = *(void *)(a4 + 60);
      int v85 = *(_DWORD *)(a4 + 96);
      *(_DWORD *)__int128 v118 = 136316675;
      *(void *)&v118[4] = v79;
      __int16 v119 = 2049;
      uint64_t v120 = v80;
      __int16 v121 = 2049;
      uint64_t v122 = v81;
      __int16 v123 = 2050;
      uint64_t v124 = v82;
      __int16 v125 = 2049;
      uint64_t v126 = v83;
      __int16 v127 = 2049;
      uint64_t v128 = v84;
      __int16 v129 = 1026;
      LODWORD(v130) = v85;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor rejected %s location fix as unusable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,speed,%{private }.1f,course,%{private}.1f,type,%{public}d",  v118,  68);
      uint64_t v78 = (char *)v86;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::updateCachedLocation(const std::string &, const std::string &, const GNSS::DaemonLocation &, GNSS::DaemonLocation &, const CLLocationProvider_Type::Notification &)",  "%s\n",  v86);
      goto LABEL_80;
    }
  }

void sub_100F9CD9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

BOOL sub_100F9CDCC(uint64_t *a1, uint64_t a2)
{
  if ((sub_100869780(a2) & 1) != 0)
  {
    double v4 = sub_100295384(a2, a2 + 160);
    if (fabs(v4) <= 20.0)
    {
      double v14 = *(double *)(a2 + 20);
      if (v14 > 165.0 || v14 <= 0.0)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        BOOL v18 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          else {
            uint64_t v19 = (uint64_t *)*a1;
          }
          double v20 = *(double *)(a2 + 20);
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v38 = v19;
          __int16 v39 = 2050;
          double v40 = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "#Actor %s fix is unusable due to horizontal accuracy,%{public}.2f",  buf,  0x16u);
        }

        BOOL result = sub_1002921D0(115, 2);
        if (result)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          else {
            __int128 v21 = (uint64_t *)*a1;
          }
          uint64_t v22 = *(void *)(a2 + 20);
          *(_DWORD *)int v35 = 136315394;
          *(void *)&_DWORD v35[4] = v21;
          *(_WORD *)&v35[12] = 2050;
          *(void *)&v35[14] = v22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s fix is unusable due to horizontal accuracy,%{public}.2f",  v35,  22,  *(_OWORD *)v35,  *(void *)&v35[16],  v36);
          goto LABEL_73;
        }
      }

      else
      {
        int v15 = *(_DWORD *)(a2 + 128);
        if (v15 == 50 || v15 == 75)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          __int128 v16 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            else {
              __int128 v17 = (uint64_t *)*a1;
            }
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v38 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "#Actor %s fix is usable", buf, 0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101890510);
            }
            else {
              int v32 = (uint64_t *)*a1;
            }
            *(_DWORD *)int v35 = 136315138;
            *(void *)&_DWORD v35[4] = v32;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s fix is usable",  v35);
            uint64_t v34 = (uint8_t *)v33;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLEmergencyActor::isLocationUsable(const std::string &, const GNSS::DaemonLocation &)",  "%s\n",  v33);
            if (v34 != buf) {
              free(v34);
            }
          }

          return 1LL;
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          char v23 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            else {
              uint64_t v24 = (uint64_t *)*a1;
            }
            int v25 = *(_DWORD *)(a2 + 128);
            *(_DWORD *)std::string buf = 136315394;
            uint64_t v38 = v24;
            __int16 v39 = 1026;
            LODWORD(v40) = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "#Actor %s fix is unusable due to low integrity,%{public}d",  buf,  0x12u);
          }

          BOOL result = sub_1002921D0(115, 2);
          if (result)
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101890510);
            }
            else {
              uint64_t v26 = (uint64_t *)*a1;
            }
            int v27 = *(_DWORD *)(a2 + 128);
            *(_DWORD *)int v35 = 136315394;
            *(void *)&_DWORD v35[4] = v26;
            *(_WORD *)&v35[12] = 1026;
            *(_DWORD *)&v35[14] = v27;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s fix is unusable due to low integrity,%{public}d",  v35,  18,  *(_OWORD *)v35,  *(void *)&v35[16],  v36);
            goto LABEL_73;
          }
        }
      }
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        else {
          BOOL v6 = (uint64_t *)*a1;
        }
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v38 = v6;
        __int16 v39 = 2050;
        double v40 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#Actor %s fix is unusable due to age,%{public}.3f",  buf,  0x16u);
      }

      BOOL result = sub_1002921D0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        else {
          uint64_t v8 = (uint64_t *)*a1;
        }
        *(_DWORD *)int v35 = 136315394;
        *(void *)&_DWORD v35[4] = v8;
        *(_WORD *)&v35[12] = 2050;
        *(double *)&v35[14] = v4;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s fix is unusable due to age,%{public}.3f",  v35,  22,  *(_OWORD *)v35,  *(void *)&v35[16],  v36);
LABEL_73:
        uint64_t v31 = (uint8_t *)v9;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLEmergencyActor::isLocationUsable(const std::string &, const GNSS::DaemonLocation &)",  "%s\n",  v9);
        if (v31 != buf) {
          free(v31);
        }
        return 0LL;
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    double v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      else {
        char v11 = (uint64_t *)*a1;
      }
      double v12 = *(double *)(a2 + 4);
      uint64_t v13 = *(void *)(a2 + 12);
      *(_DWORD *)std::string buf = 136315651;
      uint64_t v38 = v11;
      __int16 v39 = 2049;
      double v40 = v12;
      __int16 v41 = 2049;
      uint64_t v42 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#Actor %s fix is unusable due to invalid lat,%{private}.7f,lon,%{private}.7f",  buf,  0x20u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      else {
        uint64_t v28 = (uint64_t *)*a1;
      }
      uint64_t v29 = *(void *)(a2 + 4);
      uint64_t v30 = *(void *)(a2 + 12);
      *(_DWORD *)int v35 = 136315651;
      *(void *)&_DWORD v35[4] = v28;
      *(_WORD *)&v35[12] = 2049;
      *(void *)&v35[14] = v29;
      *(_WORD *)&v35[22] = 2049;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s fix is unusable due to invalid lat,%{private}.7f,lon,%{private}.7f",  v35,  32,  *(_OWORD *)v35,  *(void *)&v35[16],  v30);
      goto LABEL_73;
    }
  }

  return result;
}

BOOL sub_100F9D524(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  double v5 = *(double *)(a3 + 36);
  if (v5 > 0.0 && v5 <= 30.0)
  {
    double v14 = *(double *)(a3 + 28);
    if (v14 < -450.0 || v14 > 8850.0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      __int128 v17 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        else {
          BOOL v18 = (uint64_t *)*a2;
        }
        double v19 = *(double *)(a3 + 28);
        *(_DWORD *)std::string buf = 136315394;
        int v35 = v18;
        __int16 v36 = 2050;
        double v37 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "#Actor %s received altitude is not valid,%{public}.2f",  buf,  0x16u);
      }

      BOOL result = sub_1002921D0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        else {
          uint64_t v30 = (uint64_t *)*a2;
        }
        uint64_t v31 = *(void *)(a3 + 28);
        *(_DWORD *)uint64_t v33 = 136315394;
        *(void *)&v33[4] = v30;
        *(_WORD *)&v33[12] = 2050;
        *(void *)&v33[14] = v31;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s received altitude is not valid,%{public}.2f",  v33,  22,  *(_OWORD *)v33,  *(void *)&v33[16]);
        goto LABEL_79;
      }
    }

    else if ((*(_DWORD *)(a3 + 472) + 1) > 1)
    {
      double v20 = sub_100295384(a3, a3 + 160);
      if (fabs(v20) <= 20.0)
      {
        int v24 = *(_DWORD *)(a3 + 128);
        BOOL result = 1LL;
        if (v24 != 50 && v24 != 75)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          int v25 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            else {
              uint64_t v26 = (uint64_t *)*a2;
            }
            int v27 = *(_DWORD *)(a3 + 128);
            *(_DWORD *)std::string buf = 136315394;
            int v35 = v26;
            __int16 v36 = 1026;
            LODWORD(v37) = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "#Actor %s altitude is unusable due to low integrity,%{public}d",  buf,  0x12u);
          }

          BOOL result = sub_1002921D0(115, 2);
          if (result)
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101890510);
            }
            else {
              uint64_t v28 = (uint64_t *)*a2;
            }
            int v29 = *(_DWORD *)(a3 + 128);
            *(_DWORD *)uint64_t v33 = 136315394;
            *(void *)&v33[4] = v28;
            *(_WORD *)&v33[12] = 1026;
            *(_DWORD *)&v33[14] = v29;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s altitude is unusable due to low integrity,%{public}d",  v33,  18,  *(_OWORD *)v33,  *(void *)&v33[16]);
            goto LABEL_79;
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        __int128 v21 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          else {
            uint64_t v22 = (uint64_t *)*a2;
          }
          *(_DWORD *)std::string buf = 136315394;
          int v35 = v22;
          __int16 v36 = 2050;
          double v37 = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "#Actor %s altitude is unusable due to age,%{public}.3f",  buf,  0x16u);
        }

        BOOL result = sub_1002921D0(115, 2);
        if (result)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101890510);
          }
          else {
            char v23 = (uint64_t *)*a2;
          }
          *(_DWORD *)uint64_t v33 = 136315394;
          *(void *)&v33[4] = v23;
          *(_WORD *)&v33[12] = 2050;
          *(double *)&v33[14] = v20;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s altitude is unusable due to age,%{public}.3f",  v33,  22,  *(_OWORD *)v33,  *(void *)&v33[16]);
          goto LABEL_79;
        }
      }
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v15 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        else {
          __int128 v16 = (uint64_t *)*a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        int v35 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "#Actor %s altitude undulation model is not valid",  buf,  0xCu);
      }

      BOOL result = sub_1002921D0(115, 2);
      if (result)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s altitude undulation model is not valid",  v33);
        goto LABEL_79;
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    int v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      else {
        uint64_t v8 = (uint64_t *)*a2;
      }
      double v9 = *(double *)(a3 + 36);
      *(_DWORD *)std::string buf = 136315394;
      int v35 = v8;
      __int16 v36 = 2050;
      double v37 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#Actor %s received altitude accuracy is not valid,%{public}.2f",  buf,  0x16u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      else {
        char v11 = (uint64_t *)*a2;
      }
      uint64_t v12 = *(void *)(a3 + 36);
      *(_DWORD *)uint64_t v33 = 136315394;
      *(void *)&v33[4] = v11;
      *(_WORD *)&v33[12] = 2050;
      *(void *)&v33[14] = v12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor %s received altitude accuracy is not valid,%{public}.2f",  v33,  22,  *(_OWORD *)v33,  *(void *)&v33[16]);
LABEL_79:
      int v32 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyActor::isAltitudeUsable(const std::string &, const GNSS::DaemonLocation &)",  "%s\n",  v13);
      if (v32 != buf) {
        free(v32);
      }
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100F9DC24()
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  unsigned __int8 v0 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEBUG,  "#Actor new fix is preferred over cached by default",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    v4[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor new fix is preferred over cached by default",  v4,  2);
    uint64_t v3 = (uint8_t *)v2;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyActor::isCachedLocationBetter(const GNSS::DaemonLocation &)",  "%s\n",  v2);
    if (v3 != buf) {
      free(v3);
    }
  }

  return 0LL;
}

void sub_100F9DDAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  double v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a4 + 4);
    uint64_t v7 = *(void *)(a4 + 12);
    uint64_t v8 = *(void *)(a4 + 20);
    int v9 = *(_DWORD *)(a4 + 84);
    *(_DWORD *)std::string buf = 134284289;
    uint64_t v25 = v6;
    __int16 v26 = 2049;
    uint64_t v27 = v7;
    __int16 v28 = 2049;
    uint64_t v29 = v8;
    __int16 v30 = 1025;
    int v31 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#Actor, WiFi location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f,conf,%{private}d",  buf,  0x26u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v10 = *(void *)(a4 + 4);
    uint64_t v11 = *(void *)(a4 + 12);
    uint64_t v12 = *(void *)(a4 + 20);
    int v13 = *(_DWORD *)(a4 + 84);
    int v16 = 134284289;
    uint64_t v17 = v10;
    __int16 v18 = 2049;
    uint64_t v19 = v11;
    __int16 v20 = 2049;
    uint64_t v21 = v12;
    __int16 v22 = 1025;
    int v23 = v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor, WiFi location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f,conf,%{private}d",  &v16,  38);
    int v15 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::onWifiLocationProviderNotification(int, const CLLocationProvider_Type::Notification &, cons t CLLocationProvider_Type::NotificationData &)",  "%s\n",  v14);
    if (v15 != buf) {
      free(v15);
    }
  }

void sub_100F9DFB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  double v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a4 + 4);
    uint64_t v7 = *(void *)(a4 + 12);
    uint64_t v8 = *(void *)(a4 + 20);
    *(_DWORD *)std::string buf = 134284033;
    uint64_t v21 = v6;
    __int16 v22 = 2049;
    uint64_t v23 = v7;
    __int16 v24 = 2049;
    uint64_t v25 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#Actor, Cell location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v9 = *(void *)(a4 + 4);
    uint64_t v10 = *(void *)(a4 + 12);
    uint64_t v11 = *(void *)(a4 + 20);
    int v14 = 134284033;
    uint64_t v15 = v9;
    __int16 v16 = 2049;
    uint64_t v17 = v10;
    __int16 v18 = 2049;
    uint64_t v19 = v11;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Actor, Cell location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f",  &v14,  32);
    int v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyActor::onCellLocationProviderNotification(int, const CLLocationProvider_Type::Notification &, cons t CLLocationProvider_Type::NotificationData &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

uint64_t sub_100F9E19C(uint64_t a1, uint64_t a2, int a3, void *a4, uint64_t a5, void *a6, uint64_t a7)
{
  *(void *)a1 = off_101890468;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  sub_10001A504(a1 + 32, a5);
  *(void *)(a1 + 64) = *a6;
  uint64_t v11 = a6[1];
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = v11;
  if (v11)
  {
    uint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  sub_10001A504(a1 + 80, a7);
  *(_DWORD *)(a1 + 112) = 255;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(_BYTE *)(a1 + 184) = 0;
  sub_100F9F1F0(a1 + 192);
  *(void *)(a1 + 1432) = 0LL;
  *(_DWORD *)(a1 + 1440) = 0;
  sub_1002F0B04(&__p);
  if (sub_1002A6F64((uint64_t)__p, "ActorSessionForNonActiveEmergencies", (BOOL *)(a1 + 160)))
  {
    int v14 = *(unsigned __int8 *)(a1 + 160);
    uint64_t v15 = v37;
    if (!v37) {
      goto LABEL_9;
    }
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
      if (!v14) {
        return a1;
      }
    }

    else
    {
LABEL_9:
      if (!v14) {
        return a1;
      }
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    __int16 v18 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(int *)(a1 + 16);
      __int16 v20 = v19 > 2 ? "UnknownAction" : (&off_101890670)[v19];
      sub_1010DDBC0(&__p, v20);
      __int16 v24 = v38 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#Warning #%{public}s allowing session for non-active emergencies",  buf,  0xCu);
      if (v38 < 0) {
        operator delete(__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v26 = *(int *)(a1 + 16);
      else {
        uint64_t v27 = (&off_101890670)[v26];
      }
      uint64_t v28 = qword_101934898;
      sub_1010DDBC0(buf, v27);
      if (v33 >= 0) {
        uint64_t v29 = buf;
      }
      else {
        uint64_t v29 = *(_BYTE **)buf;
      }
      int v34 = 136446210;
      int v35 = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v28,  0LL,  "#Warning #%{public}s allowing session for non-active emergencies",  &v34,  12);
      int v31 = v30;
      if (v33 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAction::CLEmergencyAction(id<CLIntersiloUniverse>, Action, id<CLClientManagerPublicProtocol>, Network AndSimInfoCallback, std::shared_ptr<CLEmergencyAWD>, LocationCallback)",  "%s\n",  v31);
    }
  }

  else
  {
    uint64_t v21 = v37;
    if (v37)
    {
      __int16 v22 = (unint64_t *)&v37->__shared_owners_;
      do
        unint64_t v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }

  return a1;
}

void sub_100F9E54C(_Unwind_Exception *a1)
{
  uint64_t v7 = *(void **)(v1 + 104);
  if (v7 == v4)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v4;
  }

  else
  {
    if (!v7) {
      goto LABEL_8;
    }
    uint64_t v8 = 5LL;
  }

  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_8:
  sub_10000AE14(v3);
  uint64_t v9 = *(void **)(v1 + 56);
  if (v9 == v2)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v2;
  }

  else
  {
    if (!v9) {
      goto LABEL_13;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_13:
  _Unwind_Resume(a1);
}

uint64_t sub_100F9E600(uint64_t a1)
{
  return a1;
}

uint64_t sub_100F9E660(uint64_t a1)
{
  *(void *)a1 = off_101890468;

  *(void *)(a1 + 24) = 0LL;
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2 == (void *)(a1 + 80))
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = (void *)(a1 + 80);
  }

  else
  {
    if (!v2) {
      goto LABEL_16;
    }
    uint64_t v3 = 5LL;
  }

  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_16:
  sub_10000AE14(a1 + 64);
  double v4 = *(void **)(a1 + 56);
  if (v4 == (void *)(a1 + 32))
  {
    uint64_t v5 = 4LL;
    double v4 = (void *)(a1 + 32);
    goto LABEL_20;
  }

  if (v4)
  {
    uint64_t v5 = 5LL;
LABEL_20:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  return a1;
}

std::string *sub_100F9E75C(uint64_t a1, const std::string *a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101890510);
  }
  double v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a1 + 16);
    uint64_t v6 = v5 > 2 ? "UnknownAction" : (&off_101890670)[v5];
    sub_1010DDBC0(__p, v6);
    uint64_t v7 = v26 >= 0 ? __p : (void **)__p[0];
    uint64_t v8 = (a2->__r_.__value_.__s.__size_ & 0x80u) == 0 ? a2 : (const std::string *)a2->__r_.__value_.__r.__words[0];
    *(_DWORD *)std::string buf = 136446467;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v18 = 2081;
    uint64_t v19 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#%{public}s companion phone number changed to %{private}s",  buf,  0x16u);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v10 = *(int *)(a1 + 16);
    else {
      uint64_t v11 = (&off_101890670)[v10];
    }
    uint64_t v12 = qword_101934898;
    sub_1010DDBC0(buf, v11);
    if (v20 >= 0) {
      unint64_t v13 = buf;
    }
    else {
      unint64_t v13 = *(_BYTE **)buf;
    }
    if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v14 = a2;
    }
    else {
      int v14 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v21 = 136446467;
    __int16 v22 = v13;
    __int16 v23 = 2081;
    __int16 v24 = v14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v12,  0LL,  "#%{public}s companion phone number changed to %{private}s",  &v21,  22);
    __int16 v16 = v15;
    if (v20 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyAction::handleCompanionNumberChange(const std::string &)",  "%s\n",  v16);
  }

  return std::string::operator=((std::string *)(a1 + 136), a2);
}

void sub_100F9E9FC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 184) == (_DWORD)a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    double v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(int *)(a1 + 16);
      else {
        uint64_t v6 = (&off_101890670)[v5];
      }
      sub_1010DDBC0(__p, v6);
      uint64_t v10 = (void **)__p[0];
      uint64_t v11 = "disabled";
      if (v37 >= 0) {
        uint64_t v10 = __p;
      }
      if ((_DWORD)a2) {
        uint64_t v11 = "enabled";
      }
      *(_DWORD *)std::string buf = 136446466;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v29 = 2082;
      __int16 v30 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#%{public}s session assertion is already %{public}s,ignoring",  buf,  0x16u);
      if (v37 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v12 = *(int *)(a1 + 16);
      else {
        unint64_t v13 = (&off_101890670)[v12];
      }
      uint64_t v18 = qword_101934898;
      sub_1010DDBC0(buf, v13);
      uint64_t v19 = *(_BYTE **)buf;
      char v20 = "disabled";
      if (v31 >= 0) {
        uint64_t v19 = buf;
      }
      if ((_DWORD)a2) {
        char v20 = "enabled";
      }
      int v32 = 136446466;
      char v33 = v19;
      __int16 v34 = 2082;
      int v35 = v20;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v18,  0LL,  "#%{public}s session assertion is already %{public}s,ignoring",  &v32,  22);
      __int16 v22 = v21;
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAction::assertSession(BOOL)", "%s\n", v22);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    uint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(int *)(a1 + 16);
      else {
        uint64_t v9 = (&off_101890670)[v8];
      }
      sub_1010DDBC0(__p, v9);
      int v14 = (void **)__p[0];
      uint64_t v15 = "disabled";
      if (v37 >= 0) {
        int v14 = __p;
      }
      if ((_DWORD)a2) {
        uint64_t v15 = "enabled";
      }
      *(_DWORD *)std::string buf = 136446466;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#%{public}s session assertion %{public}s",  buf,  0x16u);
      if (v37 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      uint64_t v16 = *(int *)(a1 + 16);
      else {
        unint64_t v17 = (&off_101890670)[v16];
      }
      uint64_t v23 = qword_101934898;
      sub_1010DDBC0(buf, v17);
      __int16 v24 = *(_BYTE **)buf;
      uint64_t v25 = "disabled";
      if (v31 >= 0) {
        __int16 v24 = buf;
      }
      if ((_DWORD)a2) {
        uint64_t v25 = "enabled";
      }
      int v32 = 136446466;
      char v33 = v24;
      __int16 v34 = 2082;
      int v35 = v25;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v23,  0LL,  "#%{public}s session assertion %{public}s",  &v32,  22);
      uint64_t v27 = v26;
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAction::assertSession(BOOL)", "%s\n", v27);
    }

    *(_BYTE *)(a1 + 184) = a2;
    [*(id *)(a1 + 24) markClientEmergencyEnablementTransition:a2];
  }

uint64_t sub_100F9EEE8(uint64_t a1)
{
  *(_DWORD *)(a1 + 384) = sub_100496E10((unsigned int *)(a1 + 112));
  *(_BYTE *)(a1 + 1132) = sub_1009830E8(a1 + 112);
  *(_DWORD *)(a1 + 112_Block_object_dispose((const void *)(v1 - 128), 8) = *(_DWORD *)(a1 + 132);
  *(void *)(a1 + 200) = *(void *)(a1 + 168);
  *(_BYTE *)(a1 + 344) = 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
}

BOOL sub_100F9EF4C(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  BOOL result = sub_1009830C8(a1 + 112);
  if (!result)
  {
    *(_DWORD *)(a1 + 132) = 0;
    return result;
  }

  BOOL result = sub_1009830A8(v2);
  if (result)
  {
    int v4 = 1;
  }

  else
  {
    BOOL result = sub_1009830B8(v2);
    if (!result)
    {
      int v4 = *(_DWORD *)(a1 + 132);
      goto LABEL_9;
    }

    int v4 = 2;
  }

  *(_DWORD *)(a1 + 132) = v4;
LABEL_9:
  *(_DWORD *)(a1 + 112_Block_object_dispose((const void *)(v1 - 128), 8) = v4;
  return result;
}

double sub_100F9EFB4(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 232) = sub_100869780(a2);
  if (sub_100869780(a2))
  {
    if (*(double *)(a1 + 208) == -1.0)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      *(CFAbsoluteTime *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = Current;
      *(CFAbsoluteTime *)(a1 + 264) = Current - *(double *)(a1 + 200);
    }

    *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 4);
    if (sub_100F99260(a2))
    {
      double result = *(double *)(a2 + 28) + *(float *)(a2 + 476);
      *(double *)(a1 + 240) = result;
    }
  }

  return result;
}

uint64_t sub_100F9F038(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0LL) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  BOOL v4 = v3 != 0;
  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0LL) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  return sub_1011BA0AC(a1 + 192, v4, v5 != 0);
}

uint64_t sub_100F9F078(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 144LL))(a1, *a2);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, a3);
  unsigned int v8 = *a2;
  *a2 = v8;
  return result;
}

void sub_100F9F0DC(uint64_t a1)
{
  if (*(double *)(a1 + 1432) != 0.0)
  {
    *(_DWORD *)(a1 + 12sub_1011C52D0(v23 - 72) = (sub_101171D4C() - *(double *)(a1 + 1432));
    *(void *)(a1 + 1432) = 0LL;
  }

  uint64_t v2 = a1 + 192;
  sub_1011B93D0(v2);
  sub_1011B9E04(v2);
}

void sub_100F9F12C(uint64_t a1, int a2, int a3)
{
  unsigned int v4 = a3 - 2;
  if ((a2 - 2) >= 4)
  {
    if (v4 <= 3) {
      *(double *)(a1 + 1432) = sub_101171D4C();
    }
  }

  else if (v4 >= 4 && *(double *)(a1 + 1432) != 0.0)
  {
    *(_DWORD *)(a1 + 12sub_1011C52D0(v23 - 72) = (sub_101171D4C() - *(double *)(a1 + 1432));
    *(void *)(a1 + 1432) = 0LL;
  }

void sub_100F9F198(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

void sub_100F9F1C4(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100F9F1F0(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = _Q0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_BYTE *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_1012EA5D0;
  *(_OWORD *)(a1 + 64) = _Q0;
  *(_OWORD *)(a1 + sub_100F6A7D8(v1 + 80) = 0u;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 100) = -1LL;
  *(void *)(a1 + 10_Block_object_dispose((const void *)(v1 - 128), 8) = -1LL;
  *(_OWORD *)(a1 + 120) = _Q0;
  *(_DWORD *)(a1 + 136) = 0;
  __asm { FMOV            V1.2S, #-1.0 }

  *(void *)(a1 + 140) = _D1;
  *(_DWORD *)(a1 + 14_Block_object_dispose((const void *)(v1 - 128), 8) = 26;
  *(_WORD *)(a1 + 152) = 0;
  *(void *)(a1 + 156) = 0xFFFFFFFF00000000LL;
  *(void *)(a1 + 18_Block_object_dispose((const void *)(v1 - 128), 8) = 4LL;
  *(void *)(a1 + 200) = -1LL;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 128), 8) = _Q0;
  *(_OWORD *)(a1 + 384) = xmmword_101339690;
  *(_OWORD *)(a1 + 400) = xmmword_1013396A0;
  *(_OWORD *)(a1 + 416) = xmmword_1013396B0;
  *(_OWORD *)(a1 + 42_Block_object_dispose((const void *)(v1 - 128), 8) = *(__int128 *)((char *)&xmmword_1013396B0 + 12);
  *(_OWORD *)(a1 + 320) = xmmword_101339650;
  *(_OWORD *)(a1 + 336) = xmmword_101339660;
  *(_OWORD *)(a1 + 352) = xmmword_101339670;
  *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_101339680;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_101339630;
  *(_OWORD *)(a1 + 304) = xmmword_101339640;
  *(_OWORD *)(a1 + 540) = xmmword_101339690;
  *(_OWORD *)(a1 + 556) = xmmword_1013396A0;
  *(_OWORD *)(a1 + 5sub_1011C52D0(v23 - 72) = xmmword_1013396B0;
  *(_OWORD *)(a1 + 476) = xmmword_101339650;
  *(_OWORD *)(a1 + 492) = xmmword_101339660;
  *(_OWORD *)(a1 + 50_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_101339670;
  *(_OWORD *)(a1 + 524) = xmmword_101339680;
  *(_OWORD *)(a1 + 444) = xmmword_101339630;
  *(_OWORD *)(a1 + 460) = xmmword_101339640;
  *(_OWORD *)(a1 + 712) = xmmword_1013396A0;
  *(_OWORD *)(a1 + 72_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_1013396B0;
  *(_OWORD *)(a1 + 740) = *(__int128 *)((char *)&xmmword_1013396B0 + 12);
  *(_OWORD *)(a1 + 64_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_101339660;
  *(_OWORD *)(a1 + 664) = xmmword_101339670;
  *(_OWORD *)(a1 + 6sub_100F6A7D8(v1 + 80) = xmmword_101339680;
  *(_OWORD *)(a1 + 696) = xmmword_101339690;
  *(_OWORD *)(a1 + 584) = *(__int128 *)((char *)&xmmword_1013396B0 + 12);
  *(_OWORD *)(a1 + 600) = xmmword_101339630;
  *(_OWORD *)(a1 + 616) = xmmword_101339640;
  *(_OWORD *)(a1 + 632) = xmmword_101339650;
  *(_OWORD *)(a1 + 852) = xmmword_101339690;
  *(_OWORD *)(a1 + 86_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_1013396A0;
  *(_OWORD *)(a1 + 884) = xmmword_1013396B0;
  *(_OWORD *)(a1 + 78_Block_object_dispose((const void *)(v1 - 128), 8) = xmmword_101339650;
  *(_OWORD *)(a1 + 804) = xmmword_101339660;
  *(_DWORD *)(a1 + 164) = -1;
  *(_WORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_BYTE *)(a1 + 170) = 0;
  *(void *)(a1 + 176) = -1LL;
  *(_BYTE *)(a1 + 184) = 0;
  *(_WORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_BYTE *)(a1 + 212) = 0;
  *(void *)(a1 + 23_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 264) = 0xBFF0000000000000LL;
  *(void *)(a1 + 2sub_1011C52D0(v23 - 72) = 0xBFF0000000000000LL;
  *(void *)(a1 + 2sub_100F6A7D8(v1 + 80) = 0LL;
  *(_OWORD *)(a1 + 820) = xmmword_101339670;
  *(_OWORD *)(a1 + 836) = xmmword_101339680;
  *(_OWORD *)(a1 + 756) = xmmword_101339630;
  *(_OWORD *)(a1 + 7sub_1011C52D0(v23 - 72) = xmmword_101339640;
  *(void *)(a1 + 933) = 0LL;
  *(void *)(a1 + 92_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(_OWORD *)(a1 + 896) = *(__int128 *)((char *)&xmmword_1013396B0 + 12);
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 944) = xmmword_101339620;
  sub_1010DDBC0((void *)(a1 + 960), "");
  sub_1010DDBC0((void *)(a1 + 984), "");
  *(_DWORD *)(a1 + 1016) = 0;
  *(void *)(a1 + 100_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(void *)(a1 + 1040) = 0xBFF0000000000000LL;
  *(void *)&__int128 v8 = -1LL;
  *((void *)&v8 + 1) = -1LL;
  *(void *)(a1 + 104_Block_object_dispose((const void *)(v1 - 128), 8) = -1LL;
  *(_DWORD *)(a1 + 1056) = -1;
  *(void *)(a1 + 1060) = 0LL;
  *(void *)(a1 + 1065) = 0LL;
  *(_DWORD *)(a1 + 1076) = -1;
  *(void *)(a1 + 10sub_100F6A7D8(v1 + 80) = 0LL;
  *(_DWORD *)(a1 + 1087) = 0;
  *(_OWORD *)(a1 + 1092) = 0u;
  *(_OWORD *)(a1 + 110_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 1124) = 0u;
  *(void *)(a1 + 1140) = 0LL;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 116_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(void *)(a1 + 1232) = -1LL;
  *(_OWORD *)(a1 + 1216) = v8;
  *(_OWORD *)(a1 + 1200) = v8;
  return a1;
}

void sub_100F9F460(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F9F47C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100F9F4B4(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_100F9F4F0((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void sub_100F9F4F0(uint64_t a1)
{
}

uint64_t *sub_100F9F564(uint64_t a1, int *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (unint64_t i = *v9; i; unint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v6) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = a1 + 16;
  unint64_t v13 = (char *)operator new(0xC0uLL);
  v24[0] = v13;
  v24[1] = a1 + 16;
  *(void *)unint64_t v13 = 0LL;
  *((void *)v13 + 1) = v6;
  *((_DWORD *)v13 + 4) = *(_DWORD *)a3;
  *(_OWORD *)(v13 + 24) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v13 + 40) = *(_OWORD *)(a3 + 24);
  *((void *)v13 + 7) = *(void *)(a3 + 40);
  *((_OWORD *)v13 + 4) = *(_OWORD *)(a3 + 48);
  *((void *)v13 + 10) = *(void *)(a3 + 64);
  *(void *)(a3 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(v13 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a3 + 72);
  *((void *)v13 + 13) = *(void *)(a3 + 88);
  *(void *)(a3 + 64) = 0LL;
  *(void *)(a3 + sub_1011C52D0(v23 - 72) = 0LL;
  *(void *)(a3 + sub_100F6A7D8(v1 + 80) = 0LL;
  *(void *)(a3 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *((_OWORD *)v13 + 7) = *(_OWORD *)(a3 + 96);
  *((void *)v13 + 16) = *(void *)(a3 + 112);
  *(void *)(a3 + 96) = 0LL;
  *(void *)(a3 + 104) = 0LL;
  *((void *)v13 + 19) = *(void *)(a3 + 136);
  *(_OWORD *)(v13 + 136) = *(_OWORD *)(a3 + 120);
  *(void *)(a3 + 112) = 0LL;
  *(void *)(a3 + 120) = 0LL;
  *(void *)(a3 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a3 + 136) = 0LL;
  __int128 v14 = *(_OWORD *)(a3 + 144);
  *((void *)v13 + 22) = *(void *)(a3 + 160);
  *((_OWORD *)v13 + 10) = v14;
  *(void *)(a3 + 144) = 0LL;
  *(void *)(a3 + 152) = 0LL;
  *(void *)(a3 + 160) = 0LL;
  *((_DWORD *)v13 + 46) = *(_DWORD *)(a3 + 168);
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    BOOL v17 = v7 < 3 || (v7 & (v7 - 1)) != 0;
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100019E10(a1, v20);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  int v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *int v21 = v24[0];
  }

  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v3) = v12;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8LL);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v22 >= v7) {
          v22 %= v7;
        }
      }

      else
      {
        v22 &= v7 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }

  unint64_t i = (uint64_t *)v24[0];
  v24[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_100F9F84C((uint64_t)v24, 0LL);
  return i;
}

void sub_100F9F834(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100F9F84C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100F9F4F0((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

uint64_t *sub_100F9F890(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (unint64_t i = *v10; i; unint64_t i = (uint64_t *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v13 = a1 + 16;
  __int128 v14 = (char *)operator new(0xC0uLL);
  v25[0] = v14;
  v25[1] = a1 + 16;
  *(void *)__int128 v14 = 0LL;
  *((void *)v14 + 1) = v7;
  *((_DWORD *)v14 + 4) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(v14 + 152) = 0u;
  *(_OWORD *)(v14 + 136) = 0u;
  *(_OWORD *)(v14 + 120) = 0u;
  *(_OWORD *)(v14 + 104) = 0u;
  *(_OWORD *)(v14 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(v14 + sub_1011C52D0(v23 - 72) = 0u;
  *((_DWORD *)v14 + 6) = 11;
  *(void *)&__int128 v15 = -1LL;
  *((void *)&v15 + 1) = -1LL;
  *((_OWORD *)v14 + 2) = v15;
  *((_OWORD *)v14 + 3) = v15;
  *((void *)v14 + 22) = 0LL;
  *((void *)v14 + 23) = 0LL;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_DWORD *)v14 + 46) = -1;
  char v26 = 1;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v8 || (float)(v17 * (float)v8) < v16)
  {
    BOOL v18 = 1LL;
    if (v8 >= 3) {
      BOOL v18 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v8);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *unint64_t v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v23 >= v8) {
          v23 %= v8;
        }
      }

      else
      {
        v23 &= v8 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  unint64_t i = (uint64_t *)v25[0];
  v25[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_100F9F84C((uint64_t)v25, 0LL);
  return i;
}

void sub_100F9FB28(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100F9FB48(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101890560;
  result[1] = v3;
  return result;
}

uint64_t sub_100F9FB7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101890560;
  a2[1] = v2;
  return result;
}

uint64_t *sub_100F9FB98(uint64_t a1, int *a2)
{
  int v4 = *a2;
  uint64_t v2 = *(void *)(a1 + 8) + 1728LL;
  uint64_t v5 = &v4;
  return sub_100F9F890(v2, &v4, (uint64_t)&unk_1012CF090, &v5) + 3;
}

uint64_t sub_100F9FBE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100F9FC20()
{
}

void *sub_100F9FC34(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1018905F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F9FC68(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1018905F0;
  a2[1] = v2;
  return result;
}

void sub_100F9FC84(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  __int128 v4 = *(_OWORD *)(v3 + 80);
  *(_OWORD *)a2 = *(_OWORD *)(v3 + 64);
  *(_OWORD *)(a2 + 16) = v4;
  __int128 v5 = *(_OWORD *)(v3 + 144);
  __int128 v7 = *(_OWORD *)(v3 + 96);
  __int128 v6 = *(_OWORD *)(v3 + 112);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v3 + 128);
  *(_OWORD *)(a2 + sub_100F6A7D8(v1 + 80) = v5;
  *(_OWORD *)(a2 + 32) = v7;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v6;
  __int128 v9 = *(_OWORD *)(v3 + 176);
  __int128 v8 = *(_OWORD *)(v3 + 192);
  __int128 v10 = *(_OWORD *)(v3 + 160);
  *(_OWORD *)(a2 + 140) = *(_OWORD *)(v3 + 204);
  *(_OWORD *)(a2 + 112) = v9;
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
  *(_OWORD *)(a2 + 96) = v10;
  memcpy((void *)(a2 + 160), (const void *)(v3 + 224), 0x201uLL);
  *(void *)(a2 + 6sub_100F6A7D8(v1 + 80) = *(void *)(v3 + 744);
  uint64_t v11 = *(void *)(v3 + 752);
  *(void *)(a2 + 68_Block_object_dispose((const void *)(v1 - 128), 8) = v11;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  __int128 v14 = *(_OWORD *)(v3 + 760);
  __int128 v15 = *(_OWORD *)(v3 + 792);
  *(_OWORD *)(a2 + 712) = *(_OWORD *)(v3 + 776);
  *(_OWORD *)(a2 + 72_Block_object_dispose((const void *)(v1 - 128), 8) = v15;
  *(_OWORD *)(a2 + 696) = v14;
  __int128 v16 = *(_OWORD *)(v3 + 808);
  __int128 v17 = *(_OWORD *)(v3 + 824);
  __int128 v18 = *(_OWORD *)(v3 + 840);
  *(void *)(a2 + 789) = *(void *)(v3 + 853);
  *(_OWORD *)(a2 + 760) = v17;
  *(_OWORD *)(a2 + 776) = v18;
  *(_OWORD *)(a2 + 744) = v16;
  if (sub_100F9CDCC(qword_10199F8F0, v3 + 64))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v19 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#Actor,LocationCallback,returning cached fix",  buf,  2u);
    }

    uint64_t v20 = sub_1002921D0(115, 2);
    if ((_DWORD)v20)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v46[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor,LocationCallback,returning cached fix",  v46,  2);
      double v40 = (uint8_t *)v39;
      uint64_t v20 = sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLEmergencyActor::CLEmergencyActor(id<CLIntersiloUniverse>, CLEmergencyController::SendNilrLockoutCal lback)::(anonymous class)::operator()() const",  "%s\n",  v39);
      if (v40 != buf) {
        free(v40);
      }
    }

    BOOL v21 = sub_100F9D524(v20, qword_10199F8F0, v3 + 64);
    if (!v21 && sub_100F9D524(v21, qword_10199F908, v3 + 864))
    {
      *(_OWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(v3 + 892);
      *(_DWORD *)(a2 + 4sub_1011C52D0(v23 - 72) = *(_DWORD *)(v3 + 1336);
      *(_DWORD *)(a2 + 476) = *(_DWORD *)(v3 + 1340);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101890510);
    }
    unint64_t v22 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#Warning #Actor,LocationCallback,cached fix is not usable",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      v46[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #Actor,LocationCallback,cached fix is not usable",  v46,  2);
      uint64_t v42 = (uint8_t *)v41;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLEmergencyActor::CLEmergencyActor(id<CLIntersiloUniverse>, CLEmergencyController::SendNilrLockoutCallback) ::(anonymous class)::operator()() const",  "%s\n",  v41);
      if (v42 != buf) {
        free(v42);
      }
    }

    sub_100E51908(v3 + 64);
    __int128 v23 = *(_OWORD *)(v3 + 880);
    *(_OWORD *)a2 = *(_OWORD *)(v3 + 864);
    *(_OWORD *)(a2 + 16) = v23;
    __int128 v24 = *(_OWORD *)(v3 + 896);
    __int128 v25 = *(_OWORD *)(v3 + 912);
    __int128 v26 = *(_OWORD *)(v3 + 944);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(v3 + 928);
    *(_OWORD *)(a2 + sub_100F6A7D8(v1 + 80) = v26;
    *(_OWORD *)(a2 + 32) = v24;
    *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v25;
    __int128 v27 = *(_OWORD *)(v3 + 960);
    __int128 v28 = *(_OWORD *)(v3 + 976);
    __int128 v29 = *(_OWORD *)(v3 + 992);
    *(_OWORD *)(a2 + 140) = *(_OWORD *)(v3 + 1004);
    *(_OWORD *)(a2 + 112) = v28;
    *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = v29;
    *(_OWORD *)(a2 + 96) = v27;
    memcpy((void *)(a2 + 160), (const void *)(v3 + 1024), 0x201uLL);
    sub_1000F2F30((void *)(a2 + 680), (uint64_t *)(v3 + 1544));
    __int128 v31 = *(_OWORD *)(v3 + 1576);
    __int128 v30 = *(_OWORD *)(v3 + 1592);
    *(_OWORD *)(a2 + 696) = *(_OWORD *)(v3 + 1560);
    *(_OWORD *)(a2 + 712) = v31;
    *(_OWORD *)(a2 + 72_Block_object_dispose((const void *)(v1 - 128), 8) = v30;
    __int128 v33 = *(_OWORD *)(v3 + 1624);
    __int128 v32 = *(_OWORD *)(v3 + 1640);
    __int128 v34 = *(_OWORD *)(v3 + 1608);
    *(void *)(a2 + 789) = *(void *)(v3 + 1653);
    *(_OWORD *)(a2 + 760) = v33;
    *(_OWORD *)(a2 + 776) = v32;
    *(_OWORD *)(a2 + 744) = v34;
    if (sub_100F9CDCC(qword_10199F908, v3 + 864))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      int v35 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "#Actor,LocationCallback,returning cached prefiltered fix",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v46[0] = 0;
        LODWORD(v45) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Actor,LocationCallback,returning cached prefiltered fix",  v46,  v45);
        char v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLEmergencyActor::CLEmergencyActor(id<CLIntersiloUniverse>, CLEmergencyController::SendNilrLockoutCallbac k)::(anonymous class)::operator()() const",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101890510);
      }
      char v38 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "#Warning #Actor,LocationCallback,cached prefiltered fix is not usable",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101890510);
        }
        v46[0] = 0;
        LODWORD(v45) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #Actor,LocationCallback,cached prefiltered fix is not usable",  v46,  v45);
        __int128 v44 = (uint8_t *)v43;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLEmergencyActor::CLEmergencyActor(id<CLIntersiloUniverse>, CLEmergencyController::SendNilrLockoutCallbac k)::(anonymous class)::operator()() const",  "%s\n",  v43);
        if (v44 != buf) {
          free(v44);
        }
      }

      sub_100E51908(v3 + 864);
      sub_100E51908(a2);
    }
  }

void sub_100FA033C(_Unwind_Exception *a1)
{
}

uint64_t sub_100FA0360(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100FA039C()
{
}

void sub_100FA03A8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1013BB310;
      v1[3] = unk_1013BB320;
      v1[4] = xmmword_1013BB330;
      v1[0] = xmmword_1013BB2F0;
      v1[1] = unk_1013BB300;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100FA047C(_Unwind_Exception *a1)
{
}

uint64_t sub_100FA0494()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199F908, (void *)&_mh_execute_header);
}

void sub_100FA0674( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100FA0970(id a1)
{
  qword_101934908 = (uint64_t)os_log_create("com.apple.locationd.Position", "TrackingAvoidance");
}

void sub_100FA0A40(id a1)
{
  qword_10199F920 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLLocationMulticlientStreamerSilo");
}

void sub_100FA0C54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  operator delete(v19);
  _Unwind_Resume(a1);
}

id sub_100FA0C80(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101890770);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    __int128 v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient Stop timer fired}",  (uint8_t *)v4,  0x12u);
  }

  return [*(id *)(a1 + 32) stopLocation];
}

id sub_100FA0D60(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onLocationNotification:a2 withData:a3];
}

void sub_100FA1738(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    uint64_t v3 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient failed to post multiclient stream event, err:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101890770);
      }
    }

    __int128 v4 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient failed to post multiclient stream event",  "{msg%{public}.0s:#Multiclient failed to post multiclient stream event, err:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    __int128 v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"), "count");
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 1026;
      LODWORD(v13) = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Multiclient posted a location to interested peers, numClients:%{public}u}",  (uint8_t *)&v8,  0x18u);
    }
  }

uint64_t sub_100FA1B7C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101890770);
  }
  unsigned int v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    v10[0] = 68289282;
    v10[1] = 0;
    __int16 v11 = 2082;
    __int16 v12 = "";
    __int16 v13 = 2082;
    id v14 = objc_msgSend( objc_msgSend(a2, "objectForKeyedSubscript:", @"kCLLocationSTreamingMessageRapportDeviceIDKey"),  "UTF8String");
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient received interest in streaming from a nearby client, requester:%{public, location:escape_only}s}",  (uint8_t *)v10,  0x1Cu);
  }

  id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  sub_1004F2598();
  objc_msgSend( v8,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1004F7000()),  @"kCLLocationStreamingMessageRapportIsPhoneKey");
  sub_1004F2598();
  objc_msgSend( v8,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1004F75F8()),  @"kCLLocationStreamingMessageRapportIsPadKey");
  sub_1004F2598();
  objc_msgSend( v8,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1004F6DCC()),  @"kCLLocationStreamingMessageRapportHasGPSKey");
  objc_msgSend( v8,  "setObject:forKeyedSubscript:",  objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "rapportDiscoveryLink"), "localDevice"),  "effectiveIdentifier"),  @"kCLLocationSTreamingMessageRapportDeviceIDKey");
  [v8 setObject:&__kCFBooleanTrue forKeyedSubscript:@"kCLLocationStreamingMessageRapportIsAtLeast16_4"];
  return (*(uint64_t (**)(uint64_t, id, void, void))(a4 + 16))(a4, v8, 0LL, 0LL);
}

uint64_t sub_100FA1D88(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101890770);
  }
  id v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 68289283;
    int v25 = 0;
    __int16 v26 = 2082;
    __int128 v27 = "";
    __int16 v28 = 2113;
    id v29 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient received streaming action request from a client, msg:%{private, location:escape_only}@}",  buf,  0x1Cu);
  }

  id v9 = [a3 objectForKeyedSubscript:RPOptionSenderID];
  id v10 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageInFitnessSessionKey"];
  id v11 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageActivityTypeAirborneKey"];
  id v12 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageEmergencyEnablementKey"];
  if ([a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageRapportLocationStreamingActionKey"])
  {
    BOOL v13 = v9 == 0LL;
  }

  else
  {
    BOOL v13 = 1;
  }

  if (!v13)
  {
    unsigned int v14 = objc_msgSend( objc_msgSend( a2,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportLocationStreamingActionKey"),  "intValue");
    if (v14 == 1LL)
    {
      objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"), "removeObject:", v9);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101890770);
      }
      __int128 v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = [v9 UTF8String];
        *(_DWORD *)std::string buf = 68289282;
        int v25 = 0;
        __int16 v26 = 2082;
        __int128 v27 = "";
        __int16 v28 = 2082;
        id v29 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient stopping location streaming to remote client, effectiveID:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

      if (!objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"), "count")) {
        objc_msgSend( *(id *)(a1 + 32),  "toggleLocationUpdates:inFitnessSession:inAirborneSession:emergencyEnablementAssertionActive:",  0,  objc_msgSend(v10, "BOOLValue"),  objc_msgSend(v11, "BOOLValue"),  objc_msgSend(v12, "BOOLValue"));
      }
      uint64_t v20 = @"kCLLocationStreamingMessageRapportLocationStreamingActionKey";
      BOOL v21 = &off_1018D50C0;
      (*(void (**)(uint64_t, NSDictionary *, void, void))(a4 + 16))( a4,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v21,  &v20,  1LL),  0LL,  0LL);
    }

    else if (!v14)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101890770);
      }
      __int128 v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        id v16 = [v9 UTF8String];
        *(_DWORD *)std::string buf = 68289282;
        int v25 = 0;
        __int16 v26 = 2082;
        __int128 v27 = "";
        __int16 v28 = 2082;
        id v29 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient (re)starting location streaming to remote client, effectiveID:%{publ ic, location:escape_only}s}",  buf,  0x1Cu);
      }

      objc_msgSend( *(id *)(a1 + 32),  "toggleLocationUpdates:inFitnessSession:inAirborneSession:emergencyEnablementAssertionActive:",  1,  objc_msgSend(v10, "BOOLValue"),  objc_msgSend(v11, "BOOLValue"),  objc_msgSend(v12, "BOOLValue"));
      objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"), "addObject:", v9);
      unint64_t v22 = @"kCLLocationStreamingMessageRapportLocationStreamingActionKey";
      __int128 v23 = &off_1018D50A8;
      (*(void (**)(uint64_t, NSDictionary *, void, void))(a4 + 16))( a4,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1LL),  0LL,  0LL);
      sub_1005D6760(*(void *)(*(void *)(a1 + 32) + 16LL));
    }
  }

  return (*(uint64_t (**)(uint64_t, void, void, void))(a4 + 16))(a4, 0LL, 0LL, 0LL);
}

void sub_100FA22E0(uint64_t a1, void *a2)
{
  if (objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"),  "containsObject:",  objc_msgSend(a2, "effectiveIdentifier")))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    __int128 v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      id v11 = "";
      __int16 v12 = 2082;
      id v13 = objc_msgSend(objc_msgSend(a2, "effectiveIdentifier"), "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient stopping location streaming to remote client, effectiveID:%{public, lo cation:escape_only}s}",  (uint8_t *)&v8,  0x1Cu);
    }

    objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "activeStreamingClients"),  "removeObject:",  objc_msgSend(a2, "effectiveIdentifier"));
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101890770);
  }
  __int16 v5 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    id v6 = objc_msgSend(objc_msgSend(a2, "effectiveIdentifier"), "UTF8String");
    id v7 = objc_msgSend(objc_msgSend(a2, "name"), "UTF8String");
    int v8 = 68289539;
    int v9 = 0;
    __int16 v10 = 2082;
    id v11 = "";
    __int16 v12 = 2082;
    id v13 = v6;
    __int16 v14 = 2081;
    id v15 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Multiclient CLLocationStreamer can no longer see a device, effectiveID:%{public, loc ation:escape_only}s, name:%{private, location:escape_only}s}",  (uint8_t *)&v8,  0x26u);
  }

void sub_100FA24D4(id a1, RPCompanionLinkDevice *a2)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101890770);
  }
  uint64_t v3 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289539;
    v4[1] = 0;
    __int16 v5 = 2082;
    id v6 = "";
    __int16 v7 = 2082;
    id v8 = objc_msgSend(-[RPCompanionLinkDevice effectiveIdentifier](a2, "effectiveIdentifier"), "UTF8String");
    __int16 v9 = 2081;
    id v10 = objc_msgSend(-[RPCompanionLinkDevice name](a2, "name"), "UTF8String");
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Multiclient CLLocationStreamer spotted a device, effectiveID:%{public, location:esca pe_only}s, name:%{private, location:escape_only}s}",  (uint8_t *)v4,  0x26u);
  }

void sub_100FA25E4(id a1, NSError *a2)
{
  if (a2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    uint64_t v3 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 68289282;
      int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int16 v13 = 2114;
      __int16 v14 = a2;
      __int128 v4 = "{msg%{public}.0s:#Multiclient failed to activate advertisement server, error:%{public, location:escape_only}@}";
      __int16 v5 = (os_log_s *)v3;
      os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
      uint32_t v7 = 28;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v5, v6, v4, (uint8_t *)&v9, v7);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    uint64_t v8 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      int v9 = 68289026;
      int v10 = 0;
      __int16 v11 = 2082;
      __int16 v12 = "";
      __int128 v4 = "{msg%{public}.0s:#Multiclient ready to listen for incoming streaming requests}";
      __int16 v5 = (os_log_s *)v8;
      os_log_type_t v6 = OS_LOG_TYPE_INFO;
      uint32_t v7 = 18;
      goto LABEL_10;
    }
  }

void sub_100FA274C(id a1, NSError *a2)
{
  if (a2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    uint64_t v3 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      int v6 = 68289282;
      int v7 = 0;
      __int16 v8 = 2082;
      int v9 = "";
      __int16 v10 = 2114;
      __int16 v11 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient failed to activate streaming link, error:%{public, location:escape_only}@}",  (uint8_t *)&v6,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101890770);
      }
    }

    __int128 v4 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v6 = 68289282;
      int v7 = 0;
      __int16 v8 = 2082;
      int v9 = "";
      __int16 v10 = 2114;
      __int16 v11 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient failed to activate streaming link",  "{msg%{public}.0s:#Multiclient failed to activate streaming link, error:%{public, location:escape_only}@}",  (uint8_t *)&v6,  0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101890770);
    }
    __int16 v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 68289026;
      int v7 = 0;
      __int16 v8 = 2082;
      int v9 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient location streaming outbound client ready to go when needed}",  (uint8_t *)&v6,  0x12u);
    }
  }

void sub_100FA2BD8(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_100FA2C04()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1013BB668;
      v1[3] = unk_1013BB678;
      v1[4] = xmmword_1013BB688;
      v1[0] = xmmword_1013BB648;
      v1[1] = unk_1013BB658;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100FA2CD8(_Unwind_Exception *a1)
{
}

void *sub_100FA2CF0(void *a1, void *a2)
{
  *a1 = a2;
  a1[1] = 0LL;
  v6[0] = &off_1018907C0;
  v6[1] = a1;
  int v7 = v6;
  sub_100FA2DF0(a2, (uint64_t)v6);
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_100FA2DA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  id v16 = a13;
  if (a13 == v14)
  {
    uint64_t v17 = 4LL;
    id v16 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*(void *)v16 + 8 * v17))();
LABEL_6:
  sub_10127BB80(v13);
  _Unwind_Resume(a1);
}

void *sub_100FA2DF0(void *a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)*a1 + 192LL))(*a1);
  sub_10001A504((uint64_t)v6, a2);
  sub_100470144((void *)(v3 + 144), (uint64_t)v6);
  uint64_t result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    uint64_t result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_100FA2E9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  id v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    id v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100FA2EE0(void **a1)
{
  uint64_t v2 = (uint64_t)a1[1];
  if (v2)
  {
    v4.n128_u64[0] = sub_1007F8A20(v2, (double *)*a1);
    v4.n128_u64[1] = v3;
    sub_100CDF600(*a1, &v4);
  }

void sub_100FA2F24(uint64_t a1)
{
  uint64_t v1 = (void ***)(a1 + 8);
  if (!*(void *)(a1 + 8))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101890790);
    }
    uint64_t v2 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Bringing up cycling state detector", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101890790);
      }
      v7[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "Bringing up cycling state detector",  v7,  2);
      int v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSecondaryClassifiers::onCyclingDetectorActivate()",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }

    unint64_t v3 = operator new(0x50uLL);
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *unint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0xBFF0000000000000LL;
    *((_DWORD *)v3 + 13) = 3;
    __n128 v4 = *v1;
    void *v1 = (void **)v3;
    if (v4) {
      sub_100223734((int)v1, v4);
    }
  }

void sub_100FA30FC(uint64_t a1)
{
  uint64_t v1 = (void ***)(a1 + 8);
  if (*(void *)(a1 + 8))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101890790);
    }
    uint64_t v2 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Tear down cycling state detector", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101890790);
      }
      v6[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "Tear down cycling state detector",  v6,  2);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSecondaryClassifiers::onCyclingDetectorDeactivate()",  "%s\n",  v4);
      if (v5 != buf) {
        free(v5);
      }
    }

    unint64_t v3 = *v1;
    void *v1 = 0LL;
    if (v3) {
      sub_100223734((int)v1, v3);
    }
  }

void sub_100FA32A8(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void *sub_100FA32DC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1018907C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100FA3310(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1018907C0;
  a2[1] = v2;
  return result;
}

uint64_t sub_100FA332C(uint64_t a1, _BYTE *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*a2) {
    sub_100FA2F24(v2);
  }
  else {
    sub_100FA30FC(v2);
  }
  return 1LL;
}

uint64_t sub_100FA3358(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100FA3394()
{
}

uint64_t sub_100FA33A0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v6 = operator new(0x118uLL);
  uint64_t result = sub_100FA33FC((uint64_t)v6, a2, a1);
  *a3 = v6;
  return result;
}

void sub_100FA33E8(_Unwind_Exception *a1)
{
}

uint64_t sub_100FA33FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_101890840;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0x40D5180000000000LL;
  uint64_t v5 = (double *)(a1 + 32);
  *(_OWORD *)(a1 + 40) = 0u;
  int v6 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = 0LL;
  sub_10001A504((uint64_t)v39, (uint64_t)&unk_1019A4128);
  sub_101023E00(a1 + 80, a3, v39);
  int v7 = v40;
  if (v40 == v39)
  {
    uint64_t v8 = 4LL;
    int v7 = v39;
    goto LABEL_5;
  }

  if (v40)
  {
    uint64_t v8 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  *(void *)(a1 + 232) = off_10186EF60;
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 240) = v9;
  *(void *)(a1 + 24_Block_object_dispose((const void *)(v1 - 128), 8) = a1 + 256;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 2sub_1011C52D0(v23 - 72) = 0LL;
  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)buf, "CleanupInterval", v5);
  __int16 v10 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "vendor"), "proxyForService:", @"CLNetworkLocationProvider"),  "addResponseListener:",  a1 + 232);
  sub_100583844((uint64_t)sub_100FA3AB0, *(void *)(a1 + 8), *(void **)(a1 + 16), buf);
  uint64_t v13 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  uint64_t v14 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    uint64_t v15 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
  }

  [*(id *)(*(void *)(a1 + 56) + 16) register:*(void *)(*(void *)(a1 + 56) + 8) forNotification:4 registrationInfo:0];
  memset(&v36, 0, sizeof(v36));
  std::string::operator=(&v36, (const std::string *)&qword_10199F938);
  [*(id *)(*(void *)(a1 + 56) + 16) register:*(void *)(*(void *)(a1 + 56) + 8) forNotification:0 registrationInfo:sub_10120E548((uint64_t)&v36)];
  [*(id *)(*(void *)(a1 + 56) + 16) register:*(void *)(*(void *)(a1 + 56) + 8) forNotification:6 registrationInfo:sub_10120E548((uint64_t)&v36)];
  sub_100ACD980((uint64_t)sub_100FA3C98, *(void *)(a1 + 8), *(void **)(a1 + 16), buf);
  uint64_t v16 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  uint64_t v17 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    uint64_t v18 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
  }

  [*(id *)(*(void *)(a1 + 64) + 16) register:*(void *)(*(void *)(a1 + 64) + 8) forNotification:0 registrationInfo:0];
  sub_1003CC884((uint64_t)sub_100FA3E80, *(void *)(a1 + 8), *(void **)(a1 + 16), buf);
  uint64_t v19 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  uint64_t v20 = *v6;
  *int v6 = v19;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    uint64_t v21 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
  }

  [*(id *)(*v6 + 16) register:*(void *)(*v6 + 8) forNotification:6 registrationInfo:0];
  sub_1004EEF6C((uint64_t)sub_100FA4068, *(void *)(a1 + 8), *(void **)(a1 + 16), buf);
  uint64_t v22 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  uint64_t v23 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v22;
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    uint64_t v24 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
  }

  [*(id *)(*(void *)(a1 + 48) + 16) register:*(void *)(*(void *)(a1 + 48) + 8) forNotification:5 registrationInfo:0];
  sub_100C6E054((uint64_t)sub_100FA4250, *(void *)(a1 + 8), *(void **)(a1 + 16), buf);
  uint64_t v25 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  uint64_t v26 = *(void *)(a1 + 72);
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = v25;
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
    uint64_t v27 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
    }
  }

  [*(id *)(*(void *)(a1 + 72) + 16) register:*(void *)(*(void *)(a1 + 72) + 8) forNotification:5 registrationInfo:0];
  id v28 = objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "silo"), "newTimer");
  *(void *)(a1 + 24) = v28;
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472LL;
  id v35[2] = sub_100FA4438;
  uint64_t v35[3] = &unk_10181D3D0;
  _DWORD v35[4] = a1;
  [v28 setHandler:v35];
  id v29 = *(void **)(a1 + 24);
  if (v29)
  {
    [v29 setNextFireDelay:*v5 interval:*v5];
  }

  else
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018908E8);
    }
    __int128 v30 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "TileMgr, Timer allocation failure, #CloneMe",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018908E8);
      }
      v34[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "TileMgr, Timer allocation failure, #CloneMe",  v34,  2);
      __int128 v33 = (uint8_t *)v32;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWifiTilesManagerExternal::CLWifiTilesManagerExternal(CLWifiTilesManager *, id<CLIntersiloUniverse>)",  "%s\n",  v32);
      if (v33 != buf) {
        free(v33);
      }
    }
  }

  return a1;
}

void sub_100FA3970( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, char a24)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  *uint64_t v26 = v29 + 16;
  sub_100603B94(v27, *v30);
  sub_1010240A0(v25);
  uint64_t v32 = v24[9];
  v24[9] = 0LL;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
  }
  uint64_t v33 = v24[8];
  v24[8] = 0LL;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
  }
  uint64_t v34 = v24[7];
  v24[7] = 0LL;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8LL))(v34);
  }
  uint64_t v35 = v24[6];
  v24[6] = 0LL;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8LL))(v35);
  }
  uint64_t v36 = *v28;
  *id v28 = 0LL;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8LL))(v36);
  }
  _Unwind_Resume(a1);
}

void sub_100FA3AB0(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018908C8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWifiTilesManager::onClientNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018908C8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWifiTilesManager::onClientNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100DF3AF4(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FA3C78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA3C98(uint64_t a1, int *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018908C8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWifiTilesManager::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018908C8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWifiTilesManager::onDataProtectionNotification, event:%{public, location:escape_o nly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100DF0450(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FA3E60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA3E80(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018908C8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWifiTilesManager::onStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018908C8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWifiTilesManager::onStatusNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100DFBAF4(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FA4048( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA4068(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018908C8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWifiTilesManager::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018908C8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWifiTilesManager::onLocationNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100DFAC90(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FA4230( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA4250(uint64_t a1, int *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018908C8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWifiTilesManager::onCompanionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018908C8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWifiTilesManager::onCompanionNotification, event:%{public, location:escape_only}s , this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100DF2D70(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FA4418( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA4438(uint64_t a1)
{
}

uint64_t sub_100FA4444(uint64_t a1)
{
  *(void *)a1 = off_101890840;
  objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "vendor"), "proxyForService:", @"CLNetworkLocationProvider"),  "removeResponseListener:",  a1 + 232);
  [*(id *)(a1 + 24) invalidate];

  *(void *)(a1 + 24) = 0LL;
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {

    *(void *)(a1 + 2sub_1011C52D0(v23 - 72) = 0LL;
  }

  *(void *)(a1 + 232) = off_10186EF60;
  sub_100603B94(a1 + 248, *(char **)(a1 + 256));
  sub_1010240A0(a1 + 80);
  uint64_t v3 = *(void *)(a1 + 72);
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  return a1;
}

void sub_100FA4554(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100FA4444(a1);
  operator delete(v1);
}

uint64_t sub_100FA4568(uint64_t a1)
{
  return sub_101024128(a1 + 80);
}

BOOL sub_100FA4570(uint64_t a1)
{
  return objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 16), "vendor"),  "proxyForService:",  @"CLDataProtectionManager"),  "syncgetDataAvailability") != 1;
}

id sub_100FA45A0(uint64_t a1)
{
  return _objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 16), "vendor"),  "proxyForService:",  @"CLNetworkLocationProvider"),  "syncgetIsBroadConnection");
}

void sub_100FA45C4(uint64_t a1)
{
}

BOOL sub_100FA45CC()
{
  return sub_1002958AC() == 1;
}

uint64_t sub_100FA45EC()
{
  return sub_1001B9A1C();
}

BOOL sub_100FA4600()
{
  return sub_1004F7500();
}

id sub_100FA4614(void *a1)
{
  uint64_t v2 = (CLTileDownloadSchedulingClient *)a1[34];
  if (!v2)
  {
    uint64_t v3 = objc_alloc(&OBJC_CLASS___CLTileDownloadSchedulingClient);
    uint64_t v4 = a1[1];
    if (v4) {
      uint64_t v5 = v4 + 120;
    }
    else {
      uint64_t v5 = 0LL;
    }
    uint64_t v2 = -[CLTileDownloadSchedulingClient initWithUniverse:andDelegate:](v3, "initWithUniverse:andDelegate:", a1[2], v5);
    a1[34] = v2;
  }

  return (id)-[CLTileDownloadSchedulingClient scheduleTileDownloadIfNecessary](v2, "scheduleTileDownloadIfNecessary");
}

id sub_100FA465C(uint64_t a1)
{
  id v1 = objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "vendor"), "proxyForService:", @"CLClientManager");
  if (byte_10199F94F >= 0) {
    uint64_t v2 = &qword_10199F938;
  }
  else {
    uint64_t v2 = (uint64_t *)qword_10199F938;
  }
  return objc_msgSend( v1,  "resetNotificationConsumedForIdentifier:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v2));
}

void sub_100FA46B8(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100FA46E4(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100FA4710()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1013BB780;
      v1[3] = unk_1013BB790;
      v1[4] = xmmword_1013BB7A0;
      v1[0] = xmmword_1013BB760;
      v1[1] = unk_1013BB770;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100FA47E4(_Unwind_Exception *a1)
{
}

void sub_100FA47FC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100FA4860()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100FA48D4(_Unwind_Exception *a1)
{
}

uint64_t sub_100FA48EC()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_10199F938, (void *)&_mh_execute_header);
}

uint64_t sub_100FA5A40(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        char v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = 0LL;
        while (1)
        {
          uint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v18 = v17 + 1;
          if (v17 == -1 || v18 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v19 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18;
          v16 |= (unint64_t)(v19 & 0x7F) << v14;
          if ((v19 & 0x80) == 0) {
            goto LABEL_49;
          }
          v14 += 7;
          BOOL v10 = v15++ >= 9;
          if (v10)
          {
            LODWORD(v16) = 0;
            goto LABEL_51;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_49:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_51:
        uint64_t v35 = 40LL;
        goto LABEL_60;
      case 2u:
        unint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v21 <= 0xFFFFFFFFFFFFFFF7LL && v21 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          uint64_t v22 = 0LL;
        }

        uint64_t v36 = 16LL;
        goto LABEL_65;
      case 3u:
        *(_BYTE *)(a1 + 48) |= 1u;
        unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v23 <= 0xFFFFFFFFFFFFFFF7LL && v23 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v22 = 0LL;
        }

        uint64_t v36 = 8LL;
LABEL_65:
        *(void *)(a1 + v36) = v22;
        continue;
      case 4u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v16 = 0LL;
        *(_BYTE *)(a1 + 48) |= 4u;
        while (2)
        {
          uint64_t v26 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v27 = v26 + 1;
          if (v26 == -1 || v27 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v28 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v26);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v27;
            v16 |= (unint64_t)(v28 & 0x7F) << v24;
            if (v28 < 0)
            {
              v24 += 7;
              BOOL v10 = v25++ >= 9;
              if (v10)
              {
                LODWORD(v16) = 0;
                goto LABEL_55;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v16) = 0;
        }
LABEL_55:
        uint64_t v35 = 44LL;
        goto LABEL_60;
      case 5u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v16 = 0LL;
        *(_BYTE *)(a1 + 48) |= 2u;
        break;
      case 6u:
        Data = (void *)PBReaderReadData(a2);

        *(void *)(a1 + 32) = Data;
        continue;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      uint64_t v31 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v32 = v31 + 1;
      if (v31 == -1 || v32 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v33 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v31);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v32;
      v16 |= (unint64_t)(v33 & 0x7F) << v29;
      if ((v33 & 0x80) == 0) {
        goto LABEL_57;
      }
      v29 += 7;
      BOOL v10 = v30++ >= 9;
      if (v10)
      {
        LODWORD(v16) = 0;
        goto LABEL_59;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_57:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v16) = 0;
    }
LABEL_59:
    uint64_t v35 = 24LL;
LABEL_60:
    *(_DWORD *)(a1 + v35) = v16;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100FA688C(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100FA68B8()
{
  if (qword_1019A40A0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40A0 + 8LL))(qword_1019A40A0);
  }
  if (qword_1019A40A8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40A8 + 8LL))(qword_1019A40A8);
  }
  if (qword_1019A40B0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40B0 + 8LL))(qword_1019A40B0);
  }
  if (qword_1019A40B8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40B8 + 8LL))(qword_1019A40B8);
  }
  if (qword_1019A40C0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40C0 + 8LL))(qword_1019A40C0);
  }
  if (qword_1019A40C8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40C8 + 8LL))(qword_1019A40C8);
  }
  if (qword_1019A40D0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40D0 + 8LL))(qword_1019A40D0);
  }
  if (qword_1019A40D8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40D8 + 8LL))(qword_1019A40D8);
  }
  if (qword_1019A40E0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A40E0 + 8LL))(qword_1019A40E0);
  }
  uint64_t result = qword_1019A40E8;
  if (qword_1019A40E8) {
    return (*(uint64_t (**)(uint64_t))(*(void *)qword_1019A40E8 + 8LL))(qword_1019A40E8);
  }
  return result;
}

void sub_100FA69BC(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_10199F950 & 1) == 0)
  {
    byte_10199F950 = 1;
    wireless_diagnostics::google::protobuf::internal::VerifyVersion( (wireless_diagnostics::google::protobuf::internal *)0x1E9808,  2005000,  (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  a4);
    char v4 = operator new(0x18uLL);
    v4[1] = 0LL;
    _DWORD v4[2] = 0LL;
    *char v4 = off_101890A50;
    qword_1019A40A0 = (uint64_t)v4;
    unsigned int v5 = operator new(0x18uLL);
    v5[1] = 0LL;
    v5[2] = 0LL;
    *unsigned int v5 = off_101890AC8;
    qword_1019A40A8 = (uint64_t)v5;
    unint64_t v6 = operator new(0x28uLL);
    *unint64_t v6 = &off_101890B40;
    v6[1] = 0LL;
    _OWORD v6[2] = 0LL;
    void v6[3] = 0LL;
    *((_DWORD *)v6 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    qword_1019A40B0 = (uint64_t)v6;
    uint64_t v7 = operator new(0x18uLL);
    v7[1] = 0LL;
    v7[2] = 0LL;
    *uint64_t v7 = off_101890BB8;
    qword_1019A40B8 = (uint64_t)v7;
    unint64_t v8 = (char *)operator new(0x50uLL);
    *(void *)unint64_t v8 = off_101890C30;
    *((void *)v8 + 7) = 0LL;
    *((void *)v8 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    *((_DWORD *)v8 + 1_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    *(_OWORD *)(v8 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 36) = 0u;
    qword_1019A40C0 = (uint64_t)v8;
    char v9 = operator new(0x28uLL);
    void *v9 = &off_101890CA8;
    v9[1] = 0LL;
    _DWORD v9[2] = 0LL;
    void v9[3] = 0LL;
    *((_DWORD *)v9 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    qword_1019A40C8 = (uint64_t)v9;
    BOOL v10 = operator new(0x38uLL);
    *BOOL v10 = &off_101890D20;
    v10[1] = 0LL;
    *((_DWORD *)v10 + 4) = -1;
    *(void *)((char *)v10 + 20) = 0LL;
    *(void *)((char *)v10 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = 0xFFFFFFFFLL;
    *(void *)((char *)v10 + 36) = 0LL;
    *(void *)((char *)v10 + 44) = 0LL;
    qword_1019A40D0 = (uint64_t)v10;
    uint64_t v11 = (char *)operator new(0x48uLL);
    *(void *)uint64_t v11 = &off_101890D98;
    *(_OWORD *)(v11 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
    *(_OWORD *)(v11 + 24) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    *(_OWORD *)(v11 + 52) = 0u;
    qword_1019A40D8 = (uint64_t)v11;
    int v12 = operator new(0x38uLL);
    v12[5] = 0LL;
    v12[6] = 0LL;
    *int v12 = off_101890E10;
    v12[1] = 0LL;
    id v12[2] = 0LL;
    void v12[3] = 0LL;
    *((_DWORD *)v12 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    qword_1019A40E0 = (uint64_t)v12;
    int v13 = (char *)operator new(0x50uLL);
    *(void *)int v13 = off_101890E88;
    *((void *)v13 + 6) = 0LL;
    *((void *)v13 + 7) = 0LL;
    *((_DWORD *)v13 + 16) = 0;
    *((void *)v13 + 9) = 0LL;
    *(_OWORD *)(v13 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
    *(_OWORD *)(v13 + 24) = 0u;
    *((_DWORD *)v13 + 10) = 0;
    qword_1019A40E8 = (uint64_t)v13;
    v6[1] = v5;
    uint64_t v14 = sub_100FA6CD8((uint64_t)v8);
    uint64_t v16 = qword_1019A40C8;
    uint64_t v17 = qword_1019A40A8;
    if (qword_1019A40A8)
    {
      *(void *)(qword_1019A40C8 + _Block_object_dispose((const void *)(v1 - 128), 8) = qword_1019A40A8;
      uint64_t v18 = qword_1019A40D0;
      *(void *)(qword_1019A40D0 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
      uint64_t v19 = qword_1019A40E0;
      *(void *)(qword_1019A40E0 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
      *(void *)(v19 + 40) = v18;
      uint64_t v20 = qword_1019A40E8;
    }

    else
    {
      uint64_t v14 = sub_100FA69BC(v14);
      uint64_t v17 = qword_1019A40A8;
      *(void *)(v16 + _Block_object_dispose((const void *)(v1 - 128), 8) = qword_1019A40A8;
      uint64_t v21 = qword_1019A40D0;
      if (v17)
      {
        *(void *)(qword_1019A40D0 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
        uint64_t v22 = qword_1019A40E0;
      }

      else
      {
        uint64_t v14 = sub_100FA69BC(v14);
        uint64_t v17 = qword_1019A40A8;
        *(void *)(v21 + _Block_object_dispose((const void *)(v1 - 128), 8) = qword_1019A40A8;
        uint64_t v22 = qword_1019A40E0;
        if (!v17)
        {
          uint64_t v14 = sub_100FA69BC(v14);
          uint64_t v17 = qword_1019A40A8;
        }
      }

      uint64_t v23 = qword_1019A40D0;
      *(void *)(v22 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
      if (!v23)
      {
        uint64_t v14 = sub_100FA69BC(v14);
        uint64_t v17 = qword_1019A40A8;
        uint64_t v23 = qword_1019A40D0;
      }

      *(void *)(v22 + 40) = v23;
      uint64_t v20 = qword_1019A40E8;
      if (!v17)
      {
        uint64_t v14 = sub_100FA69BC(v14);
        uint64_t v17 = qword_1019A40A8;
      }
    }

    *(void *)(v20 + _Block_object_dispose((const void *)(v1 - 128), 8) = v17;
    uint64_t v24 = qword_1019A40E0;
    if (!qword_1019A40E0)
    {
      sub_100FA69BC(v14);
      uint64_t v24 = qword_1019A40E0;
    }

    *(void *)(v20 + 16) = v24;
    wireless_diagnostics::google::protobuf::internal::OnShutdown( (wireless_diagnostics::google::protobuf::internal *)sub_100FA68B8,  v15);
  }

double sub_100FA6CAC(uint64_t a1)
{
  *(void *)a1 = off_101890E88;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_100FA6CD8(uint64_t result)
{
  id v1 = (void *)result;
  uint64_t v2 = qword_1019A40A0;
  if (!qword_1019A40A0)
  {
    double result = ((uint64_t (*)(void))sub_100FA69BC)();
    uint64_t v2 = qword_1019A40A0;
  }

  v1[1] = v2;
  uint64_t v3 = qword_1019A40B0;
  if (qword_1019A40B0)
  {
    v1[2] = qword_1019A40B0;
  }

  else
  {
    double result = ((uint64_t (*)(void))sub_100FA69BC)();
    uint64_t v3 = qword_1019A40B0;
    v1[2] = qword_1019A40B0;
    if (!v3)
    {
      double result = sub_100FA69BC(result);
      uint64_t v3 = qword_1019A40B0;
    }
  }

  v1[3] = v3;
  uint64_t v4 = qword_1019A40A8;
  if (!qword_1019A40A8)
  {
    double result = sub_100FA69BC(result);
    uint64_t v4 = qword_1019A40A8;
  }

  v1[7] = v4;
  return result;
}

void sub_100FA6D54(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  305LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      unsigned int v6 = *(_DWORD *)(a2 + 8);
      if (v6 >= 5) {
        sub_10127BD6C();
      }
      a1[5] |= 1u;
      a1[2] = v6;
      int v5 = *(_DWORD *)(a2 + 20);
    }

    if ((v5 & 2) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 12);
      a1[5] |= 2u;
      a1[3] = v7;
    }
  }

void sub_100FA6E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA6E20(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FA6E30(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890A50;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100FA6E50()
{
  double result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *double result = off_101890A50;
  return result;
}

uint64_t sub_100FA6E78(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100FA6E8C( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  int v5 = a1 + 3;
  while (1)
  {
    while (1)
    {
      unsigned int v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      int v8 = TagFallback & 7;
      uint64_t v11 = (char *)*((void *)this + 1);
      if ((unint64_t)v11 >= *((void *)this + 2) || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v16);
        if (!(_DWORD)result) {
          return result;
        }
        unsigned int v12 = v16;
      }

      else
      {
        unsigned int v12 = *v11;
        *((void *)this + 1) = v11 + 1;
      }

      if (v12 <= 4)
      {
        a1[5] |= 1u;
        a1[2] = v12;
      }

      int v13 = (_BYTE *)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 2);
      if ((unint64_t)v13 < v9 && *v13 == 16)
      {
        BOOL v10 = v13 + 1;
        *((void *)this + 1) = v10;
LABEL_26:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v14 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *int v5 = *v10;
          uint64_t v14 = (unsigned __int8 *)(v10 + 1);
          *((void *)this + 1) = v14;
        }

        a1[5] |= 2u;
        if (v14 == (unsigned __int8 *)v9 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }

    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        BOOL v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        goto LABEL_26;
      }
    }

    else
    {
      int v8 = TagFallback & 7;
    }

uint64_t sub_100FA7038( uint64_t result, unsigned int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  }
  return result;
}

uint64_t sub_100FA7090(uint64_t a1, unsigned int a2)
{
  char v3 = *(_BYTE *)(a1 + 20);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v4 = 11LL;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }

      else if (v5 >= 0x80)
      {
        if ((*(_DWORD *)(a1 + 20) & 2) == 0) {
          goto LABEL_17;
        }
      }

      else
      {
        uint64_t v4 = 2LL;
        if ((v3 & 2) == 0) {
          goto LABEL_17;
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
      if ((*(_BYTE *)(a1 + 20) & 2) == 0) {
        goto LABEL_17;
      }
    }

    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    else {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

void sub_100FA712C(_DWORD *a1, void *lpsrc)
{
}

uint64_t sub_100FA7178()
{
  return 1LL;
}

void *sub_100FA7180@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.SvId");
}

float sub_100FA7190(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  505LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      int v7 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
      int v6 = *(_DWORD *)(a2 + 20);
    }

    if ((v6 & 2) != 0)
    {
      float result = *(float *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(float *)(a1 + 12) = result;
    }
  }

  return result;
}

void sub_100FA7238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA7250(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890AC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FA7260(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890AC8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100FA7280()
{
  float result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *float result = off_101890AC8;
  return result;
}

uint64_t sub_100FA72A8(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100FA72BC( unsigned int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = a1 + 2;
  do
  {
    while (1)
    {
      while (1)
      {
        int v6 = (char *)*((void *)this + 1);
        if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v6 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        int v8 = TagFallback & 7;
        BOOL v10 = (char *)*((void *)this + 1);
        unint64_t v9 = *((void *)this + 2);
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v11 = (_BYTE *)*((void *)this + 1);
          unint64_t v9 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v10;
          uint64_t v11 = v10 + 1;
          *((void *)this + 1) = v11;
        }

        a1[5] |= 1u;
        if ((unint64_t)v11 < v9 && *v11 == 21)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_24;
        }
      }

      int v8 = TagFallback & 7;
      if (v8 != 5) {
        goto LABEL_16;
      }
LABEL_24:
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v13) & 1) == 0) {
        return 0LL;
      }
      a1[3] = v13;
      a1[5] |= 2u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v8 = TagFallback & 7;
LABEL_16:
    if (v8 == 4) {
      return 1LL;
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100FA7440( uint64_t result, unsigned int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  a2,  *(float *)(v5 + 12),  a3);
  }
  return result;
}

uint64_t sub_100FA7498(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 20);
      }

      else
      {
        unsigned int v4 = 2;
      }
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      uint64_t result = v4 + 5;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 16) = result;
  return result;
}

float sub_100FA7500(uint64_t a1, void *lpsrc)
{
  return sub_100FA7190(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA754C()
{
  return 1LL;
}

void *sub_100FA7554@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.GpsTime");
}

float sub_100FA7564(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  771LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      *(_DWORD *)(a1 + 32) |= 1u;
      int v7 = *(void **)(a1 + 8);
      if (!v7)
      {
        int v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        *int v7 = off_101890AC8;
        *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A40B0 + 8);
      }
      float result = sub_100FA7190((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 32);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_16;
      }
    }

    else if ((*(_BYTE *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_6;
    }

    float result = *(float *)(a2 + 16);
    *(_DWORD *)(a1 + 32) |= 2u;
    *(float *)(a1 + 16) = result;
    int v6 = *(_DWORD *)(a2 + 32);
    if ((v6 & 4) == 0)
    {
LABEL_7:
      if ((v6 & 8) == 0) {
        return result;
      }
      goto LABEL_8;
    }

void sub_100FA7688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA76A0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101890B40;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A40B0 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FA76F4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100FA7708()
{
  float result = operator new(0x28uLL);
  *float result = &off_101890B40;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  *((_DWORD *)result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  return result;
}

uint64_t sub_100FA7734(uint64_t result)
{
  if (*(_BYTE *)(result + 32))
  {
    if ((*(_BYTE *)(result + 32) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 20)) {
          *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v1 + 20) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 0;
  }

  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FA7768( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
        *(_DWORD *)(a1 + 32) |= 1u;
        uint64_t v8 = *(unsigned int **)(a1 + 8);
        if (!v8)
        {
          uint64_t v8 = (unsigned int *)operator new(0x18uLL);
          *((void *)v8 + 1) = 0LL;
          *((void *)v8 + 2) = 0LL;
          *(void *)uint64_t v8 = off_101890AC8;
          *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v8;
        }

        char v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v21)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v21 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v10 = *((_DWORD *)this + 14);
        int v11 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v10 + 1;
        if (v10 >= v11) {
          return 0LL;
        }
        int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v21);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
        int v14 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v14, 1);
        int v16 = v14 - 1;
        if (v16 < 0 == v15) {
          *((_DWORD *)this + 14) = v16;
        }
        uint64_t v17 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v17 + 1;
        goto LABEL_31;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_19;
        }
LABEL_31:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v21) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 16) = v21;
        *(_DWORD *)(a1 + 32) |= 2u;
        uint64_t v18 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v18 + 1;
LABEL_35:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v21) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 20) = v21;
        *(_DWORD *)(a1 + 32) |= 4u;
        uint64_t v19 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v19 + 1;
LABEL_39:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v21) & 1) != 0)
        {
          *(_DWORD *)(a1 + 24) = v21;
          *(_DWORD *)(a1 + 32) |= 8u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_35;
        }
        goto LABEL_19;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_19;
        }
        goto LABEL_39;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100FA7A30( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A40B0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(float *)(v5 + 16),  a3);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  (int)a2,  *(float *)(v5 + 24),  a3);
  }

uint64_t sub_100FA7AD4(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 32) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (!v6) {
        uint64_t v6 = *(void *)(qword_1019A40B0 + 8);
      }
      uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v6, a2);
      int v9 = (int)v7;
      else {
        int v10 = 1;
      }
      unsigned int v4 = v9 + v10 + 1;
      int v3 = *(_DWORD *)(a1 + 32);
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      v4 += 5;
    }
    if ((v3 & 4) != 0) {
      v4 += 5;
    }
    if ((v3 & 8) != 0) {
      uint64_t result = v4 + 5;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

float sub_100FA7B74(uint64_t a1, void *lpsrc)
{
  return sub_100FA7564(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA7BC0()
{
  return 1LL;
}

void *sub_100FA7BC8@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.SatellitePolynomialClock");
}

float sub_100FA7BD8(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v9,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  982LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v9,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 8);
      if (v7 >= 7) {
        sub_10127BD94();
      }
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
      int v6 = *(_DWORD *)(a2 + 20);
    }

    if ((v6 & 2) != 0)
    {
      float result = *(float *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(float *)(a1 + 12) = result;
    }
  }

  return result;
}

void sub_100FA7C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA7CA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100FA7CB4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890BB8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100FA7CD4()
{
  float result = operator new(0x18uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *float result = off_101890BB8;
  return result;
}

uint64_t sub_100FA7CFC(uint64_t result)
{
  if (*(_BYTE *)(result + 20)) {
    *(void *)(result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100FA7D10( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        int v7 = TagFallback & 7;
        char v8 = (char *)*((void *)this + 1);
        if ((unint64_t)v8 >= *((void *)this + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v9 = v12;
        }

        else
        {
          unsigned int v9 = *v8;
          *((void *)this + 1) = v8 + 1;
        }

        if (v9 <= 6)
        {
          a1[5] |= 1u;
          a1[2] = v9;
        }

        int v11 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v11 < *((void *)this + 2) && *v11 == 21)
        {
          *((void *)this + 1) = v11 + 1;
          goto LABEL_25;
        }
      }

      int v7 = TagFallback & 7;
      if (v7 != 5) {
        goto LABEL_15;
      }
LABEL_25:
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v13) & 1) == 0) {
        return 0LL;
      }
      a1[3] = v13;
      a1[5] |= 2u;
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v7 = TagFallback & 7;
LABEL_15:
    if (v7 == 4) {
      return 1LL;
    }
  }

  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0);
  return 0LL;
}

uint64_t sub_100FA7E94( uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }

  if ((v6 & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  a2,  *(float *)(v5 + 12),  a3);
  }
  return result;
}

uint64_t sub_100FA7EEC(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        unsigned int v4 = 11;
      }

      else if (v6 >= 0x80)
      {
        unsigned int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        int v3 = *(_DWORD *)(a1 + 20);
      }

      else
      {
        unsigned int v4 = 2;
      }
    }

    else
    {
      unsigned int v4 = 0;
    }

    if ((v3 & 2) != 0) {
      uint64_t result = v4 + 5;
    }
    else {
      uint64_t result = v4;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(_DWORD *)(a1 + 16) = result;
  return result;
}

float sub_100FA7F60(uint64_t a1, void *lpsrc)
{
  return sub_100FA7BD8(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA7FAC()
{
  return 1LL;
}

void *sub_100FA7FB4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.SatelliteGroupDelay");
}

float sub_100FA7FC4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v24,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  1338LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v24,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v23, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v24);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 32),  *(_DWORD *)(a2 + 40) + *(_DWORD *)(a1 + 40));
  if (*(int *)(a2 + 40) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a2 + 32) + 8 * v6);
      int v8 = *(_DWORD *)(a1 + 44);
      uint64_t v9 = *(int *)(a1 + 40);
      if ((int)v9 >= v8)
      {
        if (v8 == *(_DWORD *)(a1 + 48))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 32),  v8 + 1);
          int v8 = *(_DWORD *)(a1 + 44);
        }

        *(_DWORD *)(a1 + 44) = v8 + 1;
        int v11 = operator new(0x18uLL);
        v11[1] = 0LL;
        uint64_t v11[2] = 0LL;
        *int v11 = off_101890BB8;
        uint64_t v12 = *(void *)(a1 + 32);
        uint64_t v13 = *(int *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = v13 + 1;
        *(void *)(v12 + 8 * v13) = v11;
      }

      else
      {
        uint64_t v10 = *(void *)(a1 + 32);
        *(_DWORD *)(a1 + 40) = v9 + 1;
        int v11 = *(void **)(v10 + 8 * v9);
      }

      float result = sub_100FA7BD8((uint64_t)v11, v7);
      ++v6;
    }

    while (v6 < *(int *)(a2 + 40));
  }

  LOBYTE(v14) = *(_BYTE *)(a2 + 72);
  if (!(_BYTE)v14) {
    return result;
  }
  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
  {
    *(_DWORD *)(a1 + 72) |= 1u;
    BOOL v15 = *(void **)(a1 + 8);
    if (!v15)
    {
      BOOL v15 = operator new(0x18uLL);
      v15[1] = 0LL;
      v15[2] = 0LL;
      void *v15 = off_101890A50;
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v15;
    }

    uint64_t v16 = *(void *)(a2 + 8);
    if (!v16) {
      uint64_t v16 = *(void *)(qword_1019A40C0 + 8);
    }
    sub_100FA6D54(v15, v16);
    int v14 = *(_DWORD *)(a2 + 72);
    if ((v14 & 2) == 0)
    {
LABEL_14:
      if ((v14 & 4) == 0) {
        goto LABEL_15;
      }
LABEL_29:
      *(_DWORD *)(a1 + 72) |= 4u;
      uint64_t v19 = *(void **)(a1 + 24);
      if (!v19)
      {
        uint64_t v19 = operator new(0x28uLL);
        *uint64_t v19 = &off_101890B40;
        v19[1] = 0LL;
        v19[2] = 0LL;
        v19[3] = 0LL;
        *((_DWORD *)v19 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        *(void *)(a1 + 24) = v19;
      }

      uint64_t v20 = *(void *)(a2 + 24);
      if (!v20) {
        uint64_t v20 = *(void *)(qword_1019A40C0 + 24);
      }
      float result = sub_100FA7564((uint64_t)v19, v20);
      int v14 = *(_DWORD *)(a2 + 72);
      if ((v14 & 0x10) == 0)
      {
LABEL_16:
        if ((v14 & 0x20) == 0) {
          return result;
        }
        goto LABEL_17;
      }

      goto LABEL_34;
    }
  }

  else if ((*(_BYTE *)(a2 + 72) & 2) == 0)
  {
    goto LABEL_14;
  }

  *(_DWORD *)(a1 + 72) |= 2u;
  uint64_t v17 = *(void **)(a1 + 16);
  if (!v17)
  {
    uint64_t v17 = operator new(0x28uLL);
    void *v17 = &off_101890B40;
    v17[1] = 0LL;
    v17[2] = 0LL;
    v17[3] = 0LL;
    *((_DWORD *)v17 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
    *(void *)(a1 + 16) = v17;
  }

  uint64_t v18 = *(void *)(a2 + 16);
  if (!v18) {
    uint64_t v18 = *(void *)(qword_1019A40C0 + 16);
  }
  float result = sub_100FA7564((uint64_t)v17, v18);
  int v14 = *(_DWORD *)(a2 + 72);
  if ((v14 & 4) != 0) {
    goto LABEL_29;
  }
LABEL_15:
  if ((v14 & 0x10) == 0) {
    goto LABEL_16;
  }
LABEL_34:
  *(_DWORD *)(a1 + 72) |= 0x10u;
  unsigned int v21 = *(void **)(a1 + 56);
  if (!v21)
  {
    unsigned int v21 = operator new(0x18uLL);
    v21[1] = 0LL;
    id v21[2] = 0LL;
    *unsigned int v21 = off_101890AC8;
    *(void *)(a1 + 56) = v21;
  }

  uint64_t v22 = *(void *)(a2 + 56);
  if (!v22) {
    uint64_t v22 = *(void *)(qword_1019A40C0 + 56);
  }
  float result = sub_100FA7190((uint64_t)v21, v22);
  if ((*(_DWORD *)(a2 + 72) & 0x20) != 0)
  {
LABEL_17:
    float result = *(float *)(a2 + 64);
    *(_DWORD *)(a1 + 72) |= 0x20u;
    *(float *)(a1 + 64) = result;
  }

  return result;
}

void sub_100FA8278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA8290(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890C30;
  uint64_t v2 = (uint64_t)a1 + 32;
  sub_100FA82D0(a1);
  sub_10008D0EC(v2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void *sub_100FA82D0(void *result)
{
  if ((void *)qword_1019A40C0 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    float result = (void *)v1[7];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FA8358(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100FA836C()
{
  unsigned __int8 v0 = (char *)operator new(0x50uLL);
  *(void *)unsigned __int8 v0 = off_101890C30;
  *((void *)v0 + 7) = 0LL;
  *((void *)v0 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *((_DWORD *)v0 + 1_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  double result = 0.0;
  *(_OWORD *)(v0 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 36) = 0u;
  return result;
}

uint64_t sub_100FA83A8(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 72);
  if ((_BYTE)v2)
  {
    if ((*(_BYTE *)(result + 72) & 1) != 0)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 20)) {
          *(void *)(v3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v3 + 20) = 0;
        int v2 = *(_DWORD *)(result + 72);
      }
    }

    if ((v2 & 2) != 0)
    {
      double result = *(void *)(result + 16);
      if (result)
      {
        double result = sub_100FA7734(result);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }

    if ((v2 & 4) != 0)
    {
      double result = *(void *)(v1 + 24);
      if (result)
      {
        double result = sub_100FA7734(result);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }

    if ((v2 & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 56);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 20)) {
          *(void *)(v4 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v4 + 20) = 0;
      }
    }

    *(_DWORD *)(v1 + 64) = 0;
  }

  if (*(int *)(v1 + 40) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(v1 + 32) + 8 * v5);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32LL))(v6);
      ++v5;
    }

    while (v5 < *(int *)(v1 + 40));
  }

  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + sub_1011C52D0(v23 - 72) = 0;
  return result;
}

uint64_t sub_100FA8470( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 32);
  while (1)
  {
LABEL_2:
    uint64_t v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 < *((void *)this + 2) && (*v6 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
      goto LABEL_7;
    }

    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback) {
      return 1LL;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_24;
        }
        *(_DWORD *)(a1 + 72) |= 1u;
        uint64_t v9 = *(void **)(a1 + 8);
        if (!v9)
        {
          uint64_t v9 = operator new(0x18uLL);
          v9[1] = 0LL;
          _DWORD v9[2] = 0LL;
          void *v9 = off_101890A50;
          *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v9;
        }

        uint64_t v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v61)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v61 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        int v11 = *((_DWORD *)this + 14);
        int v12 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v11 + 1;
        if (v11 >= v12) {
          return 0LL;
        }
        int v13 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v61);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v13);
        int v15 = *((_DWORD *)this + 14);
        BOOL v16 = __OFSUB__(v15, 1);
        int v17 = v15 - 1;
        if (v17 < 0 == v16) {
          *((_DWORD *)this + 14) = v17;
        }
        uint64_t v18 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v18 + 1;
        goto LABEL_36;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_24;
        }
LABEL_36:
        *(_DWORD *)(a1 + 72) |= 2u;
        uint64_t v19 = *(void **)(a1 + 16);
        if (!v19)
        {
          uint64_t v19 = operator new(0x28uLL);
          *uint64_t v19 = &off_101890B40;
          v19[1] = 0LL;
          v19[2] = 0LL;
          v19[3] = 0LL;
          *((_DWORD *)v19 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
          *(void *)(a1 + 16) = v19;
        }

        uint64_t v20 = (char *)*((void *)this + 1);
        if ((unint64_t)v20 >= *((void *)this + 2) || *v20 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v61)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v61 = *v20;
          *((void *)this + 1) = v20 + 1;
        }

        int v21 = *((_DWORD *)this + 14);
        int v22 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v21 + 1;
        if (v21 >= v22) {
          return 0LL;
        }
        int v23 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v61);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v23);
        int v25 = *((_DWORD *)this + 14);
        BOOL v16 = __OFSUB__(v25, 1);
        int v26 = v25 - 1;
        if (v26 < 0 == v16) {
          *((_DWORD *)this + 14) = v26;
        }
        unint64_t v27 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v27 + 1;
LABEL_50:
        *(_DWORD *)(a1 + 72) |= 4u;
        char v28 = *(void **)(a1 + 24);
        if (!v28)
        {
          char v28 = operator new(0x28uLL);
          *char v28 = &off_101890B40;
          v28[1] = 0LL;
          v28[2] = 0LL;
          id v28[3] = 0LL;
          *((_DWORD *)v28 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
          *(void *)(a1 + 24) = v28;
        }

        char v29 = (char *)*((void *)this + 1);
        if ((unint64_t)v29 >= *((void *)this + 2) || *v29 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v61)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v61 = *v29;
          *((void *)this + 1) = v29 + 1;
        }

        int v30 = *((_DWORD *)this + 14);
        int v31 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v30 + 1;
        if (v30 >= v31) {
          return 0LL;
        }
        int v32 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v61);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v32);
        int v34 = *((_DWORD *)this + 14);
        BOOL v16 = __OFSUB__(v34, 1);
        int v35 = v34 - 1;
        if (v35 < 0 == v16) {
          *((_DWORD *)this + 14) = v35;
        }
        uint64_t v36 = (_BYTE *)*((void *)this + 1);
        do
        {
          *((void *)this + 1) = v36 + 1;
LABEL_64:
          int v37 = *(_DWORD *)(a1 + 44);
          uint64_t v38 = *(int *)(a1 + 40);
          if ((int)v38 >= v37)
          {
            if (v37 == *(_DWORD *)(a1 + 48))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v37 + 1);
              int v37 = *(_DWORD *)(a1 + 44);
            }

            *(_DWORD *)(a1 + 44) = v37 + 1;
            double v40 = operator new(0x18uLL);
            v40[1] = 0LL;
            uint64_t v40[2] = 0LL;
            *double v40 = off_101890BB8;
            uint64_t v41 = *(void *)(a1 + 32);
            uint64_t v42 = *(int *)(a1 + 40);
            *(_DWORD *)(a1 + 40) = v42 + 1;
            *(void *)(v41 + 8 * v42) = v40;
          }

          else
          {
            uint64_t v39 = *(void *)(a1 + 32);
            *(_DWORD *)(a1 + 40) = v38 + 1;
            double v40 = *(void **)(v39 + 8 * v38);
          }

          __int128 v43 = (char *)*((void *)this + 1);
          if ((unint64_t)v43 >= *((void *)this + 2) || *v43 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v61)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v61 = *v43;
            *((void *)this + 1) = v43 + 1;
          }

          int v44 = *((_DWORD *)this + 14);
          int v45 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v44 + 1;
          if (v44 >= v45) {
            return 0LL;
          }
          int v46 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v61);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v46);
          int v48 = *((_DWORD *)this + 14);
          BOOL v16 = __OFSUB__(v48, 1);
          int v49 = v48 - 1;
          if (v49 < 0 == v16) {
            *((_DWORD *)this + 14) = v49;
          }
          uint64_t v36 = (_BYTE *)*((void *)this + 1);
          int v50 = *v36;
        }

        while (v50 == 34);
        if (v50 != 42) {
          continue;
        }
        *((void *)this + 1) = v36 + 1;
LABEL_82:
        *(_DWORD *)(a1 + 72) |= 0x10u;
        uint64_t v51 = *(unsigned int **)(a1 + 56);
        if (!v51)
        {
          uint64_t v51 = (unsigned int *)operator new(0x18uLL);
          *((void *)v51 + 1) = 0LL;
          *((void *)v51 + 2) = 0LL;
          *(void *)uint64_t v51 = off_101890AC8;
          *(void *)(a1 + 56) = v51;
        }

        uint64_t v52 = (char *)*((void *)this + 1);
        if ((unint64_t)v52 >= *((void *)this + 2) || *v52 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v61)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v61 = *v52;
          *((void *)this + 1) = v52 + 1;
        }

        int v53 = *((_DWORD *)this + 14);
        int v54 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v53 + 1;
        if (v53 >= v54) {
          return 0LL;
        }
        int v55 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v61);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v55);
        int v57 = *((_DWORD *)this + 14);
        BOOL v16 = __OFSUB__(v57, 1);
        int v58 = v57 - 1;
        if (v58 < 0 == v16) {
          *((_DWORD *)this + 14) = v58;
        }
        uint64_t v59 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v59 + 1;
LABEL_96:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v61) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 64) = v61;
        *(_DWORD *)(a1 + 72) |= 0x20u;
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }

        break;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_50;
        }
        goto LABEL_24;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_64;
        }
        goto LABEL_24;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_82;
        }
        goto LABEL_24;
      case 6u:
        int v8 = TagFallback & 7;
        if (v8 != 5) {
          goto LABEL_24;
        }
        goto LABEL_96;
      default:
        int v8 = TagFallback & 7;
LABEL_24:
        if (v8 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100FA8AC0( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 72);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A40C0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 72);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_14;
      }
      goto LABEL_11;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t v8 = *(void *)(v5 + 16);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_1019A40C0 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  if ((*(_DWORD *)(v5 + 72) & 4) != 0)
  {
LABEL_11:
    uint64_t v9 = *(void *)(v5 + 24);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A40C0 + 24);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v9,  a2,  a4);
  }

uint64_t sub_100FA8BF0(uint64_t a1, unsigned int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 72);
  if (*(_BYTE *)(a1 + 72))
  {
    if ((v3 & 1) != 0)
    {
      uint64_t v5 = *(void *)(a1 + 8);
      if (!v5) {
        uint64_t v5 = *(void *)(qword_1019A40C0 + 8);
      }
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7090(v5, a2);
      int v7 = (int)v6;
      else {
        int v8 = 1;
      }
      int v4 = v7 + v8 + 1;
      int v3 = *(_DWORD *)(a1 + 72);
      if ((v3 & 2) == 0)
      {
LABEL_17:
        if ((v3 & 4) != 0)
        {
          uint64_t v13 = *(void *)(a1 + 24);
          if (!v13) {
            uint64_t v13 = *(void *)(qword_1019A40C0 + 24);
          }
          unsigned int v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7AD4(v13, a2);
          int v15 = (int)v14;
          else {
            int v16 = 1;
          }
          v4 += v15 + v16 + 1;
          int v3 = *(_DWORD *)(a1 + 72);
          if ((v3 & 0x10) == 0) {
            goto LABEL_32;
          }
        }

        else if ((v3 & 0x10) == 0)
        {
LABEL_32:
          if ((v3 & 0x20) != 0) {
            int v3 = v4 + 5;
          }
          else {
            int v3 = v4;
          }
          goto LABEL_35;
        }

        uint64_t v17 = *(void *)(a1 + 56);
        if (!v17) {
          uint64_t v17 = *(void *)(qword_1019A40C0 + 56);
        }
        uint64_t v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v17, a2);
        int v19 = (int)v18;
        else {
          int v20 = 1;
        }
        v4 += v19 + v20 + 1;
        int v3 = *(_DWORD *)(a1 + 72);
        goto LABEL_32;
      }
    }

    else
    {
      int v4 = 0;
      if ((v3 & 2) == 0) {
        goto LABEL_17;
      }
    }

    uint64_t v9 = *(void *)(a1 + 16);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A40C0 + 16);
    }
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7AD4(v9, a2);
    int v11 = (int)v10;
    else {
      int v12 = 1;
    }
    v4 += v11 + v12 + 1;
    int v3 = *(_DWORD *)(a1 + 72);
    goto LABEL_17;
  }

float sub_100FA8DB4(uint64_t a1, void *lpsrc)
{
  return sub_100FA7FC4(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA8E00()
{
  return 1LL;
}

void *sub_100FA8E08@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.SatelliteClockData");
}

float sub_100FA8E18(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  1623LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      *(_DWORD *)(a1 + 32) |= 1u;
      int v7 = *(void **)(a1 + 8);
      if (!v7)
      {
        int v7 = operator new(0x18uLL);
        v7[1] = 0LL;
        v7[2] = 0LL;
        *int v7 = off_101890AC8;
        *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A40C8 + 8);
      }
      float result = sub_100FA7190((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 32);
    }

    if ((v6 & 2) != 0)
    {
      unsigned int v9 = *(_DWORD *)(a2 + 16);
      if (v9 >= 5) {
        sub_10127BDBC();
      }
      *(_DWORD *)(a1 + 32) |= 2u;
      *(_DWORD *)(a1 + 16) = v9;
      int v6 = *(_DWORD *)(a2 + 32);
    }

    if ((v6 & 4) != 0)
    {
      float result = *(float *)(a2 + 20);
      *(_DWORD *)(a1 + 32) |= 4u;
      *(float *)(a1 + 20) = result;
      int v6 = *(_DWORD *)(a2 + 32);
    }

    if ((v6 & 8) != 0)
    {
      float result = *(float *)(a2 + 24);
      *(_DWORD *)(a1 + 32) |= 8u;
      *(float *)(a1 + 24) = result;
    }
  }

  return result;
}

void sub_100FA8F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA8F50(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101890CA8;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A40C8 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FA8FA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100FA8FB8()
{
  float result = operator new(0x28uLL);
  *float result = &off_101890CA8;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  *((_DWORD *)result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  return result;
}

uint64_t sub_100FA8FE4(uint64_t result)
{
  if (*(_BYTE *)(result + 32))
  {
    if ((*(_BYTE *)(result + 32) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 20)) {
          *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v1 + 20) = 0;
      }
    }

    *(_DWORD *)(result + 24) = 0;
    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100FA9018( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
        *(_DWORD *)(a1 + 32) |= 1u;
        uint64_t v8 = *(unsigned int **)(a1 + 8);
        if (!v8)
        {
          uint64_t v8 = (unsigned int *)operator new(0x18uLL);
          *((void *)v8 + 1) = 0LL;
          *((void *)v8 + 2) = 0LL;
          *(void *)uint64_t v8 = off_101890AC8;
          *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v8;
        }

        unsigned int v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v24)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v24 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v12 = *((_DWORD *)this + 14);
        int v13 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v12 + 1;
        if (v12 >= v13) {
          return 0LL;
        }
        int v14 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v24);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v14);
        int v16 = *((_DWORD *)this + 14);
        BOOL v17 = __OFSUB__(v16, 1);
        int v18 = v16 - 1;
        if (v18 < 0 == v17) {
          *((_DWORD *)this + 14) = v18;
        }
        int v19 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        int v11 = v19 + 1;
        *((void *)this + 1) = v11;
        goto LABEL_31;
      case 2u:
        int v7 = TagFallback & 7;
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_31:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v20 = v24;
        }

        else
        {
          unsigned int v20 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        if (v20 <= 4)
        {
          *(_DWORD *)(a1 + 32) |= 2u;
          *(_DWORD *)(a1 + 16) = v20;
        }

        uint64_t v22 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v22 + 1;
LABEL_41:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v24) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 20) = v24;
        *(_DWORD *)(a1 + 32) |= 4u;
        uint64_t v23 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v23 + 1;
LABEL_45:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v24) & 1) != 0)
        {
          *(_DWORD *)(a1 + 24) = v24;
          *(_DWORD *)(a1 + 32) |= 8u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_41;
        }
        goto LABEL_19;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_19;
        }
        goto LABEL_45;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100FA9308( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A40C8 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  (int)a2,  *(float *)(v5 + 24),  a3);
  }

uint64_t sub_100FA93AC(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_23;
  }

  if ((*(_BYTE *)(a1 + 32) & 1) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A40C8 + 8);
    }
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v6, a2);
    int v8 = (int)v7;
    else {
      int v9 = 1;
    }
    int v4 = v8 + v9 + 1;
    int v3 = *(_DWORD *)(a1 + 32);
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
      goto LABEL_18;
    }
  }

  unint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
  if ((v10 & 0x80000000) != 0)
  {
    int v11 = 11;
  }

  else if (v10 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
    int v3 = *(_DWORD *)(a1 + 32);
  }

  else
  {
    int v11 = 2;
  }

  v4 += v11;
LABEL_18:
  unsigned int v12 = v4 + 5;
  if ((v3 & 4) == 0) {
    unsigned int v12 = v4;
  }
  if ((v3 & 8) != 0) {
    uint64_t result = v12 + 5;
  }
  else {
    uint64_t result = v12;
  }
LABEL_23:
  *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = result;
  return result;
}

float sub_100FA9478(uint64_t a1, void *lpsrc)
{
  return sub_100FA8E18(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA94C4()
{
  return 1LL;
}

void *sub_100FA94CC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.GnssToGpsTimeOffset");
}

float sub_100FA94DC(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v13,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  2025LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v13,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v12, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 48);
  if (!(_BYTE)v6) {
    return result;
  }
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    *(_DWORD *)(a1 + 48) |= 1u;
    uint64_t v7 = *(void **)(a1 + 8);
    if (!v7)
    {
      uint64_t v7 = operator new(0x18uLL);
      v7[1] = 0LL;
      v7[2] = 0LL;
      *uint64_t v7 = off_101890AC8;
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v7;
    }

    uint64_t v8 = *(void *)(a2 + 8);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A40D0 + 8);
    }
    float result = sub_100FA7190((uint64_t)v7, v8);
    int v6 = *(_DWORD *)(a2 + 48);
  }

  if ((v6 & 2) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 48) |= 2u;
    *(_DWORD *)(a1 + 16) = v9;
    int v6 = *(_DWORD *)(a2 + 48);
  }

  if ((v6 & 4) != 0)
  {
    float result = *(float *)(a2 + 20);
    *(_DWORD *)(a1 + 48) |= 4u;
    *(float *)(a1 + 20) = result;
    int v6 = *(_DWORD *)(a2 + 48);
    if ((v6 & 8) == 0)
    {
LABEL_15:
      if ((v6 & 0x10) == 0) {
        goto LABEL_16;
      }
      goto LABEL_23;
    }
  }

  else if ((v6 & 8) == 0)
  {
    goto LABEL_15;
  }

  float result = *(float *)(a2 + 24);
  *(_DWORD *)(a1 + 48) |= 8u;
  *(float *)(a1 + 24) = result;
  int v6 = *(_DWORD *)(a2 + 48);
  if ((v6 & 0x10) == 0)
  {
LABEL_16:
    if ((v6 & 0x20) == 0) {
      goto LABEL_17;
    }
LABEL_25:
    int v11 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) |= 0x20u;
    *(_DWORD *)(a1 + 32) = v11;
    int v6 = *(_DWORD *)(a2 + 48);
    if ((v6 & 0x40) == 0)
    {
LABEL_18:
      if ((v6 & 0x80) == 0) {
        return result;
      }
      goto LABEL_19;
    }

    goto LABEL_26;
  }

void sub_100FA9698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FA96B0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101890D20;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A40D0 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FA9704(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100FA9718()
{
  unsigned __int8 v0 = operator new(0x38uLL);
  *unsigned __int8 v0 = &off_101890D20;
  v0[1] = 0LL;
  *((_DWORD *)v0 + 4) = -1;
  double result = 0.0;
  *(void *)((char *)v0 + 20) = 0LL;
  *(void *)((char *)v0 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = 0xFFFFFFFFLL;
  *(void *)((char *)v0 + 36) = 0LL;
  *((_DWORD *)v0 + 11) = 0;
  *((_DWORD *)v0 + 12) = 0;
  return result;
}

uint64_t sub_100FA975C(uint64_t result)
{
  if (*(_BYTE *)(result + 48))
  {
    if ((*(_BYTE *)(result + 48) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 20)) {
          *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v1 + 20) = 0;
      }
    }

    *(_DWORD *)(result + 16) = -1;
    *(void *)(result + 20) = 0LL;
    *(void *)(result + 2_Block_object_dispose((const void *)(v1 - 128), 8) = 0xFFFFFFFFLL;
    *(void *)(result + 36) = 0LL;
  }

  *(_DWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  return result;
}

uint64_t sub_100FA97A4( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (unsigned int *)(a1 + 32);
  while (2)
  {
    int v6 = (char *)*((void *)this + 1);
    if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_28;
        }
        *(_DWORD *)(a1 + 48) |= 1u;
        int v9 = *(unsigned int **)(a1 + 8);
        if (!v9)
        {
          int v9 = (unsigned int *)operator new(0x18uLL);
          *((void *)v9 + 1) = 0LL;
          *((void *)v9 + 2) = 0LL;
          *(void *)int v9 = off_101890AC8;
          *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v9;
        }

        int v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v34)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v34 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        int v17 = *((_DWORD *)this + 14);
        int v18 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v17 + 1;
        if (v17 >= v18) {
          return 0LL;
        }
        int v19 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v34);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v19);
        int v21 = *((_DWORD *)this + 14);
        BOOL v22 = __OFSUB__(v21, 1);
        int v23 = v21 - 1;
        if (v23 < 0 == v22) {
          *((_DWORD *)this + 14) = v23;
        }
        unsigned int v24 = (_BYTE *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
        char v12 = v24 + 1;
        *((void *)this + 1) = v12;
        goto LABEL_40;
      case 2u:
        int v8 = TagFallback & 7;
        char v12 = (char *)*((void *)this + 1);
        unint64_t v11 = *((void *)this + 2);
LABEL_40:
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v34);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v25 = v34;
        }

        else
        {
          unsigned int v25 = *v12;
          *((void *)this + 1) = v12 + 1;
        }

        if (v25 + 1 <= 6)
        {
          *(_DWORD *)(a1 + 48) |= 2u;
          *(_DWORD *)(a1 + 16) = v25;
        }

        unint64_t v27 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v27 + 1;
LABEL_50:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v34) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 20) = v34;
        *(_DWORD *)(a1 + 48) |= 4u;
        char v28 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v28 + 1;
LABEL_54:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v34) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 24) = v34;
        *(_DWORD *)(a1 + 48) |= 8u;
        char v29 = (_BYTE *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        int v14 = v29 + 1;
        *((void *)this + 1) = v14;
LABEL_58:
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v34);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v30 = v34;
        }

        else
        {
          unsigned int v30 = *v14;
          *((void *)this + 1) = v14 + 1;
        }

        if (v30 + 1 <= 6)
        {
          *(_DWORD *)(a1 + 48) |= 0x10u;
          *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v30;
        }

        int v31 = (_BYTE *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        int v16 = v31 + 1;
        *((void *)this + 1) = v16;
LABEL_68:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result) {
            return result;
          }
          int v32 = (_BYTE *)*((void *)this + 1);
          unint64_t v15 = *((void *)this + 2);
        }

        else
        {
          *uint64_t v5 = *v16;
          int v32 = v16 + 1;
          *((void *)this + 1) = v32;
        }

        *(_DWORD *)(a1 + 48) |= 0x20u;
        *((void *)this + 1) = v32 + 1;
LABEL_76:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v34) & 1) == 0) {
          return 0LL;
        }
        *(_DWORD *)(a1 + 36) = v34;
        *(_DWORD *)(a1 + 48) |= 0x40u;
        unsigned int v33 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v33 + 1;
LABEL_80:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v34) & 1) != 0)
        {
          *(_DWORD *)(a1 + 40) = v34;
          *(_DWORD *)(a1 + 48) |= 0x80u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 5) {
          goto LABEL_50;
        }
        goto LABEL_28;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 == 5) {
          goto LABEL_54;
        }
        goto LABEL_28;
      case 5u:
        int v8 = TagFallback & 7;
        int v14 = (char *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 2);
        goto LABEL_58;
      case 6u:
        int v8 = TagFallback & 7;
        int v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_68;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 == 5) {
          goto LABEL_76;
        }
        goto LABEL_28;
      case 8u:
        int v8 = TagFallback & 7;
        if (v8 != 5) {
          goto LABEL_28;
        }
        goto LABEL_80;
      default:
        int v8 = TagFallback & 7;
LABEL_28:
        if (v8 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100FA9C3C( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 48);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A40D0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }

uint64_t sub_100FA9D50(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_40;
  }

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A40D0 + 8);
    }
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v6, a2);
    int v8 = (int)v7;
    else {
      int v9 = 1;
    }
    int v4 = v8 + v9 + 1;
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  int v4 = 0;
  if ((*(_BYTE *)(a1 + 48) & 2) != 0)
  {
LABEL_12:
    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v10 & 0x80000000) != 0)
    {
      int v11 = 11;
    }

    else if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 48);
    }

    else
    {
      int v11 = 2;
    }

    v4 += v11;
  }

float sub_100FA9E90(uint64_t a1, void *lpsrc)
{
  return sub_100FA94DC(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FA9EDC()
{
  return 1LL;
}

void *sub_100FA9EE4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.SpaceWeatherStatus");
}

void sub_100FA9EF4(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  2419LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    sub_10004AAFC(a1 + 24, *(_DWORD *)(a1 + 32) + v5);
    memcpy((void *)(*(void *)(a1 + 24) + 4LL * *(int *)(a1 + 32)), *(const void **)(a2 + 24), 4LL * *(int *)(a2 + 32));
    *(_DWORD *)(a1 + 32) += *(_DWORD *)(a2 + 32);
  }

  int v6 = *(_DWORD *)(a2 + 48);
  if (v6)
  {
    sub_10004AAFC(a1 + 40, *(_DWORD *)(a1 + 48) + v6);
    memcpy((void *)(*(void *)(a1 + 40) + 4LL * *(int *)(a1 + 48)), *(const void **)(a2 + 40), 4LL * *(int *)(a2 + 48));
    *(_DWORD *)(a1 + 48) += *(_DWORD *)(a2 + 48);
  }

  LOBYTE(v7) = *(_BYTE *)(a2 + 64);
  if (!(_BYTE)v7) {
    return;
  }
  if ((*(_BYTE *)(a2 + 64) & 1) != 0)
  {
    unsigned int v8 = *(_DWORD *)(a2 + 8);
    if (v8 >= 3) {
      sub_10127BE34();
    }
    *(_DWORD *)(a1 + 64) |= 1u;
    *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v8;
    int v7 = *(_DWORD *)(a2 + 64);
  }

  if ((v7 & 2) == 0)
  {
    if ((v7 & 4) == 0) {
      goto LABEL_13;
    }
LABEL_18:
    int v11 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 64) |= 4u;
    *(_DWORD *)(a1 + 16) = v11;
    int v7 = *(_DWORD *)(a2 + 64);
    if ((v7 & 8) == 0)
    {
LABEL_14:
      if ((v7 & 0x40) == 0) {
        return;
      }
      goto LABEL_15;
    }

    goto LABEL_19;
  }

  int v10 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 64) |= 2u;
  *(_DWORD *)(a1 + 12) = v10;
  int v7 = *(_DWORD *)(a2 + 64);
  if ((v7 & 4) != 0) {
    goto LABEL_18;
  }
LABEL_13:
  if ((v7 & 8) == 0) {
    goto LABEL_14;
  }
LABEL_19:
  int v12 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 64) |= 8u;
  *(_DWORD *)(a1 + 20) = v12;
  if ((*(_DWORD *)(a2 + 64) & 0x40) != 0)
  {
LABEL_15:
    int v9 = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a1 + 64) |= 0x40u;
    *(_DWORD *)(a1 + 56) = v9;
  }

void sub_100FAA094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FAA0AC(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101890D98;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {
    operator delete[](v2);
  }
  int v3 = (void *)*((void *)this + 3);
  if (v3) {
    operator delete[](v3);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100FAA0F4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100FAA108()
{
  unsigned __int8 v0 = (char *)operator new(0x48uLL);
  *(void *)unsigned __int8 v0 = &off_101890D98;
  double result = 0.0;
  *(_OWORD *)(v0 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 52) = 0u;
  return result;
}

uint64_t sub_100FAA140(uint64_t result)
{
  if (*(_BYTE *)(result + 64))
  {
    *(_DWORD *)(result + 56) = 0;
    *(void *)(result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_DWORD *)(result + 64) = 0;
  return result;
}

uint64_t sub_100FAA160( uint64_t a1, wireless_diagnostics::google::protobuf::io::CodedInputStream *this, unsigned int a3)
{
  uint64_t v5 = a1 + 40;
  uint64_t v6 = a1 + 24;
  int v45 = (unsigned int *)(a1 + 12);
  int v46 = (unsigned int *)(a1 + 16);
  unsigned int v47 = (unsigned int *)(a1 + 20);
LABEL_2:
  while (2)
  {
    int v7 = (char *)*((void *)this + 1);
    if ((unint64_t)v7 >= *((void *)this + 2) || *v7 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v7 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        int v10 = (char *)*((void *)this + 1);
        if ((unint64_t)v10 >= *((void *)this + 2) || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v49);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v11 = v49[0];
        }

        else
        {
          unsigned int v11 = *v10;
          *((void *)this + 1) = v10 + 1;
        }

        if (v11 <= 2)
        {
          *(_DWORD *)(a1 + 64) |= 1u;
          *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v11;
        }

        int v17 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        if ((unint64_t)v17 < v12 && *v17 == 16)
        {
          char v13 = v17 + 1;
          *((void *)this + 1) = v13;
          goto LABEL_40;
        }

        continue;
      case 2u:
        int v9 = TagFallback & 7;
        char v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
LABEL_40:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v45);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v18 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unsigned int *v45 = *v13;
          unsigned int v18 = v13 + 1;
          *((void *)this + 1) = v18;
        }

        *(_DWORD *)(a1 + 64) |= 2u;
        int v14 = v18 + 1;
        *((void *)this + 1) = v14;
LABEL_48:
        if ((unint64_t)v14 >= v12 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v46);
          if (!(_DWORD)result) {
            return result;
          }
          int v19 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          *int v46 = *v14;
          int v19 = v14 + 1;
          *((void *)this + 1) = v19;
        }

        *(_DWORD *)(a1 + 64) |= 4u;
        int v15 = v19 + 1;
        *((void *)this + 1) = v15;
LABEL_56:
        if ((unint64_t)v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v20 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          *unsigned int v47 = *v15;
          unsigned int v20 = v15 + 1;
          *((void *)this + 1) = v20;
        }

        *(_DWORD *)(a1 + 64) |= 8u;
        continue;
      case 3u:
        int v9 = TagFallback & 7;
        int v14 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_48;
      case 4u:
        int v9 = TagFallback & 7;
        int v15 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_56;
      case 5u:
        int v9 = TagFallback & 7;
        if (v9 == 2)
        {
          uint64_t result = sub_1008102E0(this, v6);
          if (!(_DWORD)result) {
            return result;
          }
          goto LABEL_80;
        }

        if (v9 != 5) {
          goto LABEL_26;
        }
        while (2)
        {
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, v49) & 1) == 0) {
            return 0LL;
          }
          unsigned int v21 = v49[0];
          int v22 = *(_DWORD *)(a1 + 32);
          if (v22 == *(_DWORD *)(a1 + 36))
          {
            sub_10004AAFC(v6, v22 + 1);
            int v22 = *(_DWORD *)(a1 + 32);
          }

          uint64_t v23 = *(void *)(a1 + 24);
          int v24 = v22 + 1;
          *(_DWORD *)(a1 + 32) = v22 + 1;
          *(_DWORD *)(v23 + 4LL * v22) = v21;
          uint64_t v25 = *((void *)this + 1);
          int v26 = *((_DWORD *)this + 4) - v25;
          if (v26 >= 1)
          {
            signed int v27 = v26 / 5u;
            int v28 = v27 >= *(_DWORD *)(a1 + 36) - v24 ? *(_DWORD *)(a1 + 36) - v24 : v27;
            if (v28 >= 1)
            {
              int v29 = 0;
              while (*(_BYTE *)v25 == 45)
              {
                int v30 = *(_DWORD *)(v25 + 1);
                if (v24 >= *(_DWORD *)(a1 + 36))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v49,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7db-11ef-98ff-a6e88e557b55/Applications/Xcode.app/Conten ts/Developer/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS18.2.Internal.sdk/usr/local/includ e/google/protobuf/repeated_field.h",  602LL);
                  uint64_t v31 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v49,  "CHECK failed: (size()) < (Capacity()): ");
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v48, v31);
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v49);
                  int v24 = *(_DWORD *)(a1 + 32);
                  uint64_t v23 = *(void *)(a1 + 24);
                }

                *(_DWORD *)(a1 + 32) = v24 + 1;
                *(_DWORD *)(v23 + 4LL * v24) = v30;
                ++v29;
                v25 += 5LL;
                ++v24;
                if (v28 == v29)
                {
                  int v29 = v28;
                  break;
                }
              }

              if (v29) {
                wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(this, 5 * v29);
              }
            }
          }

void sub_100FAA768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100FAA788( uint64_t result, unsigned int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 64);
  if ((v6 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  *(_DWORD *)(result + 8),  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 64);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 12),  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

uint64_t sub_100FAA8AC(_DWORD *a1, unsigned int a2)
{
  int v3 = *((unsigned __int8 *)a1 + 64);
  if (*((_BYTE *)a1 + 64))
  {
    if ((v3 & 1) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[2];
      if ((v5 & 0x80000000) != 0)
      {
        int v4 = 11;
        if ((v3 & 2) == 0) {
          goto LABEL_16;
        }
      }

      else if (v5 >= 0x80)
      {
        int v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
        int v3 = a1[16];
        if ((v3 & 2) == 0) {
          goto LABEL_16;
        }
      }

      else
      {
        int v4 = 2;
        if ((v3 & 2) == 0) {
          goto LABEL_16;
        }
      }
    }

    else
    {
      int v4 = 0;
      if ((v3 & 2) == 0) {
        goto LABEL_16;
      }
    }

    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[3];
    if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
      int v3 = a1[16];
    }

    else
    {
      int v7 = 2;
    }

    v4 += v7;
LABEL_16:
    if ((v3 & 4) != 0)
    {
      uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[4];
      if (v8 >= 0x80)
      {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
        int v3 = a1[16];
      }

      else
      {
        int v9 = 2;
      }

      v4 += v9;
      if ((v3 & 8) == 0) {
        goto LABEL_27;
      }
    }

    else if ((v3 & 8) == 0)
    {
LABEL_27:
      if ((v3 & 0x40) != 0) {
        int v3 = v4 + 5;
      }
      else {
        int v3 = v4;
      }
      goto LABEL_30;
    }

    int v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)a1[5];
    if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2) + 1;
      int v3 = a1[16];
    }

    else
    {
      int v11 = 2;
    }

    v4 += v11;
    goto LABEL_27;
  }

void sub_100FAA9B8(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100FAAA04()
{
  return 1LL;
}

void *sub_100FAAA0C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.IonosphereVTECModel");
}

float sub_100FAAA1C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v20,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  2684LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v20,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v19, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v20);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16),  *(_DWORD *)(a2 + 24) + *(_DWORD *)(a1 + 24));
  if (*(int *)(a2 + 24) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a2 + 16) + 8 * v6);
      int v8 = *(_DWORD *)(a1 + 28);
      uint64_t v9 = *(int *)(a1 + 24);
      if ((int)v9 >= v8)
      {
        if (v8 == *(_DWORD *)(a1 + 32))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16),  v8 + 1);
          int v8 = *(_DWORD *)(a1 + 28);
        }

        *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v8 + 1;
        int v11 = (char *)operator new(0x48uLL);
        *(void *)int v11 = &off_101890D98;
        *(_OWORD *)(v11 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
        *(_OWORD *)(v11 + 24) = 0u;
        *(_OWORD *)(v11 + 40) = 0u;
        *(_OWORD *)(v11 + 52) = 0u;
        uint64_t v12 = *(void *)(a1 + 16);
        uint64_t v13 = *(int *)(a1 + 24);
        *(_DWORD *)(a1 + 24) = v13 + 1;
        *(void *)(v12 + 8 * v13) = v11;
      }

      else
      {
        uint64_t v10 = *(void *)(a1 + 16);
        *(_DWORD *)(a1 + 24) = v9 + 1;
        int v11 = *(char **)(v10 + 8 * v9);
      }

      sub_100FA9EF4((uint64_t)v11, v7);
      ++v6;
    }

    while (v6 < *(int *)(a2 + 24));
  }

  LOBYTE(v14) = *(_BYTE *)(a2 + 52);
  if ((_BYTE)v14)
  {
    if ((*(_BYTE *)(a2 + 52) & 1) != 0)
    {
      *(_DWORD *)(a1 + 52) |= 1u;
      int v15 = *(void **)(a1 + 8);
      if (!v15)
      {
        int v15 = operator new(0x18uLL);
        v15[1] = 0LL;
        v15[2] = 0LL;
        void *v15 = off_101890AC8;
        *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v15;
      }

      uint64_t v16 = *(void *)(a2 + 8);
      if (!v16) {
        uint64_t v16 = *(void *)(qword_1019A40E0 + 8);
      }
      float result = sub_100FA7190((uint64_t)v15, v16);
      int v14 = *(_DWORD *)(a2 + 52);
    }

    if ((v14 & 4) != 0)
    {
      *(_DWORD *)(a1 + 52) |= 4u;
      int v17 = *(void **)(a1 + 40);
      if (!v17)
      {
        int v17 = operator new(0x38uLL);
        void *v17 = &off_101890D20;
        v17[1] = 0LL;
        *((_DWORD *)v17 + 4) = -1;
        *(void *)((char *)v17 + 20) = 0LL;
        *(void *)((char *)v17 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = 0xFFFFFFFFLL;
        *(void *)((char *)v17 + 36) = 0LL;
        *((_DWORD *)v17 + 11) = 0;
        *((_DWORD *)v17 + 12) = 0;
        *(void *)(a1 + 40) = v17;
      }

      uint64_t v18 = *(void *)(a2 + 40);
      if (!v18) {
        uint64_t v18 = *(void *)(qword_1019A40E0 + 40);
      }
      return sub_100FA94DC((uint64_t)v17, v18);
    }
  }

  return result;
}

void sub_100FAAC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FAAC3C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890E10;
  uint64_t v2 = (uint64_t)a1 + 16;
  sub_100FAAC7C(a1);
  sub_10008D0EC(v2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void *sub_100FAAC7C(void *result)
{
  if ((void *)qword_1019A40E0 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    float result = (void *)v1[5];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FAACDC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100FAACF0()
{
  float result = operator new(0x38uLL);
  result[5] = 0LL;
  result[6] = 0LL;
  *float result = off_101890E10;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  *((_DWORD *)result + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  return result;
}

uint64_t sub_100FAAD20(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 52);
  if ((_BYTE)v2)
  {
    if ((*(_BYTE *)(result + 52) & 1) != 0)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 20)) {
          *(void *)(v3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v3 + 20) = 0;
        int v2 = *(_DWORD *)(result + 52);
      }
    }

    if ((v2 & 4) != 0)
    {
      float result = *(void *)(result + 40);
      if (result) {
        float result = sub_100FA975C(result);
      }
    }
  }

  if (*(int *)(v1 + 24) >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v1 + 16) + 8 * v4);
      float result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32LL))(v5);
      ++v4;
    }

    while (v4 < *(int *)(v1 + 24));
  }

  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  return result;
}

uint64_t sub_100FAADB0( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16);
  while (1)
  {
    while (1)
    {
LABEL_2:
      uint64_t v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
        *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v6 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      unsigned int v8 = TagFallback >> 3;
      int v9 = TagFallback & 7;
      if (v9 != 2) {
        goto LABEL_21;
      }
      *(_DWORD *)(a1 + 52) |= 1u;
      uint64_t v10 = *(unsigned int **)(a1 + 8);
      if (!v10)
      {
        uint64_t v10 = (unsigned int *)operator new(0x18uLL);
        *((void *)v10 + 1) = 0LL;
        *((void *)v10 + 2) = 0LL;
        *(void *)uint64_t v10 = off_101890AC8;
        *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v10;
      }

      int v11 = (char *)*((void *)this + 1);
      if ((unint64_t)v11 >= *((void *)this + 2) || *v11 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v43)) {
          return 0LL;
        }
      }

      else
      {
        unsigned int v43 = *v11;
        *((void *)this + 1) = v11 + 1;
      }

      int v12 = *((_DWORD *)this + 14);
      int v13 = *((_DWORD *)this + 15);
      *((_DWORD *)this + 14) = v12 + 1;
      if (v12 >= v13) {
        return 0LL;
      }
      int v14 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v43);
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v14);
      int v16 = *((_DWORD *)this + 14);
      BOOL v17 = __OFSUB__(v16, 1);
      int v18 = v16 - 1;
      if (v18 < 0 == v17) {
        *((_DWORD *)this + 14) = v18;
      }
      char v19 = (_BYTE *)*((void *)this + 1);
      if ((unint64_t)v19 < *((void *)this + 2) && *v19 == 18)
      {
        while (1)
        {
          *((void *)this + 1) = v19 + 1;
LABEL_33:
          int v20 = *(_DWORD *)(a1 + 28);
          uint64_t v21 = *(int *)(a1 + 24);
          if ((int)v21 >= v20)
          {
            if (v20 == *(_DWORD *)(a1 + 32))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v20 + 1);
              int v20 = *(_DWORD *)(a1 + 28);
            }

            *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v20 + 1;
            uint64_t v23 = (char *)operator new(0x48uLL);
            *(void *)uint64_t v23 = &off_101890D98;
            *(_OWORD *)(v23 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
            *(_OWORD *)(v23 + 24) = 0u;
            *(_OWORD *)(v23 + 40) = 0u;
            *(_OWORD *)(v23 + 52) = 0u;
            uint64_t v24 = *(void *)(a1 + 16);
            uint64_t v25 = *(int *)(a1 + 24);
            *(_DWORD *)(a1 + 24) = v25 + 1;
            *(void *)(v24 + 8 * v25) = v23;
          }

          else
          {
            uint64_t v22 = *(void *)(a1 + 16);
            *(_DWORD *)(a1 + 24) = v21 + 1;
            uint64_t v23 = *(char **)(v22 + 8 * v21);
          }

          int v26 = (char *)*((void *)this + 1);
          if ((unint64_t)v26 >= *((void *)this + 2) || *v26 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v44)) {
              return 0LL;
            }
          }

          else
          {
            unsigned int v44 = *v26;
            *((void *)this + 1) = v26 + 1;
          }

          int v27 = *((_DWORD *)this + 14);
          int v28 = *((_DWORD *)this + 15);
          *((_DWORD *)this + 14) = v27 + 1;
          if (v27 >= v28) {
            return 0LL;
          }
          int v29 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v44);
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v29);
          int v31 = *((_DWORD *)this + 14);
          BOOL v17 = __OFSUB__(v31, 1);
          int v32 = v31 - 1;
          if (v32 < 0 == v17) {
            *((_DWORD *)this + 14) = v32;
          }
          char v19 = (_BYTE *)*((void *)this + 1);
          int v33 = *v19;
          if (v33 != 18)
          {
            if (v33 == 26)
            {
              *((void *)this + 1) = v19 + 1;
LABEL_51:
              *(_DWORD *)(a1 + 52) |= 4u;
              int v34 = *(void **)(a1 + 40);
              if (!v34)
              {
                int v34 = operator new(0x38uLL);
                *int v34 = &off_101890D20;
                v34[1] = 0LL;
                *((_DWORD *)v34 + 4) = -1;
                *(void *)((char *)v34 + 20) = 0LL;
                *(void *)((char *)v34 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = 0xFFFFFFFFLL;
                *(void *)((char *)v34 + 36) = 0LL;
                *((_DWORD *)v34 + 11) = 0;
                *((_DWORD *)v34 + 12) = 0;
                *(void *)(a1 + 40) = v34;
              }

              uint64_t v35 = (char *)*((void *)this + 1);
              if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v45)) {
                  return 0LL;
                }
              }

              else
              {
                unsigned int v45 = *v35;
                *((void *)this + 1) = v35 + 1;
              }

              int v36 = *((_DWORD *)this + 14);
              int v37 = *((_DWORD *)this + 15);
              *((_DWORD *)this + 14) = v36 + 1;
              if (v36 >= v37) {
                return 0LL;
              }
              int v38 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v45);
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v38);
              int v40 = *((_DWORD *)this + 14);
              BOOL v17 = __OFSUB__(v40, 1);
              int v41 = v40 - 1;
              if (v41 < 0 == v17) {
                *((_DWORD *)this + 14) = v41;
              }
              if (*((void *)this + 1) == *((void *)this + 2)
                && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
              {
                *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
                uint64_t result = 1LL;
                *((_BYTE *)this + 36) = 1;
                return result;
              }
            }

            goto LABEL_2;
          }
        }
      }
    }

    if (v8 == 2)
    {
      int v9 = TagFallback & 7;
      if (v9 != 2) {
        goto LABEL_21;
      }
      goto LABEL_33;
    }

    if (v8 == 3)
    {
      int v9 = TagFallback & 7;
      if (v9 == 2) {
        goto LABEL_51;
      }
    }

    else
    {
      int v9 = TagFallback & 7;
    }

uint64_t sub_100FAB1EC( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if ((*(_BYTE *)(result + 52) & 1) != 0)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A40E0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v6,  a2,  a4);
  }

  if (*(int *)(v5 + 24) >= 1)
  {
    uint64_t v7 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(*(void *)(v5 + 16) + 8 * v7++),  a2,  a4);
    while (v7 < *(int *)(v5 + 24));
  }

  if ((*(_BYTE *)(v5 + 52) & 4) != 0)
  {
    uint64_t v8 = *(void *)(v5 + 40);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A40E0 + 40);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  v8,  a2,  a4);
  }

  return result;
}

uint64_t sub_100FAB2A4(uint64_t a1, unsigned int a2)
{
  if (!*(_BYTE *)(a1 + 52))
  {
    int v3 = 0;
    goto LABEL_18;
  }

  if ((*(_BYTE *)(a1 + 52) & 1) == 0)
  {
    int v3 = 0;
    if ((*(_BYTE *)(a1 + 52) & 4) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_1019A40E0 + 8);
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v4, a2);
  int v6 = (int)v5;
  else {
    int v7 = 1;
  }
  int v3 = v6 + v7 + 1;
  if ((*(_DWORD *)(a1 + 52) & 4) != 0)
  {
LABEL_12:
    uint64_t v8 = *(void *)(a1 + 40);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A40E0 + 40);
    }
    int v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA9D50(v8, a2);
    int v10 = (int)v9;
    else {
      int v11 = 1;
    }
    v3 += v10 + v11 + 1;
  }

float sub_100FAB3C8(uint64_t a1, void *lpsrc)
{
  return sub_100FAAA1C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FAB414()
{
  return 1LL;
}

void *sub_100FAB41C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.IonosphereCorrections");
}

float sub_100FAB42C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v28,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenGnssAssistanceFile.pb.cc",  2966LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v28,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v27, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v28);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 24),  *(_DWORD *)(a2 + 32) + *(_DWORD *)(a1 + 32));
  if (*(int *)(a2 + 32) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 24) + 8 * v5);
      int v7 = *(_DWORD *)(a1 + 36);
      uint64_t v8 = *(int *)(a1 + 32);
      if ((int)v8 >= v7)
      {
        if (v7 == *(_DWORD *)(a1 + 40))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 24),  v7 + 1);
          int v7 = *(_DWORD *)(a1 + 36);
        }

        *(_DWORD *)(a1 + 36) = v7 + 1;
        int v10 = (char *)operator new(0x50uLL);
        *(void *)int v10 = off_101890C30;
        *((void *)v10 + 7) = 0LL;
        *((void *)v10 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        *((_DWORD *)v10 + 1_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        *(_OWORD *)(v10 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
        *(_OWORD *)(v10 + 24) = 0u;
        *(_OWORD *)(v10 + 36) = 0u;
        uint64_t v11 = *(void *)(a1 + 24);
        uint64_t v12 = *(int *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *(void *)(a1 + 24);
        *(_DWORD *)(a1 + 32) = v8 + 1;
        int v10 = *(char **)(v9 + 8 * v8);
      }

      sub_100FA7FC4((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 32));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 48),  *(_DWORD *)(a2 + 56) + *(_DWORD *)(a1 + 56));
  if (*(int *)(a2 + 56) >= 1)
  {
    uint64_t v14 = 0LL;
    do
    {
      uint64_t v15 = *(void *)(*(void *)(a2 + 48) + 8 * v14);
      int v16 = *(_DWORD *)(a1 + 60);
      uint64_t v17 = *(int *)(a1 + 56);
      if ((int)v17 >= v16)
      {
        if (v16 == *(_DWORD *)(a1 + 64))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 48),  v16 + 1);
          int v16 = *(_DWORD *)(a1 + 60);
        }

        *(_DWORD *)(a1 + 60) = v16 + 1;
        char v19 = operator new(0x28uLL);
        *char v19 = &off_101890CA8;
        v19[1] = 0LL;
        v19[2] = 0LL;
        v19[3] = 0LL;
        *((_DWORD *)v19 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        uint64_t v20 = *(void *)(a1 + 48);
        uint64_t v21 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v21 + 1;
        *(void *)(v20 + 8 * v21) = v19;
      }

      else
      {
        uint64_t v18 = *(void *)(a1 + 48);
        *(_DWORD *)(a1 + 56) = v17 + 1;
        char v19 = *(void **)(v18 + 8 * v17);
      }

      float result = sub_100FA8E18((uint64_t)v19, v15);
      ++v14;
    }

    while (v14 < *(int *)(a2 + 56));
  }

  LOBYTE(v22) = *(_BYTE *)(a2 + 76);
  if ((_BYTE)v22)
  {
    if ((*(_BYTE *)(a2 + 76) & 1) != 0)
    {
      *(_DWORD *)(a1 + 76) |= 1u;
      uint64_t v23 = *(void **)(a1 + 8);
      if (!v23)
      {
        uint64_t v23 = operator new(0x18uLL);
        v23[1] = 0LL;
        v23[2] = 0LL;
        *uint64_t v23 = off_101890AC8;
        *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v23;
      }

      uint64_t v24 = *(void *)(a2 + 8);
      if (!v24) {
        uint64_t v24 = *(void *)(qword_1019A40E8 + 8);
      }
      float result = sub_100FA7190((uint64_t)v23, v24);
      int v22 = *(_DWORD *)(a2 + 76);
    }

    if ((v22 & 2) != 0)
    {
      *(_DWORD *)(a1 + 76) |= 2u;
      uint64_t v25 = *(void **)(a1 + 16);
      if (!v25)
      {
        uint64_t v25 = operator new(0x38uLL);
        v25[5] = 0LL;
        v25[6] = 0LL;
        *uint64_t v25 = off_101890E10;
        v25[1] = 0LL;
        void v25[2] = 0LL;
        void v25[3] = 0LL;
        *((_DWORD *)v25 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
        *(void *)(a1 + 16) = v25;
      }

      uint64_t v26 = *(void *)(a2 + 16);
      if (!v26) {
        uint64_t v26 = *(void *)(qword_1019A40E8 + 16);
      }
      return sub_100FAAA1C((uint64_t)v25, v26);
    }
  }

  return result;
}

void sub_100FAB6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100FAB6FC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101890E88;
  uint64_t v2 = (uint64_t)a1 + 48;
  sub_100FAB748(a1);
  sub_10008D0EC(v2);
  sub_10008D0EC((uint64_t)a1 + 24);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void *sub_100FAB748(void *result)
{
  if ((void *)qword_1019A40E8 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    float result = (void *)v1[2];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FAB7A8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

uint64_t sub_100FAB7BC(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_1019A40E8;
  if (!qword_1019A40E8)
  {
    sub_100FA69BC(0LL, a2, a3, a4);
    return qword_1019A40E8;
  }

  return result;
}

double sub_100FAB7E8()
{
  unsigned __int8 v0 = (char *)operator new(0x50uLL);
  *(void *)unsigned __int8 v0 = off_101890E88;
  *((void *)v0 + 6) = 0LL;
  *((void *)v0 + 7) = 0LL;
  *((_DWORD *)v0 + 16) = 0;
  *((void *)v0 + 9) = 0LL;
  double result = 0.0;
  *(_OWORD *)(v0 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *((_DWORD *)v0 + 10) = 0;
  return result;
}

uint64_t sub_100FAB828(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 76);
  if ((_BYTE)v2)
  {
    if ((*(_BYTE *)(result + 76) & 1) != 0)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 20)) {
          *(void *)(v3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
        }
        *(_DWORD *)(v3 + 20) = 0;
        int v2 = *(_DWORD *)(result + 76);
      }
    }

    if ((v2 & 2) != 0)
    {
      double result = *(void *)(result + 16);
      if (result) {
        double result = sub_100FAAD20(result);
      }
    }
  }

  if (*(int *)(v1 + 32) >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v1 + 24) + 8 * v4);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32LL))(v5);
      ++v4;
    }

    while (v4 < *(int *)(v1 + 32));
  }

  *(_DWORD *)(v1 + 32) = 0;
  if (*(int *)(v1 + 56) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(v1 + 48) + 8 * v6);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32LL))(v7);
      ++v6;
    }

    while (v6 < *(int *)(v1 + 56));
  }

  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)(v1 + 76) = 0;
  return result;
}

uint64_t sub_100FAB8F0( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 24);
  uint64_t v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 48);
  while (1)
  {
LABEL_2:
    uint64_t v7 = (char *)*((void *)this + 1);
    if ((unint64_t)v7 < *((void *)this + 2) && (*v7 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
      *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v7 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
      goto LABEL_7;
    }

    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback) {
      return 1LL;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_20;
        }
        *(_DWORD *)(a1 + 76) |= 1u;
        int v10 = *(unsigned int **)(a1 + 8);
        if (!v10)
        {
          int v10 = (unsigned int *)operator new(0x18uLL);
          *((void *)v10 + 1) = 0LL;
          *((void *)v10 + 2) = 0LL;
          *(void *)int v10 = off_101890AC8;
          *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v10;
        }

        uint64_t v11 = (char *)*((void *)this + 1);
        if ((unint64_t)v11 >= *((void *)this + 2) || *v11 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v58)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v58 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        int v12 = *((_DWORD *)this + 14);
        int v13 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v12 + 1;
        if (v12 >= v13) {
          return 0LL;
        }
        int v14 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v58);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v14);
        int v16 = *((_DWORD *)this + 14);
        BOOL v17 = __OFSUB__(v16, 1);
        int v18 = v16 - 1;
        if (v18 < 0 == v17) {
          *((_DWORD *)this + 14) = v18;
        }
        char v19 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v19 + 1;
        goto LABEL_32;
      case 2u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_20;
        }
LABEL_32:
        *(_DWORD *)(a1 + 76) |= 2u;
        uint64_t v20 = *(void **)(a1 + 16);
        if (!v20)
        {
          uint64_t v20 = operator new(0x38uLL);
          v20[5] = 0LL;
          v20[6] = 0LL;
          *uint64_t v20 = off_101890E10;
          v20[1] = 0LL;
          v20[2] = 0LL;
          uint64_t v20[3] = 0LL;
          *((_DWORD *)v20 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
          *(void *)(a1 + 16) = v20;
        }

        uint64_t v21 = (char *)*((void *)this + 1);
        if ((unint64_t)v21 >= *((void *)this + 2) || *v21 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v58)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v58 = *v21;
          *((void *)this + 1) = v21 + 1;
        }

        int v22 = *((_DWORD *)this + 14);
        int v23 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v22 + 1;
        if (v22 >= v23) {
          return 0LL;
        }
        int v24 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v58);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v24);
        int v26 = *((_DWORD *)this + 14);
        BOOL v17 = __OFSUB__(v26, 1);
        int v27 = v26 - 1;
        if (v27 < 0 == v17) {
          *((_DWORD *)this + 14) = v27;
        }
        int v28 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v28 < *((void *)this + 2) && *v28 == 26)
        {
          do
          {
            *((void *)this + 1) = v28 + 1;
LABEL_46:
            int v29 = *(_DWORD *)(a1 + 36);
            uint64_t v30 = *(int *)(a1 + 32);
            if ((int)v30 >= v29)
            {
              if (v29 == *(_DWORD *)(a1 + 40))
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v29 + 1);
                int v29 = *(_DWORD *)(a1 + 36);
              }

              *(_DWORD *)(a1 + 36) = v29 + 1;
              int v32 = (char *)operator new(0x50uLL);
              *(void *)int v32 = off_101890C30;
              *((void *)v32 + 7) = 0LL;
              *((void *)v32 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
              *((_DWORD *)v32 + 1_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
              *(_OWORD *)(v32 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
              *(_OWORD *)(v32 + 24) = 0u;
              *(_OWORD *)(v32 + 36) = 0u;
              uint64_t v33 = *(void *)(a1 + 24);
              uint64_t v34 = *(int *)(a1 + 32);
              *(_DWORD *)(a1 + 32) = v34 + 1;
              *(void *)(v33 + 8 * v34) = v32;
            }

            else
            {
              uint64_t v31 = *(void *)(a1 + 24);
              *(_DWORD *)(a1 + 32) = v30 + 1;
              int v32 = *(char **)(v31 + 8 * v30);
            }

            uint64_t v35 = (char *)*((void *)this + 1);
            if ((unint64_t)v35 >= *((void *)this + 2) || *v35 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v58)) {
                return 0LL;
              }
            }

            else
            {
              unsigned int v58 = *v35;
              *((void *)this + 1) = v35 + 1;
            }

            int v36 = *((_DWORD *)this + 14);
            int v37 = *((_DWORD *)this + 15);
            *((_DWORD *)this + 14) = v36 + 1;
            if (v36 >= v37) {
              return 0LL;
            }
            int v38 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v58);
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v38);
            int v40 = *((_DWORD *)this + 14);
            BOOL v17 = __OFSUB__(v40, 1);
            int v41 = v40 - 1;
            if (v41 < 0 == v17) {
              *((_DWORD *)this + 14) = v41;
            }
            int v28 = (_BYTE *)*((void *)this + 1);
            int v42 = *v28;
          }

          while (v42 == 26);
          if (v42 == 34)
          {
            do
            {
              *((void *)this + 1) = v28 + 1;
LABEL_64:
              int v43 = *(_DWORD *)(a1 + 60);
              uint64_t v44 = *(int *)(a1 + 56);
              if ((int)v44 >= v43)
              {
                if (v43 == *(_DWORD *)(a1 + 64))
                {
                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v43 + 1);
                  int v43 = *(_DWORD *)(a1 + 60);
                }

                *(_DWORD *)(a1 + 60) = v43 + 1;
                int v46 = operator new(0x28uLL);
                *int v46 = &off_101890CA8;
                v46[1] = 0LL;
                v46[2] = 0LL;
                v46[3] = 0LL;
                *((_DWORD *)v46 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
                uint64_t v47 = *(void *)(a1 + 48);
                uint64_t v48 = *(int *)(a1 + 56);
                *(_DWORD *)(a1 + 56) = v48 + 1;
                *(void *)(v47 + 8 * v4_Block_object_dispose((const void *)(v1 - 128), 8) = v46;
              }

              else
              {
                uint64_t v45 = *(void *)(a1 + 48);
                *(_DWORD *)(a1 + 56) = v44 + 1;
                int v46 = *(void **)(v45 + 8 * v44);
              }

              int v49 = (char *)*((void *)this + 1);
              if ((unint64_t)v49 >= *((void *)this + 2) || *v49 < 0)
              {
                if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v58)) {
                  return 0LL;
                }
              }

              else
              {
                unsigned int v58 = *v49;
                *((void *)this + 1) = v49 + 1;
              }

              int v50 = *((_DWORD *)this + 14);
              int v51 = *((_DWORD *)this + 15);
              *((_DWORD *)this + 14) = v50 + 1;
              if (v50 >= v51) {
                return 0LL;
              }
              int v52 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v58);
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v52);
              int v54 = *((_DWORD *)this + 14);
              BOOL v17 = __OFSUB__(v54, 1);
              int v55 = v54 - 1;
              if (v55 < 0 == v17) {
                *((_DWORD *)this + 14) = v55;
              }
              int v28 = (_BYTE *)*((void *)this + 1);
              unsigned int v56 = (_BYTE *)*((void *)this + 2);
            }

            while (v28 < v56 && *v28 == 34);
            if (v28 == v56 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
            {
              *((_DWORD *)this + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
              uint64_t result = 1LL;
              *((_BYTE *)this + 36) = 1;
              return result;
            }
          }
        }

        break;
      case 3u:
        int v9 = TagFallback & 7;
        if (v9 == 2) {
          goto LABEL_46;
        }
        goto LABEL_20;
      case 4u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_20;
        }
        goto LABEL_64;
      default:
        int v9 = TagFallback & 7;
LABEL_20:
        if (v9 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100FABE74( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 76);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A40E8 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 76);
  }

  if ((v6 & 2) != 0)
  {
    uint64_t v8 = *(void *)(v5 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A40E8 + 16);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  }

  if (*(int *)(v5 + 32) >= 1)
  {
    uint64_t v9 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(void *)(*(void *)(v5 + 24) + 8 * v9++),  a2,  a4);
    while (v9 < *(int *)(v5 + 32));
  }

  if (*(int *)(v5 + 56) >= 1)
  {
    uint64_t v10 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  *(void *)(*(void *)(v5 + 48) + 8 * v10++),  a2,  a4);
    while (v10 < *(int *)(v5 + 56));
  }

  return result;
}

uint64_t sub_100FABF54(uint64_t a1, unsigned int a2)
{
  if (!*(_BYTE *)(a1 + 76))
  {
    int v3 = 0;
    goto LABEL_18;
  }

  if ((*(_BYTE *)(a1 + 76) & 1) == 0)
  {
    int v3 = 0;
    if ((*(_BYTE *)(a1 + 76) & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_1019A40E8 + 8);
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FA7498(v4, a2);
  int v6 = (int)v5;
  else {
    int v7 = 1;
  }
  int v3 = v6 + v7 + 1;
  if ((*(_DWORD *)(a1 + 76) & 2) != 0)
  {
LABEL_12:
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A40E8 + 16);
    }
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100FAB2A4(v8, a2);
    int v10 = (int)v9;
    else {
      int v11 = 1;
    }
    v3 += v10 + v11 + 1;
  }

float sub_100FAC0CC(uint64_t a1, void *lpsrc)
{
  return sub_100FAB42C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100FAC118()
{
  return 1LL;
}

void *sub_100FAC120@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.RavenGnssAssistanceFile.AssistanceFileContents");
}

double sub_100FAC134(double **a1, double **a2, double *a3, double a4)
{
  double v4 = a4 + -2592000.0;
  uint64_t v5 = *a1;
  int v6 = a1[1];
  if (*a1 == v6)
  {
    BOOL v12 = 0;
    int v7 = 0;
    double v13 = -INFINITY;
  }

  else
  {
    int v7 = 0;
    double v8 = 0.0;
    do
    {
      if (*v5 >= v4 + -0.0001 && *v5 < a4)
      {
        double v10 = v5[2];
        if (v10 > 0.0)
        {
          ++v7;
          double v8 = v8 + v10;
        }
      }

      v5 += 3;
    }

    while (v5 != v6);
    double v11 = v8 / (double)v7;
    BOOL v12 = v7 >= 1;
    if (v7 >= 1) {
      double v13 = v11;
    }
    else {
      double v13 = -INFINITY;
    }
  }

  uint64_t v14 = *a2;
  unsigned int v15 = a2[1];
  if (*a2 == v15)
  {
    double v17 = 0.0;
    if (v12)
    {
LABEL_25:
      double v19 = v17 / (double)v7;
      goto LABEL_28;
    }
  }

  else
  {
    double v16 = v4 + -0.0001;
    double v17 = 0.0;
    do
    {
      if (*v14 >= v16 && *v14 < a4) {
        double v17 = v17 + v14[2];
      }
      v14 += 3;
    }

    while (v14 != v15);
    if (v12) {
      goto LABEL_25;
    }
  }

  double v19 = -INFINITY;
LABEL_28:
  double v20 = *a3;
  if (qword_101934480 != -1) {
    dispatch_once(&qword_101934480, &stru_101891000);
  }
  uint64_t v21 = (os_log_s *)qword_101934488;
  if (os_log_type_enabled((os_log_t)qword_101934488, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134284033;
    double v32 = v20;
    __int16 v33 = 2049;
    double v34 = v13;
    __int16 v35 = 2049;
    double v36 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "CLMobility::SteadinessAdjustment::Features,allBoutsBoutDurationSecCv,%{private}.2f,dailySteps30daysMean,%{private} .2f,dailyFlights30daysMean,%{private}.2f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934480 != -1) {
      dispatch_once(&qword_101934480, &stru_101891000);
    }
    int v25 = 134284033;
    double v26 = v20;
    __int16 v27 = 2049;
    double v28 = v13;
    __int16 v29 = 2049;
    double v30 = v19;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934488,  0LL,  "CLMobility::SteadinessAdjustment::Features,allBoutsBoutDurationSecCv,%{private}.2f,dailySteps30daysMean,%{private} .2f,dailyFlights30daysMean,%{private}.2f",  &v25,  32);
    int v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "Features CLMobility::SteadinessAdjustment::extractFeatures(CFAbsoluteTime, const std::vector<HealthKitQuantitySamp le> &, const std::vector<HealthKitQuantitySample> &, const SteadinessModelContinuousWalking_Generated::Features &)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

  return v20;
}

void sub_100FAC404(id a1)
{
  qword_101934488 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Steadiness");
}

double sub_100FAC430(void *a1, uint64_t *a2)
{
  int v2 = sub_10101B9AC(a1, a2);
  *int v2 = off_101891030;
  v2[12] = 0LL;
  v2[13] = 0LL;
  v2[11] = 0LL;
  double result = 0.0;
  *(_OWORD *)(v2 + 3) = 0u;
  *(_OWORD *)(v2 + 5) = 0u;
  *(_OWORD *)(v2 + 7) = 0u;
  *(_OWORD *)((char *)v2 + 6_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  return result;
}

uint64_t sub_100FAC46C(uint64_t a1)
{
  *(void *)(a1 + 112) = 0x7FEFFFFFFFFFFFFFLL;
  return 1LL;
}

uint64_t sub_100FAC47C(uint64_t a1, __int128 *a2, double a3)
{
  *(double *)(a1 + 112) = a3;
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  __int128 v5 = a2[2];
  *(_OWORD *)(a1 + 6_Block_object_dispose((const void *)(v1 - 128), 8) = *(__int128 *)((char *)a2 + 44);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  *(_OWORD *)(a1 + 24) = v3;
  return 1LL;
}

uint64_t sub_100FAC4A4()
{
  return 1LL;
}

uint64_t sub_100FAC4AC(uint64_t a1)
{
  uint64_t v2 = sub_100D74AD8();
  *(double *)(a1 + 104) = sub_100D763AC(v2, *(double *)(a1 + 112) + -5184000.0) / 3.5;
  return 1LL;
}

void *sub_100FAC6A4(void *a1)
{
  *a1 = off_101891030;
  sub_10000AE14((uint64_t)(a1 + 11));
  *a1 = off_101868780;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_100FAC6EC(void *a1)
{
  *a1 = off_101891030;
  sub_10000AE14((uint64_t)(a1 + 11));
  *a1 = off_101868780;
  sub_10000AE14((uint64_t)(a1 + 1));
  operator delete(a1);
}

void sub_100FAC734(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

uint64_t sub_100FACB74()
{
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (!Children || (uint64_t v1 = Children, !CFArrayGetCount(Children)))
  {
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_1018910B0);
    }
    int v7 = (os_log_s *)qword_101934578;
    if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Event has no children", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_1018910B0);
    }
    LOWORD(v11[0]) = 0;
    double v8 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  17LL,  "Event has no children",  v11,  2,  v11[0]);
    goto LABEL_26;
  }

  ValueAtIndex = CFArrayGetValueAtIndex(v1, 0LL);
  uint64_t IntegerValue = IOHIDEventGetIntegerValue(ValueAtIndex, 65537LL);
  if (IOHIDEventGetIntegerValue(ValueAtIndex, 0x10000LL) != 65301 || IntegerValue != 2)
  {
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_1018910B0);
    }
    uint64_t v9 = (os_log_s *)qword_101934578;
    if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Event has no timestamp", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_1018910B0);
    }
    LOWORD(v11[0]) = 0;
    double v8 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  17LL,  "Event has no timestamp",  v11,  2,  v11[0]);
LABEL_26:
    double v10 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 0LL, "uint64_t sensorTimeFromHidChildEvent(IOHIDEventRef)", "%s\n", v8);
    if (v10 != buf) {
      free(v10);
    }
    return 0LL;
  }

  uint64_t DataValue = IOHIDEventGetDataValue(ValueAtIndex, 65540LL);
  uint64_t v5 = IOHIDEventGetIntegerValue(ValueAtIndex, 65539LL);
  if (!DataValue) {
    sub_10127BE5C();
  }
  if (v5 != 8) {
    sub_10127BFC8();
  }
  return *(void *)DataValue;
}

CFArrayRef sub_100FACE5C(uint64_t a1, _BYTE *a2)
{
  Children = (const __CFArray *)IOHIDEventGetChildren(a1);
  __int128 v4 = Children;
  *a2 = 0;
  if (Children)
  {
    if (!CFArrayGetCount(Children)) {
      return 0LL;
    }
    *a2 = 1;
    if (CFArrayGetCount(v4) < 1) {
      return 0LL;
    }
    CFIndex v5 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
      uint64_t IntegerValue = IOHIDEventGetIntegerValue(ValueAtIndex, 65537LL);
      uint64_t v8 = IOHIDEventGetIntegerValue(ValueAtIndex, 0x10000LL);
      uint64_t v9 = IOHIDEventGetIntegerValue(ValueAtIndex, 65539LL);
      uint64_t v10 = v9;
      if (v8 == 65301 && IntegerValue == 4 && v9 == 8) {
        break;
      }
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_1018910D0);
      }
      double v11 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 134284033;
        uint64_t v27 = v8;
        __int16 v28 = 2049;
        uint64_t v29 = IntegerValue;
        __int16 v30 = 2049;
        uint64_t v31 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "[AccessoryDeviceMotion] Invalid child event for BTC timestamp: usage page 0x%{private}lx usage 0x%{private}lx length %{private}zu",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_1018910D0);
        }
        int v20 = 134284033;
        uint64_t v21 = v8;
        __int16 v22 = 2049;
        uint64_t v23 = IntegerValue;
        __int16 v24 = 2049;
        uint64_t v25 = v10;
        LODWORD(v19) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  2LL,  "[AccessoryDeviceMotion] Invalid child event for BTC timestamp: usage page 0x%{private}lx usage 0x%{private}lx length %{private}zu",  &v20,  v19);
        double v13 = (uint8_t *)v12;
        sub_10029211C("Generic", 1LL, 0, 2LL, "uint64_t btcTimeFromHidChildEvent(IOHIDEventRef, BOOL &)", "%s\n", v12);
        if (v13 != buf) {
          free(v13);
        }
      }

      if (++v5 >= CFArrayGetCount(v4)) {
        return 0LL;
      }
    }

    __int128 v4 = *(const __CFArray **)IOHIDEventGetDataValue(ValueAtIndex, 65540LL);
    double v14 = sub_101171D4C();
    if (!v4)
    {
      if (v14 - *(double *)&qword_10199F958 > 1.0)
      {
        qword_10199F958 = *(void *)&v14;
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_1018910D0);
        }
        unsigned int v15 = (os_log_s *)qword_1019345C8;
        if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "[AccessoryDeviceMotion] Invalid child BTC timestamp",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345C0 != -1) {
            dispatch_once(&qword_1019345C0, &stru_1018910D0);
          }
          LOWORD(v20) = 0;
          LODWORD(v19) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  16LL,  "[AccessoryDeviceMotion] Invalid child BTC timestamp",  &v20,  v19);
          int v18 = (uint8_t *)v17;
          sub_10029211C("Generic", 1LL, 0, 0LL, "uint64_t btcTimeFromHidChildEvent(IOHIDEventRef, BOOL &)", "%s\n", v17);
          if (v18 != buf) {
            free(v18);
          }
        }
      }

      return 0LL;
    }
  }

  return v4;
}

BOOL sub_100FAD258(void *a1, IOHIDServiceClientRef service, CFStringRef key)
{
  CFTypeRef v5 = IOHIDServiceClientCopyProperty(service, key);
  if (v5)
  {
    int v6 = v5;
    CFTypeID TypeID = CFNumberGetTypeID();
    BOOL v8 = TypeID == CFGetTypeID(v6);
    BOOL v9 = v8;
    if (v8)
    {
      CFNumberGetValue((CFNumberRef)v6, kCFNumberIntType, a1);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_1018910F0);
      }
      double v11 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 138543362;
        CFStringRef v18 = key;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid type for key %{public}@!", buf, 0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_1018910F0);
        }
        int v15 = 138543362;
        CFStringRef v16 = key;
        double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Invalid type for key %{public}@!",  &v15,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL getIntFromHIDService(int *, IOHIDServiceClientRef, CFStringRef)",  "%s\n",  v14);
      }
    }

    CFRelease(v6);
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_1018910F0);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138543362;
      CFStringRef v18 = key;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning Key %{public}@ not found!",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_1018910F0);
      }
      int v15 = 138543362;
      CFStringRef v16 = key;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning Key %{public}@ not found!",  &v15,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL getIntFromHIDService(int *, IOHIDServiceClientRef, CFStringRef)",  "%s\n",  v13);
    }

    return 0LL;
  }

  return v9;
}

uint64_t sub_100FAD5AC(std::string *a1, IOHIDServiceClientRef service, CFStringRef key)
{
  CFTypeRef v5 = (const __CFData *)IOHIDServiceClientCopyProperty(service, key);
  if (v5)
  {
    int v6 = v5;
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(v6);
      CFIndex Length = CFDataGetLength(v6);
      size_t v10 = 0LL;
      if (Length)
      {
        while (BytePtr[v10])
        {
          if (Length == ++v10)
          {
            size_t v10 = Length;
            break;
          }
        }
      }

      sub_100104050(buf, BytePtr, v10);
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
      a1->__r_.__value_.__l.__cap_ = v21;
    }

    else
    {
      CFTypeID v13 = CFStringGetTypeID();
      if (v13 != CFGetTypeID(v6))
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_1018910F0);
        }
        double v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 138543362;
          *(void *)&uint8_t buf[4] = key;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Invalid type for key %{public}@!",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_1018910F0);
          }
          int v18 = 138543362;
          CFStringRef v19 = key;
          double v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Invalid type for key %{public}@!",  &v18,  12);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL getStringFromHIDService(std::string &, IOHIDServiceClientRef, CFStringRef)",  "%s\n",  v17);
        }

        uint64_t v12 = 0LL;
        goto LABEL_25;
      }

      std::string::assign(a1, (const std::string::value_type *)-[__CFData UTF8String](v6, "UTF8String"));
    }

    uint64_t v12 = 1LL;
LABEL_25:
    CFRelease(v6);
    return v12;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_1018910F0);
  }
  double v11 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = key;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#Warning Key %{public}@ not found!", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_1018910F0);
    }
    int v18 = 138543362;
    CFStringRef v19 = key;
    CFStringRef v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning Key %{public}@ not found!",  &v18,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL getStringFromHIDService(std::string &, IOHIDServiceClientRef, CFStringRef)",  "%s\n",  v16);
  }

  return 0LL;
}

os_log_s *sub_100FAD980(void *a1, IOHIDServiceClientRef service, __CFString *key, id a4)
{
  CFTypeRef v5 = key;
  CFTypeRef v7 = IOHIDServiceClientCopyProperty(service, key);
  if (v7)
  {
    BOOL v8 = (void *)v7;
    CFTypeID TypeID = CFDataGetTypeID();
    BOOL v10 = TypeID == CFGetTypeID(v8);
    double v11 = (os_log_s *)v10;
    if (v10)
    {
      if ([v8 length] == a4)
      {
        memcpy(a1, [v8 bytes], (size_t)a4);
LABEL_16:
        CFRelease(v8);
        return v11;
      }

      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_1018910F0);
      }
      double v17 = (os_log_s *)qword_1019344B8;
      p_vtable = (void **)"[data length] == expected_length";
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 68290051;
        *(_DWORD *)uint64_t v27 = 0;
        *(_WORD *)&v27[4] = 2082;
        *(void *)&v27[6] = "";
        __int16 v28 = 2082;
        uint64_t v29 = (__CFString *)-[__CFString UTF8String](v5, "UTF8String");
        __int16 v30 = 2050;
        id v31 = [v8 length];
        __int16 v32 = 2082;
        __int16 v33 = "assert";
        __int16 v34 = 2081;
        __int16 v35 = "[data length] == expected_length";
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_1018910F0);
        }
      }

      int v18 = (os_log_s *)qword_1019344B8;
      if (os_signpost_enabled((os_log_t)qword_1019344B8))
      {
        CFStringRef v19 = (__CFString *)-[__CFString UTF8String](v5, "UTF8String");
        id v20 = [v8 length];
        *(_DWORD *)std::string buf = 68290051;
        *(_DWORD *)uint64_t v27 = 0;
        *(_WORD *)&v27[4] = 2082;
        *(void *)&v27[6] = "";
        __int16 v28 = 2082;
        uint64_t v29 = v19;
        __int16 v30 = 2050;
        id v31 = v20;
        __int16 v32 = 2082;
        __int16 v33 = "assert";
        __int16 v34 = 2081;
        __int16 v35 = "[data length] == expected_length";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected length!",  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_1018910F0);
        }
      }

      double v11 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        CFTypeRef v5 = (__CFString *)-[__CFString UTF8String](v5, "UTF8String");
        id v21 = [v8 length];
        *(_DWORD *)std::string buf = 68290051;
        *(_DWORD *)uint64_t v27 = 0;
        *(_WORD *)&v27[4] = 2082;
        *(void *)&v27[6] = "";
        __int16 v28 = 2082;
        uint64_t v29 = v5;
        __int16 v30 = 2050;
        id v31 = v21;
        __int16 v32 = 2082;
        __int16 v33 = "assert";
        __int16 v34 = 2081;
        __int16 v35 = "[data length] == expected_length";
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
      }

      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Motion/IO/CLIoHidUtils.mm",  143,  "getBytesFromHIDService");
    }

    else
    {
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
      if (qword_1019344B0 == -1)
      {
LABEL_13:
        double v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 138543362;
          *(void *)uint64_t v27 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Invalid type for key %{public}@!",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          int v24 = 138543362;
          uint64_t v25 = v5;
          LODWORD(v23) = 12;
          __int16 v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Invalid type for key %{public}@!",  &v24,  v23);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL getBytesFromHIDService(void *, IOHIDServiceClientRef, CFStringRef, size_t)",  "%s\n",  v22);
        }

        goto LABEL_16;
      }
    }

    dispatch_once(&qword_1019344B0, &stru_1018910F0);
    goto LABEL_13;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_1018910F0);
  }
  uint64_t v12 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138543362;
    *(void *)uint64_t v27 = v5;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#Warning Key %{public}@ not found!", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_1018910F0);
    }
    int v24 = 138543362;
    uint64_t v25 = v5;
    CFStringRef v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning Key %{public}@ not found!",  &v24,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL getBytesFromHIDService(void *, IOHIDServiceClientRef, CFStringRef, size_t)",  "%s\n",  v16);
  }

  return 0LL;
}

void sub_100FADF64(id a1)
{
  qword_101934578 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Sensors");
}

void sub_100FADF90(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

void sub_100FADFBC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

float sub_100FADFE8(float a1, float a2)
{
  return (float)(1.0 - powf(a1 / a2, 0.19026)) * 44331.0;
}

float sub_100FAE01C(float a1, float a2)
{
  return powf((float)(a1 / -44331.0) + 1.0, 5.2559) * a2;
}

float sub_100FAE05C(float a1, float a2)
{
  return powf((float)(a1 / -44331.0) + 1.0, -5.2559) * a2;
}

void sub_100FAE09C(float a1, float a2)
{
}

float sub_100FAE0E8(float a1, float a2)
{
  return (float)((float)(a2 / 44331.0) / 0.19026) * powf(1.0 - (float)(a1 / 44331.0), -6.2559);
}

float sub_100FAE134(float a1)
{
  float v1 = a1 / 101320.0;
  float v2 = powf(a1 / 101320.0, -0.66338) * -0.077464;
  return v2 + (float)(powf(v1, -0.80974) * 0.083241);
}

float sub_100FAE194(float a1, float a2, float a3)
{
}

BOOL sub_100FAE1F4(float a1, float a2, float a3)
{
  BOOL result = 0LL;
  BOOL v6 = a2 < -180.0 || a2 > 180.0 || a1 < -90.0 || a1 > 90.0;
  if (!v6 && a3 > 0.0) {
    return fabsf(a1) >= 0.0000001 || fabsf(a2) >= 0.0000001;
  }
  return result;
}

uint64_t sub_100FAE268(uint64_t a1, __int128 *a2, double a3, double a4, double a5, double a6)
{
  *(void *)a1 = &off_101891120;
  uint64_t v11 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)v11, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v12 = *a2;
    *(void *)(v11 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }

  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = 0LL;
  *(void *)(a1 + sub_100F6A7D8(v1 + 80) = 0LL;
  if (qword_10199F960 != -1) {
    dispatch_once(&qword_10199F960, &stru_101891130);
  }
  *(double *)(a1 + 32) = a3;
  *(double *)(a1 + 40) = a4;
  *(double *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = a5;
  *(double *)(a1 + 56) = a6;
  return a1;
}

void sub_100FAE314(id a1)
{
  float v1 = operator new(0x10uLL);
  sub_1002E4C3C(v1, "CLAvengerZoneMonitor-Mutex", 1LL, 1LL);
  qword_1019A40F0 = (uint64_t)v1;
}

void sub_100FAE354(_Unwind_Exception *a1)
{
}

uint64_t sub_100FAE36C(uint64_t a1)
{
  *(void *)a1 = &off_101891120;
  float v2 = *(void **)(a1 + 64);
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = v2;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100FAE3BC(uint64_t a1)
{
  float v1 = (void *)sub_100FAE36C(a1);
  operator delete(v1);
}

void sub_100FAE3D0(uint64_t a1)
{
  __int16 v30 = 0LL;
  id v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v2 = sub_10040BAC0();
  __int128 v3 = (void *)(a1 + 8);
  if (!sub_100410C90(v2, (char *)(a1 + 8), &v30))
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_101891160);
    }
    uint64_t v27 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_FAULT))
    {
      __int16 v28 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:CLAvengerZoneMonitor: no zone information is found., fZoneName:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101891160);
      }
    }

    uint64_t v29 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v29,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLAvengerZoneMonitor: no zone information is found.",  "{msg%{public}.0s:CLAvengerZoneMonitor: no zone information is found., fZoneName:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    goto LABEL_41;
  }

  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_101891160);
  }
  __int128 v4 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v3;
    *(_WORD *)&buf[28] = 2049;
    *(void *)&buf[30] = (v31 - v30) >> 3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CLAvengerZoneMonitor: polygon information is found., fZoneName:%{private, location:es cape_only}s, zones:%{private}lu}",  buf,  0x26u);
  }

  CFTypeRef v5 = (sqlite3_int64 *)v30;
  BOOL v6 = v31;
  if (v30 != v31)
  {
    CFTypeRef v7 = (char **)(a1 + 64);
    do
    {
      *(void *)&_BYTE buf[32] = *v5;
      uint64_t v8 = sub_10040BAC0();
      if (sub_100411B10(v8, v5, (double *)buf, (double *)&buf[16], (double *)&buf[8], (double *)&buf[24]))
      {
        unint64_t v9 = *(void *)(a1 + 72);
        unint64_t v10 = *(void *)(a1 + 80);
        if (v9 >= v10)
        {
          unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - (void)*v7) >> 3);
          unint64_t v15 = v14 + 1;
          if (v14 + 1 > 0x666666666666666LL) {
            sub_100007008();
          }
          unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (void)*v7) >> 3);
          if (2 * v16 > v15) {
            unint64_t v15 = 2 * v16;
          }
          if (v16 >= 0x333333333333333LL) {
            unint64_t v17 = 0x666666666666666LL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17) {
            int v18 = (char *)sub_100100EF8(a1 + 80, v17);
          }
          else {
            int v18 = 0LL;
          }
          CFStringRef v19 = &v18[40 * v14];
          __int128 v20 = *(_OWORD *)buf;
          __int128 v21 = *(_OWORD *)&buf[16];
          *((void *)v19 + 4) = *(void *)&buf[32];
          *(_OWORD *)CFStringRef v19 = v20;
          *((_OWORD *)v19 + 1) = v21;
          uint64_t v23 = *(char **)(a1 + 64);
          __int16 v22 = *(char **)(a1 + 72);
          int v24 = v19;
          if (v22 != v23)
          {
            do
            {
              __int128 v25 = *(_OWORD *)(v22 - 40);
              __int128 v26 = *(_OWORD *)(v22 - 24);
              *((void *)v24 - 1) = *((void *)v22 - 1);
              *(_OWORD *)(v24 - 24) = v26;
              *(_OWORD *)(v24 - 40) = v25;
              v24 -= 40;
              v22 -= 40;
            }

            while (v22 != v23);
            __int16 v22 = *v7;
          }

          CFTypeID v13 = v19 + 40;
          *(void *)(a1 + 64) = v24;
          *(void *)(a1 + sub_1011C52D0(v23 - 72) = v19 + 40;
          *(void *)(a1 + sub_100F6A7D8(v1 + 80) = &v18[40 * v17];
          if (v22) {
            operator delete(v22);
          }
        }

        else
        {
          __int128 v11 = *(_OWORD *)buf;
          __int128 v12 = *(_OWORD *)&buf[16];
          *(void *)(v9 + 32) = *(void *)&buf[32];
          *(_OWORD *)unint64_t v9 = v11;
          *(_OWORD *)(v9 + 16) = v12;
          CFTypeID v13 = (char *)(v9 + 40);
        }

        *(void *)(a1 + sub_1011C52D0(v23 - 72) = v13;
      }

      ++v5;
    }

    while (v5 != (sqlite3_int64 *)v6);
LABEL_41:
    CFTypeRef v5 = (sqlite3_int64 *)v30;
  }

  if (v5)
  {
    id v31 = (char *)v5;
    operator delete(v5);
  }

void sub_100FAE7D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FAE7F8(uint64_t a1, double *a2, double *a3, double *a4, _BYTE *a5)
{
  uint64_t v18 = qword_1019A40F0;
  (*(void (**)(uint64_t))(*(void *)qword_1019A40F0 + 16LL))(qword_1019A40F0);
  __int16 v20 = 256;
  v10.n128_f64[0] = *a2;
  if (*a2 <= *(double *)(a1 + 32))
  {
    uint64_t v14 = 0LL;
    goto LABEL_19;
  }

  if (v10.n128_f64[0] < *(double *)(a1 + 40))
  {
    v10.n128_f64[0] = *a3;
    if (*a3 > *(double *)(a1 + 48) && v10.n128_f64[0] < *(double *)(a1 + 56))
    {
      uint64_t v11 = *(void *)(a1 + 64);
      uint64_t v12 = *(void *)(a1 + 72);
      if (v12 == v11)
      {
        sub_100FAE3D0(a1);
        uint64_t v11 = *(void *)(a1 + 64);
        uint64_t v12 = *(void *)(a1 + 72);
      }

      while (v11 != v12)
      {
        if (sub_100FAE978(v11, *a2, *a3))
        {
          uint64_t v13 = sub_10040BAC0();
          if (sub_10040F9FC(v13, (sqlite3_int64 *)(v11 + 32), &v17, &v16, *a2, *a3))
          {
            if (v17 || *a5 && (v10.n128_f64[0] = v16, v16 <= *a4))
            {
              uint64_t v14 = 1LL;
              goto LABEL_15;
            }
          }
        }

        v11 += 40LL;
      }
    }
  }

  uint64_t v14 = 0LL;
LABEL_15:
  if (HIBYTE(v20))
  {
    if ((_BYTE)v20)
    {
      pthread_mutex_unlock(v19);
      return v14;
    }

void sub_100FAE958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

BOOL sub_100FAE978(uint64_t a1, double a2, double a3)
{
  BOOL v6 = *(double *)a1 < a2 && *(double *)(a1 + 8) > a2 && *(double *)(a1 + 16) < a3 && *(double *)(a1 + 24) > a3;
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_101891160);
  }
  CFTypeRef v7 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 32);
    double v10 = *(double *)a1;
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(void *)(a1 + 16);
    v14[0] = 68291075;
    v14[1] = 0;
    __int16 v15 = 2082;
    double v16 = "";
    __int16 v17 = 1025;
    int v18 = v8;
    __int16 v19 = 2049;
    double v20 = v10;
    __int16 v21 = 2049;
    uint64_t v22 = v11;
    __int16 v23 = 2049;
    uint64_t v24 = v12;
    __int16 v25 = 2049;
    uint64_t v26 = v9;
    __int16 v27 = 2049;
    double v28 = a2;
    __int16 v29 = 2049;
    double v30 = a3;
    __int16 v31 = 1025;
    BOOL v32 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:isInside, fZoneId:%{private}d, minLat:%{private}f, maxLat:%{private}f , minLon:%{private}f, maxLon:%{private}f, latitude:%{private}f, longitude:%{private} f, isInsize:%{private}hhd}",  (uint8_t *)v14,  0x5Au);
  }

  return v6;
}

void sub_100FAEAF8(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

float sub_100FAEB24(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  CFTypeRef v5 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)a3 = sqlite3_column_int(v5, 0);
  BOOL v6 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v6, 1);
  CFTypeRef v7 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 16) = sqlite3_column_double(v7, 2);
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 24) = sqlite3_column_int(v8, 3);
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_int(v9, 4);
  double v10 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 32) = sqlite3_column_int(v10, 5);
  uint64_t v11 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 36) = sqlite3_column_int(v11, 6);
  uint64_t v12 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 40) = sqlite3_column_double(v12, 7);
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_BYTE *)(a3 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_int(v13, 8);
  uint64_t v14 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 112) = sqlite3_column_double(v14, 9);
  __int16 v15 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 120) = sqlite3_column_double(v15, 10);
  double v16 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v16, 11);
  __int16 v17 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 136) = sqlite3_column_double(v17, 12);
  int v18 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 16_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_int(v18, 13);
  __int16 v19 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 1sub_1011C52D0(v23 - 72) = sqlite3_column_int(v19, 14);
  double v20 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 176) = sqlite3_column_int(v20, 15);
  __int16 v21 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 1sub_100F6A7D8(v1 + 80) = sqlite3_column_int(v21, 16);
  uint64_t v22 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 184) = sqlite3_column_int(v22, 17);
  __int16 v23 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 18_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_int(v23, 18);
  uint64_t v24 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 192) = sqlite3_column_int(v24, 19);
  __int16 v25 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 196) = sqlite3_column_int(v25, 20);
  uint64_t v26 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 200) = sqlite3_column_int(v26, 21);
  __int16 v27 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 204) = sqlite3_column_int(v27, 22);
  double v28 = (sqlite3_stmt *)sub_100019240(*a2);
  float v29 = sqlite3_column_double(v28, 23);
  *(float *)(a3 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v29;
  double v30 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_BYTE *)(a3 + 212) = sqlite3_column_int(v30, 24) != 0;
  __int16 v31 = (sqlite3_stmt *)sub_100019240(*a2);
  float v32 = sqlite3_column_double(v31, 25);
  *(float *)(a3 + 216) = v32;
  __int16 v33 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_BYTE *)(a3 + 220) = sqlite3_column_int(v33, 26) != 0;
  __int16 v34 = (sqlite3_stmt *)sub_100019240(*a2);
  *(_DWORD *)(a3 + 52) = sqlite3_column_int(v34, 27);
  __int16 v35 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 56) = sqlite3_column_double(v35, 28);
  double v36 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 64) = sqlite3_column_double(v36, 29);
  int v37 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + sub_1011C52D0(v23 - 72) = sqlite3_column_double(v37, 30);
  int v38 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + sub_100F6A7D8(v1 + 80) = sqlite3_column_double(v38, 31);
  unsigned int v39 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 8_Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v39, 32);
  int v40 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 96) = sqlite3_column_double(v40, 33);
  int v41 = (sqlite3_stmt *)sub_100019240(*a2);
  *(double *)(a3 + 104) = sqlite3_column_double(v41, 34);
  int v42 = (sqlite3_stmt *)sub_100019240(*a2);
  float v43 = sqlite3_column_double(v42, 35);
  *(float *)(a3 + 144) = v43;
  uint64_t v44 = (sqlite3_stmt *)sub_100019240(*a2);
  float v45 = sqlite3_column_double(v44, 36);
  *(float *)(a3 + 14_Block_object_dispose((const void *)(v1 - 128), 8) = v45;
  int v46 = (sqlite3_stmt *)sub_100019240(*a2);
  float v47 = sqlite3_column_double(v46, 37);
  *(float *)(a3 + 152) = v47;
  uint64_t v48 = (sqlite3_stmt *)sub_100019240(*a2);
  float v49 = sqlite3_column_double(v48, 38);
  *(float *)(a3 + 156) = v49;
  int v50 = (sqlite3_stmt *)sub_100019240(*a2);
  float v51 = sqlite3_column_double(v50, 39);
  *(float *)(a3 + 160) = v51;
  int v52 = (sqlite3_stmt *)sub_100019240(*a2);
  float result = sqlite3_column_double(v52, 40);
  *(float *)(a3 + 164) = result;
  return result;
}

uint64_t sub_100FAEEA8(uint64_t a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101891190;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101891258;
  *(void *)(a1 + 52_Block_object_dispose((const void *)(v1 - 128), 8) = off_1018912A8;
  sub_100B14CF0((void *)(a1 + 536), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 552), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 568), 0LL, 0LL);
  *(_BYTE *)(a1 + 584) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  *(void *)(a1 + 160) = -[CLMobilityBoutMetricsRecorderCloudKitDelegate initWithBoutMetricsRecorderDb:]( objc_alloc(&OBJC_CLASS___CLMobilityBoutMetricsRecorderCloudKitDelegate),  "initWithBoutMetricsRecorderDb:",  a1);
  return a1;
}

void sub_100FAEF8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FAEFB8(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_101826EF8;
  *(void *)a1 = off_101891B88;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101891C30;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101891B88;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101891C30;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  uint64_t v13 = (void *)(a1 + 232);
  *(_DWORD *)(a1 + 276) = 0;
  *(void *)(a1 + 2sub_100F6A7D8(v1 + 80) = 0LL;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 257) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  int64x2_t v14 = vdupq_n_s64(0xFFF0000000000000LL);
  *(int64x2_t *)(a1 + 28_Block_object_dispose((const void *)(v1 - 128), 8) = v14;
  *(int64x2_t *)(a1 + 304) = v14;
  *(int64x2_t *)(a1 + 320) = v14;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_DWORD *)(a1 + 432) = 1071225242;
  *(_BYTE *)(a1 + 436) = 0;
  *(_DWORD *)(a1 + 440) = 1116213084;
  *(_BYTE *)(a1 + 444) = 0;
  *(_DWORD *)(a1 + 44_Block_object_dispose((const void *)(v1 - 128), 8) = 12000;
  *(void *)(a1 + 456) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 464));
  *(void *)(a1 + 464) = &off_101826EF8;
  uint64_t v15 = *(void *)(a1 + 112);
  uint64_t v31 = a1 + 112;
  (*(void (**)(void))(v15 + 16))();
  __int16 v33 = 256;
  if (a3)
  {
    *uint64_t v13 = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v31 + 24LL))(v31);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v30 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v16 = sub_1006E27E8();
  sub_100413284(v16, buf);
  __int16 v17 = (int *)(a1 + 448);
  char v18 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 448));
  __int16 v19 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  if ((v18 & 1) == 0) {
    int *v17 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101891378);
  }
  uint64_t v22 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v23 = *v17;
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891378);
    }
    int v26 = *v17;
    v34[0] = 67109120;
    v34[1] = v26;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v34);
    double v28 = (uint8_t *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(cons t char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobility::Bo utMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

  int v24 = HIBYTE(v33);
  *uint64_t v13 = 0xBFF0000000000000LL;
  if (v24)
  {
    if ((_BYTE)v33)
    {
      pthread_mutex_unlock(v32);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100FAF3BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[57] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_100FB43A0(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100FAF460()
{
}

void *sub_100FAF468(void *a1)
{
  a1[9] = off_101891C30;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101891B88;
  a1[57] = off_101826EC8;
  sub_1001B9C98(a1 + 58);
  sub_100FB43A0(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100FAF4E4(void *a1)
{
  *a1 = off_101891190;
  a1[9] = off_101891258;
  a1[66] = off_1018912A8;
  uint64_t v2 = (void *)a1[20];
  if (v2)
  {

    a1[20] = 0LL;
  }

  return sub_100FAF468(a1);
}

void *sub_100FAF538(uint64_t a1)
{
  return sub_100FAF4E4((void *)(a1 - 72));
}

void *sub_100FAF540(uint64_t a1)
{
  return sub_100FAF4E4((void *)(a1 - 528));
}

void sub_100FAF548(void *a1)
{
  float v1 = sub_100FAF4E4(a1);
  operator delete(v1);
}

void sub_100FAF55C(uint64_t a1)
{
  float v1 = sub_100FAF4E4((void *)(a1 - 72));
  operator delete(v1);
}

void sub_100FAF574(uint64_t a1)
{
  float v1 = sub_100FAF4E4((void *)(a1 - 528));
  operator delete(v1);
}

void sub_100FAF58C(void *a1, uint64_t a2)
{
  if (qword_1019346B0 != -1) {
    dispatch_once(&qword_1019346B0, &stru_101891358);
  }
  __int128 v3 = (os_log_s *)qword_1019346B8;
  if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a2 + 8);
    *(_DWORD *)std::string buf = 134349056;
    uint64_t v11 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Wrote boutMetrics to db: startTime=%{public}.2f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346B0 != -1) {
      dispatch_once(&qword_1019346B0, &stru_101891358);
    }
    uint64_t v5 = *(void *)(a2 + 8);
    int v8 = 134349056;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  2LL,  "Wrote boutMetrics to db: startTime=%{public}.2f",  &v8,  12);
    CFTypeRef v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMobility::BoutMetricsRecorderDb::addBoutMetrics(const BoutMetrics &)",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

void sub_100FAF744(uint64_t a1, uint64_t a2)
{
}

BOOL sub_100FAF74C(void *a1, int a2, void **a3, double a4, double a5)
{
  uint64_t v12 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v77);
  if ((SHIBYTE(v78) & 0x80000000) == 0)
  {
    if (HIBYTE(v78)) {
      goto LABEL_3;
    }
LABEL_48:
    sub_10127C134(v12);
LABEL_49:
    uint64_t v19 = v76;
    goto LABEL_41;
  }

  uint64_t v5 = (std::stringbuf *)v77[1];
  operator delete(v77[0]);
  if (!v5) {
    goto LABEL_48;
  }
LABEL_3:
  if (!sub_100D8A92C(a1 + 9))
  {
    int v6 = 2;
    return v6 != 2;
  }

  sub_10000CE18((uint64_t)v77);
  uint64_t v13 = sub_10000CF44(&v78, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if (__p[23] >= 0) {
    int64x2_t v14 = __p;
  }
  else {
    int64x2_t v14 = *(_BYTE **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v15 = __p[23];
  }
  else {
    uint64_t v15 = *(void *)&__p[8];
  }
  uint64_t v16 = sub_10000CF44(v13, (uint64_t)v14, v15);
  sub_10000CF44(v16, (uint64_t)" WHERE startTime > ? and startTime <= ? and boundaryType == ? ORDER BY rowid ASC", 80LL);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v17 = a1[10];
  uint64_t v5 = &v79;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v79);
  if (__p[23] >= 0) {
    char v18 = __p;
  }
  else {
    char v18 = *(char **)__p;
  }
  sub_1003C0D54(v17, v18, &v75);
  uint64_t v19 = v75;
  uint64_t v75 = 0LL;
  uint64_t v76 = v19;
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  double v20 = (sqlite3_stmt *)sub_100019240(v19);
  if (sub_1003B7480(v20, 1, a4))
  {
    unint64_t v21 = (sqlite3_stmt *)sub_100019240(v19);
    if (sub_1003B7480(v21, 2, a5))
    {
      uint64_t v22 = (sqlite3_stmt *)sub_100019240(v19);
      if (sub_1003C28BC(v22, 3, a2))
      {
        *(_DWORD *)std::string __p = 0;
        *(_DWORD *)&__p[52] = 0;
        memset(&__p[8], 0, 41);
        *(_OWORD *)&__p[56] = xmmword_101338660;
        *(int64x2_t *)&__p[72] = vdupq_n_s64(0xFFF0000000000000LL);
        *(_OWORD *)&__p[88] = *(_OWORD *)&__p[72];
        *(void *)&__p[104] = 0xFFF0000000000000LL;
        __int128 v68 = 0u;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        __int128 v71 = 0u;
        __int128 v72 = 0u;
        __int128 v73 = 0u;
        LODWORD(v74) = 1071225242;
        BYTE4(v74) = 0;
        DWORD2(v74) = 1116213084;
        BYTE12(v74) = 0;
        while (1)
        {
          int v6 = sub_1001BA11C((uint64_t)a1, &v76, (uint64_t)__p);
          if (v6) {
            break;
          }
          int v23 = a3[1];
          unint64_t v24 = (unint64_t)a3[2];
          if ((unint64_t)v23 >= v24)
          {
            uint64_t v36 = 0x6DB6DB6DB6DB6DB7LL * (((char *)v23 - (_BYTE *)*a3) >> 5);
            unint64_t v37 = v36 + 1;
            unint64_t v38 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v24 - (void)*a3) >> 5);
            if (2 * v38 > v37) {
              unint64_t v37 = 2 * v38;
            }
            if (v38 >= 0x92492492492492LL) {
              unint64_t v39 = 0x124924924924924LL;
            }
            else {
              unint64_t v39 = v37;
            }
            if (v39) {
              int v40 = (char *)sub_10001B858((uint64_t)(a3 + 2), v39);
            }
            else {
              int v40 = 0LL;
            }
            int v41 = &v40[224 * v36];
            __int128 v42 = *(_OWORD *)&__p[16];
            *(_OWORD *)int v41 = *(_OWORD *)__p;
            *((_OWORD *)v41 + 1) = v42;
            __int128 v43 = *(_OWORD *)&__p[32];
            __int128 v44 = *(_OWORD *)&__p[48];
            __int128 v45 = *(_OWORD *)&__p[80];
            *((_OWORD *)v41 + 4) = *(_OWORD *)&__p[64];
            *((_OWORD *)v41 + 5) = v45;
            *((_OWORD *)v41 + 2) = v43;
            *((_OWORD *)v41 + 3) = v44;
            __int128 v46 = *(_OWORD *)&__p[96];
            __int128 v47 = v68;
            __int128 v48 = v70;
            *((_OWORD *)v41 + _Block_object_dispose((const void *)(v1 - 128), 8) = v69;
            *((_OWORD *)v41 + 9) = v48;
            *((_OWORD *)v41 + 6) = v46;
            *((_OWORD *)v41 + 7) = v47;
            __int128 v49 = v71;
            __int128 v50 = v72;
            __int128 v51 = v74;
            *((_OWORD *)v41 + 12) = v73;
            *((_OWORD *)v41 + 13) = v51;
            *((_OWORD *)v41 + 10) = v49;
            *((_OWORD *)v41 + 11) = v50;
            unsigned int v53 = (char *)*a3;
            int v52 = (char *)a3[1];
            int v54 = v41;
            if (v52 != *a3)
            {
              do
              {
                __int128 v55 = *((_OWORD *)v52 - 13);
                *(v54 - 14) = *((_OWORD *)v52 - 14);
                *(v54 - 13) = v55;
                __int128 v56 = *((_OWORD *)v52 - 12);
                __int128 v57 = *((_OWORD *)v52 - 11);
                __int128 v58 = *((_OWORD *)v52 - 9);
                *(v54 - 10) = *((_OWORD *)v52 - 10);
                *(v54 - 9) = v58;
                *(v54 - 12) = v56;
                *(v54 - 11) = v57;
                __int128 v59 = *((_OWORD *)v52 - 8);
                __int128 v60 = *((_OWORD *)v52 - 7);
                __int128 v61 = *((_OWORD *)v52 - 5);
                *(v54 - 6) = *((_OWORD *)v52 - 6);
                *(v54 - 5) = v61;
                *(v54 - _Block_object_dispose((const void *)(v1 - 128), 8) = v59;
                *(v54 - 7) = v60;
                __int128 v62 = *((_OWORD *)v52 - 4);
                __int128 v63 = *((_OWORD *)v52 - 3);
                __int128 v64 = *((_OWORD *)v52 - 2);
                *(_OWORD *)((char *)v54 - 19) = *(_OWORD *)(v52 - 19);
                *(v54 - 3) = v63;
                *(v54 - 2) = v64;
                *(v54 - 4) = v62;
                v54 -= 14;
                v52 -= 224;
              }

              while (v52 != v53);
              int v52 = (char *)*a3;
            }

            __int16 v35 = v41 + 224;
            *a3 = v54;
            a3[1] = v41 + 224;
            a3[2] = &v40[224 * v39];
            if (v52) {
              operator delete(v52);
            }
          }

          else
          {
            __int128 v25 = *(_OWORD *)&__p[16];
            *int v23 = *(_OWORD *)__p;
            v23[1] = v25;
            __int128 v26 = *(_OWORD *)&__p[32];
            __int128 v27 = *(_OWORD *)&__p[48];
            __int128 v28 = *(_OWORD *)&__p[80];
            v23[4] = *(_OWORD *)&__p[64];
            v23[5] = v28;
            v23[2] = v26;
            v23[3] = v27;
            __int128 v29 = *(_OWORD *)&__p[96];
            __int128 v30 = v68;
            __int128 v31 = v70;
            v23[8] = v69;
            v23[9] = v31;
            v23[6] = v29;
            v23[7] = v30;
            __int128 v32 = v71;
            __int128 v33 = v72;
            __int128 v34 = v74;
            _BYTE v23[12] = v73;
            v23[13] = v34;
            v23[10] = v32;
            v23[11] = v33;
            __int16 v35 = v23 + 14;
          }

          a3[1] = v35;
        }

        goto LABEL_49;
      }
    }
  }

  int v6 = 2;
LABEL_41:
  uint64_t v76 = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  *(void **)((char *)v77
  uint64_t v78 = v65;
  std::streambuf::~streambuf(v5);
  std::ios::~ios(&v80);
  return v6 != 2;
}

void sub_100FAFBE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a43);
  _Unwind_Resume(a1);
}

BOOL sub_100FAFC4C(uint64_t a1, int a2, void **a3, double a4, double a5)
{
  return sub_100FAF74C((void *)(a1 - 528), a2, a3, a4, a5);
}

uint64_t sub_100FAFC54(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result)
  {
    sub_100FAFCF8(a1);
    sub_1003B59A0( *(void *)(a1 + 80),  "MobilityBoutMetricsHistory",  (const char **)&off_101891398,  (const std::string::value_type **)&off_101992C48,  0);
    *(void *)(a1 + 536) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM MobilityBoutMetricsHistory WHERE startTime >= ? ORDER BY startTime ASC");
    *(void *)(a1 + 544) = v3;
    *(void *)(a1 + 552) = sub_1003BF158( *(void *)(a1 + 80),  "\t\t\tINSERT INTO MobilityBoutMetricsHistory(\t\t\t\tstartTime, endTime, stepCount, work outType, terminationReason, numGaitMetrics, invalidGradePercentage, deviceSide, \t\t\t\twa lkingSpeed, doubleSupportPercentage, stepLength, asymmetryPercentage, \t\t\t\tsegmentsReje ctedByIsSwingStanceCycle, segmentsRejectedByIsNotRunning, segmentsRejectedByIsFeasibleWalk ingSpeed, segmentsRejectedByIsPendular, segmentsRejectedByIsSufficientVerticalTwist, segme ntsRejectedByIsCadenceConcordant, \t\t\t\twalkingSpeedRejectionStatus, doubleSupportPercen tageRejectionStatus, stepLengthRejectionStatus, asymmetryPercentageRejectionStatus, userHe ight, isHeightSet, userWeight, isWeightSet, \t\t\t\tboundaryType, cycleTimeMean, stepLengt hEntropy, stepLengthPoincareSD1, stepLengthPoincareSD2, cycleTimeEntropy, cycleTimePoincar eSD1, cycleTimePoincareSD2, stepIndexOfHarmonicityAP, stepIndexOfHarmonicityML, stepIndexO fHarmonicityVT, swingIndexOfHarmonicityAP, swingIndexOfHarmonicityML, swingIndexOfHarmonic ityVT  \t\t\t) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? , ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
    *(void *)(a1 + 560) = v4;
    uint64_t result = sub_1003BF158( *(void *)(a1 + 80),  "UPDATE MobilityBoutMetricsHistory SET \t\t\tstartTime = ?, endTime = ?, stepCount = ?, workoutType = ?, t erminationReason = ?, numGaitMetrics = ?, invalidGradePercentage = ?, deviceSide = ?, \t\t\twalkingSpeed = ?, doubleSupportPercentage = ?, stepLength = ?, asymmetryPercentage = ?, \t\t\tsegmentsRejectedByIsSwin gStanceCycle = ?, segmentsRejectedByIsNotRunning = ?, segmentsRejectedByIsFeasibleWalkingSpeed = ?, segme ntsRejectedByIsPendular = ?, segmentsRejectedByIsSufficientVerticalTwist = ?, segmentsRejectedByIsCadence Concordant = ?, \t\t\twalkingSpeedRejectionStatus = ?, doubleSupportPercentageRejectionStatus = ?, stepLe ngthRejectionStatus = ?, asymmetryPercentageRejectionStatus = ?, userHeight = ?, isHeightSet = ?, userWei ght = ?, isWeightSet = ?, boundaryType = ?, cycleTimeMean = ?, stepLengthEntropy = ?, stepLengthPoincareS D1 = ?, stepLengthPoincareSD2 = ?, cycleTimeEntropy = ?, cycleTimePoincareSD1 = ?, cycleTimePoincareSD2 = ?, stepIndexOfHarmonicityAP = ?, stepIndexOfHarmonicityML = ?, stepIndexOfHarmonicityVT = ?, swingIndexO fHarmonicityAP = ?, swingIndexOfHarmonicityML = ?, swingIndexOfHarmonicityVT = ? \t\t\tWHERE rowid = ?");
    *(void *)(a1 + 56_Block_object_dispose((const void *)(v1 - 128), 8) = result;
    *(void *)(a1 + 576) = v5;
    *(_BYTE *)(a1 + 584) = 1;
  }

  return result;
}

uint64_t sub_100FAFCF8(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "MobilityBoutMetricsHistory");
  if ((_DWORD)result)
  {
    uint64_t v3 = 0LL;
    int v4 = 0;
    int v8 = "asymmetryPercentageRejectionStatus";
    do
    {
      unint64_t v38 = v8;
      int v39 = 5;
      __int16 v40 = 0;
      char v41 = 0;
      char v42 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "MobilityBoutMetricsHistory", v8, (uint64_t)&v38) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)v34);
        uint64_t v9 = sub_10000CF44(&v35, (uint64_t)"ALTER TABLE MobilityBoutMetricsHistory ADD COLUMN ", 50LL);
        size_t v10 = strlen(v8);
        uint64_t v11 = sub_10000CF44(v9, (uint64_t)v8, v10);
        uint64_t v12 = sub_10000CF44(v11, (uint64_t)" ", 1LL);
        uint64_t v13 = (const char *)sub_1003BCC40((int)(&off_101891398)[v3 + 133]);
        size_t v14 = strlen(v13);
        uint64_t v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
        sub_10000CF44(v15, (uint64_t)";", 1LL);
        uint64_t v16 = *(void *)(a1 + 80);
        std::stringbuf::str(&v31, &v36);
        if ((v31.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v17 = &v31;
        }
        else {
          uint64_t v17 = (std::stringbuf::string_type *)v31.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v16, (char *)v17, &v29);
        uint64_t v18 = v29.__r_.__value_.__r.__words[0];
        v29.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v19 = *(void *)(a1 + 80);
        double v20 = (sqlite3_stmt *)sub_100019240(v18);
        sub_1003BB2BC(v19, v20);
        sub_10000CE18((uint64_t)&v31);
        unint64_t v21 = sub_10000CF44(&v31.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE MobilityBoutMetricsHistory SET ", 38LL);
        size_t v22 = strlen(v8);
        int v23 = sub_10000CF44(v21, (uint64_t)v8, v22);
        sub_10000CF44(v23, (uint64_t)" = 0;", 5LL);
        uint64_t v24 = *(void *)(a1 + 80);
        std::stringbuf::str(&v29, &v32);
        if ((v29.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v25 = &v29;
        }
        else {
          __int128 v25 = (std::stringbuf::string_type *)v29.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v24, (char *)v25, &v30);
        uint64_t v26 = v30;
        uint64_t v30 = 0LL;
        uint64_t v27 = *(void *)(a1 + 80);
        __int128 v28 = (sqlite3_stmt *)sub_100019240(v26);
        sub_1003BB2BC(v27, v28);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
        }
        v31.__r_.__value_.__r.__words[0] = v5;
        *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v7;
        v31.__r_.__value_.__l.__cap_ = v6;
        std::streambuf::~streambuf(&v32);
        std::ios::~ios(&v33);
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }
        v34[0] = v5;
        *(void *)((char *)v34 + *(void *)(v5 - 24)) = v7;
        std::string::size_type v35 = v6;
        std::streambuf::~streambuf(&v36);
        std::ios::~ios(&v37);
        int v4 = 1;
      }

      int v8 = (&off_101891398)[v3 + 138];
      v3 += 6LL;
    }

    while (v3 != 114);
    uint64_t result = sub_100FB0874( a1,  "MobilityBoutMetricsHistory",  (const char **)&off_101891398,  (const std::string::value_type **)&off_101992C48);
  }

  return result;
}

void sub_100FB009C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a21);
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
  }
  sub_1011F8850((uint64_t)&a59);
  _Unwind_Resume(a1);
}

void sub_100FB0134(uint64_t a1, uint64_t a2)
{
  if (sub_100D8A92C(a1 + 72))
  {
    if (*(_BYTE *)(a1 + 584) || ((*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1), *(_BYTE *)(a1 + 584)))
    {
      sub_100B14CF8((uint64_t *)(a1 + 552), v54);
      if (v54[0])
      {
        int v4 = (sqlite3_stmt *)sub_100019240(v54[0]);
        if (sub_1003B7480(v4, 1, *(double *)(a2 + 8)))
        {
          std::string::size_type v5 = (sqlite3_stmt *)sub_100019240(v54[0]);
          if (sub_1003B7480(v5, 2, *(double *)(a2 + 16)))
          {
            std::string::size_type v6 = (sqlite3_stmt *)sub_100019240(v54[0]);
            if (sub_1003C2AF0(v6, 3, *(_DWORD *)(a2 + 24)))
            {
              std::string::size_type v7 = (sqlite3_stmt *)sub_100019240(v54[0]);
              if (sub_1003C28BC(v7, 4, *(_DWORD *)(a2 + 28)))
              {
                int v8 = (sqlite3_stmt *)sub_100019240(v54[0]);
                if (sub_1003C28BC(v8, 5, *(_DWORD *)(a2 + 32)))
                {
                  uint64_t v9 = (sqlite3_stmt *)sub_100019240(v54[0]);
                  if (sub_1003C2AF0(v9, 6, *(_DWORD *)(a2 + 36)))
                  {
                    size_t v10 = (sqlite3_stmt *)sub_100019240(v54[0]);
                    if (sub_1003B7480(v10, 7, *(double *)(a2 + 40)))
                    {
                      uint64_t v11 = (sqlite3_stmt *)sub_100019240(v54[0]);
                      if (sub_1003C28BC(v11, 8, *(unsigned __int8 *)(a2 + 48)))
                      {
                        uint64_t v12 = (sqlite3_stmt *)sub_100019240(v54[0]);
                        if (sub_1003B7480(v12, 9, *(double *)(a2 + 112)))
                        {
                          uint64_t v13 = (sqlite3_stmt *)sub_100019240(v54[0]);
                          if (sub_1003B7480(v13, 10, *(double *)(a2 + 120)))
                          {
                            size_t v14 = (sqlite3_stmt *)sub_100019240(v54[0]);
                            if (sub_1003B7480(v14, 11, *(double *)(a2 + 128)))
                            {
                              uint64_t v15 = (sqlite3_stmt *)sub_100019240(v54[0]);
                              if (sub_1003B7480(v15, 12, *(double *)(a2 + 136)))
                              {
                                uint64_t v16 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                if (sub_1003C2AF0(v16, 13, *(_DWORD *)(a2 + 168)))
                                {
                                  uint64_t v17 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                  if (sub_1003C2AF0(v17, 14, *(_DWORD *)(a2 + 172)))
                                  {
                                    uint64_t v18 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                    if (sub_1003C2AF0(v18, 15, *(_DWORD *)(a2 + 176)))
                                    {
                                      uint64_t v19 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                      if (sub_1003C2AF0(v19, 16, *(_DWORD *)(a2 + 180)))
                                      {
                                        double v20 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                        if (sub_1003C2AF0(v20, 17, *(_DWORD *)(a2 + 184)))
                                        {
                                          unint64_t v21 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                          if (sub_1003C2AF0(v21, 18, *(_DWORD *)(a2 + 188)))
                                          {
                                            size_t v22 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                            if (sub_1003C2AF0(v22, 19, *(_DWORD *)(a2 + 192)))
                                            {
                                              int v23 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                              if (sub_1003C2AF0(v23, 20, *(_DWORD *)(a2 + 196)))
                                              {
                                                uint64_t v24 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                if (sub_1003C2AF0(v24, 21, *(_DWORD *)(a2 + 200)))
                                                {
                                                  __int128 v25 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                  if (sub_1003C2AF0(v25, 22, *(_DWORD *)(a2 + 204)))
                                                  {
                                                    uint64_t v26 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                    if (sub_1003B7480(v26, 23, *(float *)(a2 + 208)))
                                                    {
                                                      uint64_t v27 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                      if (sub_1003C28BC(v27, 24, *(unsigned __int8 *)(a2 + 212)))
                                                      {
                                                        __int128 v28 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                        if (sub_1003B7480(v28, 25, *(float *)(a2 + 216)))
                                                        {
                                                          std::stringbuf::string_type v29 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                          if (sub_1003C28BC(v29, 26, *(unsigned __int8 *)(a2 + 220)))
                                                          {
                                                            uint64_t v30 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                            if (sub_1003C28BC(v30, 27, *(_DWORD *)(a2 + 52)))
                                                            {
                                                              std::stringbuf::string_type v31 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                              if (sub_1003B7480(v31, 28, *(double *)(a2 + 56)))
                                                              {
                                                                std::stringbuf v32 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                if (sub_1003B7480(v32, 29, *(double *)(a2 + 64)))
                                                                {
                                                                  uint64_t v33 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                  if (sub_1003B7480(v33, 30, *(double *)(a2 + 72)))
                                                                  {
                                                                    __int128 v34 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                    if (sub_1003B7480(v34, 31, *(double *)(a2 + 80)))
                                                                    {
                                                                      std::string::size_type v35 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                      if (sub_1003B7480(v35, 32, *(double *)(a2 + 88)))
                                                                      {
                                                                        std::stringbuf v36 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                        if (sub_1003B7480( v36,  33,  *(double *)(a2 + 96)))
                                                                        {
                                                                          uint64_t v37 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                          if (sub_1003B7480( v37,  34,  *(double *)(a2 + 104)))
                                                                          {
                                                                            unint64_t v38 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                            if (sub_1003B7480( v38,  35,  *(float *)(a2 + 144)))
                                                                            {
                                                                              int v39 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                              if (sub_1003B7480( v39,  36,  *(float *)(a2 + 148)))
                                                                              {
                                                                                __int16 v40 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                                if (sub_1003B7480( v40,  37,  *(float *)(a2 + 152)))
                                                                                {
                                                                                  char v41 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                                  if (sub_1003B7480( v41,  38,  *(float *)(a2 + 156)))
                                                                                  {
                                                                                    char v42 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                                    if (sub_1003B7480( v42,  39,  *(float *)(a2 + 160)))
                                                                                    {
                                                                                      __int128 v43 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                                      if (sub_1003B7480( v43,  40,  *(float *)(a2 + 164)))
                                                                                      {
                                                                                        uint64_t v44 = *(void *)(a1 + 80);
                                                                                        __int128 v45 = (sqlite3_stmt *)sub_100019240(v54[0]);
                                                                                        sub_1003BB2BC(v44, v45);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
      {
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_101891358);
        }
        __int128 v46 = (os_log_s *)qword_1019346B8;
        if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_FAULT,  "BoutMetricsRecorderDb: failed to prepare insert #InvalidPreparedSQLStatement",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019346B0 != -1) {
            dispatch_once(&qword_1019346B0, &stru_101891358);
          }
          v53[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  17LL,  "BoutMetricsRecorderDb: failed to prepare insert #InvalidPreparedSQLStatement",  v53,  2);
          __int128 v50 = (uint8_t *)v49;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMobility::BoutMetricsRecorderDb::insertRecordUL(const BoutMetrics &, BOOL)",  "%s\n",  v49);
          if (v50 != buf) {
            free(v50);
          }
        }
      }

      uint64_t v47 = v54[0];
      v54[0] = 0LL;
      if (v47) {
        (*(void (**)(uint64_t))(*(void *)v47 + 8LL))(v47);
      }
    }

    else
    {
      if (qword_1019346B0 != -1) {
        dispatch_once(&qword_1019346B0, &stru_101891358);
      }
      __int128 v48 = (os_log_s *)qword_1019346B8;
      if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Prepare SQL statements failed", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_101891358);
        }
        LOWORD(v54[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "Prepare SQL statements failed",  v54,  2);
        int v52 = (uint8_t *)v51;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMobility::BoutMetricsRecorderDb::insertRecordUL(const BoutMetrics &, BOOL)",  "%s\n",  v51);
        if (v52 != buf) {
          free(v52);
        }
      }
    }
  }

void sub_100FB0844( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8LL))(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB0874(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891378);
    }
    int v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      uint64_t v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstrain ts(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::BoutMetrics, DataProtecti onPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    size_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      size_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      uint64_t v16 = v143;
    }
    else {
      uint64_t v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      unint64_t v21 = &__p;
    }
    else {
      unint64_t v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    size_t v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      __int128 v28 = v143;
    }
    else {
      __int128 v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    uint64_t v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v34 = &v139;
    }
    else {
      __int128 v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    std::stringbuf v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    unint64_t v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v41 = &__p;
    }
    else {
      char v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    char v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    __int128 v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v47 = &__p;
      }
      else {
        uint64_t v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      __int128 v48 = v143;
    }
    else {
      __int128 v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    __int128 v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    int v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v54 = buf;
    }
    else {
      int v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    __int128 v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v60 = buf;
    }
    else {
      __int128 v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int128 v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v69 = &__p;
    }
    else {
      __int128 v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    __int128 v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    __int128 v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v75 = &__p;
      }
      else {
        uint64_t v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    uint64_t v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      std::stringbuf v79 = &__p;
    }
    else {
      std::stringbuf v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    uint64_t v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v85 = &__p;
      }
      else {
        int v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      uint64_t v86 = v143;
    }
    else {
      uint64_t v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    uint64_t v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v95 = &__p;
    }
    else {
      int v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    __int128 v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      __int128 v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v103 = &__p;
        }
        else {
          __int128 v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        __int128 v104 = v141;
      }
      else {
        __int128 v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      __int128 v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      uint64_t v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v114 = buf;
      }
      else {
        __int128 v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      int v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v121 = &__p;
      }
      else {
        __int16 v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      uint64_t v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      __int16 v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        __int16 v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstra ints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::BoutMetrics, DataProt ectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      __int16 v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        int v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstra ints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::BoutMetrics, DataProt ectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_100FB1A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

char *sub_100FB1D2C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[111] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 11), *((void *)result + 12));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 88);
  *(void *)(a2 + 16) = *((void *)result + 13);
  return result;
}

char *sub_100FB1D58@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[39] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 2), *((void *)result + 3));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 1);
  *(void *)(a2 + 16) = *((void *)result + 4);
  return result;
}

uint64_t sub_100FB1D84(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * FROM MobilityBoutMetricsHistory ORDER BY startTime ASC LIMIT 1", &v7);
    uint64_t v8 = v7;
    int v5 = sub_1001BA11C(a1, &v8, a2);
    uint64_t v6 = v8;
    uint64_t v8 = 0LL;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    return v5 == 0;
  }

  return result;
}

void sub_100FB1E08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB1E2C(uint64_t a1, uint64_t a2)
{
  return sub_100FB1D84(a1 - 528, a2);
}

uint64_t sub_100FB1E34(uint64_t a1)
{
  return sub_1003B76B4(*(void *)(a1 + 80));
}

uint64_t sub_100FB1E3C(uint64_t a1)
{
  return sub_1003B76B4(*(void *)(a1 - 448));
}

BOOL sub_100FB1E48(uint64_t a1, uint64_t *a2, NSArray **a3)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  int v18 = 0;
  int v21 = 0;
  __int128 v19 = 0u;
  memset(v20, 0, sizeof(v20));
  __int128 v22 = xmmword_101338660;
  int64x2_t v23 = vdupq_n_s64(0xFFF0000000000000LL);
  int64x2_t v24 = v23;
  unint64_t v25 = 0xFFF0000000000000LL;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  int v32 = 1071225242;
  char v33 = 0;
  int v34 = 1116213084;
  char v35 = 0;
  int v7 = sub_1001BA11C(a1, a2, (uint64_t)&v18);
  if (!v7)
  {
    do
    {
      uint64_t v17 = 0LL;
      uint64_t v8 = -[CLSerializableMobilityBoutMetrics initWithBoutMetrics:]( objc_alloc(&OBJC_CLASS___CLSerializableMobilityBoutMetrics),  "initWithBoutMetrics:",  &v18);
      uint64_t v9 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v8,  1LL,  &v17);
      if (v17)
      {
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_101891358);
        }
        __int128 v10 = (os_log_s *)qword_1019346B8;
        if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 138412290;
          uint64_t v39 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Unable to serialize bout metrics: %@",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019346B0 != -1) {
            dispatch_once(&qword_1019346B0, &stru_101891358);
          }
          int v36 = 138412290;
          uint64_t v37 = v17;
          LODWORD(v16) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "Unable to serialize bout metrics: %@",  &v36,  v16);
          __int128 v12 = (uint8_t *)v11;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMobility::BoutMetricsRecorderDb::convertToDataBlobWithCode(const CLSqliteScopedStatement &, NSArray<NSData *> **)",  "%s\n",  v11);
          if (v12 != buf) {
            free(v12);
          }
        }
      }

      else
      {
        -[NSMutableArray addObject:](v6, "addObject:", v9);
      }

      int v13 = sub_1001BA11C(a1, a2, (uint64_t)&v18);
    }

    while (!v13);
    int v7 = v13;
  }

  uint64_t v15 = (NSArray *)-[NSMutableArray count](v6, "count");
  if (v15) {
    uint64_t v15 = +[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v6);
  }
  *a3 = v15;

  return v7 == 1;
}

BOOL sub_100FB2150(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = 0LL;
  *(void *)&double v5 = objc_opt_class(&OBJC_CLASS___CLSerializableMobilityBoutMetrics).n128_u64[0];
  id v7 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  v6,  a2,  &v13,  v5);
  uint64_t v8 = v13;
  if (v13)
  {
    if (qword_1019346B0 != -1) {
      dispatch_once(&qword_1019346B0, &stru_101891358);
    }
    uint64_t v9 = (os_log_s *)qword_1019346B8;
    if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v17 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Unable to deserialize bout metrics: %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346B0 != -1) {
        dispatch_once(&qword_1019346B0, &stru_101891358);
      }
      int v14 = 138412290;
      uint64_t v15 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "Unable to deserialize bout metrics: %@",  &v14,  12);
      uint64_t v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMobility::BoutMetricsRecorderDb::dataBlobToEntry(NSData *, BoutMetrics &)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  else
  {
    [v7 getBoutMetrics:a3];
  }

  return v8 == 0;
}

uint64_t sub_100FB2348(uint64_t *a1, char **a2)
{
  int v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v68);
  if ((SHIBYTE(v69) & 0x80000000) == 0)
  {
    if (HIBYTE(v69)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10127C29C(v4);
LABEL_44:
    sub_100007008();
  }

  __int128 v57 = v68[1];
  operator delete(v68[0]);
  if (!v57) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v68);
    uint64_t v6 = sub_10000CF44(&v69, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if (__p[23] >= 0) {
      id v7 = __p;
    }
    else {
      id v7 = *(_BYTE **)__p;
    }
    if (__p[23] >= 0) {
      uint64_t v8 = __p[23];
    }
    else {
      uint64_t v8 = *(void *)&__p[8];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v70);
    if (__p[23] >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = *(char **)__p;
    }
    sub_1003C0D54(v10, v11, &v66);
    uint64_t v12 = v66;
    uint64_t v66 = 0LL;
    uint64_t v67 = v12;
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    sub_1003C0454(a1[10]);
    *(_DWORD *)std::string __p = 0;
    *(_DWORD *)&__p[52] = 0;
    memset(&__p[8], 0, 41);
    *(_OWORD *)&__p[56] = xmmword_101338660;
    *(int64x2_t *)&__p[72] = vdupq_n_s64(0xFFF0000000000000LL);
    *(_OWORD *)&__p[88] = *(_OWORD *)&__p[72];
    *(void *)&__p[104] = 0xFFF0000000000000LL;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    LODWORD(v65) = 1071225242;
    BYTE4(v65) = 0;
    DWORD2(v65) = 1116213084;
    BYTE12(v65) = 0;
    while (!sub_1001BA11C((uint64_t)a1, &v67, (uint64_t)__p))
    {
      uint64_t v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v26 = 0x6DB6DB6DB6DB6DB7LL * ((v13 - *a2) >> 5);
        unint64_t v27 = v26 + 1;
        unint64_t v28 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v14 - (void)*a2) >> 5);
        if (2 * v28 > v27) {
          unint64_t v27 = 2 * v28;
        }
        if (v28 >= 0x92492492492492LL) {
          unint64_t v29 = 0x124924924924924LL;
        }
        else {
          unint64_t v29 = v27;
        }
        if (v29) {
          __int128 v30 = (char *)sub_10001B858((uint64_t)(a2 + 2), v29);
        }
        else {
          __int128 v30 = 0LL;
        }
        __int128 v31 = &v30[224 * v26];
        __int128 v32 = *(_OWORD *)&__p[16];
        *(_OWORD *)__int128 v31 = *(_OWORD *)__p;
        *((_OWORD *)v31 + 1) = v32;
        __int128 v33 = *(_OWORD *)&__p[32];
        __int128 v34 = *(_OWORD *)&__p[48];
        __int128 v35 = *(_OWORD *)&__p[80];
        *((_OWORD *)v31 + 4) = *(_OWORD *)&__p[64];
        *((_OWORD *)v31 + 5) = v35;
        *((_OWORD *)v31 + 2) = v33;
        *((_OWORD *)v31 + 3) = v34;
        __int128 v36 = *(_OWORD *)&__p[96];
        __int128 v37 = v59;
        __int128 v38 = v61;
        *((_OWORD *)v31 + _Block_object_dispose((const void *)(v1 - 128), 8) = v60;
        *((_OWORD *)v31 + 9) = v38;
        *((_OWORD *)v31 + 6) = v36;
        *((_OWORD *)v31 + 7) = v37;
        __int128 v39 = v62;
        __int128 v40 = v63;
        __int128 v41 = v65;
        *((_OWORD *)v31 + 12) = v64;
        *((_OWORD *)v31 + 13) = v41;
        *((_OWORD *)v31 + 10) = v39;
        *((_OWORD *)v31 + 11) = v40;
        int v43 = *a2;
        char v42 = a2[1];
        std::string::size_type v44 = v31;
        if (v42 != *a2)
        {
          do
          {
            __int128 v45 = *((_OWORD *)v42 - 13);
            *((_OWORD *)v44 - 14) = *((_OWORD *)v42 - 14);
            *((_OWORD *)v44 - 13) = v45;
            __int128 v46 = *((_OWORD *)v42 - 12);
            __int128 v47 = *((_OWORD *)v42 - 11);
            __int128 v48 = *((_OWORD *)v42 - 9);
            *((_OWORD *)v44 - 10) = *((_OWORD *)v42 - 10);
            *((_OWORD *)v44 - 9) = v48;
            *((_OWORD *)v44 - 12) = v46;
            *((_OWORD *)v44 - 11) = v47;
            __int128 v49 = *((_OWORD *)v42 - 8);
            __int128 v50 = *((_OWORD *)v42 - 7);
            __int128 v51 = *((_OWORD *)v42 - 5);
            *((_OWORD *)v44 - 6) = *((_OWORD *)v42 - 6);
            *((_OWORD *)v44 - 5) = v51;
            *((_OWORD *)v44 - _Block_object_dispose((const void *)(v1 - 128), 8) = v49;
            *((_OWORD *)v44 - 7) = v50;
            __int128 v52 = *((_OWORD *)v42 - 4);
            __int128 v53 = *((_OWORD *)v42 - 3);
            __int128 v54 = *((_OWORD *)v42 - 2);
            *(_OWORD *)(v44 - 19) = *(_OWORD *)(v42 - 19);
            *((_OWORD *)v44 - 3) = v53;
            *((_OWORD *)v44 - 2) = v54;
            *((_OWORD *)v44 - 4) = v52;
            v44 -= 224;
            v42 -= 224;
          }

          while (v42 != v43);
          char v42 = *a2;
        }

        unint64_t v25 = v31 + 224;
        *a2 = v44;
        a2[1] = v31 + 224;
        a2[2] = &v30[224 * v29];
        if (v42) {
          operator delete(v42);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)&__p[16];
        *(_OWORD *)uint64_t v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        __int128 v16 = *(_OWORD *)&__p[32];
        __int128 v17 = *(_OWORD *)&__p[48];
        __int128 v18 = *(_OWORD *)&__p[80];
        *((_OWORD *)v13 + 4) = *(_OWORD *)&__p[64];
        *((_OWORD *)v13 + 5) = v18;
        *((_OWORD *)v13 + 2) = v16;
        *((_OWORD *)v13 + 3) = v17;
        __int128 v19 = *(_OWORD *)&__p[96];
        __int128 v20 = v59;
        __int128 v21 = v61;
        *((_OWORD *)v13 + _Block_object_dispose((const void *)(v1 - 128), 8) = v60;
        *((_OWORD *)v13 + 9) = v21;
        *((_OWORD *)v13 + 6) = v19;
        *((_OWORD *)v13 + 7) = v20;
        __int128 v22 = v62;
        __int128 v23 = v63;
        __int128 v24 = v65;
        *((_OWORD *)v13 + 12) = v64;
        *((_OWORD *)v13 + 13) = v24;
        *((_OWORD *)v13 + 10) = v22;
        *((_OWORD *)v13 + 11) = v23;
        unint64_t v25 = v13 + 224;
      }

      a2[1] = v25;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v55 = v67;
    uint64_t v67 = 0LL;
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8LL))(v55);
    }
    *(void **)((char *)v68
    uint64_t v69 = v56;
    std::streambuf::~streambuf(&v70);
    return std::ios::~ios(&v71);
  }

  return result;
}

void sub_100FB277C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  sub_1011F8850((uint64_t)&a43);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB27E4(void *a1, void **a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v74);
  if ((SHIBYTE(v75) & 0x80000000) == 0)
  {
    if (HIBYTE(v75)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_10127C404(v10);
    goto LABEL_41;
  }

  int v4 = (std::stringbuf *)v74[1];
  operator delete(v74[0]);
  if (!v4) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v74);
  uint64_t v11 = sub_10000CF44(&v75, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if (__p[23] >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = *(_BYTE **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v13 = __p[23];
  }
  else {
    uint64_t v13 = *(void *)&__p[8];
  }
  unint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v15 = a1[10];
  int v4 = &v76;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v76);
  if (__p[23] >= 0) {
    __int128 v16 = __p;
  }
  else {
    __int128 v16 = *(char **)__p;
  }
  sub_1003C0D54(v15, v16, &v72);
  uint64_t v5 = v72;
  uint64_t v72 = 0LL;
  uint64_t v73 = v5;
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  __int128 v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    __int128 v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      *(_DWORD *)std::string __p = 0;
      *(_DWORD *)&__p[52] = 0;
      memset(&__p[8], 0, 41);
      *(_OWORD *)&__p[56] = xmmword_101338660;
      *(int64x2_t *)&__p[72] = vdupq_n_s64(0xFFF0000000000000LL);
      *(_OWORD *)&__p[88] = *(_OWORD *)&__p[72];
      *(void *)&__p[104] = 0xFFF0000000000000LL;
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      __int128 v67 = 0u;
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      __int128 v70 = 0u;
      LODWORD(v71) = 1071225242;
      BYTE4(v71) = 0;
      DWORD2(v71) = 1116213084;
      BYTE12(v71) = 0;
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v73, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        __int128 v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v33 = 0x6DB6DB6DB6DB6DB7LL * (((char *)v20 - (_BYTE *)*a2) >> 5);
          unint64_t v34 = v33 + 1;
          unint64_t v35 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v21 - (void)*a2) >> 5);
          if (2 * v35 > v34) {
            unint64_t v34 = 2 * v35;
          }
          if (v35 >= 0x92492492492492LL) {
            unint64_t v36 = 0x124924924924924LL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36) {
            __int128 v37 = (char *)sub_10001B858((uint64_t)(a2 + 2), v36);
          }
          else {
            __int128 v37 = 0LL;
          }
          __int128 v38 = &v37[224 * v33];
          __int128 v39 = *(_OWORD *)&__p[16];
          *(_OWORD *)__int128 v38 = *(_OWORD *)__p;
          *((_OWORD *)v38 + 1) = v39;
          __int128 v40 = *(_OWORD *)&__p[32];
          __int128 v41 = *(_OWORD *)&__p[48];
          __int128 v42 = *(_OWORD *)&__p[80];
          *((_OWORD *)v38 + 4) = *(_OWORD *)&__p[64];
          *((_OWORD *)v38 + 5) = v42;
          *((_OWORD *)v38 + 2) = v40;
          *((_OWORD *)v38 + 3) = v41;
          __int128 v43 = *(_OWORD *)&__p[96];
          __int128 v44 = v65;
          __int128 v45 = v67;
          *((_OWORD *)v38 + _Block_object_dispose((const void *)(v1 - 128), 8) = v66;
          *((_OWORD *)v38 + 9) = v45;
          *((_OWORD *)v38 + 6) = v43;
          *((_OWORD *)v38 + 7) = v44;
          __int128 v46 = v68;
          __int128 v47 = v69;
          __int128 v48 = v71;
          *((_OWORD *)v38 + 12) = v70;
          *((_OWORD *)v38 + 13) = v48;
          *((_OWORD *)v38 + 10) = v46;
          *((_OWORD *)v38 + 11) = v47;
          __int128 v50 = (char *)*a2;
          __int128 v49 = (char *)a2[1];
          __int128 v51 = v38;
          if (v49 != *a2)
          {
            do
            {
              __int128 v52 = *((_OWORD *)v49 - 13);
              *(v51 - 14) = *((_OWORD *)v49 - 14);
              *(v51 - 13) = v52;
              __int128 v53 = *((_OWORD *)v49 - 12);
              __int128 v54 = *((_OWORD *)v49 - 11);
              __int128 v55 = *((_OWORD *)v49 - 9);
              *(v51 - 10) = *((_OWORD *)v49 - 10);
              *(v51 - 9) = v55;
              *(v51 - 12) = v53;
              *(v51 - 11) = v54;
              __int128 v56 = *((_OWORD *)v49 - 8);
              __int128 v57 = *((_OWORD *)v49 - 7);
              __int128 v58 = *((_OWORD *)v49 - 5);
              *(v51 - 6) = *((_OWORD *)v49 - 6);
              *(v51 - 5) = v58;
              *(v51 - _Block_object_dispose((const void *)(v1 - 128), 8) = v56;
              *(v51 - 7) = v57;
              __int128 v59 = *((_OWORD *)v49 - 4);
              __int128 v60 = *((_OWORD *)v49 - 3);
              __int128 v61 = *((_OWORD *)v49 - 2);
              *(_OWORD *)((char *)v51 - 19) = *(_OWORD *)(v49 - 19);
              *(v51 - 3) = v60;
              *(v51 - 2) = v61;
              *(v51 - 4) = v59;
              v51 -= 14;
              v49 -= 224;
            }

            while (v49 != v50);
            __int128 v49 = (char *)*a2;
          }

          __int128 v32 = v38 + 224;
          *a2 = v51;
          a2[1] = v38 + 224;
          a2[2] = &v37[224 * v36];
          if (v49) {
            operator delete(v49);
          }
        }

        else
        {
          __int128 v22 = *(_OWORD *)&__p[16];
          *__int128 v20 = *(_OWORD *)__p;
          v20[1] = v22;
          __int128 v23 = *(_OWORD *)&__p[32];
          __int128 v24 = *(_OWORD *)&__p[48];
          __int128 v25 = *(_OWORD *)&__p[80];
          v20[4] = *(_OWORD *)&__p[64];
          v20[5] = v25;
          v20[2] = v23;
          uint64_t v20[3] = v24;
          __int128 v26 = *(_OWORD *)&__p[96];
          __int128 v27 = v65;
          __int128 v28 = v67;
          _WORD v20[8] = v66;
          v20[9] = v28;
          v20[6] = v26;
          v20[7] = v27;
          __int128 v29 = v68;
          __int128 v30 = v69;
          __int128 v31 = v71;
          v20[12] = v70;
          v20[13] = v31;
          v20[10] = v29;
          v20[11] = v30;
          __int128 v32 = v20 + 14;
        }

        a2[1] = v32;
      }

      uint64_t v5 = v73;
      goto LABEL_43;
    }
  }

void sub_100FB2C5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a43);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB2CC4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891378);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      id v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::string buf = 134349056;
        *(void *)__int128 v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::setDatab aseAccessible() [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891378);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    __int128 v16 = (void *)(v14 + 8 * (v13 / 0x12));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 224 * (v13 % 0x12);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x12)) + 224 * (v22 % 0x12);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101891C70);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101891C70);
        }
        LOWORD(v41) = 0;
        LODWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        __int128 v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::setDatab aseAccessible() [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 224LL;
      if (v17 - *v16 == 4032)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891378);
    }
    __int128 v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
    }

    __int128 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      unint64_t v21 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 1;
  }

  __int128 v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      __int128 v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 9LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 18LL;
  }

  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v32;
LABEL_61:
  uint64_t v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100FB33F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_100FB342C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  __int128 v4 = *(_OWORD *)(a3 + 32);
  __int128 v5 = *(_OWORD *)(a3 + 48);
  __int128 v6 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + sub_100F6A7D8(v1 + 80) = v6;
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v5;
  __int128 v7 = *(_OWORD *)(a3 + 96);
  __int128 v8 = *(_OWORD *)(a3 + 112);
  __int128 v9 = *(_OWORD *)(a3 + 144);
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(a2 + 144) = v9;
  *(_OWORD *)(a2 + 96) = v7;
  *(_OWORD *)(a2 + 112) = v8;
  __n128 result = *(__n128 *)(a3 + 160);
  __int128 v11 = *(_OWORD *)(a3 + 176);
  __int128 v12 = *(_OWORD *)(a3 + 192);
  *(_OWORD *)(a2 + 205) = *(_OWORD *)(a3 + 205);
  *(_OWORD *)(a2 + 176) = v11;
  *(_OWORD *)(a2 + 192) = v12;
  *(__n128 *)(a2 + 160) = result;
  return result;
}

id *sub_100FB3470(uint64_t a1, uint64_t a2, char a3)
{
  v59[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v59[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v59);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v41 = 0;
  int v44 = 0;
  __int128 v42 = 0u;
  memset(v43, 0, sizeof(v43));
  __int128 v45 = xmmword_101338660;
  int64x2_t v46 = vdupq_n_s64(0xFFF0000000000000LL);
  int64x2_t v47 = v46;
  unint64_t v48 = 0xFFF0000000000000LL;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  int v55 = 1071225242;
  char v56 = 0;
  int v57 = 1116213084;
  char v58 = 0;
  int v6 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 104LL))(a1, &v41);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        LOWORD(v60) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v60,  2);
        __int128 v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::sanitize AndStoreRecordUL(const T &, BOOL) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::ClassBDat aProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = *(double *)&v42;
    double v9 = v7 - *(double *)&v42;
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891378);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)std::string buf = 134349312;
        double v65 = *(double *)&v42;
        __int16 v66 = 2050;
        uint64_t v67 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        uint64_t v32 = *(void *)(a2 + 8);
        int v60 = 134349312;
        double v61 = *(double *)&v42;
        __int16 v62 = 2050;
        uint64_t v63 = v32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v60,  22);
        unint64_t v34 = (uint8_t *)v33;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::sanitize AndStoreRecordUL(const T &, BOOL) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::ClassBDat aProtectionPolicy]",  "%s\n",  v33);
        if (v34 != buf) {
          free(v34);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = *(double *)&v42;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        __int128 v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)std::string buf = 134217984;
          double v65 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101891378);
          }
          double v35 = *(double *)(a2 + 8);
          int v60 = 134217984;
          double v61 = v35;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v60));
          __int128 v37 = (uint8_t *)v36;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::saniti zeAndStoreRecordUL(const T &, BOOL) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::Class BDataProtectionPolicy]",  "%s\n",  v36);
          if (v37 != buf) {
            free(v37);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v40 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101891378);
        double v18 = v40;
      }

      double v19 = v17 - v18;
      __int128 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v65 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891378);
        }
        int v60 = 134217984;
        double v61 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v60));
        unsigned int v39 = (uint8_t *)v38;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::BoutMetrics, CLActivityDB::ClassBDataProtectionPolicy>::sanitize AndStoreRecordUL(const T &, BOOL) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::ClassBDat aProtectionPolicy]",  "%s\n",  v38);
        if (v39 != buf) {
          free(v39);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, int *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, &v41, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100FB3C54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, id a41)
{
}

uint64_t sub_100FB3C80(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_10127C56C(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  double v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100FB3EE0(void *a1, double a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10127C6D4(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100FB4118(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10127C83C(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  __int128 v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

uint64_t sub_100FB4340(uint64_t a1)
{
  return sub_100FB2CC4(a1 - 72);
}

void sub_100FB4348(id a1)
{
  qword_1019346B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Mobility");
}

void sub_100FB4374(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100FB43A0(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  __int128 v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      __int128 v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 9LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 18LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    double v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_100FB4434(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void *sub_100FB4460(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101891CA0;
  a1[9] = off_101891D58;
  sub_100B14CF0(a1 + 42, 0LL, 0LL);
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_100FB4500( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB452C(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_101826EF8;
  *(void *)a1 = off_101891F08;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101891FB0;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101891F08;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101891FB0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_DWORD *)(a1 + 256) = 12000;
  *(void *)(a1 + 264) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 272));
  *(void *)(a1 + 2sub_1011C52D0(v23 - 72) = &off_101826EF8;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  uint64_t v15 = (int *)(a1 + 256);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 256));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101891FF0);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891FF0);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    uint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100FB48D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[33] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_1000EAA04(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100FB4978()
{
}

void *sub_100FB4980(void *a1)
{
  a1[9] = off_101891FB0;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101891F08;
  a1[33] = off_101826EC8;
  sub_1001B9C98(a1 + 34);
  sub_1000EAA04(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100FB4A00(uint64_t a1)
{
  return sub_100FB4980((void *)(a1 - 72));
}

void sub_100FB4A08(void *a1)
{
  float v1 = sub_100FB4980(a1);
  operator delete(v1);
}

void sub_100FB4A1C(uint64_t a1)
{
  float v1 = sub_100FB4980((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100FB4A34(uint64_t *a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100B14CF8(a1 + 42, &v13);
  unint64_t v5 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v5, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v6 = a1[10];
    double v7 = (sqlite3_stmt *)sub_100019240(v13);
    sub_1003BB2BC(v6, v7);
    uint64_t v8 = (*(int (**)(uint64_t *))(*a1 + 152))(a1);
  }

  else
  {
    uint64_t v8 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v9 = a1[10];
  else {
    uint64_t v10 = *(void *)(v9 + 88);
  }
  sub_1003C1EC0(v9, v10);
  uint64_t v11 = v13;
  uint64_t v13 = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  return v8;
}

void sub_100FB4B3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB4B60(uint64_t a1, uint64_t a2)
{
  return sub_100FB4A34((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_100FB4B68(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from MaxMetsHistory ORDER BY startTime ASC", &v19);
    uint64_t v5 = v19;
    uint64_t v21 = v19;
    sub_1003C0454(*(void *)(a1 + 80));
    while (!sub_100FB4D18(&v21, (uint64_t)&v19))
    {
      uint64_t v6 = a2[1];
      unint64_t v7 = (unint64_t)a2[2];
      if ((unint64_t)v6 >= v7)
      {
        uint64_t v9 = (v6 - *a2) >> 5;
        unint64_t v10 = v9 + 1;
        uint64_t v11 = v7 - (void)*a2;
        if (v11 >> 4 > v10) {
          unint64_t v10 = v11 >> 4;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12) {
          uint64_t v13 = (char *)sub_10000835C((uint64_t)(a2 + 2), v12);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = &v13[32 * v9];
        *(_OWORD *)uint64_t v14 = v19;
        *((_OWORD *)v14 + 1) = v20;
        char v16 = *a2;
        uint64_t v15 = a2[1];
        uint64_t v17 = v14;
        if (v15 != *a2)
        {
          do
          {
            __int128 v18 = *((_OWORD *)v15 - 1);
            *((_OWORD *)v17 - 2) = *((_OWORD *)v15 - 2);
            *((_OWORD *)v17 - 1) = v18;
            v17 -= 32;
            v15 -= 32;
          }

          while (v15 != v16);
          uint64_t v15 = *a2;
        }

        uint64_t v8 = v14 + 32;
        *a2 = v17;
        a2[1] = v14 + 32;
        a2[2] = &v13[32 * v12];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *(_OWORD *)uint64_t v6 = v19;
        *((_OWORD *)v6 + 1) = v20;
        uint64_t v8 = v6 + 32;
      }

      a2[1] = v8;
    }

    uint64_t result = sub_1003C05BC(*(void *)(a1 + 80));
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100FB4CF0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB4D18(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v6, 0);
  unint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v7, 1);
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 16) = sqlite3_column_double(v8, 2);
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(*a1);
  double v10 = sqlite3_column_double(v9, 3);
  uint64_t result = 0LL;
  *(double *)(a2 + 24) = v10;
  return result;
}

uint64_t sub_100FB4DBC(uint64_t a1)
{
  uint64_t v3 = v8;
  unint64_t v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100FB4E5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB4E80(uint64_t a1)
{
  return sub_100FB4DBC(a1 - 72);
}

uint64_t sub_100FB4E88(uint64_t a1, char **a2, double a3, double a4)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a2[1] = *a2;
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM MaxMetsHistory WHERE endTime > ? and startTime <= ? ORDER BY startTime ASC",  buf);
    uint64_t v8 = *(void *)buf;
    v32[0] = *(void *)buf;
    if (*(void *)buf)
    {
      uint64_t v9 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
      if (sub_1003B7480(v9, 1, a3))
      {
        double v10 = (sqlite3_stmt *)sub_100019240(v8);
        if (sub_1003B7480(v10, 2, a4))
        {
          while (!sub_100FB4D18(v32, (uint64_t)buf))
          {
            uint64_t v11 = a2[1];
            unint64_t v12 = (unint64_t)a2[2];
            if ((unint64_t)v11 >= v12)
            {
              uint64_t v14 = (v11 - *a2) >> 5;
              unint64_t v15 = v14 + 1;
              uint64_t v16 = v12 - (void)*a2;
              if (v16 >> 4 > v15) {
                unint64_t v15 = v16 >> 4;
              }
              else {
                unint64_t v17 = v15;
              }
              if (v17) {
                __int128 v18 = (char *)sub_10000835C((uint64_t)(a2 + 2), v17);
              }
              else {
                __int128 v18 = 0LL;
              }
              __int128 v19 = &v18[32 * v14];
              *(_OWORD *)__int128 v19 = *(_OWORD *)buf;
              *((_OWORD *)v19 + 1) = v34;
              uint64_t v21 = *a2;
              __int128 v20 = a2[1];
              int v22 = v19;
              if (v20 != *a2)
              {
                do
                {
                  __int128 v23 = *((_OWORD *)v20 - 1);
                  *((_OWORD *)v22 - 2) = *((_OWORD *)v20 - 2);
                  *((_OWORD *)v22 - 1) = v23;
                  v22 -= 32;
                  v20 -= 32;
                }

                while (v20 != v21);
                __int128 v20 = *a2;
              }

              uint64_t v13 = v19 + 32;
              *a2 = v22;
              a2[1] = v19 + 32;
              a2[2] = &v18[32 * v17];
              if (v20) {
                operator delete(v20);
              }
            }

            else
            {
              *(_OWORD *)uint64_t v11 = *(_OWORD *)buf;
              *((_OWORD *)v11 + 1) = v34;
              uint64_t v13 = v11 + 32;
            }

            a2[1] = v13;
          }
        }
      }

      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
      return 100LL;
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101891DE8);
      }
      uint64_t v26 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "MaxMetsRecorderDb: failed to prepare queryInTimeRange #InvalidPreparedSQLStatement",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101891DE8);
        }
        v31[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "MaxMetsRecorderDb: failed to prepare queryInTimeRange #InvalidPreparedSQLStatement",  v31,  2);
        __int128 v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLMaxMetsRecorderDb::queryInTimeRange(const CFAbsoluteTime, const CFAbsoluteTime, std::vector<MaxMets> &) const",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      return 112LL;
    }
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101891DE8);
    }
    int v24 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "MaxMetsHistory, DB not accessible", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101891DE8);
      }
      LOWORD(v32[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "MaxMetsHistory, DB not accessible",  v32,  2);
      uint64_t v28 = (uint8_t *)v27;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLMaxMetsRecorderDb::queryInTimeRange(const CFAbsoluteTime, const CFAbsoluteTime, std::vector<MaxMets> &) const",  "%s\n",  v27);
      if (v28 != buf) {
        free(v28);
      }
    }

    return 109LL;
  }

void sub_100FB52E0(_Unwind_Exception *a1)
{
}

uint64_t sub_100FB530C(uint64_t *a1)
{
  uint64_t result = sub_1003C1048(a1[10]);
  if ((_DWORD)result)
  {
    sub_100FB5374((uint64_t)a1);
    sub_1003B59A0( a1[10],  "MaxMetsHistory",  (const char **)&off_101891E08,  (const std::string::value_type **)&off_101992C58,  0);
    uint64_t result = sub_1003BF158(a1[10], "DELETE FROM MaxMetsHistory WHERE endTime < ?");
    a1[42] = result;
    a1[43] = v3;
  }

  return result;
}

uint64_t sub_100FB5374(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "MaxMetsHistory");
  if ((_DWORD)result)
  {
    double v35 = "maxMets";
    int v36 = 5;
    __int16 v37 = 0;
    char v38 = 0;
    char v39 = 0;
    if ((sub_1003BC790(*(void *)(a1 + 80), "MaxMetsHistory", "maxMets", (uint64_t)&v35) & 1) != 0)
    {
      uint64_t result = sub_100FB5B6C( a1,  "MaxMetsHistory",  (const char **)&off_101891E08,  (const std::string::value_type **)&off_101992C58);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      sub_1003C0454(*(void *)(a1 + 80));
      sub_10000CE18((uint64_t)v31);
      uint64_t v3 = sub_10000CF44(&v32, (uint64_t)"ALTER TABLE MaxMetsHistory ADD COLUMN ", 38LL);
      unint64_t v4 = sub_10000CF44(v3, (uint64_t)"maxMets", 7LL);
      int v5 = sub_10000CF44(v4, (uint64_t)" ", 1LL);
      uint64_t v6 = (const char *)sub_1003BCC40(2);
      size_t v7 = strlen(v6);
      uint64_t v8 = sub_10000CF44(v5, (uint64_t)v6, v7);
      sub_10000CF44(v8, (uint64_t)";", 1LL);
      uint64_t v9 = *(void *)(a1 + 80);
      std::stringbuf::str(&v28, &v33);
      if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v10 = &v28;
      }
      else {
        double v10 = (std::stringbuf::string_type *)v28.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v9, (char *)v10, &v26);
      uint64_t v11 = v26.__r_.__value_.__r.__words[0];
      v26.__r_.__value_.__r.__words[0] = 0LL;
      if ((char)v28.__r_.__value_.__s.__size_ < 0)
      {
        uint64_t v12 = v11;
        operator delete(v28.__r_.__value_.__l.__data_);
        uint64_t v11 = v12;
      }

      uint64_t v13 = *(void *)(a1 + 80);
      uint64_t v25 = v11;
      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v11);
      sub_1003BB2BC(v13, v14);
      sub_10000CE18((uint64_t)&v28);
      unint64_t v15 = sub_10000CF44(&v28.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE MaxMetsHistory SET ", 26LL);
      uint64_t v16 = sub_10000CF44(v15, (uint64_t)"maxMets", 7LL);
      sub_10000CF44(v16, (uint64_t)" = 0;", 5LL);
      uint64_t v17 = *(void *)(a1 + 80);
      std::stringbuf::str(&v26, &v29);
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v18 = &v26;
      }
      else {
        __int128 v18 = (std::stringbuf::string_type *)v26.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v17, (char *)v18, &v27);
      uint64_t v19 = v27;
      uint64_t v27 = 0LL;
      uint64_t v20 = *(void *)(a1 + 80);
      uint64_t v21 = (sqlite3_stmt *)sub_100019240(v19);
      sub_1003BB2BC(v20, v21);
      sub_1003C05BC(*(void *)(a1 + 80));
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
      }
      v28.__r_.__value_.__r.__words[0] = v22;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + *(void *)(v22 - 24)) = v23;
      v28.__r_.__value_.__l.__cap_ = v24;
      std::streambuf::~streambuf(&v29);
      std::ios::~ios(&v30);
      if (v25) {
        (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
      }
      v31[0] = v22;
      *(void *)((char *)v31 + *(void *)(v22 - 24)) = v23;
      std::string::size_type v32 = v24;
      std::streambuf::~streambuf(&v33);
      std::ios::~ios(&v34);
      sub_100FB5B6C( a1,  "MaxMetsHistory",  (const char **)&off_101891E08,  (const std::string::value_type **)&off_101992C58);
    }

    return sub_1003BF200(*(void *)(a1 + 80), "MaxMetsHistory");
  }

  return result;
}

void sub_100FB56CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  sub_1011F8850((uint64_t)&a55);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB5768(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM MaxMetsHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100FB57FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB581C(uint64_t a1)
{
  return sub_100FB5768(a1 - 72);
}

uint64_t sub_100FB5824(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, 1LL);
    sub_1003C0D54(a1[10], "DELETE FROM MaxMetsHistory WHERE startTime > ?", &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 8)))
    {
      uint64_t v7 = a1[10];
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
    }

    uint64_t v9 = a1[10];
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    uint64_t result = sub_1003C1EC0(v9, v10);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100FB58EC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB590C(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "UPDATE MaxMetsHistory SET startTime = startTime + ?, endTime = endTime + ?",  &v10);
    uint64_t v5 = v10;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v10);
    uint64_t result = sub_1003B7480(v6, 1, a2);
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003B7480(v7, 2, a2);
      if ((_DWORD)result)
      {
        uint64_t v8 = *(void *)(a1 + 80);
        uint64_t v9 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t result = sub_1003BB2BC(v8, v9);
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100FB59BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB59DC(uint64_t a1, double *a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO MaxMetsHistory (startTime, endTime, maxMets) VALUES (?, ?, ?)",  &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    uint64_t result = sub_1003B7480(v6, 1, a2[1]);
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003B7480(v7, 2, a2[2]);
      if ((_DWORD)result)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t result = sub_1003B7480(v8, 3, a2[3]);
        if ((_DWORD)result)
        {
          uint64_t v9 = *(void *)(a1 + 80);
          uint64_t v10 = (sqlite3_stmt *)sub_100019240(v5);
          uint64_t result = sub_1003BB2BC(v9, v10);
        }
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100FB5AA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB5AC4()
{
  return 0LL;
}

uint64_t sub_100FB5ACC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v7;
  uint64_t v8 = v7;
  uint64_t v5 = sub_100FB4D18(&v8, a2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return v5;
}

void sub_100FB5B4C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB5B6C(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891FF0);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      uint64_t v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBD ataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      uint64_t v16 = v143;
    }
    else {
      uint64_t v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    __int128 v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      uint64_t v21 = &__p;
    }
    else {
      uint64_t v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    std::string::size_type v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    std::stringbuf::string_type v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf::string_type v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      std::stringbuf::string_type v28 = v143;
    }
    else {
      std::stringbuf::string_type v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    uint64_t v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v34 = &v139;
    }
    else {
      uint64_t v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    int v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    char v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v41 = &__p;
    }
    else {
      int v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    __int128 v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    int64x2_t v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int64x2_t v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int64x2_t v47 = &__p;
      }
      else {
        int64x2_t v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      unint64_t v48 = v143;
    }
    else {
      unint64_t v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    __int128 v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v54 = buf;
    }
    else {
      __int128 v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    char v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    char v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v60 = buf;
    }
    else {
      int v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v69 = &__p;
    }
    else {
      __int128 v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    __int128 v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    __int128 v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v75 = &__p;
      }
      else {
        uint64_t v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    std::stringbuf v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      std::stringbuf v79 = &__p;
    }
    else {
      std::stringbuf v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    uint64_t v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v85 = &__p;
      }
      else {
        int v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      uint64_t v86 = v143;
    }
    else {
      uint64_t v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    uint64_t v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v95 = &__p;
    }
    else {
      int v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    __int128 v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      __int128 v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v103 = &__p;
        }
        else {
          __int128 v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        __int128 v104 = v141;
      }
      else {
        __int128 v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      __int128 v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      uint64_t v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v114 = buf;
      }
      else {
        __int128 v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      int v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v121 = &__p;
      }
      else {
        __int16 v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      uint64_t v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      __int16 v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        __int16 v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = MaxMets, DataProtectionPolicy = CLActivityDB::Cla ssBDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      __int16 v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        int v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = MaxMets, DataProtectionPolicy = CLActivityDB::Cla ssBDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_100FB6D04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FB7024(void *a1, void **a2, double a3, double a4)
{
  __int128 v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v41);
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if (HIBYTE(v42)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_10127C9A4(v10);
    goto LABEL_40;
  }

  uint64_t v4 = (std::stringbuf *)v41[1];
  operator delete(v41[0]);
  if (!v4) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v41);
  uint64_t v11 = sub_10000CF44(&v42, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(void **__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    __int128 v12 = __p;
  }
  else {
    __int128 v12 = (void **)__p[0];
  }
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v13 = BYTE7(v38);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = a1[10];
  uint64_t v4 = &v43;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v43);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v16 = (char *)__p;
  }
  else {
    uint64_t v16 = (char *)__p[0];
  }
  sub_1003C0D54(v15, v16, &v39);
  uint64_t v5 = v39;
  uint64_t v39 = 0LL;
  uint64_t v40 = v5;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    __int128 v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v40, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        signed __int8 v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v24 = ((char *)v20 - (_BYTE *)*a2) >> 5;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = v21 - (void)*a2;
          if (v26 >> 4 > v25) {
            unint64_t v25 = v26 >> 4;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            std::stringbuf::string_type v28 = (char *)sub_10000835C((uint64_t)(a2 + 2), v27);
          }
          else {
            std::stringbuf::string_type v28 = 0LL;
          }
          std::string::size_type v29 = &v28[32 * v24];
          __int128 v30 = v38;
          *(_OWORD *)std::string::size_type v29 = *(_OWORD *)__p;
          *((_OWORD *)v29 + 1) = v30;
          std::string::size_type v32 = (char *)*a2;
          __int128 v31 = (char *)a2[1];
          __int128 v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *((_OWORD *)v31 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 32;
              v31 -= 32;
            }

            while (v31 != v32);
            __int128 v31 = (char *)*a2;
          }

          int v23 = v29 + 32;
          *a2 = v33;
          a2[1] = v29 + 32;
          a2[2] = &v28[32 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = v38;
          *signed __int8 v20 = *(_OWORD *)__p;
          v20[1] = v22;
          int v23 = v20 + 2;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v40;
      goto LABEL_42;
    }
  }

void sub_100FB7328( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB7390(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891FF0);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::string buf = 134349056;
        *(void *)uint64_t v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        int v36 = (uint8_t *)v35;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessible() [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v35);
        if (v36 != buf) {
          free(v36);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891FF0);
    }
    __int128 v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    uint64_t v13 = *(void *)(a1 + 184);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = (void *)(v13 + 8LL * (*(void *)(a1 + 208) >> 7));
    if (v14 == v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *v15 + 32 * (*(void *)(a1 + 208) & 0x7FLL);
    }
    while (1)
    {
      if (v14 == v13)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        unint64_t v21 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v22 = *(void *)(v13 + ((v21 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v21 & 0x7F);
      }

      if (v16 == v22) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101892010);
      }
      int v23 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101892010);
        }
        LOWORD(v39) = 0;
        LODWORD(v37) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v37);
        uint64_t v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessible() [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v16, 1LL);
      v16 += 32LL;
      if (v16 - *v15 == 4096)
      {
        uint64_t v24 = v15[1];
        ++v15;
        uint64_t v16 = v24;
      }

      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v14 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101891FF0);
    }
    std::string::size_type v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      __int128 v18 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
    }

    uint64_t v19 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      signed __int8 v20 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 1;
  }

  unint64_t v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      unint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 64LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 128LL;
  }

  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v31;
LABEL_61:
  std::string::size_type v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100FB7A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id *sub_100FB7ACC(uint64_t a1, uint64_t a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 104LL))(a1, v32);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRecordUL (const T &, BOOL) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = v33;
    double v9 = v7 - v33;
    if (v7 - v33 < 0.0) {
      double v9 = -(v7 - v33);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
      }
      __int128 v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)std::string buf = 134349312;
        double v40 = v33;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        uint64_t v23 = *(void *)(a2 + 8);
        int v35 = 134349312;
        double v36 = v33;
        __int16 v37 = 2050;
        uint64_t v38 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        unint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRecordUL (const T &, BOOL) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = v33;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)std::string buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101891FF0);
          }
          double v26 = *(double *)(a2 + 8);
          int v35 = 134217984;
          double v36 = v26;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          uint64_t v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRecord UL(const T &, BOOL) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v31 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101891FF0);
        double v18 = v31;
      }

      double v19 = v17 - v18;
      signed __int8 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v40 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101891FF0);
        }
        int v35 = 134217984;
        double v36 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        uint64_t v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRecordUL (const T &, BOOL) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, v32, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100FB8208( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100FB8234(uint64_t a1)
{
  return sub_100FB7390(a1 - 72);
}

void sub_100FB823C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100FB8268(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10127CB10(v4);
LABEL_44:
    sub_100007008();
  }

  uint64_t v30 = v35[1];
  operator delete(v35[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v35);
    int v6 = sub_10000CF44(&v36, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(void **__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      double v7 = __p;
    }
    else {
      double v7 = (void **)__p[0];
    }
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v32);
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    double v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v37);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v11 = (char *)__p;
    }
    else {
      uint64_t v11 = (char *)__p[0];
    }
    sub_1003C0D54(v10, v11, &v33);
    uint64_t v12 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v12;
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)__p))
    {
      double v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v17 = (v13 - *a2) >> 5;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v14 - (void)*a2;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          __int128 v21 = (char *)sub_10000835C((uint64_t)(a2 + 2), v20);
        }
        else {
          __int128 v21 = 0LL;
        }
        uint64_t v22 = &v21[32 * v17];
        __int128 v23 = v32;
        *(_OWORD *)uint64_t v22 = *(_OWORD *)__p;
        *((_OWORD *)v22 + 1) = v23;
        unint64_t v25 = *a2;
        uint64_t v24 = a2[1];
        double v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *((_OWORD *)v24 - 1);
            *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v24 -= 32;
          }

          while (v24 != v25);
          uint64_t v24 = *a2;
        }

        uint64_t v16 = v22 + 32;
        *a2 = v26;
        a2[1] = v22 + 32;
        a2[2] = &v21[32 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = v32;
        *(_OWORD *)double v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        uint64_t v16 = v13 + 32;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v34;
    uint64_t v34 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v35
    uint64_t v36 = v29;
    std::streambuf::~streambuf(&v37);
    return std::ios::~ios(&v38);
  }

  return result;
}

void sub_100FB8528( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB8590(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_10127CC7C(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100FB87F0(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10127CDE8(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100FB8A28(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10127CF54(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_100FB8C50(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100FB8C7C(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

ALSLocationRequest *sub_100FB8CA8()
{
  unsigned __int8 v0 = objc_alloc_init(&OBJC_CLASS___ALSLocationRequest);
  -[ALSLocationRequest setMeta:](v0, "setMeta:", sub_100FB8CEC());
  uint64_t v1 = v0;
  return v0;
}

ALSMeta *sub_100FB8CEC()
{
  unsigned __int8 v0 = objc_alloc_init(&OBJC_CLASS___ALSMeta);
  uint64_t v1 = sub_1004F2598();
  sub_1004F5AD0(v1, (uint64_t)__p);
  int v2 = v15;
  uint64_t v3 = (void **)__p[0];
  NSStringEncoding v4 = +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding");
  if (v2 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = v3;
  }
  int v6 = +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", v5, v4);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_1004F2598();
  sub_1004F54FC((uint64_t)__p);
  int v7 = v15;
  uint64_t v8 = (void **)__p[0];
  NSStringEncoding v9 = +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding");
  if (v7 >= 0) {
    uint64_t v10 = __p;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v11 = +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", v10, v9);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  -[ALSMeta setProductId:](v0, "setProductId:", v6);
  -[ALSMeta setSoftwareBuild:](v0, "setSoftwareBuild:", v11);
  uint64_t v12 = v0;
  return v0;
}

void sub_100FB8DF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

ALSNearbyRequest *sub_100FB8E14()
{
  unsigned __int8 v0 = objc_alloc_init(&OBJC_CLASS___ALSNearbyRequest);
  -[ALSNearbyRequest setMeta:](v0, "setMeta:", sub_100FB8CEC());
  uint64_t v1 = v0;
  return v0;
}

void sub_100FB8E58(void *a1)
{
  uint64_t v3 = (void **)(a1 + 20);
  uint64_t v2 = a1[20];
  uint64_t v4 = (a1[21] - v2) >> 3;
  uint64_t v5 = (double **)(a1 + 23);
  if (v4 == (((a1[18] - a1[17]) << 28) - 0x100000000LL) >> 32)
  {
    int v6 = (double *)a1[23];
  }

  else
  {
    int v6 = *v5;
  }

  a1[16] = 0LL;
  a1[21] = v2;
  a1[24] = v6;
  sub_100D2D9A4((uint64_t)v53);
  uint64_t v7 = a1[17];
  if (a1[18] - v7 != 16)
  {
    uint64_t v8 = 0LL;
    do
    {
      unint64_t v9 = v8 + 1;
      double v10 = sub_100D2DBDC( v53,  *(double *)(v7 + 16 * v8),  *(double *)(v7 + 16 * v8 + 8),  *(double *)(v7 + 16 * (v8 + 1)),  *(double *)(v7 + 16 * (v8 + 1) + 8),  0.0);
      double v11 = v10;
      uint64_t v13 = (double *)a1[21];
      unint64_t v12 = a1[22];
      if ((unint64_t)v13 >= v12)
      {
        char v15 = (double *)*v3;
        uint64_t v16 = ((char *)v13 - (_BYTE *)*v3) >> 3;
        unint64_t v17 = v16 + 1;
        uint64_t v18 = v12 - (void)v15;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          uint64_t v20 = (char *)sub_1000071BC((uint64_t)(a1 + 22), v19);
          char v15 = (double *)a1[20];
          uint64_t v13 = (double *)a1[21];
        }

        else
        {
          uint64_t v20 = 0LL;
        }

        uint64_t v21 = (double *)&v20[8 * v16];
        *uint64_t v21 = v11;
        uint64_t v14 = v21 + 1;
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13-- - 1);
          *((void *)v21-- - 1) = v22;
        }

        a1[20] = v21;
        a1[21] = v14;
        a1[22] = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *uint64_t v13 = v10;
        uint64_t v14 = v13 + 1;
      }

      a1[21] = v14;
      *((double *)a1 + 16) = v11 + *((double *)a1 + 16);
      double v23 = sub_100D2ED14( v53,  *(double *)(a1[17] + 16 * v8),  *(double *)(a1[17] + 16 * v8 + 8),  *(double *)(a1[17] + 16 * v9),  *(double *)(a1[17] + 16 * v9 + 8));
      if (v23 < 0.0)
      {
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_101892030);
        }
        std::stringbuf v24 = (os_log_s *)qword_1019348B8;
        if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v25 = a1[17];
          uint64_t v26 = (uint64_t *)(v25 + 16 * v8);
          uint64_t v28 = *v26;
          uint64_t v27 = v26[1];
          uint64_t v29 = (uint64_t *)(v25 + 16 * v9);
          uint64_t v31 = *v29;
          uint64_t v30 = v29[1];
          *(_DWORD *)std::string buf = 134284289;
          uint64_t v63 = v28;
          __int16 v64 = 2049;
          uint64_t v65 = v27;
          __int16 v66 = 2049;
          uint64_t v67 = v31;
          __int16 v68 = 2049;
          uint64_t v69 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "CLMMLE,invalid heading for flowline coordinate,%{private}.7lf,%{private}.7lf,prev,%{private}.7lf,%{private}.7lf",  buf,  0x2Au);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348B0 != -1) {
            dispatch_once(&qword_1019348B0, &stru_101892030);
          }
          uint64_t v43 = a1[17];
          uint64_t v44 = (uint64_t *)(v43 + 16 * v8);
          uint64_t v46 = *v44;
          uint64_t v45 = v44[1];
          int64x2_t v47 = (uint64_t *)(v43 + 16 * v9);
          uint64_t v49 = *v47;
          uint64_t v48 = v47[1];
          int v54 = 134284289;
          uint64_t v55 = v46;
          __int16 v56 = 2049;
          uint64_t v57 = v45;
          __int16 v58 = 2049;
          uint64_t v59 = v49;
          __int16 v60 = 2049;
          uint64_t v61 = v48;
          LODWORD(v52) = 42;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  16LL,  "CLMMLE,invalid heading for flowline coordinate,%{private}.7lf,%{private}.7lf,prev,%{private}.7lf,%{private}.7lf",  &v54,  v52);
          __int128 v51 = (uint8_t *)v50;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLMapFlowLine::computeSegmentDistancesAndHeading()", "%s\n", v50);
          if (v51 != buf) {
            free(v51);
          }
        }
      }

      uint64_t v33 = (double *)a1[24];
      unint64_t v32 = a1[25];
      if ((unint64_t)v33 >= v32)
      {
        int v35 = *v5;
        uint64_t v36 = v33 - *v5;
        unint64_t v37 = v36 + 1;
        uint64_t v38 = v32 - (void)v35;
        if (v38 >> 2 > v37) {
          unint64_t v37 = v38 >> 2;
        }
        else {
          unint64_t v39 = v37;
        }
        if (v39)
        {
          double v40 = (char *)sub_1000071BC((uint64_t)(a1 + 25), v39);
          int v35 = (double *)a1[23];
          uint64_t v33 = (double *)a1[24];
        }

        else
        {
          double v40 = 0LL;
        }

        __int16 v41 = (double *)&v40[8 * v36];
        double *v41 = v23;
        uint64_t v34 = v41 + 1;
        while (v33 != v35)
        {
          uint64_t v42 = *((void *)v33-- - 1);
          *((void *)v41-- - 1) = v42;
        }

        a1[23] = v41;
        a1[24] = v34;
        a1[25] = &v40[8 * v39];
        if (v35) {
          operator delete(v35);
        }
      }

      else
      {
        *uint64_t v33 = v23;
        uint64_t v34 = v33 + 1;
      }

      a1[24] = v34;
      uint64_t v7 = a1[17];
      ++v8;
    }

    while (((a1[18] - v7) >> 4) - 1 > v9);
  }

void sub_100FB92D0(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  double v12 = v11;
  sub_100292950(a6);
  double v14 = v13;
  uint64_t v16 = *(char **)a2;
  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v16;
  v41[0] = 0LL;
  v41[1] = 0LL;
  double v40 = (uint64_t *)v41;
  unint64_t v19 = *(void **)(a1 + 40);
  uint64_t v17 = a1 + 40;
  uint64_t v18 = v19;
  if (v19 == (void *)(v17 + 8)) {
    goto LABEL_46;
  }
  do
  {
    if (!v18[5]) {
      goto LABEL_40;
    }
    *(void *)std::string buf = v18 + 4;
    uint64_t v21 = *(double **)(v18[5] + 136LL);
    uint64_t v20 = *(double **)(v18[5] + 144LL);
    BOOL v22 = (((char *)v20 - (char *)v21) & 0xFFFFFFFF0LL) == 0 || v21 == v20;
    if (v22) {
      goto LABEL_40;
    }
    while (1)
    {
      if (*v21 < a3 || *v21 > a5) {
        goto LABEL_28;
      }
      if (v14 <= v12) {
        break;
      }
      double v24 = v21[1];
      if (v24 >= v12 && v24 <= v14) {
        goto LABEL_30;
      }
LABEL_28:
      v21 += 2;
      if (v21 == v20) {
        goto LABEL_40;
      }
    }

    if (v14 >= v12) {
      goto LABEL_28;
    }
    double v26 = v21[1];
    if (v26 >= v14 && v26 <= v12) {
      goto LABEL_28;
    }
LABEL_30:
    uint64_t v28 = sub_100FB97F8(v17, v18 + 4);
    uint64_t v30 = v29;
    if (v28 != v29)
    {
      do
      {
        if (v28[4] == v18[4])
        {
          sub_100FB8E58((void *)v28[5]);
          sub_1000E8F38((char **)a2, (__int128 *)(v28 + 5));
        }

        uint64_t v31 = (void *)v28[1];
        if (v31)
        {
          do
          {
            unint64_t v32 = v31;
            uint64_t v31 = (void *)*v31;
          }

          while (v31);
        }

        else
        {
          do
          {
            unint64_t v32 = (void *)v28[2];
            BOOL v22 = *v32 == (void)v28;
            uint64_t v28 = v32;
          }

          while (!v22);
        }

        uint64_t v28 = v32;
      }

      while (v32 != v30);
    }

    *(void *)std::string buf = v18 + 4;
    *((_BYTE *)sub_100FB9738(&v40, v18 + 4, (uint64_t)&unk_1012CF090, (void **)buf) + 40) = 1;
LABEL_40:
    uint64_t v33 = (void *)v18[1];
    if (v33)
    {
      do
      {
        uint64_t v34 = v33;
        uint64_t v33 = (void *)*v33;
      }

      while (v33);
    }

    else
    {
      do
      {
        uint64_t v34 = (void *)v18[2];
        BOOL v22 = *v34 == (void)v18;
        uint64_t v18 = v34;
      }

      while (!v22);
    }

    uint64_t v18 = v34;
  }

  while (v34 != (void *)(v17 + 8));
LABEL_46:
  if (qword_1019348B0 != -1) {
    dispatch_once(&qword_1019348B0, &stru_101892030);
  }
  int v35 = (os_log_s *)qword_1019348B8;
  if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v36 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4;
    *(_DWORD *)std::string buf = 134350081;
    *(void *)&uint8_t buf[4] = v36;
    __int16 v53 = 2049;
    double v54 = a3;
    __int16 v55 = 2049;
    double v56 = v12;
    __int16 v57 = 2049;
    double v58 = a5;
    __int16 v59 = 2049;
    double v60 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "CLMMLE,FlowlineBuffer,found roads,size,%{public}ld,min,%{private}.7lf,%{private}.7lf,max,%{private}.7lf,%{private}.7lf",  buf,  0x34u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_101892030);
    }
    uint64_t v37 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4;
    int v42 = 134350081;
    uint64_t v43 = v37;
    __int16 v44 = 2049;
    double v45 = a3;
    __int16 v46 = 2049;
    double v47 = v12;
    __int16 v48 = 2049;
    double v49 = a5;
    __int16 v50 = 2049;
    double v51 = v14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMMLE,FlowlineBuffer,found roads,size,%{public}ld,min,%{private}.7lf,%{private}.7lf,max,%{private}.7lf,%{private}.7lf",  &v42,  52);
    unint64_t v39 = (char *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMapFlowLineBuffer::findFlowLinesInThisBox(double, double, double, double, std::vector<CLMapFlowLinePtr> &) const",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
  }

  sub_100008390((uint64_t)&v40, v41[0]);
}

void sub_100FB96E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

void sub_100FB970C(id a1)
{
  qword_1019348B8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MapMatcher");
}

uint64_t **sub_100FB9738(uint64_t **a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    uint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        uint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    double v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_BYTE *)v11 + 40) = 0;
    sub_1000085FC(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void *sub_100FB97F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v4 = *a2;
  while (1)
  {
    uint64_t v5 = v3[4];
    if (v4 >= v5) {
      break;
    }
    uint64_t v2 = v3;
LABEL_7:
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      return v2;
    }
  }

  if (v5 < v4)
  {
    ++v3;
    goto LABEL_7;
  }

  uint64_t v7 = (void *)*v3;
  uint64_t result = v3;
  if (*v3)
  {
    uint64_t result = v3;
    do
    {
      uint64_t v8 = v7[4];
      BOOL v9 = v8 < v4;
      if (v8 >= v4) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      if (!v9) {
        uint64_t result = v7;
      }
      uint64_t v7 = (void *)*v10;
    }

    while (*v10);
  }

  double v11 = (void *)v3[1];
  if (v11)
  {
    do
    {
      if (v4 >= v11[4]) {
        double v12 = v11 + 1;
      }
      else {
        double v12 = v11;
      }
      double v11 = (void *)*v12;
    }

    while (*v12);
  }

  return result;
}

uint64_t sub_100FB9890()
{
  if (qword_10199F968 != -1) {
    dispatch_once(&qword_10199F968, &stru_101892050);
  }
  return qword_1019A40F8;
}

void sub_100FB98D0(id a1)
{
  uint64_t v1 = (CFRunLoopTimerRef *)operator new(0x40uLL);
  sub_1007154B8(v1, 3, 0);
  CFRunLoopTimerRef *v1 = (CFRunLoopTimerRef)&off_101892080;
  qword_1019A40F8 = (uint64_t)v1;
}

void sub_100FB9914(_Unwind_Exception *a1)
{
}

void sub_100FB992C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10071558C(a1);
  operator delete(v1);
}

BOOL sub_100FB9940(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 128);
  if (!v4 || (int v5 = *(_DWORD *)(a2 + 128)) == 0)
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    uint64_t v10 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *(_DWORD *)(a1 + 128);
      int v12 = *(_DWORD *)(a2 + 128);
      *(_DWORD *)std::string buf = 67240448;
      *(_DWORD *)uint64_t v29 = v11;
      *(_WORD *)&v29[4] = 1026;
      *(_DWORD *)&v29[6] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Location equality comparison failed, unknown location type,%{public}d,%{public}d",  buf,  0xEu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    int v13 = *(_DWORD *)(a1 + 128);
    int v14 = *(_DWORD *)(a2 + 128);
    int v25 = 67240448;
    *(_DWORD *)double v26 = v13;
    *(_WORD *)&v26[4] = 1026;
    *(_DWORD *)&void v26[6] = v14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "Location equality comparison failed, unknown location type,%{public}d,%{public}d",  &v25,  14);
    uint64_t v16 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL cllcf::LCFusionProviderLocation::checkLocationTypesAndTimestampsEquality(const LCFusionProviderLocation &) const",  "%s\n",  v15);
LABEL_30:
    if (v16 != buf) {
      free(v16);
    }
    return 0LL;
  }

  double v6 = *(double *)(a1 + 8);
  if (v6 > 0.0)
  {
    double v7 = *(double *)(a2 + 8);
    if (v7 > 0.0)
    {
      BOOL result = 0LL;
      if (v4 == v5 && vabdd_f64(v6, v7) < 2.22044605e-16)
      {
        if (qword_101934960 != -1) {
          dispatch_once(&qword_101934960, &stru_101892190);
        }
        BOOL v9 = (os_log_s *)qword_101934968;
        if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Location equality comparison, location types and timestamps are identical.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101892190);
          }
          LOWORD(v25) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "Location equality comparison, location types and timestamps are identical.",  &v25,  2);
          double v24 = (uint8_t *)v23;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL cllcf::LCFusionProviderLocation::checkLocationTypesAndTimestampsEquality(const LCFusionProvider Location &) const",  "%s\n",  v23);
          if (v24 != buf) {
            free(v24);
          }
        }

        (*(void (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
        (*(void (**)(uint64_t))(*(void *)a2 + 56LL))(a2);
        return 1LL;
      }

      return result;
    }
  }

  if (qword_101934960 != -1) {
    dispatch_once(&qword_101934960, &stru_101892190);
  }
  uint64_t v17 = (os_log_s *)qword_101934968;
  if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v18 = *(void *)(a1 + 8);
    uint64_t v19 = *(void *)(a2 + 8);
    *(_DWORD *)std::string buf = 134349312;
    *(void *)uint64_t v29 = v18;
    *(_WORD *)&v29[8] = 2050;
    uint64_t v30 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Location equality comparison failed, invalid location ios timestamp,%{public}.3f,%{public}.3f",  buf,  0x16u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    uint64_t v20 = *(void *)(a1 + 8);
    uint64_t v21 = *(void *)(a2 + 8);
    int v25 = 134349312;
    *(void *)double v26 = v20;
    *(_WORD *)&v26[8] = 2050;
    uint64_t v27 = v21;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "Location equality comparison failed, invalid location ios timestamp,%{public}.3f,%{public}.3f",  &v25,  22);
    uint64_t v16 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL cllcf::LCFusionProviderLocation::checkLocationTypesAndTimestampsEquality(const LCFusionProviderLocation &) const",  "%s\n",  v22);
    goto LABEL_30;
  }

  return result;
}

void sub_100FB9E18(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100FB9E24(uint64_t a1, uint64_t a2, double a3)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = *(void *)(a2 + 76);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 4);
  *(double *)(a1 + 40) = a3;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = *(_OWORD *)(a2 + 28);
  *(_OWORD *)(a1 + sub_100F6A7D8(v1 + 80) = *(_OWORD *)(a2 + 44);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 + 84);
  *(void *)(a1 + 112) = *(void *)(a2 + 88);
  *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = *(_DWORD *)(a2 + 96);
  sub_1002929AC(*(double *)(a1 + 24));
  sub_100292950(*(double *)(a1 + 32));
  if (*(double *)(a1 + 104) <= 0.0)
  {
    *(void *)(a1 + 96) = 0xBFF0000000000000LL;
  }

  else
  {
    double v4 = *(double *)(a1 + 96);
    if (v4 >= 0.0) {
      sub_100292890(v4);
    }
  }

uint64_t sub_100FB9EF0(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 128) < 0xFu) & (0x20Eu >> *(_DWORD *)(a1 + 128));
}

double sub_100FB9F0C(uint64_t a1)
{
  if (*(double *)(a1 + 16) <= 0.0)
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    int v12 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#Error,ProviderLoc,getAge called while MCT not set",  buf,  2u);
    }

    double v11 = -1.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101892190);
      }
      LOWORD(v24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,ProviderLoc,getAge called while MCT not set",  &v24,  2);
      BOOL v22 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval cllcf::LCFusionProviderLocation::getAge() const",  "%s\n",  v21);
      if (v22 != buf) {
        free(v22);
      }
    }
  }

  else
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    uint64_t v2 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = sub_10080E94C();
      *(_DWORD *)std::string buf = 1;
      double v4 = sub_10080EB58(v3, buf);
      double v5 = *(double *)(a1 + 16);
      uint64_t v6 = sub_10080E94C();
      *(_DWORD *)std::string buf = 1;
      double v7 = sub_10080EB58(v6, buf);
      uint64_t v8 = sub_10080E94C();
      double v9 = sub_10080EF30(v8);
      *(_DWORD *)std::string buf = 134218496;
      double v31 = v4 - v5;
      __int16 v32 = 2048;
      double v33 = v7;
      __int16 v34 = 2048;
      double v35 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "ProviderLoc,getAge,age,%.3f,now_mct,%.3f,propagation_us,%.3f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101892190);
      }
      uint64_t v14 = qword_101934968;
      double v15 = sub_1003713F0();
      double v16 = *(double *)(a1 + 16);
      double v17 = sub_1003713F0();
      uint64_t v18 = sub_10080E94C();
      int v24 = 134218496;
      double v25 = v15 - v16;
      __int16 v26 = 2048;
      double v27 = v17;
      __int16 v28 = 2048;
      double v29 = sub_10080EF30(v18);
      LODWORD(v23) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  2LL,  "ProviderLoc,getAge,age,%.3f,now_mct,%.3f,propagation_us,%.3f",  COERCE_DOUBLE(&v24),  v23);
      uint64_t v20 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval cllcf::LCFusionProviderLocation::getAge() const",  "%s\n",  v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    uint64_t v10 = sub_10080E94C();
    *(_DWORD *)std::string buf = 1;
    return sub_10080EB58(v10, buf) - *(double *)(a1 + 16);
  }

  return v11;
}

void sub_100FBA2AC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

double sub_100FBA2B8(uint64_t a1, double *a2)
{
  double v2 = *(double *)(a1 + 16);
  if (v2 > 0.0) {
    return *a2 - v2;
  }
  if (qword_101934960 != -1) {
    dispatch_once(&qword_101934960, &stru_101892190);
  }
  double v4 = (os_log_s *)qword_101934968;
  if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#Error,ProviderLoc,getAge called while MCT not set",  buf,  2u);
  }

  double v3 = -1.0;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,ProviderLoc,getAge called while MCT not set",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval cllcf::LCFusionProviderLocation::getAge(const CFTimeInterval &) const",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return v3;
}

void sub_100FBA464(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100FBA470(uint64_t a1)
{
  if (qword_101934960 != -1) {
    dispatch_once(&qword_101934960, &stru_101892190);
  }
  double v2 = (os_log_s *)qword_101934968;
  if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *(_DWORD *)(a1 + 128);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v24 = *(void *)(a1 + 40);
    uint64_t v26 = *(void *)(a1 + 56);
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v9 = *(void *)(a1 + 96);
    uint64_t v28 = *(void *)(a1 + 88);
    uint64_t v30 = *(void *)(a1 + 104);
    int v32 = *(_DWORD *)(a1 + 120);
    uint64_t v34 = *(void *)(a1 + 112);
    int v36 = *(unsigned __int8 *)(a1 + 124);
    uint64_t v10 = *(void *)(a1 + 8);
    double v11 = (*(double (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
    *(_DWORD *)std::string buf = 134352897;
    uint64_t v71 = v10;
    __int16 v72 = 2050;
    uint64_t v73 = v4;
    __int16 v74 = 1026;
    int v75 = v3;
    __int16 v76 = 2049;
    uint64_t v77 = v5;
    __int16 v78 = 2049;
    uint64_t v79 = v6;
    __int16 v80 = 2049;
    uint64_t v81 = v7;
    __int16 v82 = 2049;
    uint64_t v83 = v8;
    __int16 v84 = 2049;
    uint64_t v85 = v9;
    __int16 v86 = 2049;
    uint64_t v87 = v24;
    __int16 v88 = 2050;
    uint64_t v89 = v26;
    __int16 v90 = 2050;
    uint64_t v91 = v28;
    __int16 v92 = 2050;
    uint64_t v93 = v30;
    __int16 v94 = 1026;
    int v95 = v32;
    __int16 v96 = 2050;
    uint64_t v97 = v34;
    __int16 v98 = 1026;
    int v99 = v36;
    __int16 v100 = 2050;
    double v101 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "ProviderLoc:Log,%{public}.3f,%{public}.3f,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{private}.1f,%{pri vate}.2f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}d,%{public}.2f,%{public}d,%{public}.3f",  buf,  0x96u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    uint64_t v37 = qword_101934968;
    int v12 = *(_DWORD *)(a1 + 128);
    uint64_t v13 = *(void *)(a1 + 16);
    uint64_t v14 = *(void *)(a1 + 24);
    uint64_t v15 = *(void *)(a1 + 32);
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 48);
    uint64_t v18 = *(void *)(a1 + 80);
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v27 = *(void *)(a1 + 88);
    uint64_t v19 = *(void *)(a1 + 96);
    uint64_t v29 = *(void *)(a1 + 104);
    int v31 = *(_DWORD *)(a1 + 120);
    uint64_t v33 = *(void *)(a1 + 112);
    int v35 = *(unsigned __int8 *)(a1 + 124);
    uint64_t v20 = *(void *)(a1 + 8);
    double v21 = (*(double (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
    int v38 = 134352897;
    uint64_t v39 = v20;
    __int16 v40 = 2050;
    uint64_t v41 = v13;
    __int16 v42 = 1026;
    int v43 = v12;
    __int16 v44 = 2049;
    uint64_t v45 = v14;
    __int16 v46 = 2049;
    uint64_t v47 = v15;
    __int16 v48 = 2049;
    uint64_t v49 = v17;
    __int16 v50 = 2049;
    uint64_t v51 = v18;
    __int16 v52 = 2049;
    uint64_t v53 = v19;
    __int16 v54 = 2049;
    uint64_t v55 = v16;
    __int16 v56 = 2050;
    uint64_t v57 = v25;
    __int16 v58 = 2050;
    uint64_t v59 = v27;
    __int16 v60 = 2050;
    uint64_t v61 = v29;
    __int16 v62 = 1026;
    int v63 = v31;
    __int16 v64 = 2050;
    uint64_t v65 = v33;
    __int16 v66 = 1026;
    int v67 = v35;
    __int16 v68 = 2050;
    double v69 = v21;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v37,  2LL,  "ProviderLoc:Log,%{public}.3f,%{public}.3f,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{private}.1f,%{pri vate}.2f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}d,%{public}.2f,%{public}d,%{public}.3f",  &v38,  150);
    double v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void cllcf::LCFusionProviderLocation::debugPrint() const",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

void sub_100FBA818(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100FBA824(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_101934960 != -1) {
    dispatch_once(&qword_101934960, &stru_101892190);
  }
  uint64_t v6 = (os_log_s *)qword_101934968;
  if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    int v9 = *(_DWORD *)(a1 + 128);
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 80);
    uint64_t v15 = *(void *)(a1 + 88);
    uint64_t v17 = *(void *)(a1 + 96);
    uint64_t v18 = *(void *)(a1 + 104);
    int v19 = *(unsigned __int8 *)(a1 + 124);
    *(_DWORD *)std::string buf = 134352643;
    uint64_t v66 = v7;
    __int16 v67 = 2050;
    uint64_t v68 = v8;
    __int16 v69 = 1026;
    int v70 = v9;
    __int16 v71 = 2049;
    uint64_t v72 = v10;
    __int16 v73 = 2049;
    uint64_t v74 = v11;
    __int16 v75 = 2049;
    uint64_t v76 = v12;
    __int16 v77 = 2049;
    uint64_t v78 = v13;
    __int16 v79 = 2050;
    uint64_t v80 = v14;
    __int16 v81 = 2049;
    uint64_t v82 = v16;
    __int16 v83 = 2050;
    uint64_t v84 = v15;
    __int16 v85 = 2049;
    uint64_t v86 = v17;
    __int16 v87 = 2050;
    uint64_t v88 = v18;
    __int16 v89 = 1026;
    int v90 = v19;
    __int16 v91 = 1026;
    int v92 = a3;
    __int16 v93 = 2082;
    uint64_t v94 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "ProviderLoc:PositionLog,%{public}.3f,%{public}.3f,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{private}. 2f,%{public}.1f,%{private}.2f,%{public}.2f,%{private}.1f,%{public}.1f,%{public}d,%{public}d,%{public}s",  buf,  0x8Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101892190);
    }
    uint64_t v20 = *(void *)(a1 + 8);
    uint64_t v21 = *(void *)(a1 + 16);
    int v22 = *(_DWORD *)(a1 + 128);
    uint64_t v23 = *(void *)(a1 + 24);
    uint64_t v24 = *(void *)(a1 + 32);
    uint64_t v25 = *(void *)(a1 + 40);
    uint64_t v26 = *(void *)(a1 + 48);
    uint64_t v27 = *(void *)(a1 + 56);
    uint64_t v28 = *(void *)(a1 + 80);
    uint64_t v29 = *(void *)(a1 + 88);
    uint64_t v30 = *(void *)(a1 + 96);
    uint64_t v31 = *(void *)(a1 + 104);
    int v32 = *(unsigned __int8 *)(a1 + 124);
    int v35 = 134352643;
    uint64_t v36 = v20;
    __int16 v37 = 2050;
    uint64_t v38 = v21;
    __int16 v39 = 1026;
    int v40 = v22;
    __int16 v41 = 2049;
    uint64_t v42 = v23;
    __int16 v43 = 2049;
    uint64_t v44 = v24;
    __int16 v45 = 2049;
    uint64_t v46 = v25;
    __int16 v47 = 2049;
    uint64_t v48 = v26;
    __int16 v49 = 2050;
    uint64_t v50 = v27;
    __int16 v51 = 2049;
    uint64_t v52 = v28;
    __int16 v53 = 2050;
    uint64_t v54 = v29;
    __int16 v55 = 2049;
    uint64_t v56 = v30;
    __int16 v57 = 2050;
    uint64_t v58 = v31;
    __int16 v59 = 1026;
    int v60 = v32;
    __int16 v61 = 1026;
    int v62 = a3;
    __int16 v63 = 2082;
    uint64_t v64 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "ProviderLoc:PositionLog,%{public}.3f,%{public}.3f,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{private}. 2f,%{public}.1f,%{private}.2f,%{public}.2f,%{private}.1f,%{public}.1f,%{public}d,%{public}d,%{public}s",  &v35,  140);
    uint64_t v34 = (uint8_t *)v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void cllcf::LCFusionProviderLocation::debugPrintLocation(const char *, int) const",  "%s\n",  v33);
    if (v34 != buf) {
      free(v34);
    }
  }

void sub_100FBAB24(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

__n128 sub_100FBAB30(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }

  *(__n128 *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = result;
  *(_OWORD *)(a1 + 40) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 56) = xmmword_1012E0070;
  *(_DWORD *)(a1 + sub_1011C52D0(v23 - 72) = -1;
  *(__n128 *)(a1 + sub_100F6A7D8(v1 + 80) = result;
  *(__n128 *)(a1 + 96) = result;
  *(void *)(a1 + 112) = 0x3FF0000000000000LL;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_BYTE *)(a1 + 124) = 0;
  return result;
}

void sub_100FBAB6C(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = _Q0;
  *(_OWORD *)(a1 + 40) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 56) = xmmword_1012E0070;
  *(_DWORD *)(a1 + sub_1011C52D0(v23 - 72) = -1;
  *(_OWORD *)(a1 + sub_100F6A7D8(v1 + 80) = _Q0;
  *(_OWORD *)(a1 + 96) = _Q0;
  *(void *)(a1 + 112) = 0x3FF0000000000000LL;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_BYTE *)(a1 + 124) = 0;
  __asm { FMOV            V0.2S, #-1.0 }

  *(void *)(a1 + 132) = _Q0;
  *(_DWORD *)(a1 + 140) = -1082130432;
  __int128 v10 = 0uLL;
  sub_10005F550(a1 + 144, &v10);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)&v10 + 1);
  if (*((void *)&v10 + 1))
  {
    uint64_t v8 = (unint64_t *)(*((void *)&v10 + 1) + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  *(_DWORD *)(a1 + 160) = 0;
}

void *sub_100FBAC24(void *a1)
{
  *a1 = off_101892128;
  sub_10000AE14((uint64_t)(a1 + 18));
  return a1;
}

void sub_100FBAC54(void *a1)
{
  *a1 = off_101892128;
  sub_10000AE14((uint64_t)(a1 + 18));
  operator delete(a1);
}

void sub_100FBAC84(id a1)
{
  qword_101934968 = (uint64_t)os_log_create("com.apple.locationd.Position", "LCFusion");
}

uint64_t sub_100FBACB0(uint64_t a1)
{
  return a1;
}

double sub_100FBACD8(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a3[1];
  *(void *)(a1 + 16) = *a3;
  *(void *)(a1 + 24) = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = a4[1];
  *(void *)(a1 + 32) = *a4;
  *(void *)(a1 + 40) = v11;
  if (v11)
  {
    uint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  uint64_t v14 = a5[1];
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = *a5;
  *(void *)(a1 + 56) = v14;
  if (v14)
  {
    uint64_t v15 = (unint64_t *)(v14 + 8);
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  *(_OWORD *)(a1 + 64) = xmmword_1013BBD40;
  *(_OWORD *)(a1 + sub_100F6A7D8(v1 + 80) = unk_1013BBD50;
  *(_OWORD *)(a1 + 96) = xmmword_1013BBD60;
  *(void *)&double result = 1092616192LL;
  *(_OWORD *)(a1 + 10_Block_object_dispose((const void *)(v1 - 128), 8) = *(__int128 *)((char *)&xmmword_1013BBD60 + 12);
  return result;
}

void sub_100FBAD80(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = Current;
  *(_DWORD *)(a3 + 16) = -1;
  *(void *)(a3 + 24) = 0LL;
  double v7 = 0.0;
  if (*(int *)(a2 + 48) >= 30)
  {
    if (*(_BYTE *)(a1 + 121)
      && *(_BYTE *)(a1 + 122)
      && (float v9 = *(float *)(a1 + 76), v9 > 0.0)
      && (float v10 = *(float *)(a1 + 72), v10 > 0.0))
    {
      else {
        double v11 = *(double *)a2 / v9;
      }
      else {
        double v13 = *(double *)(a2 + 8);
      }
      else {
        double v14 = *(double *)(a2 + 24);
      }
      else {
        double v15 = *(double *)(a2 + 32) / sqrt(v10 * 0.55 * 9.81);
      }
      sub_1010DDBC0(buf, "constant");
      double v16 = *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)buf);
      sub_1010DDBC0(&v38, "activeEnergyBurned");
      double v17 = *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)&v38);
      sub_1010DDBC0(v36, "meanMaxHRPerDay");
      double v27 = v17;
      double v28 = v16;
      double v29 = v15;
      double v18 = *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)v36);
      sub_1010DDBC0(v34, "meanRestingHRPerDay");
      double v19 = v14;
      double v20 = v13;
      double v21 = *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)v34);
      double v22 = *(double *)(a2 + 16);
      sub_1010DDBC0(v32, "mean6MWTDPerDay");
      double v23 = v11;
      double v24 = *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)v32);
      sub_1010DDBC0(__p, "meanWalkingSpeedPerDay");
      double v7 = v28
         + v27 * v23
         + v18 * v20
         + v21 * v22
         + v24 * v19
         + *(double *)sub_100FBB2D8((uint64_t)&unk_10199F970, (const void **)__p) * v29;
      *(double *)(a3 + 24) = v7;
      if (v31 < 0) {
        operator delete(__p[0]);
      }
      if (v33 < 0) {
        operator delete(v32[0]);
      }
      if (v35 < 0) {
        operator delete(v34[0]);
      }
      if (v37 < 0) {
        operator delete(v36[0]);
      }
      if (SBYTE3(v42) < 0) {
        operator delete(v38);
      }
      if (SBYTE3(v46) < 0) {
        operator delete(*(void **)buf);
      }
      sub_101204164(buf, "CardioChangeEstimatorThreshold", &qword_1013BBD80, 0);
      unsigned int v8 = v7 > *(double *)v44;
    }

    else
    {
      unsigned int v8 = 2;
    }
  }

  else
  {
    unsigned int v8 = 3;
  }

  *(_DWORD *)(a3 + 16) = v8;
  if (qword_101934760 != -1) {
    dispatch_once(&qword_101934760, &stru_1018921B0);
  }
  uint64_t v12 = (os_log_s *)qword_101934768;
  if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67175169;
    *(_DWORD *)&uint8_t buf[4] = v8;
    *(_WORD *)uint64_t v44 = 2049;
    *(CFAbsoluteTime *)&id v44[2] = Current;
    __int16 v45 = 2049;
    double v46 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Estimator,status,%{private}d,startTime,%{private}f,riskScore,%{private}f",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    LODWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = 67175169;
    HIDWORD(v3_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
    __int16 v39 = 2049;
    CFAbsoluteTime v40 = Current;
    __int16 v41 = 2049;
    double v42 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  0LL,  "Estimator,status,%{private}d,startTime,%{private}f,riskScore,%{private}f",  &v38,  28);
    uint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCardioChange::EstimateResult CLCardioChangeEstimator::makeEstimate(const CLCardioChange::InputSample &)",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  if (v8 <= 1) {
    sub_10024D4E8(*(void *)a1, a3);
  }
}

void sub_100FBB228( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, void *a39, uint64_t a40, int a41, __int16 a42, char a43, char a44, uint64_t a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FBB2D8(uint64_t a1, const void **a2)
{
  uint64_t v2 = *sub_1000227E8(a1, &v4, a2);
  if (!v2) {
    sub_10000C918("map::at:  key not found");
  }
  return v2 + 56;
}

void sub_100FBB314(uint64_t a1, __int128 *a2)
{
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  __int128 v5 = a2[2];
  *(_OWORD *)(a1 + 10_Block_object_dispose((const void *)(v1 - 128), 8) = *(__int128 *)((char *)a2 + 44);
  *(_OWORD *)(a1 + sub_100F6A7D8(v1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 64) = v3;
  if (qword_101934760 != -1) {
    dispatch_once(&qword_101934760, &stru_1018921B0);
  }
  uint64_t v6 = (os_log_s *)qword_101934768;
  if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(unsigned __int8 *)(a1 + 120);
    double v8 = *(float *)(a1 + 84);
    int v9 = *(_DWORD *)(a1 + 68);
    int v10 = *(unsigned __int8 *)(a1 + 121);
    double v11 = *(float *)(a1 + 72);
    int v12 = *(unsigned __int8 *)(a1 + 122);
    double v13 = *(float *)(a1 + 76);
    int v14 = *(unsigned __int8 *)(a1 + 112);
    *(_DWORD *)std::string buf = 67241985;
    int v41 = v7;
    __int16 v42 = 2049;
    double v43 = v8;
    __int16 v44 = 1025;
    int v45 = v9;
    __int16 v46 = 1026;
    int v47 = v10;
    __int16 v48 = 2049;
    double v49 = v11;
    __int16 v50 = 1026;
    int v51 = v12;
    __int16 v52 = 2049;
    double v53 = v13;
    __int16 v54 = 1025;
    int v55 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Estimator,IsAgeSet,%{public}d,Age,%{private}f,BiologicalSex,%{private}d,IsHeightSet,%{public}d,Height,%{private}f, IsWeightSet,%{public}d,Weight,%{private}f,BetaBlockerUse,%{private}d",  buf,  0x3Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    int v15 = *(unsigned __int8 *)(a1 + 120);
    double v16 = *(float *)(a1 + 84);
    int v17 = *(_DWORD *)(a1 + 68);
    int v18 = *(unsigned __int8 *)(a1 + 121);
    double v19 = *(float *)(a1 + 72);
    int v20 = *(unsigned __int8 *)(a1 + 122);
    double v21 = *(float *)(a1 + 76);
    int v22 = *(unsigned __int8 *)(a1 + 112);
    v25[0] = 67241985;
    v25[1] = v15;
    __int16 v26 = 2049;
    double v27 = v16;
    __int16 v28 = 1025;
    int v29 = v17;
    __int16 v30 = 1026;
    int v31 = v18;
    __int16 v32 = 2049;
    double v33 = v19;
    __int16 v34 = 1026;
    int v35 = v20;
    __int16 v36 = 2049;
    double v37 = v21;
    __int16 v38 = 1025;
    int v39 = v22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  2LL,  "Estimator,IsAgeSet,%{public}d,Age,%{private}f,BiologicalSex,%{private}d,IsHeightSet,%{public}d,Height,%{private}f, IsWeightSet,%{public}d,Weight,%{private}f,BetaBlockerUse,%{private}d",  v25,  62);
    double v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCardioChangeEstimator::feedBodyMetrics(const CLBodyMetrics &)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

void sub_100FBB5AC(uint64_t a1, uint64_t **a2, double a3)
{
  std::stringbuf::string_type __p = 0LL;
  int v17 = 0LL;
  uint64_t v18 = 0LL;
  LODWORD(v19) = 0;
  double v13 = &v19;
  uint64_t v6 = sub_10000C858(a2, (int *)&v19, (uint64_t)&unk_1012CF090, (_DWORD **)&v13);
  sub_100FBB718(a1, (uint64_t)&__p, *((double *)v6 + 5), a3);
  int v7 = (char *)__p;
  double v8 = v17;
  while (v7 != v8)
  {
    sub_10024D4E8(*(void *)(a1 + 16), (uint64_t)v7);
    v7 += 32;
  }

  double v13 = 0LL;
  int v14 = 0LL;
  uint64_t v15 = 0LL;
  int v12 = 1;
  double v19 = &v12;
  int v9 = sub_10000C858(a2, &v12, (uint64_t)&unk_1012CF090, &v19);
  sub_100FBBAB8(a1, (uint64_t)&v13, *((double *)v9 + 5), a3);
  int v10 = v13;
  double v11 = v14;
  if (v13 != v14)
  {
    do
    {
      sub_10024D4E8(*(void *)(a1 + 16), (uint64_t)v10);
      v10 += 4;
    }

    while (v10 != v11);
    int v10 = v13;
  }

  if (v10)
  {
    int v14 = v10;
    operator delete(v10);
  }

  if (__p)
  {
    int v17 = (char *)__p;
    operator delete(__p);
  }

void sub_100FBB6DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBB718(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (a3 == a4)
  {
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    double v8 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      double v21 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Up to date with processing data for VO2Max feature, startTime %f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      LODWORD(__p[0]) = 134217984;
      *(void **)((char *)__p + 4) = *(void **)&a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  0LL,  "Up to date with processing data for VO2Max feature, startTime %f",  COERCE_DOUBLE(__p));
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCardioChangeEstimator::calculateVO2MaxFeatures(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLCardioChange ::AggregateFeatureEntry> &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  memset(__p, 0, 24);
  uint64_t v9 = (*(uint64_t (**)(void, void **, double, double))(**(void **)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  __p,  a3,  a4);
  if ((_DWORD)v9 == 100)
  {
    sub_100FBBE5C(a3, a4, v9, (uint64_t *)__p, a2);
  }

  else
  {
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    int v10 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134349312;
      double v21 = a3;
      __int16 v22 = 2050;
      double v23 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Estimator, failed to get VO2Max session records in time range, startTime: %{public}f, endTime: %{public}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      int v15 = 134349312;
      double v16 = a3;
      __int16 v17 = 2050;
      double v18 = a4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  16LL,  "Estimator, failed to get VO2Max session records in time range, startTime: %{public}f, endTime: %{public}f",  &v15,  22);
      int v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCardioChangeEstimator::calculateVO2MaxFeatures(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLCardioChange ::AggregateFeatureEntry> &)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

void sub_100FBBA90( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBBAB8(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (a3 == a4)
  {
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    double v8 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      double v21 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Up to date with processing data for HRRecovery feature, startTime %f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      LODWORD(__p[0]) = 134217984;
      *(void **)((char *)__p + 4) = *(void **)&a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  0LL,  "Up to date with processing data for HRRecovery feature, startTime %f",  COERCE_DOUBLE(__p));
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCardioChangeEstimator::calculateHRRecoveryFeatures(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLCardioCh ange::AggregateFeatureEntry> &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  memset(__p, 0, 24);
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t, void **, double, double))(**(void **)(a1 + 48) + 16LL))( *(void *)(a1 + 48),  0xFFFFFFFFLL,  __p,  a3,  a4);
  if ((_DWORD)v9 == 100)
  {
    sub_100FBC1F4(a3, a4, v9, (uint64_t *)__p, a2);
  }

  else
  {
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    int v10 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134349312;
      double v21 = a3;
      __int16 v22 = 2050;
      double v23 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Estimator, failed to get HRRecovery session records in time range, startTime: %{public}f, endTime: %{public}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      int v15 = 134349312;
      double v16 = a3;
      __int16 v17 = 2050;
      double v18 = a4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  16LL,  "Estimator, failed to get HRRecovery session records in time range, startTime: %{public}f, endTime: %{public}f",  &v15,  22);
      int v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCardioChangeEstimator::calculateHRRecoveryFeatures(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLCardioCh ange::AggregateFeatureEntry> &)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

void sub_100FBBE34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FBBE5C(double a1, double a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  double v7 = a1;
  double v8 = a1 + 86400.0;
  uint64_t v10 = *a4;
  uint64_t v9 = a4[1];
  if (*a4 == v9) {
    goto LABEL_49;
  }
LABEL_2:
  unsigned int v12 = 0;
  double v13 = v7;
  double v7 = v8;
  double v14 = 0.0;
  do
  {
    double v15 = *(double *)(v10 + 24);
    if (v15 < v13 || v15 >= v7)
    {
      double v17 = 0.0;
      if (v14 > 0.0) {
        double v17 = v14 / (double)v12;
      }
      double v19 = *(double **)(a5 + 8);
      unint64_t v18 = *(void *)(a5 + 16);
      if ((unint64_t)v19 >= v18)
      {
        double v21 = *(double **)a5;
        uint64_t v22 = ((uint64_t)v19 - *(void *)a5) >> 5;
        unint64_t v23 = v22 + 1;
        uint64_t v24 = v18 - (void)v21;
        if (v24 >> 4 > v23) {
          unint64_t v23 = v24 >> 4;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          __int16 v26 = (char *)sub_10000835C(a5 + 16, v25);
          double v21 = *(double **)a5;
          double v19 = *(double **)(a5 + 8);
        }

        else
        {
          __int16 v26 = 0LL;
        }

        double v27 = (double *)&v26[32 * v22];
        *double v27 = 0.0;
        v27[1] = v13;
        *((_DWORD *)v27 + 4) = 0;
        v27[3] = v17;
        __int16 v28 = v27;
        if (v19 != v21)
        {
          do
          {
            __int128 v29 = *((_OWORD *)v19 - 1);
            *((_OWORD *)v28 - 2) = *((_OWORD *)v19 - 2);
            *((_OWORD *)v28 - 1) = v29;
            v28 -= 4;
            v19 -= 4;
          }

          while (v19 != v21);
          double v21 = *(double **)a5;
        }

        int v20 = (char *)(v27 + 4);
        *(void *)a5 = v28;
        *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v27 + 4;
        *(void *)(a5 + 16) = &v26[32 * v25];
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        *double v19 = 0.0;
        v19[1] = v13;
        *((_DWORD *)v19 + 4) = 0;
        int v20 = (char *)(v19 + 4);
        v19[3] = v17;
      }

      *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v20;
      double v8 = v7 + 86400.0;
      uint64_t v9 = a4[1];
      double v13 = v7;
      if (v10 == v9) {
        goto LABEL_50;
      }
      goto LABEL_2;
    }

    double v14 = v14 + *(double *)(v10 + 136);
    ++v12;
    v10 += 144LL;
  }

  while (v10 != v9);
  if (v14 <= 0.0)
  {
    double v8 = v7;
    goto LABEL_50;
  }

  double v30 = v14 / (double)v12;
  __int16 v32 = *(double **)(a5 + 8);
  unint64_t v31 = *(void *)(a5 + 16);
  if ((unint64_t)v32 < v31)
  {
    *__int16 v32 = 0.0;
    v32[1] = v13;
    *((_DWORD *)v32 + 4) = 0;
    double v33 = (char *)(v32 + 4);
    v32[3] = v30;
    goto LABEL_48;
  }

  __int16 v34 = *(double **)a5;
  uint64_t v35 = ((uint64_t)v32 - *(void *)a5) >> 5;
  unint64_t v36 = v35 + 1;
  if ((unint64_t)(v35 + 1) >> 59) {
LABEL_70:
  }
    sub_100007008();
  uint64_t v37 = v31 - (void)v34;
  if (v37 >> 4 > v36) {
    unint64_t v36 = v37 >> 4;
  }
  else {
    unint64_t v38 = v36;
  }
  if (v38)
  {
    int v39 = (char *)sub_10000835C(a5 + 16, v38);
    __int16 v34 = *(double **)a5;
    __int16 v32 = *(double **)(a5 + 8);
  }

  else
  {
    int v39 = 0LL;
  }

  CFAbsoluteTime v40 = (double *)&v39[32 * v35];
  *CFAbsoluteTime v40 = 0.0;
  v40[1] = v13;
  int v41 = &v39[32 * v38];
  *((_DWORD *)v40 + 4) = 0;
  v40[3] = v30;
  double v33 = (char *)(v40 + 4);
  if (v32 != v34)
  {
    do
    {
      __int128 v42 = *((_OWORD *)v32 - 1);
      *((_OWORD *)v40 - 2) = *((_OWORD *)v32 - 2);
      *((_OWORD *)v40 - 1) = v42;
      v40 -= 4;
      v32 -= 4;
    }

    while (v32 != v34);
    __int16 v34 = *(double **)a5;
  }

  *(void *)a5 = v40;
  *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v33;
  *(void *)(a5 + 16) = v41;
  if (v34) {
    operator delete(v34);
  }
LABEL_48:
  *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v33;
  double v8 = v7 + 86400.0;
LABEL_49:
  double v13 = v7;
LABEL_50:
  if (v8 <= a2)
  {
    double v43 = (void *)(a5 + 16);
    __int16 v44 = *(double **)(a5 + 8);
    do
    {
      double v45 = v13;
      double v13 = v8;
      if ((unint64_t)v44 >= *v43)
      {
        __int16 v46 = *(double **)a5;
        uint64_t v47 = ((uint64_t)v44 - *(void *)a5) >> 5;
        unint64_t v48 = v47 + 1;
        uint64_t v49 = *v43 - (void)v46;
        if (v49 >> 4 > v48) {
          unint64_t v48 = v49 >> 4;
        }
        else {
          unint64_t v50 = v48;
        }
        if (v50)
        {
          int v51 = (char *)sub_10000835C(a5 + 16, v50);
          __int16 v46 = *(double **)a5;
          __int16 v44 = *(double **)(a5 + 8);
        }

        else
        {
          int v51 = 0LL;
        }

        __int16 v52 = &v51[32 * v47];
        *(void *)__int16 v52 = 0LL;
        *((double *)v52 + 1) = v45;
        *((_DWORD *)v52 + 4) = 0;
        *((void *)v52 + 3) = 0LL;
        double v53 = v52;
        if (v44 != v46)
        {
          do
          {
            __int128 v54 = *((_OWORD *)v44 - 1);
            *((_OWORD *)v53 - 2) = *((_OWORD *)v44 - 2);
            *((_OWORD *)v53 - 1) = v54;
            v53 -= 32;
            v44 -= 4;
          }

          while (v44 != v46);
          __int16 v46 = *(double **)a5;
        }

        __int16 v44 = (double *)(v52 + 32);
        *(void *)a5 = v53;
        *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v52 + 32;
        *(void *)(a5 + 16) = &v51[32 * v50];
        if (v46) {
          operator delete(v46);
        }
      }

      else
      {
        double *v44 = 0.0;
        v44[1] = v45;
        *((_DWORD *)v44 + 4) = 0;
        v44[3] = 0.0;
        v44 += 4;
      }

      *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v44;
      double v8 = v13 + 86400.0;
    }

    while (v13 + 86400.0 <= a2);
  }

void sub_100FBC1F4(double a1, double a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  double v7 = a1;
  double v8 = a1 + 86400.0;
  uint64_t v10 = *a4;
  uint64_t v9 = a4[1];
  if (*a4 == v9) {
    goto LABEL_49;
  }
LABEL_2:
  unsigned int v12 = 0;
  double v13 = v7;
  double v7 = v8;
  double v14 = 0.0;
  do
  {
    double v15 = *(double *)(v10 + 8);
    if (v15 < v13 || v15 >= v7)
    {
      double v17 = 0.0;
      if (v14 > 0.0) {
        double v17 = v14 / (double)v12;
      }
      double v19 = *(double **)(a5 + 8);
      unint64_t v18 = *(void *)(a5 + 16);
      if ((unint64_t)v19 >= v18)
      {
        double v21 = *(double **)a5;
        uint64_t v22 = ((uint64_t)v19 - *(void *)a5) >> 5;
        unint64_t v23 = v22 + 1;
        uint64_t v24 = v18 - (void)v21;
        if (v24 >> 4 > v23) {
          unint64_t v23 = v24 >> 4;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          __int16 v26 = (char *)sub_10000835C(a5 + 16, v25);
          double v21 = *(double **)a5;
          double v19 = *(double **)(a5 + 8);
        }

        else
        {
          __int16 v26 = 0LL;
        }

        double v27 = (double *)&v26[32 * v22];
        *double v27 = 0.0;
        v27[1] = v13;
        *((_DWORD *)v27 + 4) = 1;
        v27[3] = v17;
        __int16 v28 = v27;
        if (v19 != v21)
        {
          do
          {
            __int128 v29 = *((_OWORD *)v19 - 1);
            *((_OWORD *)v28 - 2) = *((_OWORD *)v19 - 2);
            *((_OWORD *)v28 - 1) = v29;
            v28 -= 4;
            v19 -= 4;
          }

          while (v19 != v21);
          double v21 = *(double **)a5;
        }

        int v20 = (char *)(v27 + 4);
        *(void *)a5 = v28;
        *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v27 + 4;
        *(void *)(a5 + 16) = &v26[32 * v25];
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        *double v19 = 0.0;
        v19[1] = v13;
        *((_DWORD *)v19 + 4) = 1;
        int v20 = (char *)(v19 + 4);
        v19[3] = v17;
      }

      *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v20;
      double v8 = v7 + 86400.0;
      uint64_t v9 = a4[1];
      double v13 = v7;
      if (v10 == v9) {
        goto LABEL_50;
      }
      goto LABEL_2;
    }

    double v14 = v14 + *(double *)(v10 + 112);
    ++v12;
    v10 += 160LL;
  }

  while (v10 != v9);
  if (!v12)
  {
    double v8 = v7;
    goto LABEL_50;
  }

  double v30 = v14 / (double)v12;
  __int16 v32 = *(double **)(a5 + 8);
  unint64_t v31 = *(void *)(a5 + 16);
  if ((unint64_t)v32 < v31)
  {
    *__int16 v32 = 0.0;
    v32[1] = v13;
    *((_DWORD *)v32 + 4) = 1;
    v32[3] = v30;
    double v33 = (char *)(v32 + 4);
    goto LABEL_48;
  }

  __int16 v34 = *(double **)a5;
  uint64_t v35 = ((uint64_t)v32 - *(void *)a5) >> 5;
  unint64_t v36 = v35 + 1;
  if ((unint64_t)(v35 + 1) >> 59) {
LABEL_70:
  }
    sub_100007008();
  uint64_t v37 = v31 - (void)v34;
  if (v37 >> 4 > v36) {
    unint64_t v36 = v37 >> 4;
  }
  else {
    unint64_t v38 = v36;
  }
  if (v38)
  {
    int v39 = (char *)sub_10000835C(a5 + 16, v38);
    __int16 v34 = *(double **)a5;
    __int16 v32 = *(double **)(a5 + 8);
  }

  else
  {
    int v39 = 0LL;
  }

  CFAbsoluteTime v40 = (double *)&v39[32 * v35];
  int v41 = &v39[32 * v38];
  *CFAbsoluteTime v40 = 0.0;
  v40[1] = v13;
  *((_DWORD *)v40 + 4) = 1;
  v40[3] = v30;
  double v33 = (char *)(v40 + 4);
  if (v32 != v34)
  {
    do
    {
      __int128 v42 = *((_OWORD *)v32 - 1);
      *((_OWORD *)v40 - 2) = *((_OWORD *)v32 - 2);
      *((_OWORD *)v40 - 1) = v42;
      v40 -= 4;
      v32 -= 4;
    }

    while (v32 != v34);
    __int16 v34 = *(double **)a5;
  }

  *(void *)a5 = v40;
  *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v33;
  *(void *)(a5 + 16) = v41;
  if (v34) {
    operator delete(v34);
  }
LABEL_48:
  *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v33;
  double v8 = v7 + 86400.0;
LABEL_49:
  double v13 = v7;
LABEL_50:
  if (v8 <= a2)
  {
    double v43 = (void *)(a5 + 16);
    __int16 v44 = *(double **)(a5 + 8);
    do
    {
      double v45 = v13;
      double v13 = v8;
      if ((unint64_t)v44 >= *v43)
      {
        __int16 v46 = *(double **)a5;
        uint64_t v47 = ((uint64_t)v44 - *(void *)a5) >> 5;
        unint64_t v48 = v47 + 1;
        uint64_t v49 = *v43 - (void)v46;
        if (v49 >> 4 > v48) {
          unint64_t v48 = v49 >> 4;
        }
        else {
          unint64_t v50 = v48;
        }
        if (v50)
        {
          int v51 = (char *)sub_10000835C(a5 + 16, v50);
          __int16 v46 = *(double **)a5;
          __int16 v44 = *(double **)(a5 + 8);
        }

        else
        {
          int v51 = 0LL;
        }

        __int16 v52 = &v51[32 * v47];
        *(void *)__int16 v52 = 0LL;
        *((double *)v52 + 1) = v45;
        *((_DWORD *)v52 + 4) = 1;
        *((void *)v52 + 3) = 0LL;
        double v53 = v52;
        if (v44 != v46)
        {
          do
          {
            __int128 v54 = *((_OWORD *)v44 - 1);
            *((_OWORD *)v53 - 2) = *((_OWORD *)v44 - 2);
            *((_OWORD *)v53 - 1) = v54;
            v53 -= 32;
            v44 -= 4;
          }

          while (v44 != v46);
          __int16 v46 = *(double **)a5;
        }

        __int16 v44 = (double *)(v52 + 32);
        *(void *)a5 = v53;
        *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v52 + 32;
        *(void *)(a5 + 16) = &v51[32 * v50];
        if (v46) {
          operator delete(v46);
        }
      }

      else
      {
        double *v44 = 0.0;
        v44[1] = v45;
        *((_DWORD *)v44 + 4) = 1;
        v44[3] = 0.0;
        v44 += 4;
      }

      *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 128), 8) = v44;
      double v8 = v13 + 86400.0;
    }

    while (v13 + 86400.0 <= a2);
  }

BOOL sub_100FBC598(uint64_t a1, uint64_t a2)
{
  double v4 = 86400.0 * floor(CFAbsoluteTimeGetCurrent() / 86400.0) - 7776000.0;
  double v11 = 0LL;
  unsigned int v12 = 0LL;
  uint64_t v13 = 0LL;
  int v5 = sub_10024D6B4(*(void *)(a1 + 16), &v11, v4);
  if (v5 == 100)
  {
    sub_100FBC678((uint64_t *)&v11, (uint64_t)v9);
    __int128 v6 = v9[3];
    *(_OWORD *)(a2 + 32) = v9[2];
    *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v6;
    *(void *)(a2 + 64) = v10;
    __int128 v7 = v9[1];
    *(_OWORD *)a2 = v9[0];
    *(_OWORD *)(a2 + 16) = v7;
    *(double *)a2 = v4;
  }

  if (v11)
  {
    unsigned int v12 = v11;
    operator delete(v11);
  }

  return v5 == 100;
}

void sub_100FBC658(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 4_Block_object_dispose((const void *)(v1 - 128), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100FBC678(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0LL;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (*a1 != v4)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    unsigned int v30 = 0;
    uint64_t v31 = 0LL;
    double v10 = 0.0;
    double v11 = 0.0;
    double v12 = 0.0;
    double v13 = 0.0;
    double v14 = 0.0;
    double v15 = 0.0;
    double v16 = 0.0;
    double v17 = 0.0;
    do
    {
      switch(*(_DWORD *)(v3 + 16))
      {
        case 0xFFFFFFFF:
          if (qword_101934760 != -1) {
            dispatch_once(&qword_101934760, &stru_1018921B0);
          }
          unint64_t v18 = (os_log_s *)qword_101934768;
          if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Aggregate feature type not set for record",  buf,  2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934760 != -1) {
              dispatch_once(&qword_101934760, &stru_1018921B0);
            }
            v32[0] = 0;
            LODWORD(v29) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  16LL,  "Aggregate feature type not set for record",  v32,  v29);
            int v20 = (uint8_t *)v19;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCardioChange::RiskModelFeatureInput CLCardioChangeEstimator::computeRiskModelInputFromDailyAggregates(st d::vector<CLCardioChange::AggregateFeatureEntry> &)",  "%s\n",  v19);
            if (v20 != buf) {
              free(v20);
            }
          }

          break;
        case 0:
          double v21 = *(double *)(v3 + 24);
          if (v21 > 0.0)
          {
            double v10 = v21 + v10;
            *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v10;
            ++v5;
          }

          break;
        case 1:
          double v22 = *(double *)(v3 + 24);
          if (v22 > 0.0)
          {
            double v11 = v22 + v11;
            *(double *)(a2 + 16) = v11;
            ++v6;
          }

          break;
        case 2:
          double v23 = *(double *)(v3 + 24);
          if (v23 > 0.0)
          {
            double v12 = v23 + v12;
            *(double *)(a2 + 24) = v12;
            ++v7;
          }

          break;
        case 3:
          double v24 = *(double *)(v3 + 24);
          if (v24 > 0.0)
          {
            double v13 = v24 + v13;
            *(double *)(a2 + 32) = v13;
            ++v8;
          }

          break;
        case 4:
          double v25 = *(double *)(v3 + 24);
          if (v25 > 0.0)
          {
            double v14 = v25 + v14;
            *(double *)(a2 + 40) = v14;
            ++v9;
          }

          break;
        case 5:
          double v26 = *(double *)(v3 + 24);
          if (v26 > 0.0)
          {
            double v15 = v26 + v15;
            *(double *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v15;
            ++v30;
          }

          break;
        case 6:
          double v27 = *(double *)(v3 + 24);
          if (v27 > 0.0)
          {
            double v16 = v27 + v16;
            *(double *)(a2 + 56) = v16;
            LODWORD(v31) = v31 + 1;
          }

          break;
        case 7:
          double v28 = *(double *)(v3 + 24);
          if (v28 > 0.0)
          {
            double v17 = v28 + v17;
            *(double *)(a2 + 64) = v17;
            ++HIDWORD(v31);
          }

          break;
        default:
          break;
      }

      v3 += 32LL;
    }

    while (v3 != v4);
    if (v5) {
      *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v10 / (double)v5;
    }
    if (v6) {
      *(double *)(a2 + 16) = v11 / (double)v6;
    }
    if (v7) {
      *(double *)(a2 + 24) = v12 / (double)v7;
    }
    if (v8) {
      *(double *)(a2 + 32) = v13 / (double)v8;
    }
    if (v9) {
      *(double *)(a2 + 40) = v14 / (double)v9;
    }
    if (v30) {
      *(double *)(a2 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v15 / (double)v30;
    }
    if ((_DWORD)v31) {
      *(double *)(a2 + 56) = v16 / (double)v31;
    }
    if (HIDWORD(v31)) {
      *(double *)(a2 + 64) = v17 / (double)HIDWORD(v31);
    }
  }

uint64_t sub_100FBCA70(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  v12[0] = 0LL;
  double v4 = *(double *)(a2 + 8);
  v12[1] = *(void *)a2;
  if (v4 > 0.0)
  {
    int v13 = 8;
    double v14 = v4;
    double result = sub_10024D4E8(*(void *)(result + 16), (uint64_t)v12);
  }

  double v5 = *(double *)(a2 + 16);
  if (v5 > 0.0)
  {
    int v13 = 9;
    double v14 = v5;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v6 = *(double *)(a2 + 24);
  if (v6 > 0.0)
  {
    int v13 = 10;
    double v14 = v6;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v7 = *(double *)(a2 + 32);
  if (v7 > 0.0)
  {
    int v13 = 11;
    double v14 = v7;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v8 = *(double *)(a2 + 40);
  if (v8 > 0.0)
  {
    int v13 = 12;
    double v14 = v8;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v9 = *(double *)(a2 + 48);
  if (v9 > 0.0)
  {
    int v13 = 13;
    double v14 = v9;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v10 = *(double *)(a2 + 56);
  if (v10 > 0.0)
  {
    int v13 = 14;
    double v14 = v10;
    double result = sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  double v11 = *(double *)(a2 + 64);
  if (v11 > 0.0)
  {
    int v13 = 15;
    double v14 = v11;
    return sub_10024D4E8(*(void *)(v3 + 16), (uint64_t)v12);
  }

  return result;
}

void sub_100FBCBC0(uint64_t a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = Current;
  *(_DWORD *)(a3 + 16) = -1;
  *(void *)(a3 + 24) = 0LL;
  if (!*(_BYTE *)(a1 + 120))
  {
    *(_DWORD *)(a3 + 16) = 4;
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    __int16 v32 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(CFAbsoluteTime *)int v60 = Current;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "Age not set, can't run risk model, startTime %f",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    uint64_t v28 = qword_101934768;
    *(_DWORD *)uint64_t v47 = 134217984;
    *(CFAbsoluteTime *)&v47[4] = Current;
    LODWORD(v46) = 12;
    uint64_t v29 = "Age not set, can't run risk model, startTime %f";
LABEL_56:
    uint64_t v31 = 1LL;
LABEL_57:
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  v31,  v29,  v47,  *(void *)&v46,  *(_OWORD *)v47,  *(void *)&v47[16]);
    double v45 = (uint8_t *)v44;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCardioChange::EstimateResult CLCardioChangeEstimator::runRiskModel(CLCardioChange::RiskModelFeatureInput &)",  "%s\n",  v44);
    if (v45 != buf) {
      free(v45);
    }
    return;
  }

  if (!*(_DWORD *)(a1 + 68))
  {
    *(_DWORD *)(a3 + 16) = 5;
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    double v33 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(CFAbsoluteTime *)int v60 = Current;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "Sex not set, can't run risk model startTime %f",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    uint64_t v28 = qword_101934768;
    *(_DWORD *)uint64_t v47 = 134217984;
    *(CFAbsoluteTime *)&v47[4] = Current;
    LODWORD(v46) = 12;
    uint64_t v29 = "Sex not set, can't run risk model startTime %f";
    goto LABEL_56;
  }

  sub_100FBD3A8(a1, a2);
  if (qword_101934760 != -1) {
    dispatch_once(&qword_101934760, &stru_1018921B0);
  }
  double v7 = (os_log_s *)qword_101934768;
  if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = *((void *)a2 + 1);
    uint64_t v9 = *((void *)a2 + 2);
    uint64_t v10 = *((void *)a2 + 3);
    uint64_t v11 = *((void *)a2 + 4);
    uint64_t v12 = *((void *)a2 + 5);
    uint64_t v13 = *((void *)a2 + 6);
    uint64_t v14 = *((void *)a2 + 7);
    uint64_t v15 = *((void *)a2 + 8);
    *(_DWORD *)std::string buf = 134219776;
    *(void *)int v60 = v8;
    *(_WORD *)&v60[8] = 2048;
    *(void *)&v60[10] = v9;
    __int16 v61 = 2048;
    uint64_t v62 = v10;
    __int16 v63 = 2048;
    uint64_t v64 = v11;
    __int16 v65 = 2048;
    uint64_t v66 = v12;
    __int16 v67 = 2048;
    uint64_t v68 = v13;
    __int16 v69 = 2048;
    uint64_t v70 = v14;
    __int16 v71 = 2048;
    uint64_t v72 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Inputs used in the risk model after imputation,sessionVo2maxDailyMean_Window0to90_Mean,%.2f, sessionHRRecovery_Dai lyMean_Window0to90_Mean,%.2f, heartRateDailyMax_Window0To90_Mean,%.2f, sixMinuteWalkDistanceDailyMean_Window0To90_ Mean,%.2f,walkingHeartRateAverageDailyMean_Window0To90_Mean, %.2f,walkingSpeedNormLegLengthDailyMax_Window0to90_Me an,%.2f,stairAscentSpeedDailyMean_Window0to90_Mean,%.2f, stairDescentSpeedDailyMean_Window0to90_Mean,%.2f",  buf,  0x52u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    uint64_t v34 = *((void *)a2 + 1);
    uint64_t v35 = *((void *)a2 + 2);
    uint64_t v36 = *((void *)a2 + 3);
    uint64_t v37 = *((void *)a2 + 4);
    uint64_t v38 = *((void *)a2 + 5);
    uint64_t v39 = *((void *)a2 + 6);
    uint64_t v40 = *((void *)a2 + 7);
    uint64_t v41 = *((void *)a2 + 8);
    *(_DWORD *)uint64_t v47 = 134219776;
    *(void *)&v47[4] = v34;
    *(_WORD *)&v47[12] = 2048;
    *(void *)&v47[14] = v35;
    *(_WORD *)&v47[22] = 2048;
    uint64_t v48 = v36;
    __int16 v49 = 2048;
    uint64_t v50 = v37;
    __int16 v51 = 2048;
    uint64_t v52 = v38;
    __int16 v53 = 2048;
    uint64_t v54 = v39;
    __int16 v55 = 2048;
    uint64_t v56 = v40;
    __int16 v57 = 2048;
    uint64_t v58 = v41;
    LODWORD(v46) = 82;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  1LL,  "Inputs used in the risk model after imputation,sessionVo2maxDailyMean_Window0to90_Mean,%.2f, sessionHRRecovery_Dai lyMean_Window0to90_Mean,%.2f, heartRateDailyMax_Window0To90_Mean,%.2f, sixMinuteWalkDistanceDailyMean_Window0To90_ Mean,%.2f,walkingHeartRateAverageDailyMean_Window0To90_Mean, %.2f,walkingSpeedNormLegLengthDailyMax_Window0to90_Me an,%.2f,stairAscentSpeedDailyMean_Window0to90_Mean,%.2f, stairDescentSpeedDailyMean_Window0to90_Mean,%.2f",  COERCE_DOUBLE(v47),  v46);
    double v43 = (uint8_t *)v42;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCardioChange::EstimateResult CLCardioChangeEstimator::runRiskModel(CLCardioChange::RiskModelFeatureInput &)",  "%s\n",  v42);
    if (v43 != buf) {
      free(v43);
    }
  }

  double v16 = a2[1];
  if (v16 <= 0.0
    || (double v17 = a2[2], v17 <= 0.0)
    || (double v18 = a2[3], v18 <= 0.0)
    || (double v19 = a2[4], v19 <= 0.0)
    || (double v20 = a2[7], v20 <= 0.0)
    || (double v21 = a2[8], v21 <= 0.0)
    || (double v22 = a2[5], v22 <= 0.0)
    || (double v23 = a2[6], v23 <= 0.0))
  {
    *(_DWORD *)(a3 + 16) = 2;
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    unsigned int v30 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Could not run risk model due to insufficient input data",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      uint64_t v28 = qword_101934768;
      *(_WORD *)uint64_t v47 = 0;
      LODWORD(v46) = 2;
      uint64_t v29 = "Could not run risk model due to insufficient input data";
      goto LABEL_34;
    }
  }

  else
  {
    double v24 = 0.0;
    if (*(_DWORD *)(a1 + 68) == 1) {
      double v24 = 1.0;
    }
    double v25 = 1.0
        / (exp(-(v24 * -0.580510263
               + 2.56936377
               + *(float *)(a1 + 84) * 0.0375412183
               + v16 * -0.0434542339
               + v17 * -0.00687964534
               + v18 * -0.018156946
               + v19 * -0.00298962705
               + v20 * -1.63084493
               + v21 * -3.3056337
               + v22 * -0.0141687166
               + v23 * -1.90431624))
         + 1.0);
    *(double *)(a3 + 24) = v25;
    sub_101204164(buf, "CardioChangeRiskModelAlertThreshold", &qword_1013BBD88, 0);
    BOOL v26 = v25 >= *(double *)&v60[4];
    *(_DWORD *)(a3 + 16) = v26;
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_1018921B0);
    }
    double v27 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      *(double *)int v60 = v25;
      *(_WORD *)&v60[8] = 1024;
      *(_DWORD *)&v60[10] = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Risk model run successful, score, %f, status, %d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_1018921B0);
      }
      uint64_t v28 = qword_101934768;
      *(_DWORD *)uint64_t v47 = 134218240;
      *(double *)&v47[4] = v25;
      *(_WORD *)&v47[12] = 1024;
      *(_DWORD *)&v47[14] = v26;
      LODWORD(v46) = 18;
      uint64_t v29 = "Risk model run successful, score, %f, status, %d";
LABEL_34:
      uint64_t v31 = 0LL;
      goto LABEL_57;
    }
  }

double sub_100FBD3A8(uint64_t a1, double *a2)
{
  if (a2[1] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 8);
    a2[1] = v8;
  }

  if (a2[2] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 9);
    a2[2] = v8;
  }

  if (a2[3] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 10);
    a2[3] = v8;
  }

  if (a2[4] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 11);
    a2[4] = v8;
  }

  if (a2[5] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 12);
    a2[5] = v8;
  }

  if (a2[6] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 13);
    a2[6] = v8;
  }

  if (a2[7] == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 14);
    a2[7] = v8;
  }

  double result = a2[8];
  if (result == 0.0)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    int v7 = -1;
    double v8 = 0.0;
    sub_10024DA50(*(void *)(a1 + 16), (uint64_t)&v5, 15);
    double result = v8;
    a2[8] = v8;
  }

  return result;
}

void sub_100FBD570(id a1)
{
  qword_101934768 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CardioChange");
}

uint64_t sub_100FBD59C(uint64_t a1, const void **a2, uint64_t a3)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  double v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_100FBD618((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 4;
      v6 -= 32LL;
    }

    while (v6);
  }

  return a1;
}

void sub_100FBD600(_Unwind_Exception *a1)
{
}

uint64_t *sub_100FBD618(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_1003F9A10(a1, a2, &v10, &v9, a3);
  double result = *v6;
  if (!*v6)
  {
    sub_100FBD698((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000085FC(a1, (uint64_t)v10, v6, v8);
    return v8;
  }

  return result;
}

double sub_100FBD698@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  int v7 = v6 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1010DD48C(v7, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)int v7 = *(_OWORD *)a2;
    *((void *)v6 + 6) = *(void *)(a2 + 16);
  }

  double result = *(double *)(a2 + 24);
  *((double *)v6 + 7) = result;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_100FBD720(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100022988(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBD73C()
{
  v2[3] = (const void *)0x401ED552E2FBE33BLL;
  sub_1010DDBC0(v3, "activeEnergyBurned");
  v3[3] = 0x3F8700CD855970B5LL;
  sub_1010DDBC0(v4, "meanMaxHRPerDay");
  __int128 v4[3] = 0xC0084A6FC58AB92CLL;
  sub_1010DDBC0(v5, "meanRestingHRPerDay");
  void v5[3] = 0x3F9BABEAD4F5903ALL;
  sub_1010DDBC0(v6, "mean6MWTDPerDay");
  void v6[3] = 0xBF69BB2788DB0575LL;
  sub_1010DDBC0(v7, "meanWalkingSpeedPerDay");
  v7[3] = 0xC02AE4DD0D8CB07DLL;
  sub_100FBD59C((uint64_t)&unk_10199F970, v2, 6LL);
  for (uint64_t i = 0LL; i != -24; i -= 4LL)
  {
    if (SHIBYTE(v7[i + 2]) < 0) {
      operator delete((void *)v7[i]);
    }
  }

  return __cxa_atexit((void (*)(void *))sub_100FBACB0, &unk_10199F970, (void *)&_mh_execute_header);
}

void sub_100FBD8E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = 0LL;
  while (1)
  {
    v12 -= 32LL;
    if (v12 == -192) {
      _Unwind_Resume(exception_object);
    }
  }

void sub_100FBD950()
{
}

void *sub_100FBD958@<X0>(void *a1@<X8>)
{
  double result = operator new(8uLL);
  *double result = &off_1018921E0;
  *a1 = result;
  return result;
}

BOOL sub_100FBD98C()
{
  return sub_1004F7500();
}

uint64_t sub_100FBD9A0()
{
  return sub_1001B9A1C();
}

BOOL sub_100FBD9B8()
{
  id v0 = -[objc_class getActivePairedDevice]( -[objc_class sharedInstance](off_101992C68(), "sharedInstance"),  "getActivePairedDevice");
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_101892270);
  }
  uint64_t v1 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 67240192;
    BOOL v7 = v0 != 0LL;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "@GtsMgr, nrIsPairingActive, %{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_101892270);
    }
    v5[0] = 67240192;
    v5[1] = v0 != 0LL;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, nrIsPairingActive, %{public}d",  v5,  8);
    double v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual BOOL CLTileSyncManagerExternal::isPairingActive() const", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  return v0 != 0LL;
}

uint64_t sub_100FBDB8C()
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_101892270);
  }
  id v0 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "GtsMgr, canDownload, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_101892270);
    }
    v4[0] = 67109120;
    v4[1] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "GtsMgr, canDownload, %d",  v4);
    uint64_t v3 = (uint8_t *)v2;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLTileSyncManagerExternal::canWatchDownloadTiles() const",  "%s\n",  v2);
    if (v3 != buf) {
      free(v3);
    }
  }

  return 0LL;
}

double sub_100FBDD2C()
{
  id v0 = -[objc_class getActivePairedDevice]( -[objc_class sharedInstance](off_101992C68(), "sharedInstance"),  "getActivePairedDevice");
  id v1 = [v0 valueForProperty:off_101992C70()];
  if (v1)
  {
    [v1 timeIntervalSinceNow];
    return -v2;
  }

  else
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_101892270);
    }
    double v4 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "@GtsSync, inactive nil", buf, 2u);
    }

    double v3 = 1209600.0;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_101892270);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, inactive nil",  v8,  2);
      BOOL v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLTileSyncManagerExternal::getWatchInactiveTime() const",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  return v3;
}

BOOL sub_100FBDF04()
{
  return sub_1002958AC() == 1;
}

Class sub_100FBDF20()
{
  if (qword_10199F990 != -1) {
    dispatch_once(&qword_10199F990, &stru_101892250);
  }
  Class result = objc_getClass("NRPairedDeviceRegistry");
  qword_10199F988 = (uint64_t)result;
  off_101992C68 = sub_100FBDF7C;
  return result;
}

uint64_t sub_100FBDF7C()
{
  return qword_10199F988;
}

void sub_100FBDF88(id a1)
{
  qword_10199F998 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/NanoRegistry.framework/NanoRegistry", 2);
}

void sub_100FBDFB0(id a1)
{
  qword_101934868 = (uint64_t)os_log_create("com.apple.locationd.Position", "WifiPosition");
}

uint64_t sub_100FBDFDC()
{
  if (qword_10199F990 != -1) {
    dispatch_once(&qword_10199F990, &stru_101892250);
  }
  id v0 = (uint64_t *)dlsym((void *)qword_10199F998, "NRDevicePropertyLastInactiveDate");
  if (v0)
  {
    uint64_t result = *v0;
    qword_10199F9A0 = result;
  }

  else
  {
    uint64_t result = qword_10199F9A0;
  }

  off_101992C70 = sub_100FBE054;
  return result;
}

uint64_t sub_100FBE054()
{
  return qword_10199F9A0;
}

void sub_100FBE518(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t **sub_100FBE544(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  BOOL v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        BOOL v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        BOOL v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    sub_1000085FC(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }

  return v9;
}

BOOL sub_100FBE604()
{
  return os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT);
}

BOOL sub_100FBE618()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2520), OS_LOG_TYPE_INFO);
}

BOOL sub_100FBE628()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2520));
}

void sub_100FBE6E0(_Unwind_Exception *a1)
{
}

id sub_100FBE6F4(uint64_t a1, void *a2)
{
  return _[a2 onSurfaceCalibration:a1];
}

void sub_100FBEA9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100FBEAF0(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

void *sub_100FBEB1C(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a1 = off_1018A2210;
  id v9 = a5;
  *a1 = off_1018922E0;
  a1[1] = v9;
  a1[2] = a3;
  a1[3] = a4;
  id v10 = a2;
  a1[5] = 0LL;
  a1[4] = v10;
  a1[6] = 0LL;
  v14[0] = 0LL;
  v14[1] = v14;
  _DWORD v14[2] = 0x2020000000LL;
  char v15 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472LL;
  aBlock[2] = sub_100FBEC50;
  aBlock[3] = &unk_10182EFC8;
  aBlock[4] = v14;
  a1[5] = _Block_copy(aBlock);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  void v12[2] = sub_100FBEC64;
  void v12[3] = &unk_10182EFF0;
  _DWORD v12[4] = v14;
  a1[6] = _Block_copy(v12);
  _Block_object_dispose(v14, 8);
  return a1;
}

void sub_100FBEC28(_Unwind_Exception *a1)
{
}

uint64_t sub_100FBEC50(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  return result;
}

BOOL sub_100FBEC64(uint64_t a1)
{
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void sub_100FBEC80(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100FBEF3C(a1);
  operator delete(v1);
}

id sub_100FBEC94(void *a1, int a2, void *__src, unint64_t a4)
{
  *(void *)&__uuid_t dst = 0x7FEFFFFFFFFFFFFFLL;
  if (a4 >= 0x10) {
    size_t v8 = 16LL;
  }
  else {
    size_t v8 = a4;
  }
  memcpy(&__dst, __src, v8);
  if (a4 >= 0x11)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892320);
    }
    id v9 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 136315906;
      unint64_t v31 = 0x80000001013BBE2ALL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v32 = 2048;
      uint64_t v33 = 16LL;
      __int16 v34 = 2048;
      unint64_t v35 = a4;
      __int16 v36 = 1024;
      int v37 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892320);
      }
      int v22 = 136315906;
      unint64_t v23 = 0x80000001013BBE2ALL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v24 = 2048;
      uint64_t v25 = 16LL;
      __int16 v26 = 2048;
      unint64_t v27 = a4;
      __int16 v28 = 1024;
      int v29 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  (const char *)&v22,  38,  v17,  LODWORD(v18[0]));
      double v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMotionNotifier::SiloDispatcher<CLWaterSubmersion_Types::CMSurfaceCalibrationSample>::dispatchData (int, const void *, size_t) [T = CLWaterSubmersion_Types::CMSurfaceCalibrationSample]",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

  uint64_t v11 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v12 = a1[6];
  uint64_t v13 = (void *)a1[4];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  v18[2] = sub_100FBEF94;
  v18[3] = &unk_101861860;
  v18[4] = v12;
  v18[5] = v11;
  __int128 v19 = __dst;
  uint64_t v20 = v10;
  return [v13 async:v18];
}

uint64_t sub_100FBEF3C(uint64_t a1)
{
  *(void *)a1 = off_1018922E0;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));

  return sub_1011C07F8(a1);
}

uint64_t sub_100FBEF94(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, void))(a1 + 40))(a1 + 48, *(void *)(a1 + 64));
  }
  return result;
}

void sub_100FBEFD8(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100FBF004(uint64_t a1)
{
  *(void *)a1 = &off_101892350;
  sub_100208DE8(a1 + 8);
  *(void *)(a1 + 32) = 0x4090000041900000LL;
  uint64_t v2 = sub_1006E27E8();
  sub_100413284(v2, &v7);
  sub_1002A81F8(v7, "SemiStatVMThreshold", (float *)(a1 + 32));
  double v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  return a1;
}

void sub_100FBF0A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100FBF0C0(uint64_t a1, float a2)
{
  uint64_t result = sub_100FBF004(a1);
  *(float *)(result + 36) = a2;
  return result;
}

uint64_t sub_100FBF0E8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(**(void **)(a2 + 40) + 48LL))(*(void *)(a2 + 40));
}

void sub_100FBF0F8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + 24) = 3LL;
  *(void *)(a3 + 32) = 3LL;
  float v6 = *(float *)(a2 + 296);
  if (*(_BYTE *)(a2 + 352) || v6 > 1.0)
  {
    int v7 = *(unsigned __int8 *)(a2 + 324);
    BOOL v8 = *(_BYTE *)(a2 + 324) == 0;
    sub_100208DEC(a1 + 8, a2, (uint64_t)buf);
    float v9 = *(float *)&v49;
    float v10 = *(float *)v50;
    *(_DWORD *)(a3 + 32) = 0;
    float v11 = 0.0;
    if (v6 > *(float *)(a1 + 32))
    {
      sub_1004493F4();
      float v11 = v12;
    }

    float v13 = flt_1013BBE70[v8];
    if (*(_BYTE *)(a2 + 352))
    {
      int v14 = *(_DWORD *)(a1 + 36);
      *(float *)std::string buf = v9;
      int v46 = v14;
      *(float *)uint64_t v47 = v13;
      *(float *)&v47[4] = v11;
      uint64_t v15 = 4LL;
      float v16 = v9;
      uint64_t v17 = buf;
      do
      {
        if (v16 < *(float *)&buf[v15])
        {
          float v16 = *(float *)&buf[v15];
          uint64_t v17 = &buf[v15];
        }

        v15 += 4LL;
      }

      while (v15 != 16);
      float v18 = *(float *)v17;
      *(_DWORD *)(a3 + 20) = *(_DWORD *)v17;
      *(float *)std::string buf = v10;
      int v46 = 1067869798;
      *(float *)uint64_t v47 = v13;
      *(float *)&v47[4] = v11;
      uint64_t v19 = 4LL;
      float v20 = v10;
      double v21 = buf;
      do
      {
        if (v20 < *(float *)&buf[v19])
        {
          float v20 = *(float *)&buf[v19];
          double v21 = &buf[v19];
        }

        v19 += 4LL;
      }

      while (v19 != 16);
      float v22 = *(float *)v21;
    }

    else
    {
      if (v9 >= v13) {
        float v23 = v9;
      }
      else {
        float v23 = flt_1013BBE70[v8];
      }
      if (v23 >= v11) {
        float v18 = v23;
      }
      else {
        float v18 = v11;
      }
      *(float *)(a3 + 20) = v18;
      if (v10 >= v13) {
        float v24 = v10;
      }
      else {
        float v24 = v13;
      }
      if (v24 >= v11) {
        float v22 = v24;
      }
      else {
        float v22 = v11;
      }
    }

    *(float *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v22;
    *(float *)(a3 + 12) = v22;
    if (v22 != v10 || v10 <= 2.1) {
      int v26 = 1;
    }
    else {
      int v26 = 12;
    }
    *(_DWORD *)(a3 + 36) = v26;
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101892390);
    }
    unint64_t v27 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v28 = *(void *)(a2 + 112);
      int v29 = *(_DWORD *)(a2 + 152);
      double v30 = *(float *)(a1 + 36);
      *(_DWORD *)std::string buf = 67111424;
      int v46 = v7;
      *(_WORD *)uint64_t v47 = 2048;
      *(double *)&_OWORD v47[2] = v11;
      __int16 v48 = 2048;
      double v49 = v9;
      *(_WORD *)uint64_t v50 = 2048;
      *(double *)&_OWORD v50[2] = v13;
      __int16 v51 = 2048;
      double v52 = v18;
      __int16 v53 = 2048;
      uint64_t v54 = v28;
      __int16 v55 = 2048;
      double v56 = v22;
      __int16 v57 = 2048;
      double v58 = v10;
      __int16 v59 = 1024;
      int v60 = v29;
      __int16 v61 = 2048;
      double v62 = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Semistationary, Standing, %d, metsFromIntensity, %.1f, userMetsFromSteps, %.1f, metsFromPosture, %.1f, userMetsF inal, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromSteps, %.1f, activityType, %d, floor, %f",  buf,  0x5Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101892390);
      }
      uint64_t v31 = *(void *)(a2 + 112);
      int v32 = *(_DWORD *)(a2 + 152);
      double v33 = *(float *)(a1 + 36);
      LODWORD(v36) = 67111424;
      HIDWORD(v36) = v7;
      *(_WORD *)int v37 = 2048;
      *(double *)&v37[2] = v11;
      *(_WORD *)&v37[10] = 2048;
      *(double *)&v37[12] = v9;
      *(_WORD *)&v37[20] = 2048;
      *(double *)&v37[22] = v13;
      *(_WORD *)&v37[30] = 2048;
      *(_WORD *)uint64_t v38 = 2048;
      *(void *)&void v38[2] = v31;
      *(_WORD *)&v38[10] = 2048;
      *(double *)&v38[12] = v22;
      __int16 v39 = 2048;
      double v40 = v10;
      __int16 v41 = 1024;
      int v42 = v32;
      __int16 v43 = 2048;
      double v44 = v33;
      LODWORD(v35) = 94;
      __int16 v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Semistationary, Standing, %d, metsFromIntensity, %.1f, userMetsFromSteps, %.1f, metsFromPosture, % .1f, userMetsFinal, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromSteps, %.1f, activ ityType, %d, floor, %f",  &v36,  v35,  v36,  *(double *)v37,  *(double *)&v37[8],  *(double *)&v37[16],  *(double *)&v37[24],  v18,  *(_DWORD *)v38,  *(double *)&v38[8]);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieSemiStatModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v34);
    }
  }

void sub_100FBF51C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100FBF548(uint64_t a1)
{
  *(void *)a1 = off_1018923C0;
  *(_WORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0;
  *(_DWORD *)(a1 + 12) = 1067030938;
  int v8 = -1;
  uint64_t v2 = sub_1002F8DDC();
  sub_1002A7D20(v2, (uint64_t)@"NumActiveCalibrations", &v8);
  if (v8 >= 1) {
    *(_DWORD *)(a1 + 12) = 1067869798;
  }
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101892410);
  }
  double v3 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    double v4 = *(float *)(a1 + 12);
    *(_DWORD *)std::string buf = 134217984;
    double v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Pedestrian, metsHrUpperBound, %.1f ", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101892410);
    }
    double v6 = *(float *)(a1 + 12);
    int v9 = 134217984;
    double v10 = v6;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Pedestrian, metsHrUpperBound, %.1f ",  COERCE_DOUBLE(&v9));
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCaloriePedestrianModelInterface::CLCaloriePedestrianModelInterface()",  "%s\n",  v7);
  }

  return a1;
}

void sub_100FBF75C(int a1, float a2, float a3, float a4)
{
  if (a1 == 1 && a4 > 0.0)
  {
    if (a3 >= 0.5) {
      float v4 = a2 / a3;
    }
    else {
      float v4 = 0.0;
    }
    pow(v4, 3.0);
    pow(v4, 4.0);
    pow(v4, 5.0);
  }

uint64_t sub_100FBF864(uint64_t a1, double *a2)
{
  double v2 = a2[70];
  if (v2 <= 0.0) {
    return 0LL;
  }
  double v3 = a2[57];
  if (v3 <= 0.0) {
    return 0LL;
  }
  double v4 = vabdd_f64(v2 / (v3 * 60.0), round(v2 / (v3 * 60.0)));
  double v5 = vabdd_f64(0.5, v4);
  if (v5 >= v4) {
    double v5 = v4;
  }
  double v6 = a2[71];
  if (v5 < 0.05 && v6 < 0.899999976) {
    return 1LL;
  }
  if (v5 >= 0.05 && (v5 <= 0.075 ? (BOOL v7 = v6 < 0.75) : (BOOL v7 = 0), v7)) {
    return 1LL;
  }
  else {
    return 0LL;
  }
}

float sub_100FBF8F8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1003DBFB4(a2);
  float v4 = 0.0;
  if ((_DWORD)v3 && *(double *)(a2 + 600) < *(double *)a2 && (sub_100FBF864(v3, (double *)a2) & 1) == 0)
  {
    float v6 = *(float *)(a2 + 1380);
    float v7 = *(float *)(a2 + 1384);
    float v8 = 1.0;
    if (v6 > v7)
    {
      float v9 = *(double *)(a2 + 560);
      float v8 = (v6 - v9) / (v6 - v7);
    }

    float v5 = *(float *)(a2 + 1368);
    return v5 * sub_100D086F8(v8, *(float *)(a2 + 1372));
  }

  return v4;
}

void sub_100FBF994(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + 24) = 3LL;
  *(void *)(a3 + 32) = 3LL;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 40LL))(&v36);
  float v6 = (*(void *(**)(double *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 48LL))(v31, a1, a2);
  float v7 = sub_100FBF8F8((uint64_t)v6, a2);
  *(float *)a3 = v7;
  float v8 = v38;
  *(_DWORD *)(a3 + 12) = v37;
  *(_DWORD *)(a3 + 36) = v40;
  float v9 = -1.0;
  if (v7 > 0.0) {
    float v9 = (float)(v7 - v8) / v8;
  }
  *(float *)(a3 + 16) = v9;
  BOOL v11 = v8 > 2.1 && *(_BYTE *)(a1 + 8) != 0;
  BOOL v12 = v9 > 0.1 && v11;
  if (v12)
  {
    float v13 = v7;
    float v14 = v7;
    if (!*(_BYTE *)(a1 + 9))
    {
      float v15 = *(float *)(a1 + 12);
      float v16 = v8 * v15;
      if (v16 >= v7) {
        float v13 = v7;
      }
      else {
        float v13 = v16;
      }
      else {
        float v14 = v15 * v39;
      }
    }

    *(float *)(a3 + 20) = v13;
    *(float *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v14;
    int v17 = 1;
    *(_DWORD *)(a3 + 24) = 1;
  }

  else
  {
    float v18 = *((float *)&v34 + 1);
    BOOL v19 = v33 > v8;
    if (v33 >= v8) {
      float v13 = v33;
    }
    else {
      float v13 = v8;
    }
    *(float *)(a3 + 20) = v13;
    *(_DWORD *)(a3 + 24) = 4 * v19;
    BOOL v20 = v18 > v39;
    if (v18 >= v39) {
      float v14 = v18;
    }
    else {
      float v14 = v39;
    }
    *(float *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v14;
    int v17 = 4 * v20;
  }

  *(_DWORD *)(a3 + 32) = v17;
  int v21 = *(unsigned __int8 *)(a2 + 324);
  unsigned __int8 v22 = sub_100FBFD6C(*(unsigned int *)(a2 + 288));
  float v23 = 1.6;
  if (((v21 != 0) & v22) != 0) {
    float v23 = 2.1;
  }
  if (v14 <= v23) {
    float v24 = v23;
  }
  else {
    float v24 = *(float *)(a3 + 28);
  }
  *(float *)(a3 + 2_Block_object_dispose((const void *)(v1 - 128), 8) = v24;
  float v25 = v38;
  float v26 = v33;
  *(float *)(a3 + 4) = v38;
  *(float *)(a3 + _Block_object_dispose((const void *)(v1 - 128), 8) = v26;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101892410);
  }
  unint64_t v27 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 134219520;
    double v56 = v25;
    __int16 v57 = 2048;
    double v58 = v26;
    __int16 v59 = 2048;
    double v60 = v7;
    __int16 v61 = 2048;
    double v62 = v9;
    __int16 v63 = 1024;
    BOOL v64 = v12;
    __int16 v65 = 2048;
    double v66 = v13;
    __int16 v67 = 2048;
    double v68 = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Pedestrian, wrMets, %f,  fmMets, %f, hrMets, %f, hrwrDiff, %f, useHrMets, %d, userMets, %f, truthMets, %f",  buf,  0x44u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101892410);
    }
    int v41 = 134219520;
    double v42 = v25;
    __int16 v43 = 2048;
    double v44 = v26;
    __int16 v45 = 2048;
    double v46 = v7;
    __int16 v47 = 2048;
    double v48 = v9;
    __int16 v49 = 1024;
    BOOL v50 = v12;
    __int16 v51 = 2048;
    double v52 = v13;
    __int16 v53 = 2048;
    double v54 = v24;
    LODWORD(v30) = 68;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Pedestrian, wrMets, %f,  fmMets, %f, hrMets, %f, hrwrDiff, %f, useHrMets, %d, userMets, %f, truthMets, %f",  COERCE_DOUBLE(&v41),  v30,  v31[0],  v31[1],  v32,  v34,  v35);
    int v29 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLCaloriePedestrianModelInterface::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v28);
    if (v29 != buf) {
      free(v29);
    }
  }

uint64_t sub_100FBFD6C(uint64_t a1)
{
  if ((CLMotionActivity::isTypePedestrian(a1) & 1) != 0) {
    return 1LL;
  }
  LODWORD(result) = CLMotionActivity::isTypeIndoorPedestrian(a1);
  else {
    return result;
  }
}

uint64_t sub_100FBFDAC(double a1, uint64_t a2, void **a3)
{
  int v5 = CLMotionActivity::isTypePedestrian(v9[2]) ^ 1;
  if (v10) {
    int v6 = v5;
  }
  else {
    int v6 = 1;
  }
  unsigned int v7 = (*(uint64_t (**)(void *, double))(*a3[5] + 48LL))(a3[5], a1);
  uint64_t result = v6 & v7;
  if ((v6 & 1) == 0)
  {
    if (v7) {
      return (*(uint64_t (**)(void *, double))(*a3[3] + 48LL))(a3[3], a1);
    }
  }

  return result;
}

void sub_100FBFE74(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100FBFEA0(uint64_t a1)
{
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 256LL;
  *(_DWORD *)a1 = 8;
  double v2 = &_mh_execute_header;
  uint64_t v3 = 152LL;
  float64x2_t v11 = (float64x2_t)vdupq_n_s64(0x3F80000000000000uLL);
  float64x2_t v12 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
  do
  {
    int32x2_t v4 = vneg_s32((int32x2_t)v2);
    v5.i64[0] = v4.i32[0];
    v5.i64[1] = v4.i32[1];
    float32x2_t v6 = vcvt_f32_f64(vmulq_f64(vmulq_f64(vcvtq_f64_s64(v5), v12), v11));
    float v13 = v6.f32[0];
    __float2 v7 = __sincosf_stret(v6.f32[1]);
    __float2 v8 = __sincosf_stret(v13);
    v14.val[1] = (float32x2_t)__PAIR64__(LODWORD(v7.__sinval), LODWORD(v8.__sinval));
    v14.val[0] = (float32x2_t)__PAIR64__(LODWORD(v7.__cosval), LODWORD(v8.__cosval));
    float v9 = (float *)(a1 + v3);
    vst2_f32(v9, v14);
    double v2 = (const mach_header_64 *)vadd_s32((int32x2_t)v2, (int32x2_t)0x200000002LL);
    v3 += 16LL;
  }

  while (v3 != 2200);
  sub_100FBFF90(256LL, (int *)(a1 + 16));
  return a1;
}

uint64_t sub_100FBFF90(uint64_t result, int *a2)
{
  float v2 = sqrtf((float)(int)result);
  int v3 = 4;
  do
  {
    while ((int)result % v3)
    {
      int v4 = v3 + 2;
      if (v3 == 2) {
        int v4 = 3;
      }
      if (v3 == 4) {
        int v3 = 2;
      }
      else {
        int v3 = v4;
      }
    }

    uint64_t result = ((int)result / v3);
    *a2 = v3;
    a2[1] = result;
    a2 += 2;
  }

  while ((int)result > 1);
  return result;
}

void sub_100FBFFEC(uint64_t a1, _DWORD *a2, unsigned __int16 *a3)
{
  int64x2_t v5 = (int *)(a1 + 8);
  bzero(&v13, 8LL * *(int *)(a1 + 8));
  sub_100FC00CC(&v13, a3, 0LL, 1LL, 1u, v5 + 2, (uint64_t)v5);
  *a2 = 0;
  unint64_t v6 = *v5;
  if ((int)v6 >= 4)
  {
    unint64_t v7 = v6 >> 1;
    float v8 = (float)(int)v6;
    float v9 = (float *)(a2 + 1);
    char v10 = (float32x2_t *)&v14;
    unint64_t v11 = v7 - 1;
    do
    {
      float32x2_t v12 = *v10++;
      *v9++ = sqrtf(vaddv_f32(vmul_f32(v12, v12)) / v8);
      --v11;
    }

    while (v11);
  }

void sub_100FC00CC( float *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, unsigned int a5, int *a6, uint64_t a7)
{
  float v9 = a1;
  int v10 = a6[1];
  uint64_t v11 = v10 * *a6;
  int v73 = *a6;
  if (v10 == 1)
  {
    int v12 = a4 * a5;
    uint64_t v13 = 8 * v11;
    uint64_t v14 = a1;
    do
    {
      *uint64_t v14 = *(float *)sub_100208A44(a2, (int)a3);
      v14 += 2;
      LODWORD(a3) = a3 + v12;
      v13 -= 8LL;
    }

    while (v13);
  }

  else
  {
    unint64_t v15 = 0LL;
    float v16 = a6 + 2;
    uint64_t v17 = *a6 * a4;
    int v18 = a4 * a5;
    uint64_t v19 = 8 * v11;
    do
    {
      sub_100FC00CC(&v9[v15 / 4], a2, a3, v17, a5, v16, a7);
      a3 = (a3 + v18);
      v15 += 8LL * v10;
    }

    while (v19 != v15);
  }

  if (v73 == 2)
  {
    double v60 = (float *)(*(void *)(a7 + 136) + 4LL);
    uint64_t v61 = 2LL * v10;
    do
    {
      double v62 = &v9[v61];
      float v63 = *(v60 - 1);
      float v64 = v9[v61];
      float v65 = v9[v61 + 1];
      float v66 = (float)(v64 * v63) - (float)(v65 * *v60);
      float v67 = (float)(v63 * v65) + (float)(v64 * *v60);
      float v68 = v9[1] - v67;
      *double v62 = *v9 - v66;
      v62[1] = v68;
      float v69 = v67 + v9[1];
      float *v9 = v66 + *v9;
      v9[1] = v69;
      v9 += 2;
      v60 += 2 * a4;
      --v10;
    }

    while (v10);
  }

  else
  {
    uint64_t v20 = v10;
    if (v73 == 4)
    {
      uint64_t v21 = 2LL * v10;
      unsigned __int8 v22 = v9 + 1;
      float v23 = (float *)(*(void *)(a7 + 136) + 4LL);
      uint64_t v24 = 4LL * v10;
      int v25 = *(_DWORD *)(a7 + 4);
      uint64_t v26 = 6LL * v10;
      unint64_t v27 = v23;
      uint64_t v28 = v23;
      do
      {
        int v29 = &v22[v21];
        float v30 = *(v23 - 1);
        float v31 = v22[v21 - 1];
        float v32 = v22[2 * v10];
        float v33 = (float)(v31 * v30) - (float)(v32 * *v23);
        float v34 = (float)(v30 * v32) + (float)(v31 * *v23);
        double v35 = &v22[v24];
        float v36 = *(v27 - 1);
        float v37 = v22[v24 - 1];
        float v38 = v22[4 * v10];
        float v39 = (float)(v37 * v36) - (float)(v38 * *v27);
        float v40 = (float)(v36 * v38) + (float)(v37 * *v27);
        int v41 = &v22[v26];
        float v42 = *(v28 - 1);
        float v43 = v22[v26 - 1];
        float v44 = v22[6 * v10];
        float v45 = (float)(v43 * v42) - (float)(v44 * *v28);
        float v46 = (float)(v42 * v44) + (float)(v43 * *v28);
        float v47 = *(v22 - 1);
        float v48 = v47 - v39;
        float v49 = *v22 - v40;
        float v50 = v39 + v47;
        float v51 = v40 + *v22;
        *(v22 - 1) = v50;
        *unsigned __int8 v22 = v51;
        float v52 = v34 + v46;
        float v53 = v33 - v45;
        float v54 = v34 - v46;
        *(v35 - 1) = v50 - (float)(v33 + v45);
        *double v35 = v51 - v52;
        float v55 = v52 + *v22;
        *(v22 - 1) = (float)(v33 + v45) + *(v22 - 1);
        *unsigned __int8 v22 = v55;
        if (v25)
        {
          float v56 = v48 + v54;
          float v57 = v49 - v53;
          float v58 = v48 - v54;
          float v59 = v49 + v53;
        }

        else
        {
          float v58 = v48 + v54;
          float v59 = v49 - v53;
          float v56 = v48 - v54;
          float v57 = v49 + v53;
        }

        v22[2 * v10] = v59;
        v22[6 * v10] = v57;
        v22 += 2;
        v28 += 6 * a4;
        *(v29 - 1) = v58;
        v27 += 4 * a4;
        v23 += 2 * a4;
        *(v41 - 1) = v56;
        --v20;
      }

      while (v20);
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892450);
      }
      uint64_t v70 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        int v78 = v73;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_FAULT, "Error in FFT,p,%d", buf, 8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101892450);
        }
        v76[0] = 67109120;
        v76[1] = v73;
        __int16 v71 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Error in FFT,p,%d",  v76);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void kf_work(kiss_fft_cpx *, const CMQueue<scalar_32> &, int, const size_t, int, const int *, const kiss_fft_state *)",  "%s\n",  v71);
      }
    }
  }

void sub_100FC04E0(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100FC050C(uint64_t a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v6 = *(_DWORD *)(a2 + 1);
  if (v6 < 0x8000)
  {
    if (v6 <= 127)
    {
      if (v6 < 3)
      {
        int v9 = 0;
        goto LABEL_55;
      }

      goto LABEL_101;
    }

    if (v6 > 4127)
    {
      if (v6 >= 12288)
      {
        if (v6 != 12288 && v6 != 0x4000) {
          goto LABEL_101;
        }
      }

      else if (v6 != 4128 && v6 != 0x2000)
      {
        goto LABEL_101;
      }
    }

    else if (v6 > 511)
    {
      if (v6 != 512 && v6 != 4096) {
        goto LABEL_101;
      }
    }

    else if (v6 != 128 && v6 != 256)
    {
      goto LABEL_101;
    }

    goto LABEL_54;
  }

  if (v6 < 528384)
  {
    if (v6 > 262271)
    {
      if (v6 >= 397312)
      {
        if (v6 != 397312 && v6 != 462848) {
          goto LABEL_101;
        }
        goto LABEL_54;
      }

      if (v6 == 262272) {
        goto LABEL_54;
      }
      int v10 = 327808;
    }

    else
    {
      if (v6 > 131199)
      {
        if (v6 != 131200 && v6 != 196608) {
          goto LABEL_101;
        }
        goto LABEL_54;
      }

      if (v6 == 0x8000) {
        goto LABEL_54;
      }
      int v10 = 65664;
    }

    if (v6 != v10) {
      goto LABEL_101;
    }
    goto LABEL_54;
  }

  if (v6 <= 786447)
  {
    if (v6 > 655423)
    {
      if (v6 == 655424) {
        goto LABEL_48;
      }
      int v7 = 720912;
    }

    else
    {
      if (v6 == 528384) {
        goto LABEL_54;
      }
      int v7 = 589888;
    }

const char *sub_100FC0C60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch((int)a1)
  {
    case 1:
      uint64_t result = "Portrait";
      break;
    case 2:
      uint64_t result = "PortraitUpsideDown";
      break;
    case 3:
      uint64_t result = "LandscapeLeft";
      break;
    case 4:
      uint64_t result = "LandscapeRight";
      break;
    case 5:
      uint64_t result = "FaceUp";
      break;
    case 6:
      uint64_t result = "FaceDown";
      break;
    case 7:
      sub_10127D52C(a1, a2, a3);
    default:
      uint64_t result = "Ambiguous";
      break;
  }

  return result;
}

NSDictionary *sub_100FC0CE4(uint64_t a1)
{
  v5[0] = @"logTimestamp";
  v6[0] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 40));
  v5[1] = @"fromOrientation";
  v6[1] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 64));
  v5[2] = @"toOrientation";
  _OWORD v6[2] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 68));
  void v5[3] = @"displayState";
  void v6[3] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 72));
  _DWORD v5[4] = @"isAPAwake";
  void v6[4] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 48) + 16LL));
  void v5[5] = @"timeSinceLastOrientationChange";
  _OWORD v6[5] = +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", *(void *)(a1 + 56));
  void v5[6] = @"motionState";
  float v2 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 76));
  v5[7] = @"transitionType";
  uint64_t v3 = *(void *)(a1 + 32);
  v6[6] = v2;
  v6[7] = v3;
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  8LL);
}

void sub_100FC0E28(id a1)
{
  qword_101934528 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Orientation");
}

void sub_100FC0E54(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_100FC0EAC(uint64_t a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_1018924C8;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101892580;
  sub_100B14CF0((void *)(a1 + 336), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 352), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 368), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 384), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 400), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 416), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 432), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 448), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 464), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 480), 0LL, 0LL);
  sub_100B14CF0((void *)(a1 + 496), 0LL, 0LL);
  *(_OWORD *)(a1 + 512) = 0u;
  (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  return a1;
}

void sub_100FC0FF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC1024(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  int v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *int v12 = &off_10182BDA0;
  *(void *)a1 = off_101892660;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101892708;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101892660;
  *(void *)(a1 + sub_1011C52D0(v23 - 72) = off_101892708;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = 0u;
  *(_DWORD *)(a1 + 256) = 12000;
  *(void *)(a1 + 264) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 272));
  *(void *)(a1 + 2sub_1011C52D0(v23 - 72) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 240) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  unint64_t v15 = (int *)(a1 + 256);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 256));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101892610);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892610);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    int v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLWorkloadCalibratorEntry>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLWorkloadCalibratorEntry, DataProtectionPolicy = CLAc tivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 240) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100FC13CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[33] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_1000EAA04(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100FC1470()
{
}

void *sub_100FC1478(void *a1)
{
  a1[9] = off_101892708;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101892660;
  a1[33] = off_10182BD58;
  sub_1001B9C98(a1 + 34);
  sub_1000EAA04(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100FC14F4(void *a1)
{
  *a1 = off_1018924C8;
  a1[9] = off_101892580;
  sub_100FC1538((uint64_t)a1, 0LL, 0LL);
  return sub_100FC1478(a1);
}

void sub_100FC1538(uint64_t a1, void *a2, const void *a3)
{
  if ((a2 != 0LL) == (a3 != 0LL))
  {

    *(void *)(a1 + 512) = a2;
    char v6 = *(const void **)(a1 + 520);
    if (v6) {
      _Block_release(v6);
    }
    if (a3) {
      *(void *)(a1 + 520) = _Block_copy(a3);
    }
  }

  else
  {
    uint64_t v7 = sub_10127D550();
    sub_100FC15AC(v7);
  }

void *sub_100FC15B0(uint64_t a1)
{
  return sub_100FC14F4((void *)(a1 - 72));
}

void sub_100FC15B8(void *a1)
{
  uint64_t v1 = sub_100FC14F4(a1);
  operator delete(v1);
}

void sub_100FC15CC(uint64_t a1)
{
  uint64_t v1 = sub_100FC14F4((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100FC15E4()
{
  return -1LL;
}

uint64_t sub_100FC15EC()
{
  return -1LL;
}

uint64_t sub_100FC15F4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v30[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v31 = 256;
  if (sub_100D8A92C(v6))
  {
    sub_100B14CF8((uint64_t *)(a1 + 352), v30);
    while (!sub_100FC17E8(v30, (uint64_t)v26))
    {
      int v8 = v26[0];
      int v7 = v26[1];
      float v9 = v27;
      float v10 = v28;
      uint64_t v11 = v29;
      uint64_t v13 = *(_DWORD **)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      if ((unint64_t)v13 >= v12)
      {
        unint64_t v15 = *(_DWORD **)a2;
        uint64_t v16 = ((uint64_t)v13 - *(void *)a2) >> 5;
        unint64_t v17 = v16 + 1;
        uint64_t v18 = v12 - (void)v15;
        if (v18 >> 4 > v17) {
          unint64_t v17 = v18 >> 4;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          uint64_t v20 = (char *)sub_10000835C(a2 + 16, v19);
          unint64_t v15 = *(_DWORD **)a2;
          uint64_t v13 = *(_DWORD **)(a2 + 8);
        }

        else
        {
          uint64_t v20 = 0LL;
        }

        int v21 = &v20[32 * v16];
        *(_DWORD *)int v21 = v8;
        *((_DWORD *)v21 + 1) = v7;
        *((float *)v21 + 2) = v9;
        *((float *)v21 + 3) = v10;
        *((void *)v21 + 2) = v11;
        int v22 = v21;
        if (v13 != v15)
        {
          do
          {
            __int128 v23 = *((_OWORD *)v13 - 1);
            *((_OWORD *)v22 - 2) = *((_OWORD *)v13 - 2);
            *((_OWORD *)v22 - 1) = v23;
            v22 -= 32;
            v13 -= 8;
          }

          while (v13 != v15);
          unint64_t v15 = *(_DWORD **)a2;
        }

        uint64_t v14 = v21 + 32;
        *(void *)a2 = v22;
        *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v21 + 32;
        *(void *)(a2 + 16) = &v20[32 * v19];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *uint64_t v13 = v26[0];
        v13[1] = v7;
        *((float *)v13 + 2) = v9;
        *((float *)v13 + 3) = v10;
        uint64_t v14 = (char *)(v13 + 8);
        *((void *)v13 + 2) = v11;
      }

      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v14;
    }

    uint64_t v24 = v30[0];
    v30[0] = 0LL;
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
}

void sub_100FC17A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_100FC17E8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)a2 = sqlite3_column_int(v6, 0);
  int v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 4) = sqlite3_column_int(v7, 1);
  int v8 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = sqlite3_column_double(v8, 2);
  float v9 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 16) = sqlite3_column_double(v9, 3);
  float v10 = (sqlite3_stmt *)sub_100019240(*a1);
  double v11 = sqlite3_column_double(v10, 4);
  uint64_t result = 0LL;
  *(double *)(a2 + 24) = v11;
  return result;
}

uint64_t sub_100FC189C(uint64_t a1)
{
  uint64_t v3 = (sqlite3_stmt *)sub_100019240(v8);
  int v4 = sqlite3_step(v3);
  if (v4 == 100)
  {
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    uint64_t v1 = sqlite3_column_int(v5, 0);
  }

  uint64_t v6 = v8;
  uint64_t v8 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  if (v4 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100FC192C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC1954(uint64_t a1)
{
  return sub_100FC189C(a1 - 72);
}

uint64_t sub_100FC195C(void *a1, uint64_t a2, int a3, float a4)
{
  uint64_t v9 = a1[14];
  uint64_t v8 = a1 + 14;
  float v10 = v8 - 5;
  float v38 = v8;
  (*(void (**)(void))(v9 + 16))();
  __int16 v40 = 256;
  sub_100B14CF8(a1 + 46, &v37);
  if (v37)
  {
    double v11 = (sqlite3_stmt *)sub_100019240(v37);
    if (sub_1003C28BC(v11, 1, a3))
    {
      unint64_t v12 = (sqlite3_stmt *)sub_100019240(v37);
      if (sub_1003B7480(v12, 2, a4))
      {
        uint64_t v13 = a1[10];
        uint64_t v14 = (sqlite3_stmt *)sub_100019240(v37);
        sub_1003BB2BC(v13, v14);
      }
    }

    while (!sub_100FC17E8(&v37, (uint64_t)buf))
    {
      int v16 = *(_DWORD *)buf;
      int v15 = v42;
      float v17 = v43;
      float v18 = v44;
      uint64_t v19 = v45;
      int v21 = *(_DWORD **)(a2 + 8);
      unint64_t v20 = *(void *)(a2 + 16);
      if ((unint64_t)v21 >= v20)
      {
        __int128 v23 = *(_DWORD **)a2;
        uint64_t v24 = ((uint64_t)v21 - *(void *)a2) >> 5;
        unint64_t v25 = v24 + 1;
        uint64_t v26 = v20 - (void)v23;
        if (v26 >> 4 > v25) {
          unint64_t v25 = v26 >> 4;
        }
        else {
          unint64_t v27 = v25;
        }
        if (v27)
        {
          double v28 = (char *)sub_10000835C(a2 + 16, v27);
          __int128 v23 = *(_DWORD **)a2;
          int v21 = *(_DWORD **)(a2 + 8);
        }

        else
        {
          double v28 = 0LL;
        }

        uint64_t v29 = &v28[32 * v24];
        *(_DWORD *)uint64_t v29 = v16;
        *((_DWORD *)v29 + 1) = v15;
        *((float *)v29 + 2) = v17;
        *((float *)v29 + 3) = v18;
        *((void *)v29 + 2) = v19;
        uint64_t v30 = v29;
        if (v21 != v23)
        {
          do
          {
            __int128 v31 = *((_OWORD *)v21 - 1);
            *((_OWORD *)v30 - 2) = *((_OWORD *)v21 - 2);
            *((_OWORD *)v30 - 1) = v31;
            v30 -= 32;
            v21 -= 8;
          }

          while (v21 != v23);
          __int128 v23 = *(_DWORD **)a2;
        }

        int v22 = v29 + 32;
        *(void *)a2 = v30;
        *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v29 + 32;
        *(void *)(a2 + 16) = &v28[32 * v27];
        if (v23) {
          operator delete(v23);
        }
      }

      else
      {
        *int v21 = *(_DWORD *)buf;
        v21[1] = v15;
        *((float *)v21 + 2) = v17;
        *((float *)v21 + 3) = v18;
        int v22 = (char *)(v21 + 8);
        *((void *)v21 + 2) = v19;
      }

      *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 128), 8) = v22;
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892610);
    }
    uint64_t v32 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "WorkloadCalibratorRecorderDb: failed to prepare getActTypeAndStdDevAsc #InvalidPreparedSQLStatement",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892610);
      }
      v36[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "WorkloadCalibratorRecorderDb: failed to prepare getActTypeAndStdDevAsc #InvalidPreparedSQLStatement",  v36,  2);
      int v35 = (uint8_t *)v34;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWorkloadCalibratorRecorderDb::getAllRecordsByActivityTypeAndMaximumStandardDeviation(std::vector<CLWorklo adCalibratorEntry> &, const int, const float) const",  "%s\n",  v34);
      if (v35 != buf) {
        free(v35);
      }
    }
  }

  uint64_t result = v37;
  uint64_t v37 = 0LL;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  if (HIBYTE(v40))
  {
LABEL_32:
    if ((_BYTE)v40) {
      return pthread_mutex_unlock(v39);
    }
    else {
      return (*(uint64_t (**)(void *))(*v38 + 24LL))(v38);
    }
  }

  return result;
}

void sub_100FC1CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  if (a6) {
    (*(void (**)(uint64_t))(*(void *)a6 + 8LL))(a6);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC1D28(uint64_t a1, double a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v18[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v19 = 256;
  if (sub_100D8A92C(v6))
  {
    sub_100B14CF8((uint64_t *)(a1 + 384), v18);
    int v7 = (sqlite3_stmt *)sub_100019240(v18[0]);
    if (sub_1003B7480(v7, 1, a2))
    {
      uint64_t v8 = *(void *)(a1 + 80);
      uint64_t v9 = (sqlite3_stmt *)sub_100019240(v18[0]);
      sub_1003BB2BC(v8, v9);
      uint64_t v10 = *(void *)(a1 + 80);
      else {
        uint64_t v11 = *(void *)(v10 + 88);
      }
      sub_1003C1EC0(v10, v11);
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892630);
      }
      unint64_t v12 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "Failed to delete records", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101892630);
        }
        v17[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Failed to delete records",  v17,  2);
        int v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWorkloadCalibratorRecorderDb::deleteRecordsBefore(CFTimeInterval)",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }
    }

    uint64_t v13 = v18[0];
    v18[0] = 0LL;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
}

void sub_100FC1F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  if (a6) {
    (*(void (**)(uint64_t))(*(void *)a6 + 8LL))(a6);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100FC1FD4(uint64_t *a1)
{
  if (sub_1003C1048(a1[10]))
  {
    sub_1003B59A0( a1[10],  "WorkloadCalibratorHistory",  (const char **)&qword_10199F9A8,  (const std::string::value_type **)&qword_10199FAC8,  0);
    a1[42] = sub_1003BF158(a1[10], "SELECT COUNT(*) FROM WorkloadCalibratorHistory WHERE activityType == ?");
    a1[43] = v2;
    a1[44] = sub_1003BF158(a1[10], "SELECT * FROM WorkloadCalibratorHistory ORDER BY startTime ASC");
    a1[45] = v3;
    a1[46] = sub_1003BF158( a1[10],  "SELECT * FROM WorkloadCalibratorHistory WHERE activityType == ? AND standardDeviation <= ? ORDER BY startTime ASC");
    a1[47] = v4;
    a1[48] = sub_1003BF158(a1[10], "DELETE FROM WorkloadCalibratorHistory WHERE startTime < ?");
    a1[49] = v5;
    a1[50] = sub_1003BF158(a1[10], "DELETE FROM WorkloadCalibratorHistory WHERE startTime > ?");
    a1[51] = v6;
    a1[52] = sub_1003BF158(a1[10], "DELETE FROM WorkloadCalibratorHistory");
    a1[53] = v7;
    a1[54] = sub_1003BF158( a1[10],  "INSERT INTO WorkloadCalibratorHistory (activityType, valueAverage, standardDeviation, startTime) VALUES (?, ?, ?, ?)");
    a1[55] = v8;
    a1[58] = sub_1003BF158(a1[10], "SELECT * FROM WorkloadCalibratorHistory ORDER BY startTime DESC LIMIT 1");
    a1[59] = v9;
    a1[56] = sub_1003BF158(a1[10], "UPDATE WorkloadCalibratorHistory SET startTime = startTime + ?");
    a1[57] = v10;
    a1[60] = sub_1003BF158( a1[10],  "DELETE FROM WorkloadCalibratorHistory WHERE id not in (SELECT id FROM WorkloadCalibratorHistory ORDER BY id DESC LIMIT ?) AND activityType = ?");
    a1[61] = v11;
    a1[62] = sub_1003BF158( a1[10],  "UPDATE WorkloadCalibratorHistory SET valueAverage= ?, standardDeviation= ? WHERE startTime = ? AND activityType = ?");
    a1[63] = v12;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101892630);
    }
    uint64_t v13 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Device is locked and we are unable to open the database.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892630);
      }
      v16[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Device is locked and we are unable to open the database.",  v16,  2);
      int v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLWorkloadCalibratorRecorderDb::prepareSQLStatements()",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

uint64_t sub_100FC226C(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 416), &v7);
    uint64_t v3 = *(void *)(a1 + 80);
    uint64_t v4 = (sqlite3_stmt *)sub_100019240(v7);
    sub_1003BB2BC(v3, v4);
    uint64_t v5 = *(void *)(a1 + 80);
    else {
      uint64_t v6 = *(void *)(v5 + 88);
    }
    sub_1003C1EC0(v5, v6);
    *(_DWORD *)(a1 + 132) = 0;
    uint64_t result = v7;
    uint64_t v7 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC22F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC2318(uint64_t a1)
{
  return sub_100FC226C(a1 - 72);
}

uint64_t sub_100FC2320(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
    sub_100B14CF8((uint64_t *)(a1 + 400), &v14);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v14);
    if (sub_1003B7480(v5, 3, *(double *)(a2 + 16)))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v14);
      sub_1003BB2BC(v6, v7);
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892630);
      }
      uint64_t v8 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Failed to delete records.", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101892630);
        }
        __int16 v13 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Failed to delete records.",  &v13,  2);
        uint64_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLWorkloadCalibratorRecorderDb::deleteRecordsAfterInsertUL(const CLWorkloadCalibratorEntry &)",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }
    }

    uint64_t v9 = *(void *)(a1 + 80);
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    sub_1003C1EC0(v9, v10);
    uint64_t result = v14;
    uint64_t v14 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC255C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC258C(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 448), &v12);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v5, 1, a2))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v6, v7);
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892630);
      }
      uint64_t v8 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Failed to shift records.", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101892630);
        }
        __int16 v11 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Failed to shift records.",  &v11,  2);
        uint64_t v10 = (uint8_t *)v9;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLWorkloadCalibratorRecorderDb::shiftRecordsByUL(CFTimeInterval)",  "%s\n",  v9);
        if (v10 != buf) {
          free(v10);
        }
      }
    }

    uint64_t result = v12;
    uint64_t v12 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC2784( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC27B4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 432), &v11);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003C28BC(v5, 1, *(_DWORD *)(a2 + 4)))
    {
      uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
      if (sub_1003B7480(v6, 2, *(float *)(a2 + 8)))
      {
        uint64_t v7 = (sqlite3_stmt *)sub_100019240(v11);
        if (sub_1003B7480(v7, 3, *(float *)(a2 + 12)))
        {
          uint64_t v8 = (sqlite3_stmt *)sub_100019240(v11);
          if (sub_1003B7480(v8, 4, *(double *)(a2 + 16)))
          {
            uint64_t v9 = *(void *)(a1 + 80);
            uint64_t v10 = (sqlite3_stmt *)sub_100019240(v11);
            sub_1003BB2BC(v9, v10);
          }
        }
      }
    }

    uint64_t result = v11;
    uint64_t v11 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC288C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC28B0(uint64_t a1, int a2, int a3)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 480), &v13);
    uint64_t v7 = (sqlite3_stmt *)sub_100019240(v13);
    if (sub_1003C28BC(v7, 1, a2))
    {
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v13);
      if (sub_1003C28BC(v8, 2, a3))
      {
        uint64_t v9 = *(void *)(a1 + 80);
        uint64_t v10 = (sqlite3_stmt *)sub_100019240(v13);
        sub_1003BB2BC(v9, v10);
        uint64_t v11 = *(void *)(a1 + 80);
        else {
          uint64_t v12 = *(void *)(v11 + 88);
        }
        sub_1003C1EC0(v11, v12);
      }
    }

    uint64_t result = v13;
    uint64_t v13 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC2974( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC2998(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 496), &v11);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v5, 1, *(float *)(a2 + 8)))
    {
      uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
      if (sub_1003B7480(v6, 2, *(float *)(a2 + 12)))
      {
        uint64_t v7 = (sqlite3_stmt *)sub_100019240(v11);
        if (sub_1003B7480(v7, 3, *(double *)(a2 + 16)))
        {
          uint64_t v8 = (sqlite3_stmt *)sub_100019240(v11);
          if (sub_1003C28BC(v8, 4, *(_DWORD *)(a2 + 4)))
          {
            uint64_t v9 = *(void *)(a1 + 80);
            uint64_t v10 = (sqlite3_stmt *)sub_100019240(v11);
            sub_1003BB2BC(v9, v10);
          }
        }
      }
    }

    uint64_t result = v11;
    uint64_t v11 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC2A70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC2A94(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101892630);
    }
    uint64_t v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *(_DWORD *)(a2 + 4);
      double v7 = *(float *)(a2 + 8);
      double v8 = *(float *)(a2 + 12);
      uint64_t v9 = *(void *)(a2 + 16);
      *(_DWORD *)std::string buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v6;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(double *)&buf[10] = v7;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v8;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "WorkloadCalibratorDb (%d,%f,%f,%f).",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101892630);
      }
      double v18 = *(float *)(a2 + 8);
      double v19 = *(float *)(a2 + 12);
      uint64_t v20 = *(void *)(a2 + 16);
      uint64_t v28 = __PAIR64__(*(_DWORD *)(a2 + 4), 67109888);
      __int16 v29 = 2048;
      double v30 = v18;
      __int16 v31 = 2048;
      double v32 = v19;
      __int16 v33 = 2048;
      uint64_t v34 = v20;
      LODWORD(v23) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "WorkloadCalibratorDb (%d,%f,%f,%f).",  &v28,  v23,  v24,  v25[0]);
      int v22 = (char *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLWorkloadCalibratorRecorderDb::insertRecordUL(const CLWorkloadCalibratorEntry &, BOOL)",  "%s\n",  v21);
      if (v22 != buf) {
        free(v22);
      }
    }

    __int128 v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)std::string buf = *(_OWORD *)a2;
    *(_OWORD *)&uint8_t buf[16] = v10;
    sub_100B14CF8((uint64_t *)(a1 + 432), &v28);
    uint64_t v11 = (sqlite3_stmt *)sub_100019240(v28);
    if (sub_1003C28BC(v11, 1, *(_DWORD *)(a2 + 4)))
    {
      uint64_t v12 = (sqlite3_stmt *)sub_100019240(v28);
      if (sub_1003B7480(v12, 2, *(float *)(a2 + 8)))
      {
        uint64_t v13 = (sqlite3_stmt *)sub_100019240(v28);
        if (sub_1003B7480(v13, 3, *(float *)(a2 + 12)))
        {
          uint64_t v14 = (sqlite3_stmt *)sub_100019240(v28);
          if (sub_1003B7480(v14, 4, *(double *)(a2 + 16)))
          {
            uint64_t v15 = *(void *)(a1 + 80);
            int v16 = (sqlite3_stmt *)sub_100019240(v28);
            sub_1003BB2BC(v15, v16);
            ++*(_DWORD *)(a1 + 132);
            float v17 = *(void **)(a1 + 512);
            if (v17)
            {
              if (*(void *)(a1 + 520))
              {
                *(void *)&v25[0] = _NSConcreteStackBlock;
                *(void *)&v25[1] = 3221225472LL;
                *(void *)&_DWORD v25[2] = sub_100FC2DEC;
                *(void *)&void v25[3] = &unk_10182D1B8;
                *(void *)&v25[4] = a1;
                __int128 v26 = *(_OWORD *)buf;
                __int128 v27 = *(_OWORD *)&buf[16];
                [v17 async:v25];
              }
            }
          }
        }
      }
    }

    uint64_t result = v28;
    uint64_t v28 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_100FC2DC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
}

uint64_t sub_100FC2DEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 520LL);
  __int128 v2 = *(_OWORD *)(a1 + 56);
  v4[0] = *(_OWORD *)(a1 + 40);
  v4[1] = v2;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(v1 + 16))(v1, v4);
}

uint64_t sub_100FC2E28()
{
  return 0LL;
}

uint64_t sub_100FC2E30(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_100FC17E8(&v11, (uint64_t)&v8);
  if (!(_DWORD)v4)
  {
    float32x2_t v5 = vcvt_f32_f64(v9);
    *a2 = v8;
    a2[1] = v5;
    a2[2] = v10;
  }

  uint64_t v6 = v11;
  uint64_t v11 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  return v4;
}

void sub_100FC2EC0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 24);
  *(void *)(v1 - 24) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC2EE4(void *a1, void **a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v41);
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if (HIBYTE(v42)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_10127D6D8(v10);
    goto LABEL_40;
  }

  uint64_t v4 = (std::stringbuf *)v41[1];
  operator delete(v41[0]);
  if (!v4) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v41);
  uint64_t v11 = sub_10000CF44(&v42, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(void **__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v13 = BYTE7(v38);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = a1[10];
  uint64_t v4 = &v43;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v43);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    int v16 = (char *)__p;
  }
  else {
    int v16 = (char *)__p[0];
  }
  sub_1003C0D54(v15, v16, &v39);
  uint64_t v5 = v39;
  uint64_t v39 = 0LL;
  uint64_t v40 = v5;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  float v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    double v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v40, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        uint64_t v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v24 = ((char *)v20 - (_BYTE *)*a2) >> 5;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = v21 - (void)*a2;
          if (v26 >> 4 > v25) {
            unint64_t v25 = v26 >> 4;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            uint64_t v28 = (char *)sub_10000835C((uint64_t)(a2 + 2), v27);
          }
          else {
            uint64_t v28 = 0LL;
          }
          __int16 v29 = &v28[32 * v24];
          __int128 v30 = v38;
          *(_OWORD *)__int16 v29 = *(_OWORD *)__p;
          *((_OWORD *)v29 + 1) = v30;
          double v32 = (char *)*a2;
          __int16 v31 = (char *)a2[1];
          __int16 v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *((_OWORD *)v31 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 32;
              v31 -= 32;
            }

            while (v31 != v32);
            __int16 v31 = (char *)*a2;
          }

          double v23 = v29 + 32;
          *a2 = v33;
          a2[1] = v29 + 32;
          a2[2] = &v28[32 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = v38;
          *uint64_t v20 = *(_OWORD *)__p;
          v20[1] = v22;
          double v23 = v20 + 2;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v40;
      goto LABEL_42;
    }
  }

void sub_100FC31E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC3250(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892610);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892610);
      }
      double v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::string buf = 134349056;
        *(void *)uint64_t v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101892610);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        float v36 = (uint8_t *)v35;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLWorkloadCalibratorEntry>::setDatabaseAccessible() [T = CLWorkloadCalibrato rEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v35);
        if (v36 != buf) {
          free(v36);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892610);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    uint64_t v13 = *(void *)(a1 + 184);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = (void *)(v13 + 8LL * (*(void *)(a1 + 208) >> 7));
    if (v14 == v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *v15 + 32 * (*(void *)(a1 + 208) & 0x7FLL);
    }
    while (1)
    {
      if (v14 == v13)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        unint64_t v21 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v22 = *(void *)(v13 + ((v21 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v21 & 0x7F);
      }

      if (v16 == v22) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101892748);
      }
      double v23 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101892748);
        }
        LOWORD(v39) = 0;
        LODWORD(v37) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v37);
        uint64_t v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLWorkloadCalibratorEntry>::setDatabaseAccessible() [T = CLWorkloadCalibrato rEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v16, 1LL);
      v16 += 32LL;
      if (v16 - *v15 == 4096)
      {
        uint64_t v24 = v15[1];
        ++v15;
        uint64_t v16 = v24;
      }

      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v14 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892610);
    }
    float v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      double v18 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892610);
      }
    }

    uint64_t v19 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v20 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 128), 8) = 1;
  }

  unint64_t v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      unint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 64LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 128LL;
  }

  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 128), 8) = v31;
LABEL_61:
  double v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100FC3958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id *sub_100FC398C(uint64_t a1, uint64_t a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 240) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)a1 + 104LL))(a1, v32);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892610);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101892610);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLWorkloadCalibratorEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = C LWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 16);
    double v8 = v33;
    double v9 = v7 - v33;
    if (v7 - v33 < 0.0) {
      double v9 = -(v7 - v33);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101892610);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 16);
        *(_DWORD *)std::string buf = 134349312;
        double v40 = v33;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101892610);
        }
        uint64_t v23 = *(void *)(a2 + 16);
        int v35 = 134349312;
        double v36 = v33;
        __int16 v37 = 2050;
        uint64_t v38 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        unint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLWorkloadCalibratorEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = C LWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 16);
      double v8 = v33;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101892610);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 16);
          *(_DWORD *)std::string buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101892610);
          }
          double v26 = *(double *)(a2 + 16);
          int v35 = 134217984;
          double v36 = v26;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          uint64_t v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLWorkloadCalibratorEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v31 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101892610);
        double v18 = v31;
      }

      double v19 = v17 - v18;
      uint64_t v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v40 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101892610);
        }
        int v35 = 134217984;
        double v36 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        uint64_t v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLWorkloadCalibratorEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = C LWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, v32, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100FC40C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100FC40F4(uint64_t a1)
{
  return sub_100FC3250(a1 - 72);
}

void sub_100FC40FC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100FC4128(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100FC4154(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10127D844(v4);
LABEL_44:
    sub_100007008();
  }

  uint64_t v30 = v35[1];
  operator delete(v35[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v35);
    int v6 = sub_10000CF44(&v36, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(void **__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      double v7 = __p;
    }
    else {
      double v7 = (void **)__p[0];
    }
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v32);
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    double v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v37);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v11 = (char *)__p;
    }
    else {
      uint64_t v11 = (char *)__p[0];
    }
    sub_1003C0D54(v10, v11, &v33);
    uint64_t v12 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v12;
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)__p))
    {
      double v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v17 = (v13 - *a2) >> 5;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v14 - (void)*a2;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          __int128 v21 = (char *)sub_10000835C((uint64_t)(a2 + 2), v20);
        }
        else {
          __int128 v21 = 0LL;
        }
        uint64_t v22 = &v21[32 * v17];
        __int128 v23 = v32;
        *(_OWORD *)uint64_t v22 = *(_OWORD *)__p;
        *((_OWORD *)v22 + 1) = v23;
        unint64_t v25 = *a2;
        uint64_t v24 = a2[1];
        double v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *((_OWORD *)v24 - 1);
            *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v24 -= 32;
          }

          while (v24 != v25);
          uint64_t v24 = *a2;
        }

        uint64_t v16 = v22 + 32;
        *a2 = v26;
        a2[1] = v22 + 32;
        a2[2] = &v21[32 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = v32;
        *(_OWORD *)double v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        uint64_t v16 = v13 + 32;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v34;
    uint64_t v34 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v35
    uint64_t v36 = v29;
    std::streambuf::~streambuf(&v37);
    return std::ios::~ios(&v38);
  }

  return result;
}

void sub_100FC4414( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100FC447C(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_10127D9B0(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 16)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100FC46DC(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10127DB1C(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100FC4914(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10127DC88(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_100FC4B3C(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_100FC4B68()
{
  qword_10199F9A8 = (uint64_t)"id";
  dword_10199F9B0 = 1;
  word_10199F9B4 = 1;
  byte_10199F9B8 = 0;
  byte_10199F9D0 = 0;
  qword_10199F9D8 = (uint64_t)"activityType";
  dword_10199F9E0 = 1;
  word_10199F9E4 = 0;
  byte_10199F9E8 = 0;
  byte_10199FA00 = 0;
  qword_10199FA08 = (uint64_t)"valueAverage";
  dword_10199FA10 = 2;
  word_10199FA14 = 0;
  byte_10199FA18 = 0;
  byte_10199FA30 = 0;
  qword_10199FA38 = (uint64_t)"standardDeviation";
  dword_10199FA40 = 2;
  word_10199FA44 = 0;
  byte_10199FA48 = 0;
  byte_10199FA60 = 0;
  qword_10199FA68 = (uint64_t)"startTime";
  dword_10199FA70 = 2;
  word_10199FA74 = 0;
  byte_10199FA78 = 0;
  byte_10199FA90 = 0;
  qword_10199FA98 = 0LL;
  dword_10199FAA0 = 5;
  word_10199FAA4 = 0;
  byte_10199FAA8 = 0;
  byte_10199FAC0 = 0;
  qword_10199FAC8 = (uint64_t)"activityType";
  unk_10199FAD0 = "startTime";
  qword_10199FAD8 = 0LL;
}

uint64_t sub_100FC4C30(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  double v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *double v7 = off_101892778;
  v7[6] = 0LL;
  sub_101041EA0((uint64_t)sub_100FC4CEC, a1, a3, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = v12;
    uint64_t v12 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a1;
}

void sub_100FC4CC0(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + 4_Block_object_dispose((const void *)(v1 - 128), 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_100FC4CEC(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101892838);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSwimDataSubscription::onSwimNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101892838);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int128 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSwimDataSubscription::onSwimNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100FC5ECC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100FC4EA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC4EC8(void *a1)
{
  *a1 = off_101892778;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    uint64_t v3 = a1[6];
    a1[6] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return sub_100C6AB50((uint64_t)a1);
}

void sub_100FC4F28(void *a1)
{
  uint64_t v1 = (void *)sub_100FC4EC8(a1);
  operator delete(v1);
}

void *sub_100FC4F3C@<X0>(uint64_t a1@<X8>)
{
  v15[0] = &off_101892AA8;
  v15[1] = sub_100FC525C;
  v15[2] = 0LL;
  __int16 v16 = v15;
  sub_1010DDBC0(v17, "kCLConnectionMessageSwimDataUpdate");
  sub_10089AEA0((uint64_t)&v18, (uint64_t)v15);
  v13[0] = &off_101892B58;
  v13[1] = sub_100FC5664;
  v13[2] = 0LL;
  __int16 v14 = v13;
  sub_1010DDBC0(v19, "kCLConnectionMessageSwimDataQuery");
  sub_10089AEA0((uint64_t)&v20, (uint64_t)v13);
  v11[0] = &off_101892B58;
  v11[1] = sub_100FC5ACC;
  void v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v21, "kCLConnectionMessageSwimSWOLFSessionQuery");
  sub_10089AEA0((uint64_t)v22, (uint64_t)v11);
  sub_100FC7208(a1, (unsigned __int8 *)v17, 3LL);
  for (uint64_t i = 0LL; i != -21; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v22[i * 8 + 24];
    if (&v22[i * 8] == v3)
    {
      uint64_t v3 = &v22[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v21[i + 2]) < 0) {
      operator delete((void *)v21[i]);
    }
  }

  uint64_t v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v11;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v12)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v14;
  if (v14 == v13)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v13;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v14)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  uint64_t result = v16;
  if (v16 == v15)
  {
    uint64_t v10 = 4LL;
    uint64_t result = v15;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  else if (v16)
  {
    uint64_t v10 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  return result;
}

void sub_100FC5150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, char *a20, char a21)
{
  for (uint64_t i = 112LL; i != -56; i -= 56LL)
    sub_10026E430((uint64_t)(&a21 + i));
  uint64_t v23 = a12;
  if (a12 == &a9)
  {
    uint64_t v24 = 4LL;
    uint64_t v23 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_8;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_8:
  uint64_t v25 = a16;
  if (a16 == &a13)
  {
    uint64_t v26 = 4LL;
    uint64_t v25 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_13;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*(void *)v25 + 8 * v26))();
LABEL_13:
  __int128 v27 = a20;
  if (a20 == &a17)
  {
    uint64_t v28 = 4LL;
    __int128 v27 = &a17;
  }

  else
  {
    if (!a20) {
      goto LABEL_18;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*(void *)v27 + 8 * v28))();
LABEL_18:
  _Unwind_Resume(a1);
}

void sub_100FC525C(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101892878);
  }
  uint64_t v5 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)std::string buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v27 = 2048;
    uint64_t v28 = a1;
    __int16 v29 = 1024;
    int v30 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "SwimData subscription changed, %@, %p, %d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101892878);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    unsigned int v20 = 138412802;
    uint64_t v21 = v11;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
    __int16 v24 = 1024;
    int v25 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "SwimData subscription changed, %@, %p, %d",  &v20,  28);
    int v13 = (char *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSwimDataSubscription::handleRequestSwimDataUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  if ((sub_100FC61D0(a1, (int *)&v20) & 1) != 0)
  {
    sub_100C6AC8C(a1);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(v7 + 8);
    uint64_t v8 = *(void **)(v7 + 16);
    if (a2) {
      [v8 register:v9 forNotification:0 registrationInfo:0];
    }
    else {
      [v8 unregister:v9 forNotification:0];
    }
  }

  else
  {
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_101892858);
    }
    uint64_t v10 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning Failed to subscribe to swim updates.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      v17[0] = 0;
      LODWORD(v16) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "#Warning Failed to subscribe to swim updates.",  v17,  v16);
      __int128 v15 = (char *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSwimDataSubscription::handleRequestSwimDataUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    uint64_t v18 = CMErrorMessage;
    uint64_t v19 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v20);
    *(void *)std::string buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v19,  &v18,  1LL);
    sub_100FC6298(a1, buf);
  }
}

void sub_100FC5624(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100FC5664(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if ((sub_100FC61D0(a1, (int *)&v28) & 1) != 0)
  {
    objc_opt_class(&OBJC_CLASS___CMSwimData);
    uint64_t v6 = v5;
    *(void *)&double v7 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses( *(CLConnectionMessage **)a2,  +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v6, v7, v8, 0LL));
    uint64_t v10 = DictionaryOfClasses;
    if (DictionaryOfClasses
      && (uint64_t v11 = CMSwimKeyDataRecord, [DictionaryOfClasses objectForKeyedSubscript:CMSwimKeyDataRecord]))
    {
      uint64_t v12 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLDaemonClient.SwimNotifierQuery");
      uint64_t v55 = 0LL;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      *(_OWORD *)std::string buf = 0u;
      objc_msgSend(objc_msgSend(v10, "objectForKeyedSubscript:", v11), "convertToSwimEntry:", buf);
      int v13 = *(void **)(*(void *)(a1 + 48) + 16LL);
      v42[6] = v52;
      v42[7] = v53;
      v42[8] = v54;
      v42[2] = v48;
      v42[3] = v49;
      v42[4] = v50;
      v42[5] = v51;
      v42[0] = *(_OWORD *)buf;
      v42[1] = v47;
      v29[1] = 3321888768LL;
      __int128 v36 = v52;
      __int128 v37 = v53;
      __int128 v38 = v54;
      __int128 v32 = v48;
      __int128 v33 = v49;
      __int128 v34 = v50;
      __int128 v35 = v51;
      __int128 v30 = *(_OWORD *)buf;
      uint64_t v43 = v55;
      v29[0] = _NSConcreteStackBlock;
      _OWORD v29[2] = sub_100FC6338;
      uint64_t v29[3] = &unk_1018927A0;
      __int128 v31 = v47;
      __int128 v15 = *(CLConnectionMessage **)a2;
      __int16 v14 = *(std::__shared_weak_count **)(a2 + 8);
      uint64_t v39 = v55;
      double v40 = v15;
      __int16 v41 = v14;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          unint64_t v17 = __ldxr(p_shared_owners);
        while (__stxr(v17 + 1, p_shared_owners));
      }

      v29[4] = v12;
      [v13 queryUsingRecord:v42 withReply:v29];
      uint64_t v18 = v41;
      if (v41)
      {
        uint64_t v19 = (unint64_t *)&v41->__shared_owners_;
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }

    else
    {
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      __int16 v22 = (os_log_s *)qword_1019344E8;
      if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "Programmer error: Wrong parameters were passed.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344E0 != -1) {
          dispatch_once(&qword_1019344E0, &stru_101892858);
        }
        v27[0] = 0;
        LODWORD(v26) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  17LL,  "Programmer error: Wrong parameters were passed.",  v27,  v26);
        int v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSwimDataSubscription::handleMessageSwimDataQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      uint64_t v23 = *(CLConnectionMessage **)a2;
      uint64_t v44 = CMErrorMessage;
      __int16 v45 = &off_1018D50D8;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v45,  &v44,  1LL);
      CLConnectionMessage::sendReply(v23);
    }
  }

  else
  {
    uint64_t v21 = *(CLConnectionMessage **)a2;
    uint64_t v56 = CMErrorMessage;
    int v57 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v28);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v57,  &v56,  1LL);
    CLConnectionMessage::sendReply(v21);
  }
}

void sub_100FC5A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100FC5ACC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  uint64_t v30 = 0LL;
  __int128 v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  if ((sub_100FC61D0(a1, &v33) & 1) != 0)
  {
    objc_opt_class(&OBJC_CLASS___NSUUID);
    uint64_t v6 = v5;
    *(void *)&double v7 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses( *(CLConnectionMessage **)a2,  +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v6, v7, v8, 0LL));
    uint64_t v10 = CMSwimSWOLFSessionIdKey;
    if ([DictionaryOfClasses objectForKeyedSubscript:CMSwimSWOLFSessionIdKey])
    {
      uint64_t v11 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLDaemonClient.SWOLFQueryForSessionId");
      uint64_t v12 = *(void **)(*(void *)(a1 + 48) + 16LL);
      id v13 = [DictionaryOfClasses objectForKeyedSubscript:v10];
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3321888768LL;
      v27[2] = sub_100FC65EC;
      v27[3] = &unk_1018927D8;
      __int128 v15 = *(CLConnectionMessage **)a2;
      __int16 v14 = *(std::__shared_weak_count **)(a2 + 8);
      v27[5] = &v30;
      __int16 v27[6] = v15;
      unsigned int v28 = v14;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          unint64_t v17 = __ldxr(p_shared_owners);
        while (__stxr(v17 + 1, p_shared_owners));
      }

      v27[4] = v11;
      [v12 querySessionSWOLF:v13 withReply:v27];
      uint64_t v18 = v28;
      if (v28)
      {
        uint64_t v19 = (unint64_t *)&v28->__shared_owners_;
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }

    else
    {
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      __int16 v22 = (os_log_s *)qword_1019344E8;
      if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "SWOLF query,empty request", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344E0 != -1) {
          dispatch_once(&qword_1019344E0, &stru_101892858);
        }
        v29[0] = 0;
        LODWORD(v26) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  17LL,  "SWOLF query,empty request",  v29,  v26);
        int v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSwimDataSubscription::handleSWOLFQueryForSessionId(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      uint64_t v23 = *(CLConnectionMessage **)a2;
      uint64_t v34 = CMErrorMessage;
      __int128 v35 = &off_1018D50D8;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v35,  &v34,  1LL);
      CLConnectionMessage::sendReply(v23);
    }
  }

  else
  {
    uint64_t v21 = *(CLConnectionMessage **)a2;
    uint64_t v37 = CMErrorMessage;
    __int128 v38 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v31 + 6));
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v38,  &v37,  1LL);
    CLConnectionMessage::sendReply(v21);
  }

  _Block_object_dispose(&v30, 8);
}

void sub_100FC5E78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Unwind_Resume(a1);
}

void sub_100FC5ECC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (!*a3)
  {
    id v5 = [[CMSwimData alloc] initWithSwimEntry:a4];
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_101892858);
    }
    uint64_t v6 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 24);
      *(_DWORD *)std::string buf = 138412802;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v21 = 2112;
      uint64_t v22 = v7;
      __int16 v23 = 2048;
      uint64_t v24 = a1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@, %@, %p", buf, 0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      uint64_t v8 = *(void *)(a1 + 24);
      int v14 = 138412802;
      id v15 = v5;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "%@, %@, %p",  &v14,  32);
      uint64_t v10 = (char *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSwimDataSubscription::onSwimNotification(int, const CLSwimNotifier_Type::Notification &, const CLSwimNoti fier_Type::NotificationData &)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    id v11 = v5;
    uint64_t v12 = CMSwimKeyDataArray;
    id v13 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v11, 1LL);
    *(void *)std::string buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v13,  &v12,  1LL);

    sub_100FC6128(a1, buf);
  }

void sub_100FC6128(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100FC61BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100FC61D0(uint64_t a1, int *a2)
{
  char v4 = sub_100C6AC9C(a1);
  char v5 = v4;
  if ((v9 & 0x80000000) == 0)
  {
    if ((v4 & 1) != 0) {
      goto LABEL_3;
    }
LABEL_8:
    int v6 = 110;
    goto LABEL_10;
  }

  operator delete(__p);
  if ((v5 & 1) == 0) {
    goto LABEL_8;
  }
LABEL_3:
  if (sub_100C6ADE0(a1))
  {
    int v6 = 109;
  }

  else
  {
    int v6 = 111;
  }

void sub_100FC627C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC6298(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_101892BC8, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100FC6324(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100FC6338(uint64_t a1, void *a2)
{
  if (a2) {
    char v4 = a2;
  }
  else {
    char v4 = &__NSArray0__struct;
  }
  uint64_t v29 = CMSwimKeyDataArray;
  uint64_t v30 = v4;
  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL);
  uuid_unparse((const unsigned __int8 *)(a1 + 48), out);
  uuid_unparse((const unsigned __int8 *)(a1 + 64), v27);
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_101892858);
  }
  unint64_t v5 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)std::string buf = 134218754;
    uint64_t v20 = v6;
    __int16 v21 = 2080;
    uint64_t v22 = out;
    __int16 v23 = 2080;
    uint64_t v24 = v27;
    __int16 v25 = 2048;
    id v26 = [a2 count];
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Query: id, %llu, session, %s, db, %s, Response (numel): %lu",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_101892858);
    }
    uint64_t v7 = qword_1019344E8;
    uint64_t v8 = *(void *)(a1 + 40);
    int v11 = 134218754;
    uint64_t v12 = v8;
    __int16 v13 = 2080;
    int v14 = out;
    __int16 v15 = 2080;
    __int16 v16 = v27;
    __int16 v17 = 2048;
    id v18 = [a2 count];
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  1LL,  "Query: id, %llu, session, %s, db, %s, Response (numel): %lu",  &v11,  42);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSwimDataSubscription::handleMessageSwimDataQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  CLConnectionMessage::sendReply(*(void *)(a1 + 192));
}

uint64_t sub_100FC65C0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 200);
  *(void *)(result + 192) = *(void *)(a2 + 192);
  *(void *)(result + 200) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_100FC65E4(uint64_t a1)
{
  return sub_10000AE14(a1 + 192);
}

void sub_100FC65EC(uint64_t a1, void *a2, uint64_t a3)
{
  if ((_DWORD)a3 == 100)
  {
    uint64_t v19 = CMSwimSWOLFDataKey;
    uint64_t v20 = a2;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_101892858);
    }
    unint64_t v5 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [a2 description];
      *(_DWORD *)std::string buf = 138412290;
      id v24 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Session SWOLF Query Result: %@", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      uint64_t v11 = qword_1019344E8;
      int v17 = 138412290;
      id v18 = [a2 description];
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  0LL,  "Session SWOLF Query Result: %@",  &v17,  12);
      __int16 v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSwimDataSubscription::handleSWOLFQueryForSessionId(std::shared_ptr<CLConnectionMessage>)_block_invoke",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    CLConnectionMessage::sendReply(*(void *)(a1 + 48));
  }

  else
  {
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_101892858);
    }
    uint64_t v8 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_ERROR))
    {
      int v9 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(_DWORD *)std::string buf = 67240192;
      LODWORD(v24) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Error querying session swolf, %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_101892858);
      }
      int v14 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      int v17 = 67240192;
      LODWORD(v1_Block_object_dispose(va, 8) = v14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  16LL,  "Error querying session swolf, %{public}d",  &v17,  8);
      __int16 v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSwimDataSubscription::handleSWOLFQueryForSessionId(std::shared_ptr<CLConnectionMessage>)_block_invoke",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    uint64_t v10 = *(void *)(a1 + 48);
    uint64_t v21 = CMErrorMessage;
    uint64_t v22 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a3);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v22,  &v21,  1LL);
    CLConnectionMessage::sendReply(v10);
  }

void sub_100FC69B0(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100FC69DC(id a1)
{
  qword_1019344E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Swimming");
}

void sub_100FC6A08(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void *sub_100FC6A3C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_1018928A8;
  return result;
}

void sub_100FC6A60(uint64_t a1, void *a2)
{
  *a2 = &off_1018928A8;
}

double sub_100FC6A78(uint64_t a1, double **a2)
{
  uint64_t v2 = *a2;
  double result = **a2;
  double v4 = 0.0;
  while (v2 != a2[1])
  {
    double v4 = v4 + v2[2];
    v2 += 3;
  }

  return result;
}

uint64_t sub_100FC6AA4(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100FC6AE0()
{
}

void *sub_100FC6AF4()
{
  double result = operator new(0x10uLL);
  *double result = &off_101892928;
  return result;
}

void sub_100FC6B18(uint64_t a1, void *a2)
{
  *a2 = &off_101892928;
}

double sub_100FC6B30(uint64_t a1, double **a2)
{
  uint64_t v2 = a2[1];
  double result = **a2;
  double v4 = 0.0;
  if (*a2 != v2)
  {
    unint64_t v5 = *a2;
    do
    {
      double v4 = v4 + v5[2];
      v5 += 3;
    }

    while (v5 != v2);
  }

  return result;
}

uint64_t sub_100FC6B80(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100FC6BBC()
{
}

void *sub_100FC6BD0()
{
  double result = operator new(0x10uLL);
  *double result = &off_1018929A8;
  return result;
}

void sub_100FC6BF4(uint64_t a1, void *a2)
{
  *a2 = &off_1018929A8;
}

BOOL sub_100FC6C0C(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) >= 0.0;
}

uint64_t sub_100FC6C1C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100FC6C58()
{
}

void *sub_100FC6C6C()
{
  double result = operator new(0x10uLL);
  *double result = &off_101892A28;
  return result;
}

void sub_100FC6C90(uint64_t a1, void *a2)
{
  *a2 = &off_101892A28;
}

BOOL sub_100FC6CA8(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) > 2.22044605e-16;
}

uint64_t sub_100FC6CC0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100FC6CFC()
{
}

__n128 sub_100FC6D08(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101892AA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_100FC6D44(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101892AA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_100FC6D68(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_100FC6D70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100FC6DAC()
{
}

void sub_100FC6DB8(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_100FC6E3C(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    double v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100FC6E24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC6E3C(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892B18);
    }
    uint64_t v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101892B18);
      }
    }

    uint64_t v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_100FC7020( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100FC703C(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_100FC7068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101892B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_100FC70A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101892B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_100FC70C8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100FC70D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100FC710C()
{
}

void sub_100FC7118(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  __int16 v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  uint64_t v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    __int16 v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100FC71EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100FC7208(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100FC7280(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100FC726C(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100FC7280(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    __int16 v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100FC7500(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *uint64_t v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100FC74E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100FC7500@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100FC7574(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100FC755C(_Unwind_Exception *a1)
{
}

void *sub_100FC7574(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100FC75CC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100FC75E8()
{
  xmmword_10199FAE0 = xmmword_1013BBF70;
  *(_OWORD *)algn_10199FAF0 = xmmword_1013BBF80;
  xmmword_10199FB00 = xmmword_1013BBF90;
  unk_10199FB10 = xmmword_1013BBFA0;
  xmmword_10199FB20 = xmmword_1013BBFB0;
  unk_10199FB30 = xmmword_1013BBFC0;
  xmmword_10199FB40 = xmmword_1013BBFD0;
  *(_OWORD *)algn_10199FB50 = xmmword_1013BBFE0;
  xmmword_10199FB60 = xmmword_1013BBFF0;
  unk_10199FB70 = xmmword_1013BC000;
  xmmword_10199FB80 = xmmword_1013BC010;
  unk_10199FB90 = xmmword_1013BC020;
  qword_10199FBA0 = (uint64_t)&off_1018928A8;
  qword_10199FBB8 = (uint64_t)&qword_10199FBA0;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_10199FBA0, (void *)&_mh_execute_header);
  qword_10199FBC0 = (uint64_t)&off_101892928;
  qword_10199FBD8 = (uint64_t)&qword_10199FBC0;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_10199FBC0, (void *)&_mh_execute_header);
  qword_10199FBE0 = (uint64_t)&off_1018929A8;
  qword_10199FBF8 = (uint64_t)&qword_10199FBE0;
  __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_10199FBE0, (void *)&_mh_execute_header);
  qword_10199FC00 = (uint64_t)&off_101892A28;
  qword_10199FC18 = (uint64_t)&qword_10199FC00;
  return __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_10199FC00, (void *)&_mh_execute_header);
}

void sub_100FC77D0(id a1)
{
  qword_10199FC20 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLClientAuthorizationCacheSilo");
}

uint64_t sub_100FC7CF8(uint64_t a1)
{
  if (objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "clientKeyToClientInfoMap"),  "objectForKeyedSubscript:",  *(void *)(a1 + 40)))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101892BF0);
    }
    uint64_t v2 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      id v3 = [*(id *)(a1 + 40) UTF8String];
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      unint64_t v10 = "";
      __int16 v11 = 2082;
      id v12 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Zonal client trying to access auth-context via Non-Zonal CLCAC api, Client:%{public , location:escape_only}s}",  (uint8_t *)&v7,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101892BF0);
      }
    }

    __int128 v4 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v5 = [*(id *)(a1 + 40) UTF8String];
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      unint64_t v10 = "";
      __int16 v11 = 2082;
      id v12 = v5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Zonal client trying to access auth-context via Non-Zonal CLCAC api",  "{msg%{public}.0s:Zonal client trying to access auth-context via Non-Zonal CLCAC api, Client:%{public , location:escape_only}s}",  (uint8_t *)&v7,  0x1Cu);
    }
  }

  return (*(uint64_t (**)(void, id))(*(void *)(a1 + 48) + 16))( *(void *)(a1 + 48),  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "clientKeyToAuthContextMap"),  "objectForKeyedSubscript:",  *(void *)(a1 + 40)));
}

void sub_100FC86C8(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x2B7]) < 0) {
    operator delete((void *)STACK[0x2A0]);
  }
  _Unwind_Resume(a1);
}

void sub_100FC8D70(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_100FC928C(uint64_t a1, void *a2)
{
  __int128 v4 = sub_100FCB1A0((void *)a1);
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101892DB0);
  }
  id v5 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = [*(id *)(a1 + 136) isAuthorizedForServiceType:6];
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t buf = 68290050LL;
    __int16 v45 = 2082;
    uint64_t v46 = "";
    __int16 v47 = 1026;
    *(_DWORD *)__int128 v48 = v6;
    *(_WORD *)&v48[4] = 2114;
    *(void *)&v48[6] = v4;
    *(_WORD *)&v48[14] = 2114;
    *(void *)&v48[16] = v7;
    *(_WORD *)&v48[24] = 2114;
    *(void *)&v48[26] = sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#INFO #slv authorization status, isAuthorized:%{public}hhd, commencementDate:%{pu blic, location:escape_only}@, client:%{public, location:escape_only}@, interest:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x36u);
  }

  if ([*(id *)(a1 + 136) isAuthorizedForServiceType:6])
  {
    if ([*(id *)(a1 + 136) isAuthorizedForServiceType:12])
    {
      sub_100FCA5EC(a1, (uint64_t)a2, v4);
    }

    else
    {
      [a2 coordinate];
      uint64_t v12 = v11;
      [a2 coordinate];
      uint64_t v14 = v13;
      [a2 horizontalAccuracy];
      uint64_t v16 = v15;
      float v17 = *(void **)(a1 + 280);
      BOOL v18 = objc_alloc(&OBJC_CLASS___CLLocation);
      int v25 = 0xFFFF;
      uint64_t v26 = v12;
      uint64_t v27 = v14;
      uint64_t v28 = v16;
      __asm { FMOV            V0.2D, #-1.0 }

      __int128 v29 = xmmword_1012EA5D0;
      __int128 v30 = _Q0;
      __int128 v31 = _Q0;
      unint64_t v32 = 0xBFF0000000000000LL;
      uint64_t v35 = 0LL;
      uint64_t v36 = 0LL;
      unint64_t v34 = 0xBFF0000000000000LL;
      int v33 = 0;
      int v37 = 0;
      unint64_t v38 = 0xBFF0000000000000LL;
      int v39 = 0x7FFFFFFF;
      uint64_t v41 = 0LL;
      uint64_t v42 = 0LL;
      uint64_t v40 = 0LL;
      char v43 = 0;
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      void v24[2] = sub_100FCB1E4;
      v24[3] = &unk_101892CC0;
      v24[5] = v4;
      v24[6] = a1;
      v24[4] = a2;
      objc_msgSend( v17,  "snapLocation:withReply:",  -[CLLocation initWithClientLocation:](v18, "initWithClientLocation:", &v25),  v24);
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    int v8 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 64);
      uint64_t v10 = sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
      uint64_t buf = 68289794LL;
      __int16 v45 = 2082;
      uint64_t v46 = "";
      __int16 v47 = 2114;
      *(void *)__int128 v48 = v4;
      *(_WORD *)&v48[8] = 2114;
      *(void *)&v48[10] = v9;
      *(_WORD *)&v48[18] = 2114;
      *(void *)&v48[20] = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning #slv Got visit when we should be unsubscribed, commencementDate:%{public, location:escape_only}@, client:%{public, location:escape_only}@, interest:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x30u);
    }
  }

uint64_t sub_100FC95C8(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  if (*(char *)(a5 + 23) < 0)
  {
    sub_1010DD48C(v14, *(void **)a5, *(void *)(a5 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a5;
    uint64_t v15 = *(void *)(a5 + 16);
  }

  if (*(char *)(a5 + 47) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(a5 + 24), *(void *)(a5 + 32));
  }

  else
  {
    __int128 __p = *(_OWORD *)(a5 + 24);
    uint64_t v17 = *(void *)(a5 + 40);
  }

  uint64_t v18 = *(void *)(a5 + 48);
  sub_1004C625C(a1, a2, a3, a4, (__int128 *)v14);
  *(void *)a1 = off_101892D68;
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  *(void *)a1 = off_101892C20;
  *(void *)(a1 + 256) = -[CLVisitMonitoringSubscriptionAdapter initWithSubscription:]( objc_alloc(&OBJC_CLASS___CLVisitMonitoringSubscriptionAdapter),  "initWithSubscription:",  a1);
  *(void *)(a1 + 264) = 0LL;
  *(_BYTE *)(a1 + 2sub_1011C52D0(v23 - 72) = 0;
  *(_BYTE *)(a1 + 276) = 0;
  *(void *)(a1 + 2sub_100F6A7D8(v1 + 80) = 0LL;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  id v10 = objc_msgSend(objc_msgSend(*(id *)(a1 + 128), "vendor"), "proxyForService:", @"CLRoutineMonitor");
  *(void *)(a1 + 264) = v10;
  objc_msgSend(v10, "registerDelegate:inSilo:", *(void *)(a1 + 256), objc_msgSend(*(id *)(a1 + 128), "silo"));
  id v11 =  objc_msgSend( objc_msgSend(*(id *)(a1 + 128), "vendor"),  "proxyForService:",  @"CLLocationCorrectiveCompensator");
  *(void *)(a1 + 2sub_100F6A7D8(v1 + 80) = v11;
  objc_msgSend(v11, "registerDelegate:inSilo:", *(void *)(a1 + 256), objc_msgSend(*(id *)(a1 + 128), "silo"));
  id v12 = objc_msgSend(objc_msgSend(*(id *)(a1 + 128), "vendor"), "proxyForService:", @"CLClientManager");
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = v12;
  objc_msgSend(v12, "registerDelegate:inSilo:", *(void *)(a1 + 256), objc_msgSend(*(id *)(a1 + 128), "silo"));
  return a1;
}

void sub_100FC979C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC97DC(uint64_t a1)
{
  *(void *)a1 = off_101892C20;
  sub_100FC9848(a1);

  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 2sub_100F6A7D8(v1 + 80) = 0LL;

  *(void *)(a1 + 264) = 0LL;
  [*(id *)(a1 + 256) invalidate];

  *(void *)(a1 + 256) = 0LL;
  return sub_1004C63B0(a1);
}

void sub_100FC9848(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 276)) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 272);
  if (v2 == 1)
  {
    [*(id *)(a1 + 264) stopLeechingVisitsForClient:*(void *)(a1 + 256)];
  }

  else
  {
    if (v2)
    {
LABEL_7:
      *(_BYTE *)(a1 + 276) = 0;
      goto LABEL_8;
    }

    [*(id *)(a1 + 264) stopMonitoringVisitsForClient:*(void *)(a1 + 256)];
  }

  if (*(_BYTE *)(a1 + 276)) {
    goto LABEL_7;
  }
LABEL_8:
  id v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 128), "vendor"), "proxyForService:", @"CLClientManager");
  __int128 v4 = *(void **)(a1 + 64);
  if (v4)
  {
    [v4 clientName];
  }

  else
  {
    uint64_t v16 = 0LL;
    *(_OWORD *)__int128 __p = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    *(_OWORD *)uint64_t v13 = 0u;
    __int128 v10 = 0u;
    *(_OWORD *)id v11 = 0u;
    *(_OWORD *)int v8 = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    *(_OWORD *)unsigned int v6 = 0u;
    __int128 v7 = 0u;
    *(_OWORD *)id v5 = 0u;
  }

  [v3 setClients:sub_100C7319C((uint64_t)v5) significantLocationVisitTo:0];
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v13[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[1]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  if (SHIBYTE(v9[0]) < 0) {
    operator delete(v8[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  if (SHIBYTE(v6[0]) < 0) {
    operator delete(v5[0]);
  }
}

void sub_100FC9978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FC9990(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100FC97DC(a1);
  operator delete(v1);
}

void *sub_100FC99A4@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_101892DE0;
  v11[1] = sub_100FC9C0C;
  void v11[2] = 0LL;
  __int128 v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageSignificantLocationVisit");
  sub_100891A80((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_101892DE0;
  v9[1] = sub_100FCA088;
  _DWORD v9[2] = 0LL;
  __int128 v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageSignificantLocationVisitState");
  sub_100891A80((uint64_t)v16, (uint64_t)v9);
  sub_100FCBFAC(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    id v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      id v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  id v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    id v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  __n128 result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    __n128 result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_100FC9B3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  unint64_t v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    unint64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  uint64_t v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    uint64_t v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_100FC9C0C(void *a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_1002A5550((int)v23, Dictionary);
  BOOL v22 = 0;
  if ((sub_1002A6F64((uint64_t)v23, "kCLConnectionMessageSubscribeKey", &v22) & 1) != 0)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v6 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[8];
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 2114;
      uint64_t v28 = v7;
      __int16 v29 = 1026;
      BOOL v30 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Client subscribe, client:%{public, location:escape_only}@, subscribe:%{public}hhd}",  buf,  0x22u);
    }

    if (!v22)
    {
      sub_100FCB338(a1, 0LL);
      goto LABEL_20;
    }

    unsigned int v21 = 0;
    uint64_t v8 = *a2;
    sub_1010DDBC0(buf, "com.apple.locationd.slv_configurer");
    char isEntitled = CLConnectionMessage::isEntitled(v8, buf);
    char v10 = isEntitled;
    if (SBYTE3(v28) < 0)
    {
      operator delete(*(void **)buf);
      if ((v10 & 1) != 0) {
        goto LABEL_10;
      }
    }

    else if ((isEntitled & 1) != 0)
    {
LABEL_10:
      sub_100FCB338(a1, v21 | (unint64_t)&_mh_execute_header);
      goto LABEL_20;
    }

    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v17 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      uint64_t v18 = a1[8];
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 2114;
      uint64_t v28 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Client is not entitled to provide #SLV configuration, client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101892DB0);
      }
    }

    uint64_t v19 = qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      uint64_t v20 = a1[8];
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 2114;
      uint64_t v28 = v20;
      uint64_t v13 = "Client is not entitled to provide #SLV configuration";
      uint64_t v14 = "{msg%{public}.0s:Client is not entitled to provide #SLV configuration, client:%{public, location:escape_only}@}";
      __int128 v15 = (os_log_s *)v19;
      uint32_t v16 = 28;
      goto LABEL_18;
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    id v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101892DB0);
      }
    }

    uint64_t v12 = qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      uint64_t v13 = "Couldn't get value for kCLConnectionMessageSubscribeKey key";
      uint64_t v14 = "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}";
      __int128 v15 = (os_log_s *)v12;
      uint32_t v16 = 18;
LABEL_18:
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v13,  v14,  buf,  v16);
    }
  }

void sub_100FCA02C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1002A5590(&a11);

  _Unwind_Resume(a1);
}

void sub_100FCA088(uint64_t a1)
{
  int v2 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v3 = sub_100FCB1A0((void *)a1);
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101892DB0);
  }
  uint64_t v4 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 136) isAuthorizedForServiceType:6];
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)uint64_t buf = 68290050;
    __int16 v24 = 2082;
    int v23 = 0;
    __int16 v25 = "";
    __int16 v26 = 1026;
    *(_DWORD *)__int16 v27 = v5;
    *(_WORD *)&v27[4] = 2114;
    *(void *)&__int16 v27[6] = v3;
    *(_WORD *)&_BYTE v27[14] = 2114;
    *(void *)&v27[16] = v6;
    *(_WORD *)&v27[24] = 2114;
    *(void *)&v27[26] = sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#INFO #slv authorization status, isAuthorized:%{public}hhd, commencementDate:%{pu blic, location:escape_only}@, client:%{public, location:escape_only}@, interest:%{public, location:escape_only}@}",  buf,  0x36u);
  }

  unsigned __int8 v7 = [*(id *)(a1 + 136) isAuthorizedForServiceType:6];
  if (v3) {
    unsigned __int8 v8 = v7;
  }
  else {
    unsigned __int8 v8 = 0;
  }
  if ((v8 & 1) != 0)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v9 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEBUG))
    {
      id v10 = [*(id *)(a1 + 128) silo];
      *(_DWORD *)uint64_t buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      *(void *)__int16 v27 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#slv We can retrieve the visit, Silo:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 264))
    {
      id v11 = objc_alloc(&OBJC_CLASS___RTStoredVisitFetchOptions);
      id v12 =  objc_msgSend( v11,  "initWithAscending:confidence:dateInterval:labelVisit:limit:",  0,  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", RTVisitConfidenceHigh),  0,  1,  &off_1018D50F0);
      uint64_t v13 = *(void **)(a1 + 264);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472LL;
      id v21[2] = sub_100FCB3C4;
      void v21[3] = &unk_101892CE8;
      v21[4] = v3;
      void v21[5] = a1;
      [v13 fetchStoredVisitsWithOptions:v12 withReply:v21];
      goto LABEL_24;
    }

    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v20 = qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      uint64_t v17 = "{msg%{public}.0s:#Warning #slv CLRoutineMonitor is not supported.}";
      uint64_t v18 = (os_log_s *)v20;
      uint32_t v19 = 18;
      goto LABEL_23;
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v14 = qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a1 + 64);
      uint64_t v16 = sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
      *(_DWORD *)uint64_t buf = 68289794;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      *(void *)__int16 v27 = v3;
      *(_WORD *)&v27[8] = 2114;
      *(void *)&v27[10] = v15;
      *(_WORD *)&v27[18] = 2114;
      *(void *)&v27[20] = v16;
      uint64_t v17 = "{msg%{public}.0s:#Warning #slv Got visit state request when we should be unsubscribed, commencemen"
            "tDate:%{public, location:escape_only}@, client:%{public, location:escape_only}@, interest:%{public"
            ", location:escape_only}@}";
      uint64_t v18 = (os_log_s *)v14;
      uint32_t v19 = 48;
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
    }
  }

void sub_100FCA450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100FCA488@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "VisitMonitoring");
}

void sub_100FCA498(void *a1)
{
}

void sub_100FCA4D0(uint64_t a1)
{
  int v2 = (void *)sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
  unsigned int v3 = [*(id *)(a1 + 136) isAuthorizedForServiceType:6];
  uint64_t v4 = sub_100B57ACC((void *)a1, (uint64_t)@"startDate");
  if (v2 && v3)
  {
    if (!v4)
    {
      unsigned int v5 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", CFAbsoluteTimeGetCurrent());
      sub_100B57D4C(a1, (uint64_t)@"startDate", (uint64_t)v5);
      sub_100B57DFC(a1);
    }

    sub_100FCBB8C(a1, (int)[v2 intValue]);
  }

  else
  {
    if (v4)
    {
      sub_100B57D4C(a1, (uint64_t)@"startDate", 0LL);
      sub_100B57DFC(a1);
    }

    sub_100FC9848(a1);
  }

NSData *sub_100FCA5A4(uint64_t a1, void *a2)
{
  unsigned int v3 =  -[NSKeyedArchiver initRequiringSecureCoding:]( objc_alloc(&OBJC_CLASS___NSKeyedArchiver),  "initRequiringSecureCoding:",  1LL);
  [a2 encodeWithCoder:v3];
  return -[NSKeyedArchiver encodedData](v3, "encodedData");
}

void sub_100FCA5EC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = +[CLVisit _visitWithVisit:authDate:](&OBJC_CLASS___CLVisit, "_visitWithVisit:authDate:", a2, a3);
  if (v5)
  {
    uint64_t v6 = v5;
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    unsigned __int8 v7 = (os_log_s *)qword_101934978;
    BOOL v8 = os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 64);
      uint64_t buf = 68289539LL;
      __int16 v53 = 2082;
      __int128 v54 = "";
      __int16 v55 = 2113;
      uint64_t v56 = v6;
      __int16 v57 = 2114;
      uint64_t v58 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Sending visit to client, visit:%{private, location:escape_only}@, client:% {public, location:escape_only}@}",  (uint8_t *)&buf,  0x26u);
    }

    __int128 v50 = @"kCLConnectionMessageSignificantLocationVisitKey";
    __int128 v51 = sub_100FCA5A4(v8, v6);
    id v10 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v51,  &v50,  1LL);
    id v11 = [*(id *)(a1 + 64) legacyClientKey];
    [v6 coordinate];
    uint64_t v13 = v12;
    [v6 coordinate];
    uint64_t v15 = v14;
    [v6 horizontalAccuracy];
    uint64_t v17 = v16;
    uint64_t v18 = objc_alloc(&OBJC_CLASS___CLLocation);
    int v31 = 0xFFFF;
    uint64_t v32 = v13;
    uint64_t v33 = v15;
    uint64_t v34 = v17;
    __asm { FMOV            V0.2D, #-1.0 }

    __int128 v35 = xmmword_1012EA5D0;
    __int128 v36 = _Q0;
    __int128 v37 = _Q0;
    unint64_t v38 = 0xBFF0000000000000LL;
    uint64_t v41 = 0LL;
    uint64_t v42 = 0LL;
    unint64_t v40 = 0xBFF0000000000000LL;
    int v39 = 0;
    int v43 = 0;
    unint64_t v44 = 0xBFF0000000000000LL;
    int v45 = 0x7FFFFFFF;
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    uint64_t v46 = 0LL;
    char v49 = 0;
    __int16 v24 = -[CLLocation initWithClientLocation:](v18, "initWithClientLocation:", &v31);
    __int16 v25 = *(void **)(a1 + 288);
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472LL;
    _DWORD v30[2] = sub_100FCA914;
    uint64_t v30[3] = &unk_101892C70;
    v30[5] = v11;
    v30[6] = a1;
    v30[4] = v10;
    [v25 handleProvisionalIntermediationForService:6 forClientKey:v11 at:v24 withReply:v30];
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    __int16 v26 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(void *)(a1 + 64);
      uint64_t v28 = sub_100B57ACC((void *)a1, (uint64_t)@"activeType");
      unsigned int v29 = [*(id *)(a1 + 136) isAuthorizedForServiceType:6];
      uint64_t buf = 68290050LL;
      __int16 v53 = 2082;
      __int128 v54 = "";
      __int16 v55 = 2114;
      uint64_t v56 = a3;
      __int16 v57 = 2114;
      uint64_t v58 = v27;
      __int16 v59 = 2114;
      uint64_t v60 = v28;
      __int16 v61 = 1026;
      unsigned int v62 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Dropping visit because there's nothing left after slicing out unauthorized bits,  commencementDate:%{public, location:escape_only}@, client:%{public, location:escape_only}@, interest:% {public, location:escape_only}@, authorized:%{public}hhd}",  (uint8_t *)&buf,  0x36u);
    }
  }

void *sub_100FCA914(void *result, int a2)
{
  if (a2)
  {
    int v2 = result;
    uint64_t v3 = result[6];
    sub_100FCA968(v3, result + 4, 10.0);
    return objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(v3 + 128), "vendor"),  "proxyForService:",  @"CLApplicationLifecycleManager"),  "launchApplication:requiringAuthForServiceMask:",  v2[5],  64);
  }

  return result;
}

void sub_100FCA968(uint64_t a1, void *a2, double a3)
{
  uint64_t v25 = 64LL;
  uint64_t v26 = v28;
  uint64_t v27 = v29;
  if (v29)
  {
    p_shared_owners = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  uint64_t v32 = __p;
  BOOL v8 = sub_100C749C8(a1 + 200, (unsigned __int8 *)__p, (uint64_t)&unk_1012CF090, (__int128 **)&v32);
  *((void *)v8 + 5) = v25;
  sub_1000F2F30((void *)v8 + 6, &v26);
  for (uint64_t i = *(void **)(a1 + 176); i; uint64_t i = (void *)*i)
  {
    uint64_t v10 = i[2];
    uint64_t v23 = v28;
    __int16 v24 = v29;
    if (v29)
    {
      id v11 = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v10 + 16LL))(v10, &v23, 64LL);
    uint64_t v13 = v24;
    if (v24)
    {
      uint64_t v14 = (unint64_t *)&v24->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  if (a3 >= 0.0)
  {
    sub_100FCC38C(a1, a3);
  }

  else
  {
    uint64_t v16 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "kCLConnectionMessageSignificantLocationVisit");
    objc_msgSend(objc_msgSend(*(id *)(a1 + 240), "objectForKeyedSubscript:", v16), "invalidate");
    [*(id *)(a1 + 240) setObject:0 forKeyedSubscript:v16];
  }

  uint64_t v17 = v27;
  if (v27)
  {
    uint64_t v18 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = v29;
  if (v29)
  {
    unsigned int v21 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  if (v31 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FCAB80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100FCABC4(uint64_t a1, char *a2)
{
  if (a2)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v4 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 64);
      uint64_t buf = 68289539LL;
      __int16 v55 = 2082;
      uint64_t v56 = "";
      __int16 v57 = 2113;
      uint64_t v58 = a2;
      __int16 v59 = 2114;
      uint64_t v60 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Preparing visit info for client, visit:%{private, location:escape_only}@, cl ient:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x26u);
    }

    uint64_t v6 = objc_alloc(&OBJC_CLASS___CLVisit);
    [a2 coordinate];
    double v8 = v7;
    double v10 = v9;
    [a2 horizontalAccuracy];
    unint64_t v12 =  -[CLVisit initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:]( v6,  "initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:",  +[NSDate distantPast](NSDate, "distantPast"),  +[NSDate distantFuture](NSDate, "distantFuture"),  +[NSDate distantPast](NSDate, "distantPast"),  [a2 _placeInference],  v8,  v10,  v11);
    __int128 v52 = @"kCLConnectionMessageSignificantLocationVisitStateKey";
    __int16 v53 = sub_100FCA5A4((uint64_t)v12, v12);
    uint64_t v13 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v53,  &v52,  1LL);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101892DB0);
    }
    uint64_t v14 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a1 + 64);
      uint64_t buf = 68289539LL;
      __int16 v55 = 2082;
      uint64_t v56 = "";
      __int16 v57 = 2081;
      uint64_t v58 = "";
      __int16 v59 = 2114;
      uint64_t v60 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Preparing visit info for client, visit:%{private, location:escape_only}s, cl ient:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x26u);
    }

    uint64_t v13 = (NSDictionary *)&__NSDictionary0__struct;
  }

  id v16 = [*(id *)(a1 + 64) legacyClientKey];
  [a2 coordinate];
  uint64_t v18 = v17;
  [a2 coordinate];
  uint64_t v20 = v19;
  [a2 horizontalAccuracy];
  uint64_t v22 = v21;
  uint64_t v23 = objc_alloc(&OBJC_CLASS___CLLocation);
  int v33 = 0xFFFF;
  uint64_t v34 = v18;
  uint64_t v35 = v20;
  uint64_t v36 = v22;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v37 = xmmword_1012EA5D0;
  __int128 v38 = _Q0;
  __int128 v39 = _Q0;
  unint64_t v40 = 0xBFF0000000000000LL;
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  unint64_t v42 = 0xBFF0000000000000LL;
  int v41 = 0;
  int v45 = 0;
  unint64_t v46 = 0xBFF0000000000000LL;
  int v47 = 0x7FFFFFFF;
  uint64_t v49 = 0LL;
  uint64_t v50 = 0LL;
  uint64_t v48 = 0LL;
  char v51 = 0;
  unsigned int v29 = -[CLLocation initWithClientLocation:](v23, "initWithClientLocation:", &v33);
  BOOL v30 = *(void **)(a1 + 288);
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472LL;
  uint64_t v32[2] = sub_100FCAF28;
  v32[3] = &unk_101892C98;
  _DWORD v32[4] = v13;
  v32[5] = a1;
  return [v30 handleProvisionalIntermediationForService:6 forClientKey:v16 at:v29 withReply:v32];
}

void sub_100FCAF28(uint64_t a1, int a2)
{
  if (a2) {
    sub_100FCAF44(*(void *)(a1 + 40), (void *)(a1 + 32), 10.0);
  }
}

void sub_100FCAF44(uint64_t a1, void *a2, double a3)
{
  uint64_t v25 = 64LL;
  uint64_t v26 = v28;
  uint64_t v27 = v29;
  if (v29)
  {
    p_shared_owners = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  uint64_t v32 = __p;
  double v8 = sub_100C749C8(a1 + 200, (unsigned __int8 *)__p, (uint64_t)&unk_1012CF090, (__int128 **)&v32);
  *((void *)v8 + 5) = v25;
  sub_1000F2F30((void *)v8 + 6, &v26);
  for (uint64_t i = *(void **)(a1 + 176); i; uint64_t i = (void *)*i)
  {
    uint64_t v10 = i[2];
    uint64_t v23 = v28;
    __int16 v24 = v29;
    if (v29)
    {
      double v11 = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v10 + 16LL))(v10, &v23, 64LL);
    uint64_t v13 = v24;
    if (v24)
    {
      uint64_t v14 = (unint64_t *)&v24->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  if (a3 >= 0.0)
  {
    sub_100FCC528(a1, a3);
  }

  else
  {
    id v16 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "kCLConnectionMessageSignificantLocationVisitState");
    objc_msgSend(objc_msgSend(*(id *)(a1 + 240), "objectForKeyedSubscript:", v16), "invalidate");
    [*(id *)(a1 + 240) setObject:0 forKeyedSubscript:v16];
  }

  uint64_t v17 = v27;
  if (v27)
  {
    uint64_t v18 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = v29;
  if (v29)
  {
    uint64_t v21 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  if (v31 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FCB15C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NSDate *sub_100FCB1A0(void *a1)
{
  __n128 result = (NSDate *)sub_100B57ACC(a1, (uint64_t)@"startDate");
  if (result)
  {
    -[NSDate doubleValue](result, "doubleValue");
    return +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:");
  }

  return result;
}

void sub_100FCB1E4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = sub_100FCB218(a1, a2, *(void **)(a1 + 32));
  sub_100FCA5EC(v3, (uint64_t)v4, *(void **)(a1 + 40));
}

CLVisit *sub_100FCB218(uint64_t a1, void *a2, void *a3)
{
  if (a2)
  {
    [a2 clientLocation];
    double v5 = v11;
    [a2 clientLocation];
    double v6 = v10;
    unint64_t v7 = objc_alloc(&OBJC_CLASS___CLVisit);
    [a2 clientLocation];
    double v8 = v12;
  }

  else
  {
    unint64_t v7 = objc_alloc(&OBJC_CLASS___CLVisit);
    double v8 = 0.0;
    double v6 = 0.0;
    double v5 = 0.0;
  }

  return  -[CLVisit initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:]( v7,  "initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:",  [a3 arrivalDate],  objc_msgSend(a3, "departureDate"),  objc_msgSend(a3, "detectionDate"),  objc_msgSend(a3, "_placeInference"),  v5,  v6,  v8);
}