void sub_1006E3B34(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  os_log_s *v5;
  const char *v6;
  os_log_s *v7;
  int v8;
  int v9;
  os_log_s *v10;
  int v11;
  int v12;
  os_log_s *v13;
  os_log_s *v14;
  os_log_s *v15;
  os_log_s *v16;
  int v17;
  int v18;
  const char *v19;
  uint8_t *v20;
  const char *v21;
  uint8_t *v22;
  const char *v23;
  uint8_t *v24;
  const char *v25;
  uint8_t *v26;
  const char *v27;
  uint8_t *v28;
  uint8_t *v29;
  uint64_t v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  BOOL v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  BOOL v41;
  v2 = *(void *)(a1 + 40);
  v3 = *(_DWORD *)(v2 + 52);
  if (*(_BYTE *)(a1 + 48))
  {
    if (v3 != -1)
    {
      v4 = v3 + 1;
LABEL_6:
      *(_DWORD *)(v2 + 52) = v4;
      goto LABEL_20;
    }

    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    v5 = (os_log_s *)qword_101934558;
    if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "[CLSPUMagicMountControl] Invalid client count. Not increasing.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934550 != -1) {
        dispatch_once(&qword_101934550, &stru_10184B208);
      }
      LOWORD(v31) = 0;
      LODWORD(v30) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  16LL,  "[CLSPUMagicMountControl] Invalid client count. Not increasing.",  &v31,  v30,  v31);
LABEL_75:
      v29 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLSPUMagicMountControl::setMagicMountDetectionEnabled(BOOL)_block_invoke",  "%s\n",  v6);
      if (v29 != buf) {
        free(v29);
      }
    }
  }

  else
  {
    if (v3)
    {
      v4 = v3 - 1;
      goto LABEL_6;
    }

    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    v7 = (os_log_s *)qword_101934558;
    if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "[CLSPUMagicMountControl] Invalid client count. Not decreasing.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934550 != -1) {
        dispatch_once(&qword_101934550, &stru_10184B208);
      }
      LOWORD(v31) = 0;
      LODWORD(v30) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  16LL,  "[CLSPUMagicMountControl] Invalid client count. Not decreasing.",  &v31,  v30,  v31);
      goto LABEL_75;
    }
  }

BOOL sub_1006E4468(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 52);
  int v4 = *(_DWORD *)(a1 + 56) == v2 && v2 != 0;
  int v5 = *(unsigned __int8 *)(a1 + 48);
  if (qword_101934550 != -1) {
    dispatch_once(&qword_101934550, &stru_10184B208);
  }
  v6 = (os_log_s *)qword_101934558;
  if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 52);
    int v7 = *(_DWORD *)(a1 + 56);
    int v9 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)buf = 67240960;
    int v28 = v7;
    __int16 v29 = 1026;
    int v30 = v8;
    __int16 v31 = 1026;
    int v32 = v9;
    __int16 v33 = 1026;
    BOOL v34 = v5 != v4;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[CLSPUMagicMountControl] Number of DisableAPWakes clients,%{public}u, Number of service clients,%{public}d, prior status (isDisabled),%{public}d, shouldConfigure,%{public}d",  buf,  0x1Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    int v13 = *(_DWORD *)(a1 + 52);
    int v12 = *(_DWORD *)(a1 + 56);
    int v14 = *(unsigned __int8 *)(a1 + 48);
    v20[0] = 67240960;
    v20[1] = v12;
    __int16 v21 = 1026;
    int v22 = v13;
    __int16 v23 = 1026;
    int v24 = v14;
    __int16 v25 = 1026;
    BOOL v26 = v5 != v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  0LL,  "[CLSPUMagicMountControl] Number of DisableAPWakes clients,%{public}u, Number of service clients,%{public}d, prior status (isDisabled),%{public}d, shouldConfigure,%{public}d",  v20,  26);
    v16 = (uint8_t *)v15;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSPUMagicMountControl::checkDisableAPWakesCriteria()", "%s\n", v15);
    if (v16 != buf) {
      free(v16);
    }
  }

  if (v5 == v4)
  {
    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    v10 = (os_log_s *)qword_101934558;
    if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "[CLSPUMagicMountControl] No APWakes configure needed.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934550 != -1) {
        dispatch_once(&qword_101934550, &stru_10184B208);
      }
      LOWORD(v20[0]) = 0;
      LODWORD(v19) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  2LL,  "[CLSPUMagicMountControl] No APWakes configure needed.",  v20,  v19);
      v18 = (uint8_t *)v17;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSPUMagicMountControl::checkDisableAPWakesCriteria()", "%s\n", v17);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 48) = v4;
  }

  return v5 != v4;
}

BOOL sub_1006E47C4(uint64_t a1)
{
  BYTE6(v7) = 4;
  int v2 = *(unsigned __int8 *)(a1 + 48) ^ 1;
  HIBYTE(v7) = *(_BYTE *)(a1 + 48) ^ 1;
  if (qword_101934550 != -1) {
    dispatch_once(&qword_101934550, &stru_10184B208);
  }
  v3 = (os_log_s *)qword_101934558;
  if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    int v10 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "[CLMagicMountControl] APWakesSetting,isAllowed,%{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    v8[0] = 67240192;
    v8[1] = v2;
    LODWORD(v7) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  0LL,  "[CLMagicMountControl] APWakesSetting,isAllowed,%{public}d",  v8,  v7);
    v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSPUMagicMountControl::sendAPWakesAllowedCommand()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  return sub_100CD5940(a1, (uint64_t)&v7 + 6, (char *)2);
}

uint64_t sub_1006E4990(uint64_t a1, char a2)
{
  uint64_t v9 = 0LL;
  int v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 1;
  uint64_t v4 = sub_1006E27E8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_1006E4A4C;
  v7[3] = &unk_10184B178;
  char v8 = a2;
  v7[4] = &v9;
  v7[5] = a1;
  sub_1006E28B8(v4, (uint64_t)v7);
  uint64_t v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_1006E4A34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1006E4A4C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = *(_DWORD *)(v2 + 56);
  if (*(_BYTE *)(a1 + 48))
  {
    if (v3)
    {
      int v4 = v3 - 1;
LABEL_6:
      *(_DWORD *)(v2 + 56) = v4;
      goto LABEL_20;
    }

    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    uint64_t v5 = (os_log_s *)qword_101934558;
    if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "[CLSPUMagicMountControl] Invalid APWake client count. Not decreasing.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934550 != -1) {
        dispatch_once(&qword_101934550, &stru_10184B208);
      }
      LOWORD(v13[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  16LL,  "[CLSPUMagicMountControl] Invalid APWake client count. Not decreasing.",  v13,  2,  v13[0]);
LABEL_35:
      uint64_t v11 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLSPUMagicMountControl::setAPWakesAllowed(BOOL)_block_invoke",  "%s\n",  v6);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  else
  {
    if (v3 != -1)
    {
      int v4 = v3 + 1;
      goto LABEL_6;
    }

    if (qword_101934550 != -1) {
      dispatch_once(&qword_101934550, &stru_10184B208);
    }
    uint64_t v7 = (os_log_s *)qword_101934558;
    if (os_log_type_enabled((os_log_t)qword_101934558, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "[CLSPUMagicMountControl] Invalid APWake client count. Not increasing.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934550 != -1) {
        dispatch_once(&qword_101934550, &stru_10184B208);
      }
      LOWORD(v13[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934558,  16LL,  "[CLSPUMagicMountControl] Invalid APWake client count. Not increasing.",  v13,  2,  v13[0]);
      goto LABEL_35;
    }
  }

void sub_1006E4E40(uint64_t *a1)
{
  *a1 = (uint64_t)&off_10184B1E8;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10029D2EC(a1 + 3, 0LL);
  sub_10000AE14(v2);
  operator delete(a1);
}

void sub_1006E4E88(id a1)
{
  qword_101934558 = (uint64_t)os_log_create("com.apple.locationd.Motion", "MagicMount");
}

uint64_t sub_1006E4EB4(uint64_t a1)
{
  *(void *)a1 = off_10184B238;
  *(_DWORD *)(a1 + 16) = 1065353216;
  uint64_t v2 = (float *)(a1 + 16);
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0x40426A333F800000LL;
  *(_DWORD *)(a1 + 24) = 1053609165;
  int v3 = (float *)(a1 + 24);
  sub_1005EF1AC(a1 + 32, 2048LL, 0LL);
  uint64_t v4 = sub_1006E27E8();
  sub_100413284(v4, buf);
  uint64_t v5 = (_BYTE *)(a1 + 20);
  char v6 = sub_1002A6F64(*(uint64_t *)buf, "EnableEllipticalLoadCal", (BOOL *)(a1 + 20));
  char v7 = v6;
  char v8 = (std::__shared_weak_count *)v32[0];
  if (v32[0])
  {
    uint64_t v9 = (unint64_t *)(v32[0] + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if ((v7 & 1) != 0) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }

  if ((v6 & 1) == 0) {
LABEL_6:
  }
    *uint64_t v5 = 1;
LABEL_7:
  uint64_t v11 = sub_1006E27E8();
  sub_100413284(v11, buf);
  sub_1002A81F8(*(uint64_t *)buf, "EllipticalModelMetsScale", v2);
  uint64_t v12 = (std::__shared_weak_count *)v32[0];
  if (v32[0])
  {
    int v13 = (unint64_t *)(v32[0] + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  sub_1002A81F8(*(uint64_t *)buf, "EllipticalModelSwitchMargin", v3);
  v16 = (std::__shared_weak_count *)v32[0];
  if (v32[0])
  {
    v17 = (unint64_t *)(v32[0] + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184B278);
  }
  uint64_t v19 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    int v20 = *v5;
    double v21 = *v3;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v20;
    LOWORD(v32[0]) = 2048;
    *(double *)((char *)v32 + 2) = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Ellptical, Load Calibration Enabled status, %d, WR-HR switch margin, %f",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B278);
    }
    int v23 = *v5;
    double v24 = *v3;
    v28[0] = 67109376;
    v28[1] = v23;
    __int16 v29 = 2048;
    double v30 = v24;
    LODWORD(v27) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Ellptical, Load Calibration Enabled status, %d, WR-HR switch margin, %f",  v28,  v27);
    BOOL v26 = (uint8_t *)v25;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLNatalieEllipticalModel::CLNatalieEllipticalModel()", "%s\n", v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  return a1;
}

void sub_1006E5210(_Unwind_Exception *a1)
{
}

uint64_t sub_1006E5250(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 48) + 48LL))(*(void *)(a3 + 48));
  if ((_DWORD)result)
  {
    uint64_t result = (*(uint64_t (**)(void, _BYTE *, double))(**(void **)(a3 + 48) + 24LL))( *(void *)(a3 + 48),  v6,  a1);
    if (v6[208]) {
      return sub_100253308(*(void *)(a3 + 8));
    }
  }

  return result;
}

uint64_t sub_1006E52E8(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 40) + 48LL))(*(void *)(a3 + 40));
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void, double))(**(void **)(a3 + 8) + 48LL))(*(void *)(a3 + 8), a1);
  }
  return result;
}

void sub_1006E5344(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  float v6 = *(float *)(a2 + 1364);
  LODWORD(v49) = *(_DWORD *)(a2 + 1368);
  float v7 = *(float *)(a2 + 1372);
  float v8 = *(float *)(a2 + 1376);
  float v9 = *(float *)(a2 + 1380);
  unsigned int v10 = *(_DWORD *)(a2 + 400);
  double v11 = *(double *)(a2 + 128);
  float v12 = (double)v10 / (v11 - *(double *)(a2 + 120));
  float v13 = (float)(*(float *)(a1 + 12) / v6) * v12;
  if (v12 <= 0.0) {
    float v14 = 2.1;
  }
  else {
    float v14 = (float)((float)(v12 * 0.5748) + 3.4781) + (float)(v13 * 34.475);
  }
  HIBYTE(v49) = 0;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184B278);
  }
  uint64_t v15 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    double v16 = *(double *)(a2 + 128) - *(double *)(a2 + 120);
    double v17 = *(float *)(a1 + 12);
    *(_DWORD *)buf = 134219776;
    double v61 = v11;
    __int16 v62 = 2048;
    double v63 = v16;
    __int16 v64 = 1024;
    *(_DWORD *)v65 = v10;
    *(_WORD *)&v65[4] = 2048;
    *(double *)&v65[6] = v12;
    *(_WORD *)&v65[14] = 2048;
    *(double *)&v65[16] = v17;
    *(_WORD *)&v65[24] = 2048;
    *(double *)&v65[26] = v6;
    *(_WORD *)&v65[34] = 2048;
    *(double *)&v65[36] = v13;
    *(_WORD *)&v65[44] = 2048;
    *(double *)&v65[46] = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Elliptical, Linear Regression, timestamp, %f, duration, %f, stepcount, %d, steprate, %f, resistance, %f, weight, % f, feature2, %f, mets, %f",  buf,  0x4Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B278);
    }
    double v37 = *(double *)(a2 + 128) - *(double *)(a2 + 120);
    double v38 = *(float *)(a1 + 12);
    int v50 = 134219776;
    double v51 = v11;
    __int16 v52 = 2048;
    double v53 = v37;
    __int16 v54 = 1024;
    *(_DWORD *)v55 = v10;
    *(_WORD *)&v55[4] = 2048;
    *(double *)&v55[6] = v12;
    *(_WORD *)&v55[14] = 2048;
    *(double *)&v55[16] = v38;
    *(_WORD *)&v55[24] = 2048;
    *(double *)&v55[26] = v6;
    *(_WORD *)&v55[34] = 2048;
    *(double *)&v55[36] = v13;
    *(_WORD *)&v55[44] = 2048;
    *(double *)&v55[46] = v14;
    LODWORD(v47) = 78;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Elliptical, Linear Regression, timestamp, %f, duration, %f, stepcount, %d, steprate, %f, resistance, %f, weight, % f, feature2, %f, mets, %f",  COERCE_DOUBLE(&v50),  v47,  LODWORD(v48),  v49);
    v40 = (uint8_t *)v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieEllipticalModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v39);
    if (v40 != buf) {
      free(v40);
    }
  }

  float v18 = 0.0;
  float v19 = *(double *)(a2 + 560);
  double v20 = v19;
  float v21 = (v9 - v19) / (v9 - v8);
  float v22 = sub_100D086F8(v21, v7);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184B278);
  }
  float v18 = *(float *)&v49 * v22;
  int v23 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134219264;
    double v61 = v11;
    __int16 v62 = 2048;
    double v63 = v20;
    __int16 v64 = 2048;
    *(double *)v65 = v9;
    *(_WORD *)&v65[8] = 2048;
    *(double *)&v65[10] = v8;
    *(_WORD *)&v65[18] = 2048;
    *(double *)&v65[20] = *(float *)&v49;
    *(_WORD *)&v65[28] = 2048;
    *(double *)&v65[30] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "Elliptical, DT Regression, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max (METs), %f, METS, %f",  buf,  0x3Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B278);
    }
    int v50 = 134219264;
    double v51 = v11;
    __int16 v52 = 2048;
    double v53 = v20;
    __int16 v54 = 2048;
    *(double *)v55 = v9;
    *(_WORD *)&v55[8] = 2048;
    *(double *)&v55[10] = v8;
    *(_WORD *)&v55[18] = 2048;
    *(double *)&v55[20] = *(float *)&v49;
    *(_WORD *)&v55[28] = 2048;
    *(double *)&v55[30] = v18;
    LODWORD(v47) = 62;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Elliptical, DT Regression, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max (METs), %f, METS, %f",  COERCE_DOUBLE(&v50),  v47,  v48,  v49);
    v46 = (uint8_t *)v45;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieEllipticalModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v45);
    if (v46 != buf) {
      free(v46);
    }
  }

  if (*(_BYTE *)(a1 + 20))
  {
    sub_1005EF1B0((char *)(a1 + 32), a2, (_BYTE *)&v49 + 7, v11, v18, v14);
    *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v24;
    int v25 = 2 * HIBYTE(v49);
  }

  else
  {
LABEL_18:
    int v25 = 0;
  }

  double v26 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 40);
  float v27 = 1.0;
  if (v26 >= 300.0) {
    float v28 = v27;
  }
  else {
    float v28 = *(float *)(a1 + 8);
  }
  *(float *)(a1 + _Block_object_dispose(va, 8) = v28;
  float v29 = v14 * v28;
  float v30 = -1.0;
  if (v18 > 0.0) {
    float v30 = (float)(v18 - v29) / v18;
  }
  float v31 = *(float *)(a1 + 24);
  if (v30 > v31) {
    int v32 = 1;
  }
  else {
    int v32 = v25;
  }
  if (v30 <= v31) {
    float v33 = v29;
  }
  else {
    float v33 = v18;
  }
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184B278);
  }
  BOOL v34 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    double v35 = *(float *)(a1 + 8);
    double v36 = *(float *)(a1 + 16);
    *(_DWORD *)buf = 134220288;
    double v61 = v11;
    __int16 v62 = 2048;
    double v63 = v18;
    __int16 v64 = 2048;
    *(double *)v65 = v14;
    *(_WORD *)&v65[8] = 2048;
    *(double *)&v65[10] = v35;
    *(_WORD *)&v65[18] = 2048;
    *(double *)&v65[20] = v29;
    *(_WORD *)&v65[28] = 2048;
    *(double *)&v65[30] = v30;
    *(_WORD *)&v65[38] = 2048;
    *(double *)&v65[40] = v33;
    *(_WORD *)&v65[48] = 1024;
    *(_DWORD *)&v65[50] = v32;
    __int16 v66 = 2048;
    double v67 = v36;
    __int16 v68 = 1024;
    int v69 = HIBYTE(v49);
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "Elliptical, METs, timestamp, %f, hrMets, %f, wrMets, %f, calibrationValue, %f, calibrated wrMets, %f, HR-WR diff, %f, mets, %f, metsSource, %d, fMetsScaling, %f, loadCalStatus, %d",  buf,  0x5Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B278);
    }
    double v41 = *(float *)(a1 + 8);
    double v42 = *(float *)(a1 + 16);
    int v50 = 134220288;
    double v51 = v11;
    __int16 v52 = 2048;
    double v53 = v18;
    __int16 v54 = 2048;
    *(double *)v55 = v14;
    *(_WORD *)&v55[8] = 2048;
    *(double *)&v55[10] = v41;
    *(_WORD *)&v55[18] = 2048;
    *(double *)&v55[20] = v29;
    *(_WORD *)&v55[28] = 2048;
    *(double *)&v55[30] = v30;
    *(_WORD *)&v55[38] = 2048;
    *(double *)&v55[40] = v33;
    *(_WORD *)&v55[48] = 1024;
    *(_DWORD *)&v55[50] = v32;
    __int16 v56 = 2048;
    double v57 = v42;
    __int16 v58 = 1024;
    int v59 = HIBYTE(v49);
    LODWORD(v47) = 94;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Elliptical, METs, timestamp, %f, hrMets, %f, wrMets, %f, calibrationValue, %f, calibrated wrMets, %f, HR-WR diff, %f, mets, %f, metsSource, %d, fMetsScaling, %f, loadCalStatus, %d",  COERCE_DOUBLE(&v50),  v47,  v48,  v49);
    v44 = (uint8_t *)v43;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieEllipticalModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v43);
    if (v44 != buf) {
      free(v44);
    }
  }

  *(float *)a3 = v18;
  *(float *)(a3 + 4) = v14;
  *(_DWORD *)(a3 + _Block_object_dispose(va, 8) = 0;
  *(float *)(a3 + 12) = v14;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)(a3 + 20) = v33 * *(float *)(a1 + 16);
  *(_DWORD *)(a3 + 24) = v32;
  *(_DWORD *)(a3 + 2_Block_object_dispose(va, 8) = 0;
  *(void *)(a3 + 32) = 0x600000003LL;
}

void sub_1006E5B40(void *a1)
{
  v1 = sub_1006E5B80(a1);
  operator delete(v1);
}

void sub_1006E5B54(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void *sub_1006E5B80(void *a1)
{
  *a1 = off_10184B238;
  uint64_t v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }

  int v3 = (void *)a1[16];
  if (v3)
  {
    a1[17] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[13];
  if (v4)
  {
    a1[14] = v4;
    operator delete(v4);
  }

  sub_10000AE14((uint64_t)(a1 + 11));
  uint64_t v5 = (void *)a1[7];
  if (v5)
  {
    a1[8] = v5;
    operator delete(v5);
  }

  return a1;
}

uint64_t sub_1006E5BF4()
{
  uint64_t result = sub_1004FAB40();
  if ((result & 4) != 0)
  {
    v1 = operator new(0x38uLL);
    uint64_t result = sub_1006E5C84((uint64_t)v1);
    qword_1019A1598 = (uint64_t)v1;
  }

  return result;
}

void sub_1006E5C2C(_Unwind_Exception *a1)
{
}

uint64_t sub_1006E5C40()
{
  if (qword_101998268 != -1) {
    dispatch_once(&qword_101998268, &stru_10184B298);
  }
  return qword_1019A1598;
}

uint64_t sub_1006E5C84(uint64_t a1)
{
  uint64_t v2 = sub_1006DC9EC(a1, (uint64_t)"CLAccelerometer", 1);
  *(void *)uint64_t v2 = off_10184B2C8;
  *(_BYTE *)(v2 + 32) = 0;
  int v3 = (BOOL *)(v2 + 32);
  *(void *)(v2 + 40) = 0LL;
  *(void *)(v2 + 4_Block_object_dispose(va, 8) = 0LL;
  uint64_t v4 = sub_1006E27E8();
  sub_100413284(v4, &v11);
  char v5 = sub_1002A6F64(v11, "LogAccelerometer", v3);
  char v6 = v5;
  float v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if ((v6 & 1) != 0) {
        return a1;
      }
      goto LABEL_6;
    }
  }

  if ((v5 & 1) == 0) {
LABEL_6:
  }
    BOOL *v3 = 0;
  return a1;
}

void sub_1006E5D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1006E5D84(void *a1)
{
  *a1 = off_10184B2C8;
  sub_10000AE14((uint64_t)(a1 + 5));
  return sub_1006DCAA8(a1);
}

void sub_1006E5DB4(void *a1)
{
  *a1 = off_10184B2C8;
  sub_10000AE14((uint64_t)(a1 + 5));
  uint64_t v2 = sub_1006DCAA8(a1);
  operator delete(v2);
}

double sub_1006E5DE8(uint64_t a1, int a2, double *a3)
{
  if (a2)
  {
    if (qword_1019345A0 != -1) {
      dispatch_once(&qword_1019345A0, &stru_10184B310);
    }
    int v3 = (os_log_s *)qword_1019345A8;
    if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Unrecognized notification", buf, 2u);
    }

    double v4 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      LOWORD(v15) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  17LL,  "Unrecognized notification",  &v15,  2);
      char v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    double v4 = 0.0;
    if (sub_1006E60FC(a1))
    {
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      unint64_t v9 = (os_log_s *)qword_1019345A8;
      if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_INFO))
      {
        double v10 = *a3;
        *(_DWORD *)buf = 134349056;
        double v18 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Setting accelerometer update interval to %{public}f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345A0 != -1) {
          dispatch_once(&qword_1019345A0, &stru_10184B310);
        }
        uint64_t v12 = *(void *)a3;
        int v15 = 134349056;
        uint64_t v16 = v12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  1LL,  "Setting accelerometer update interval to %{public}f",  &v15,  12);
        float v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }

      sub_10071A73C(*(void *)(a1 + 40), *a3);
      return *a3;
    }
  }

  return v4;
}

uint64_t sub_1006E60FC(uint64_t a1)
{
  unsigned int v2 = sub_1004FAB40();
  if ((v2 & 4) != 0)
  {
    if (!*(void *)(a1 + 40))
    {
      int v3 = (uint64_t *)sub_10071542C();
      uint64_t v22 = 0x30000FF00LL;
      char v23 = 0;
      sub_10121B774(v3, (uint64_t)&v22, (uint64_t *)buf);
      sub_10005F550(a1 + 40, (__int128 *)buf);
      double v4 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        char v5 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }

      id v7 = [&off_1018D6990 mutableCopy];
      HIDWORD(v21) = 0;
      uint64_t v8 = sub_1006E27E8();
      sub_100413284(v8, buf);
      int v9 = sub_1002A775C(*(uint64_t *)buf, "IMULocationID", (_DWORD *)&v21 + 1);
      if (HIDWORD(v21)) {
        int v10 = 1;
      }
      else {
        int v10 = v9;
      }
      uint64_t v11 = *(std::__shared_weak_count **)&buf[8];
      if (!*(void *)&buf[8]) {
        goto LABEL_15;
      }
      uint64_t v12 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
        if (v10) {
          goto LABEL_16;
        }
      }

      else
      {
LABEL_15:
        if (v10)
        {
LABEL_16:
          objc_msgSend( v7,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", HIDWORD(v21)),  @"LocationID");
          if (qword_1019345A0 != -1) {
            dispatch_once(&qword_1019345A0, &stru_10184B310);
          }
          float v14 = (os_log_s *)qword_1019345A8;
          if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = HIDWORD(v21);
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Setting Accel matching properties with IMULocationID %d",  buf,  8u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345A0 != -1) {
              dispatch_once(&qword_1019345A0, &stru_10184B310);
            }
            v24[0] = 67109120;
            v24[1] = HIDWORD(v21);
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  0LL,  "Setting Accel matching properties with IMULocationID %d",  v24);
            double v20 = (uint8_t *)v19;
            sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLAccelerometer::openHidDevice()", "%s\n", v19);
            if (v20 != buf) {
              free(v20);
            }
          }
        }
      }

      sub_10071A850(*(void *)(a1 + 40), v7);
      sub_100719D78(*(uint64_t **)(a1 + 40), (uint64_t)sub_1006E6C10, a1);
    }
  }

  else
  {
    if (qword_1019345A0 != -1) {
      dispatch_once(&qword_1019345A0, &stru_10184B310);
    }
    int v15 = (os_log_s *)qword_1019345A8;
    if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Accel unavailable, unable to establish hid interface",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      LOWORD(v24[0]) = 0;
      LODWORD(v21) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  17LL,  "Accel unavailable, unable to establish hid interface",  v24,  v21);
      double v18 = (uint8_t *)v17;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLAccelerometer::openHidDevice()", "%s\n", v17);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

  return (v2 >> 2) & 1;
}

void sub_1006E6538( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

double sub_1006E6568(uint64_t a1, int a2, double *a3)
{
  if (a2)
  {
    if (qword_1019345A0 != -1) {
      dispatch_once(&qword_1019345A0, &stru_10184B310);
    }
    double v4 = (os_log_s *)qword_1019345A8;
    if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v19) = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unrecognized notification %{public}d", buf, 8u);
    }

    double v5 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      int v16 = 67240192;
      LODWORD(v17) = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  17LL,  "Unrecognized notification %{public}d",  &v16,  8);
      id v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    double v5 = 0.0;
    if (sub_1006E60FC(a1))
    {
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      int v10 = (os_log_s *)qword_1019345A8;
      if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_INFO))
      {
        double v11 = *a3;
        *(_DWORD *)buf = 134349056;
        double v19 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Setting batch interval to %{public}f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345A0 != -1) {
          dispatch_once(&qword_1019345A0, &stru_10184B310);
        }
        uint64_t v13 = *(void *)a3;
        int v16 = 134349056;
        uint64_t v17 = v13;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  1LL,  "Setting batch interval to %{public}f",  &v16,  12);
        int v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }

      sub_10071A7C0(*(void *)(a1 + 40), *a3);
      return *a3;
    }
  }

  return v5;
}

uint64_t sub_1006E6898(uint64_t a1, uint64_t a2, double *a3)
{
  v27[0] = *a3;
  v27[1] = *(double *)a2;
  int v28 = *(_DWORD *)(a2 + 8);
  if (qword_1019345A0 != -1) {
    dispatch_once(&qword_1019345A0, &stru_10184B310);
  }
  unint64_t v6 = (os_log_s *)qword_1019345A8;
  if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_DEBUG))
  {
    double v7 = *(float *)a2;
    double v8 = *(float *)(a2 + 4);
    double v9 = *(float *)(a2 + 8);
    double v10 = *a3;
    *(_DWORD *)buf = 134218752;
    double v30 = v7;
    __int16 v31 = 2048;
    double v32 = v8;
    __int16 v33 = 2048;
    double v34 = v9;
    __int16 v35 = 2048;
    double v36 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "[Accelerometer] x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345A0 != -1) {
      dispatch_once(&qword_1019345A0, &stru_10184B310);
    }
    double v19 = *(float *)a2;
    double v20 = *(float *)(a2 + 4);
    double v21 = *(float *)(a2 + 8);
    double v22 = *a3;
    *(_DWORD *)v39 = 134218752;
    *(double *)&v39[4] = v19;
    *(_WORD *)&v39[12] = 2048;
    *(double *)&v39[14] = v20;
    __int16 v40 = 2048;
    double v41 = v21;
    *(_WORD *)double v42 = 2048;
    *(double *)&v42[2] = v22;
    LODWORD(v25) = 42;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  2LL,  "[Accelerometer] x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f",  COERCE_DOUBLE(v39),  v25,  v26,  v27[0]);
    int v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAccelerometer::onAccelerometerData(const CLMotionTypeAcceleration &, const CLMotionTypeTimestamp &)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

  if (*(_BYTE *)(a1 + 32))
  {
    *(void *)v39 = &off_1018577E8;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    double v12 = *(double *)a2;
    *(_DWORD *)&v42[8] = *(_DWORD *)(a2 + 8);
    double v13 = *a3;
    *(CFAbsoluteTime *)&v39[8] = Current;
    double v41 = v13;
    *(double *)double v42 = v12;
    uint64_t v14 = sub_100E00E14();
    sub_100E022E0(v14, (uint64_t)v39);
    sub_101125260(buf);
    sub_10113A4E8(buf);
    v38 |= 1u;
    uint64_t v37 = *(void *)&v39[8];
    double v15 = v34;
    double v16 = *a3;
    char v17 = *(_BYTE *)(*(void *)&v34 + 32LL);
    *(_BYTE *)(*(void *)&v34 + 32LL) = v17 | 1;
    *(double *)(*(void *)&v15 + 8LL) = v16;
    LODWORD(v16) = *(_DWORD *)a2;
    *(_BYTE *)(*(void *)&v15 + 32LL) = v17 | 5;
    *(_DWORD *)(*(void *)&v15 + 20LL) = LODWORD(v16);
    LODWORD(v16) = *(_DWORD *)(a2 + 4);
    *(_BYTE *)(*(void *)&v15 + 32LL) = v17 | 0xD;
    *(_DWORD *)(*(void *)&v15 + 24LL) = LODWORD(v16);
    LODWORD(v16) = *(_DWORD *)(a2 + 8);
    *(_BYTE *)(*(void *)&v15 + 32LL) = v17 | 0x1D;
    *(_DWORD *)(*(void *)&v15 + 28LL) = LODWORD(v16);
    if (qword_1019A1D00 != -1) {
      dispatch_once(&qword_1019A1D00, &stru_10184B330);
    }
    if (qword_1019A1D08) {
      sub_1011CF3D0(qword_1019A1D08, (uint64_t)buf);
    }
    sub_101127D00((PB::Base *)buf);
  }

  return sub_1006DD528(a1, 0LL, (uint64_t)v27, 24LL);
}

void sub_1006E6BF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1006E6C10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (IOHIDEventGetType(a4) == 13)
  {
    if (IOHIDEventGetIntegerValue(a4, 851971LL) == 1)
    {
      if (qword_1019345A0 != -1) {
        dispatch_once(&qword_1019345A0, &stru_10184B310);
      }
      unint64_t v6 = (os_log_s *)qword_1019345A8;
      if (os_log_type_enabled((os_log_t)qword_1019345A8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Received shake data, discarding.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345A0 != -1) {
          dispatch_once(&qword_1019345A0, &stru_10184B310);
        }
        LOWORD(v13[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345A8,  2LL,  "Received shake data, discarding.",  v13,  2);
        double v8 = (uint8_t *)v7;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLAccelerometer::onAccelerometerIohidEvent(void *, void *, void *, IOHIDEventRef)",  "%s\n",  v7);
        if (v8 != buf) {
          free(v8);
        }
      }
    }

    else
    {
      float FloatValue = IOHIDEventGetFloatValue(a4, 851968LL);
      *(float *)buf = FloatValue;
      float v10 = IOHIDEventGetFloatValue(a4, 851969LL);
      float v15 = v10;
      float v11 = IOHIDEventGetFloatValue(a4, 851970LL);
      float v16 = v11;
      unint64_t TimeStamp = IOHIDEventGetTimeStamp(a4);
      v13[0] = sub_101171C7C(TimeStamp);
      sub_1006E6898(a1, (uint64_t)buf, v13);
    }
  }

void sub_1006E6E28(id a1)
{
  qword_1019345A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accel");
}

void sub_1006E741C(uint64_t a1, void *a2)
{
  id v79 = a2;
  if (qword_1019345C0 != -1) {
    dispatch_once(&qword_1019345C0, &stru_10184B350);
  }
  double v4 = (os_log_s *)qword_1019345C8;
  if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEFAULT))
  {
    v85[0] = @"idle_time_both_in_ear_trcy";
    double v5 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v5) {
      unint64_t v6 = v5;
    }
    else {
      unint64_t v6 = @"<MISSING>";
    }
    v86[0] = v6;
    v85[1] = @"idle_time_trcy_l";
    double v7 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v7) {
      double v8 = v7;
    }
    else {
      double v8 = @"<MISSING>";
    }
    v86[1] = v8;
    v85[2] = @"idle_time_trcy_r";
    double v9 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v9) {
      float v10 = v9;
    }
    else {
      float v10 = @"<MISSING>";
    }
    v86[2] = v10;
    v85[3] = @"total_time_in_connect_session";
    float v11 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v11) {
      double v12 = v11;
    }
    else {
      double v12 = @"<MISSING>";
    }
    v86[3] = v12;
    v85[4] = @"serial_number_left";
    double v13 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = @"<MISSING>";
    }
    v86[4] = v14;
    v85[5] = @"serial_number_right";
    float v15 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v15) {
      float v16 = v15;
    }
    else {
      float v16 = @"<MISSING>";
    }
    v86[5] = v16;
    v85[6] = @"serial_number_system";
    char v17 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v17) {
      double v18 = v17;
    }
    else {
      double v18 = @"<MISSING>";
    }
    v86[6] = v18;
    v85[7] = @"case_charging_cycle";
    double v19 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v19) {
      double v20 = v19;
    }
    else {
      double v20 = @"<MISSING>";
    }
    v86[7] = v20;
    v85[8] = @"bud_daily_charging_soc_delta_r";
    double v21 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v21) {
      double v22 = v21;
    }
    else {
      double v22 = @"<MISSING>";
    }
    v86[8] = v22;
    v85[9] = @"bud_daily_charging_soc_delta_l";
    char v23 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v23) {
      int v24 = v23;
    }
    else {
      int v24 = @"<MISSING>";
    }
    v86[9] = v24;
    v85[10] = @"time_out_of_ear_both_incase";
    double v25 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v25) {
      double v26 = v25;
    }
    else {
      double v26 = @"<MISSING>";
    }
    v86[10] = v26;
    v85[11] = @"bud_mileage_l";
    float v27 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v27) {
      int v28 = v27;
    }
    else {
      int v28 = @"<MISSING>";
    }
    v86[11] = v28;
    v85[12] = @"bud_mileage_r";
    float v29 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v29) {
      double v30 = v29;
    }
    else {
      double v30 = @"<MISSING>";
    }
    v86[12] = v30;
    v85[13] = @"timestamp_received_on_companion";
    __int16 v31 = (const __CFString *)objc_msgSend(a2, "objectForKeyedSubscript:");
    if (v31) {
      double v32 = v31;
    }
    else {
      double v32 = @"<MISSING>";
    }
    v86[13] = v32;
    *(_DWORD *)buf = 138477827;
    v84 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v86,  v85,  14LL);
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[HeadphoneUsage] Received metrics. Sending to client, abridged: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_10184B350);
    }
    uint64_t v43 = qword_1019345C8;
    v81[0] = @"idle_time_both_in_ear_trcy";
    v44 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v44) {
      v45 = v44;
    }
    else {
      v45 = @"<MISSING>";
    }
    v82[0] = v45;
    v81[1] = @"idle_time_trcy_l";
    v46 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v46) {
      double v47 = v46;
    }
    else {
      double v47 = @"<MISSING>";
    }
    v82[1] = v47;
    v81[2] = @"idle_time_trcy_r";
    double v48 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v48) {
      double v49 = v48;
    }
    else {
      double v49 = @"<MISSING>";
    }
    v82[2] = v49;
    v81[3] = @"total_time_in_connect_session";
    int v50 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v50) {
      double v51 = v50;
    }
    else {
      double v51 = @"<MISSING>";
    }
    v82[3] = v51;
    v81[4] = @"serial_number_left";
    __int16 v52 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v52) {
      double v53 = v52;
    }
    else {
      double v53 = @"<MISSING>";
    }
    v82[4] = v53;
    v81[5] = @"serial_number_right";
    __int16 v54 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v54) {
      v55 = v54;
    }
    else {
      v55 = @"<MISSING>";
    }
    v82[5] = v55;
    v81[6] = @"serial_number_system";
    __int16 v56 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v56) {
      double v57 = v56;
    }
    else {
      double v57 = @"<MISSING>";
    }
    v82[6] = v57;
    v81[7] = @"case_charging_cycle";
    __int16 v58 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v58) {
      int v59 = v58;
    }
    else {
      int v59 = @"<MISSING>";
    }
    v82[7] = v59;
    v81[8] = @"bud_daily_charging_soc_delta_r";
    v60 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v60) {
      double v61 = v60;
    }
    else {
      double v61 = @"<MISSING>";
    }
    v82[8] = v61;
    v81[9] = @"bud_daily_charging_soc_delta_l";
    __int16 v62 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v62) {
      double v63 = v62;
    }
    else {
      double v63 = @"<MISSING>";
    }
    v82[9] = v63;
    v81[10] = @"time_out_of_ear_both_incase";
    __int16 v64 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v64) {
      v65 = v64;
    }
    else {
      v65 = @"<MISSING>";
    }
    v82[10] = v65;
    v81[11] = @"bud_mileage_l";
    __int16 v66 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v66) {
      double v67 = v66;
    }
    else {
      double v67 = @"<MISSING>";
    }
    v82[11] = v67;
    v81[12] = @"bud_mileage_r";
    __int16 v68 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v68) {
      int v69 = v68;
    }
    else {
      int v69 = @"<MISSING>";
    }
    v82[12] = v69;
    v81[13] = @"timestamp_received_on_companion";
    v70 = (const __CFString *)objc_msgSend(v79, "objectForKeyedSubscript:");
    if (v70) {
      v71 = v70;
    }
    else {
      v71 = @"<MISSING>";
    }
    v82[13] = v71;
    LODWORD(v80) = 138477827;
    *(void *)((char *)&v80 + 4) = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v82,  v81,  14LL);
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v43,  0LL,  "[HeadphoneUsage] Received metrics. Sending to client, abridged: %{private}@",  &v80,  12);
    v73 = (uint8_t *)v72;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAudioAccessoryStatsSubscription::onUsageMetricsEvent(NSDictionary *)",  "%s\n",  v72);
    if (v73 != buf) {
      free(v73);
    }
  }

  sub_1006E7E64("kCLConnectionMessageAudioAccessoryUsageMetricsUpdate", &v79, &v80);
  uint64_t v33 = *(void *)(a1 + 8);
  if (v33)
  {
    __int128 v78 = v80;
    if (*((void *)&v80 + 1))
    {
      double v34 = (unint64_t *)(*((void *)&v80 + 1) + 8LL);
      do
        unint64_t v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }

    CLConnection::sendMessage(v33, &v78);
    double v36 = (std::__shared_weak_count *)*((void *)&v78 + 1);
    if (*((void *)&v78 + 1))
    {
      uint64_t v37 = (unint64_t *)(*((void *)&v78 + 1) + 8LL);
      do
        unint64_t v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
  }

  else
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_10184B350);
    }
    v39 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "[HeadphoneUsage] #warning, connection invalid, unable to send usage message",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_10184B350);
      }
      __int16 v77 = 0;
      LODWORD(v76) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "[HeadphoneUsage] #warning, connection invalid, unable to send usage message",  &v77,  v76);
      v75 = (uint8_t *)v74;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAudioAccessoryStatsSubscription::onUsageMetricsEvent(NSDictionary *)",  "%s\n",  v74);
      if (v75 != buf) {
        free(v75);
      }
    }
  }

  __int16 v40 = (std::__shared_weak_count *)*((void *)&v80 + 1);
  if (*((void *)&v80 + 1))
  {
    double v41 = (unint64_t *)(*((void *)&v80 + 1) + 8LL);
    do
      unint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

void sub_1006E7BD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1006E7E38(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

void *sub_1006E7E64@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x70uLL);
  uint64_t result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1006E7EB0(_Unwind_Exception *a1)
{
}

void sub_1006E7EC4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)buf;
  uuid_unparse((const unsigned __int8 *)(a2 + 8), out);
  double v5 = (sqlite3_stmt *)sub_100019240(v4);
  if (!sub_1003BC1F0(v5, 1, out)) {
    goto LABEL_18;
  }
  unint64_t v6 = (sqlite3_stmt *)sub_100019240(v4);
  double v7 = (sqlite3_stmt *)sub_100019240(v4);
  double v8 = (sqlite3_stmt *)sub_100019240(v4);
  if (!sub_1003C28BC(v8, 4, *(_DWORD *)(a2 + 76))) {
    goto LABEL_18;
  }
  double v9 = (sqlite3_stmt *)sub_100019240(v4);
  float v10 = (sqlite3_stmt *)sub_100019240(v4);
  float v11 = (sqlite3_stmt *)sub_100019240(v4);
  if (!sub_1003C28BC(v11, 7, *(_DWORD *)(a2 + 56))) {
    goto LABEL_18;
  }
  double v12 = (sqlite3_stmt *)sub_100019240(v4);
  double v13 = (sqlite3_stmt *)sub_100019240(v4);
  uint64_t v14 = (sqlite3_stmt *)sub_100019240(v4);
  float v15 = (sqlite3_stmt *)sub_100019240(v4);
  if (sub_1003C28BC(v15, 11, *(_DWORD *)(a2 + 80))
    && (float v16 = (sqlite3_stmt *)sub_100019240(v4), sub_1003B7480(v16, 12, *(double *)(a2 + 88)))
    && (char v17 = (sqlite3_stmt *)sub_100019240(v4), sub_1003B7480(v17, 13, *(double *)(a2 + 96)))
    && (double v18 = (sqlite3_stmt *)sub_100019240(v4), sub_1003C28BC(v18, 14, *(unsigned __int8 *)(a2 + 104)))
    && (double v19 = (sqlite3_stmt *)sub_100019240(v4), sub_1003B7480(v19, 15, *(double *)(a2 + 48)))
    && (v20 = *(void *)(a1 + 80), double v21 = (sqlite3_stmt *)sub_100019240(v4), sub_1003BB2BC(v20, v21)))
  {
    ++*(_DWORD *)(a1 + 132);
  }

  else
  {
LABEL_18:
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B4C8);
    }
    double v22 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "Unable to insert VO2Max Input record.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184B4C8);
      }
      v25[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "Unable to insert VO2Max Input record.",  v25,  2);
      int v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLVO2MaxInputCache::insertRecordUL(const VO2MaxInput &, BOOL)",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }
  }

  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
}

void sub_1006E8230(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E825C(uint64_t a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_10184B380;
  *(void *)(a1 + 72) = off_10184B438;
  *(_BYTE *)(a1 + 416) = 0;
  sub_1006E9BC4(a1);
  return a1;
}

void sub_1006E82EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1006E8318(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  double v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *double v12 = &off_101826EF8;
  *(void *)a1 = off_10184B868;
  *(void *)(a1 + 72) = off_10184B910;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10184B868;
  *(void *)(a1 + 72) = off_10184B910;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 256) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 272) = 0xFFEFFFFFFFFFFFFFLL;
  *(_DWORD *)(a1 + 336) = 12000;
  *(void *)(a1 + 344) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 352));
  *(void *)(a1 + 352) = &off_101826EF8;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 256) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)__p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  float v15 = (int *)(a1 + 336);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 336));
  char v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184B950);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184B950);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    double v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, bo ol, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxInput, DataProtectio nPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 256) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_1006E86CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[43] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_10028EB1C(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_1006E8770()
{
}

void *sub_1006E8778(void *a1)
{
  a1[9] = off_10184B910;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10184B868;
  a1[43] = off_101826EC8;
  sub_1001B9C98(a1 + 44);
  sub_10028EB1C(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_1006E87F8(uint64_t a1)
{
  return sub_1006E8778((void *)(a1 - 72));
}

void sub_1006E8800(void *a1)
{
  uint64_t v1 = sub_1006E8778(a1);
  operator delete(v1);
}

void sub_1006E8814(uint64_t a1)
{
  uint64_t v1 = sub_1006E8778((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_1006E882C(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  *(void *)(a3 + _Block_object_dispose(va, 8) = *(void *)a3;
  uuid_unparse(a2, out);
  sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxInputHistory WHERE uuid = ?", buf);
  uint64_t v6 = *(void *)buf;
  uint64_t v12 = *(void *)buf;
  double v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003BC1F0(v7, 1, out))
  {
    else {
      uint64_t v8 = 109LL;
    }
    if (!v6) {
      return v8;
    }
LABEL_15:
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    return v8;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184B4C8);
  }
  double v9 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = out;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Unable to get entries for uuid %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B4C8);
    }
    int v13 = 136446210;
    uint64_t v14 = out;
    float v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "Unable to get entries for uuid %{public}s",  &v13,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLVO2MaxInputCache::getEntries(unsigned char *, std::vector<VO2MaxInput> &) const",  "%s\n",  v11);
    if (v11 != buf) {
      free(v11);
    }
  }

  uint64_t v8 = 109LL;
  if (v6) {
    goto LABEL_15;
  }
  return v8;
}

void sub_1006E8A84(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006E8AB0(uint64_t a1, uint64_t *a2, char **a3)
{
  a3[1] = *a3;
  sub_1003C0454(*(void *)(a1 + 80));
  *(void *)&__int128 v37 = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)&__int128 v38 = 0xFFEFFFFFFFFFFFFFLL;
  for (int i = sub_1006E9A08(a2, (uint64_t)&v35); !i; int i = sub_1006E9A08(a2, (uint64_t)&v35))
  {
    double v7 = a3[1];
    unint64_t v8 = (unint64_t)a3[2];
    if ((unint64_t)v7 >= v8)
    {
      uint64_t v15 = 0x6DB6DB6DB6DB6DB7LL * ((v7 - *a3) >> 4);
      unint64_t v16 = v15 + 1;
      unint64_t v17 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v8 - (void)*a3) >> 4);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0x124924924924924LL) {
        unint64_t v18 = 0x249249249249249LL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18) {
        unint64_t v19 = (char *)sub_10005057C((uint64_t)(a3 + 2), v18);
      }
      else {
        unint64_t v19 = 0LL;
      }
      uint64_t v20 = &v19[112 * v15];
      __int128 v21 = v35;
      __int128 v22 = v37;
      *((_OWORD *)v20 + 1) = v36;
      *((_OWORD *)v20 + 2) = v22;
      *(_OWORD *)uint64_t v20 = v21;
      __int128 v23 = v38;
      __int128 v24 = v39;
      __int128 v25 = v41;
      *((_OWORD *)v20 + 5) = v40;
      *((_OWORD *)v20 + 6) = v25;
      *((_OWORD *)v20 + 3) = v23;
      *((_OWORD *)v20 + 4) = v24;
      float v27 = *a3;
      double v26 = a3[1];
      uint64_t v28 = v20;
      if (v26 != *a3)
      {
        do
        {
          __int128 v29 = *((_OWORD *)v26 - 7);
          __int128 v30 = *((_OWORD *)v26 - 5);
          *((_OWORD *)v28 - 6) = *((_OWORD *)v26 - 6);
          *((_OWORD *)v28 - 5) = v30;
          *((_OWORD *)v28 - 7) = v29;
          __int128 v31 = *((_OWORD *)v26 - 4);
          __int128 v32 = *((_OWORD *)v26 - 3);
          __int128 v33 = *((_OWORD *)v26 - 2);
          *(_OWORD *)(v28 - 23) = *(_OWORD *)(v26 - 23);
          *((_OWORD *)v28 - 3) = v32;
          *((_OWORD *)v28 - 2) = v33;
          *((_OWORD *)v28 - 4) = v31;
          v28 -= 112;
          v26 -= 112;
        }

        while (v26 != v27);
        double v26 = *a3;
      }

      uint64_t v14 = v20 + 112;
      *a3 = v28;
      a3[1] = v20 + 112;
      a3[2] = &v19[112 * v18];
      if (v26) {
        operator delete(v26);
      }
    }

    else
    {
      __int128 v9 = v35;
      __int128 v10 = v37;
      *((_OWORD *)v7 + 1) = v36;
      *((_OWORD *)v7 + 2) = v10;
      *(_OWORD *)double v7 = v9;
      __int128 v11 = v38;
      __int128 v12 = v39;
      __int128 v13 = v41;
      *((_OWORD *)v7 + 5) = v40;
      *((_OWORD *)v7 + 6) = v13;
      *((_OWORD *)v7 + 3) = v11;
      *((_OWORD *)v7 + 4) = v12;
      uint64_t v14 = v7 + 112;
    }

    a3[1] = v14;
  }

  sub_1003C05BC(*(void *)(a1 + 80));
  return i != 2;
}

uint64_t sub_1006E8CF4(uint64_t a1, void *a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_1006E8D20(a1, a2, Current);
}

uint64_t sub_1006E8D20(uint64_t a1, void *a2, double a3)
{
  if (!*(_BYTE *)(a1 + 416)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(*(void *)(a1 + 80), "DELETE from VO2MaxInputHistory WHERE startTime < ?", buf);
  uint64_t v7 = *(void *)buf;
  unint64_t v8 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (!sub_1003B7480(v8, 1, a3 - *(double *)(a2[1] - 24LL))
    || (uint64_t v9 = *(void *)(a1 + 80), v10 = (sqlite3_stmt *)sub_100019240(v7), !sub_1003BB2BC(v9, v10)))
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    __int128 v11 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Unable to purge records.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      LOWORD(v32) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to purge records.",  &v32,  2);
      __int128 v30 = (char *)v29;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "long CLVO2MaxInputCache::aggregateRecordsInternal(const CLAggregationRules &, CFAbsoluteTime)",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }
  }

  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10184B4E8);
  }
  __int128 v12 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
  {
    CFAbsoluteTime v13 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134349056;
    *(double *)&uint8_t buf[4] = v13 - Current;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Completed delete of aged-out input records; duration: %{public}f",
      buf,
      0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    uint64_t v21 = qword_1019346E8;
    CFAbsoluteTime v22 = CFAbsoluteTimeGetCurrent();
    int v32 = 134349056;
    double v33 = v22 - Current;
    LODWORD(v31) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Completed delete of aged-out input records; duration: %{public}f",
      &v32,
      v31);
    __int128 v24 = (char *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLVO2MaxInputCache::aggregateRecordsInternal(const CLAggregationRules &, CFAbsoluteTime)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

  sub_1006E92BC(a1);
  double v14 = CFAbsoluteTimeGetCurrent();
  uint64_t v15 = *(void *)(a1 + 80);
  else {
    uint64_t v16 = *(void *)(v15 + 88);
  }
  sub_1003C1EC0(v15, v16);
  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10184B4E8);
  }
  unint64_t v17 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
  {
    CFAbsoluteTime v18 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134349056;
    *(double *)&uint8_t buf[4] = v18 - v14;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Completed reduce free pages after VO2MaxInputHistory deletes; duration: %{public}f",
      buf,
      0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    uint64_t v25 = qword_1019346E8;
    CFAbsoluteTime v26 = CFAbsoluteTimeGetCurrent();
    int v32 = 134349056;
    double v33 = v26 - v14;
    LODWORD(v31) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "Completed reduce free pages after VO2MaxInputHistory deletes; duration: %{public}f",
      &v32,
      v31);
    uint64_t v28 = (char *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLVO2MaxInputCache::aggregateRecordsInternal(const CLAggregationRules &, CFAbsoluteTime)",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

  uint64_t v19 = *(int *)(a1 + 132);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  return v19;
}

void sub_1006E9248(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E9290(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 - 72;
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_1006E8D20(v3, a2, Current);
}

void sub_1006E92BC(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10184B4E8);
  }
  uint64_t v3 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134349056;
    *(double *)&uint8_t buf[4] = CFAbsoluteTimeGetCurrent() - Current;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Completed fetch of input record count; duration: %{public}f",
      buf,
      0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    uint64_t v19 = qword_1019346E8;
    int v25 = 134349056;
    double v26 = CFAbsoluteTimeGetCurrent() - Current;
    uint64_t v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v19,  2LL,  "Completed fetch of input record count; duration: %{public}f",
                    &v25,
                    12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLVO2MaxInputCache::trimTableIfExceedingMaxRecordCount()", "%s\n", v20);
    if (v20 != buf) {
      free(v20);
    }
  }

  int v4 = *(_DWORD *)(a1 + 132);
  if (v4 >= 513282)
  {
    double v5 = CFAbsoluteTimeGetCurrent();
    sub_1003C0D54( *(void *)(a1 + 80),  "DELETE FROM VO2MaxInputHistory WHERE uuid IN (SELECT uuid FROM VO2MaxInputHistory ORDER BY startTime ASC LIMIT ?)",  buf);
    uint64_t v6 = *(void *)buf;
    uint64_t v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003C28BC(v7, 1, v4 - 513281)
      && (uint64_t v8 = *(void *)(a1 + 80), v9 = (sqlite3_stmt *)sub_100019240(v6), sub_1003BB2BC(v8, v9)))
    {
      double v10 = CFAbsoluteTimeGetCurrent();
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      __int128 v11 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
      {
        CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 134349056;
        *(double *)&uint8_t buf[4] = v12 - v10;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Completed fetch of input record count after delete after exceeding max record count; duration: %{public}f",
          buf,
          0xCu);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_22;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      uint64_t v13 = qword_1019346E8;
      CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent();
      int v25 = 134349056;
      double v26 = v14 - v10;
      LODWORD(v24) = 12;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  2LL,  "Completed fetch of input record count after delete after exceeding max record count; duration: %{public}f",
                      &v25,
                      v24);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxInputCache::trimTableIfExceedingMaxRecordCount()",  "%s\n",  v15);
    }

    else
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      uint64_t v16 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "Unable to purge VO2MaxInputHistory records from oldest sessions after exceeding max record count.",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_22;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      LOWORD(v25) = 0;
      LODWORD(v24) = 2;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to purge VO2MaxInputHistory records from oldest sessions after exceeding max record count.",  &v25,  v24);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLVO2MaxInputCache::trimTableIfExceedingMaxRecordCount()",  "%s\n",  v15);
    }

    if (v15 != buf) {
      free(v15);
    }
LABEL_22:
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    unint64_t v17 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
    {
      CFAbsoluteTime v18 = CFAbsoluteTimeGetCurrent();
      *(_DWORD *)buf = 134349056;
      *(double *)&uint8_t buf[4] = v18 - v5;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Completed delete of VO2MaxInputHistory records from oldest sessions after exceeding max record count; duration: %{public}f",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      uint64_t v21 = qword_1019346E8;
      CFAbsoluteTime v22 = CFAbsoluteTimeGetCurrent();
      int v25 = 134349056;
      double v26 = v22 - v5;
      LODWORD(v24) = 12;
      __int128 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Completed delete of VO2MaxInputHistory records from oldest sessions after exceeding max record cou nt; duration: %{public}f",
                      &v25,
                      v24);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxInputCache::trimTableIfExceedingMaxRecordCount()",  "%s\n",  v23);
      if (v23 != buf) {
        free(v23);
      }
    }

    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

void sub_1006E98F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E993C(uint64_t a1)
{
  uint64_t v3 = v8;
  int v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_1006E99DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E9A00(uint64_t a1)
{
  return sub_1006E993C(a1 - 72);
}

uint64_t sub_1006E9A08(uint64_t *a1, uint64_t a2)
{
  int v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int64(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  uint64_t v8 = sqlite3_column_text(v7, 1);
  uuid_parse((const char *)v8, (unsigned __int8 *)(a2 + 8));
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 32) = sqlite3_column_double(v9, 2);
  double v10 = (sqlite3_stmt *)sub_100019240(*a1);
  float v11 = sqlite3_column_double(v10, 3);
  *(float *)(a2 + 24) = v11;
  CFAbsoluteTime v12 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 76) = sqlite3_column_int(v12, 4);
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(*a1);
  float v14 = sqlite3_column_double(v13, 5);
  *(float *)(a2 + 40) = v14;
  uint64_t v15 = (sqlite3_stmt *)sub_100019240(*a1);
  float v16 = sqlite3_column_double(v15, 6);
  *(float *)(a2 + 44) = v16;
  unint64_t v17 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 56) = sqlite3_column_int(v17, 7);
  CFAbsoluteTime v18 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 64) = sqlite3_column_double(v18, 8);
  uint64_t v19 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_BYTE *)(a2 + 72) = sqlite3_column_int(v19, 9) != 0;
  uint64_t v20 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_BYTE *)(a2 + 73) = sqlite3_column_int(v20, 10) != 0;
  uint64_t v21 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)(a2 + 80) = sqlite3_column_int(v21, 11);
  CFAbsoluteTime v22 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 8_Block_object_dispose(va, 8) = sqlite3_column_double(v22, 12);
  __int128 v23 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 96) = sqlite3_column_double(v23, 13);
  uint64_t v24 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_BYTE *)(a2 + 104) = sqlite3_column_int(v24, 14) != 0;
  int v25 = (sqlite3_stmt *)sub_100019240(*a1);
  double v26 = sqlite3_column_double(v25, 15);
  uint64_t result = 0LL;
  *(double *)(a2 + 4_Block_object_dispose(va, 8) = v26;
  return result;
}

uint64_t sub_1006E9BC4(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result)
  {
    sub_1006E9C34(a1);
    sub_1003B59A0( *(void *)(a1 + 80),  "VO2MaxInputHistory",  (const char **)&off_10184B508,  (const std::string::value_type **)&off_101939E20,  0);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    *(_DWORD *)(a1 + 132) = result;
    *(_BYTE *)(a1 + 416) = 1;
  }

  return result;
}

void sub_1006E9C34(uint64_t a1)
{
  if (sub_1003B747C(*(void *)(a1 + 80), "VO2MaxInputHistory"))
  {
    uint64_t v2 = 0LL;
    int v3 = 0;
    uint64_t v7 = "workoutType";
    do
    {
      __int128 v41 = v7;
      int v42 = 5;
      __int16 v43 = 0;
      char v44 = 0;
      char v45 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "VO2MaxInputHistory", v7, (uint64_t)&v41) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)v37);
        uint64_t v8 = sub_10000CF44(&v38, (uint64_t)"ALTER TABLE ", 12LL);
        uint64_t v9 = sub_10000CF44(v8, (uint64_t)"VO2MaxInputHistory", 18LL);
        double v10 = sub_10000CF44(v9, (uint64_t)" ADD COLUMN ", 12LL);
        size_t v11 = strlen(v7);
        CFAbsoluteTime v12 = sub_10000CF44(v10, (uint64_t)v7, v11);
        uint64_t v13 = sub_10000CF44(v12, (uint64_t)" ", 1LL);
        float v14 = (const char *)sub_1003BCC40((int)(&off_10184B508)[v2 + 67]);
        size_t v15 = strlen(v14);
        float v16 = sub_10000CF44(v13, (uint64_t)v14, v15);
        sub_10000CF44(v16, (uint64_t)";", 1LL);
        uint64_t v17 = *(void *)(a1 + 80);
        std::stringbuf::str(&v34, &v39);
        if ((v34.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          CFAbsoluteTime v18 = &v34;
        }
        else {
          CFAbsoluteTime v18 = (std::stringbuf::string_type *)v34.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v17, (char *)v18, &v32);
        uint64_t v19 = v32.__r_.__value_.__r.__words[0];
        v32.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v20 = *(void *)(a1 + 80);
        uint64_t v21 = (sqlite3_stmt *)sub_100019240(v19);
        sub_1003BB2BC(v20, v21);
        sub_10000CE18((uint64_t)&v34);
        CFAbsoluteTime v22 = sub_10000CF44(&v34.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE ", 7LL);
        __int128 v23 = sub_10000CF44(v22, (uint64_t)"VO2MaxInputHistory", 18LL);
        uint64_t v24 = sub_10000CF44(v23, (uint64_t)" SET ", 5LL);
        size_t v25 = strlen(v7);
        double v26 = sub_10000CF44(v24, (uint64_t)v7, v25);
        sub_10000CF44(v26, (uint64_t)" = 0;", 5LL);
        uint64_t v27 = *(void *)(a1 + 80);
        std::stringbuf::str(&v32, &v35);
        if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v28 = &v32;
        }
        else {
          uint64_t v28 = (std::stringbuf::string_type *)v32.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v27, (char *)v28, &v33);
        uint64_t v29 = v33;
        uint64_t v33 = 0LL;
        uint64_t v30 = *(void *)(a1 + 80);
        uint64_t v31 = (sqlite3_stmt *)sub_100019240(v29);
        sub_1003BB2BC(v30, v31);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v29) {
          (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
        }
        v34.__r_.__value_.__r.__words[0] = v4;
        *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + *(void *)(v4 - 24)) = v6;
        v34.__r_.__value_.__l.__cap_ = v5;
        std::streambuf::~streambuf(&v35);
        std::ios::~ios(&v36);
        if (v19) {
          (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
        }
        v37[0] = v4;
        *(void *)((char *)v37 + *(void *)(v4 - 24)) = v6;
        std::string::size_type v38 = v5;
        std::streambuf::~streambuf(&v39);
        std::ios::~ios(&v40);
        int v3 = 1;
      }

      uint64_t v7 = (&off_10184B508)[v2 + 72];
      v2 += 6LL;
    }

    while (v2 != 30);
    if (((v3 | sub_1006EA190( a1,  "VO2MaxInputHistory",  (const char **)&off_10184B508,  (const std::string::value_type **)&off_101939E20)) & 1) != 0) {
      sub_1003BF200(*(void *)(a1 + 80), "VO2MaxInputHistory");
    }
    sub_1006EB648(a1);
  }

void sub_1006EA020( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a23);
  if (v61) {
    (*(void (**)(uint64_t))(*(void *)v61 + 8LL))(v61);
  }
  sub_1011F8850((uint64_t)&a61);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EA0B8(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxInputHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    std::string::size_type v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    *(_DWORD *)(a1 + 132) = 0;
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_1006EA150(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EA170(uint64_t a1)
{
  return sub_1006EA0B8(a1 - 72);
}

uint64_t sub_1006EA180()
{
  return 0LL;
}

uint64_t sub_1006EA188()
{
  return 2LL;
}

uint64_t sub_1006EA190(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184B950);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const cha r *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB: :ClassBDataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    size_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    float v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      float v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      float v16 = v143;
    }
    else {
      float v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    CFAbsoluteTime v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      uint64_t v21 = &__p;
    }
    else {
      uint64_t v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    CFAbsoluteTime v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    double v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      uint64_t v28 = v143;
    }
    else {
      uint64_t v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    uint64_t v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf::string_type v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::stringbuf::string_type v34 = &v139;
    }
    else {
      std::stringbuf::string_type v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    uint64_t v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v41 = &__p;
    }
    else {
      __int128 v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    int v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v47 = &__p;
      }
      else {
        double v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      double v48 = v143;
    }
    else {
      double v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    int v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v54 = buf;
    }
    else {
      __int16 v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      v60 = buf;
    }
    else {
      v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v69 = &__p;
    }
    else {
      int v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v75 = &__p;
      }
      else {
        v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    uint64_t v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      id v79 = &__p;
    }
    else {
      id v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    __int128 v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v85 = &__p;
      }
      else {
        v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      v86 = v143;
    }
    else {
      v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      v95 = &__p;
    }
    else {
      v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          v103 = &__p;
        }
        else {
          v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        v104 = v141;
      }
      else {
        v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v114 = buf;
      }
      else {
        v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v121 = &__p;
      }
      else {
        v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const c har *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxInput, DataProtectionPolicy = CLActivit yDB::ClassBDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const c har *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxInput, DataProtectionPolicy = CLActivit yDB::ClassBDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_1006EB328( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

void sub_1006EB648(uint64_t a1)
{
  sub_1003C0D54( *(void *)(a1 + 80),  "SELECT COUNT(name) FROM sqlite_master WHERE type='index' AND name = 'VO2MaxInputHistoryUuidIndex'",  buf);
  uint64_t v2 = *(void *)buf;
  uint64_t v3 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sqlite3_step(v3) == 100)
  {
    uint64_t v4 = (sqlite3_stmt *)sub_100019240(v2);
    if (sqlite3_column_int(v4, 0) >= 1)
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      std::string::size_type v5 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Index VO2MaxInputHistoryUuidIndex already exists; not re-creating",
          buf,
          2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10184B4E8);
        }
        v16[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "Index VO2MaxInputHistoryUuidIndex already exists; not re-creating",
          v16,
          2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLVO2MaxInputCache::createIndexOnUuidIfNecessary()", "%s\n", v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      goto LABEL_28;
    }
  }

  sub_1003C0D54(*(void *)(a1 + 80), "CREATE INDEX VO2MaxInputHistoryUuidIndex ON VO2MaxInputHistory (uuid)", buf);
  uint64_t v8 = *(void *)buf;
  uint64_t v9 = *(void *)(a1 + 80);
  __int128 v10 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003BB2BC(v9, v10))
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    size_t v11 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Index VO2MaxInputHistoryUuidIndex created successfully",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "Index VO2MaxInputHistoryUuidIndex created successfully",  v16,  2);
    uint64_t v13 = (uint8_t *)v12;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLVO2MaxInputCache::createIndexOnUuidIfNecessary()", "%s\n", v12);
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    float v14 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Unable to create index VO2MaxInputHistoryUuidIndex",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  16LL,  "Unable to create index VO2MaxInputHistoryUuidIndex",  v16,  2);
    uint64_t v13 = (uint8_t *)v15;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLVO2MaxInputCache::createIndexOnUuidIfNecessary()", "%s\n", v15);
  }

  if (v13 != buf) {
    free(v13);
  }
LABEL_26:
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
LABEL_28:
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
}

void sub_1006EBABC(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EBB10(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxInputHistory", &v6);
    uint64_t v5 = v6;
    uint64_t v7 = v6;
    uint64_t result = sub_1006E8AB0(a1, &v7, a2);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_1006EBB8C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EBBAC(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = __p;
  uint64_t v16 = 0LL;
  std::string::size_type v17 = __p;
  std::string __p = 0LL;
  size_t v15 = 0LL;
  BOOL v5 = sub_1006E8AB0(a1, (uint64_t *)&v17, (char **)&__p);
  uint64_t v6 = __p;
  if (!v5)
  {
    uint64_t v12 = 109LL;
    if (!__p) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  if (__p != v15)
  {
    __int128 v7 = *(_OWORD *)__p;
    __int128 v8 = *((_OWORD *)__p + 2);
    a2[1] = *((_OWORD *)__p + 1);
    a2[2] = v8;
    *a2 = v7;
    __int128 v9 = v6[3];
    __int128 v10 = v6[4];
    __int128 v11 = v6[5];
    *(_OWORD *)((char *)a2 + 89) = *(_OWORD *)((char *)v6 + 89);
    a2[4] = v10;
    a2[5] = v11;
    a2[3] = v9;
    uint64_t v12 = 100LL;
LABEL_7:
    size_t v15 = v6;
    operator delete(v6);
    goto LABEL_8;
  }

  uint64_t v12 = 100LL;
  if (__p) {
    goto LABEL_7;
  }
LABEL_8:
  if (v4) {
    (*(void (**)(void *))(*(void *)v4 + 8LL))(v4);
  }
  return v12;
}

void sub_1006EBC9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EBCCC(uint64_t *a1, int *a2, void **a3)
{
  if ((sub_100D8A92C(a1 + 9) & 1) != 0)
  {
    if (*(void *)a2)
    {
      sub_1003C0D54(a1[10], "SELECT * FROM VO2MaxInputHistory WHERE id >= ? ORDER BY id ASC", buf);
      uint64_t v6 = *(void *)buf;
      uint64_t v46 = *(void *)buf;
      *(void *)&__int128 v49 = 0xFFEFFFFFFFFFFFFFLL;
      *(void *)&__int128 v50 = 0xFFEFFFFFFFFFFFFFLL;
      __int128 v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
      if (sub_1003C28BC(v7, 1, *a2))
      {
        while (!sub_1006E9A08(&v46, (uint64_t)&v47))
        {
          __int128 v8 = a3[1];
          unint64_t v9 = (unint64_t)a3[2];
          if ((unint64_t)v8 >= v9)
          {
            uint64_t v16 = 0x6DB6DB6DB6DB6DB7LL * (((char *)v8 - (_BYTE *)*a3) >> 4);
            unint64_t v17 = v16 + 1;
            unint64_t v18 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v9 - (void)*a3) >> 4);
            if (2 * v18 > v17) {
              unint64_t v17 = 2 * v18;
            }
            if (v18 >= 0x124924924924924LL) {
              unint64_t v19 = 0x249249249249249LL;
            }
            else {
              unint64_t v19 = v17;
            }
            if (v19) {
              signed __int8 v20 = (char *)sub_10005057C((uint64_t)(a3 + 2), v19);
            }
            else {
              signed __int8 v20 = 0LL;
            }
            uint64_t v21 = &v20[112 * v16];
            __int128 v22 = v47;
            __int128 v23 = v49;
            *((_OWORD *)v21 + 1) = v48;
            *((_OWORD *)v21 + 2) = v23;
            *(_OWORD *)uint64_t v21 = v22;
            __int128 v24 = v50;
            __int128 v25 = v51;
            __int128 v26 = v53;
            *((_OWORD *)v21 + 5) = v52;
            *((_OWORD *)v21 + 6) = v26;
            *((_OWORD *)v21 + 3) = v24;
            *((_OWORD *)v21 + 4) = v25;
            uint64_t v28 = (char *)*a3;
            uint64_t v27 = (char *)a3[1];
            std::string::size_type v29 = v21;
            if (v27 != *a3)
            {
              do
              {
                __int128 v30 = *((_OWORD *)v27 - 7);
                __int128 v31 = *((_OWORD *)v27 - 5);
                *(v29 - 6) = *((_OWORD *)v27 - 6);
                *(v29 - 5) = v31;
                *(v29 - 7) = v30;
                __int128 v32 = *((_OWORD *)v27 - 4);
                __int128 v33 = *((_OWORD *)v27 - 3);
                __int128 v34 = *((_OWORD *)v27 - 2);
                *(_OWORD *)((char *)v29 - 23) = *(_OWORD *)(v27 - 23);
                *(v29 - 3) = v33;
                *(v29 - 2) = v34;
                *(v29 - 4) = v32;
                v29 -= 7;
                v27 -= 112;
              }

              while (v27 != v28);
              uint64_t v27 = (char *)*a3;
            }

            size_t v15 = v21 + 112;
            *a3 = v29;
            a3[1] = v21 + 112;
            a3[2] = &v20[112 * v19];
            if (v27) {
              operator delete(v27);
            }
          }

          else
          {
            __int128 v10 = v47;
            __int128 v11 = v49;
            v8[1] = v48;
            v8[2] = v11;
            *__int128 v8 = v10;
            __int128 v12 = v50;
            __int128 v13 = v51;
            __int128 v14 = v53;
            v8[5] = v52;
            v8[6] = v14;
            v8[3] = v12;
            _DWORD v8[4] = v13;
            size_t v15 = v8 + 7;
          }

          a3[1] = v15;
        }
      }

      else
      {
        if (qword_101934820 != -1) {
          dispatch_once(&qword_101934820, &stru_10184B838);
        }
        std::string::size_type v38 = (os_log_s *)qword_101934828;
        if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "Error querying records.", buf, 2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934820 != -1) {
            dispatch_once(&qword_101934820, &stru_10184B838);
          }
          __int16 v45 = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  17LL,  "Error querying records.",  &v45,  2);
          std::string::size_type v44 = (uint8_t *)v43;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLVO2MaxInputCache::queryVO2MaxInputSince(const VO2MaxInput, std::vector<VO2MaxInput> &) const",  "%s\n",  v43);
          if (v44 != buf) {
            free(v44);
          }
        }
      }

      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184B4C8);
      }
      __int128 v37 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "Non-existent query record, returning all records.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10184B4C8);
        }
        LOWORD(v47) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Non-existent query record, returning all records.",  &v47,  2);
        int v42 = (uint8_t *)v41;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLVO2MaxInputCache::queryVO2MaxInputSince(const VO2MaxInput, std::vector<VO2MaxInput> &) const",  "%s\n",  v41);
        if (v42 != buf) {
          free(v42);
        }
      }

      (*(void (**)(uint64_t *, void **))(*a1 + 40))(a1, a3);
    }

    return 100LL;
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B4C8);
    }
    std::string::size_type v35 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "History not accessible", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184B4C8);
      }
      LOWORD(v47) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "History not accessible",  &v47,  2);
      unsigned __int8 v40 = (uint8_t *)v39;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxInputCache::queryVO2MaxInputSince(const VO2MaxInput, std::vector<VO2MaxInput> &) const",  "%s\n",  v39);
      if (v40 != buf) {
        free(v40);
      }
    }

    return 109LL;
  }

void sub_1006EC2D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EC300(uint64_t a1, const unsigned __int8 *a2, char **a3)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a3[1] = *a3;
    uuid_unparse(a2, out);
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxInputHistory WHERE uuid = ?", buf);
    uint64_t v6 = *(void *)buf;
    uint64_t v38 = *(void *)buf;
    *(void *)&__int128 v42 = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v43 = 0xFFEFFFFFFFFFFFFFLL;
    __int128 v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003BC1F0(v7, 1, out))
    {
      while (!sub_1006E9A08(&v38, (uint64_t)buf))
      {
        __int128 v8 = a3[1];
        unint64_t v9 = (unint64_t)a3[2];
        if ((unint64_t)v8 >= v9)
        {
          uint64_t v16 = 0x6DB6DB6DB6DB6DB7LL * ((v8 - *a3) >> 4);
          unint64_t v17 = v16 + 1;
          unint64_t v18 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v9 - (void)*a3) >> 4);
          if (2 * v18 > v17) {
            unint64_t v17 = 2 * v18;
          }
          if (v18 >= 0x124924924924924LL) {
            unint64_t v19 = 0x249249249249249LL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19) {
            signed __int8 v20 = (char *)sub_10005057C((uint64_t)(a3 + 2), v19);
          }
          else {
            signed __int8 v20 = 0LL;
          }
          uint64_t v21 = &v20[112 * v16];
          __int128 v22 = *(_OWORD *)buf;
          __int128 v23 = v42;
          *((_OWORD *)v21 + 1) = v41;
          *((_OWORD *)v21 + 2) = v23;
          *(_OWORD *)uint64_t v21 = v22;
          __int128 v24 = v43;
          __int128 v25 = v44;
          __int128 v26 = v46;
          *((_OWORD *)v21 + 5) = v45;
          *((_OWORD *)v21 + 6) = v26;
          *((_OWORD *)v21 + 3) = v24;
          *((_OWORD *)v21 + 4) = v25;
          uint64_t v28 = *a3;
          uint64_t v27 = a3[1];
          std::string::size_type v29 = v21;
          if (v27 != *a3)
          {
            do
            {
              __int128 v30 = *((_OWORD *)v27 - 7);
              __int128 v31 = *((_OWORD *)v27 - 5);
              *((_OWORD *)v29 - 6) = *((_OWORD *)v27 - 6);
              *((_OWORD *)v29 - 5) = v31;
              *((_OWORD *)v29 - 7) = v30;
              __int128 v32 = *((_OWORD *)v27 - 4);
              __int128 v33 = *((_OWORD *)v27 - 3);
              __int128 v34 = *((_OWORD *)v27 - 2);
              *(_OWORD *)(v29 - 23) = *(_OWORD *)(v27 - 23);
              *((_OWORD *)v29 - 3) = v33;
              *((_OWORD *)v29 - 2) = v34;
              *((_OWORD *)v29 - 4) = v32;
              v29 -= 112;
              v27 -= 112;
            }

            while (v27 != v28);
            uint64_t v27 = *a3;
          }

          size_t v15 = v21 + 112;
          *a3 = v29;
          a3[1] = v21 + 112;
          a3[2] = &v20[112 * v19];
          if (v27) {
            operator delete(v27);
          }
        }

        else
        {
          __int128 v10 = *(_OWORD *)buf;
          __int128 v11 = v42;
          *((_OWORD *)v8 + 1) = v41;
          *((_OWORD *)v8 + 2) = v11;
          *(_OWORD *)__int128 v8 = v10;
          __int128 v12 = v43;
          __int128 v13 = v44;
          __int128 v14 = v46;
          *((_OWORD *)v8 + 5) = v45;
          *((_OWORD *)v8 + 6) = v14;
          *((_OWORD *)v8 + 3) = v12;
          *((_OWORD *)v8 + 4) = v13;
          size_t v15 = v8 + 112;
        }

        a3[1] = v15;
      }
    }

    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    return 100LL;
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184B4C8);
    }
    std::string::size_type v35 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "VO2MaxInputHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184B4C8);
      }
      *(_WORD *)uuid_string_t out = 0;
      __int128 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "VO2MaxInputHistory, DB not accessible",  out,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxInputCache::queryBySessionId(unsigned char *, std::vector<VO2MaxInput> &) const",  "%s\n",  v37);
    }

    return 109LL;
  }

void sub_1006EC69C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1006EC6C8(uint64_t a1, const unsigned __int8 *a2)
{
  sub_1003C0D54(*(void *)(a1 + 80), "SELECT COUNT(*) from VO2MaxInputHistory WHERE uuid = ?", &v10);
  uint64_t v4 = v10;
  BOOL v5 = (sqlite3_stmt *)sub_100019240(v10);
  if (!sub_1003BC1F0(v5, 1, out) || (uint64_t v6 = (sqlite3_stmt *)sub_100019240(v4), sqlite3_step(v6) != 100))
  {
    char v8 = 1;
    if (!v4) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  __int128 v7 = (sqlite3_stmt *)sub_100019240(v4);
  a2 = (const unsigned __int8 *)sqlite3_column_int(v7, 0);
  char v8 = 0;
  if (v4) {
LABEL_7:
  }
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
LABEL_8:
  if ((v8 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  return (uint64_t)a2;
}

void sub_1006EC7C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EC7F0(uint64_t a1, const unsigned __int8 *a2, void *a3, void *a4)
{
  if (sub_1003C1048(*(void *)(a1 + 80)))
  {
    sub_1003C0454(*(void *)(a1 + 80));
    uuid_unparse(a2, out);
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxInputHistory WHERE uuid = ?", buf);
    uint64_t v8 = *(void *)buf;
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO VO2MaxInputHistory (uuid, startTime, mets, metSource, hr, hrConfidence, gradeType, grade, gps, strideC al, workoutType, cadence, pace, stroller, hrTime) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",  buf);
    uint64_t v9 = *(void *)buf;
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO VO2MaxSessionAttributesHistory (startTime, sessionId, meanMaxMets, prior, hardwareType, betaBlockerUse , algorithmVersion, outputCloudKitSystemFields, inputCloudKitSystemFields) VALUES (0, ?, -1, -1, 0, 0, 0, NULL, ?)",  buf);
    uint64_t v10 = *(void *)buf;
    sub_1003C0D54( *(void *)(a1 + 80),  "UPDATE VO2MaxSessionAttributesHistory SET inputCloudKitSystemFields = ? WHERE sessionId = ?",  buf);
    uint64_t v11 = *(void *)buf;
    __int128 v12 = (sqlite3_stmt *)sub_100019240(v8);
    if (sub_1003BC1F0(v12, 1, out)
      && (uint64_t v13 = *(void *)(a1 + 80), v14 = (sqlite3_stmt *)sub_100019240(v8), sub_1003BB2BC(v13, v14)))
    {
      uint64_t v15 = a4[1];
      if (*a4 == v15)
      {
LABEL_23:
        std::string::size_type v35 = (sqlite3_stmt *)sub_100019240(v11);
        if (sub_1003C2F58(v35, 1, a3)
          && (uint64_t v36 = (sqlite3_stmt *)sub_100019240(v11), sub_1003BC1F0(v36, 2, out))
          && (uint64_t v37 = *(void *)(a1 + 80), v38 = (sqlite3_stmt *)sub_100019240(v11), sub_1003BB2BC(v37, v38)))
        {
          if (sub_1003C10E4(*(void *)(a1 + 80)) > 0
            || (__int128 v46 = (sqlite3_stmt *)sub_100019240(v10), sub_1003BC1F0(v46, 1, out))
            && (__int128 v47 = (sqlite3_stmt *)sub_100019240(v10), sub_1003C2F58(v47, 2, a3))
            && (uint64_t v48 = *(void *)(a1 + 80), v49 = (sqlite3_stmt *)sub_100019240(v10), sub_1003BB2BC(v48, v49)))
          {
            sub_1003C05BC(*(void *)(a1 + 80));
            sub_1006E92BC(a1);
            uint64_t v39 = 1LL;
LABEL_40:
            if (v11) {
              (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
            }
            if (v10) {
              (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
            }
            if (v9) {
              (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
            }
            if (v8) {
              (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
            }
            return v39;
          }

          if (qword_1019346E0 != -1) {
            dispatch_once(&qword_1019346E0, &stru_10184B4E8);
          }
          __int128 v50 = (os_log_s *)qword_1019346E8;
          if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_FAULT,  "Unable to insert synced VO2MaxSessionAttributes record",  buf,  2u);
          }

          if (!sub_1002921D0(115, 0))
          {
LABEL_39:
            sub_1003C0E18(*(void *)(a1 + 80));
            uint64_t v39 = 0LL;
            goto LABEL_40;
          }

          bzero(buf, 0x65CuLL);
          if (qword_1019346E0 != -1) {
            dispatch_once(&qword_1019346E0, &stru_10184B4E8);
          }
          v52[0] = 0;
          __int128 v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to insert synced VO2MaxSessionAttributes record",  v52,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)",  "%s\n",  v44);
        }

        else
        {
          if (qword_1019346E0 != -1) {
            dispatch_once(&qword_1019346E0, &stru_10184B4E8);
          }
          __int128 v45 = (os_log_s *)qword_1019346E8;
          if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_FAULT,  "Unable to update synced VO2MaxSessionAttributes record",  buf,  2u);
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_39;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1019346E0 != -1) {
            dispatch_once(&qword_1019346E0, &stru_10184B4E8);
          }
          v52[0] = 0;
          __int128 v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to update synced VO2MaxSessionAttributes record",  v52,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)",  "%s\n",  v44);
        }
      }

      else
      {
        uint64_t v16 = *a4 + 56LL;
        while (1)
        {
          unint64_t v17 = (sqlite3_stmt *)sub_100019240(v9);
          if (!sub_1003BC1F0(v17, 1, out)) {
            break;
          }
          unint64_t v18 = (sqlite3_stmt *)sub_100019240(v9);
          unint64_t v19 = (sqlite3_stmt *)sub_100019240(v9);
          signed __int8 v20 = (sqlite3_stmt *)sub_100019240(v9);
          if (!sub_1003C28BC(v20, 4, *(_DWORD *)(v16 + 20))) {
            break;
          }
          uint64_t v21 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v22 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v23 = (sqlite3_stmt *)sub_100019240(v9);
          if (!sub_1003C28BC(v23, 7, *(_DWORD *)v16)) {
            break;
          }
          __int128 v24 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v25 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v26 = (sqlite3_stmt *)sub_100019240(v9);
          uint64_t v27 = (sqlite3_stmt *)sub_100019240(v9);
          if (!sub_1003C28BC(v27, 11, *(_DWORD *)(v16 + 24))) {
            break;
          }
          uint64_t v28 = (sqlite3_stmt *)sub_100019240(v9);
          std::string::size_type v29 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v30 = (sqlite3_stmt *)sub_100019240(v9);
          __int128 v31 = (sqlite3_stmt *)sub_100019240(v9);
          uint64_t v32 = *(void *)(a1 + 80);
          __int128 v33 = (sqlite3_stmt *)sub_100019240(v9);
          if (!sub_1003BB2BC(v32, v33)) {
            break;
          }
          uint64_t v34 = v16 + 56;
          v16 += 112LL;
          if (v34 == v15) {
            goto LABEL_23;
          }
        }

        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10184B4E8);
        }
        __int128 v43 = (os_log_s *)qword_1019346E8;
        if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Unable to save synced VO2MaxSummaryInput records",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          goto LABEL_39;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10184B4E8);
        }
        v52[0] = 0;
        __int128 v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to save synced VO2MaxSummaryInput records",  v52,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)",  "%s\n",  v44);
      }
    }

    else
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      __int128 v41 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "Unable to delete out-of-date VO2MaxInputHistory records",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_39;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10184B4E8);
      }
      v52[0] = 0;
      __int128 v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  17LL,  "Unable to delete out-of-date VO2MaxInputHistory records",  v52,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)",  "%s\n",  v44);
    }

    goto LABEL_39;
  }

  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10184B4E8);
  }
  unsigned __int8 v40 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEBUG,  "Unable to save fetched input data from CloudKit. Device is locked and we are unable to open the database",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10184B4E8);
    }
    *(_WORD *)uuid_string_t out = 0;
    __int128 v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "Unable to save fetched input data from CloudKit. Device is locked and we are unable to open the database",  out,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)",  "%s\n",  v51);
  }

  return 0LL;
}

void sub_1006ED1BC(_Unwind_Exception *exception_object)
{
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    if (!v3)
    {
LABEL_3:
      if (!v2) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }

  else if (!v3)
  {
    goto LABEL_3;
  }

  (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  if (!v2)
  {
LABEL_4:
    if (!v1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

void *sub_1006ED26C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "VO2MaxInputHistory");
}

void *sub_1006ED27C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "VO2MaxInputHistory");
}

uint64_t sub_1006ED28C(void *a1, void **a2, double a3, double a4)
{
  uint64_t v8 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v51);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
    if (HIBYTE(v52)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_101244890(v8);
    __break(1u);
  }

  __int128 v46 = v51[1];
  operator delete(v51[0]);
  if (!v46) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v51);
  uint64_t v9 = sub_10000CF44(&v52, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(v55, a1);
  if (v55[23] >= 0) {
    uint64_t v10 = v55;
  }
  else {
    uint64_t v10 = *(_BYTE **)v55;
  }
  if (v55[23] >= 0) {
    uint64_t v11 = v55[23];
  }
  else {
    uint64_t v11 = *(void *)&v55[8];
  }
  __int128 v12 = sub_10000CF44(v9, (uint64_t)v10, v11);
  sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((v55[23] & 0x80000000) != 0) {
    operator delete(*(void **)v55);
  }
  uint64_t v13 = a1[10];
  std::stringbuf::str((std::stringbuf::string_type *)v55, &v53);
  if (v55[23] >= 0) {
    __int128 v14 = v55;
  }
  else {
    __int128 v14 = *(char **)v55;
  }
  sub_1003C0D54(v13, v14, &v49);
  uint64_t v15 = v49;
  uint64_t v49 = 0LL;
  uint64_t v50 = v15;
  if ((v55[23] & 0x80000000) != 0) {
    operator delete(*(void **)v55);
  }
  uint64_t v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (sub_1003B7480(v16, 1, a3) && (unint64_t v17 = (sqlite3_stmt *)sub_100019240(v15), sub_1003B7480(v17, 2, a4)))
  {
    *(void *)&__int128 v56 = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v57 = 0xFFEFFFFFFFFFFFFFLL;
    while (1)
    {
      uint64_t v18 = sub_1001BA11C((uint64_t)a1, &v50, (uint64_t)v55);
      if ((_DWORD)v18) {
        break;
      }
      unint64_t v19 = a2[1];
      unint64_t v20 = (unint64_t)a2[2];
      if ((unint64_t)v19 >= v20)
      {
        uint64_t v27 = 0x6DB6DB6DB6DB6DB7LL * (((char *)v19 - (_BYTE *)*a2) >> 4);
        unint64_t v28 = v27 + 1;
        unint64_t v29 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v20 - (void)*a2) >> 4);
        if (2 * v29 > v28) {
          unint64_t v28 = 2 * v29;
        }
        if (v29 >= 0x124924924924924LL) {
          unint64_t v30 = 0x249249249249249LL;
        }
        else {
          unint64_t v30 = v28;
        }
        if (v30) {
          __int128 v31 = (char *)sub_10005057C((uint64_t)(a2 + 2), v30);
        }
        else {
          __int128 v31 = 0LL;
        }
        uint64_t v32 = &v31[112 * v27];
        __int128 v33 = *(_OWORD *)v55;
        __int128 v34 = v56;
        *((_OWORD *)v32 + 1) = *(_OWORD *)&v55[16];
        *((_OWORD *)v32 + 2) = v34;
        *(_OWORD *)uint64_t v32 = v33;
        __int128 v35 = v57;
        __int128 v36 = v58;
        __int128 v37 = v60;
        *((_OWORD *)v32 + 5) = v59;
        *((_OWORD *)v32 + 6) = v37;
        *((_OWORD *)v32 + 3) = v35;
        *((_OWORD *)v32 + 4) = v36;
        uint64_t v39 = (char *)*a2;
        uint64_t v38 = (char *)a2[1];
        unsigned __int8 v40 = v32;
        if (v38 != *a2)
        {
          do
          {
            __int128 v41 = *((_OWORD *)v38 - 7);
            __int128 v42 = *((_OWORD *)v38 - 5);
            *(v40 - 6) = *((_OWORD *)v38 - 6);
            *(v40 - 5) = v42;
            *(v40 - 7) = v41;
            __int128 v43 = *((_OWORD *)v38 - 4);
            __int128 v44 = *((_OWORD *)v38 - 3);
            __int128 v45 = *((_OWORD *)v38 - 2);
            *(_OWORD *)((char *)v40 - 23) = *(_OWORD *)(v38 - 23);
            *(v40 - 3) = v44;
            *(v40 - 2) = v45;
            *(v40 - 4) = v43;
            v40 -= 7;
            v38 -= 112;
          }

          while (v38 != v39);
          uint64_t v38 = (char *)*a2;
        }

        __int128 v26 = v32 + 112;
        *a2 = v40;
        a2[1] = v32 + 112;
        a2[2] = &v31[112 * v30];
        if (v38) {
          operator delete(v38);
        }
      }

      else
      {
        __int128 v21 = *(_OWORD *)v55;
        __int128 v22 = v56;
        v19[1] = *(_OWORD *)&v55[16];
        v19[2] = v22;
        *unint64_t v19 = v21;
        __int128 v23 = v57;
        __int128 v24 = v58;
        __int128 v25 = v60;
        v19[5] = v59;
        v19[6] = v25;
        v19[3] = v23;
        v19[4] = v24;
        __int128 v26 = v19 + 7;
      }

      a2[1] = v26;
    }

    uint64_t v15 = v50;
  }

  else
  {
    uint64_t v18 = 2LL;
  }

  uint64_t v50 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  *(void **)((char *)v51
  uint64_t v52 = v47;
  std::streambuf::~streambuf(&v53);
  std::ios::~ios(&v54);
  return v18;
}

void sub_1006ED65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_1006ED6CC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184B950);
    }
    BOOL v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      __int128 v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)buf = 134349056;
        *(void *)__int128 v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessibl e() [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184B950);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x24));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 112 * (v13 % 0x24);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x24)) + 112 * (v22 % 0x24);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10184B970);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10184B970);
        }
        LOWORD(v41) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        uint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessibl e() [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 112LL;
      if (v17 - *v16 == 4032)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184B950);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      unint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
    }

    unint64_t v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v21 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      __int128 v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  unint64_t v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      unint64_t v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 18LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 36LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v32;
LABEL_61:
  __int128 v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_1006EDE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_1006EDE34(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v3 = *a3;
  __int128 v4 = a3[2];
  *(_OWORD *)(a2 + 16) = a3[1];
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)a2 = v3;
  __n128 result = (__n128)a3[3];
  __int128 v6 = a3[4];
  __int128 v7 = a3[5];
  *(_OWORD *)(a2 + 89) = *(__int128 *)((char *)a3 + 89);
  *(_OWORD *)(a2 + 64) = v6;
  *(_OWORD *)(a2 + 80) = v7;
  *(__n128 *)(a2 + 4_Block_object_dispose(va, 8) = result;
  return result;
}

id *sub_1006EDE60(uint64_t a1, __int128 *a2, char a3)
{
  v36[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v36[1] = 0LL;
  if (*(double *)(a1 + 256) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v36);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  double v46 = -1.79769313e308;
  unint64_t v47 = 0xFFEFFFFFFFFFFFFFLL;
  int v6 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)a1 + 104LL))(a1, v45);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        LOWORD(v37) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v37,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *((double *)a2 + 4);
    double v8 = v46;
    double v9 = v7 - v46;
    if (v7 - v46 < 0.0) {
      double v9 = -(v7 - v46);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184B950);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 4);
        *(_DWORD *)buf = 134349312;
        double v42 = v46;
        __int16 v43 = 2050;
        uint64_t v44 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        uint64_t v27 = *((void *)a2 + 4);
        int v37 = 134349312;
        double v38 = v46;
        __int16 v39 = 2050;
        uint64_t v40 = v27;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v37,  22);
        uint64_t v29 = (uint8_t *)v28;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *((double *)a2 + 4);
      double v8 = v46;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 4);
          *(_DWORD *)buf = 134217984;
          double v42 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184B950);
          }
          double v30 = *((double *)a2 + 4);
          int v37 = 134217984;
          double v38 = v30;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v37));
          uint64_t v32 = (uint8_t *)v31;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRe cordUL(const T &, BOOL) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v31);
          if (v32 != buf) {
            free(v32);
          }
        }

        (*(void (**)(uint64_t, __int128 *))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v35 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10184B950);
        double v18 = v35;
      }

      double v19 = v17 - v18;
      unint64_t v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        double v42 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184B950);
        }
        int v37 = 134217984;
        double v38 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v37));
        __int128 v34 = (uint8_t *)v33;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxInput, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v33);
        if (v34 != buf) {
          free(v34);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, _BYTE *, uint64_t, __int128 *))(*(void *)a1 + 144LL))(a1, v45, a1 + 224, a2);
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_1006EE5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1006EE5F4(uint64_t a1)
{
  return sub_1006ED6CC(a1 - 72);
}

void sub_1006EE5FC(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_1006EE628(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

void sub_1006EE654(id a1)
{
  qword_101934828 = (uint64_t)os_log_create("com.apple.locationd.Position", "Spring");
}

uint64_t sub_1006EE680(uint64_t *a1, char **a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v45);
  if ((SHIBYTE(v46) & 0x80000000) == 0)
  {
    if (HIBYTE(v46)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_1012449FC(v4);
    __break(1u);
  }

  double v42 = v45[1];
  operator delete(v45[0]);
  if (!v42) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v45);
    int v6 = sub_10000CF44(&v46, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 64))(v49, a1);
    if (v49[23] >= 0) {
      double v7 = v49;
    }
    else {
      double v7 = *(_BYTE **)v49;
    }
    if (v49[23] >= 0) {
      uint64_t v8 = v49[23];
    }
    else {
      uint64_t v8 = *(void *)&v49[8];
    }
    double v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if ((v49[23] & 0x80000000) != 0) {
      operator delete(*(void **)v49);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)v49, &v47);
    if (v49[23] >= 0) {
      uint64_t v11 = v49;
    }
    else {
      uint64_t v11 = *(char **)v49;
    }
    sub_1003C0D54(v10, v11, &v43);
    uint64_t v12 = v43;
    uint64_t v43 = 0LL;
    uint64_t v44 = v12;
    if ((v49[23] & 0x80000000) != 0) {
      operator delete(*(void **)v49);
    }
    sub_1003C0454(a1[10]);
    *(void *)&__int128 v50 = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v51 = 0xFFEFFFFFFFFFFFFFLL;
    while (!sub_1001BA11C((uint64_t)a1, &v44, (uint64_t)v49))
    {
      double v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v21 = 0x6DB6DB6DB6DB6DB7LL * ((v13 - *a2) >> 4);
        unint64_t v22 = v21 + 1;
        unint64_t v23 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v14 - (void)*a2) >> 4);
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x124924924924924LL) {
          unint64_t v24 = 0x249249249249249LL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24) {
          __int128 v25 = (char *)sub_10005057C((uint64_t)(a2 + 2), v24);
        }
        else {
          __int128 v25 = 0LL;
        }
        __int128 v26 = &v25[112 * v21];
        __int128 v27 = *(_OWORD *)v49;
        __int128 v28 = v50;
        *((_OWORD *)v26 + 1) = *(_OWORD *)&v49[16];
        *((_OWORD *)v26 + 2) = v28;
        *(_OWORD *)__int128 v26 = v27;
        __int128 v29 = v51;
        __int128 v30 = v52;
        __int128 v31 = v54;
        *((_OWORD *)v26 + 5) = v53;
        *((_OWORD *)v26 + 6) = v31;
        *((_OWORD *)v26 + 3) = v29;
        *((_OWORD *)v26 + 4) = v30;
        __int128 v33 = *a2;
        uint64_t v32 = a2[1];
        __int128 v34 = v26;
        if (v32 != *a2)
        {
          do
          {
            __int128 v35 = *((_OWORD *)v32 - 7);
            __int128 v36 = *((_OWORD *)v32 - 5);
            *((_OWORD *)v34 - 6) = *((_OWORD *)v32 - 6);
            *((_OWORD *)v34 - 5) = v36;
            *((_OWORD *)v34 - 7) = v35;
            __int128 v37 = *((_OWORD *)v32 - 4);
            __int128 v38 = *((_OWORD *)v32 - 3);
            __int128 v39 = *((_OWORD *)v32 - 2);
            *(_OWORD *)(v34 - 23) = *(_OWORD *)(v32 - 23);
            *((_OWORD *)v34 - 3) = v38;
            *((_OWORD *)v34 - 2) = v39;
            *((_OWORD *)v34 - 4) = v37;
            v34 -= 112;
            v32 -= 112;
          }

          while (v32 != v33);
          uint64_t v32 = *a2;
        }

        unint64_t v20 = v26 + 112;
        *a2 = v34;
        a2[1] = v26 + 112;
        a2[2] = &v25[112 * v24];
        if (v32) {
          operator delete(v32);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)v49;
        __int128 v16 = v50;
        *((_OWORD *)v13 + 1) = *(_OWORD *)&v49[16];
        *((_OWORD *)v13 + 2) = v16;
        *(_OWORD *)double v13 = v15;
        __int128 v17 = v51;
        __int128 v18 = v52;
        __int128 v19 = v54;
        *((_OWORD *)v13 + 5) = v53;
        *((_OWORD *)v13 + 6) = v19;
        *((_OWORD *)v13 + 3) = v17;
        *((_OWORD *)v13 + 4) = v18;
        unint64_t v20 = v13 + 112;
      }

      a2[1] = v20;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v40 = v44;
    uint64_t v44 = 0LL;
    if (v40) {
      (*(void (**)(uint64_t))(*(void *)v40 + 8LL))(v40);
    }
    *(void **)((char *)v45
    uint64_t v46 = v41;
    std::streambuf::~streambuf(&v47);
    return std::ios::~ios(&v48);
  }

  return result;
}

void sub_1006EEA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1011F8850((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EEA78(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_101244B68(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  __int128 v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 32)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_1006EECD8(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101244CD4(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_1006EEF10(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101244E40(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  BOOL v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_1006EF138(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_1006EF164(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_1006EF190(uint64_t a1, int a2)
{
  uint64_t v3 = sub_1003070C0(a1, a2);
  *(void *)uint64_t v3 = off_10184B9A0;
  *(void *)(v3 + 200) = off_10184BA08;
  sub_100A3ECDC(v3 + 200, *(unsigned __int8 *)(v3 + 8), 0);
  *(void *)a1 = off_10184B9A0;
  *(void *)(a1 + 200) = off_10184BA08;
  *(_BYTE *)(a1 + 274) = 0;
  *(void *)(a1 + 280) = 0LL;
  sub_100808A84(a1 + 288);
  sub_100B0CE58(a1 + 1112, a1 + 288);
  return a1;
}

void sub_1006EF20C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  *uint64_t v4 = &off_101858AA8;
  sub_100A3ED0C(v2);
  sub_100307A9C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EF250(void *a1)
{
  *a1 = off_10184B9A0;
  a1[25] = off_10184BA08;
  uint64_t v2 = a1 + 25;
  sub_100A3EFD4((uint64_t)(a1 + 25));
  sub_100A3ED50(v2);
  sub_100A3ED9C(v2);
  a1[36] = &off_101858AA8;
  sub_100A3ED0C(v2);
  return sub_100307A9C((uint64_t)a1);
}

uint64_t sub_1006EF2C0(uint64_t a1)
{
  return sub_1006EF250((void *)(a1 - 200));
}

void sub_1006EF2C8(void *a1)
{
  uint64_t v1 = (void *)sub_1006EF250(a1);
  operator delete(v1);
}

void sub_1006EF2DC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1006EF250((void *)(a1 - 200));
  operator delete(v1);
}

uint64_t sub_1006EF2F4(uint64_t a1)
{
  uint64_t v3 = 2LL;
  uint64_t result = sub_10030867C(a1, &v3);
  *(_BYTE *)(a1 + 274) = 0;
  *(void *)(a1 + 280) = 0LL;
  return result;
}

void *sub_1006EF368(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 200);
  sub_100A3EFD4(a1 + 200);
  sub_100A3ED50(v1);
  return sub_100A3ED9C(v1);
}

void sub_1006EF398(uint64_t a1, int a2)
{
  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_10184BA70);
  }
  uint64_t v4 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    int v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Application state changed, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10184BA70);
    }
    v7[0] = 67109120;
    v7[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Application state changed, %d",  v7);
    int v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionService6AxisAP::applicationStateChanged(BOOL)",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  *(_BYTE *)(a1 + 274) = a2 ^ 1;
}

void sub_1006EF54C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (unint64_t)(*(double *)a2 * 1000000.0);
  float v5 = *(float *)(a2 + 16) * 0.017453;
  float32x2_t v28 = vmul_f32(*(float32x2_t *)(a2 + 8), (float32x2_t)vdup_n_s32(0x3C8EFA35u));
  float v29 = v5;
  uint64_t v6 = a1 + 1112;
  sub_100B0DC48(a1 + 1112, &v28, v4);
  sub_1008090E8(a1 + 288, &v28, v4);
  *(_OWORD *)uint64_t v23 = 0uLL;
  double v22 = -1.0;
  sub_100833700((float32x4_t *)v23, v7);
  memset(&v23[4], 0, 36);
  *(_OWORD *)&v23[13] = xmmword_1012E2F40;
  uint64_t v24 = 0x1FF00000000LL;
  int v25 = 0;
  char v26 = 0;
  uint64_t v27 = 0LL;
  double v22 = *(double *)a2;
  if (v23 != (_DWORD *)(a1 + 1124)) {
    *(_OWORD *)uint64_t v23 = *(_OWORD *)(a1 + 1124);
  }
  sub_100B0D900(v6);
  v23[4] = v8;
  v23[5] = v9;
  v23[6] = v10;
  uint64_t v11 = *(void *)(a1 + 1168);
  *(void *)&v23[7] = *(void *)(v11 + 432);
  v23[9] = *(_DWORD *)(v11 + 440);
  WORD2(v24) = 511;
  *(_OWORD *)&v23[10] = xmmword_1012E2F50;
  v23[14] = -1082130432;
  if (*(_BYTE *)(v11 + 416) && *(void *)(v11 + 408) && *(_BYTE *)(a1 + 1122)) {
    __int16 v12 = HIWORD(v24) & 0xFFEF | (16 * *(unsigned __int8 *)(a1 + 252)) | 0x100;
  }
  else {
    __int16 v12 = HIWORD(v24) & 0xFEEF | (16 * *(unsigned __int8 *)(a1 + 252)) & 0xFEFF;
  }
  HIWORD(v24) = v12;
  int v25 = 3;
  uint64_t v27 = 0LL;
  char v26 = *(_BYTE *)(a2 + 22);
  double v13 = *(double *)a2;
  double v14 = *(double *)(a1 + 280);
  if (v14 != 0.0)
  {
    double v15 = v13 - v14;
    if (v13 - v14 > 0.100000001)
    {
      if (qword_101934560 != -1) {
        dispatch_once(&qword_101934560, &stru_10184BA70);
      }
      uint64_t v16 = (os_log_s *)qword_101934568;
      if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        double v33 = v15;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "Large time gap, %lf", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934560 != -1) {
          dispatch_once(&qword_101934560, &stru_10184BA70);
        }
        int v30 = 134217984;
        double v31 = v15;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Large time gap, %lf",  COERCE_DOUBLE(&v30));
        uint64_t v19 = (uint8_t *)v18;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionService6AxisAP::feedGyroData(const CLGyro::Sample *)",  "%s\n",  v18);
        if (v19 != buf) {
          free(v19);
        }
      }

      if (*(_BYTE *)(a1 + 274))
      {
        if (qword_101934560 != -1) {
          dispatch_once(&qword_101934560, &stru_10184BA70);
        }
        uint64_t v17 = (os_log_s *)qword_101934568;
        if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Reset while backgrounded", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934560 != -1) {
            dispatch_once(&qword_101934560, &stru_10184BA70);
          }
          LOWORD(v30) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  0LL,  "Reset while backgrounded",  &v30,  2);
          uint64_t v21 = (uint8_t *)v20;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionService6AxisAP::feedGyroData(const CLGyro::Sample *)",  "%s\n",  v20);
          if (v21 != buf) {
            free(v21);
          }
        }

        sub_100B0CED8(v6);
      }
    }
  }

  *(double *)(a1 + 280) = v13;
  sub_100307D50(a1, (uint64_t)&v22);
}

void sub_1006EF9C4(uint64_t a1, uint64_t a2)
{
}

float sub_1006EF9CC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v8 = *a2;
  int v9 = v3;
  int v4 = *((_DWORD *)a3 + 2);
  uint64_t v6 = *a3;
  int v7 = v4;
  return sub_1008093D4(a1 + 288, &v8, (uint64_t)&v6);
}

float sub_1006EFA14(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v8 = *a2;
  int v9 = v3;
  int v4 = *((_DWORD *)a3 + 2);
  uint64_t v6 = *a3;
  int v7 = v4;
  return sub_1008093D4(a1 + 88, &v8, (uint64_t)&v6);
}

uint64_t sub_1006EFA5C(float32x2_t *a1, uint64_t a2)
{
  uint64_t v3 = (unint64_t)(*(double *)a2 * 1000000.0);
  int v4 = *(_DWORD *)(a2 + 16);
  float32x2_t v6 = *(float32x2_t *)(a2 + 8);
  int v7 = v4;
  sub_100808D7C((uint64_t)&a1[36], &v6, v3);
  return sub_100B0E16C(a1 + 139, (uint64_t)&v6, v3);
}

uint64_t sub_1006EFAC0(uint64_t a1, uint64_t a2)
{
  return sub_1006EFA5C((float32x2_t *)(a1 - 200), a2);
}

void sub_1006EFAC8(id a1)
{
  qword_101934568 = (uint64_t)os_log_create("com.apple.locationd.Motion", "DeviceMotion");
}

void *sub_1006EFAF4(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10184BAA0;
  a1[9] = off_10184BB58;
  sub_1006F04DC((uint64_t)a1);
  return a1;
}

void sub_1006EFB7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1006EFBA8(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  __int16 v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *__int16 v12 = &off_101826EF8;
  *(void *)a1 = off_10184BC88;
  *(void *)(a1 + 72) = off_10184BD30;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10184BC88;
  *(void *)(a1 + 72) = off_10184BD30;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 240) = 12000;
  double v13 = (int *)(a1 + 240);
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 256));
  *(void *)(a1 + 256) = &off_101826EF8;
  uint64_t v14 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v14 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 240));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    *double v13 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184BD70);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v13;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184BD70);
    }
    int v24 = *v13;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    char v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, bo ol, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxAlert, DataProtectio nPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_1006EFF50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[31] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_100231C10(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_1006EFFF4()
{
}

void *sub_1006EFFFC(void *a1)
{
  a1[9] = off_10184BD30;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10184BC88;
  a1[31] = off_101826EC8;
  sub_1001B9C98(a1 + 32);
  sub_100231C10(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_1006F007C(uint64_t a1)
{
  return sub_1006EFFFC((void *)(a1 - 72));
}

void sub_1006F0084(void *a1)
{
  uint64_t v1 = sub_1006EFFFC(a1);
  operator delete(v1);
}

void sub_1006F0098(uint64_t a1)
{
  uint64_t v1 = sub_1006EFFFC((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_1006F00B0(uint64_t *a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(a1[10], "DELETE FROM VO2MaxAlertHistory WHERE startTime < ?", &v13);
  uint64_t v5 = v13;
  char v6 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v7 = a1[10];
    uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
    sub_1003BB2BC(v7, v8);
    uint64_t v9 = (*(int (**)(uint64_t *))(*a1 + 152))(a1);
  }

  else
  {
    uint64_t v9 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v10 = a1[10];
  else {
    uint64_t v11 = *(void *)(v10 + 88);
  }
  sub_1003C1EC0(v10, v11);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v9;
}

void sub_1006F01C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F01E8(uint64_t a1, uint64_t a2)
{
  return sub_1006F00B0((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_1006F01F0(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxAlertHistory ORDER BY startTime ASC", &v18);
    uint64_t v5 = v18;
    uint64_t v19 = v18;
    sub_1003C0454(*(void *)(a1 + 80));
    while (!sub_1006F0394(&v19, (uint64_t)&v18))
    {
      uint64_t v7 = a2[1];
      unint64_t v6 = (unint64_t)a2[2];
      if ((unint64_t)v7 >= v6)
      {
        uint64_t v9 = (v7 - *a2) >> 4;
        unint64_t v10 = v9 + 1;
        uint64_t v11 = v6 - (void)*a2;
        if (v11 >> 3 > v10) {
          unint64_t v10 = v11 >> 3;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12) {
          uint64_t v13 = (char *)sub_100037038((uint64_t)(a2 + 2), v12);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = &v13[16 * v9];
        *(_OWORD *)uint64_t v14 = v18;
        char v16 = *a2;
        uint64_t v15 = a2[1];
        uint64_t v17 = v14;
        if (v15 != *a2)
        {
          do
          {
            *((_OWORD *)v17 - 1) = *((_OWORD *)v15 - 1);
            v17 -= 16;
            v15 -= 16;
          }

          while (v15 != v16);
          uint64_t v15 = *a2;
        }

        uint64_t v8 = v14 + 16;
        *a2 = v17;
        a2[1] = v14 + 16;
        a2[2] = &v13[16 * v12];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *(_OWORD *)uint64_t v7 = v18;
        uint64_t v8 = v7 + 16;
      }

      a2[1] = v8;
    }

    uint64_t result = sub_1003C05BC(*(void *)(a1 + 80));
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_1006F036C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0394(uint64_t *a1, uint64_t a2)
{
  int v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  unint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  double v8 = sqlite3_column_double(v7, 1);
  uint64_t result = 0LL;
  *(double *)(a2 + _Block_object_dispose(va, 8) = v8;
  return result;
}

uint64_t sub_1006F0410(uint64_t a1)
{
  uint64_t v3 = v8;
  int v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    unint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_1006F04B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F04D4(uint64_t a1)
{
  return sub_1006F0410(a1 - 72);
}

uint64_t sub_1006F04DC(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result)
  {
    sub_1006F0538(a1);
    return sub_1003B59A0( *(void *)(a1 + 80),  "VO2MaxAlertHistory",  (const char **)&off_10184BBE8,  (const std::string::value_type **)&off_101939E30,  0);
  }

  return result;
}

uint64_t sub_1006F0538(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "VO2MaxAlertHistory");
  if ((_DWORD)result)
  {
    __int128 v35 = "startTime";
    int v36 = 5;
    __int16 v37 = 0;
    char v38 = 0;
    char v39 = 0;
    if ((sub_1003BC790(*(void *)(a1 + 80), "VO2MaxAlertHistory", "startTime", (uint64_t)&v35) & 1) != 0)
    {
      uint64_t result = sub_1006F0CE8( a1,  "VO2MaxAlertHistory",  (const char **)&off_10184BBE8,  (const std::string::value_type **)&off_101939E30);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      sub_1003C0454(*(void *)(a1 + 80));
      sub_10000CE18((uint64_t)v31);
      uint64_t v3 = sub_10000CF44(&v32, (uint64_t)"ALTER TABLE VO2MaxAlertHistory ADD COLUMN ", 42LL);
      int v4 = sub_10000CF44(v3, (uint64_t)"startTime", 9LL);
      int v5 = sub_10000CF44(v4, (uint64_t)" ", 1LL);
      unint64_t v6 = (const char *)sub_1003BCC40(2);
      size_t v7 = strlen(v6);
      uint64_t v8 = sub_10000CF44(v5, (uint64_t)v6, v7);
      sub_10000CF44(v8, (uint64_t)";", 1LL);
      uint64_t v9 = *(void *)(a1 + 80);
      std::stringbuf::str(&v28, &v33);
      if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unint64_t v10 = &v28;
      }
      else {
        unint64_t v10 = (std::stringbuf::string_type *)v28.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v9, (char *)v10, &v26);
      uint64_t v11 = v26.__r_.__value_.__r.__words[0];
      v26.__r_.__value_.__r.__words[0] = 0LL;
      if ((char)v28.__r_.__value_.__s.__size_ < 0)
      {
        uint64_t v12 = v11;
        operator delete(v28.__r_.__value_.__l.__data_);
        uint64_t v11 = v12;
      }

      uint64_t v13 = *(void *)(a1 + 80);
      uint64_t v25 = v11;
      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v11);
      sub_1003BB2BC(v13, v14);
      sub_10000CE18((uint64_t)&v28);
      uint64_t v15 = sub_10000CF44(&v28.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE VO2MaxAlertHistory SET ", 30LL);
      char v16 = sub_10000CF44(v15, (uint64_t)"startTime", 9LL);
      sub_10000CF44(v16, (uint64_t)" = 0;", 5LL);
      uint64_t v17 = *(void *)(a1 + 80);
      std::stringbuf::str(&v26, &v29);
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v18 = &v26;
      }
      else {
        __int128 v18 = (std::stringbuf::string_type *)v26.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v17, (char *)v18, &v27);
      uint64_t v19 = v27;
      uint64_t v27 = 0LL;
      uint64_t v20 = *(void *)(a1 + 80);
      int v21 = (sqlite3_stmt *)sub_100019240(v19);
      sub_1003BB2BC(v20, v21);
      sub_1003C05BC(*(void *)(a1 + 80));
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
      }
      v28.__r_.__value_.__r.__words[0] = v22;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + *(void *)(v22 - 24)) = v23;
      v28.__r_.__value_.__l.__cap_ = v24;
      std::streambuf::~streambuf(&v29);
      std::ios::~ios(&v30);
      if (v25) {
        (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
      }
      v31[0] = v22;
      *(void *)((char *)v31 + *(void *)(v22 - 24)) = v23;
      std::string::size_type v32 = v24;
      std::streambuf::~streambuf(&v33);
      std::ios::~ios(&v34);
      sub_1006F0CE8( a1,  "VO2MaxAlertHistory",  (const char **)&off_10184BBE8,  (const std::string::value_type **)&off_101939E30);
    }

    return sub_1003BF200(*(void *)(a1 + 80), "VO2MaxAlertHistory");
  }

  return result;
}

void sub_1006F0890( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  sub_1011F8850((uint64_t)&a55);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F092C(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxAlertHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_1006F09C0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F09E0(uint64_t a1)
{
  return sub_1006F092C(a1 - 72);
}

uint64_t sub_1006F09E8(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, 1LL);
    sub_1003C0D54(a1[10], "DELETE FROM VO2MaxAlertHistory WHERE startTime > ?", &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 8)))
    {
      uint64_t v7 = a1[10];
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
    }

    uint64_t v9 = a1[10];
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    uint64_t result = sub_1003C1EC0(v9, v10);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_1006F0AB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0AD0(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "UPDATE VO2MaxAlertHistory SET startTime = startTime + ?", &v9);
    uint64_t v5 = v9;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v9);
    uint64_t result = sub_1003B7480(v6, 1, a2);
    if ((_DWORD)result)
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003BB2BC(v7, v8);
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_1006F0B68(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0B88(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "INSERT INTO VO2MaxAlertHistory (startTime) VALUES (?)", &v9);
    uint64_t v5 = v9;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v9);
    uint64_t result = sub_1003B7480(v6, 1, *(double *)(a2 + 8));
    if ((_DWORD)result)
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003BB2BC(v7, v8);
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_1006F0C20(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0C40()
{
  return 0LL;
}

uint64_t sub_1006F0C48(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v7;
  uint64_t v8 = v7;
  uint64_t v5 = sub_1006F0394(&v8, a2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return v5;
}

void sub_1006F0CC8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0CE8(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184BD70);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const cha r *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB: :ClassBDataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      char v16 = v143;
    }
    else {
      char v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    __int128 v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      int v21 = &__p;
    }
    else {
      int v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    std::string::size_type v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    std::stringbuf::string_type v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf::string_type v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      std::stringbuf::string_type v28 = v143;
    }
    else {
      std::stringbuf::string_type v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    uint64_t v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v34 = &v139;
    }
    else {
      uint64_t v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    int v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    char v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v41 = &__p;
    }
    else {
      uint64_t v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    double v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::stringbuf v47 = &__p;
      }
      else {
        std::stringbuf v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      uint64_t v48 = v143;
    }
    else {
      uint64_t v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    __int128 v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v54 = buf;
    }
    else {
      __int128 v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    __int128 v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v60 = buf;
    }
    else {
      __int128 v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v69 = &__p;
    }
    else {
      int v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v75 = &__p;
      }
      else {
        v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    uint64_t v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      id v79 = &__p;
    }
    else {
      id v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    __int128 v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v85 = &__p;
      }
      else {
        v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      v86 = v143;
    }
    else {
      v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      v95 = &__p;
    }
    else {
      v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          v103 = &__p;
        }
        else {
          v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        v104 = v141;
      }
      else {
        v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v114 = buf;
      }
      else {
        v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v121 = &__p;
      }
      else {
        v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const c har *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxAlert, DataProtectionPolicy = CLActivit yDB::ClassBDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const c har *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxAlert, DataProtectionPolicy = CLActivit yDB::ClassBDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_1006F1E80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006F21A0(void *a1, void **a2, double a3, double a4)
{
  __int128 v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v37);
  if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
    if (HIBYTE(v38)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_101244FAC(v10);
    goto LABEL_40;
  }

  uint64_t v4 = (std::stringbuf *)v37[1];
  operator delete(v37[0]);
  if (!v4) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v37);
  uint64_t v11 = sub_10000CF44(&v38, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)p_p, size);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  uint64_t v15 = a1[10];
  uint64_t v4 = &v39;
  std::stringbuf::str(&__p, &v39);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    char v16 = &__p;
  }
  else {
    char v16 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v15, (char *)v16, &v34);
  uint64_t v5 = v34;
  uint64_t v34 = 0LL;
  uint64_t v35 = v5;
  std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    __int128 v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v35, (uint64_t)&__p);
        if ((_DWORD)v19) {
          break;
        }
        int v21 = a2[1];
        unint64_t v20 = (unint64_t)a2[2];
        if ((unint64_t)v21 >= v20)
        {
          uint64_t v23 = ((char *)v21 - (_BYTE *)*a2) >> 4;
          unint64_t v24 = v23 + 1;
          uint64_t v25 = v20 - (void)*a2;
          if (v25 >> 3 > v24) {
            unint64_t v24 = v25 >> 3;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26) {
            uint64_t v27 = (char *)sub_100037038((uint64_t)(a2 + 2), v26);
          }
          else {
            uint64_t v27 = 0LL;
          }
          std::stringbuf::string_type v28 = &v27[16 * v23];
          *(_OWORD *)std::stringbuf::string_type v28 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          uint64_t v30 = (char *)*a2;
          std::string::size_type v29 = (char *)a2[1];
          __int128 v31 = v28;
          if (v29 != *a2)
          {
            do
            {
              *((_OWORD *)v31 - 1) = *((_OWORD *)v29 - 1);
              v31 -= 16;
              v29 -= 16;
            }

            while (v29 != v30);
            std::string::size_type v29 = (char *)*a2;
          }

          std::string::size_type v22 = v28 + 16;
          *a2 = v31;
          a2[1] = v28 + 16;
          a2[2] = &v27[16 * v26];
          if (v29) {
            operator delete(v29);
          }
        }

        else
        {
          *int v21 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          std::string::size_type v22 = v21 + 1;
        }

        a2[1] = v22;
      }

      uint64_t v5 = v35;
      goto LABEL_42;
    }
  }

void sub_1006F24A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F2508(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v39 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184BD70);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)int v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2082;
      size_t v45 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)buf = 134349056;
        *(void *)int v43 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v40 = 134349056;
        uint64_t v41 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v40,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessibl e() [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184BD70);
    }
    __int128 v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)int v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2082;
      size_t v45 = v11;
      __int16 v46 = 2049;
      uint64_t v47 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    char v16 = (void *)(v14 + 8 * (v13 >> 8));
    if (v15 == v14) {
      uint64_t v17 = 0LL;
    }
    else {
      uint64_t v17 = *v16 + 16LL * v13;
    }
    while (1)
    {
      if (v15 == v14)
      {
        uint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v23 = *(void *)(v14 + ((v22 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v22;
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10184BD90);
      }
      unint64_t v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10184BD90);
        }
        LOWORD(v40) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v40,  v38);
        uint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessibl e() [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 16LL;
      if (v17 - *v16 == 4096)
      {
        uint64_t v25 = v16[1];
        ++v16;
        uint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184BD70);
    }
    __int128 v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)int v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2082;
      size_t v45 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
    }

    unint64_t v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      int v21 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)int v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2082;
      size_t v45 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  std::stringbuf::string_type v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      std::stringbuf::string_type v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 128LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 256LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v32;
LABEL_61:
  __int128 v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_1006F2C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_1006F2C3C(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

id *sub_1006F2C48(uint64_t a1, uint64_t a2, char a3)
{
  v33[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v33[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v33);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 104LL))(a1, v31);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        LOWORD(v34) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v34,  2);
        char v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = v32;
    double v9 = v7 - v32;
    if (v7 - v32 < 0.0) {
      double v9 = -(v7 - v32);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
      }
      __int128 v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)buf = 134349312;
        double v39 = v32;
        __int16 v40 = 2050;
        uint64_t v41 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        uint64_t v22 = *(void *)(a2 + 8);
        int v34 = 134349312;
        double v35 = v32;
        __int16 v36 = 2050;
        uint64_t v37 = v22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v34,  22);
        unint64_t v24 = (uint8_t *)v23;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
        if (v24 != buf) {
          free(v24);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = v32;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)buf = 134217984;
          double v39 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184BD70);
          }
          double v25 = *(double *)(a2 + 8);
          int v34 = 134217984;
          double v35 = v25;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v34));
          uint64_t v27 = (uint8_t *)v26;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRe cordUL(const T &, BOOL) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
          if (v27 != buf) {
            free(v27);
          }
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v30 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10184BD70);
        double v18 = v30;
      }

      double v19 = v17 - v18;
      unint64_t v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        double v39 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184BD70);
        }
        int v34 = 134217984;
        double v35 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v34));
        uint64_t v29 = (uint8_t *)v28;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxAlert, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreReco rdUL(const T &, BOOL) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, v31, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_1006F3384( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1006F33B0(uint64_t a1)
{
  return sub_1006F2508(a1 - 72);
}

uint64_t sub_1006F33B8(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v31);
  if ((SHIBYTE(v32) & 0x80000000) == 0)
  {
    if (HIBYTE(v32)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_101245118(v4);
LABEL_44:
    sub_100007008();
  }

  uint64_t v27 = v31[1];
  operator delete(v31[0]);
  if (!v27) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v31);
    int v6 = sub_10000CF44(&v32, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t *))(*a1 + 64))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v33);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v28);
    uint64_t v12 = v28;
    uint64_t v28 = 0LL;
    uint64_t v29 = v12;
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v29, (uint64_t)&__p))
    {
      uint64_t v14 = a2[1];
      unint64_t v13 = (unint64_t)a2[2];
      if ((unint64_t)v14 >= v13)
      {
        uint64_t v16 = (v14 - *a2) >> 4;
        unint64_t v17 = v16 + 1;
        uint64_t v18 = v13 - (void)*a2;
        if (v18 >> 3 > v17) {
          unint64_t v17 = v18 >> 3;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19) {
          unint64_t v20 = (char *)sub_100037038((uint64_t)(a2 + 2), v19);
        }
        else {
          unint64_t v20 = 0LL;
        }
        int v21 = &v20[16 * v16];
        *(_OWORD *)int v21 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        uint64_t v23 = *a2;
        uint64_t v22 = a2[1];
        unint64_t v24 = v21;
        if (v22 != *a2)
        {
          do
          {
            *((_OWORD *)v24 - 1) = *((_OWORD *)v22 - 1);
            v24 -= 16;
            v22 -= 16;
          }

          while (v22 != v23);
          uint64_t v22 = *a2;
        }

        uint64_t v15 = v21 + 16;
        *a2 = v24;
        a2[1] = v21 + 16;
        a2[2] = &v20[16 * v19];
        if (v22) {
          operator delete(v22);
        }
      }

      else
      {
        *(_OWORD *)uint64_t v14 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        uint64_t v15 = v14 + 16;
      }

      a2[1] = v15;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v25 = v29;
    uint64_t v29 = 0LL;
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
    }
    *(void **)((char *)v31
    uint64_t v32 = v26;
    std::streambuf::~streambuf(&v33);
    return std::ios::~ios(&v34);
  }

  return result;
}

void sub_1006F3674( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F36DC(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_101245284(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  unint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_1006F393C(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_1012453F0(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_1006F3B74(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10124555C(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_1006F3D9C(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_1006F3DC8(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

double sub_1006F3DF4(uint64_t a1)
{
  *(void *)(a1 + 24) = 0LL;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 24_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(a1 + 260) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_BYTE *)(a1 + 184) = 0;
  __asm { FMOV            V1.2D, #-1.0 }

  *(_OWORD *)(a1 + 80) = _Q1;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0LL;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  double result = 1.0;
  *(_OWORD *)(a1 + 40) = xmmword_1012E0180;
  return result;
}

void *sub_1006F3E58(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1;
    goto LABEL_5;
  }

  if (v2)
  {
    uint64_t v3 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

void *sub_1006F3EA4(void *a1, uint64_t a2, uint64_t a3)
{
  double result = sub_1006F3ECC(a1, a2);
  a1[4] = a3;
  return result;
}

void *sub_1006F3ECC(void *a1, uint64_t a2)
{
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_1006F3F64(uint64_t a1, float *a2, float *a3, float *a4, double a5)
{
  float v13 = sub_100833624(a2, v10, v11, v12);
  float v15 = v14;
  int v17 = v16;
  double v18 = atan2( (float)((float)(v13 * *(float *)(a1 + 100)) - (float)(*(float *)(a1 + 96) * v15)),  (float)((float)(*(float *)(a1 + 100) * v15) + (float)(v13 * *(float *)(a1 + 96))));
  sub_1006F40D8(a1, a3, a5, v18);
  if (*(_BYTE *)(a1 + 296))
  {
    float v19 = a5 - *(double *)(a1 + 88);
    float v20 = v19 * 9.8067;
    sub_10083361C((float *)(a1 + 264), (float *)v24);
    for (uint64_t i = 0LL; i != 36; i += 4LL)
      *(float *)((char *)v24 + i) = v20 * *(float *)((char *)v24 + i);
    v26[0] = v24[0];
    v26[1] = v24[1];
    int v27 = v25;
    float v22 = sub_1002B8A2C((uint64_t)v26, a4);
  }

  else
  {
    unsigned int v23 = 0;
    float v22 = 0.0;
  }

  if (*(_BYTE *)(a1 + 240) && fabs(*(double *)(a1 + 200)) <= 0.005)
  {
    if (!*(_BYTE *)(a1 + 260)) {
      sub_100036CD8();
    }
    *(float *)(a1 + 24_Block_object_dispose(va, 8) = v22 + *(float *)(a1 + 248);
    *(float32x2_t *)(a1 + 252) = vadd_f32((float32x2_t)v23, *(float32x2_t *)(a1 + 252));
  }

  *(float *)(a1 + 96) = v13;
  *(float *)(a1 + 100) = v15;
  *(_DWORD *)(a1 + 104) = v17;
  *(double *)(a1 + 8_Block_object_dispose(va, 8) = a5;
}

double sub_1006F40D8(uint64_t a1, float *a2, double result, double a4)
{
  double v4 = *(double *)(a1 + 88);
  if (v4 >= 0.0)
  {
    double v5 = *(double *)(a1 + 136);
    *(double *)(a1 + 12_Block_object_dispose(va, 8) = *(double *)(a1 + 128) + a4;
    *(double *)(a1 + 136) = v5 + a4 * a4;
    double v6 = result - v4 + *(double *)(a1 + 144);
    *(double *)(a1 + 144) = v6;
    float v7 = *(float *)(a1 + 156);
    *(float *)(a1 + 152) = *a2 + *(float *)(a1 + 152);
    *(float *)(a1 + 156) = a2[1] + v7;
    *(float *)(a1 + 160) = a2[2] + *(float *)(a1 + 160);
    *(float *)&double v6 = (float)((float)(a2[2] * a2[2]) + (float)(a2[1] * a2[1])) + (float)(*a2 * *a2);
    *(float32x2_t *)(a1 + 164) = vadd_f32(*(float32x2_t *)(a1 + 164), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v6, 0));
    *(float *)(a1 + 172) = *(float *)&v6 + *(float *)(a1 + 172);
    double result = *(double *)(a1 + 176) + 1.0;
    *(double *)(a1 + 176) = result;
  }

  return result;
}

void sub_1006F4174(uint64_t a1, float *a2, float *a3, double a4, uint64_t a5, float *a6)
{
  BOOL v11 = sub_1006F4384(a1, a2, a4);
  sub_1006F3F64(a1, a2, a3, a6, a4);
  if (*(double *)(a1 + 48) >= a4)
  {
    char v12 = 0;
    if (!v11) {
      return;
    }
  }

  else
  {
    char v12 = sub_1006F440C(a1, a2, a4);
    if (!v11) {
      return;
    }
  }

  if (*(double *)(a1 + 48) < a4)
  {
    double v13 = atan2( (float)((float)(*(float *)(a1 + 96) * *(float *)(a1 + 112))
                  - (float)(*(float *)(a1 + 108) * *(float *)(a1 + 100))),
    double v14 = sub_1006F4508((double *)a1);
    if (!*(_BYTE *)(a1 + 260)) {
      sub_100036CD8();
    }
    uint64_t v15 = 0LL;
    float v16 = 0.0;
    do
    {
      float v16 = v16 + (float)(*(float *)(a1 + 248 + v15) * *(float *)(a1 + 248 + v15));
      v15 += 4LL;
    }

    while (v15 != 12);
    double v17 = sqrtf(v16);
    double v18 = 0.0;
    if ((v12 & 1) == 0) {
      double v18 = v17 - *(double *)(a1 + 120);
    }
    *(double *)&__int128 v25 = v13;
    *((double *)&v25 + 1) = v18;
    *(double *)uint64_t v26 = v14;
    *(_OWORD *)&v26[8] = xmmword_1012E0180;
    double v19 = a4 - *(double *)(a1 + 80);
    *(double *)&__int128 v24 = a4;
    *((double *)&v24 + 1) = v19;
    uint64_t v20 = *(void *)(a1 + 24);
    if (v20 && *(void *)(a1 + 32))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      (*(void (**)(uint64_t, uint64_t *, __int128 *))(*(void *)v20 + 48LL))(v20, &v27, &v24);
    }

    int v21 = *(unsigned __int8 *)(a1 + 240);
    __int128 v22 = v25;
    *(_OWORD *)(a1 + 184) = v24;
    *(_OWORD *)(a1 + 200) = v22;
    *(_OWORD *)(a1 + 216) = *(_OWORD *)v26;
    *(void *)(a1 + 232) = *(void *)&v26[16];
    if (!v21) {
      *(_BYTE *)(a1 + 240) = 1;
    }
    unsigned int v23 = (float *)(a1 + 56);
    if (*(_BYTE *)(a1 + 72))
    {
      if (v23 != a2) {
        *(_OWORD *)unsigned int v23 = *(_OWORD *)a2;
      }
    }

    else
    {
      *(_OWORD *)unsigned int v23 = *(_OWORD *)a2;
      *(_BYTE *)(a1 + 72) = 1;
    }

    *(void *)(a1 + 10_Block_object_dispose(va, 8) = *(void *)(a1 + 96);
    *(_DWORD *)(a1 + 116) = *(_DWORD *)(a1 + 104);
    *(double *)(a1 + 120) = v17;
    *(double *)(a1 + 80) = a4;
    *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(void *)(a1 + 176) = 0LL;
    *(double *)(a1 + 4_Block_object_dispose(va, 8) = *(double *)(a1 + 40) * ceil(a4 / *(double *)(a1 + 40) + 0.5);
  }

BOOL sub_1006F4384(uint64_t a1, float *a2, double a3)
{
  double v5 = *(double *)(a1 + 48);
  BOOL result = v5 < a3;
  if (!*(_BYTE *)(a1 + 260))
  {
    BOOL result = 0LL;
    *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(a1 + 256) = 0;
    *(_BYTE *)(a1 + 260) = 1;
  }

  if (v5 < a3 && !*(_BYTE *)(a1 + 72))
  {
    *(_OWORD *)(a1 + 56) = *(_OWORD *)a2;
    *(_BYTE *)(a1 + 72) = 1;
    *(double *)(a1 + 80) = a3;
    sub_100834754(a2);
    float v10 = sub_100833624(a2, v7, v8, v9);
    BOOL result = 0LL;
    *(float *)(a1 + 10_Block_object_dispose(va, 8) = v10;
    *(_DWORD *)(a1 + 112) = v11;
    *(_DWORD *)(a1 + 116) = v12;
  }

  return result;
}

uint64_t sub_1006F440C(uint64_t a1, _OWORD *a2, double a3)
{
  double v3 = *(double *)(a1 + 176);
  uint64_t v4 = 0LL;
  float v5 = (float)((float)((float)(*(float *)(a1 + 160) * *(float *)(a1 + 160))
                     + (float)(*(float *)(a1 + 156) * *(float *)(a1 + 156)))
  float v6 = v3;
  if (v7 != 0.0)
  {
    double v8 = v7;
    if (v8 <= 0.001)
    {
      float v9 = (_OWORD *)(a1 + 264);
      if (*(_BYTE *)(a1 + 296))
      {
        *float v9 = *a2;
        *(double *)(a1 + 280) = a3;
        *(double *)(a1 + 28_Block_object_dispose(va, 8) = v8;
      }

      else
      {
        *float v9 = *a2;
        *(double *)(a1 + 280) = a3;
        *(double *)(a1 + 28_Block_object_dispose(va, 8) = v8;
        *(_BYTE *)(a1 + 296) = 1;
      }

      int v11 = *(unsigned __int8 *)(a1 + 260);
      *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
      uint64_t v4 = 1LL;
      *(_DWORD *)(a1 + 256) = 0;
      if (!v11) {
        *(_BYTE *)(a1 + 260) = 1;
      }
    }
  }

  return v4;
}

double sub_1006F4508(double *a1)
{
  double v1 = a1[22];
  double v2 = -1.0;
  if (v1 < 3.0
    || (double v3 = a1[18], v3 <= 0.0)
    || (double v2 = a1[5] / (v3 / v1) * ((a1[17] - a1[16] * a1[16] / v1) / (v1 + -1.0)), v4 = v2, v2 < 0.00000305))
  {
    if (qword_101934950 != -1) {
      dispatch_once(&qword_101934950, &stru_10184BDB0);
    }
    float v5 = (os_log_s *)qword_101934958;
    if (os_log_type_enabled((os_log_t)qword_101934958, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134349312;
      double v13 = v2;
      __int16 v14 = 2050;
      uint64_t v15 = 0x3EC995D33B7BD711LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#VDR,computeDeltaCourseVar, deltaCourseVar,%{public}.6f,less than threshold,%{public}.6f,using threshold",  buf,  0x16u);
    }

    double v4 = 0.00000305;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934950 != -1) {
        dispatch_once(&qword_101934950, &stru_10184BDB0);
      }
      int v8 = 134349312;
      double v9 = v2;
      __int16 v10 = 2050;
      uint64_t v11 = 0x3EC995D33B7BD711LL;
      float v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934958,  2LL,  "#VDR,computeDeltaCourseVar, deltaCourseVar,%{public}.6f,less than threshold,%{public}.6f,using threshold",  &v8,  22);
      sub_10029211C("Generic", 1LL, 0, 2LL, "double CLVDREstimator2DoF::computeDeltaCourseVar() const", "%s\n", v7);
    }
  }

  return v4;
}

void sub_1006F4754(id a1)
{
  qword_101934958 = (uint64_t)os_log_create("com.apple.locationd.Position", "VDR");
}

void *sub_1006F4780(void *result, void *a2)
{
  if (a2 != result)
  {
    double v3 = result;
    double v4 = (void *)result[3];
    float v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_1006F48E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_1006F48F4(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v6 = sub_1006F4F64(a1, "CLSensorRecorderDb", a2, a3, 6, 30.0);
  *(void *)uint64_t v6 = off_10184BDE0;
  *(void *)(v6 + 72) = off_10184BE90;
  *(_DWORD *)(v6 + 344) = a4;
  *(void *)(v6 + 352) = v6 + 352;
  *(void *)(v6 + 360) = v6 + 352;
  *(void *)(v6 + 36_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v6 + 376) = 0LL;
  *(_DWORD *)(v6 + 384) = 0x20000;
  *(void *)(v6 + 392) = v6 + 352;
  *(_DWORD *)(v6 + 400) = 0;
  if (a4 > 2) {
    float v7 = "";
  }
  else {
    float v7 = (&off_10184C2B8)[a4];
  }
  int v8 = (std::string *)sub_1010DDBC0(buf, v7);
  double v9 = std::string::insert(v8, 0LL, "SensorRecorder");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__l.__cap_ = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v11 = std::string::append(&v43, "Data");
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  *(void *)(a1 + 424) = v11->__r_.__value_.__l.__cap_;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  if (v45 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v13 = *(int *)(a1 + 344);
  else {
    __int16 v14 = (&off_10184C2B8)[v13];
  }
  uint64_t v15 = (std::string *)sub_1010DDBC0(buf, v14);
  float v16 = std::string::insert(v15, 0LL, "SensorRecorder");
  __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  double v18 = std::string::append(&v43, "Meta");
  __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  *(void *)(a1 + 44_Block_object_dispose(va, 8) = v18->__r_.__value_.__l.__cap_;
  *(_OWORD *)(a1 + 432) = v19;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  if (v45 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v20 = sub_1006E27E8();
  sub_100413284(v20, &v43);
  int v21 = (int *)(a1 + 384);
  sub_1002A7CB0((uint64_t)v43.__r_.__value_.__l.__data_, "SensorRecorderCacheSizeBytes", (_DWORD *)(a1 + 384));
  uint64_t size = (std::__shared_weak_count *)v43.__r_.__value_.__l.__size_;
  if (v43.__r_.__value_.__l.__size_)
  {
    unsigned int v23 = (unint64_t *)(v43.__r_.__value_.__l.__size_ + 8);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }

  if (qword_1019345F0 != -1) {
    dispatch_once(&qword_1019345F0, &stru_10184BF50);
  }
  __int128 v25 = (os_log_s *)qword_1019345F8;
  if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
  {
    int v26 = *v21;
    LODWORD(v43.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(v43.__r_.__value_.__r.__words[0]) = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "SensorRecorderCacheSizeBytes, %d",  (uint8_t *)&v43,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v43, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    int v32 = *v21;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v43,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "SensorRecorderCacheSizeBytes, %d",  buf);
    uint64_t v34 = (std::string *)v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSensorRecorderDb::CLSensorRecorderDb(BOOL, const std::string, CLSensorRecorder_Types::DataType)",  "%s\n",  v33);
    if (v34 != &v43) {
      free(v34);
    }
  }

  if (qword_1019345F0 != -1) {
    dispatch_once(&qword_1019345F0, &stru_10184BF50);
  }
  uint64_t v27 = (os_log_s *)qword_1019345F8;
  if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
  {
    uint64_t v28 = *(int *)(a1 + 344);
    uint64_t v29 = v28 > 2 ? "" : (&off_10184C2B8)[v28];
    sub_1010DDBC0(&v43, v29);
    double v30 = (v43.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v43 : (std::string *)v43.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "SensorRecorderType, %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v43, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    uint64_t v35 = *(int *)(a1 + 344);
    else {
      __int16 v36 = (&off_10184C2B8)[v35];
    }
    uint64_t v37 = qword_1019345F8;
    sub_1010DDBC0(buf, v36);
    if (v45 >= 0) {
      uint64_t v38 = buf;
    }
    else {
      uint64_t v38 = *(_BYTE **)buf;
    }
    int v41 = 136315138;
    double v42 = v38;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v43,  1628LL,  &_mh_execute_header,  v37,  1LL,  "SensorRecorderType, %s",  (const char *)&v41);
    __int16 v40 = v39;
    if (v45 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSensorRecorderDb::CLSensorRecorderDb(BOOL, const std::string, CLSensorRecorder_Types::DataType)",  "%s\n",  (const char *)v40);
    if (v40 != &v43) {
      free(v40);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  return a1;
}

void sub_1006F4E9C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_1006F4F64(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  __int128 v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *__int128 v12 = &off_10182BDA0;
  *(void *)a1 = off_10184C190;
  *(void *)(a1 + 72) = off_10184C238;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10184C190;
  *(void *)(a1 + 72) = off_10184C238;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 256) = 0LL;
  *(_DWORD *)(a1 + 264) = 12000;
  *(void *)(a1 + 272) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 280));
  *(void *)(a1 + 280) = &off_10182BDA0;
  uint64_t v14 = a1 + 112;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v30 = a1 + 112;
  (*(void (**)(uint64_t))(v13 + 16))(a1 + 112);
  __int16 v32 = 256;
  if (a3)
  {
    *(void *)(a1 + 224) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v14 + 24LL))(v14);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v29 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  float v16 = (int *)(a1 + 264);
  char v17 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 264));
  uint64_t v18 = v35;
  if (v35)
  {
    p_shared_owners = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  if ((v17 & 1) == 0) {
    int *v16 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184C278);
  }
  int v21 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v22 = *v16;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184C278);
    }
    int v25 = *v16;
    v33[0] = 67109120;
    v33[1] = v25;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v33);
    uint64_t v27 = (uint8_t *)v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLSensorRecorderDataPacket>::CLActivityRecorderDb(const char *, BOOL, float, const std::strin g &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSensorRecorderDataPacket, DataProtectionPolicy = CL ActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
    if (v27 != buf) {
      free(v27);
    }
  }

  int v23 = HIBYTE(v32);
  *(void *)(a1 + 224) = 0xBFF0000000000000LL;
  if (v23)
  {
    if ((_BYTE)v32)
    {
      pthread_mutex_unlock(v31);
      return a1;
    }

    uint64_t v14 = v30;
    goto LABEL_3;
  }

  return a1;
}

void sub_1006F5324( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[34] = off_10182BD58;
  sub_1001B9C98(v28);
  sub_10000AE14(v27);
  sub_1006FAA74(v26);
  sub_100D8A88C(a12);
  *unint64_t v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_1006F53D0()
{
}

void *sub_1006F53D8(void *a1)
{
  a1[9] = off_10184C238;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10184C190;
  a1[34] = off_10182BD58;
  sub_1001B9C98(a1 + 35);
  sub_10000AE14((uint64_t)(a1 + 31));
  sub_1006FAA74(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_1006F545C(uint64_t a1)
{
  *(void *)a1 = off_10184BDE0;
  *(void *)(a1 + 72) = off_10184BE90;
  sub_1006FA058((uint64_t *)(a1 + 352));
  return sub_1006F53D8((void *)a1);
}

void *sub_1006F54BC(uint64_t a1)
{
  return sub_1006F545C(a1 - 72);
}

void sub_1006F54C4(uint64_t a1)
{
  double v1 = sub_1006F545C(a1);
  operator delete(v1);
}

void sub_1006F54D8(uint64_t a1)
{
  double v1 = sub_1006F545C(a1 - 72);
  operator delete(v1);
}

void sub_1006F54F0(uint64_t a1)
{
  uint64_t v2 = (char *)(a1 + 408);
  double v3 = (char *)(a1 + 432);
  if (sub_1003C1048(*(void *)(a1 + 80)))
  {
    if (sub_1003BEE74(*(void *)(a1 + 80), v2, (uint64_t)"2245.4.99")
      && (sub_1003BEE74(*(void *)(a1 + 80), v2, (uint64_t)"") & 1) == 0)
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      double v4 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Detected incompatible sensor table, purging Sensor Recorder data",  buf,  2u);
      }

      uint64_t v5 = sub_1002921D0(115, 0);
      if ((_DWORD)v5)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_10184BF50);
        }
        v12[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  16LL,  "Detected incompatible sensor table, purging Sensor Recorder data",  v12,  2);
        uint64_t v11 = (uint8_t *)v10;
        uint64_t v5 = sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSensorRecorderDb::prepareSQLStatements()",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      uint64_t v6 = sub_1006F587C(v5, (uint64_t)v2, *(char **)(a1 + 80));
      sub_1006F587C(v6, (uint64_t)v3, *(char **)(a1 + 80));
    }

    sub_1003B59A0(*(void *)(a1 + 80), v2, (const char **)&off_10184BF70, 0LL, 0);
    sub_1003B59A0( *(void *)(a1 + 80),  v3,  (const char **)&off_10184C000,  (const std::string::value_type **)&off_101939E40,  0);
    sub_1006F59B4(a1);
    sub_1006F5ADC();
  }

  else
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    float v7 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Device is locked and we are unable to open the database",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      v12[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "Device is locked and we are unable to open the database",  v12,  2);
      double v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLSensorRecorderDb::prepareSQLStatements()", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

uint64_t sub_1006F587C(uint64_t a1, uint64_t a2, char *a3)
{
  if (qword_1019345F0 != -1) {
    dispatch_once(&qword_1019345F0, &stru_10184BF50);
  }
  uint64_t v5 = (os_log_s *)qword_1019345F8;
  if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003B5CA0(a3, (uint64_t)__p);
    if (v9 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 68289539;
    int v11 = 0;
    __int16 v12 = 2082;
    uint64_t v13 = "";
    __int16 v14 = 2081;
    uint64_t v15 = a2;
    __int16 v16 = 2082;
    char v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Deleting Sensor Table, table:%{private, location:escape_only}s, database:%{public , location:escape_only}s}",  buf,  0x26u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_1003C0200(a3, a2);
}

uint64_t sub_1006F59B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  std::operator+<char>(&v10, "DELETE FROM ", a1 + 432);
  double v3 = std::string::append(&v10, " WHERE dataId = 0");
  __int128 v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  int64_t cap = v3->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::stringbuf::string_type __p = v4;
  v3->__r_.__value_.__l.__size_ = 0LL;
  v3->__r_.__value_.__l.__cap_ = 0LL;
  v3->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v5 = (char *)__p;
  }
  else {
    uint64_t v5 = (char *)__p[0];
  }
  sub_1003C0D54(v2, v5, &v13);
  uint64_t v6 = v13;
  uint64_t v13 = 0LL;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = *(void *)(a1 + 80);
  int v8 = (sqlite3_stmt *)sub_100019240(v6);
  uint64_t result = sub_1003BB2BC(v7, v8);
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  return result;
}

void sub_1006F5A8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F5ADC()
{
  v0 = (char *)operator new(0x88uLL);
  sub_1010DDBC0(v6, "");
  *(void *)buf = 0x100000003LL;
  __int16 v9 = 0;
  if (SHIBYTE(v7) < 0)
  {
    sub_1010DD48C(&__p, v6[0], (unint64_t)v6[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v6;
    uint64_t v11 = v7;
  }

  uint64_t v12 = 0LL;
  sub_1003B35F4(v0, buf);
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  BOOL v1 = sub_1003C1048((uint64_t)v0);
  if (v1)
  {
    sub_1006F6A84(v1, v0);
  }

  else
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    uint64_t v2 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Unable to open legacy database; failed to drop obsolete tables",
        buf,
        2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v6[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "Unable to open legacy database; failed to drop obsolete tables",
        v6,
        2);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorRecorderDb::deleteTablesFromLegacyDatabase()", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

  return (*(uint64_t (**)(char *))(*(void *)v0 + 8LL))(v0);
}

void sub_1006F5D18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
}

uint64_t sub_1006F5D78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 112;
  uint64_t v5 = a1 + 72;
  (*(void (**)(uint64_t))(*(void *)(a1 + 112) + 16LL))(a1 + 112);
  if ((sub_100D8A92C(v5) & 1) != 0)
  {
    sub_1006F5E34((uint64_t *)(a1 + 352), a2);
    unint64_t v6 = *(void *)(a1 + 376) + *(unsigned int *)(a2 + 16);
    *(void *)(a1 + 376) = v6;
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
}

void sub_1006F5E20(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

_OWORD *sub_1006F5E34(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new(0x38uLL);
  result[1] = *(_OWORD *)a2;
  *((_DWORD *)result + _Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 32);
  *((void *)result + 5) = *(void *)(a2 + 24);
  *((void *)result + 6) = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = *a1;
  *(void *)uint64_t result = *a1;
  *((void *)result + 1) = a1;
  *(void *)(v8 + _Block_object_dispose(va, 8) = result;
  *a1 = (uint64_t)result;
  ++a1[2];
  return result;
}

id *sub_1006F5EA8(id *result, int a2)
{
  if (!result[46]) {
    return result;
  }
  uint64_t v2 = (uint64_t)result;
  sub_100222B94(v63, (uint64_t)"CLSensorRecorderDb::storeToDb", 0);
  if (qword_1019345F0 != -1) {
    dispatch_once(&qword_1019345F0, &stru_10184BF50);
  }
  double v3 = (os_log_s *)qword_1019345F8;
  if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = *(void *)(v2 + 368);
    uint64_t v5 = *(void *)(v2 + 376);
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Flushing to memory. %zu, %zu", buf, 0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    std::string::size_type v51 = *(void *)(v2 + 368);
    std::string::size_type v52 = *(void *)(v2 + 376);
    LODWORD(v64.__r_.__value_.__l.__data_) = 134218240;
    *(std::string::size_type *)((char *)v64.__r_.__value_.__r.__words + 4) = v51;
    WORD2(v64.__r_.__value_.__r.__words[1]) = 2048;
    *(std::string::size_type *)((char *)&v64.__r_.__value_.__r.__words[1] + 6) = v52;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "Flushing to memory. %zu, %zu",  (size_t)&v64,  22);
    __int128 v54 = (char *)v53;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSensorRecorderDb::storeToDb(BOOL)", "%s\n", v53);
    if (v54 != buf) {
      free(v54);
    }
  }

  unint64_t v6 = objc_autoreleasePoolPush();
  unint64_t v7 = +[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", *(void *)(v2 + 376));
  uint64_t v8 = v2 + 352;
  for (uint64_t i = *(void *)(v2 + 360); i != v8; uint64_t i = *(void *)(i + 8))
    -[NSMutableData appendBytes:length:](v7, "appendBytes:length:", *(void *)(i + 40), *(unsigned int *)(i + 32));
  sub_1003C0454(*(void *)(v2 + 80));
  std::string v10 = (uint64_t *)(v2 + 360);
  uint64_t v11 = *(void *)(v2 + 392);
  if (v11 != v8) {
    std::string v10 = (uint64_t *)(v11 + 8);
  }
  uint64_t v12 = *v10;
  uint64_t v13 = *(void *)(v2 + 80);
  std::operator+<char>(&v64, "INSERT INTO ", v2 + 432);
  __int16 v14 = std::string::append(&v64, " (startTime, timestamp, dataId, offset, size, movement) VALUES (?, ?, ?, ?, ?, ?)");
  __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  *(void *)&uint8_t buf[16] = v14->__r_.__value_.__l.__cap_;
  *(_OWORD *)buf = v15;
  v14->__r_.__value_.__l.__size_ = 0LL;
  v14->__r_.__value_.__l.__cap_ = 0LL;
  v14->__r_.__value_.__r.__words[0] = 0LL;
  if (buf[23] >= 0) {
    __int16 v16 = buf;
  }
  else {
    __int16 v16 = *(char **)buf;
  }
  sub_1003C0D54(v13, v16, &v62);
  uint64_t v17 = v62;
  uint64_t v62 = 0LL;
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  while (1)
  {
    if (v12 == v8)
    {
      int v27 = 1;
      goto LABEL_35;
    }

    uint64_t v18 = (sqlite3_stmt *)sub_100019240(v17);
    __int128 v19 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003C2D24(v19, 2, *(void *)(v12 + 24))) {
      break;
    }
    unint64_t v20 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003C28BC(v20, 3, 0)) {
      break;
    }
    int v21 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003C28BC(v21, 4, *(_DWORD *)(v2 + 400))) {
      break;
    }
    int v22 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003C2AF0(v22, 5, *(_DWORD *)(v12 + 32))) {
      break;
    }
    int v23 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003C28BC(v23, 6, 0)) {
      break;
    }
    uint64_t v24 = *(void *)(v2 + 80);
    uint64_t v25 = (sqlite3_stmt *)sub_100019240(v17);
    if (!sub_1003BB2BC(v24, v25)) {
      break;
    }
    *(_DWORD *)(v2 + 400) += *(_DWORD *)(v12 + 32);
    *(void *)(v2 + 392) = v12;
    uint64_t v12 = *(void *)(v12 + 8);
  }

  if (qword_1019345F0 != -1) {
    dispatch_once(&qword_1019345F0, &stru_10184BF50);
  }
  int v26 = (os_log_s *)qword_1019345F8;
  if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unable to insert meta data.", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    LOWORD(v64.__r_.__value_.__l.__data_) = 0;
    LODWORD(v60) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "Unable to insert meta data.",  &v64,  v60);
    __int128 v56 = (char *)v55;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorRecorderDb::storeToDb(BOOL)", "%s\n", v55);
    if (v56 != buf) {
      free(v56);
    }
  }

  int v27 = 0;
LABEL_35:
  if (a2)
  {
    uint64_t v28 = *(void *)(v2 + 80);
    std::operator+<char>(&v64, "INSERT INTO ", v2 + 408);
    uint64_t v29 = std::string::append(&v64, " (data) VALUES (?)");
    __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
    *(void *)&uint8_t buf[16] = v29->__r_.__value_.__l.__cap_;
    *(_OWORD *)buf = v30;
    v29->__r_.__value_.__l.__size_ = 0LL;
    v29->__r_.__value_.__l.__cap_ = 0LL;
    v29->__r_.__value_.__r.__words[0] = 0LL;
    if (buf[23] >= 0) {
      uint64_t v31 = buf;
    }
    else {
      uint64_t v31 = *(char **)buf;
    }
    sub_1003C0D54(v28, v31, &v62);
    uint64_t v32 = v62;
    uint64_t v62 = 0LL;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    std::stringbuf v33 = (sqlite3_stmt *)sub_100019240(v32);
    if (sub_1003C2F58(v33, 1, v7)
      && (uint64_t v34 = *(void *)(v2 + 80), v35 = (sqlite3_stmt *)sub_100019240(v32), sub_1003BB2BC(v34, v35)))
    {
      sqlite3_int64 v36 = sub_1003C1068(*(void *)(v2 + 80));
      if (v36)
      {
        uint64_t v37 = *(void *)(v2 + 80);
        std::operator+<char>(&v64, "UPDATE ", v2 + 432);
        uint64_t v38 = std::string::append(&v64, " SET dataId = ? WHERE dataId = 0");
        __int128 v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
        *(void *)&uint8_t buf[16] = v38->__r_.__value_.__l.__cap_;
        *(_OWORD *)buf = v39;
        v38->__r_.__value_.__l.__size_ = 0LL;
        v38->__r_.__value_.__l.__cap_ = 0LL;
        v38->__r_.__value_.__r.__words[0] = 0LL;
        if (buf[23] >= 0) {
          __int16 v40 = buf;
        }
        else {
          __int16 v40 = *(char **)buf;
        }
        sub_1003C0D54(v37, v40, &v62);
        uint64_t v41 = v62;
        uint64_t v62 = 0LL;
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        double v42 = (sqlite3_stmt *)sub_100019240(v41);
        if (!sub_1003C2D24(v42, 1, v36)
          || (uint64_t v43 = *(void *)(v2 + 80), v44 = (sqlite3_stmt *)sub_100019240(v41), !sub_1003BB2BC(v43, v44)))
        {
          if (qword_1019345F0 != -1) {
            dispatch_once(&qword_1019345F0, &stru_10184BF50);
          }
          char v45 = (os_log_s *)qword_1019345F8;
          if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_FAULT,  "Unable to update meta records dataId.",  buf,  2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345F0 != -1) {
              dispatch_once(&qword_1019345F0, &stru_10184BF50);
            }
            LOWORD(v64.__r_.__value_.__l.__data_) = 0;
            LODWORD(v60) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "Unable to update meta records dataId.",  &v64,  v60);
            __int128 v59 = (char *)v58;
            sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorRecorderDb::storeToDb(BOOL)", "%s\n", v58);
            if (v59 != buf) {
              free(v59);
            }
          }

          int v27 = 0;
        }

        if (v41) {
          (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
        }
        goto LABEL_69;
      }

      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      uint64_t v48 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, "Unable to get last accel data id.", buf, 2u);
      }

      if (!sub_1002921D0(115, 0))
      {
LABEL_68:
        int v27 = 0;
LABEL_69:
        if (v32) {
          (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
        }
        goto LABEL_71;
      }

      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v64.__r_.__value_.__l.__data_) = 0;
      LODWORD(v60) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "Unable to get last accel data id.",  &v64,  v60);
      __int128 v50 = (char *)v49;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorRecorderDb::storeToDb(BOOL)", "%s\n", v49);
    }

    else
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      __int16 v46 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_FAULT, "Unable to insert data.", buf, 2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_68;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v64.__r_.__value_.__l.__data_) = 0;
      LODWORD(v60) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "Unable to insert data.",  &v64,  v60);
      __int128 v50 = (char *)v57;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorRecorderDb::storeToDb(BOOL)", "%s\n", v57);
    }

    if (v50 != buf) {
      free(v50);
    }
    goto LABEL_68;
  }

void sub_1006F6950( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
  }
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
  }
  sub_1001BA1BC(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F6A84(uint64_t a1, char *a2)
{
  uint64_t result = sub_1003C1048((uint64_t)a2);
  if ((_DWORD)result)
  {
    for (uint64_t i = 0LL; i != 6; ++i)
    {
      uint64_t v5 = off_10184BED0[i];
      uint64_t result = sub_1003B747C(a2, v5);
      if ((_DWORD)result)
      {
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_10184BF50);
        }
        unint64_t v6 = (os_log_s *)qword_1019345F8;
        if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003B5CA0(a2, (uint64_t)__p);
          unint64_t v7 = __p;
          if (v9 < 0) {
            unint64_t v7 = (void **)__p[0];
          }
          *(_DWORD *)buf = 68289539;
          int v11 = 0;
          __int16 v12 = 2082;
          uint64_t v13 = "";
          __int16 v14 = 2081;
          __int128 v15 = v5;
          __int16 v16 = 2082;
          uint64_t v17 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Deleting Sensor Table, table:%{private, location:escape_only}s, database:%{ public, location:escape_only}s}",  buf,  0x26u);
          if (v9 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t result = sub_1003C0200(a2, v5);
      }
    }
  }

  return result;
}

uint64_t sub_1006F6C1C(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  uint64_t v3 = a1 + 72;
  (*(void (**)(uint64_t))(*(void *)(a1 + 112) + 16LL))(a1 + 112);
  uint64_t v4 = sub_100D8A92C(v3);
  if ((v4 & 1) != 0) {
    sub_1006F6A84(v4, *(char **)(a1 + 80));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

void sub_1006F6C94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1006F6CA8(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  (*(void (**)(uint64_t))(*(void *)(a1 + 112) + 16LL))(a1 + 112);
  sub_1006F5EA8((id *)a1, 1);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

void sub_1006F6D0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1006F6D20(uint64_t a1, sqlite3_int64 a2, void *a3)
{
  int v23 = a3;
  uint64_t v6 = a1 + 112;
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v7 = a1 + 72;
  v21[1] = a1 + 112;
  (*(void (**)(uint64_t))(v5 + 16))(a1 + 112);
  __int16 v22 = 256;
  if (!sub_100D8A92C(v7))
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    __int16 v14 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Database is inaccessible", (uint8_t *)__p, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v19.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "Database is inaccessible",  &v19,  2);
      uint64_t v18 = (void **)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordMeta(uint64_t, CLSensorRecorderSensorMeta *)",  "%s\n",  v17);
      if (v18 != __p) {
        free(v18);
      }
    }

    goto LABEL_18;
  }

  uint64_t v8 = *(void *)(a1 + 80);
  std::operator+<char>(&v19, "SELECT * FROM ", a1 + 432);
  char v9 = std::string::append(&v19, " WHERE id = ?");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t cap = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    int v11 = (char *)__p;
  }
  else {
    int v11 = (char *)__p[0];
  }
  sub_1003C0D54(v8, v11, &v20);
  uint64_t v12 = v20;
  uint64_t v20 = 0LL;
  v21[0] = v12;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
  if (!sub_1003C2D24(v13, 1, a2) || sub_1006F705C(v21, &v23))
  {
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
LABEL_18:
    uint64_t v15 = 0LL;
    goto LABEL_19;
  }

  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  uint64_t v15 = 1LL;
LABEL_19:
  (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  return v15;
}

void sub_1006F6FE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
}

uint64_t sub_1006F705C(uint64_t *a1, void **a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = *a2;
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setIdentifier:", sqlite3_column_int64(v7, 0));
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setStartTime:", sqlite3_column_double(v8, 1));
  char v9 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setTimestamp:", sqlite3_column_int64(v9, 2));
  __int128 v10 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setDataIdentifier:", sqlite3_column_int64(v10, 3));
  int v11 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setOffset:", sqlite3_column_int(v11, 4));
  uint64_t v12 = (sqlite3_stmt *)sub_100019240(*a1);
  objc_msgSend(v6, "setDataSize:", sqlite3_column_int(v12, 5));
  return 0LL;
}

void sub_1006F7154(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 80);
  std::operator+<char>(&v15, "SELECT * FROM ", a1 + 408);
  uint64_t v4 = std::string::append(&v15, " WHERE id = ?");
  __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  int64_t cap = v4->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v5;
  v4->__r_.__value_.__l.__size_ = 0LL;
  v4->__r_.__value_.__l.__cap_ = 0LL;
  v4->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v6 = (char *)__p;
  }
  else {
    uint64_t v6 = (char *)__p[0];
  }
  sub_1003C0D54(v3, v6, &v18);
  uint64_t v7 = v18;
  uint64_t v18 = 0LL;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(v7);
  if (!sub_1003C2D24(v8, 1, *(void *)a2) || (char v9 = (sqlite3_stmt *)sub_100019240(v7), sqlite3_step(v9) != 100))
  {
    if (!v7) {
      return;
    }
    goto LABEL_14;
  }

  __int128 v10 = (sqlite3_stmt *)sub_100019240(v7);
  *(void *)a2 = sqlite3_column_int64(v10, 0);
  int v11 = (sqlite3_stmt *)sub_100019240(v7);
  uint64_t v12 = sqlite3_column_blob(v11, 1);
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(v7);
  int v14 = sqlite3_column_bytes(v13, 1);
  if (v14 >= (unint64_t)*(unsigned int *)(a2 + 16))
  {
    sub_1012456C8();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Motion/SensorRecorder/CLSensorRecorderDb.mm",  35,  "formatFromStatement");
    __break(1u);
    return;
  }

  memcpy(*(void **)(a2 + 8), v12, v14);
  *(_DWORD *)(a2 + 16) = v14;
  if (v7) {
LABEL_14:
  }
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
}

void sub_1006F72E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F7338(uint64_t a1, uint64_t a2, sqlite3_int64 a3)
{
  uint64_t v7 = a1 + 112;
  uint64_t v6 = *(void *)(a1 + 112);
  uint64_t v8 = a1 + 72;
  v32[1] = (void *)(a1 + 112);
  (*(void (**)(uint64_t))(v6 + 16))(a1 + 112);
  __int16 v33 = 256;
  if ((sub_100D8A92C(v8) & 1) == 0)
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    int v11 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Database is inaccessible", buf, 2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_18;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    LOWORD(v29.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "Database is inaccessible",  &v29,  2);
    uint64_t v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordData(CLSensorRecorderSensorData &, uint64_t) const",  "%s\n",  v12);
    goto LABEL_45;
  }

  if (!(*(void *)a2 | a3))
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    int v14 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Invalid query, both data id and meta id are 0",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_18;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    LOWORD(v29.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Invalid query, both data id and meta id are 0",  &v29,  2);
    uint64_t v13 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordData(CLSensorRecorderSensorData &, uint64_t) const",  "%s\n",  v28);
LABEL_45:
    if (v13 != buf) {
      free(v13);
    }
LABEL_18:
    uint64_t v10 = 0LL;
    goto LABEL_19;
  }

  if (*(void *)a2)
  {
    sub_1006F7154(a1, a2);
    uint64_t v10 = v9;
  }

  else
  {
    id v16 = [[CLSensorRecorderSensorMeta alloc] initWithDataType:*(unsigned int *)(a1 + 344)];
    v32[0] = v16;
    uint64_t v17 = *(void *)(a1 + 80);
    std::operator+<char>(&v29, "SELECT * FROM ", a1 + 432);
    uint64_t v18 = std::string::append(&v29, " WHERE id = ?");
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    int64_t cap = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)buf = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      uint64_t v20 = (char *)buf;
    }
    else {
      uint64_t v20 = *(char **)buf;
    }
    sub_1003C0D54(v17, v20, &v30);
    uint64_t v21 = v30;
    uint64_t v30 = 0LL;
    uint64_t v31 = v21;
    if (SHIBYTE(cap) < 0) {
      operator delete(*(void **)buf);
    }
    __int16 v22 = (sqlite3_stmt *)sub_100019240(v21);
    if (sub_1003C2D24(v22, 1, a3) && !sub_1006F705C(&v31, v32))
    {
      if ([v16 dataIdentifier])
      {
        *(void *)a2 = [v16 dataIdentifier];
        sub_1006F7154(a1, a2);
        uint64_t v10 = v23;
      }

      else
      {
        uint64_t v24 = a1 + 352;
        uint64_t v25 = *(void *)(a1 + 360);
        if (v25 == v24)
        {
          LODWORD(v26) = 0;
        }

        else
        {
          uint64_t v26 = 0LL;
          do
          {
            size_t v27 = *(unsigned int *)(v25 + 32);
            if (v26 + v27 < *(unsigned int *)(a2 + 16))
            {
              memcpy((void *)(*(void *)(a2 + 8) + v26), *(const void **)(v25 + 40), v27);
              v26 += *(unsigned int *)(v25 + 32);
            }

            uint64_t v25 = *(void *)(v25 + 8);
          }

          while (v25 != v24);
        }

        *(_DWORD *)(a2 + 16) = v26;
        uint64_t v10 = 1LL;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
  }

void sub_1006F77DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
}

uint64_t sub_1006F785C(uint64_t a1, sqlite3_int64 a2, void *a3)
{
  uint64_t v23 = a3;
  uint64_t v6 = a1 + 112;
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v7 = a1 + 72;
  v21[1] = a1 + 112;
  (*(void (**)(uint64_t))(v5 + 16))(a1 + 112);
  __int16 v22 = 256;
  if (!sub_100D8A92C(v7))
  {
LABEL_18:
    uint64_t v15 = 0LL;
    goto LABEL_19;
  }

  uint64_t v8 = *(void *)(a1 + 80);
  std::operator+<char>(&v19, "SELECT * FROM ", a1 + 432);
  uint64_t v9 = std::string::append(&v19, " WHERE id >= ? ORDER BY id ASC");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t cap = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    int v11 = (char *)__p;
  }
  else {
    int v11 = (char *)__p[0];
  }
  sub_1003C0D54(v8, v11, &v20);
  uint64_t v12 = v20;
  uint64_t v20 = 0LL;
  v21[0] = v12;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
  if (!sub_1003C2D24(v13, 1, a2) || sub_1006F705C(v21, &v23))
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    int v14 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Database is inaccessible",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v19.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Database is inaccessible",  &v19,  2);
      uint64_t v18 = (void **)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordMetaSinceId(uint64_t, CLSensorRecorderSensorMeta *)",  "%s\n",  v17);
      if (v18 != __p) {
        free(v18);
      }
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    goto LABEL_18;
  }

  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  uint64_t v15 = 1LL;
LABEL_19:
  (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  return v15;
}

void sub_1006F7B1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  sub_1011C52D0((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F7B94(uint64_t a1, void *a2, void *a3, double a4, double a5)
{
  uint64_t v35 = a3;
  sqlite3_int64 v36 = a2;
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = a1 + 432;
  std::operator+<char>(&v32, "SELECT * FROM ", a1 + 432);
  __int128 v10 = std::string::append(&v32, " WHERE startTime >= ? ORDER BY id ASC LIMIT 1");
  __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  int64_t cap = v10->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v11;
  v10->__r_.__value_.__l.__size_ = 0LL;
  v10->__r_.__value_.__l.__cap_ = 0LL;
  v10->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v12 = (char *)__p;
  }
  else {
    uint64_t v12 = (char *)__p[0];
  }
  sub_1003C0D54(v8, v12, &v33);
  uint64_t v13 = v33;
  uint64_t v33 = 0LL;
  uint64_t v34 = v13;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = *(void *)(a1 + 80);
  std::operator+<char>(&v32, "SELECT * FROM ", v9);
  uint64_t v15 = std::string::append(&v32, " WHERE startTime < ? ORDER BY id DESC LIMIT 1");
  __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  int64_t cap = v15->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v16;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v17 = (char *)__p;
  }
  else {
    uint64_t v17 = (char *)__p[0];
  }
  sub_1003C0D54(v14, v17, &v31);
  uint64_t v18 = v31;
  uint64_t v33 = v31;
  uint64_t v31 = 0LL;
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  std::string v19 = (sqlite3_stmt *)sub_100019240(v13);
  if (!sub_1003B7480(v19, 1, a4) || (uint64_t v20 = (sqlite3_stmt *)sub_100019240(v18), !sub_1003B7480(v20, 1, a5)))
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    uint64_t v25 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Database upper and/or lower time bound query failed to bind.",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      LOWORD(v32.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Database upper and/or lower time bound query failed to bind.",  &v32,  2);
      uint64_t v29 = (void **)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityDB::ActivityCode CLSensorRecorderDb::getSensorRecordMetaIdsBounds(CFAbsoluteTime, CFAbsoluteTime, CLSe nsorRecorderSensorMeta *, CLSensorRecorderSensorMeta *) const",  "%s\n",  v30);
      goto LABEL_48;
    }

void sub_1006F8010( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006F80C4(uint64_t a1, void *a2, double a3, double a4)
{
  uint64_t v9 = a1 + 112;
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v10 = a1 + 72;
  v44[1] = a1 + 112;
  (*(void (**)(uint64_t))(v8 + 16))(a1 + 112);
  __int16 v45 = 256;
  if ((sub_100D8A92C(v10) & 1) != 0)
  {
    if (*(void *)(a1 + 368))
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      __int128 v11 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
      {
        double v12 = *(double *)(*(void *)(a1 + 360) + 16LL);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        uint64_t v14 = *(void *)(*(void *)(a1 + 360) + 16LL);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v12 < a4;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(CFAbsoluteTime *)&buf[10] = Current;
        *(_WORD *)&buf[18] = 2048;
        *(double *)&buf[20] = a4;
        __int16 v50 = 2048;
        uint64_t v51 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Non-empty, endTime in memory, %d, current time, %f, endTime, %f, first entry startTime, %f, ",  buf,  0x26u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_10184BF50);
        }
        uint64_t v33 = qword_1019345F8;
        double v34 = *(double *)(*(void *)(a1 + 360) + 16LL);
        CFAbsoluteTime v35 = CFAbsoluteTimeGetCurrent();
        uint64_t v36 = *(void *)(*(void *)(a1 + 360) + 16LL);
        *(_DWORD *)__int16 v46 = 67109888;
        *(_DWORD *)&v46[4] = v34 < a4;
        *(_WORD *)&v46[8] = 2048;
        *(CFAbsoluteTime *)&v46[10] = v35;
        *(_WORD *)&v46[18] = 2048;
        *(double *)&v46[20] = a4;
        __int16 v47 = 2048;
        uint64_t v48 = v36;
        LODWORD(v41) = 38;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  1LL,  "Non-empty, endTime in memory, %d, current time, %f, endTime, %f, first entry startTime, %f, ",  v46,  v41,  v42,  v43);
        uint64_t v38 = (char *)v37;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordMetaIds(CFAbsoluteTime, CFAbsoluteTime, NSMutableArray *)",  "%s\n",  v37);
        if (v38 != buf) {
          free(v38);
        }
      }

      if (*(double *)(*(void *)(a1 + 360) + 16LL) < a4)
      {
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_10184BF50);
        }
        uint64_t v15 = (os_log_s *)qword_1019345F8;
        if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "Data requested is in memory.  Writing incremental data out to disk.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345F0 != -1) {
            dispatch_once(&qword_1019345F0, &stru_10184BF50);
          }
          *(_WORD *)__int16 v46 = 0;
          LODWORD(v41) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "Data requested is in memory.  Writing incremental data out to disk.",  v46,  *(void *)&v41);
          __int16 v40 = (char *)v39;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordMetaIds(CFAbsoluteTime, CFAbsoluteTime, NSMutableArray *)",  "%s\n",  v39);
          if (v40 != buf) {
            free(v40);
          }
        }

        sub_1006F5EA8((id *)a1, 0);
      }
    }

    id v16 = [[CLSensorRecorderSensorMeta alloc] initWithDataType:*(unsigned int *)(a1 + 344)];
    id v17 = [[CLSensorRecorderSensorMeta alloc] initWithDataType:*(unsigned int *)(a1 + 344)];
    int v18 = sub_1006F7B94(a1, v16, v17, a3, a4);
    if (v18)
    {
      BOOL v19 = v18 != 2;
    }

    else
    {
      uint64_t v21 = *(void *)(a1 + 80);
      std::operator+<char>(v46, "SELECT * FROM ", a1 + 432);
      int v22 = std::string::append((std::string *)v46, " WHERE ? <= id AND id <= ? ORDER BY id ASC");
      __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      *(void *)&uint8_t buf[16] = v22->__r_.__value_.__l.__cap_;
      *(_OWORD *)buf = v23;
      v22->__r_.__value_.__l.__size_ = 0LL;
      v22->__r_.__value_.__l.__cap_ = 0LL;
      v22->__r_.__value_.__r.__words[0] = 0LL;
      if (buf[23] >= 0) {
        uint64_t v24 = buf;
      }
      else {
        uint64_t v24 = *(char **)buf;
      }
      sub_1003C0D54(v21, v24, &v43);
      uint64_t v25 = *(void *)&v43;
      double v43 = 0.0;
      v44[0] = v25;
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if ((v46[23] & 0x80000000) != 0) {
        operator delete(*(void **)v46);
      }
      uint64_t v26 = (sqlite3_stmt *)sub_100019240(v25);
      sub_1003C2D24(v26, 1, (sqlite3_int64)[v16 identifier]);
      size_t v27 = (sqlite3_stmt *)sub_100019240(v25);
      sub_1003C2D24(v27, 2, (sqlite3_int64)[v17 identifier]);
      do
      {
        id v28 = [[CLSensorRecorderSensorMeta alloc] initWithDataType:*(unsigned int *)(a1 + 344)];
        *(void *)buf = v28;
        int v29 = sub_1006F705C(v44, (void **)buf);
        if (!v29) {
          [a2 addObject:v28];
        }
      }

      while (!v29);
      BOOL v19 = v29 == 1;
      if (v25) {
        (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
      }
    }
  }

  else
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_10184BF50);
    }
    uint64_t v20 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Data request failed because db is not accessible.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_10184BF50);
      }
      *(_WORD *)__int16 v46 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Data request failed because db is not accessible.",  v46,  2);
      std::string v32 = (char *)v31;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderDb::getSensorRecordMetaIds(CFAbsoluteTime, CFAbsoluteTime, NSMutableArray *)",  "%s\n",  v31);
      if (v32 != buf) {
        free(v32);
      }
    }

    BOOL v19 = 0LL;
  }

  (*(void (**)(uint64_t))(*(void *)v9 + 24LL))(v9);
  return v19;
}

void sub_1006F8754( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

uint64_t sub_1006F87EC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  v37[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v38 = 256;
  if (*(double *)(*(void *)(a2 + 8) - 16LL) != 0.0 && sub_100D8A92C(a1 + 72))
  {
    uint64_t v6 = *(void *)(a1 + 80);
    std::operator+<char>(&v34, "SELECT dataId FROM ", a1 + 432);
    uint64_t v7 = std::string::append(&v34, " WHERE startTime < ? ORDER BY dataId DESC LIMIT 1");
    __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    int64_t cap = v7->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 __p = v8;
    v7->__r_.__value_.__l.__size_ = 0LL;
    v7->__r_.__value_.__l.__cap_ = 0LL;
    v7->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      uint64_t v9 = (char *)__p;
    }
    else {
      uint64_t v9 = (char *)__p[0];
    }
    sub_1003C0D54(v6, v9, v37);
    uint64_t v10 = v37[0];
    v37[0] = 0LL;
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
    __int128 v11 = (sqlite3_stmt *)sub_100019240(v10);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    if (sub_1003B7480(v11, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
    {
      uint64_t v13 = (sqlite3_stmt *)sub_100019240(v10);
      if (sqlite3_step(v13) == 100)
      {
        uint64_t v14 = (sqlite3_stmt *)sub_100019240(v10);
        int v15 = sqlite3_column_int(v14, 0);
        if (v15 >= 1)
        {
          uint64_t v16 = *(void *)(a1 + 80);
          std::operator+<char>(&v34, "DELETE FROM ", a1 + 408);
          id v17 = std::string::append(&v34, " WHERE id < ?");
          __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          int64_t cap = v17->__r_.__value_.__l.__cap_;
          *(_OWORD *)__int128 __p = v18;
          v17->__r_.__value_.__l.__size_ = 0LL;
          v17->__r_.__value_.__l.__cap_ = 0LL;
          v17->__r_.__value_.__r.__words[0] = 0LL;
          if (cap >= 0) {
            BOOL v19 = (char *)__p;
          }
          else {
            BOOL v19 = (char *)__p[0];
          }
          sub_1003C0D54(v16, v19, v37);
          uint64_t v20 = v37[0];
          v37[0] = 0LL;
          if (SHIBYTE(cap) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v21 = (sqlite3_stmt *)sub_100019240(v20);
          if (sub_1003C2D24(v21, 1, v15))
          {
            sub_1003C0454(*(void *)(a1 + 80));
            uint64_t v22 = *(void *)(a1 + 80);
            __int128 v23 = (sqlite3_stmt *)sub_100019240(v20);
            sub_1003BB2BC(v22, v23);
            uint64_t v24 = *(void *)(a1 + 80);
            std::operator+<char>(&v34, "DELETE FROM ", a1 + 432);
            uint64_t v25 = std::string::append(&v34, " WHERE dataId < ?");
            __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
            int64_t cap = v25->__r_.__value_.__l.__cap_;
            *(_OWORD *)__int128 __p = v26;
            v25->__r_.__value_.__l.__size_ = 0LL;
            v25->__r_.__value_.__l.__cap_ = 0LL;
            v25->__r_.__value_.__r.__words[0] = 0LL;
            if (cap >= 0) {
              size_t v27 = (char *)__p;
            }
            else {
              size_t v27 = (char *)__p[0];
            }
            sub_1003C0D54(v24, v27, v37);
            uint64_t v28 = v37[0];
            v37[0] = 0LL;
            if (SHIBYTE(cap) < 0) {
              operator delete(__p[0]);
            }
            int v29 = (sqlite3_stmt *)sub_100019240(v28);
            BOOL v30 = sub_1003C2D24(v29, 1, v15);
            uint64_t v31 = *(void *)(a1 + 80);
            if (v30)
            {
              std::string v32 = (sqlite3_stmt *)sub_100019240(v28);
              sub_1003BB2BC(v31, v32);
              sub_1003C05BC(*(void *)(a1 + 80));
            }

            else
            {
              sub_1003C0E18(*(void *)(a1 + 80));
            }

            if (v28) {
              (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
            }
          }

          if (v20) {
            (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
          }
        }
      }
    }

    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return 0LL;
}

void sub_1006F8B30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
  }
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
  }
  sub_1011C52D0((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F8C38(uint64_t a1, uint64_t a2)
{
  return 0LL;
}

uint64_t sub_1006F8C54(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  v8[2] = (id)(a1 + 112);
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v9 = 256;
  sub_100222B94(v8, (uint64_t)"CLSensorRecorderDb::reduceFreePages", 0);
  sub_1003C0454(*(void *)(a1 + 80));
  uint64_t v6 = sub_1003C1EC0(*(void *)(a1 + 80), a2);
  sub_1003C05BC(*(void *)(a1 + 80));
  sub_1001BA1BC(v8);
  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v6;
}

void sub_1006F8CF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  id v3 = va_arg(va1, id);
  uint64_t v5 = va_arg(va1, void);
  sub_1001BA1BC((id *)va);
  sub_1011C52D0((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F8D38()
{
  return 0LL;
}

uint64_t sub_1006F8D40()
{
  return 2LL;
}

uint64_t sub_1006F8D4C(void *a1, uint64_t *a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v30);
  if ((SHIBYTE(v31) & 0x80000000) == 0)
  {
    if (HIBYTE(v31)) {
      goto LABEL_3;
    }
LABEL_24:
    sub_101245874(v10);
    goto LABEL_25;
  }

  uint64_t v4 = (std::stringbuf *)v30[1];
  operator delete(v30[0]);
  if (!v4) {
    goto LABEL_24;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v30);
  __int128 v11 = sub_10000CF44(&v31, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)p_p, size);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  uint64_t v15 = a1[10];
  uint64_t v4 = &v32;
  std::stringbuf::str(&__p, &v32);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v16 = &__p;
  }
  else {
    uint64_t v16 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v15, (char *)v16, &v28);
  uint64_t v5 = v28;
  uint64_t v28 = 0LL;
  uint64_t v29 = v5;
  id v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    __int128 v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      uint64_t v26 = 0LL;
      size_t v27 = 0LL;
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v29, (uint64_t)&__p);
        if ((_DWORD)v19) {
          break;
        }
        sub_1006FABB4(a2, (__int128 *)&__p);
      }

      uint64_t v20 = v27;
      if (v27)
      {
        p_shared_owners = (unint64_t *)&v27->__shared_owners_;
        do
          unint64_t v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }

      uint64_t v5 = v29;
      goto LABEL_32;
    }
  }

void sub_1006F8FC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1006F902C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v46 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184C278);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int16 v50 = 0;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = "";
      __int16 v51 = 2082;
      std::string::size_type v52 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184C278);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)buf = 134349056;
        *(void *)__int16 v50 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184C278);
        }
        uint64_t v41 = *(void *)(a1 + 216);
        int v47 = 134349056;
        uint64_t v48 = v41;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v47,  12);
        double v43 = (uint8_t *)v42;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLSensorRecorderDataPacket>::setDatabaseAccessible() [T = CLSensorRecorderDa taPacket, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v42);
        if (v43 != buf) {
          free(v43);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_70;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184C278);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)__int16 v50 = 0;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = "";
      __int16 v51 = 2082;
      std::string::size_type v52 = v11;
      __int16 v53 = 2049;
      uint64_t v54 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x66));
    unsigned int v45 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 40 * (v13 % 0x66);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x66)) + 40 * (v22 % 0x66);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10184C298);
      }
      uint64_t v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10184C298);
        }
        LOWORD(v47) = 0;
        LODWORD(v44) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v47,  v44);
        size_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLSensorRecorderDataPacket>::setDatabaseAccessible() [T = CLSensorRecorderDa taPacket, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 40LL;
      if (v17 - *v16 == 4080)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v45;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184C278);
    }
    __int128 v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int16 v50 = 0;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = "";
      __int16 v51 = 2082;
      std::string::size_type v52 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184C278);
      }
    }

    uint64_t v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v21 = (void *)(a1 + 88);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)__int16 v50 = 0;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = "";
      __int16 v51 = 2082;
      std::string::size_type v52 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  uint64_t v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void ***)(a1 + 192);
  if (v29 == v28)
  {
    BOOL v30 = (void *)(a1 + 216);
    uint64_t v29 = *(void ***)(a1 + 184);
  }

  else
  {
    BOOL v30 = (void *)(a1 + 216);
    unint64_t v31 = *(void *)(a1 + 208);
    std::stringbuf v32 = &v28[v31 / 0x66];
    unint64_t v33 = (unint64_t)*v32 + 40 * (v31 % 0x66);
    unint64_t v34 = (unint64_t)v28[(*(void *)(a1 + 216) + v31) / 0x66] + 40 * ((*(void *)(a1 + 216) + v31) % 0x66);
    if (v33 != v34)
    {
      do
      {
        sub_10000AE14(v33 + 24);
        v33 += 40LL;
        if (v33 - (void)*v32 == 4080)
        {
          unint64_t v35 = (unint64_t)v32[1];
          ++v32;
          unint64_t v33 = v35;
        }
      }

      while (v33 != v34);
      uint64_t v28 = *(void ***)(a1 + 184);
      uint64_t v29 = *(void ***)(a1 + 192);
    }
  }

  *BOOL v30 = 0LL;
  unint64_t v36 = (char *)v29 - (char *)v28;
  if (v36 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v37 = *(void *)(a1 + 192);
      uint64_t v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v36 = v37 - (void)v28;
    }

    while (v36 > 0x10);
  }

  if (v36 >> 3 == 1)
  {
    uint64_t v38 = 51LL;
  }

  else
  {
    if (v36 >> 3 != 2) {
      goto LABEL_68;
    }
    uint64_t v38 = 102LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v38;
LABEL_68:
  __int128 v39 = *(void **)(a1 + 144);
  if (v39)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_1006F97FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1006F9830(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v3 = *a3;
  *(_DWORD *)(a2 + 16) = *((_DWORD *)a3 + 4);
  *(_OWORD *)a2 = v3;
  return sub_1000F2F30((void *)(a2 + 24), (uint64_t *)a3 + 3);
}

id *sub_1006F984C(uint64_t *a1, __int128 *a2, char a3)
{
  v37[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v37[1] = 0LL;
  if (*((double *)a1 + 28) <= 0.0
    || !(*(unsigned int (**)(uint64_t *, uint64_t *, __int128 *))(*a1 + 136))(a1, a1 + 28, a2))
  {
    if ((a3 & 1) == 0) {
      sub_1003C0454(a1[10]);
    }
    v35[3] = 0.0;
    unint64_t v36 = 0LL;
    int v6 = (*(uint64_t (**)(uint64_t *, double *))(*a1 + 104))(a1, v35);
    if (v6 == 1)
    {
      (*(void (**)(uint64_t *, __int128 *, uint64_t))(*a1 + 120))(a1, a2, 1LL);
    }

    else
    {
      if (v6)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184C278);
        }
        uint64_t v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184C278);
          }
          LOWORD(v3_Block_object_dispose(va, 8) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v38,  2);
          uint64_t v16 = (uint8_t *)v15;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLSensorRecorderDataPacket>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSensorRecorderDataPacket, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
          if (v16 != buf) {
            free(v16);
          }
        }

void sub_1006F9FEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1006FA024(uint64_t a1)
{
  return sub_1006F902C(a1 - 72);
}

void sub_1006FA02C(id a1)
{
  qword_1019345F8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "SensorRecorder");
}

void sub_1006FA058(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    __int128 v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + _Block_object_dispose(va, 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + _Block_object_dispose(va, 8) = v4;
    a1[2] = 0LL;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_10000AE14((uint64_t)(v3 + 5));
        operator delete(v3);
        __int128 v3 = v5;
      }

      while (v5 != a1);
    }
  }

uint64_t sub_1006FA0C8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v5 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v30);
  if ((SHIBYTE(v31) & 0x80000000) == 0)
  {
    if (HIBYTE(v31)) {
      goto LABEL_3;
    }
LABEL_34:
    unint64_t v23 = (_Unwind_Exception *)sub_1012459E4(v5);
    sub_10000AE14(v2);
    uint64_t v24 = v29;
    uint64_t v29 = 0LL;
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    }
    sub_1011F8850((uint64_t)v30);
    _Unwind_Resume(v23);
  }

  unint64_t v22 = v30[1];
  operator delete(v30[0]);
  if (!v22) {
    goto LABEL_34;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    uint64_t v8 = *a2;
    uint64_t v7 = a2[1];
    if (v7 != *a2)
    {
      do
      {
        uint64_t v9 = v7 - 40;
        sub_10000AE14(v7 - 16);
        uint64_t v7 = v9;
      }

      while (v9 != v8);
    }

    a2[1] = v8;
    sub_10000CE18((uint64_t)v30);
    uint64_t v10 = sub_10000CF44(&v31, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t *))(*a1 + 64))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v13 = sub_10000CF44(v10, (uint64_t)p_p, size);
    sub_10000CF44(v13, (uint64_t)" ORDER BY id ASC", 16LL);
    uint64_t v14 = a1[10];
    std::stringbuf::str(&__p, &v32);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v15 = &__p;
    }
    else {
      uint64_t v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v14, (char *)v15, &v28);
    uint64_t v16 = v28;
    uint64_t v28 = 0LL;
    uint64_t v29 = v16;
    sub_1003C0454(a1[10]);
    uint64_t v26 = 0LL;
    size_t v27 = 0LL;
    sub_1003C05BC(a1[10]);
    double v17 = v27;
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        unint64_t v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }

    uint64_t v20 = v29;
    uint64_t v29 = 0LL;
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    }
    *(void **)((char *)v30
    uint64_t v31 = v21;
    std::streambuf::~streambuf(&v32);
    return std::ios::~ios(&v33);
  }

  return result;
}

uint64_t sub_1006FA388(void *a1, double *a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    uint64_t v20 = (_Unwind_Exception *)sub_101245B54(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  unint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, double *, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v11 = &__p;
    }
    else {
      double v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_1006FA5E8(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101245CC4(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v11 = &__p;
    }
    else {
      double v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_1006FA820(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101245E34(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_1006FAA48(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_1006FAA74(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  __int128 v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    __int128 v3 = (void **)a1[1];
  }

  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    int v6 = &v2[v5 / 0x66];
    unint64_t v7 = (unint64_t)*v6 + 40 * (v5 % 0x66);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x66] + 40 * ((a1[5] + v5) % 0x66);
    if (v7 != v8)
    {
      do
      {
        sub_10000AE14(v7 + 24);
        v7 += 40LL;
        if (v7 - (void)*v6 == 4080)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }

      while (v7 != v8);
      uint64_t v2 = (void **)a1[1];
      __int128 v3 = (void **)a1[2];
    }
  }

  *uint64_t v4 = 0LL;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      __int128 v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 51LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 102LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

uint64_t sub_1006FABB4(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0x666666666666666LL) {
      sub_100007008();
    }
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x333333333333333LL) {
      unint64_t v16 = 0x666666666666666LL;
    }
    else {
      unint64_t v16 = v14;
    }
    _DWORD v24[4] = result;
    uint64_t v17 = (char *)sub_100100EF8(result, v16);
    uint64_t v18 = &v17[40 * v13];
    v24[0] = v17;
    v24[1] = v18;
    v24[3] = &v17[40 * v19];
    int v20 = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v18 = *a2;
    *((_DWORD *)v18 + 4) = v20;
    *((void *)v18 + 3) = *((void *)a2 + 3);
    uint64_t v21 = *((void *)a2 + 4);
    *((void *)v18 + 4) = v21;
    if (v21)
    {
      uint64_t v22 = (unint64_t *)(v21 + 8);
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    _OWORD v24[2] = v18 + 40;
    sub_1006FAD20(a1, v24);
    uint64_t v12 = a1[1];
    uint64_t result = sub_1006FADA8((uint64_t)v24);
  }

  else
  {
    __int128 v8 = *a2;
    *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 4);
    *(_OWORD *)unint64_t v7 = v8;
    *(void *)(v7 + sub_10000AE14(v9 + 24) = *((void *)a2 + 3);
    uint64_t v9 = *((void *)a2 + 4);
    *(void *)(v7 + 32) = v9;
    if (v9)
    {
      unint64_t v10 = (unint64_t *)(v9 + 8);
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    uint64_t v12 = v7 + 40;
    a1[1] = v7 + 40;
  }

  a1[1] = v12;
  return result;
}

void sub_1006FAD0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_1006FAD20(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }

  else
  {
    do
    {
      uint64_t v5 = v4 - 40;
      __int128 v6 = *(_OWORD *)(v3 - 40);
      *(_DWORD *)(v4 - sub_10000AE14(v9 + 24) = *(_DWORD *)(v3 - 24);
      *(_OWORD *)(v4 - 40) = v6;
      *(_OWORD *)(v4 - 16) = *(_OWORD *)(v3 - 16);
      *(void *)(v3 - 16) = 0LL;
      *(void *)(v3 - _Block_object_dispose(va, 8) = 0LL;
      v3 -= 40LL;
      v4 -= 40LL;
    }

    while (v3 != v2);
  }

  a2[1] = v5;
  uint64_t v7 = *result;
  *uint64_t result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1006FADA8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    sub_10000AE14(i - 16);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1006FADF8(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

BOOL sub_1006FAE24(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  if (*a1 == v4)
  {
    double v14 = 0.0;
    double v25 = 2.22044605e-16;
    double v114 = 2.22044605e-16;
    double v12 = 0.0;
    double v8 = 0.0;
    double v5 = 0.0;
    double v24 = 2.22044605e-16;
    double v26 = 0.0;
  }

  else
  {
    double v5 = 0.0;
    unint64_t v6 = -1LL;
    double v7 = 0.0;
    double v8 = 0.0;
    double v9 = 0.0;
    uint64_t v10 = *a1;
    double v11 = 0.0;
    double v12 = 0.0;
    double v13 = 0.0;
    double v14 = 0.0;
    do
    {
      double v15 = *(float *)(v10 + 16);
      double v16 = v15 - v5;
      double v17 = (double)(v6 + 2);
      double v5 = v5 + (v15 - v5) / v17;
      double v7 = v7 + v16 * (v15 - v5);
      double v18 = *(double *)(v10 + 24);
      double v19 = *(double *)(v10 + 32);
      double v20 = v18 - v8;
      double v8 = v8 + (v18 - v8) / v17;
      double v9 = v9 + v20 * (v18 - v8);
      double v21 = v19 - v14;
      double v14 = v14 + (v19 - v14) / v17;
      double v13 = v13 + v21 * (v19 - v14);
      double v22 = *(double *)(v10 + 40);
      double v23 = v22 - v12;
      double v12 = v12 + (v22 - v12) / v17;
      double v11 = v11 + v23 * (v22 - v12);
      v10 += 72LL;
      ++v6;
    }

    while (v10 != v4);
    if (v6)
    {
      double v114 = sqrt(v7 / (double)v6) + 2.22044605e-16;
      double v24 = sqrt(v9 / (double)v6) + 2.22044605e-16;
      double v25 = sqrt(v13 / (double)v6) + 2.22044605e-16;
      double v26 = v11 / (double)v6;
    }

    else
    {
      double v26 = 0.0;
      double v25 = 2.22044605e-16;
      double v114 = 2.22044605e-16;
      double v24 = 2.22044605e-16;
    }
  }

  sub_1003F7EE4(v120, 0x8E38E38E38E38E39LL * ((v4 - *a1) >> 3));
  uint64_t v112 = a2;
  uint64_t v27 = *a1;
  uint64_t v28 = a1[1];
  if (*a1 != v28)
  {
    uint64_t v29 = 0LL;
    double v30 = sqrt(v26) + 2.22044605e-16;
    do
    {
      uint64_t v31 = v120[0] + 24 * v29;
      double v32 = (*(float *)(v27 + 16) - v5) / v114;
      double v34 = (double **)(v31 + 8);
      uint64_t v33 = *(double **)(v31 + 8);
      unint64_t v36 = (void *)(v31 + 16);
      unint64_t v35 = *(void *)(v31 + 16);
      if ((unint64_t)v33 >= v35)
      {
        int v38 = *(double **)v31;
        uint64_t v39 = ((uint64_t)v33 - *(void *)v31) >> 3;
        unint64_t v40 = v39 + 1;
        uint64_t v41 = v35 - (void)v38;
        if (v41 >> 2 > v40) {
          unint64_t v40 = v41 >> 2;
        }
        else {
          unint64_t v42 = v40;
        }
        if (v42)
        {
          double v43 = (char *)sub_1000071BC((uint64_t)v36, v42);
          uint64_t v33 = *v34;
          int v38 = *(double **)v31;
        }

        else
        {
          double v43 = 0LL;
        }

        __int16 v44 = (double *)&v43[8 * v39];
        double *v44 = v32;
        uint64_t v37 = v44 + 1;
        while (v33 != v38)
        {
          uint64_t v45 = *((void *)v33-- - 1);
          *((void *)v44-- - 1) = v45;
        }

        *(void *)uint64_t v31 = v44;
        *double v34 = v37;
        *unint64_t v36 = &v43[8 * v42];
        if (v38) {
          operator delete(v38);
        }
      }

      else
      {
        *uint64_t v33 = v32;
        uint64_t v37 = v33 + 1;
      }

      *double v34 = v37;
      uint64_t v46 = v120[0] + 24 * v29;
      double v47 = (*(double *)(v27 + 24) - v8) / v24;
      std::string::size_type v49 = (double **)(v46 + 8);
      uint64_t v48 = *(double **)(v46 + 8);
      __int16 v51 = (void *)(v46 + 16);
      unint64_t v50 = *(void *)(v46 + 16);
      if ((unint64_t)v48 >= v50)
      {
        __int16 v53 = *(double **)v46;
        uint64_t v54 = ((uint64_t)v48 - *(void *)v46) >> 3;
        unint64_t v55 = v54 + 1;
        uint64_t v56 = v50 - (void)v53;
        if (v56 >> 2 > v55) {
          unint64_t v55 = v56 >> 2;
        }
        else {
          unint64_t v57 = v55;
        }
        if (v57)
        {
          __int128 v58 = (char *)sub_1000071BC((uint64_t)v51, v57);
          uint64_t v48 = *v49;
          __int16 v53 = *(double **)v46;
        }

        else
        {
          __int128 v58 = 0LL;
        }

        __int128 v59 = (double *)&v58[8 * v54];
        *__int128 v59 = v47;
        std::string::size_type v52 = v59 + 1;
        while (v48 != v53)
        {
          uint64_t v60 = *((void *)v48-- - 1);
          *((void *)v59-- - 1) = v60;
        }

        *(void *)uint64_t v46 = v59;
        *std::string::size_type v49 = v52;
        *__int16 v51 = &v58[8 * v57];
        if (v53) {
          operator delete(v53);
        }
      }

      else
      {
        *uint64_t v48 = v47;
        std::string::size_type v52 = v48 + 1;
      }

      *std::string::size_type v49 = v52;
      uint64_t v61 = v120[0] + 24 * v29;
      double v62 = (*(double *)(v27 + 32) - v14) / v25;
      std::string v64 = (double **)(v61 + 8);
      __int128 v63 = *(double **)(v61 + 8);
      __int16 v66 = (void *)(v61 + 16);
      unint64_t v65 = *(void *)(v61 + 16);
      if ((unint64_t)v63 >= v65)
      {
        unsigned __int8 v68 = *(double **)v61;
        uint64_t v69 = ((uint64_t)v63 - *(void *)v61) >> 3;
        unint64_t v70 = v69 + 1;
        uint64_t v71 = v65 - (void)v68;
        if (v71 >> 2 > v70) {
          unint64_t v70 = v71 >> 2;
        }
        else {
          unint64_t v72 = v70;
        }
        if (v72)
        {
          size_t v73 = (char *)sub_1000071BC((uint64_t)v66, v72);
          __int128 v63 = *v64;
          unsigned __int8 v68 = *(double **)v61;
        }

        else
        {
          size_t v73 = 0LL;
        }

        v74 = (double *)&v73[8 * v69];
        double *v74 = v62;
        std::string::size_type v67 = v74 + 1;
        while (v63 != v68)
        {
          uint64_t v75 = *((void *)v63-- - 1);
          *((void *)v74-- - 1) = v75;
        }

        *(void *)uint64_t v61 = v74;
        *std::string v64 = v67;
        *__int16 v66 = &v73[8 * v72];
        if (v68) {
          operator delete(v68);
        }
      }

      else
      {
        *__int128 v63 = v62;
        std::string::size_type v67 = v63 + 1;
      }

      *std::string v64 = v67;
      uint64_t v76 = v120[0] + 24 * v29;
      double v77 = (*(double *)(v27 + 40) - v12) / v30;
      id v79 = (double **)(v76 + 8);
      signed __int8 v78 = *(double **)(v76 + 8);
      int v81 = (void *)(v76 + 16);
      unint64_t v80 = *(void *)(v76 + 16);
      if ((unint64_t)v78 >= v80)
      {
        size_t v83 = *(double **)v76;
        uint64_t v84 = ((uint64_t)v78 - *(void *)v76) >> 3;
        unint64_t v85 = v84 + 1;
        uint64_t v86 = v80 - (void)v83;
        if (v86 >> 2 > v85) {
          unint64_t v85 = v86 >> 2;
        }
        else {
          unint64_t v87 = v85;
        }
        if (v87)
        {
          v88 = (char *)sub_1000071BC((uint64_t)v81, v87);
          signed __int8 v78 = *v79;
          size_t v83 = *(double **)v76;
        }

        else
        {
          v88 = 0LL;
        }

        __int128 v89 = (double *)&v88[8 * v84];
        *__int128 v89 = v77;
        std::string::size_type v82 = v89 + 1;
        while (v78 != v83)
        {
          uint64_t v90 = *((void *)v78-- - 1);
          *((void *)v89-- - 1) = v90;
        }

        *(void *)uint64_t v76 = v89;
        *id v79 = v82;
        *int v81 = &v88[8 * v87];
        if (v83) {
          operator delete(v83);
        }
      }

      else
      {
        *signed __int8 v78 = v77;
        std::string::size_type v82 = v78 + 1;
      }

      *id v79 = v82;
      ++v29;
      v27 += 72LL;
    }

    while (v27 != v28);
  }

  sub_1003F7EE4(&v118, 4uLL);
  uint64_t v91 = v118;
  uint64_t v115 = v119;
  if (v118 != v119)
  {
    int v92 = 0;
    uint64_t v93 = v120[0];
    unint64_t v113 = (0xAAAAAAAAAAAAAAABLL * ((v120[1] - v120[0]) >> 3) - 1) >> 2;
    uint64_t v94 = *(void *)v120[0];
    do
    {
      ++v92;
      if (*(void *)(v93 + 8) != v94)
      {
        unint64_t v95 = 0LL;
        v96 = (void *)(v91 + 16);
        int v97 = *(void **)(v91 + 8);
        do
        {
          uint64_t v98 = *(void *)(v93 + 24LL * (v92 * v113));
          if ((unint64_t)v97 >= *v96)
          {
            unsigned __int8 v100 = *(void **)v91;
            uint64_t v101 = ((uint64_t)v97 - *(void *)v91) >> 3;
            unint64_t v102 = v101 + 1;
            uint64_t v103 = *v96 - (void)v100;
            if (v103 >> 2 > v102) {
              unint64_t v102 = v103 >> 2;
            }
            else {
              unint64_t v104 = v102;
            }
            if (v104)
            {
              std::string::size_type v105 = (char *)sub_1000071BC(v91 + 16, v104);
              unsigned __int8 v100 = *(void **)v91;
              int v97 = *(void **)(v91 + 8);
            }

            else
            {
              std::string::size_type v105 = 0LL;
            }

            v106 = &v105[8 * v101];
            *(void *)v106 = *(void *)(v98 + 8 * v95);
            std::string::size_type v99 = v106 + 8;
            while (v97 != v100)
            {
              uint64_t v107 = *--v97;
              *((void *)v106 - 1) = v107;
              v106 -= 8;
            }

            *(void *)uint64_t v91 = v106;
            *(void *)(v91 + _Block_object_dispose(va, 8) = v99;
            *(void *)(v91 + 16) = &v105[8 * v104];
            if (v100) {
              operator delete(v100);
            }
          }

          else
          {
            *int v97 = *(void *)(v98 + 8 * v95);
            std::string::size_type v99 = v97 + 1;
          }

          *(void *)(v91 + _Block_object_dispose(va, 8) = v99;
          ++v95;
          uint64_t v93 = v120[0];
          uint64_t v94 = *(void *)v120[0];
          int v97 = v99;
        }

        while (v95 < (uint64_t)(*(void *)(v120[0] + 8LL) - *(void *)v120[0]) >> 3);
      }

      v91 += 24LL;
    }

    while (v91 != v115);
  }

  memset(v117, 0, sizeof(v117));
  BOOL v108 = sub_100008E60((uint64_t)buf, (uint64_t)&v118, (uint64_t)v120, 4u, v117, v112);
  if (!v108)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184C2D0);
    }
    __int128 v109 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "VO2Max,Clustering failed", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184C2D0);
      }
      __int16 v116 = 0;
      __int128 v111 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "VO2Max,Clustering failed",  &v116,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLVO2MaxModel::deriveClusters(const std::vector<VO2MaxModelInput> &, std::vector<uint32_t> &)",  "%s\n",  v111);
    }
  }

  *(void *)buf = v117;
  sub_100006BC8((void ***)buf);
  *(void *)buf = &v118;
  sub_100006BC8((void ***)buf);
  *(void *)buf = v120;
  sub_100006BC8((void ***)buf);
  return v108;
}

void sub_1006FB678( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, void **a25)
{
  a25 = (void **)&a16;
  sub_100006BC8(&a25);
  a25 = (void **)&a19;
  sub_100006BC8(&a25);
  a25 = (void **)&a22;
  sub_100006BC8(&a25);
  _Unwind_Resume(a1);
}

void sub_1006FB6F8(uint64_t *a1, __n128 a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (*a1 != v2)
  {
    a2.n128_u64[0] = 134222336LL;
    __n128 v43 = a2;
    do
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184C2D0);
      }
      uint64_t v4 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(v3 + 8);
        uint64_t v6 = *(void *)(v3 + 40);
        uint64_t v7 = *(void *)(v3 + 48);
        uint64_t v8 = *(void *)(v3 + 56);
        uint64_t v9 = *(void *)(v3 + 64);
        uint64_t v10 = *(void *)(v3 + 72);
        uint64_t v11 = *(void *)(v3 + 80);
        uint64_t v12 = *(void *)(v3 + 88);
        uint64_t v13 = *(void *)(v3 + 96);
        uint64_t v15 = *(void *)(v3 + 104);
        uint64_t v14 = *(void *)(v3 + 112);
        uint64_t v17 = *(void *)(v3 + 128);
        uint64_t v16 = *(void *)(v3 + 136);
        uint64_t v18 = *(void *)(v3 + 152);
        uint64_t v19 = *(void *)(v3 + 160);
        uint64_t v20 = *(void *)(v3 + 168);
        uint64_t v21 = *(void *)(v3 + 120);
        int v22 = *(_DWORD *)(v3 + 176);
        *(_DWORD *)buf = v43.n128_u32[0];
        uint64_t v81 = v5;
        __int16 v82 = 2048;
        uint64_t v83 = v6;
        __int16 v84 = 2048;
        uint64_t v85 = v7;
        __int16 v86 = 2048;
        uint64_t v87 = v8;
        __int16 v88 = 2048;
        uint64_t v89 = v9;
        __int16 v90 = 2048;
        uint64_t v91 = v10;
        __int16 v92 = 2048;
        uint64_t v93 = v11;
        __int16 v94 = 2048;
        uint64_t v95 = v12;
        __int16 v96 = 2048;
        uint64_t v97 = v13;
        __int16 v98 = 2048;
        uint64_t v99 = v15;
        __int16 v100 = 2048;
        uint64_t v101 = v14;
        __int16 v102 = 2048;
        uint64_t v103 = v17;
        __int16 v104 = 2048;
        uint64_t v105 = v16;
        __int16 v106 = 2048;
        uint64_t v107 = v18;
        __int16 v108 = 2048;
        uint64_t v109 = v19;
        __int16 v110 = 2048;
        uint64_t v111 = v20;
        __int16 v112 = 2048;
        uint64_t v113 = v21;
        __int16 v114 = 1024;
        int v115 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "AlgoName,AdaptiveOutdoorPedestrianModel,ts,%.9f,duration,%.9f,size,%lld,hr min.,%f,hr max.,%f,hrMean,%f,hrConf Mean,%f,hrCadenceMean,%f,vo2Mean,%f,speedMean,%f,gradeMean,%f,hrVariance,%f,hrConfVariance,%f,vo2Variance,%f,s peedVariance,%f,gradeVariance,%f,cadenceMean,%f,vo2MaxModelSource,%d",  buf,  0xB2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10184C2D0);
        }
        uint64_t v23 = *(void *)(v3 + 8);
        uint64_t v24 = *(void *)(v3 + 40);
        uint64_t v25 = *(void *)(v3 + 48);
        uint64_t v26 = *(void *)(v3 + 56);
        uint64_t v27 = *(void *)(v3 + 64);
        uint64_t v28 = *(void *)(v3 + 72);
        uint64_t v29 = *(void *)(v3 + 80);
        uint64_t v30 = *(void *)(v3 + 88);
        uint64_t v31 = *(void *)(v3 + 96);
        uint64_t v33 = *(void *)(v3 + 104);
        uint64_t v32 = *(void *)(v3 + 112);
        uint64_t v35 = *(void *)(v3 + 128);
        uint64_t v34 = *(void *)(v3 + 136);
        uint64_t v36 = *(void *)(v3 + 152);
        uint64_t v37 = *(void *)(v3 + 160);
        uint64_t v38 = *(void *)(v3 + 168);
        uint64_t v39 = *(void *)(v3 + 120);
        int v40 = *(_DWORD *)(v3 + 176);
        unsigned __int32 v44 = v43.n128_u32[0];
        uint64_t v45 = v23;
        __int16 v46 = 2048;
        uint64_t v47 = v24;
        __int16 v48 = 2048;
        uint64_t v49 = v25;
        __int16 v50 = 2048;
        uint64_t v51 = v26;
        __int16 v52 = 2048;
        uint64_t v53 = v27;
        __int16 v54 = 2048;
        uint64_t v55 = v28;
        __int16 v56 = 2048;
        uint64_t v57 = v29;
        __int16 v58 = 2048;
        uint64_t v59 = v30;
        __int16 v60 = 2048;
        uint64_t v61 = v31;
        __int16 v62 = 2048;
        uint64_t v63 = v33;
        __int16 v64 = 2048;
        uint64_t v65 = v32;
        __int16 v66 = 2048;
        uint64_t v67 = v35;
        __int16 v68 = 2048;
        uint64_t v69 = v34;
        __int16 v70 = 2048;
        uint64_t v71 = v36;
        __int16 v72 = 2048;
        uint64_t v73 = v37;
        __int16 v74 = 2048;
        uint64_t v75 = v38;
        __int16 v76 = 2048;
        uint64_t v77 = v39;
        __int16 v78 = 1024;
        int v79 = v40;
        LODWORD(v42) = 178;
        uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "AlgoName,AdaptiveOutdoorPedestrianModel,ts,%.9f,duration,%.9f,size,%lld,hr min.,%f,hr max.,%f,hr Mean,%f,hrConfMean,%f,hrCadenceMean,%f,vo2Mean,%f,speedMean,%f,gradeMean,%f,hrVariance,%f,hrConf Variance,%f,vo2Variance,%f,speedVariance,%f,gradeVariance,%f,cadenceMean,%f,vo2MaxModelSource,%d",  COERCE_DOUBLE(&v44),  v42,  v43.n128_u64[0],  v43.n128_f64[1]);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxModel::logClusters(std::vector<VO2MaxSummary> &)",  "%s\n",  v41);
      }

      v3 += 184LL;
    }

    while (v3 != v2);
  }

uint64_t sub_1006FBA44(uint64_t result, void *a2, int a3)
{
  *(void *)uint64_t result = *a2;
  *(_DWORD *)(result + _Block_object_dispose(va, 8) = a3;
  return result;
}

void sub_1006FBA54( float *a1, uint64_t *a2, __int128 **a3, uint64_t a4, uint64_t a5, float a6, double a7, double a8)
{
  std::stringbuf::string_type __p = 0LL;
  __int16 v50 = 0LL;
  uint64_t v51 = 0LL;
  if (*(void *)(a5 + 48) == *(void *)(a5 + 40)) {
    uint64_t v15 = 4294967287LL;
  }
  else {
    uint64_t v15 = sub_1006FC874(v14, a3, (char **)(a5 + 40), &__p, a8);
  }
  *(_DWORD *)(a5 + 2_Block_object_dispose(va, 8) = v15;
  if (*(_DWORD *)(a5 + 24)) {
    BOOL v16 = (_DWORD)v15 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    *(void *)a5 = 0xBFF0000000000000LL;
    goto LABEL_16;
  }

  double v48 = 0.0;
  if (!sub_1006FCBC8(v15, (double **)&__p, &v48))
  {
    int v18 = -7;
    goto LABEL_13;
  }

  double v17 = v48;
  *(double *)(a5 + 64) = v48;
  if (a7 == 0.0)
  {
    int v18 = -8;
LABEL_13:
    int v19 = *(_DWORD *)(a5 + 24);
    if (!v19) {
      int v19 = v18;
    }
    *(_DWORD *)(a5 + sub_10000AE14(v9 + 24) = v19;
    *(_DWORD *)(a5 + 2_Block_object_dispose(va, 8) = v18;
    goto LABEL_16;
  }

  int v20 = *(_DWORD *)(a4 + 4);
  double v21 = 0.5;
  if (v20 == 2) {
    double v21 = 0.0;
  }
  if (v20 == 1) {
    double v21 = 1.0;
  }
  double v22 = (float)((float)(*(float *)(a4 + 20) * -0.0007) + 0.1935)
      + v21 * -0.0277999993
      + (float)((float)(*(float *)(a4 + 12) * -0.0015) / (float)(*(float *)(a4 + 8) * *(float *)(a4 + 8)))
      + a7 * 0.00520000001
      + v17 * 0.00540000014;
  double v23 = v22 * a1[1];
  *(double *)(a5 + _Block_object_dispose(va, 8) = v23;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184C2D0);
  }
  uint64_t v24 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    double v25 = *(float *)(a4 + 20);
    int v26 = *(unsigned __int8 *)(a4 + 4);
    double v27 = *(float *)(a4 + 8);
    double v28 = *(float *)(a4 + 12);
    uint64_t v29 = *(void *)(a5 + 8);
    *(_DWORD *)buf = 134285569;
    double v71 = v25;
    __int16 v72 = 1025;
    int v73 = v26;
    __int16 v74 = 2049;
    double v75 = v27;
    __int16 v76 = 2049;
    double v77 = v28;
    __int16 v78 = 2049;
    double v79 = a7;
    __int16 v80 = 2049;
    double v81 = v17;
    __int16 v82 = 2049;
    uint64_t v83 = v29;
    __int16 v84 = 2049;
    double v85 = v22 * 0.959999979 + 0.00659999996;
    __int16 v86 = 2049;
    double v87 = v22 * 0.330000013 + -0.023;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "VO2Max,AdaptiveOutdoorPedestrianModel,ComputePriors,age,%{private}f,biologicalSex,%{private}u,height,%{private}f,w eight,%{private}f,maxMets,%{private}f,efficiency,%{private}f,priorVO2Max,%{private}f,modelPriorCoefficient_a,%{pri vate}f,modelPriorCoefficient_b,%{private}f",  buf,  0x58u);
  }

  uint64_t v30 = sub_1002921D0(115, 2);
  if ((_DWORD)v30)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184C2D0);
    }
    double v42 = *(float *)(a4 + 20);
    int v43 = *(unsigned __int8 *)(a4 + 4);
    double v44 = *(float *)(a4 + 8);
    double v45 = *(float *)(a4 + 12);
    uint64_t v46 = *(void *)(a5 + 8);
    int v52 = 134285569;
    double v53 = v42;
    __int16 v54 = 1025;
    int v55 = v43;
    __int16 v56 = 2049;
    double v57 = v44;
    __int16 v58 = 2049;
    double v59 = v45;
    __int16 v60 = 2049;
    double v61 = a7;
    __int16 v62 = 2049;
    double v63 = v17;
    __int16 v64 = 2049;
    uint64_t v65 = v46;
    __int16 v66 = 2049;
    double v67 = v22 * 0.959999979 + 0.00659999996;
    __int16 v68 = 2049;
    double v69 = v22 * 0.330000013 + -0.023;
    uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "VO2Max,AdaptiveOutdoorPedestrianModel,ComputePriors,age,%{private}f,biologicalSex,%{private}u,height ,%{private}f,weight,%{private}f,maxMets,%{private}f,efficiency,%{private}f,priorVO2Max,%{private}f,m odelPriorCoefficient_a,%{private}f,modelPriorCoefficient_b,%{private}f",  &v52,  88);
    uint64_t v30 = sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::estimateVO2Max(const std::vector<VO2MaxModelInput> &, co nst std::vector<VO2MaxSummary> &, float, const CLBodyMetrics &, double, CLVO2MaxModel::Result &, CFAbsoluteTime) const",  "%s\n",  v47);
  }

  if (!*(_DWORD *)(a5 + 24))
  {
    v31.n128_f64[0] = v22;
    sub_1006FD280(a1, (void *)(a5 + 40), (int *)buf, v31, v23, 1.79769313e308);
    *(double *)(a5 + 16) = v32;
    if (v32 == -1.0) {
      int v33 = -6;
    }
    else {
      int v33 = 0;
    }
    *(_DWORD *)(a5 + sub_10000AE14(v9 + 24) = v33;
  }

  if (__p != v50)
  {
    double v34 = 0.0;
    double v35 = 0.0;
    uint64_t v36 = (double *)__p;
    do
    {
      double v34 = v34 + v36[9];
      double v35 = v35 + v36[12] / 3.5;
      v36 += 23;
    }

    while (v36 != (double *)v50);
    double v37 = (double)(0xD37A6F4DE9BD37A7LL * ((v50 - (_BYTE *)__p) >> 3));
    *(double *)(a5 + 72) = v34 / v37;
    *(double *)(a5 + 80) = v35 / v37;
  }

  *(_DWORD *)buf = 0;
  double v38 = sub_1006FCE4C(v22, a8, v30, (double **)a3);
  v39.n128_f64[0] = v22;
  sub_1006FD280(a1, &__p, (int *)buf, v39, v23, v38);
  *(double *)a5 = v40;
  if (v40 == -1.0)
  {
    int v41 = -6;
  }

  else
  {
    int v41 = 0;
    *(_DWORD *)(a5 + 32) = *(_DWORD *)buf;
  }

  *(_DWORD *)(a5 + 2_Block_object_dispose(va, 8) = v41;
LABEL_16:
  if (__p)
  {
    __int16 v50 = __p;
    operator delete(__p);
  }

void sub_1006FBF98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006FBFC4(uint64_t a1, uint64_t a2, uint64_t *a3, float a4)
{
  if (a4 > 20.0 || 0x8E38E38E38E38E39LL * ((a3[1] - *a3) >> 3) <= 0x31)
  {
    *(_DWORD *)(a2 + sub_10000AE14(v9 + 24) = -1;
    return;
  }

  v125 = 0LL;
  char v126 = 0LL;
  uint64_t v127 = 0LL;
  if (sub_1006FAE24(a3, (uint64_t)&v125))
  {
    sub_1006FDBC8(v124, 4uLL);
    sub_1006FDBC8(v123, 4uLL);
    sub_1006FDBC8(v122, 4uLL);
    sub_1006FDBC8(v121, 4uLL);
    sub_1006FDBC8(v120, 4uLL);
    sub_1006FDBC8(v119, 4uLL);
    uint64_t v8 = v125;
    uint64_t v9 = v126;
    if (v125 != v126)
    {
      unsigned int v10 = 0;
      uint64_t v11 = *a3;
      unint64_t v12 = 0x8E38E38E38E38E39LL * ((a3[1] - *a3) >> 3);
      uint64_t v13 = (char *)v124[0];
      int v14 = (char *)v123[0];
      uint64_t v15 = (char *)v122[0];
      BOOL v16 = (char *)v121[0];
      double v17 = (char *)v120[0];
      int v18 = (char *)v119[0];
      do
      {
        uint64_t v19 = *v8;
        if (v19 >= 4 && v12 <= v10)
        {
          sub_101245FA4();
          abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Motion/FunctionalCapacity/VO2Max/Models/CLVO2MaxAd aptiveOutdoorPedestrianModel.mm",  336,  "populateClusters");
          __break(1u);
        }

        uint64_t v21 = 3 * v19;
        double v22 = (double *)&v13[8 * v21];
        uint64_t v23 = v11 + 72LL * v10;
        double v24 = *(float *)(v23 + 16);
        double v25 = v22[1];
        double v26 = v22[2];
        double v27 = v24 - v25;
        uint64_t v28 = *(void *)v22 + 1LL;
        *(void *)double v22 = v28;
        double v29 = v25 + (v24 - v25) / (double)(unint64_t)v28;
        v22[1] = v29;
        v22[2] = v26 + v27 * (v24 - v29);
        uint64_t v30 = (double *)&v14[8 * v21];
        double v31 = *(float *)(v23 + 20);
        double v32 = v30[1];
        double v33 = v30[2];
        double v34 = v31 - v32;
        uint64_t v35 = *(void *)v30 + 1LL;
        *(void *)uint64_t v30 = v35;
        double v36 = v32 + (v31 - v32) / (double)(unint64_t)v35;
        v30[1] = v36;
        v30[2] = v33 + v34 * (v31 - v36);
        double v37 = (double *)&v15[8 * v21];
        double v38 = *(double *)(v23 + 24);
        double v39 = v37[1];
        double v40 = v37[2];
        double v41 = v38 - v39;
        uint64_t v42 = *(void *)v37 + 1LL;
        *(void *)double v37 = v42;
        double v43 = v39 + (v38 - v39) / (double)(unint64_t)v42;
        v37[1] = v43;
        id v37[2] = v40 + v41 * (v38 - v43);
        double v44 = (double *)&v16[8 * v21];
        double v45 = *(double *)(v23 + 32);
        double v46 = v44[1];
        double v47 = v44[2];
        double v48 = v45 - v46;
        uint64_t v49 = *(void *)v44 + 1LL;
        *(void *)double v44 = v49;
        double v50 = v46 + (v45 - v46) / (double)(unint64_t)v49;
        v44[1] = v50;
        v44[2] = v47 + v48 * (v45 - v50);
        uint64_t v51 = (double *)&v17[8 * v21];
        double v52 = *(double *)(v23 + 48);
        double v53 = v51[1];
        double v54 = v51[2];
        double v55 = v52 - v53;
        uint64_t v56 = *(void *)v51 + 1LL;
        *(void *)uint64_t v51 = v56;
        double v57 = v53 + (v52 - v53) / (double)(unint64_t)v56;
        v51[1] = v57;
        v51[2] = v54 + v55 * (v52 - v57);
        __int16 v58 = (double *)&v18[8 * v21];
        double v59 = *(double *)(v23 + 56);
        double v60 = v58[1];
        double v61 = v58[2];
        double v62 = v59 - v60;
        uint64_t v63 = *(void *)v58 + 1LL;
        double v64 = v60 + (v59 - v60) / (double)(unint64_t)v63;
        *(void *)__int16 v58 = v63;
        v58[1] = v64;
        v58[2] = v61 + v62 * (v59 - v64);
        ++v10;
        ++v8;
      }

      while (v8 != v9);
    }

    unint64_t v65 = 0LL;
    uint64_t v66 = 0LL;
    double v110 = *(double *)(a3[1] - 72) - *(double *)*a3;
    uint64_t v111 = *(void *)(a3[1] - 72);
    float v67 = *(float *)a1;
    float v68 = *(float *)(a1 + 4);
    std::stringbuf::string_type __p = 0LL;
    __int128 v117 = 0LL;
    uint64_t v118 = 0LL;
    double v69 = v67;
    v7.n128_f64[0] = v68;
    double v108 = v68;
    double v109 = v69;
    do
    {
      unint64_t v70 = *((void *)v124[0] + 3 * v66);
      if (v70)
      {
        __int128 v128 = 0uLL;
        double v71 = *((double *)v124[0] + 3 * v66 + 1);
        double v72 = *((double *)v119[0] + 3 * v66 + 1);
        double v73 = 1.0;
        if (v71 > 0.0 && v72 > 0.0)
        {
          double v74 = vabdd_f64(v71 / (v72 * 60.0), round(v71 / (v72 * 60.0)));
          double v75 = vabdd_f64(0.5, v74);
          if (v75 >= v74) {
            double v73 = v74;
          }
          else {
            double v73 = v75;
          }
        }

        double v76 = 0.0;
        double v77 = 0.0;
        if (v70 >= 2) {
          double v77 = *((double *)v124[0] + 3 * v66 + 2) / (double)(v70 - 1);
        }
        __int16 v78 = (char *)v120[0] + 24 * v66;
        if (*v78 >= 2uLL) {
          double v76 = *((double *)v120[0] + 3 * v66 + 2) / (double)(unint64_t)(*v78 - 1LL);
        }
        double v79 = (char *)v123[0] + 24 * v66;
        double v80 = 0.0;
        double v81 = 0.0;
        if (*v79 >= 2uLL) {
          double v81 = *((double *)v123[0] + 3 * v66 + 2) / (double)(unint64_t)(*v79 - 1LL);
        }
        double v112 = v77;
        double v113 = v76;
        double v114 = v73;
        uint64_t v115 = *((void *)v119[0] + 3 * v66 + 1);
        __int16 v82 = (char *)v122[0] + 24 * v66;
        if (*v82 >= 2uLL) {
          double v80 = *((double *)v122[0] + 3 * v66 + 2) / (double)(unint64_t)(*v82 - 1LL);
        }
        uint64_t v83 = (char *)v121[0] + 24 * v66;
        double v84 = 0.0;
        if (*v83 >= 2uLL) {
          double v84 = *((double *)v121[0] + 3 * v66 + 2) / (double)(unint64_t)(*v83 - 1LL);
        }
        uint64_t v85 = v78[1];
        uint64_t v86 = v79[1];
        uint64_t v87 = v82[1];
        uint64_t v88 = v83[1];
        int v89 = *(_DWORD *)(a1 + 8);
        if (v65 >= (unint64_t)v118)
        {
          unint64_t v90 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v65 - (void)__p) >> 3);
          unint64_t v91 = v90 + 1;
          if (v90 + 1 > 0x1642C8590B21642LL) {
            sub_100007008();
          }
          if (0xA6F4DE9BD37A6F4ELL * ((v118 - (_BYTE *)__p) >> 3) > v91) {
            unint64_t v91 = 0xA6F4DE9BD37A6F4ELL * ((v118 - (_BYTE *)__p) >> 3);
          }
          if (0xD37A6F4DE9BD37A7LL * ((v118 - (_BYTE *)__p) >> 3) >= 0xB21642C8590B21LL) {
            unint64_t v92 = 0x1642C8590B21642LL;
          }
          else {
            unint64_t v92 = v91;
          }
          if (v92) {
            uint64_t v93 = (char *)sub_1002DF6FC((uint64_t)&v118, v92);
          }
          else {
            uint64_t v93 = 0LL;
          }
          __int16 v94 = &v93[184 * v90];
          *(void *)__int16 v94 = 0LL;
          *((void *)v94 + 1) = v111;
          *((void *)v94 + 3) = 0LL;
          *((void *)v94 + 4) = 0LL;
          *((void *)v94 + 2) = 0LL;
          *((double *)v94 + 5) = v110;
          *((void *)v94 + 6) = v70;
          *((double *)v94 + 7) = v109;
          *((double *)v94 + _Block_object_dispose(va, 8) = v108;
          *((double *)v94 + 9) = v71;
          *((void *)v94 + 10) = v85;
          *((double *)v94 + 11) = v114;
          *((void *)v94 + 12) = v86;
          *((void *)v94 + 13) = v87;
          *((void *)v94 + 14) = v88;
          *((void *)v94 + 15) = v115;
          *((double *)v94 + 16) = v112;
          v7.n128_f64[0] = v113;
          *((double *)v94 + 17) = v113;
          *((void *)v94 + 1_Block_object_dispose(va, 8) = 0LL;
          *((double *)v94 + 19) = v81;
          *((double *)v94 + 20) = v80;
          *((double *)v94 + 21) = v84;
          *((_DWORD *)v94 + 44) = 1;
          *((_DWORD *)v94 + 45) = v89;
          __int16 v96 = (char *)__p;
          uint64_t v95 = v117;
          uint64_t v97 = v94;
          if (v117 != __p)
          {
            do
            {
              __int128 v98 = *(_OWORD *)(v95 - 184);
              __int128 v99 = *(_OWORD *)(v95 - 168);
              __int128 v100 = *(_OWORD *)(v95 - 152);
              *(_OWORD *)(v97 - 136) = *(_OWORD *)(v95 - 136);
              *(_OWORD *)(v97 - 152) = v100;
              *(_OWORD *)(v97 - 16_Block_object_dispose(va, 8) = v99;
              *(_OWORD *)(v97 - 184) = v98;
              __int128 v101 = *(_OWORD *)(v95 - 120);
              __int128 v102 = *(_OWORD *)(v95 - 104);
              __int128 v103 = *(_OWORD *)(v95 - 88);
              *(_OWORD *)(v97 - 72) = *(_OWORD *)(v95 - 72);
              *(_OWORD *)(v97 - 8_Block_object_dispose(va, 8) = v103;
              *(_OWORD *)(v97 - 104) = v102;
              *(_OWORD *)(v97 - 120) = v101;
              __n128 v7 = *(__n128 *)(v95 - 56);
              __int128 v104 = *(_OWORD *)(v95 - 40);
              __int128 v105 = *(_OWORD *)(v95 - 24);
              *((void *)v97 - 1) = *((void *)v95 - 1);
              *(_OWORD *)(v97 - sub_10000AE14(v9 + 24) = v105;
              *(_OWORD *)(v97 - 40) = v104;
              *(__n128 *)(v97 - 56) = v7;
              v97 -= 184;
              v95 -= 184;
            }

            while (v95 != v96);
            uint64_t v95 = v96;
          }

          unint64_t v65 = (unint64_t)(v94 + 184);
          std::stringbuf::string_type __p = v97;
          __int128 v117 = v94 + 184;
          uint64_t v118 = &v93[184 * v92];
          if (v95) {
            operator delete(v95);
          }
        }

        else
        {
          *(void *)unint64_t v65 = 0LL;
          *(void *)(v65 + _Block_object_dispose(va, 8) = v111;
          *(void *)(v65 + 16) = 0LL;
          v7.n128_u64[1] = *((void *)&v128 + 1);
          *(_OWORD *)(v65 + sub_10000AE14(v9 + 24) = v128;
          *(double *)(v65 + 40) = v110;
          *(void *)(v65 + 4_Block_object_dispose(va, 8) = v70;
          *(double *)(v65 + 56) = v109;
          *(double *)(v65 + 64) = v108;
          *(double *)(v65 + 72) = v71;
          *(void *)(v65 + 80) = v85;
          *(double *)(v65 + 8_Block_object_dispose(va, 8) = v73;
          *(void *)(v65 + 96) = v86;
          *(void *)(v65 + 104) = v87;
          *(void *)(v65 + 112) = v88;
          *(double *)(v65 + 120) = v72;
          *(double *)(v65 + 12_Block_object_dispose(va, 8) = v77;
          v7.n128_f64[0] = v76;
          *(double *)(v65 + 136) = v76;
          *(void *)(v65 + 144) = 0LL;
          *(double *)(v65 + 152) = v81;
          *(double *)(v65 + 160) = v80;
          *(double *)(v65 + 16_Block_object_dispose(va, 8) = v84;
          *(_DWORD *)(v65 + 176) = 1;
          *(_DWORD *)(v65 + 180) = v89;
          v65 += 184LL;
        }

        __int128 v117 = (char *)v65;
      }

      ++v66;
    }

    while (v66 != 4);
    __int16 v106 = (char *)__p;
    unint64_t v107 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v65 - (void)__p) >> 3);
    if (v107 >= 4)
    {
      *(_DWORD *)(a2 + sub_10000AE14(v9 + 24) = 0;
      sub_1006FB6F8((uint64_t *)(a2 + 40), v7);
      __int16 v106 = (char *)__p;
      if (!__p) {
        goto LABEL_50;
      }
    }

    else
    {
      *(_DWORD *)(a2 + sub_10000AE14(v9 + 24) = -9;
      if (!v106)
      {
LABEL_50:
        if (v119[0])
        {
          v119[1] = v119[0];
          operator delete(v119[0]);
        }

        if (v120[0])
        {
          v120[1] = v120[0];
          operator delete(v120[0]);
        }

        if (v121[0])
        {
          v121[1] = v121[0];
          operator delete(v121[0]);
        }

        if (v122[0])
        {
          v122[1] = v122[0];
          operator delete(v122[0]);
        }

        if (v123[0])
        {
          v123[1] = v123[0];
          operator delete(v123[0]);
        }

        if (v124[0])
        {
          v124[1] = v124[0];
          operator delete(v124[0]);
        }

        goto LABEL_64;
      }
    }

    __int128 v117 = v106;
    operator delete(v106);
    goto LABEL_50;
  }

  *(_DWORD *)(a2 + sub_10000AE14(v9 + 24) = -5;
LABEL_64:
  if (v125)
  {
    char v126 = v125;
    operator delete(v125);
  }

void sub_1006FC79C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39)
{
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a29) {
    operator delete(a29);
  }
  if (a32) {
    operator delete(a32);
  }
  if (a35) {
    operator delete(a35);
  }
  if (a38) {
    operator delete(a38);
  }
  double v41 = *(void **)(v39 - 224);
  if (v41)
  {
    *(void *)(v39 - 216) = v41;
    operator delete(v41);
  }

  uint64_t v42 = *(void **)(v39 - 200);
  if (v42)
  {
    *(void *)(v39 - 192) = v42;
    operator delete(v42);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1006FC874(int a1, __int128 **a2, char **a3, void **a4, double a5)
{
  if (a3[1] != *a3) {
    uuid_copy(dst, (const unsigned __int8 *)*a3 + 24);
  }
  *(void *)uu1 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v9 = *a2;
  unsigned int v10 = a2[1];
  if (*a2 != v10)
  {
    unsigned int v11 = 0;
    do
    {
      if (uuid_compare((const unsigned __int8 *)v9 + 24, dst))
      {
        int v12 = *((_DWORD *)v9 + 44);
        if (v12 == 1 || v12 == -1)
        {
          if (uuid_compare(uu1, (const unsigned __int8 *)v9 + 24))
          {
            uuid_copy(uu1, (const unsigned __int8 *)v9 + 24);
            ++v11;
          }

          int v14 = (char *)a4[1];
          uint64_t v15 = (char *)a4[2];
          if (v14 >= v15)
          {
            unint64_t v26 = 0xD37A6F4DE9BD37A7LL * ((v14 - (_BYTE *)*a4) >> 3);
            unint64_t v27 = v26 + 1;
            if (v26 + 1 > 0x1642C8590B21642LL) {
              sub_100007008();
            }
            unint64_t v28 = 0xD37A6F4DE9BD37A7LL * ((v15 - (_BYTE *)*a4) >> 3);
            if (2 * v28 > v27) {
              unint64_t v27 = 2 * v28;
            }
            if (v28 >= 0xB21642C8590B21LL) {
              unint64_t v29 = 0x1642C8590B21642LL;
            }
            else {
              unint64_t v29 = v27;
            }
            if (v29) {
              uint64_t v30 = (char *)sub_1002DF6FC((uint64_t)(a4 + 2), v29);
            }
            else {
              uint64_t v30 = 0LL;
            }
            double v31 = &v30[184 * v26];
            __int128 v32 = *v9;
            __int128 v33 = v9[1];
            __int128 v34 = v9[3];
            *((_OWORD *)v31 + 2) = v9[2];
            *((_OWORD *)v31 + 3) = v34;
            *(_OWORD *)double v31 = v32;
            *((_OWORD *)v31 + 1) = v33;
            __int128 v35 = v9[4];
            __int128 v36 = v9[5];
            __int128 v37 = v9[7];
            *((_OWORD *)v31 + 6) = v9[6];
            *((_OWORD *)v31 + 7) = v37;
            *((_OWORD *)v31 + 4) = v35;
            *((_OWORD *)v31 + 5) = v36;
            __int128 v38 = v9[8];
            __int128 v39 = v9[9];
            __int128 v40 = v9[10];
            *((void *)v31 + 22) = *((void *)v9 + 22);
            *((_OWORD *)v31 + 9) = v39;
            *((_OWORD *)v31 + 10) = v40;
            *((_OWORD *)v31 + _Block_object_dispose(va, 8) = v38;
            uint64_t v42 = (char *)*a4;
            double v41 = (char *)a4[1];
            double v43 = v31;
            if (v41 != *a4)
            {
              do
              {
                __int128 v44 = *(_OWORD *)(v41 - 184);
                __int128 v45 = *(_OWORD *)(v41 - 168);
                __int128 v46 = *(_OWORD *)(v41 - 152);
                *(_OWORD *)(v43 - 136) = *(_OWORD *)(v41 - 136);
                *(_OWORD *)(v43 - 152) = v46;
                *(_OWORD *)(v43 - 16_Block_object_dispose(va, 8) = v45;
                *(_OWORD *)(v43 - 184) = v44;
                __int128 v47 = *(_OWORD *)(v41 - 120);
                __int128 v48 = *(_OWORD *)(v41 - 104);
                __int128 v49 = *(_OWORD *)(v41 - 88);
                *(_OWORD *)(v43 - 72) = *(_OWORD *)(v41 - 72);
                *(_OWORD *)(v43 - 8_Block_object_dispose(va, 8) = v49;
                *(_OWORD *)(v43 - 104) = v48;
                *(_OWORD *)(v43 - 120) = v47;
                __int128 v50 = *(_OWORD *)(v41 - 56);
                __int128 v51 = *(_OWORD *)(v41 - 40);
                __int128 v52 = *(_OWORD *)(v41 - 24);
                *((void *)v43 - 1) = *((void *)v41 - 1);
                *(_OWORD *)(v43 - sub_10000AE14(v9 + 24) = v52;
                *(_OWORD *)(v43 - 40) = v51;
                *(_OWORD *)(v43 - 56) = v50;
                v43 -= 184;
                v41 -= 184;
              }

              while (v41 != v42);
              double v41 = (char *)*a4;
            }

            double v25 = v31 + 184;
            *a4 = v43;
            a4[1] = v31 + 184;
            a4[2] = &v30[184 * v29];
            if (v41) {
              operator delete(v41);
            }
          }

          else
          {
            __int128 v16 = *v9;
            __int128 v17 = v9[1];
            __int128 v18 = v9[3];
            *((_OWORD *)v14 + 2) = v9[2];
            *((_OWORD *)v14 + 3) = v18;
            *(_OWORD *)int v14 = v16;
            *((_OWORD *)v14 + 1) = v17;
            __int128 v19 = v9[4];
            __int128 v20 = v9[5];
            __int128 v21 = v9[7];
            *((_OWORD *)v14 + 6) = v9[6];
            *((_OWORD *)v14 + 7) = v21;
            *((_OWORD *)v14 + 4) = v19;
            *((_OWORD *)v14 + 5) = v20;
            __int128 v22 = v9[8];
            __int128 v23 = v9[9];
            __int128 v24 = v9[10];
            *((void *)v14 + 22) = *((void *)v9 + 22);
            *((_OWORD *)v14 + 9) = v23;
            *((_OWORD *)v14 + 10) = v24;
            *((_OWORD *)v14 + _Block_object_dispose(va, 8) = v22;
            double v25 = v14 + 184;
          }

          a4[1] = v25;
        }
      }

      uint64_t v9 = (__int128 *)((char *)v9 + 184);
    }

    while (v9 != v10);
  }

  sub_100306B0C((uint64_t)a4, (uint64_t)a4[1], *a3, a3[1], 0xD37A6F4DE9BD37A7LL * ((a3[1] - *a3) >> 3));
  uint64_t result = 4294967290LL;
  if (a2[1] != *a2)
  {
    if (0xD37A6F4DE9BD37A7LL * (((_BYTE *)a4[1] - (_BYTE *)*a4) >> 3) >= 3) {
      return 0LL;
    }
    else {
      return 4294967290LL;
    }
  }

  return result;
}

BOOL sub_1006FCBC8(uint64_t a1, double **a2, double *a3)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = qword_1019344D0;
  if (*a2 == v3)
  {
    double v7 = 0.0;
    double v6 = 0.0;
  }

  else
  {
    double v6 = 0.0;
    double v7 = 0.0;
    do
    {
      double v8 = v4[8];
      double v9 = v4[9];
      double v10 = v4[7];
      double v11 = v4[12];
      if (v5 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184C2D0);
      }
      double v12 = (v9 - v10) / (v8 - v10);
      uint64_t v13 = (os_log_s *)qword_1019344D8;
      double v14 = v11 / 3.5;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 68289539;
        int v24 = 0;
        __int16 v25 = 2082;
        unint64_t v26 = "";
        __int16 v27 = 2049;
        double v28 = v12;
        __int16 v29 = 2049;
        double v30 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:VO2Max,AdaptiveOutdoorPedestrianModel,ComputeEfficiency, fhr:%{private}f, m ets:%{private}f}",  buf,  0x26u);
        uint64_t v5 = qword_1019344D0;
      }

      else
      {
        uint64_t v5 = -1LL;
      }

      if (v14 >= 0.0 && v14 < 20.0)
      {
        double v16 = v14 / v12;
        if (v14 / v12 > 20.0) {
          double v16 = 20.0;
        }
        double v6 = v6 + v16;
        double v7 = v7 + 1.0;
      }

      v4 += 23;
    }

    while (v4 != v3);
  }

  double v17 = v6 / v7;
  if (v7 <= 0.0) {
    double v17 = 0.0;
  }
  *a3 = v17;
  if (v5 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184C2D0);
  }
  __int128 v18 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    __int128 v19 = "false";
    double v20 = *a3;
    *(_DWORD *)buf = 68289539;
    if (v7 > 0.0) {
      __int128 v19 = "true";
    }
    int v24 = 0;
    __int16 v25 = 2082;
    unint64_t v26 = "";
    __int16 v27 = 2081;
    double v28 = *(double *)&v19;
    __int16 v29 = 2049;
    double v30 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:VO2Max,AdaptiveOutdoorPedestrianModel,ComputeEfficiency, canCalculateEfficiency:%{pri vate, location:escape_only}s, efficiency:%{private}f}",  buf,  0x26u);
  }

  return v7 > 0.0;
}

double sub_1006FCE4C(double a1, double a2, uint64_t a3, double **a4)
{
  uint64_t v4 = *a4;
  uint64_t v5 = a4[1];
  if (*a4 == v5) {
    return 1.79769313e308;
  }
  double v7 = 0LL;
  double v8 = 0LL;
  double v9 = 0LL;
  double v10 = a1 * 0.959999979 + 0.00659999996;
  double v11 = a1 * 0.330000013 + -0.023;
  double v12 = 0.0;
  do
  {
    float v13 = v4[7];
    float v14 = v4[8];
    double v15 = v4[9];
    float v16 = v15;
    float v17 = (v14 - v16) / (v14 - v13);
    double v18 = v4[12] / v15;
    double v19 = v18 - (v10 + v11 * log((float)(1.0 - v17)));
    double v20 = (v4[1] - a2 + 18144000.0) / 36288000.0 + 0.5;
    if (v8 >= v7)
    {
      uint64_t v21 = ((char *)v8 - (char *)v9) >> 4;
      unint64_t v22 = v21 + 1;
      if (v7 - v9 > v22) {
        unint64_t v22 = v7 - v9;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23)
      {
        if (v23 >> 60) {
          sub_1000070D4();
        }
        int v24 = (char *)operator new(16 * v23);
      }

      else
      {
        int v24 = 0LL;
      }

      __int16 v25 = (double *)&v24[16 * v21];
      *__int16 v25 = v19;
      v25[1] = v20;
      if (v8 == v9)
      {
        __int16 v27 = v8;
        double v9 = (double *)&v24[16 * v21];
      }

      else
      {
        unint64_t v26 = (double *)&v24[16 * v21];
        do
        {
          *((_OWORD *)v26 - 1) = *((_OWORD *)v8 - 1);
          v26 -= 2;
          v8 -= 2;
        }

        while (v8 != v9);
        __int16 v27 = v9;
        double v9 = v26;
      }

      double v7 = (double *)&v24[16 * v23];
      double v8 = v25 + 2;
      if (v27) {
        operator delete(v27);
      }
    }

    else
    {
      *double v8 = v19;
      v8[1] = v20;
      v8 += 2;
    }

    double v12 = v12 + v20;
    v4 += 23;
  }

  while (v4 != v5);
  if (v9 == v8)
  {
    double v33 = 1.79769313e308;
  }

  else
  {
    unint64_t v28 = ((char *)v8 - (char *)v9) >> 4;
    sub_1006FDC60((uint64_t)v9, v8, 126 - 2 * __clz(v28), 1);
    double v29 = v12 - v9[1];
    uint64_t v30 = 0LL;
    if (v29 > v12 * 0.5)
    {
      double v31 = v9 + 3;
      do
      {
        LODWORD(v30) = v30 + 1;
        double v32 = *v31;
        v31 += 2;
        double v29 = v29 - v32;
      }

      while (v29 > v12 * 0.5);
      uint64_t v30 = v30;
    }

    double v33 = v9[2 * v30];
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184C2D0);
    }
    __int128 v34 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v43 = v28;
      __int16 v44 = 2048;
      double v45 = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "AlgoName,AdaptiveOutdoorPedestrianModel,numHistoricalResiduals,%ld,median,%f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184C2D0);
      }
      int v38 = 134218240;
      unint64_t v39 = v28;
      __int16 v40 = 2048;
      double v41 = v33;
      LODWORD(v37) = 22;
      __int128 v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "AlgoName,AdaptiveOutdoorPedestrianModel,numHistoricalResiduals,%ld,median,%f",  &v38,  v37);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeWeightedMedianOfResiduals(const std::vector<VO2MaxS ummary> &, double, CFAbsoluteTime) const",  "%s\n",  v35);
    }
  }

  operator delete(v9);
  return v33;
}

void sub_1006FD25C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006FD280(float *a1, void *a2, int *a3, __n128 a4, double a5, double a6)
{
  double v8 = a4.n128_f64[0];
  double v77 = a1;
  *a3 = 0;
  *(void *)uu1 = 0LL;
  uint64_t v89 = 0LL;
  double v9 = a5 * 0.2 + -6.4;
  double v10 = 0.0;
  if (v9 < 0.0) {
    double v9 = 0.0;
  }
  if (v9 <= 1.0) {
    double v11 = v9;
  }
  else {
    double v11 = 1.0;
  }
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  double v76 = a2;
  if (*a2 != v13)
  {
    int v14 = 0;
    double v87 = v8 * 0.959999979 + 0.00659999996;
    double v75 = v8;
    double v85 = 1.0 - v11;
    double v86 = v8 * 0.330000013 + -0.023;
    double v84 = v11;
    double v15 = ((1.0 - v11) * 2.5 + v11 * 4.0) * 3.5;
    double v82 = -0.02;
    double v78 = 0.02;
    a4.n128_u64[0] = 134221056LL;
    __n128 v79 = a4;
    double v83 = -0.07;
    double v81 = 0.1;
    double v16 = 0.0;
    double v17 = 0.0;
    while (1)
    {
      double v18 = *(double *)(v12 + 72);
      double v19 = 0.0;
      if (v18 > 0.0) {
        double v19 = *(double *)(v12 + 96) / v18;
      }
      float v20 = *(double *)(v12 + 56);
      float v21 = *(double *)(v12 + 64);
      float v22 = v18;
      float v23 = (v21 - v22) / (v21 - v20);
      double v24 = (float)(1.0 - v23);
      double v25 = v19 - (v87 + v86 * log(v24));
      if (a6 == 1.79769313e308) {
        break;
      }
      double v26 = 1.0;
      double v27 = v84;
      if (v25 - a6 >= v82)
      {
        BOOL v29 = v25 - a6 > v78;
        goto LABEL_15;
      }

      double v28 = 0.0;
      BOOL v29 = 1;
LABEL_28:
      if (v24 >= 0.3) {
        double v39 = v26;
      }
      else {
        double v39 = 0.0;
      }
      double v40 = (v85 * v39 + v24 * v27) * v28;
      else {
        double v43 = 0.0;
      }
      if (v43 > 0.0)
      {
        ++v14;
        if (uuid_compare(uu1, (const unsigned __int8 *)(v12 + 24)))
        {
          uuid_copy(uu1, (const unsigned __int8 *)(v12 + 24));
          ++*a3;
        }
      }

      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10184C2D0);
      }
      __int16 v44 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v45 = *(void *)(v12 + 8);
        uint64_t v46 = *(void *)(v12 + 48);
        uint64_t v47 = *(void *)(v12 + 56);
        uint64_t v48 = *(void *)(v12 + 64);
        uint64_t v49 = *(void *)(v12 + 72);
        uint64_t v50 = *(void *)(v12 + 96);
        uint64_t v51 = *(void *)(v12 + 80);
        uint64_t v52 = *(void *)(v12 + 112);
        int v53 = *(_DWORD *)(v12 + 180);
        *(_DWORD *)buf = v79.n128_u32[0];
        unint64_t v111 = v45;
        __int16 v112 = 2048;
        *(void *)double v113 = v46;
        *(_WORD *)&v113[8] = 2048;
        *(void *)double v114 = v47;
        *(_WORD *)&v114[8] = 2048;
        *(void *)uint64_t v115 = v48;
        *(_WORD *)&v115[8] = 2048;
        *(void *)__int16 v116 = v49;
        *(_WORD *)&v116[8] = 2048;
        *(void *)__int128 v117 = v50;
        *(_WORD *)&v117[8] = 2048;
        *(void *)uint64_t v118 = v51;
        *(_WORD *)&v118[8] = 2048;
        uint64_t v119 = v52;
        __int16 v120 = 2048;
        double v121 = v24;
        __int16 v122 = 2048;
        double v123 = v25;
        __int16 v124 = 1024;
        BOOL v125 = v29;
        __int16 v126 = 2048;
        double v127 = v43;
        __int16 v128 = 1024;
        int v129 = v53;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,ts,%.9f,size,%lld,hrMin,%f,hrMax,%f,hrMean,%f,vo2M ean,%f,hrConfidenceMean,%f,gradeMean,%f,oneMinusFHR,%f,residual,%f,failHistResidCheck,%d,confidence,%f,sessionType,%d",  buf,  0x7Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10184C2D0);
        }
        unint64_t v54 = *(void *)(v12 + 8);
        uint64_t v55 = *(void *)(v12 + 48);
        uint64_t v56 = *(void *)(v12 + 56);
        uint64_t v57 = *(void *)(v12 + 64);
        uint64_t v58 = *(void *)(v12 + 72);
        uint64_t v59 = *(void *)(v12 + 96);
        uint64_t v60 = *(void *)(v12 + 80);
        uint64_t v61 = *(void *)(v12 + 112);
        int v62 = *(_DWORD *)(v12 + 180);
        int v90 = v79.n128_u32[0];
        unint64_t v91 = v54;
        __int16 v92 = 2048;
        *(void *)uint64_t v93 = v55;
        *(_WORD *)&v93[8] = 2048;
        *(void *)__int16 v94 = v56;
        *(_WORD *)&v94[8] = 2048;
        *(void *)uint64_t v95 = v57;
        *(_WORD *)&v95[8] = 2048;
        *(void *)__int16 v96 = v58;
        *(_WORD *)&v96[8] = 2048;
        *(void *)uint64_t v97 = v59;
        *(_WORD *)&v97[8] = 2048;
        *(void *)__int128 v98 = v60;
        *(_WORD *)&v98[8] = 2048;
        uint64_t v99 = v61;
        __int16 v100 = 2048;
        double v101 = v24;
        __int16 v102 = 2048;
        double v103 = v25;
        __int16 v104 = 1024;
        BOOL v105 = v29;
        __int16 v106 = 2048;
        double v107 = v43;
        __int16 v108 = 1024;
        int v109 = v62;
        LODWORD(v74) = 124;
        uint64_t v63 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,ts,%.9f,size,%lld,hrMin,%f,hrMax,%f, hrMean,%f,vo2Mean,%f,hrConfidenceMean,%f,gradeMean,%f,oneMinusFHR,%f,residual,%f,failHistResidCh eck,%d,confidence,%f,sessionType,%d",  COERCE_DOUBLE(&v90),  v74,  v75,  *(double *)&v76,  *(double *)&v77,  v78,  v79.n128_f64[0],  v79.n128_f64[1],  v80,  v81,  LODWORD(v82),  v83,  LODWORD(v84));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeLongitudinalEstimate(const std::vector<VO2MaxSummar y> &, double, double, double, uint32_t &)::(anonymous class)::operator()(const VO2MaxSummary &) const",  "%s\n",  v63);
      }

      double v16 = v16 + v43 * v25;
      double v17 = v17 + v43;
      v12 += 184LL;
      if (v12 == v13)
      {
        double v10 = v16 / (v17 + 2.22044605e-16);
        goto LABEL_55;
      }
    }

    BOOL v29 = 0;
    double v26 = 1.0;
    double v27 = v84;
LABEL_15:
    double v28 = 0.0;
    if (v25 >= v83 && v25 <= v81 && !v29)
    {
      uint64_t v30 = 0LL;
      double v31 = (double *)qword_10130F3D8;
      do
      {
        ++v30;
        v31 += 2;
      }

      while (v30 != 7);
      uint64_t v32 = 0LL;
      double v33 = *(double *)&qword_10130F3D8[2 * v30 + 1];
      __int128 v34 = (double *)qword_10130F448;
      do
      {
        ++v32;
        v34 += 2;
      }

      while (v32 != 9);
      uint64_t v35 = 0LL;
      double v36 = v33 * *(double *)&qword_10130F448[2 * v32 + 1];
      double v37 = fabs(*(double *)(v12 + 112));
      int v38 = (double *)qword_10130F4D8;
      do
      {
        if (*v38 >= v37) {
          break;
        }
        ++v35;
        v38 += 2;
      }

      while (v35 != 5);
      BOOL v29 = 0;
      double v28 = v36 * *(double *)&qword_10130F4D8[2 * v35 + 1];
    }

    goto LABEL_28;
  }

  int v14 = 0;
LABEL_55:
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10184C2D0);
  }
  double v64 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v65 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v76[1] - *v76) >> 3);
    int v66 = *a3;
    double v67 = *v77;
    double v68 = v77[1];
    *(_DWORD *)buf = 134219776;
    unint64_t v111 = v65;
    __int16 v112 = 1024;
    *(_DWORD *)double v113 = v14;
    *(_WORD *)&v113[4] = 1024;
    *(_DWORD *)&v113[6] = v66;
    *(_WORD *)double v114 = 2048;
    *(double *)&v114[2] = a6;
    *(_WORD *)uint64_t v115 = 2048;
    *(double *)&v115[2] = v67;
    *(_WORD *)__int16 v116 = 2048;
    *(double *)&v116[2] = v68;
    *(_WORD *)__int128 v117 = 2048;
    *(double *)&v117[2] = v10;
    *(_WORD *)uint64_t v118 = 2048;
    *(void *)&v118[2] = 0x3FB999999999999ALL;
    _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,numClusters,%lu,numClustersContr,%u,numWorkoutsContr,% u,medianResidual,%f,hrMin,%f,hrMax,%f,meanResidual,%f,clusterResidualBoundsMax,%f",  buf,  0x4Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10184C2D0);
    }
    unint64_t v69 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v76[1] - *v76) >> 3);
    int v70 = *a3;
    double v71 = *v77;
    double v72 = v77[1];
    int v90 = 134219776;
    unint64_t v91 = v69;
    __int16 v92 = 1024;
    *(_DWORD *)uint64_t v93 = v14;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v70;
    *(_WORD *)__int16 v94 = 2048;
    *(double *)&v94[2] = a6;
    *(_WORD *)uint64_t v95 = 2048;
    *(double *)&v95[2] = v71;
    *(_WORD *)__int16 v96 = 2048;
    *(double *)&v96[2] = v72;
    *(_WORD *)uint64_t v97 = 2048;
    *(double *)&v97[2] = v10;
    *(_WORD *)__int128 v98 = 2048;
    *(void *)&v98[2] = 0x3FB999999999999ALL;
    double v73 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,numClusters,%lu,numClustersContr,%u,numW orkoutsContr,%u,medianResidual,%f,hrMin,%f,hrMax,%f,meanResidual,%f,clusterResidualBoundsMax,%f",  &v90,  74,  LODWORD(v75),  *(double *)&v76,  *(double *)&v77,  v78,  v79.n128_f64[0],  v79.n128_f64[1]);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeLongitudinalEstimate(const std::vector<VO2MaxSummary> &, double, double, double, uint32_t &) const",  "%s\n",  v73);
  }

double sub_1006FDB30(double a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  if (*a3 != v6)
  {
    int v7 = *(_DWORD *)(a4 + 104);
    do
    {
      double v8 = *(double *)v5 - a1;
      if (v7 != 3 && v8 <= 120.0) {
        *(_DWORD *)(v5 + 64) = 0;
      }
      if (a5 == 17 && v8 >= 2700.0) {
        *(_DWORD *)(v5 + 64) = 0;
      }
      v5 += 72LL;
    }

    while (v5 != v6);
  }

  double result = 0.06;
  *(_OWORD *)(a4 + 120) = xmmword_10130F3B0;
  return result;
}

void sub_1006FDB9C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void *sub_1006FDBC8(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100006E1C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }

  return a1;
}

void sub_1006FDC44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1006FDC60(uint64_t a1, double *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = (uint64_t)a2 - v8;
    unint64_t v10 = (uint64_t)((uint64_t)a2 - v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        double v33 = *(a2 - 2);
        uint64_t v32 = a2 - 2;
        if (v33 < *(double *)v8)
        {
          __int128 v85 = *(_OWORD *)v8;
          *(_OWORD *)unint64_t v8 = *(_OWORD *)v32;
          *(_OWORD *)uint64_t v32 = v85;
        }

        return;
      case 3uLL:
        sub_1006FE358((double *)v8, (double *)(v8 + 16), a2 - 2);
        return;
      case 4uLL:
        sub_1006FE604((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), (unint64_t *)a2 - 2);
        return;
      case 5uLL:
        __int128 v34 = (__int128 *)(v8 + 16);
        uint64_t v35 = (__int128 *)(v8 + 32);
        double v36 = (__int128 *)(v8 + 48);
        sub_1006FE604((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), (unint64_t *)(v8 + 48));
        double v38 = *(a2 - 2);
        double v37 = a2 - 2;
        if (v38 < *(double *)(v8 + 48))
        {
          __int128 v39 = *v36;
          *double v36 = *(_OWORD *)v37;
          *(_OWORD *)double v37 = v39;
          if (*(double *)v36 < *(double *)v35)
          {
            __int128 v40 = *v35;
            *uint64_t v35 = *v36;
            *double v36 = v40;
            if (*(double *)v35 < *(double *)v34)
            {
              __int128 v41 = *v34;
              *__int128 v34 = *v35;
              *uint64_t v35 = v41;
              if (*(double *)(v8 + 16) < *(double *)v8)
              {
                __int128 v86 = *(_OWORD *)v8;
                *(_OWORD *)unint64_t v8 = *v34;
                *__int128 v34 = v86;
              }
            }
          }
        }

        return;
      default:
        if (v9 <= 383)
        {
          uint64_t v42 = (double *)(v8 + 16);
          BOOL v44 = (double *)v8 == a2 || v42 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v44)
            {
              uint64_t v45 = 0LL;
              unint64_t v46 = v8;
              do
              {
                uint64_t v47 = v42;
                double v48 = *(double *)(v46 + 16);
                if (v48 < *(double *)v46)
                {
                  uint64_t v49 = *(void *)(v46 + 24);
                  uint64_t v50 = v45;
                  while (1)
                  {
                    *(_OWORD *)(v8 + v50 + 16) = *(_OWORD *)(v8 + v50);
                    if (!v50) {
                      break;
                    }
                    double v51 = *(double *)(v8 + v50 - 16);
                    v50 -= 16LL;
                    if (v48 >= v51)
                    {
                      uint64_t v52 = v8 + v50 + 16;
                      goto LABEL_76;
                    }
                  }

                  uint64_t v52 = v8;
LABEL_76:
                  *(double *)uint64_t v52 = v48;
                  *(void *)(v52 + _Block_object_dispose(va, 8) = v49;
                }

                uint64_t v42 = v47 + 2;
                v45 += 16LL;
                unint64_t v46 = (unint64_t)v47;
              }

              while (v47 + 2 != a2);
            }
          }

          else if (!v44)
          {
            do
            {
              uint64_t v77 = (uint64_t)v42;
              double v78 = *(double *)(a1 + 16);
              if (v78 < *(double *)a1)
              {
                uint64_t v79 = *(void *)(a1 + 24);
                double v80 = v42;
                do
                {
                  *(_OWORD *)double v80 = *((_OWORD *)v80 - 1);
                  double v81 = *(v80 - 4);
                  v80 -= 2;
                }

                while (v78 < v81);
                *double v80 = v78;
                *((void *)v80 + 1) = v79;
              }

              v42 += 2;
              a1 = v77;
            }

            while ((double *)(v77 + 16) != a2);
          }

          return;
        }

        if (!a3)
        {
          if ((double *)v8 != a2)
          {
            int64_t v53 = (v10 - 2) >> 1;
            int64_t v54 = v53;
            do
            {
              int64_t v55 = v54;
              if (v53 >= v54)
              {
                uint64_t v56 = (2 * v54) | 1;
                uint64_t v57 = (double *)(v8 + 16 * v56);
                if (2 * v55 + 2 < (uint64_t)v10 && *v57 < v57[2])
                {
                  v57 += 2;
                  uint64_t v56 = 2 * v55 + 2;
                }

                uint64_t v58 = (double *)(v8 + 16 * v55);
                double v59 = *v58;
                if (*v57 >= *v58)
                {
                  uint64_t v60 = *((void *)v58 + 1);
                  do
                  {
                    uint64_t v61 = v58;
                    uint64_t v58 = v57;
                    *(_OWORD *)uint64_t v61 = *(_OWORD *)v57;
                    if (v53 < v56) {
                      break;
                    }
                    uint64_t v62 = 2 * v56;
                    uint64_t v56 = (2 * v56) | 1;
                    uint64_t v57 = (double *)(v8 + 16 * v56);
                    uint64_t v63 = v62 + 2;
                    if (v63 < (uint64_t)v10 && *v57 < v57[2])
                    {
                      v57 += 2;
                      uint64_t v56 = v63;
                    }
                  }

                  while (*v57 >= v59);
                  *uint64_t v58 = v59;
                  *((void *)v58 + 1) = v60;
                }
              }

              int64_t v54 = v55 - 1;
            }

            while (v55);
            uint64_t v64 = (unint64_t)v9 >> 4;
            do
            {
              uint64_t v65 = 0LL;
              __int128 v87 = *(_OWORD *)v8;
              int v66 = (double *)v8;
              do
              {
                double v67 = v66;
                v66 += 2 * v65 + 2;
                uint64_t v68 = 2 * v65;
                uint64_t v65 = (2 * v65) | 1;
                uint64_t v69 = v68 + 2;
                if (v69 < v64 && *v66 < v66[2])
                {
                  v66 += 2;
                  uint64_t v65 = v69;
                }

                *(_OWORD *)double v67 = *(_OWORD *)v66;
              }

              while (v65 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
              a2 -= 2;
              if (v66 == a2)
              {
                *(_OWORD *)int v66 = v87;
              }

              else
              {
                *(_OWORD *)int v66 = *(_OWORD *)a2;
                *(_OWORD *)a2 = v87;
                uint64_t v70 = (uint64_t)v66 - v8 + 16;
                if (v70 >= 17)
                {
                  unint64_t v71 = (((unint64_t)v70 >> 4) - 2) >> 1;
                  double v72 = (double *)(v8 + 16 * v71);
                  double v73 = *v66;
                  if (*v72 < *v66)
                  {
                    uint64_t v74 = *((void *)v66 + 1);
                    do
                    {
                      double v75 = v66;
                      int v66 = v72;
                      *(_OWORD *)double v75 = *(_OWORD *)v72;
                      if (!v71) {
                        break;
                      }
                      unint64_t v71 = (v71 - 1) >> 1;
                      double v72 = (double *)(v8 + 16 * v71);
                    }

                    while (*v72 < v73);
                    *int v66 = v73;
                    *((void *)v66 + 1) = v74;
                  }
                }
              }
            }

            while (v64-- > 2);
          }

          return;
        }

        unint64_t v11 = v10 >> 1;
        uint64_t v12 = (double *)(v8 + 16 * (v10 >> 1));
        if ((unint64_t)v9 < 0x801)
        {
          sub_1006FE358((double *)(a1 + 16 * (v10 >> 1)), (double *)a1, a2 - 2);
        }

        else
        {
          sub_1006FE358((double *)a1, (double *)(a1 + 16 * (v10 >> 1)), a2 - 2);
          sub_1006FE358((double *)(a1 + 16), v12 - 2, a2 - 4);
          sub_1006FE358((double *)(a1 + 32), (double *)(a1 + 16 + 16 * v11), a2 - 6);
          sub_1006FE358(v12 - 2, v12, (double *)(a1 + 16 + 16 * v11));
          __int128 v82 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)uint64_t v12 = v82;
        }

        --a3;
        double v13 = *(double *)a1;
        if ((a4 & 1) == 0 && *(double *)(a1 - 16) >= v13)
        {
          if (v13 >= *(a2 - 2))
          {
            unint64_t v26 = a1 + 16;
            do
            {
              unint64_t v8 = v26;
              v26 += 16LL;
            }

            while (v13 >= *(double *)v8);
          }

          else
          {
            unint64_t v8 = a1;
            do
            {
              double v25 = *(double *)(v8 + 16);
              v8 += 16LL;
            }

            while (v13 >= v25);
          }

          double v27 = a2;
          if (v8 < (unint64_t)a2)
          {
            double v27 = a2;
            do
            {
              double v28 = *(v27 - 2);
              v27 -= 2;
            }

            while (v13 < v28);
          }

          uint64_t v29 = *(void *)(a1 + 8);
          while (v8 < (unint64_t)v27)
          {
            __int128 v84 = *(_OWORD *)v8;
            *(_OWORD *)unint64_t v8 = *(_OWORD *)v27;
            *(_OWORD *)double v27 = v84;
            do
            {
              double v30 = *(double *)(v8 + 16);
              v8 += 16LL;
            }

            while (v13 >= v30);
            do
            {
              double v31 = *(v27 - 2);
              v27 -= 2;
            }

            while (v13 < v31);
          }

          if (v8 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)(v8 - 16);
          }
          a4 = 0;
          *(double *)(v8 - 16) = v13;
          *(void *)(v8 - _Block_object_dispose(va, 8) = v29;
          continue;
        }

        uint64_t v14 = 0LL;
        uint64_t v15 = *(void *)(a1 + 8);
        do
        {
          double v16 = *(double *)(a1 + v14 + 16);
          v14 += 16LL;
        }

        while (v16 < v13);
        unint64_t v17 = a1 + v14;
        double v18 = a2;
        if (v14 == 16)
        {
          double v18 = a2;
          do
          {
            double v20 = *(v18 - 2);
            v18 -= 2;
          }

          while (v20 >= v13);
        }

        else
        {
          do
          {
            double v19 = *(v18 - 2);
            v18 -= 2;
          }

          while (v19 >= v13);
        }

        unint64_t v8 = a1 + v14;
        if (v17 < (unint64_t)v18)
        {
          float v21 = v18;
          do
          {
            __int128 v83 = *(_OWORD *)v8;
            *(_OWORD *)unint64_t v8 = *(_OWORD *)v21;
            *(_OWORD *)float v21 = v83;
            do
            {
              double v22 = *(double *)(v8 + 16);
              v8 += 16LL;
            }

            while (v22 < v13);
            do
            {
              double v23 = *(v21 - 2);
              v21 -= 2;
            }

            while (v23 >= v13);
          }

          while (v8 < (unint64_t)v21);
        }

        if (v8 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)(v8 - 16);
        }
        *(double *)(v8 - 16) = v13;
        *(void *)(v8 - _Block_object_dispose(va, 8) = v15;
        if (v17 < (unint64_t)v18)
        {
LABEL_29:
          sub_1006FDC60(a1, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }

        BOOL v24 = sub_1006FE3FC(a1, v8 - 16);
        if (!sub_1006FE3FC(v8, (uint64_t)a2))
        {
          if (v24) {
            continue;
          }
          goto LABEL_29;
        }

        a2 = (double *)(v8 - 16);
        if (!v24) {
          goto LABEL_1;
        }
        return;
    }
  }

double *sub_1006FE358(double *result, double *a2, double *a3)
{
  double v3 = *a2;
  double v4 = *a3;
  if (*a2 >= *result)
  {
    if (v4 < v3)
    {
      __int128 v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (*a2 < *result)
      {
        __int128 v7 = *(_OWORD *)result;
        *(_OWORD *)double result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }

  else
  {
    if (v4 >= v3)
    {
      __int128 v8 = *(_OWORD *)result;
      *(_OWORD *)double result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*a3 >= *a2) {
        return result;
      }
      __int128 v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }

    else
    {
      __int128 v5 = *(_OWORD *)result;
      *(_OWORD *)double result = *(_OWORD *)a3;
    }

    *(_OWORD *)a3 = v5;
  }

  return result;
}

BOOL sub_1006FE3FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      __int128 v6 = (_OWORD *)(a2 - 16);
      if (*(double *)(a2 - 16) < *(double *)a1)
      {
        __int128 v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        _OWORD *v6 = v7;
      }

      return result;
    case 3LL:
      sub_1006FE358((double *)a1, (double *)(a1 + 16), (double *)(a2 - 16));
      return 1LL;
    case 4LL:
      sub_1006FE604((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), (unint64_t *)(a2 - 16));
      return 1LL;
    case 5LL:
      unint64_t v17 = (__int128 *)(a1 + 16);
      double v18 = (__int128 *)(a1 + 32);
      double v19 = (__int128 *)(a1 + 48);
      sub_1006FE604((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), (unint64_t *)(a1 + 48));
      double v21 = *(double *)(a2 - 16);
      double v20 = (__int128 *)(a2 - 16);
      if (v21 < *(double *)(a1 + 48))
      {
        __int128 v22 = *v19;
        *double v19 = *v20;
        *double v20 = v22;
        if (*(double *)v19 < *(double *)v18)
        {
          __int128 v23 = *v18;
          __int128 *v18 = *v19;
          *double v19 = v23;
          if (*(double *)v18 < *(double *)v17)
          {
            __int128 v24 = *v17;
            __int128 *v17 = *v18;
            __int128 *v18 = v24;
            if (*(double *)(a1 + 16) < *(double *)a1)
            {
              __int128 v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              __int128 *v17 = v25;
            }
          }
        }
      }

      return 1LL;
    default:
      __int128 v8 = (double *)(a1 + 32);
      sub_1006FE358((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32));
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      break;
  }

  while (1)
  {
    double v12 = *(double *)v9;
    if (*(double *)v9 < *v8)
    {
      uint64_t v13 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        double v15 = *(double *)(a1 + v14 + 16);
        v14 -= 16LL;
        if (v12 >= v15)
        {
          uint64_t v16 = a1 + v14 + 48;
          goto LABEL_13;
        }
      }

      uint64_t v16 = a1;
LABEL_13:
      *(double *)uint64_t v16 = v12;
      *(void *)(v16 + _Block_object_dispose(va, 8) = v13;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }

    __int128 v8 = (double *)v9;
    v10 += 16LL;
    v9 += 16LL;
    if (v9 == a2) {
      return 1LL;
    }
  }

__n128 sub_1006FE604(double *a1, double *a2, double *a3, unint64_t *a4)
{
  result.n128_u64[0] = *a4;
  if (*(double *)a4 < *a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_f64[0] = *a3;
    if (*a3 < *a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_f64[0] = *a2;
      if (*a2 < *a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }

  return result;
}

uint64_t sub_1006FE6A0()
{
  if (qword_101998270 != -1) {
    dispatch_once(&qword_101998270, &stru_10184C2F0);
  }
  return qword_1019A15A0;
}

double sub_1006FE6E4(uint64_t a1, uint64_t a2)
{
  return *(double *)a2;
}

BOOL sub_1006FE6EC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  double v3 = (uint64_t *)a1[1];
  if (v3 != a1)
  {
    while (1)
    {
      sub_1010DDBC0(__p, "");
      BOOL v7 = sub_1006FEBB8((uint64_t)(v3 + 2), a2, a3, (uint64_t)__p);
      BOOL v8 = v7;
      if (SHIBYTE(v41) < 0)
      {
        operator delete(*(void **)__p);
        if (!v8) {
          goto LABEL_19;
        }
      }

      else if (!v7)
      {
        goto LABEL_19;
      }

      uint64_t v9 = v3[35];
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_10184C310);
      }
      uint64_t v10 = (os_log_s *)qword_101934878;
      if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
      {
        else {
          uint64_t v11 = *(void *)a2;
        }
        uint64_t v12 = *(void *)a3;
        uint64_t v13 = v3 + 5;
        *(_DWORD *)std::stringbuf::string_type __p = 136446979;
        *(void *)&__p[4] = v11;
        __int16 v39 = 2081;
        uint64_t v40 = v12;
        __int16 v41 = 2081;
        uint64_t v42 = v13;
        __int16 v43 = 2050;
        uint64_t v44 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "remove %{public}s/%{private}s from %{private}s, remaining fences, %{public}lu",  __p,  0x2Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934870 != -1) {
          dispatch_once(&qword_101934870, &stru_10184C310);
        }
        else {
          uint64_t v19 = *(void *)a2;
        }
        uint64_t v20 = *(void *)a3;
        double v21 = v3 + 5;
        int v30 = 136446979;
        double v31 = (void *)v19;
        __int16 v32 = 2081;
        uint64_t v33 = v20;
        __int16 v34 = 2081;
        uint64_t v35 = v21;
        __int16 v36 = 2050;
        uint64_t v37 = v9;
        LODWORD(v29) = 42;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "remove %{public}s/%{private}s from %{private}s, remaining fences, %{public}lu",  &v30,  v29);
        __int128 v23 = (char *)v22;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLCombinedFencesList::removeFenceFromCombinedList(std::list<CLFenceManager_Type::CombinedFence> &, const std::string &, const std::string &)",  "%s\n",  v22);
        if (v23 != __p) {
          free(v23);
        }
      }

      if (!v9)
      {
        if (qword_101934870 != -1) {
          dispatch_once(&qword_101934870, &stru_10184C310);
        }
        uint64_t v14 = (os_log_s *)qword_101934878;
        if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
        {
          double v15 = v3 + 5;
          uint64_t v16 = a1[2] - 1;
          *(_DWORD *)std::stringbuf::string_type __p = 136380931;
          *(void *)&__p[4] = v15;
          __int16 v39 = 2050;
          uint64_t v40 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Fence: kill combinedFence, %{private}s, remaining fences, %{public}lu",  __p,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10184C310);
          }
          __int128 v24 = v3 + 5;
          uint64_t v25 = a1[2] - 1;
          int v30 = 136380931;
          double v31 = v24;
          __int16 v32 = 2050;
          uint64_t v33 = v25;
          LODWORD(v29) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: kill combinedFence, %{private}s, remaining fences, %{public}lu",  &v30,  v29);
          double v27 = (char *)v26;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLCombinedFencesList::removeFenceFromCombinedList(std::list<CLFenceManager_Type::CombinedFence> &, const std::string &, const std::string &)",  "%s\n",  v26);
          if (v27 != __p) {
            free(v27);
          }
        }

        uint64_t v17 = *v3;
        double v18 = (uint64_t *)v3[1];
        *(void *)(v17 + _Block_object_dispose(va, 8) = v18;
        *(void *)v3[1] = v17;
        --a1[2];
        sub_100700568((uint64_t)(v3 + 2));
        operator delete(v3);
        double v3 = v18;
        goto LABEL_20;
      }

void sub_1006FEB94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006FEBB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 296) = 0LL;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)__uuid_t dst = *(_OWORD *)a2;
    uint64_t v31 = *(void *)(a2 + 16);
  }

  if (*(char *)(a3 + 23) < 0)
  {
    sub_1010DD48C(v28, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)double v28 = *(_OWORD *)a3;
    uint64_t v29 = *(void *)(a3 + 16);
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v27 = *(void *)(a4 + 16);
  }

  sub_100922A7C((char *)v32, (uint64_t)__dst, (uint64_t)v28, (uint64_t)__p);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v7 = sub_100700B2C((uint64_t **)(a1 + 248), (unsigned __int8 *)v32);
  uint64_t v8 = v7;
  uint64_t v9 = *(void **)(a1 + 248);
  if (v9 == (void *)(a1 + 256))
  {
    LOBYTE(v11) = 0;
    char v10 = 0;
    if (!v7) {
      goto LABEL_38;
    }
    goto LABEL_29;
  }

  char v10 = 0;
  int v11 = 0;
  do
  {
    double v12 = *(double *)(a1 + 296);
    BOOL v13 = *((_BYTE *)v9 + 220) != 0;
    char v14 = *((_BYTE *)v9 + 192);
    double v15 = (void *)v9[1];
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        double v15 = (void *)*v15;
      }

      while (v15);
    }

    else
    {
      do
      {
        uint64_t v16 = (void *)v9[2];
        BOOL v17 = *v16 == (void)v9;
        uint64_t v9 = v16;
      }

      while (!v17);
    }

    v10 |= v13;
    v11 |= (v14 & 0x20) >> 5;
    uint64_t v9 = v16;
  }

  while (v16 != (void *)(a1 + 256));
  if (v8)
  {
LABEL_29:
    *(void *)(a1 + 280) = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0x7FEFFFFFFFFFFFFFLL;
    if (*(void *)(a1 + 264))
    {
      uint64_t v18 = *(void *)(a1 + 248);
      std::string::operator=((std::string *)(a1 + 24), (const std::string *)(v18 + 56));
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(v18 + 104);
      *(void *)(a1 + 104) = *(void *)(v18 + 136);
      *(_DWORD *)(a1 + 184) = sub_100923FF0(v18 + 32);
      *(_BYTE *)(a1 + 18_Block_object_dispose(va, 8) = *(_BYTE *)(v18 + 220);
      *(_BYTE *)(a1 + 30_Block_object_dispose(va, 8) = (*(_BYTE *)(v18 + 192) & 0x20) != 0;
    }

    else
    {
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_10184C310);
      }
      uint64_t v19 = (os_log_s *)qword_101934878;
      if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = (void *)(a1 + 24);
        *(_DWORD *)buf = 136380675;
        unint64_t v46 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Fence: fence, %{private}s, became empty",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934870 != -1) {
          dispatch_once(&qword_101934870, &stru_10184C310);
        }
        __int128 v23 = (void *)(a1 + 24);
        int v43 = 136380675;
        uint64_t v44 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: fence, %{private}s, became empty",  &v43,  12);
        uint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLFenceManager_Type::CombinedFence::removeFence(const std::string &, const std::string &, const std::string &)",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }
    }
  }

void sub_1006FEFE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, char a31)
{
}

uint64_t sub_1006FF068(uint64_t *a1, uint64_t a2, char a3)
{
  __int128 v6 = (uint64_t *)a1[1];
  if (v6 == a1) {
    goto LABEL_80;
  }
  while (1)
  {
    double v7 = sub_1006FFE14((uint64_t)(v6 + 2), *(double *)(a2 + 72), *(double *)(a2 + 80));
    double v8 = *(double *)(a2 + 96);
    BOOL v10 = v8 > 400.0 || *(_BYTE *)(a2 + 188) != 0 || *(_DWORD *)(a2 + 180) == 2;
    if (!v10
      && *(void *)(a2 + 232) == *(void *)(a2 + 224)
      && (*(_BYTE *)(a2 + 160) & 0x20) == 0
      && *((double *)v6 + 14) <= 400.0
      && !*((_BYTE *)v6 + 204)
      && *((_DWORD *)v6 + 49) != 2
      && v6[31] == v6[30]
      && (v6[22] & 0x20) == 0
      && !*((_BYTE *)v6 + 324)
      && v7 <= 35.0)
    {
      int v11 = *((_DWORD *)v6 + 50);
      if (v11 == sub_100923FF0(a2))
      {
        if (qword_101934870 != -1) {
          dispatch_once(&qword_101934870, &stru_10184C310);
        }
        int64_t v54 = (os_log_s *)qword_101934878;
        if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
        {
          else {
            size_t v55 = *(void *)(a2 + 8);
          }
          sub_1000392EC((uint64_t)&v81, v55 + 1);
          if ((v81.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v56 = &v81;
          }
          else {
            uint64_t v56 = (std::string *)v81.__r_.__value_.__r.__words[0];
          }
          if (v55)
          {
            else {
              uint64_t v57 = *(const void **)a2;
            }
            uint64_t v58 = v56;
            memmove(v56, v57, v55);
            uint64_t v56 = v58;
          }

          *(_WORD *)((char *)&v56->__r_.__value_.__l.__data_ + v55) = 47;
          int v59 = *(char *)(a2 + 47);
          if (v59 >= 0) {
            uint64_t v60 = (const std::string::value_type *)(a2 + 24);
          }
          else {
            uint64_t v60 = *(const std::string::value_type **)(a2 + 24);
          }
          if (v59 >= 0) {
            std::string::size_type v61 = *(unsigned __int8 *)(a2 + 47);
          }
          else {
            std::string::size_type v61 = *(void *)(a2 + 32);
          }
          uint64_t v62 = std::string::append(&v81, v60, v61);
          __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
          buf.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
          *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v63;
          v62->__r_.__value_.__l.__size_ = 0LL;
          v62->__r_.__value_.__l.__cap_ = 0LL;
          v62->__r_.__value_.__r.__words[0] = 0LL;
          p_std::stringbuf::string_type buf = &buf;
          if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v81.__r_.__value_.__l.__data_) = 134283779;
          *(double *)((char *)v81.__r_.__value_.__r.__words + 4) = v7;
          WORD2(v81.__r_.__value_.__r.__words[1]) = 2081;
          *(std::string::size_type *)((char *)&v81.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
          _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEBUG,  "FenceCal: combine fine fence, distance, %{private}.1lf, %{private}s",  (uint8_t *)&v81,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&v81, 0x65CuLL);
          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10184C310);
          }
          uint64_t v65 = qword_101934878;
          sub_10065EF44((const void **)a2, &buf);
          if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v66 = &buf;
          }
          else {
            int v66 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
          }
          int v77 = 134283779;
          double v78 = v7;
          __int16 v79 = 2081;
          double v80 = v66;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &v81,  1628LL,  &_mh_execute_header,  v65,  2LL,  "FenceCal: combine fine fence, distance, %{private}.1lf, %{private}s",  &v77,  22);
          uint64_t v49 = v67;
          goto LABEL_195;
        }

        goto LABEL_79;
      }

      double v8 = *(double *)(a2 + 96);
    }

    if (v7 > 35.0) {
      goto LABEL_47;
    }
    double v12 = *((double *)v6 + 14);
    if (v8 >= 7000.0 != v12 >= 7000.0) {
      goto LABEL_47;
    }
    BOOL v13 = v8 <= 400.0 && *(_BYTE *)(a2 + 188) == 0;
    int v14 = *(_DWORD *)(a2 + 180);
    BOOL v15 = !v13 || v14 == 2;
    char v16 = v15;
    BOOL v17 = !v15 && *(void *)(a2 + 232) == *(void *)(a2 + 224) && (*(_BYTE *)(a2 + 160) & 0x20) == 0;
    if (v12 > 400.0 || *((_BYTE *)v6 + 204) || *((_DWORD *)v6 + 49) == 2 || v6[31] != v6[30])
    {
      if (v17) {
        goto LABEL_47;
      }
    }

    else if (((v17 ^ ((v6[22] & 0x20) == 0)) & 1) != 0)
    {
      goto LABEL_47;
    }

    int v18 = (v16 & 1) == 0 && *(void *)(a2 + 232) == *(void *)(a2 + 224) && (*(_BYTE *)(a2 + 160) & 0x20) == 0;
    if (*((unsigned __int8 *)v6 + 324) == v18 && v14 == *((_DWORD *)v6 + 49))
    {
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_10184C310);
      }
      __int16 v36 = (os_log_s *)qword_101934878;
      if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
      {
        else {
          size_t v37 = *(void *)(a2 + 8);
        }
        double v38 = &v81;
        sub_1000392EC((uint64_t)&v81, v37 + 1);
        if ((v81.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          double v38 = (std::string *)v81.__r_.__value_.__r.__words[0];
        }
        if (v37)
        {
          else {
            char v39 = *(const void **)a2;
          }
          memmove(v38, v39, v37);
        }

        *(_WORD *)((char *)&v38->__r_.__value_.__l.__data_ + v37) = 47;
        int v40 = *(char *)(a2 + 47);
        if (v40 >= 0) {
          __int16 v41 = (const std::string::value_type *)(a2 + 24);
        }
        else {
          __int16 v41 = *(const std::string::value_type **)(a2 + 24);
        }
        if (v40 >= 0) {
          std::string::size_type v42 = *(unsigned __int8 *)(a2 + 47);
        }
        else {
          std::string::size_type v42 = *(void *)(a2 + 32);
        }
        int v43 = std::string::append(&v81, v41, v42);
        __int128 v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__l.__cap_ = v43->__r_.__value_.__l.__cap_;
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v44;
        v43->__r_.__value_.__l.__size_ = 0LL;
        v43->__r_.__value_.__l.__cap_ = 0LL;
        v43->__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v45 = &buf;
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v45 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        }
        LODWORD(v81.__r_.__value_.__l.__data_) = 134283779;
        *(double *)((char *)v81.__r_.__value_.__r.__words + 4) = v7;
        WORD2(v81.__r_.__value_.__r.__words[1]) = 2081;
        *(std::string::size_type *)((char *)&v81.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v45;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "FenceCal: combine non-fine non-large fence, distance, %{private}.1lf, %{private}s",  (uint8_t *)&v81,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&v81, 0x65CuLL);
        if (qword_101934870 != -1) {
          dispatch_once(&qword_101934870, &stru_10184C310);
        }
        uint64_t v46 = qword_101934878;
        sub_10065EF44((const void **)a2, &buf);
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v47 = &buf;
        }
        else {
          uint64_t v47 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        }
        int v77 = 134283779;
        double v78 = v7;
        __int16 v79 = 2081;
        double v80 = v47;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v81,  1628LL,  &_mh_execute_header,  v46,  2LL,  "FenceCal: combine non-fine non-large fence, distance, %{private}.1lf, %{private}s",  &v77,  22);
        uint64_t v49 = v48;
LABEL_195:
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLCombinedFencesList::addFenceToCombinedList(std::list<CLFenceManager_Type::CombinedFence> &, cons t CLFenceManager_Type::Fence &, BOOL)",  "%s\n",  (const char *)v49);
        if (v49 != &v81) {
          free(v49);
        }
        goto LABEL_79;
      }

      goto LABEL_79;
    }

void sub_1006FFDD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1006FFE14(uint64_t a1, double a2, double a3)
{
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)&qword_1019982A0);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1019982A0))
  {
    sub_100D2D9A4((uint64_t)dbl_101998278);
    __cxa_guard_release(&qword_1019982A0);
  }

  if (*(void *)(a1 + 264)) {
    return sub_100D2DBDC( dbl_101998278,  a2,  a3,  *(double *)(*(void *)(a1 + 248) + 104LL),  *(double *)(*(void *)(a1 + 248) + 112LL),  0.0);
  }
  double v8 = sub_100D2DBDC(dbl_101998278, a2, a3, *(double *)(a1 + 72), *(double *)(a1 + 80), 0.0);
  if (qword_101934870 != -1) {
    dispatch_once(&qword_101934870, &stru_10184C310);
  }
  uint64_t v9 = (os_log_s *)qword_101934878;
  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
  {
    sub_100923668(a1, __p);
    BOOL v10 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
        ? __p
        : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136380931;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2049;
    *(double *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Fence: why is this used?, %{private}s, %{private}lf",  (uint8_t *)&buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_10184C310);
    }
    uint64_t v11 = qword_101934878;
    sub_100923668(a1, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    int v16 = 136380931;
    BOOL v17 = p_buf;
    __int16 v18 = 2049;
    double v19 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v11,  0LL,  "#Warning Fence: why is this used?, %{private}s, %{private}lf",  &v16,  22);
    int v14 = v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLFenceManager_Type::CombinedFence::distanceTo(double, double) const",  "%s\n",  (const char *)v14);
    if (v14 != __p) {
      free(v14);
    }
  }

  return v8;
}

void sub_100700100(_Unwind_Exception *a1)
{
}

void sub_100700120(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 184) == -1) {
    sub_101246168();
  }
  sub_100700BFC((uint64_t **)(a1 + 248), (unsigned __int8 *)a2, (__int128 *)a2);
  double v4 = *(double *)(a2 + 80);
  double v5 = v4 + 360.0;
  if (v4 >= 0.0) {
    double v5 = *(double *)(a2 + 80);
  }
  double v6 = v5 + *(double *)(a1 + 288);
  *(double *)(a1 + 280) = *(double *)(a2 + 72) + *(double *)(a1 + 280);
  *(double *)(a1 + 28_Block_object_dispose(va, 8) = v6;
  double v7 = *(double *)(a1 + 296);
  if (v7 <= sub_1009232CC(a2)) {
    *(double *)(a1 + 296) = sub_1009232CC(a2);
  }
  if (*(void *)(a1 + 264) == 1LL)
  {
    std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_DWORD *)(a1 + 180) = *(_DWORD *)(a2 + 180);
    *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
    *(_DWORD *)(a1 + 184) = sub_100923FF0(a2);
    *(_BYTE *)(a1 + 18_Block_object_dispose(va, 8) = *(_BYTE *)(a2 + 188);
    int v8 = (*(unsigned __int8 *)(a2 + 160) >> 5) & 1;
LABEL_12:
    *(_BYTE *)(a1 + 30_Block_object_dispose(va, 8) = v8;
    goto LABEL_13;
  }

  if (*(_BYTE *)(a2 + 188)) {
    *(_BYTE *)(a1 + 18_Block_object_dispose(va, 8) = 1;
  }
  if ((*(_BYTE *)(a2 + 160) & 0x20) != 0)
  {
    LOBYTE(v_Block_object_dispose(va, 8) = 1;
    goto LABEL_12;
  }

uint64_t sub_100700244(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 != a1)
  {
    while (1)
    {
      unint64_t v2 = *(void *)(v1 + 280);
      if (!v2) {
        break;
      }
      double v3 = *(double *)(v1 + 304) / (double)v2;
      *(double *)(v1 + 8_Block_object_dispose(va, 8) = *(double *)(v1 + 296) / (double)v2;
      *(double *)(v1 + 96) = v3;
      uint64_t v4 = *(void *)(v1 + 312);
      *(void *)(v1 + 104) = v4;
      *(void *)(v1 + 112) = v4;
      if (v3 > 180.0) {
        *(double *)(v1 + 96) = v3 + -360.0;
      }
      uint64_t v1 = *(void *)(v1 + 8);
      if (v1 == a1) {
        return 1LL;
      }
    }

    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_10184C310);
    }
    double v5 = (os_log_s *)qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "FenceCal: No fences", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_10184C310);
      }
      v9[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "FenceCal: No fences",  v9,  2);
      int v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLCombinedFencesList::finalizeCombinedFencesList(std::list<CLFenceManager_Type::CombinedFence> &)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  return 1LL;
}

void sub_100700430(id a1)
{
  qword_101934878 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeoFencing");
}

uint64_t sub_10070045C(uint64_t a1)
{
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = a1 + 256;
  *(_BYTE *)(a1 + 272) = 0;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 280) = 0LL;
  *(_DWORD *)(a1 + 304) = -1;
  *(_BYTE *)(a1 + 30_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_10070051C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100700568(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(void *)(a1 + 232) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_1007005F0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1007005F0(a1, *a2);
    sub_1007005F0(a1, a2[1]);
    sub_100700638((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_100700638(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(void *)(a1 + 232) = v2;
    operator delete(v2);
  }
}

void *sub_1007006B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7 = operator new(0x148uLL);
  *double v7 = a2;
  v7[1] = a3;
  sub_100700714((uint64_t)(v7 + 2), a4);
  return v7;
}

void sub_100700700(_Unwind_Exception *a1)
{
}

uint64_t sub_100700714(uint64_t a1, uint64_t a2)
{
  char v4 = sub_1002718F0((char *)a1, (__int128 *)a2);
  sub_100700790((uint64_t *)v4 + 31, a2 + 248);
  __int128 v5 = *(_OWORD *)(a2 + 272);
  __int128 v6 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 301) = *(void *)(a2 + 301);
  *(_OWORD *)(a1 + 272) = v5;
  *(_OWORD *)(a1 + 28_Block_object_dispose(va, 8) = v6;
  return a1;
}

void sub_100700760(_Unwind_Exception *a1)
{
  double v3 = *(void **)(v1 + 224);
  if (v3)
  {
    *(void *)(v1 + 232) = v3;
    operator delete(v3);
  }

  sub_1012462D4(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100700790(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1007007E4(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_1007007CC(_Unwind_Exception *a1)
{
}

uint64_t *sub_1007007E4(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    __int128 v5 = (uint64_t **)result;
    __int128 v6 = result + 1;
    do
    {
      __n128 result = sub_100700868(v5, v6, v4 + 32, (__int128 *)v4 + 2);
      double v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          char v8 = v7;
          double v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          char v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          char v4 = v8;
        }

        while (!v9);
      }

      char v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100700868(uint64_t **a1, uint64_t *a2, unsigned __int8 *a3, __int128 *a4)
{
  __int128 v6 = sub_1007008FC(a1, a2, &v12, &v11, a3);
  double v7 = *(uint64_t **)v6;
  if (!*(void *)v6)
  {
    char v8 = (uint64_t **)v6;
    sub_100700A80((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000085FC(a1, (uint64_t)v12, v8, v10[0]);
    double v7 = v10[0];
    v10[0] = 0LL;
    sub_100700AE8((uint64_t)v10, 0LL);
  }

  return v7;
}

unsigned __int8 *sub_1007008FC( void *a1, uint64_t *a2, unsigned __int8 **a3, uint64_t *a4, unsigned __int8 *a5)
{
  BOOL v9 = (unsigned __int8 *)(a1 + 1);
  if (a1 + 1 == a2 || sub_100923324(a5, (unsigned __int8 *)a2 + 32))
  {
    if ((uint64_t *)*a1 == a2)
    {
      double v12 = (unsigned __int8 *)a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 8;
      }

      else
      {
        *a3 = (unsigned __int8 *)a2;
        return (unsigned __int8 *)a2;
      }
    }

    uint64_t v11 = (unsigned __int8 *)*a2;
    if (*a2)
    {
      do
      {
        double v12 = v11;
        uint64_t v11 = (unsigned __int8 *)*((void *)v11 + 1);
      }

      while (v11);
    }

    else
    {
      int v16 = a2;
      do
      {
        double v12 = (unsigned __int8 *)v16[2];
        BOOL v17 = *(void *)v12 == (void)v16;
        int v16 = (uint64_t *)v12;
      }

      while (v17);
    }

    return (unsigned __int8 *)sub_1006695D4((uint64_t)a1, a3, a5);
  }

  if (sub_100923324((unsigned __int8 *)a2 + 32, a5))
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      int v14 = (unsigned __int8 *)a2[1];
      do
      {
        BOOL v15 = v14;
        int v14 = *(unsigned __int8 **)v14;
      }

      while (v14);
    }

    else
    {
      __int16 v18 = (unsigned __int8 *)a2;
      do
      {
        BOOL v15 = (unsigned __int8 *)*((void *)v18 + 2);
        BOOL v17 = *(void *)v15 == (void)v18;
        __int16 v18 = v15;
      }

      while (!v17);
    }

    if (v15 != v9)
    {
      uint64_t v13 = *a4;
    }

    if (v13)
    {
      *a3 = v15;
      return v15;
    }

    else
    {
      *a3 = (unsigned __int8 *)a2;
    }

    return (unsigned __int8 *)a4;
  }

  *a3 = (unsigned __int8 *)a2;
  *a4 = (uint64_t)a2;
  return (unsigned __int8 *)a4;
}

char *sub_100700A80@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  __int128 v6 = (char *)operator new(0x118uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  __n128 result = sub_1002718F0(v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_100700AD0(_Unwind_Exception *a1)
{
}

void sub_100700AE8(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100700638((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t sub_100700B2C(uint64_t **a1, unsigned __int8 *a2)
{
  double v3 = (uint64_t *)sub_100700B84((uint64_t)a1, a2);
  char v4 = v3;
  sub_1000087E8(a1, v3);
  sub_100700638((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

uint64_t sub_100700B84(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = sub_100923324((unsigned __int8 *)(v3 + 32), a2);
    double v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      double v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

uint64_t *sub_100700BFC(uint64_t **a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v5 = (uint64_t **)sub_1006695D4((uint64_t)a1, &v10, a2);
  int v6 = *v5;
  if (!*v5)
  {
    double v7 = v5;
    sub_100700A80((uint64_t)a1, a3, (uint64_t)v9);
    sub_1000085FC(a1, v10, v7, v9[0]);
    int v6 = v9[0];
    v9[0] = 0LL;
    sub_100700AE8((uint64_t)v9, 0LL);
  }

  return v6;
}

double sub_100700C8C(void *a1)
{
  if (*a1 == a1[1]) {
    return 0.0;
  }
  else {
    return *(double *)(*a1 + 16LL);
  }
}

double sub_100700CA8(void *a1)
{
  uint64_t v1 = a1[1];
  if (*a1 == v1) {
    return 0.0;
  }
  else {
    return *(double *)(v1 - 64);
  }
}

uint64_t sub_100700CC4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = a3[1];
  *(void *)(a1 + _Block_object_dispose(va, 8) = *a3;
  *(void *)(a1 + 16) = v4;
  if (v4)
  {
    uint64_t v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  uint64_t v7 = a2[1];
  *(void *)(a1 + sub_10000AE14(v9 + 24) = *a2;
  *(void *)(a1 + 32) = v7;
  if (v7)
  {
    char v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  *(_BYTE *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 200) = 0LL;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(_BYTE *)(a1 + 184) = 0;
  sub_100700DB4(a1);
  return a1;
}

void sub_100700D78(_Unwind_Exception *a1)
{
  uint64_t v7 = v4;
  sub_100008390(v7, *v6);
  unint64_t v9 = *v5;
  if (*v5)
  {
    *(void *)(v2 + 12_Block_object_dispose(va, 8) = v9;
    operator delete(v9);
  }

  sub_10000AE14(v3);
  sub_10000AE14(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100700DB4(uint64_t a1)
{
  *(_DWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 86400 * v4;
  *(void *)(a1 + 176) = 0LL;
  __n128 result = sub_10023AE2C(v3, "MaximumTimeToSaveInDBS", &dword_10130F564, 0);
  *(_DWORD *)(a1 + 216) = v4;
  return result;
}

uint64_t sub_100700E30(uint64_t a1, unsigned __int8 a2)
{
  unsigned __int8 v24 = a2;
  sub_10070518C(&v24, &v20);
  sub_10070527C(&v20, &v22);
  sub_100705484(&v24, &v16);
  sub_100705574(&v16, &v18);
  sub_100700CC4(a1, &v22, &v18);
  uint64_t v3 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  unint64_t v6 = v17;
  if (v17)
  {
    uint64_t v7 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  unint64_t v9 = v23;
  if (v23)
  {
    uint64_t v10 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  double v12 = v21;
  if (v21)
  {
    uint64_t v13 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  sub_100700DB4(a1);
  return a1;
}

void sub_100700F94(_Unwind_Exception *a1)
{
}

uint64_t sub_100700FE8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = v2;
    operator delete(v2);
  }

  sub_10000AE14(a1 + 24);
  sub_10000AE14(a1 + 8);
  return a1;
}

void sub_100701034(int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 16) = xmmword_10130F530;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a3 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = _Q0;
  unint64_t v11 = 0xBFF0000000000000LL;
  *(void *)(a3 + 56) = 0xBFF0000000000000LL;
  double v12 = *(double *)a2;
  *(void *)(a3 + _Block_object_dispose(va, 8) = *(void *)a2;
  if (*(double *)(a2 + 504) > 0.0)
  {
    unint64_t v13 = *(void *)(a2 + 544);
    *(void *)(a3 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v13;
    unint64_t v11 = v13;
  }

  float v14 = 0.0;
  if (*(double *)(a2 + 704) > 0.0)
  {
    float v14 = *(double *)(a2 + 728);
    *(float *)(a3 + sub_10000AE14(v9 + 24) = v14;
  }

  float v15 = *(double *)(a2 + 1040);
  *(float *)(a3 + 32) = v15;
  double v16 = *(double *)(a2 + 1024);
  if (vabdd_f64(v16, v12) >= 5.0)
  {
    double v18 = -1.0;
    if (v16 > 0.0)
    {
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      double v19 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = *(void *)(a2 + 1024);
        *(_DWORD *)std::stringbuf::string_type buf = 134218240;
        double v81 = v12;
        __int16 v82 = 2048;
        uint64_t v83 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "Cadence timestamp is too old, entryTime, %f, cadenceTime, %f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v48 = *(void *)(a2 + 1024);
        int v52 = 134218240;
        double v53 = v12;
        __int16 v54 = 2048;
        uint64_t v55 = v48;
        LODWORD(v51) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "Cadence timestamp is too old, entryTime, %f, cadenceTime, %f",  COERCE_DOUBLE(&v52),  v51);
        uint64_t v50 = (uint8_t *)v49;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLCyclingFTPInput CLCyclingFTPDataStore::createDbEntryFromCalorieInputs(const CLNatalieModelInput::Data &)",  "%s\n",  v49);
        if (v50 != buf) {
          free(v50);
        }
      }
    }
  }

  else
  {
    float v17 = *(double *)(a2 + 1016);
    *(float *)(a3 + 2_Block_object_dispose(va, 8) = v17;
    double v18 = v17;
  }

  if (vabdd_f64(*(double *)(a2 + 1192), v12) >= 5.0)
  {
    double v23 = -1.0;
    double v24 = 0.0;
  }

  else
  {
    float v21 = *(double *)(a2 + 1200);
    float v22 = *(double *)(a2 + 1208);
    *(float *)(a3 + 16) = v21;
    *(float *)(a3 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v22;
    double v23 = v21;
    double v24 = v22;
  }

  if (v15 >= 0.0) {
    ++*a1;
  }
  if (v23 > 0.39) {
    ++a1[1];
  }
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10184C330);
  }
  std::string::size_type v25 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = *(void *)(a2 + 504);
    uint64_t v27 = *(void *)(a2 + 704);
    uint64_t v28 = *(void *)(a2 + 1024);
    uint64_t v29 = *(void *)(a2 + 1048);
    uint64_t v30 = *(void *)(a2 + 1192);
    int v31 = *a1;
    int v32 = a1[1];
    *(_DWORD *)std::stringbuf::string_type buf = 134221312;
    double v81 = v12;
    __int16 v82 = 2048;
    uint64_t v83 = v26;
    __int16 v84 = 2048;
    unint64_t v85 = v11;
    __int16 v86 = 2048;
    uint64_t v87 = v27;
    __int16 v88 = 2048;
    double v89 = v14;
    __int16 v90 = 2048;
    uint64_t v91 = v28;
    __int16 v92 = 2048;
    double v93 = v18;
    __int16 v94 = 2048;
    uint64_t v95 = v29;
    __int16 v96 = 2048;
    double v97 = v15;
    __int16 v98 = 2048;
    uint64_t v99 = v30;
    __int16 v100 = 2048;
    double v101 = v23;
    __int16 v102 = 2048;
    double v103 = v24;
    __int16 v104 = 1024;
    int v105 = v31;
    __int16 v106 = 1024;
    int v107 = v32;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "new FTP input,startTime,%f,odometerTime,%f,rawSpeed,%f,elevationTime,%f,vspeed,%f,cadenceTime,%f,cadence,%f,powerT ime,%f,power,%f,hrTime,%f,hr,%f,hrConfidence,%f,numSamplesWithPower,%d,numSamplesWithPowerAndHR,%d",  buf,  0x86u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v33 = *(double *)(a3 + 8);
    uint64_t v34 = *(void *)(a2 + 504);
    uint64_t v35 = *(void *)(a3 + 40);
    uint64_t v36 = *(void *)(a2 + 704);
    double v37 = *(float *)(a3 + 24);
    uint64_t v38 = *(void *)(a2 + 1024);
    double v39 = *(float *)(a3 + 28);
    uint64_t v40 = *(void *)(a2 + 1048);
    double v41 = *(float *)(a3 + 32);
    uint64_t v42 = *(void *)(a2 + 1192);
    double v43 = *(float *)(a3 + 20);
    int v44 = *a1;
    int v45 = a1[1];
    int v52 = 134221312;
    double v53 = v33;
    __int16 v54 = 2048;
    uint64_t v55 = v34;
    __int16 v56 = 2048;
    uint64_t v57 = v35;
    __int16 v58 = 2048;
    uint64_t v59 = v36;
    __int16 v60 = 2048;
    double v61 = v37;
    __int16 v62 = 2048;
    uint64_t v63 = v38;
    __int16 v64 = 2048;
    double v65 = v39;
    __int16 v66 = 2048;
    uint64_t v67 = v40;
    __int16 v68 = 2048;
    double v69 = v41;
    __int16 v70 = 2048;
    uint64_t v71 = v42;
    __int16 v72 = 2048;
    double v73 = v23;
    __int16 v74 = 2048;
    double v75 = v43;
    __int16 v76 = 1024;
    int v77 = v44;
    __int16 v78 = 1024;
    int v79 = v45;
    LODWORD(v51) = 134;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "new FTP input,startTime,%f,odometerTime,%f,rawSpeed,%f,elevationTime,%f,vspeed,%f,cadenceTime,%f,cadence,%f,powerT ime,%f,power,%f,hrTime,%f,hr,%f,hrConfidence,%f,numSamplesWithPower,%d,numSamplesWithPowerAndHR,%d",  COERCE_DOUBLE(&v52),  v51);
    uint64_t v47 = (uint8_t *)v46;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPInput CLCyclingFTPDataStore::createDbEntryFromCalorieInputs(const CLNatalieModelInput::Data &)",  "%s\n",  v46);
    if (v47 != buf) {
      free(v47);
    }
  }

void sub_1007015B0(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = a2;
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    uint64_t v3 = *(void **)(a1 + 200);
    if (!v3) {
      goto LABEL_12;
    }
    int v4 = (void *)(a1 + 200);
    do
    {
      uint64_t v5 = v3[4];
      BOOL v6 = v5 < a2;
      if (v5 >= a2) {
        uint64_t v7 = v3;
      }
      else {
        uint64_t v7 = v3 + 1;
      }
      if (!v6) {
        int v4 = v3;
      }
      uint64_t v3 = (void *)*v7;
    }

    while (*v7);
    if (v4 == (void *)(a1 + 200) || v4[4] > a2)
    {
LABEL_12:
      unint64_t v8 = (uint64_t **)(a1 + 192);
      sub_1003CF0F0((uint64_t **)(a1 + 192), &v30, &v30);
      unint64_t v9 = sub_1007057FC(v29, (uint64_t)v8);
      uint64_t v10 = sub_100701A74((uint64_t)v9, v29);
      sub_100008390((uint64_t)v29, (void *)v29[1]);
      uint64_t v11 = a1 + 144;
      (*(void (**)(uint64_t *__return_ptr, void, uint64_t))(**(void **)(a1 + 8) + 40LL))( v44,  *(void *)(a1 + 8),  a1 + 144);
      uuid_unparse((const unsigned __int8 *)(a1 + 144), out);
      if (v46)
      {
        if (v45 != v10)
        {
          sub_100701B74(v45, (uint64_t **)buf);
          double v12 = *(void **)buf;
          unint64_t v13 = *(void **)&buf[8];
          if (*(void *)buf != *(void *)&buf[8])
          {
            do
            {
              *(void *)int v31 = *v12;
              sub_1003CF0F0(v8, (uint64_t *)v31, (uint64_t *)v31);
              ++v12;
            }

            while (v12 != v13);
            double v12 = *(void **)buf;
          }

          if (v12)
          {
            *(void *)&uint8_t buf[8] = v12;
            operator delete(v12);
          }

          uint64_t v14 = *(void *)(a1 + 8);
          float v15 = sub_1007057FC(v28, (uint64_t)v8);
          uint64_t v16 = sub_100701A74((uint64_t)v15, v28);
          LOBYTE(v14) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 56LL))(v14, v11, v16);
          sub_100008390((uint64_t)v28, (void *)v28[1]);
          if ((v14 & 1) == 0)
          {
            if (qword_1019347A0 != -1) {
              dispatch_once(&qword_1019347A0, &stru_10184C330);
            }
            float v17 = (os_log_s *)qword_1019347A8;
            if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::stringbuf::string_type buf = 136315138;
              *(void *)&uint8_t buf[4] = out;
              _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Could not update the power meter id code in the db. sessionid, %s",  buf,  0xCu);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019347A0 != -1) {
                dispatch_once(&qword_1019347A0, &stru_10184C330);
              }
              *(_DWORD *)int v31 = 136315138;
              *(void *)&v31[4] = out;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "Could not update the power meter id code in the db. sessionid, %s",  v31);
              double v19 = (char *)v18;
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCyclingFTPDataStore::updatePowerMeterId(int64_t)",  "%s\n",  v18);
LABEL_37:
              if (v19 != buf) {
                free(v19);
              }
            }
          }
        }
      }

      else
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v20 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v21 = *(void *)(a1 + 160);
          uint64_t v22 = *(void *)(a1 + 176);
          *(_DWORD *)std::stringbuf::string_type buf = 136315906;
          *(void *)&uint8_t buf[4] = out;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v21;
          __int16 v39 = 2048;
          uint64_t v40 = v30;
          __int16 v41 = 2048;
          uint64_t v42 = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "There is a new power meter id but there is no information about the current session in the db. sessionid, %s , startTime, %f, power meter id, %lld, workout type, %ld",  buf,  0x2Au);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          uint64_t v23 = *(void *)(a1 + 160);
          uint64_t v24 = *(void *)(a1 + 176);
          *(_DWORD *)int v31 = 136315906;
          *(void *)&v31[4] = out;
          __int16 v32 = 2048;
          uint64_t v33 = v23;
          __int16 v34 = 2048;
          uint64_t v35 = v30;
          __int16 v36 = 2048;
          uint64_t v37 = v24;
          LODWORD(v26) = 42;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "There is a new power meter id but there is no information about the current session in the db. sessionid, %s , startTime, %f, power meter id, %lld, workout type, %ld",  v31,  v26,  v27,  v28[0]);
          double v19 = (char *)v25;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLCyclingFTPDataStore::updatePowerMeterId(int64_t)", "%s\n", v25);
          goto LABEL_37;
        }
      }
    }
  }

void sub_100701A3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26)
{
}

uint64_t sub_100701A74(uint64_t a1, void *a2)
{
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  do
  {
    uint64_t v5 = v3[4];
    if (v5 < 62) {
      goto LABEL_14;
    }
    v5 %= 0x3EuLL;
    BOOL v6 = (void *)*v2;
    if (!*v2) {
      goto LABEL_14;
    }
    uint64_t v7 = v2;
    do
    {
      uint64_t v8 = v6[4];
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        uint64_t v10 = v6;
      }
      else {
        uint64_t v10 = v6 + 1;
      }
      if (!v9) {
        uint64_t v7 = v6;
      }
      BOOL v6 = (void *)*v10;
    }

    while (*v10);
    if (v7 == v2 || v5 < v7[4]) {
LABEL_14:
    }
      uint64_t v4 = (uint64_t)(exp2((double)v5) + (double)v4);
    uint64_t v11 = (void *)v3[1];
    if (v11)
    {
      do
      {
        double v12 = v11;
        uint64_t v11 = (void *)*v11;
      }

      while (v11);
    }

    else
    {
      do
      {
        double v12 = (void *)v3[2];
        BOOL v13 = *v12 == (void)v3;
        uint64_t v3 = v12;
      }

      while (!v13);
    }

    uint64_t v3 = v12;
  }

  while (v12 != v2);
  return v4;
}

void sub_100701B74(uint64_t a1@<X1>, uint64_t **a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  if (a1 <= 0x3FFFFFFFFFFFFFFFLL)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 61LL;
    do
    {
      uint64_t v5 = v4;
      double v6 = ldexp(1.0, v4);
      uint64_t v7 = v3 - (uint64_t)v6;
      if (v3 >= (uint64_t)v6)
      {
        BOOL v9 = a2[1];
        unint64_t v8 = (unint64_t)a2[2];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = *a2;
          uint64_t v12 = v9 - *a2;
          unint64_t v13 = v12 + 1;
          uint64_t v14 = v8 - (void)v11;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          else {
            unint64_t v15 = v13;
          }
          if (v15)
          {
            uint64_t v16 = (char *)sub_1000071BC((uint64_t)(a2 + 2), v15);
            uint64_t v11 = *a2;
            BOOL v9 = a2[1];
          }

          else
          {
            uint64_t v16 = 0LL;
          }

          float v17 = (uint64_t *)&v16[8 * v12];
          uint64_t *v17 = v5;
          uint64_t v10 = v17 + 1;
          while (v9 != v11)
          {
            uint64_t v18 = *--v9;
            *--float v17 = v18;
          }

          *a2 = v17;
          a2[1] = v10;
          a2[2] = (uint64_t *)&v16[8 * v15];
          if (v11) {
            operator delete(v11);
          }
        }

        else
        {
          *BOOL v9 = v5;
          uint64_t v10 = v9 + 1;
        }

        a2[1] = v10;
        uint64_t v3 = v7;
      }

      uint64_t v4 = v5 - 1;
    }

    while (v5);
  }

void sub_100701CA0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_100701CC0(uint64_t a1, uint64_t a2)
{
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10184C330);
  }
  uint64_t v4 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
  {
    BOOL v5 = 0;
    uint64_t v6 = *(void *)(a1 + 176);
    BOOL v8 = v6 == 3 || (v6 & 0xFFFFFFFFFFFFFFFELL) == 4;
    double v9 = *(double *)(a2 + 16);
    double v10 = *(double *)(a1 + 160);
    if (v10 <= v9)
    {
      int v12 = *(_DWORD *)(a1 + 216);
      BOOL v11 = v9 - v10 < (double)v12;
    }

    else
    {
      BOOL v11 = 0;
      int v12 = *(_DWORD *)(a1 + 216);
    }

    uint64_t v13 = *(void *)(a1 + 160);
    uint64_t v14 = *(void *)(a2 + 1040);
    int v15 = *(unsigned __int8 *)(a1 + 44);
    int v16 = *(unsigned __int8 *)(a1 + 184);
    double v17 = vabdd_f64(*(double *)(a2 + 1048), *(double *)a2);
    *(_DWORD *)std::stringbuf::string_type buf = 67111680;
    *(_DWORD *)double v61 = v5;
    *(_WORD *)&v61[4] = 1024;
    *(_DWORD *)&v61[6] = v8;
    *(_WORD *)&v61[10] = 1024;
    *(_DWORD *)&v61[12] = v11;
    *(_WORD *)&v61[16] = 2048;
    *(double *)&v61[18] = v9;
    __int16 v62 = 2048;
    uint64_t v63 = v13;
    __int16 v64 = 1024;
    int v65 = v12;
    __int16 v66 = 2048;
    uint64_t v67 = v14;
    __int16 v68 = 1024;
    int v69 = v15;
    __int16 v70 = 1024;
    int v71 = v16;
    __int16 v72 = 2048;
    double v73 = v17;
    __int16 v74 = 2048;
    uint64_t v75 = 0x4014000000000000LL;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "shouldCommitInputData, %d, isCyclingWorkout, %d, inTimeRange, %d, now, %f, sessionStartTime, %f, maxPossibleDiffer ence, %d, power, %f, fApproximatePowerFromMets, %d, inPauseMode, %d, powerSampleTimediff, %f, powerSampleTimediffTolerance, %f",  buf,  0x58u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    uint64_t v39 = *(void *)(a1 + 176);
    BOOL v41 = v39 == 3 || (v39 & 0xFFFFFFFFFFFFFFFELL) == 4;
    double v42 = *(double *)(a2 + 16);
    double v43 = *(double *)(a1 + 160);
    if (v43 <= v42)
    {
      int v45 = *(_DWORD *)(a1 + 216);
      BOOL v44 = v42 - v43 < (double)v45;
    }

    else
    {
      BOOL v44 = 0;
      int v45 = *(_DWORD *)(a1 + 216);
    }

    double v46 = *(double *)(a1 + 160);
    uint64_t v47 = *(void *)(a2 + 1040);
    int v48 = *(unsigned __int8 *)(a1 + 44);
    int v49 = *(unsigned __int8 *)(a1 + 184);
    double v50 = vabdd_f64(*(double *)(a2 + 1048), *(double *)a2);
    *(_WORD *)&v54[8] = 1024;
    *(_DWORD *)&v54[10] = v41;
    *(_WORD *)&v54[14] = 1024;
    *(_DWORD *)&v54[16] = v44;
    *(_WORD *)&v54[20] = 2048;
    *(_WORD *)&v54[22] = LOWORD(v42);
    LOWORD(v55) = 1024;
    HIWORD(v55) = v45;
    LOWORD(v56) = 1024;
    *(_DWORD *)((char *)&v56 + 2) = v48;
    HIWORD(v56) = 1024;
    *(_DWORD *)uint64_t v57 = v49;
    *(_WORD *)&v57[4] = 2048;
    *(double *)&v57[6] = v50;
    __int16 v58 = 2048;
    uint64_t v59 = 0x4014000000000000LL;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "shouldCommitInputData, %d, isCyclingWorkout, %d, inTimeRange, %d, now, %f, sessionStartTime, %f, maxPossibleDiffer ence, %d, power, %f, fApproximatePowerFromMets, %d, inPauseMode, %d, powerSampleTimediff, %f, powerSampleTimediffTolerance, %f",  v54,  88,  67111680,  *(double *)&v54[8],  *(double *)&v54[16],  *(void *)&v42 >> 16,  v46,  v55,  v47,  v56,  *(double *)v57);
    int v52 = (uint8_t *)v51;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCyclingFTPDataStore::shouldCommitInputData(const CLNatalieModelInput::Data &)",  "%s\n",  v51);
    if (v52 != buf) {
      free(v52);
    }
  }

  if (!*(_BYTE *)(a1 + 44) && (*(double *)(a2 + 1040) < 0.0 || *(double *)(a2 + 928) <= 0.0))
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    uint64_t v35 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
    {
      int v36 = *(unsigned __int8 *)(a1 + 44);
      uint64_t v37 = *(void *)(a2 + 1040);
      uint64_t v38 = *(void *)(a2 + 928);
      *(_DWORD *)std::stringbuf::string_type buf = 67109632;
      *(_DWORD *)double v61 = v36;
      *(_WORD *)&v61[4] = 2048;
      *(void *)&v61[6] = v37;
      *(_WORD *)&v61[14] = 2048;
      *(void *)&v61[16] = v38;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "Cannot commit the data since there is no power or start time is 0. fApproximatePowerFromMets %d, power, %f, start time, %f ",  buf,  0x1Cu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v33 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "Cannot commit the data since there is no power or start time is 0. fApproximatePowerFromMets %d, power, %f, start time, %f ",  v54);
LABEL_74:
    uint64_t v30 = v32;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCyclingFTPDataStore::shouldCommitInputData(const CLNatalieModelInput::Data &)",  "%s\n",  v33);
LABEL_75:
    if (v30 != buf) {
      free(v30);
    }
    return 0LL;
  }

  if ((unint64_t)(*(void *)(a1 + 176) - 3LL) >= 3)
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    int v31 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "Cannot commit the data since it is not a cycling workout.",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    *(_WORD *)__int16 v54 = 0;
    LODWORD(v53) = 2;
    double v33 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "Cannot commit the data since it is not a cycling workout.",  v54,  *(void *)&v53,  *(_OWORD *)v54,  *(_OWORD *)&v54[16]);
    goto LABEL_74;
  }

  double v18 = *(double *)(a2 + 16);
  double v19 = *(double *)(a1 + 160);
  if (v19 > v18 || v18 - v19 >= (double)*(int *)(a1 + 216))
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    __int16 v34 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "Cannot commit the data since it is not in time range.",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v33 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "Cannot commit the data since it is not in time range.");
    goto LABEL_74;
  }

  BOOL result = *(_BYTE *)(a1 + 184) == 0;
  if (!(*(unsigned __int8 *)(a1 + 184) | *(unsigned __int8 *)(a1 + 44)))
  {
    double v21 = *(double *)(a2 + 1048);
    if (v21 <= 0.0) {
      return 0LL;
    }
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    uint64_t v22 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = *(void *)(a2 + 1048);
      double v24 = *(double *)a2;
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      *(void *)double v61 = v23;
      *(_WORD *)&v61[8] = 2048;
      *(double *)&v61[10] = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Power timestamp is too old, entryTime, %f, powerTime, %f",  buf,  0x16u);
    }

    BOOL v25 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v25)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      uint64_t v26 = *(void *)(a2 + 1048);
      double v27 = *(double *)a2;
      *(_DWORD *)__int16 v54 = 134218240;
      *(void *)&v54[4] = v26;
      *(_WORD *)&v54[12] = 2048;
      *(double *)&v54[14] = v27;
      LODWORD(v53) = 22;
      double v28 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "Power timestamp is too old, entryTime, %f, powerTime, %f",  COERCE_DOUBLE(v54),  v53);
      uint64_t v30 = v29;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLCyclingFTPDataStore::shouldCommitInputData(const CLNatalieModelInput::Data &)",  "%s\n",  v28);
      goto LABEL_75;
    }
  }

  return result;
}

uint64_t sub_100702550(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  __int128 v6 = a3[1];
  __int128 v7 = a3[2];
  *(_OWORD *)(a1 + 92) = *(__int128 *)((char *)a3 + 44);
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v7;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v5;
  uint64_t result = sub_100701CC0(a1, a2);
  if ((_DWORD)result)
  {
    sub_1007015B0(a1, *(int *)(a2 + 1056));
    sub_100701034((int *)a1, a2, (uint64_t)v9);
    return (*(uint64_t (**)(void, _BYTE *))(**(void **)(a1 + 24) + 16LL))(*(void *)(a1 + 24), v9);
  }

  return result;
}

void sub_1007025C8(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    while (1)
    {
      uint64_t v8 = *a3;
      uint64_t v7 = a3[1];
      __int128 v9 = *(_OWORD *)(v6 + 16);
      v72[0] = *(_OWORD *)v6;
      v72[1] = v9;
      __int128 v10 = *(_OWORD *)(v6 + 80);
      __int128 v12 = *(_OWORD *)(v6 + 32);
      __int128 v11 = *(_OWORD *)(v6 + 48);
      v72[4] = *(_OWORD *)(v6 + 64);
      v72[5] = v10;
      v72[2] = v12;
      v72[3] = v11;
      if (v8 == v7) {
        goto LABEL_22;
      }
      while (uuid_compare((const unsigned __int8 *)v8, (const unsigned __int8 *)v72 + 8))
      {
        v8 += 88LL;
        if (v8 == v7)
        {
          uint64_t v8 = v7;
          break;
        }
      }

      if (v8 == a3[1])
      {
LABEL_22:
        double v71 = 0.0;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        *(_OWORD *)&dst[16] = *(_OWORD *)(v6 + 24);
        *(void *)&__int128 v68 = *(void *)(v6 + 40);
        double v21 = operator new(0x30uLL);
        v21[1] = 0LL;
        v21[2] = 0LL;
        *double v21 = off_10184C560;
        v21[4] = 0LL;
        v21[5] = 0LL;
        uint64_t v21[3] = 0LL;
        *(void *)&__int128 v69 = v21 + 3;
        *((void *)&v69 + 1) = v21;
        double v22 = *(double *)(v6 + 56);
        *((void *)&v68 + 1) = *(void *)(v6 + 48);
        if (v22 == -1.0)
        {
          double v23 = *(float *)(a1 + 76);
          double v24 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
          double v25 = v24 + -44.0;
          if (!*(_BYTE *)(a1 + 96)) {
            double v25 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
          }
          if (v25 > v23) {
            double v23 = v25;
          }
          if (v23 >= v24) {
            double v23 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
          }
          *((double *)&v70 + 1) = v23;
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          uint64_t v26 = (os_log_s *)qword_1019347A8;
          if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)std::stringbuf::string_type buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "No recorded HRMax, computing from body metrics",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019347A0 != -1) {
              dispatch_once(&qword_1019347A0, &stru_10184C330);
            }
            v62[0] = 0;
            LODWORD(v61) = 2;
            double v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "No recorded HRMax, computing from body metrics",  v62,  v61);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLCyclingFTPHistory::Session> CLCyclingFTPDataStore::aggregateSessionDbRows(const std::vector< CLCyclingSessionSummaryDbRow> &) const",  "%s\n",  v27);
          }
        }

        else
        {
          *((double *)&v70 + 1) = v22;
        }

        double v28 = *(double *)(v6 + 64);
        if (v28 == -1.0) {
          double v28 = *(float *)(a1 + 72);
        }
        *(double *)&__int128 v70 = v28;
        uuid_copy(dst, (const unsigned __int8 *)(v6 + 8));
        double v71 = *(float *)(v6 + 72);
        unint64_t v29 = a3[1];
        if (v29 >= a3[2])
        {
          uint64_t v36 = sub_10070599C(a3, (__int128 *)dst);
        }

        else
        {
          __int128 v30 = *(_OWORD *)dst;
          __int128 v31 = v68;
          *(_OWORD *)(v29 + 16) = *(_OWORD *)&dst[16];
          *(_OWORD *)(v29 + 32) = v31;
          *(_OWORD *)unint64_t v29 = v30;
          *(void *)(v29 + 4_Block_object_dispose(va, 8) = v69;
          uint64_t v32 = *((void *)&v69 + 1);
          *(void *)(v29 + 56) = *((void *)&v69 + 1);
          if (v32)
          {
            double v33 = (unint64_t *)(v32 + 8);
            do
              unint64_t v34 = __ldxr(v33);
            while (__stxr(v34 + 1, v33));
          }

          __int128 v35 = v70;
          *(double *)(v29 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v71;
          *(_OWORD *)(v29 + 64) = v35;
          uint64_t v36 = v29 + 88;
        }

        a3[1] = v36;
        uint64_t v37 = (std::__shared_weak_count *)*((void *)&v69 + 1);
        if (*((void *)&v69 + 1))
        {
          uint64_t v38 = (unint64_t *)(*((void *)&v69 + 1) + 8LL);
          do
            unint64_t v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }

        goto LABEL_70;
      }

      double v13 = *(double *)(v6 + 24);
      double v14 = *(double *)(v8 + 24);
      *(double *)(v8 + 16) = v13;
      double v15 = *(double *)(v6 + 32);
      if (v14 >= v15) {
        double v15 = v14;
      }
      *(double *)(v8 + sub_10000AE14(v9 + 24) = v15;
      *(void *)(v8 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)(v6 + 48);
      if (*(void *)(v8 + 32) != *(void *)(v6 + 40))
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        int v16 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_FAULT))
        {
          uint64_t v17 = *(void *)(v8 + 32);
          uint64_t v18 = *(void *)(v6 + 40);
          *(_DWORD *)std::stringbuf::string_type buf = 134218240;
          uint64_t v64 = v17;
          __int16 v65 = 2048;
          uint64_t v66 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "found two workout ids with different workout types when aggregating sessions,%lu,%lu",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          uint64_t v55 = *(void *)(v8 + 32);
          uint64_t v56 = *(void *)(v6 + 40);
          *(_DWORD *)uuid_t dst = 134218240;
          *(void *)&dst[4] = v55;
          *(_WORD *)&dst[12] = 2048;
          *(void *)&dst[14] = v56;
          LODWORD(v61) = 22;
          uint64_t v57 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  17LL,  "found two workout ids with different workout types when aggregating sessions,%lu,%lu",  dst,  v61);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::vector<CLCyclingFTPHistory::Session> CLCyclingFTPDataStore::aggregateSessionDbRows(const std::vector<CL CyclingSessionSummaryDbRow> &) const",  "%s\n",  v57);
        }
      }

      double v19 = *(double *)(v8 + 72);
      double v20 = *(double *)(v6 + 56);
      if (v19 != -1.0) {
        break;
      }
      if (v20 != -1.0) {
        goto LABEL_53;
      }
      double v44 = *(float *)(a1 + 76);
      double v45 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      double v46 = v45 + -44.0;
      if (!*(_BYTE *)(a1 + 96)) {
        double v46 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      }
      if (v46 > v44) {
        double v44 = v46;
      }
      if (v44 >= v45) {
        double v44 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      }
      *(double *)(v8 + 72) = v44;
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      uint64_t v47 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v48 = *(void *)(v8 + 72);
        *(_DWORD *)std::stringbuf::string_type buf = 134217984;
        uint64_t v64 = v48;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEBUG,  "No recorded HRMax, computed from body metrics, %f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v49 = *(void *)(v8 + 72);
        *(_DWORD *)uuid_t dst = 134217984;
        *(void *)&dst[4] = v49;
        double v50 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "No recorded HRMax, computed from body metrics, %f",  COERCE_DOUBLE(dst));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLCyclingFTPHistory::Session> CLCyclingFTPDataStore::aggregateSessionDbRows(const std::vector<CLCy clingSessionSummaryDbRow> &) const",  "%s\n",  v50);
      }

void sub_100703050( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100703094( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>, double a5@<D0>, double a6@<D1>)
{
  double v20 = 0LL;
  double v21 = 0LL;
  uint64_t v22 = 0LL;
  *(_OWORD *)uint64_t v17 = 0u;
  __int128 v18 = 0u;
  int v19 = 0;
  if (*(_BYTE *)(a1 + 44))
  {
    v17[0] = (void *)0x4072C00000000000LL;
    sub_10004C5F8((char *)&v20, 0LL, 0LL, 0LL);
    *(void *)std::stringbuf::string_type buf = 4LL;
    sub_1000F9040((char *)&v17[1], (char *)buf, (uint64_t)v25, 1uLL);
  }

  else
  {
    *(void *)std::stringbuf::string_type buf = 0LL;
    v25[0] = 0LL;
    v25[1] = 0LL;
    sub_100705BE8((uint64_t)&__p, *(void **)a2, (void *)(a2 + 8), (uint64_t)buf);
    std::stringbuf::string_type __p = 0LL;
    double v15 = 0LL;
    uint64_t v16 = 0LL;
    sub_100705C74((uint64_t)v23, *(void **)a3, (void *)(a3 + 8), (uint64_t)&__p);
    v17[0] = (void *)0x4072C00000000000LL;
    int v19 = 1;
    sub_10004C5F8((char *)&v20, *(char **)buf, v25[0], (v25[0] - *(void *)buf) >> 2);
    sub_1000F9040((char *)&v17[1], (char *)__p, (uint64_t)v15, (v15 - (_BYTE *)__p) >> 3);
    if (__p)
    {
      double v15 = __p;
      operator delete(__p);
    }

    if (*(void *)buf)
    {
      v25[0] = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }

  std::stringbuf::string_type __p = 0LL;
  double v15 = 0LL;
  uint64_t v16 = 0LL;
  int v11 = (*(uint64_t (**)(void, void **, void **, double, double))(**(void **)(a1 + 8) + 24LL))( *(void *)(a1 + 8),  v17,  &__p,  a5,  a6);
  if (v11 != 100)
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    __int128 v12 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Failed to retrieve sessions when building history, %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      v23[0] = 67109120;
      v23[1] = v11;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Failed to retrieve sessions when building history, %d",  v23);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLCyclingFTPHistory::Session> CLCyclingFTPDataStore::getSessionsInTimeRange(CFAbsoluteTime, CFAbsolu teTime, const std::set<int> &, const std::set<CMWorkoutType> &) const",  "%s\n",  v13);
    }

    double v15 = __p;
  }

  sub_1007025C8(a1, (uint64_t *)&__p, a4);
  if (__p)
  {
    double v15 = __p;
    operator delete(__p);
  }

  if (v20)
  {
    double v21 = v20;
    operator delete(v20);
  }

  if (v17[1])
  {
    *(void **)&__int128 v18 = v17[1];
    operator delete(v17[1]);
  }

void sub_1007033DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10070343C(&a15);
  _Unwind_Resume(a1);
}

void *sub_10070343C(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }

  return a1;
}

void *sub_10070347C(uint64_t a1, uint64_t a2)
{
  v18[0] = (uint64_t)v18;
  v18[1] = (uint64_t)v18;
  v18[2] = 0LL;
  uint64_t v4 = *(void **)(a2 + 48);
  uint64_t v5 = (void *)*v4;
  uint64_t v6 = (void *)v4[1];
  while (v5 != v6)
  {
    v17[0] = v5[1];
    v17[1] = v5[5];
    v17[2] = 0LL;
    sub_100F4B62C(v18, (uint64_t)v17);
    v5[6] = v7;
    v5 += 8;
  }

  if (*(void *)(a2 + 32) == 4LL)
  {
    uint64_t v8 = *(uint64_t **)(a2 + 48);
    uint64_t v9 = *v8;
    uint64_t v10 = v8[1];
    if (*v8 == v10)
    {
      BOOL v11 = 1;
    }

    else
    {
      do
      {
        *(double *)(v9 + 56) = sub_100F29100(v9, *(float *)(a1 + 60));
        v9 += 64LL;
      }

      while (v9 != v10);
      BOOL v11 = *(void *)(a2 + 32) == 4LL;
    }

    if (*(_BYTE *)(a1 + 44)) {
      BOOL v12 = !v11;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12)
    {
      double v14 = *(uint64_t **)(a2 + 48);
      uint64_t v15 = *v14;
      uint64_t v16 = v14[1];
      while (v15 != v16)
      {
        *(float *)(v15 + 32) = sub_100F2912C(v15, *(float *)(a1 + 60));
        v15 += 64LL;
      }
    }
  }

  return sub_1001B4C40(v18);
}

void sub_10070358C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_1007035A8( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>, double a6@<D1>)
{
  BOOL v12 = (char *)operator new(0x30uLL);
  *((void *)v12 + 2) = 0LL;
  *((void *)v12 + 3) = 0LL;
  *(void *)BOOL v12 = off_10184C5B0;
  *((void *)v12 + 1) = 0LL;
  *((void *)v12 + 4) = 0LL;
  *((void *)v12 + 5) = 0LL;
  *a4 = v12 + 24;
  a4[1] = v12;
  sub_100703094(a1, a2, a3, (uint64_t *)&v13, a5, a6);
  sub_100705D64((void **)v12 + 3);
  *(_OWORD *)(v12 + sub_10000AE14(v9 + 24) = v13;
  *((void *)v12 + 5) = v14;
  uint64_t v14 = 0LL;
  __int128 v13 = 0uLL;
  uint64_t v15 = (void **)&v13;
  sub_1007058D4(&v15);
}

void sub_10070367C(_Unwind_Exception *a1)
{
}

void *sub_100703690(uint64_t a1, uint64_t a2)
{
  return sub_10070347C(a1, a2);
}

void sub_1007036D0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = (const unsigned __int8 *)(a2 + 64);
  uint64_t v8 = sub_100BEF6EC(*(void *)(a2 + 112), *(void *)(a2 + 120));
  unint64_t v9 = *(void *)(a1 + 176) & 0xFFFFFFFFFFFFFFFELL;
  if (v9 == 4) {
    *(_BYTE *)(a1 + 113) = 1;
  }
  uuid_unparse(v7, out);
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10184C330);
  }
  uint64_t v10 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    double v11 = *(double *)a2;
    uint64_t v12 = *(void *)(a2 + 8);
    *(_DWORD *)std::stringbuf::string_type buf = 134219010;
    uint64_t v37 = v8;
    __int16 v38 = 2048;
    uint64_t v39 = v6;
    __int16 v40 = 2048;
    double v41 = v11;
    __int16 v42 = 2048;
    uint64_t v43 = v12;
    __int16 v44 = 2080;
    double v45 = out;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "feed workout event, workout type: %ld, event type, %ld, start time, %f end time, %f, session Id, %s",  buf,  0x34u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v18 = *(double *)a2;
    uint64_t v19 = *(void *)(a2 + 8);
    int v26 = 134219010;
    uint64_t v27 = v8;
    __int16 v28 = 2048;
    uint64_t v29 = v6;
    __int16 v30 = 2048;
    double v31 = v18;
    __int16 v32 = 2048;
    uint64_t v33 = v19;
    __int16 v34 = 2080;
    __int128 v35 = out;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "feed workout event, workout type: %ld, event type, %ld, start time, %f end time, %f, session Id, %s",  &v26,  52);
    double v21 = (uint8_t *)v20;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPDataStore::WorkoutEventInfo CLCyclingFTPDataStore::feedWorkoutEvent(const CLMotionStateMediator_Type::WorkoutEvent &)",  "%s\n",  v20);
    if (v21 != buf) {
      free(v21);
    }
  }

  switch(v6)
  {
    case 13LL:
      goto LABEL_34;
    case 14LL:
    case 18LL:
      if (v8 == 33)
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        __int128 v13 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "ftp calculation in multi sport in transition.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          LOWORD(v26) = 0;
          LODWORD(v25) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "ftp calculation in multi sport in transition.",  &v26,  v25);
          double v23 = (uint8_t *)v22;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPDataStore::WorkoutEventInfo CLCyclingFTPDataStore::feedWorkoutEvent(const CLMotionStateMediator_ Type::WorkoutEvent &)",  "%s\n",  v22);
          if (v23 != buf) {
LABEL_43:
          }
            free(v23);
        }
      }

      else if (v8 == *(void *)(a1 + 176))
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v17 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "ftp calculation in multi sport, go back to the same workout.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          LOWORD(v26) = 0;
          LODWORD(v25) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "ftp calculation in multi sport, go back to the same workout.",  &v26,  v25);
          double v23 = (uint8_t *)v24;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCyclingFTPDataStore::WorkoutEventInfo CLCyclingFTPDataStore::feedWorkoutEvent(const CLMotionStateMediator_ Type::WorkoutEvent &)",  "%s\n",  v24);
          if (v23 != buf) {
            goto LABEL_43;
          }
        }
      }

      else
      {
        if (v9 == 4) {
          sub_100703D60(a1, 1, *(double *)a2);
        }
LABEL_34:
        sub_100704764(a1, v7, v8, *(double *)a2);
      }

void sub_100703D60(uint64_t a1, int a2, double a3)
{
  if (a2)
  {
    uint64_t v5 = (_OWORD *)(a1 + 144);
    (*(void (**)(__int128 *__return_ptr, void, uint64_t))(**(void **)(a1 + 8) + 40LL))( &v77,  *(void *)(a1 + 8),  a1 + 144);
    uuid_unparse((const unsigned __int8 *)(a1 + 144), out);
    if (v84)
    {
      *(_OWORD *)__int128 v70 = v77;
      *(void *)&v70[16] = v78;
      double v6 = v79;
      __int128 v53 = v81;
      __int128 v55 = v82;
      uint64_t v56 = v83;
      if (v80 != 0.0)
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v7 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 136315394;
          *(void *)&uint8_t buf[4] = out;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Looks like there was a crash for sessionid, %s, around time, %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          int v66 = 136315394;
          uint64_t v67 = out;
          __int16 v68 = 2048;
          double v69 = a3;
          LODWORD(v51) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Looks like there was a crash for sessionid, %s, around time, %f",  (const char *)&v66,  v51);
          double v46 = (char *)v45;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCyclingFTPDataStore::finishSession(const CFAbsoluteTime, BOOL)",  "%s\n",  v45);
          if (v46 != buf) {
            free(v46);
          }
        }

        *(void *)(a1 + 176) = v53;
      }

      if (*(double *)(a1 + 160) != v6)
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v8 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 136315394;
          *(void *)&uint8_t buf[4] = out;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Looks like there was a crash for sessionid, %s, before time, %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          int v66 = 136315394;
          uint64_t v67 = out;
          __int16 v68 = 2048;
          double v69 = a3;
          LODWORD(v51) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Looks like there was a crash for sessionid, %s, before time, %f",  (const char *)&v66,  v51);
          uint64_t v48 = (char *)v47;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCyclingFTPDataStore::finishSession(const CFAbsoluteTime, BOOL)",  "%s\n",  v47);
          if (v48 != buf) {
            free(v48);
          }
        }

        *(double *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v6;
        *(void *)(a1 + 176) = v53;
      }

      *(double *)(a1 + 16_Block_object_dispose(va, 8) = a3;
      double v9 = *(float *)(a1 + 72);
      double v10 = *(float *)(a1 + 76);
      double v11 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      double v12 = v11 + -44.0;
      if (!*(_BYTE *)(a1 + 96)) {
        double v12 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      }
      if (v12 > v10) {
        double v10 = v12;
      }
      if (v10 < v11) {
        double v11 = v10;
      }
      uint64_t v13 = *(void *)(a1 + 8);
      __int128 v57 = *(_OWORD *)v70;
      uint64_t v58 = *(void *)&v70[16];
      double v59 = v6;
      double v60 = a3;
      __int128 v61 = v53;
      double v62 = v11;
      double v63 = v9;
      __int128 v64 = v55;
      uint64_t v65 = v56;
      if (((*(uint64_t (**)(uint64_t, __int128 *))(*(void *)v13 + 48LL))(v13, &v57) & 1) == 0)
      {
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v14 = (os_log_s *)qword_1019347A8;
        if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 136315394;
          *(void *)&uint8_t buf[4] = out;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Could not update the end time for the session in the db. sessionid, %s, endTime, %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347A0 != -1) {
            dispatch_once(&qword_1019347A0, &stru_10184C330);
          }
          int v66 = 136315394;
          uint64_t v67 = out;
          __int16 v68 = 2048;
          double v69 = a3;
          LODWORD(v51) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "Could not update the end time for the session in the db. sessionid, %s, endTime, %f",  (const char *)&v66,  v51);
          double v50 = (char *)v49;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCyclingFTPDataStore::finishSession(const CFAbsoluteTime, BOOL)",  "%s\n",  v49);
          if (v50 != buf) {
            free(v50);
          }
        }
      }

      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      uint64_t v15 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 136315394;
        *(void *)&uint8_t buf[4] = out;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(double *)&buf[14] = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "The cycling session is added to the sessions. sessionid, %s, at time, %f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        int v66 = 136315394;
        uint64_t v67 = out;
        __int16 v68 = 2048;
        double v69 = a3;
        LODWORD(v51) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "The cycling session is added to the sessions. sessionid, %s, at time, %f",  (const char *)&v66,  v51);
        __int16 v44 = (char *)v43;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCyclingFTPDataStore::finishSession(const CFAbsoluteTime, BOOL)",  "%s\n",  v43);
        if (v44 != buf) {
          free(v44);
        }
      }

      __int128 v16 = *(_OWORD *)(a1 + 160);
      *(_OWORD *)std::stringbuf::string_type buf = *v5;
      *(_OWORD *)&uint8_t buf[16] = v16;
      v75[0] = *(void *)(a1 + 176);
      unint64_t v17 = *(void *)(a1 + 136);
      unint64_t v18 = *(void *)(a1 + 128);
      if (v18 >= v17)
      {
        uint64_t v29 = *(void *)(a1 + 120);
        unint64_t v30 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - v29) >> 3);
        unint64_t v31 = v30 + 1;
        if (v30 + 1 > 0x666666666666666LL) {
          sub_100007008();
        }
        unint64_t v32 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v29) >> 3);
        if (2 * v32 > v31) {
          unint64_t v31 = 2 * v32;
        }
        if (v32 >= 0x333333333333333LL) {
          unint64_t v33 = 0x666666666666666LL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33) {
          __int16 v34 = (char *)sub_100100EF8(a1 + 136, v33);
        }
        else {
          __int16 v34 = 0LL;
        }
        __int128 v35 = &v34[40 * v30];
        uint64_t v36 = &v34[40 * v33];
        *(_OWORD *)__int128 v35 = *(_OWORD *)buf;
        *((_OWORD *)v35 + 1) = *(_OWORD *)&buf[16];
        *((void *)v35 + 4) = v75[0];
        double v21 = v35 + 40;
        __int16 v38 = *(char **)(a1 + 120);
        uint64_t v37 = *(char **)(a1 + 128);
        if (v37 != v38)
        {
          do
          {
            __int128 v39 = *(_OWORD *)(v37 - 40);
            __int128 v40 = *(_OWORD *)(v37 - 24);
            *((void *)v35 - 1) = *((void *)v37 - 1);
            *(_OWORD *)(v35 - sub_10000AE14(v9 + 24) = v40;
            *(_OWORD *)(v35 - 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v39;
            v35 -= 40;
            v37 -= 40;
          }

          while (v37 != v38);
          uint64_t v37 = *(char **)(a1 + 120);
        }

        *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v35;
        *(void *)(a1 + 12_Block_object_dispose(va, 8) = v21;
        *(void *)(a1 + 136) = v36;
        if (v37) {
          operator delete(v37);
        }
      }

      else
      {
        __int128 v19 = *v5;
        __int128 v20 = *(_OWORD *)(a1 + 160);
        *(void *)(v18 + 32) = *(void *)(a1 + 176);
        *(_OWORD *)unint64_t v18 = v19;
        *(_OWORD *)(v18 + 16) = v20;
        double v21 = (char *)(v18 + 40);
      }

      *(void *)(a1 + 12_Block_object_dispose(va, 8) = v21;
    }

    else
    {
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      uint64_t v22 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v23 = *(void *)(a1 + 160);
        uint64_t v24 = *(void *)(a1 + 176);
        *(_DWORD *)std::stringbuf::string_type buf = 136315906;
        *(void *)&uint8_t buf[4] = out;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v23;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(double *)&buf[24] = a3;
        LOWORD(v75[0]) = 2048;
        *(void *)((char *)v75 + 2) = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "The session was ended but there is no information about the start of the session in the db. sessionid, %s, sta rtTime, %f, end time, %f, workout type: %ld",  buf,  0x2Au);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019347A0 != -1) {
          dispatch_once(&qword_1019347A0, &stru_10184C330);
        }
        uint64_t v25 = *(void *)(a1 + 160);
        uint64_t v26 = *(void *)(a1 + 176);
        *(_DWORD *)__int128 v70 = 136315906;
        *(void *)&v70[4] = out;
        *(_WORD *)&v70[12] = 2048;
        *(void *)&v70[14] = v25;
        *(_WORD *)&v70[22] = 2048;
        double v71 = a3;
        __int16 v72 = 2048;
        uint64_t v73 = v26;
        LODWORD(v51) = 42;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "The session was ended but there is no information about the start of the session in the db. sessionid, %s, sta rtTime, %f, end time, %f, workout type: %ld",  v70,  v51,  v52,  v54);
        __int16 v28 = (char *)v27;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCyclingFTPDataStore::finishSession(const CFAbsoluteTime, BOOL)",  "%s\n",  v27);
        if (v28 != buf) {
          free(v28);
        }
      }
    }
  }

  __int16 v42 = *(void **)(a1 + 200);
  double v41 = (void *)(a1 + 200);
  *(v41 - 3) = 0LL;
  *(_OWORD *)(v41 - 5) = 0u;
  *(_OWORD *)(v41 - 7) = 0u;
  sub_100008390((uint64_t)(v41 - 1), v42);
  *(v41 - 1) = v41;
  *double v41 = 0LL;
  v41[1] = 0LL;
}

void sub_100704764(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, double a4)
{
  *(_BYTE *)(a1 + 184) = 0;
  uuid_copy((unsigned __int8 *)(a1 + 144), a2);
  *(void *)(a1 + 176) = a3;
  *(void *)a1 = 0LL;
  if ((a3 & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    (*(void (**)(void *__return_ptr, void, const unsigned __int8 *))(**(void **)(a1 + 8) + 40LL))( v23,  *(void *)(a1 + 8),  a2);
    if (v24)
    {
      a4 = *(double *)&v23[3];
    }

    else
    {
      uuid_copy(v13, a2);
      double v14 = a4;
      uint64_t v15 = 0LL;
      uint64_t v16 = a3;
      int v20 = -1082130432;
      int v22 = -1082130432;
      uint64_t v17 = 0LL;
      double v8 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      double v9 = *(float *)(a1 + 76);
      double v10 = v8 + -44.0;
      if (!*(_BYTE *)(a1 + 96)) {
        double v10 = *(float *)(a1 + 68) * -0.699999988 + 208.0;
      }
      if (v10 > v9) {
        double v9 = v10;
      }
      if (v9 < v8) {
        double v8 = v9;
      }
      double v11 = *(float *)(a1 + 72);
      double v18 = v8;
      double v19 = v11;
      uint64_t v21 = 0LL;
      (*(void (**)(void, uint64_t *))(**(void **)(a1 + 8) + 16LL))(*(void *)(a1 + 8), &v12);
    }
  }

  *(double *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a4;
}

uint64_t sub_1007048B0(uint64_t a1)
{
  std::stringbuf::string_type __p = 0LL;
  double v9 = 0LL;
  double v10 = 0LL;
  int v2 = *(_DWORD *)(a1 + 40);
  uint64_t v3 = sub_10000701C((uint64_t)&v10, 1uLL);
  *(double *)uint64_t v3 = (double)v2;
  v3[1] = 0x7FEFFFFFFFFFFFFFLL;
  *((_BYTE *)v3 + 16) = 0;
  std::stringbuf::string_type __p = v3;
  double v10 = (char *)&v3[3 * v4];
  double v9 = v3 + 3;
  uint64_t v5 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), &__p);
  uint64_t v6 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 8) + 32LL))(*(void *)(a1 + 8), &__p);
  if (__p)
  {
    double v9 = __p;
    operator delete(__p);
  }

  return v6 + v5;
}

void sub_1007049A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007049C4(uint64_t a1, const unsigned __int8 *a2)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 8) + 40LL))(v12);
  if (v14) {
    return v13 != -1.0;
  }
  uuid_unparse(a2, out);
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10184C330);
  }
  uint64_t v4 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    double v10 = out;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "There is no session to calculate the ftp! session id, %s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    int v7 = 136315138;
    double v8 = out;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  16LL,  "There is no session to calculate the ftp! session id, %s",  (const char *)&v7);
    uint64_t v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLCyclingFTPDataStore::doesSessionHaveFtp(const unsigned char *)",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  return 0LL;
}

double sub_100704BAC(uint64_t a1, double a2, double a3)
{
  if (v7 == 0.0) {
    double v6 = (*(double (**)(void, double))(**(void **)(a1 + 8) + 80LL))(*(void *)(a1 + 8), a3);
  }
  double v8 = v6;
  double v9 = v7;
  double v10 = (a3 - v7) / 86400.0;
  if (v7 != 0.0 && ((v11 = v6 + -2.0, v10 >= 0.0) ? (BOOL v12 = v11 > a2) : (BOOL v12 = 0), v12))
  {
    double v13 = v8 * (v10 * -0.00714285714 + 1.0);
    double v14 = a2 * 0.09 * v10 + v8 * (v10 * -0.09 + 1.0);
    if (v13 >= a2) {
      double v15 = v8 * (v10 * -0.00714285714 + 1.0);
    }
    else {
      double v15 = a2;
    }
    if (v14 <= v13) {
      double v16 = v8 * (v10 * -0.00714285714 + 1.0);
    }
    else {
      double v16 = a2 * 0.09 * v10 + v8 * (v10 * -0.09 + 1.0);
    }
    if (v14 >= a2) {
      double v17 = v16;
    }
    else {
      double v17 = v15;
    }
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v18 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134220288;
      double v47 = a2;
      __int16 v48 = 2048;
      double v49 = v8;
      __int16 v50 = 2048;
      double v51 = v9;
      __int16 v52 = 2048;
      double v53 = v10;
      __int16 v54 = 2048;
      double v55 = a2 * 0.09 * v10 + v8 * (v10 * -0.09 + 1.0);
      __int16 v56 = 2048;
      double v57 = v8 * (v10 * -0.00714285714 + 1.0);
      __int16 v58 = 2048;
      uint64_t v59 = 0x4000000000000000LL;
      __int16 v60 = 2048;
      uint64_t v61 = 0x3F7D41D41D41D41ELL;
      __int16 v62 = 2048;
      uint64_t v63 = 0x3FB70A3D70A3D70ALL;
      __int16 v64 = 2048;
      double v65 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "EstimatedFTP, %f, lastFtp, %f, LastFtpTime, %f, daysDifference, %f, suggestedDecayedFtp, %f, maxAllowedDecayedFT P, %f, kMinimumWattDeltaToUseFTPDecay, %f, kMaxFTPDecayRatePerDay, %f, kBlendCoefficientForFTPDecay, %f, smoothedFtp, %f",  buf,  0x66u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      int v26 = 134220288;
      double v27 = a2;
      __int16 v28 = 2048;
      double v29 = v8;
      __int16 v30 = 2048;
      double v31 = v9;
      __int16 v32 = 2048;
      double v33 = v10;
      __int16 v34 = 2048;
      double v35 = a2 * 0.09 * v10 + v8 * (v10 * -0.09 + 1.0);
      __int16 v36 = 2048;
      double v37 = v8 * (v10 * -0.00714285714 + 1.0);
      __int16 v38 = 2048;
      uint64_t v39 = 0x4000000000000000LL;
      __int16 v40 = 2048;
      uint64_t v41 = 0x3F7D41D41D41D41ELL;
      __int16 v42 = 2048;
      uint64_t v43 = 0x3FB70A3D70A3D70ALL;
      __int16 v44 = 2048;
      double v45 = v17;
      LODWORD(v25) = 102;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "EstimatedFTP, %f, lastFtp, %f, LastFtpTime, %f, daysDifference, %f, suggestedDecayedFtp, %f, maxAllowedDecayedFT P, %f, kMinimumWattDeltaToUseFTPDecay, %f, kMaxFTPDecayRatePerDay, %f, kBlendCoefficientForFTPDecay, %f, smoothedFtp, %f",  COERCE_DOUBLE(&v26),  v25);
      int v22 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "const double CLCyclingFTPDataStore::decayEstimatedFTP(const double, const CFAbsoluteTime)",  "%s\n",  v21);
      if (v22 != buf) {
        free(v22);
      }
    }

    return v17;
  }

  else
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184C330);
    }
    double v19 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218752;
      double v47 = a2;
      __int16 v48 = 2048;
      double v49 = v8;
      __int16 v50 = 2048;
      double v51 = v9;
      __int16 v52 = 2048;
      double v53 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "There is a no need to smooth the ftp. Current ftp %f last ftp, %f. Last ftp time, %f, days Difference, %f",  buf,  0x2Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_10184C330);
      }
      int v26 = 134218752;
      double v27 = a2;
      __int16 v28 = 2048;
      double v29 = v8;
      __int16 v30 = 2048;
      double v31 = v9;
      __int16 v32 = 2048;
      double v33 = v10;
      LODWORD(v25) = 42;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "There is a no need to smooth the ftp. Current ftp %f last ftp, %f. Last ftp time, %f, days Difference, %f",  COERCE_DOUBLE(&v26),  v25);
      char v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "const double CLCyclingFTPDataStore::decayEstimatedFTP(const double, const CFAbsoluteTime)",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }
  }

  return a2;
}

uint64_t sub_10070509C(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = *(__int128 **)(a2 + 8);
  uint64_t v5 = *(__int128 **)(a2 + 16);
  if (v4 == v5) {
    return 1LL;
  }
  LODWORD(v9) = 1;
  do
  {
    __int128 v10 = *v4;
    __int128 v11 = v4[1];
    uint64_t v14 = *((void *)v4 + 4);
    v13[0] = v10;
    v13[1] = v11;
    uint64_t v9 = v9 & (*(unsigned int (**)(void, _OWORD *, double, double, double))(**(void **)(a1 + 8) + 64LL))( *(void *)(a1 + 8),  v13,  a3,  a4,  *((double *)&v11 + 1));
    uint64_t v4 = (__int128 *)((char *)v4 + 40);
  }

  while (v4 != v5);
  return v9;
}

void sub_100705160(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

void *sub_10070518C@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x198uLL);
  uint64_t result = sub_1007051E4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1007051D0(_Unwind_Exception *a1)
{
}

void *sub_1007051E4(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10184C360;
  sub_100B08084(a1 + 3, *a2);
  return a1;
}

void sub_100705220(_Unwind_Exception *a1)
{
}

void sub_100705234(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C360;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100705248(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C360;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10070526C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_10070527C@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x30uLL);
  uint64_t result = sub_1007052D4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1007052C0(_Unwind_Exception *a1)
{
}

void *sub_1007052D4(void *a1, uint64_t *a2)
{
  a1[2] = 0LL;
  *a1 = off_10184C3B0;
  a1[1] = 0LL;
  sub_10070537C((uint64_t)&v4, a1 + 3, a2);
  return a1;
}

void sub_100705320(_Unwind_Exception *a1)
{
}

void sub_100705334(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C3B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100705348(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C3B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10070536C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10070537C(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  char v4 = (std::__shared_weak_count *)a3[1];
  *a3 = 0LL;
  a3[1] = 0LL;
  *a2 = off_10184C400;
  a2[1] = v3;
  a2[2] = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void *sub_1007053FC(void *a1)
{
  *a1 = off_10184C400;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_100705430(void *a1)
{
  *a1 = off_10184C400;
  sub_10000AE14((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_100705464(uint64_t a1)
{
  return sub_100B0835C(*(void *)(a1 + 8));
}

uint64_t sub_10070546C(uint64_t a1, char **a2, double a3, double a4)
{
  return sub_100B08BD4(*(void *)(a1 + 8), a2, a3, a4);
}

uint64_t sub_100705474(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32LL))(*(void *)(a1 + 8));
}

void *sub_100705484@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  char v4 = operator new(0x1D0uLL);
  uint64_t result = sub_1007054DC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1007054C8(_Unwind_Exception *a1)
{
}

void *sub_1007054DC(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10184C448;
  sub_1009CF3C8(a1 + 3, *a2);
  return a1;
}

void sub_100705518(_Unwind_Exception *a1)
{
}

void sub_10070552C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C448;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100705540(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C448;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100705564(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_100705574@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  char v4 = operator new(0x30uLL);
  uint64_t result = sub_1007055CC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1007055B8(_Unwind_Exception *a1)
{
}

void *sub_1007055CC(void *a1, uint64_t *a2)
{
  a1[2] = 0LL;
  *a1 = off_10184C498;
  a1[1] = 0LL;
  sub_100705674((uint64_t)&v4, a1 + 3, a2);
  return a1;
}

void sub_100705618(_Unwind_Exception *a1)
{
}

void sub_10070562C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C498;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100705640(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C498;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100705664(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100705674(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  char v4 = (std::__shared_weak_count *)a3[1];
  *a3 = 0LL;
  a3[1] = 0LL;
  *a2 = off_10184C4E8;
  a2[1] = v3;
  a2[2] = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void *sub_1007056F4(void *a1)
{
  *a1 = off_10184C4E8;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_100705728(void *a1)
{
  *a1 = off_10184C4E8;
  sub_10000AE14((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_10070575C(uint64_t a1)
{
  return sub_1009CF6E4(*(void *)(a1 + 8));
}

uint64_t sub_100705764(uint64_t a1, uint64_t a2, void *a3, double a4, double a5)
{
  return sub_1009D0544(*(void *)(a1 + 8), a2, a3, a4, a5);
}

void sub_10070576C(uint64_t a1@<X0>, const unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_100705774(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  __int128 v3 = a2[3];
  v7[2] = a2[2];
  v7[3] = v3;
  __int128 v4 = a2[5];
  _DWORD v7[4] = a2[4];
  v7[5] = v4;
  __int128 v5 = a2[1];
  v7[0] = *a2;
  v7[1] = v5;
  return sub_1009D2818(v2, (uint64_t)v7);
}

uint64_t sub_1007057DC(uint64_t a1, const unsigned __int8 *a2, sqlite3_int64 a3)
{
  return sub_1009D29D4(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1007057E4(uint64_t a1, const unsigned __int8 *a2, double a3, double a4, double a5)
{
  return sub_1009D2B6C(*(void *)(a1 + 8), a2, a3, a4, a5);
}

double sub_1007057EC(uint64_t a1, double a2)
{
  return sub_1009D2D44(*(void *)(a1 + 8), a2);
}

double sub_1007057F4(uint64_t a1, double a2)
{
  return sub_1009D2F8C(*(void *)(a1 + 8), a2);
}

uint64_t *sub_1007057FC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100705850(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100705838(_Unwind_Exception *a1)
{
}

uint64_t *sub_100705850(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    __int128 v4 = a2;
    __int128 v5 = (uint64_t **)result;
    unint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100397640(v5, v6, v4 + 4, v4 + 4);
      unint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          double v8 = v7;
          unint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          double v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          __int128 v4 = v8;
        }

        while (!v9);
      }

      __int128 v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

void sub_1007058D4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    __int128 v4 = (char *)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 88;
        sub_10000AE14((uint64_t)(v4 - 40));
        __int128 v4 = v6;
      }

      while (v6 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100705948(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C560;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10070595C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C560;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100705980(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

uint64_t sub_10070599C(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v21[4] = a1 + 2;
  if (v9) {
    __int128 v10 = (char *)sub_100023598(v7, v9);
  }
  else {
    __int128 v10 = 0LL;
  }
  __int128 v11 = &v10[88 * v4];
  v21[0] = v10;
  v21[1] = v11;
  uint64_t v21[3] = &v10[88 * v9];
  __int128 v12 = *a2;
  __int128 v13 = a2[2];
  *((_OWORD *)v11 + 1) = a2[1];
  *((_OWORD *)v11 + 2) = v13;
  *(_OWORD *)__int128 v11 = v12;
  *((void *)v11 + 6) = *((void *)a2 + 6);
  uint64_t v14 = *((void *)a2 + 7);
  *((void *)v11 + 7) = v14;
  if (v14)
  {
    double v15 = (unint64_t *)(v14 + 8);
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  double v17 = &v10[88 * v4];
  __int128 v18 = a2[4];
  *((void *)v17 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *((void *)a2 + 10);
  *((_OWORD *)v17 + 4) = v18;
  v21[2] = v11 + 88;
  sub_100705AF8(a1, v21);
  uint64_t v19 = a1[1];
  sub_100705B98((uint64_t)v21);
  return v19;
}

void sub_100705AE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_100705AF8(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }

  else
  {
    do
    {
      uint64_t v5 = v4 - 88;
      __int128 v6 = *(_OWORD *)(v3 - 88);
      __int128 v7 = *(_OWORD *)(v3 - 72);
      *(_OWORD *)(v4 - 56) = *(_OWORD *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v7;
      *(_OWORD *)(v4 - 8_Block_object_dispose(va, 8) = v6;
      *(_OWORD *)(v4 - 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(v3 - 40);
      *(void *)(v3 - 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
      *(void *)(v3 - 32) = 0LL;
      __int128 v8 = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - _Block_object_dispose(va, 8) = *(void *)(v3 - 8);
      *(_OWORD *)(v4 - sub_10000AE14(v9 + 24) = v8;
      v3 -= 88LL;
      v4 -= 88LL;
    }

    while (v3 != v2);
  }

  a2[1] = v5;
  uint64_t v9 = *result;
  *uint64_t result = v5;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100705B98(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 88;
    sub_10000AE14(i - 40);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100705BE8(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v10 = a4;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  do
  {
    sub_10009CA94(&v10, (_DWORD *)v4 + 7);
    __int128 v6 = (void *)v4[1];
    if (v6)
    {
      do
      {
        __int128 v7 = v6;
        __int128 v6 = (void *)*v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        __int128 v7 = (void *)v4[2];
        BOOL v8 = *v7 == (void)v4;
        uint64_t v4 = v7;
      }

      while (!v8);
    }

    uint64_t v4 = v7;
  }

  while (v7 != v5);
  return v5;
}

void *sub_100705C74(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v10 = a4;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  do
  {
    sub_1000BBDB4(&v10, v4 + 4);
    __int128 v6 = (void *)v4[1];
    if (v6)
    {
      do
      {
        __int128 v7 = v6;
        __int128 v6 = (void *)*v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        __int128 v7 = (void *)v4[2];
        BOOL v8 = *v7 == (void)v4;
        uint64_t v4 = v7;
      }

      while (!v8);
    }

    uint64_t v4 = v7;
  }

  while (v7 != v5);
  return v5;
}

void sub_100705D00(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184C5B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100705D14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184C5B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100705D38(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_1007058D4(&v1);
}

void sub_100705D64(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 88;
        sub_10000AE14((uint64_t)(v3 - 40));
        uint64_t v3 = v5;
      }

      while (v5 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_100705DCC()
{
  if (qword_1019A15A8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A15A8 + 8LL))(qword_1019A15A8);
  }
  if (qword_1019A15B0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A15B0 + 8LL))(qword_1019A15B0);
  }
  uint64_t result = qword_1019A15B8;
  if (qword_1019A15B8) {
    return (*(uint64_t (**)(uint64_t))(*(void *)qword_1019A15B8 + 8LL))(qword_1019A15B8);
  }
  return result;
}

void sub_100705E28(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_1019982A8 & 1) == 0)
  {
    byte_1019982A8 = 1;
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::VerifyVersion( (wireless_diagnostics::google::protobuf::internal *)0x1E9808,  2005000,  (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenLogEntry.pb.cc",  a4);
    sub_1001BBE2C(v4, v5, v6, v7);
    BOOL v8 = operator new(0x20uLL);
    *BOOL v8 = off_10184C600;
    v8[1] = 0LL;
    v8[2] = 0LL;
    v8[3] = 0LL;
    qword_1019A15A8 = (uint64_t)v8;
    uint64_t v9 = operator new(0x38uLL);
    *uint64_t v9 = off_10184C6F0;
    v9[1] = 0LL;
    *((_DWORD *)v9 + 4) = 0;
    *((_BYTE *)v9 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    v9[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v9[4] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
    v9[5] = 0LL;
    v9[6] = 0LL;
    qword_1019A15B0 = (uint64_t)v9;
    uint64_t v10 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v10 = off_10184C678;
    *(_OWORD *)(v10 + _Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v10 + sub_10000AE14(v9 + 24) = 0u;
    qword_1019A15B8 = (uint64_t)v10;
    v8[1] = sub_1001BCCA0((uint64_t)v10, v11, v12, v13);
    uint64_t v15 = qword_1019A15B0;
    if (!qword_1019A15B0)
    {
      sub_100705E28();
      uint64_t v15 = qword_1019A15B0;
    }

    v8[2] = v15;
    uint64_t v16 = qword_1019A15B8;
    if (!qword_1019A15B8)
    {
      sub_100705E28();
      uint64_t v16 = qword_1019A15B8;
    }

    *(void *)(v15 + _Block_object_dispose(va, 8) = v16;
    wireless_diagnostics::google::protobuf::internal::OnShutdown( (wireless_diagnostics::google::protobuf::internal *)sub_100705DCC,  v14);
  }

void *sub_100705F44(void *result)
{
  *uint64_t result = off_10184C600;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100705F58(uint64_t result)
{
  *(void *)uint64_t result = off_10184C6F0;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(result + 16) = 0;
  *(_BYTE *)(result + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(void *)(result + sub_10000AE14(v9 + 24) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(result + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(void *)(result + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(result + 4_Block_object_dispose(va, 8) = 0LL;
  return result;
}

void sub_100705F80(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v11,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenLogEntry.pb.cc",  244LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v11,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }

  LOBYTE(v5) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      *(_DWORD *)(a1 + 28) |= 1u;
      uint64_t v6 = *(void **)(a1 + 8);
      if (!v6)
      {
        uint64_t v6 = operator new(0x40uLL);
        sub_1001BC5A4((uint64_t)v6);
        *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
      }

      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_1019A15A8 + 8);
      }
      sub_1001BC7F8((uint64_t)v6, v7);
      int v5 = *(_DWORD *)(a2 + 28);
    }

    if ((v5 & 2) != 0)
    {
      *(_DWORD *)(a1 + 28) |= 2u;
      BOOL v8 = *(void **)(a1 + 16);
      if (!v8)
      {
        BOOL v8 = operator new(0x38uLL);
        *BOOL v8 = off_10184C6F0;
        v8[1] = 0LL;
        *((_DWORD *)v8 + 4) = 0;
        *((_BYTE *)v8 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
        v8[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        id v8[4] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        v8[5] = 0LL;
        v8[6] = 0LL;
        *(void *)(a1 + 16) = v8;
      }

      uint64_t v9 = *(void *)(a2 + 16);
      if (!v9) {
        uint64_t v9 = *(void *)(qword_1019A15A8 + 16);
      }
      sub_10070673C((uint64_t)v8, v9);
    }
  }

void sub_1007060A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *sub_1007060D0(void *result)
{
  if ((void *)qword_1019A15A8 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t result = (void *)v1[2];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_10070612C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C600;
  sub_1007060D0(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_10070615C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C600;
  sub_1007060D0(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

uint64_t sub_100706190(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_1019A15A8;
  if (!qword_1019A15A8)
  {
    sub_100705E28(0LL, a2, a3, a4);
    return qword_1019A15A8;
  }

  return result;
}

void *sub_1007061BC()
{
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = off_10184C600;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_1007061E4(uint64_t result)
{
  uint64_t v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 28);
  if ((_BYTE)v2)
  {
    if ((*(_BYTE *)(result + 28) & 1) != 0)
    {
      uint64_t result = *(void *)(result + 8);
      if (result)
      {
        uint64_t result = sub_1001BCD04(result);
        int v2 = *(_DWORD *)(v1 + 28);
      }
    }

    if ((v2 & 2) != 0)
    {
      uint64_t result = *(void *)(v1 + 16);
      if (result) {
        uint64_t result = sub_100706230(result);
      }
    }
  }

  *(_DWORD *)(v1 + 2_Block_object_dispose(va, 8) = 0;
  return result;
}

uint64_t sub_100706230(uint64_t result)
{
  LOBYTE(v1) = *(_BYTE *)(result + 52);
  if ((_BYTE)v1)
  {
    if ((*(_BYTE *)(result + 52) & 1) != 0)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        if (*(_BYTE *)(v2 + 36))
        {
          *(void *)(v2 + _Block_object_dispose(va, 8) = 0LL;
          *(void *)(v2 + 16) = 0LL;
          *(void *)(v2 + sub_10000AE14(v9 + 24) = 0LL;
        }

        *(_DWORD *)(v2 + 36) = 0;
        int v1 = *(_DWORD *)(result + 52);
      }
    }

    *(_DWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    if ((v1 & 8) != 0)
    {
      uint64_t v3 = *(void *)(result + 24);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)uint64_t v3 = 0;
          *(void *)(v3 + _Block_object_dispose(va, 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }

    if ((*(_BYTE *)(result + 52) & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(result + 32);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(_BYTE **)uint64_t v4 = 0;
          *(void *)(v4 + _Block_object_dispose(va, 8) = 0LL;
        }

        else
        {
          *(_BYTE *)uint64_t v4 = 0;
          *(_BYTE *)(v4 + 23) = 0;
        }
      }
    }

    *(void *)(result + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  *(_DWORD *)(result + 52) = 0;
  return result;
}

uint64_t sub_1007062DC( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_17;
        }
        *(_DWORD *)(a1 + 28) |= 1u;
        BOOL v8 = *(void **)(a1 + 8);
        if (!v8)
        {
          BOOL v8 = operator new(0x40uLL);
          sub_1001BC5A4((uint64_t)v8);
          *(void *)(a1 + _Block_object_dispose(va, 8) = v8;
        }

        uint64_t v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v27)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v27 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v10 = *((_DWORD *)this + 14);
        int v11 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v10 + 1;
        if (v10 >= v11) {
          return 0LL;
        }
        int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v27);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
        int v14 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v14, 1);
        int v16 = v14 - 1;
        if (v16 < 0 == v15) {
          *((_DWORD *)this + 14) = v16;
        }
        double v17 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v17 < *((void *)this + 2) && *v17 == 18)
        {
          *((void *)this + 1) = v17 + 1;
          goto LABEL_29;
        }
      }

      int v7 = TagFallback & 7;
      if (v7 != 2) {
        goto LABEL_17;
      }
LABEL_29:
      *(_DWORD *)(a1 + 28) |= 2u;
      __int128 v18 = *(void **)(a1 + 16);
      if (!v18)
      {
        __int128 v18 = operator new(0x38uLL);
        void *v18 = off_10184C6F0;
        v18[1] = 0LL;
        *((_DWORD *)v18 + 4) = 0;
        *((_BYTE *)v18 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
        uint64_t v18[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        v18[4] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
        v18[5] = 0LL;
        v18[6] = 0LL;
        *(void *)(a1 + 16) = v18;
      }

      uint64_t v19 = (char *)*((void *)this + 1);
      if ((unint64_t)v19 >= *((void *)this + 2) || *v19 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v28)) {
          return 0LL;
        }
      }

      else
      {
        unsigned int v28 = *v19;
        *((void *)this + 1) = v19 + 1;
      }

      int v20 = *((_DWORD *)this + 14);
      int v21 = *((_DWORD *)this + 15);
      *((_DWORD *)this + 14) = v20 + 1;
      if (v20 >= v21) {
        return 0LL;
      }
      int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v28);
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v22);
      int v24 = *((_DWORD *)this + 14);
      BOOL v15 = __OFSUB__(v24, 1);
      int v25 = v24 - 1;
      if (v25 < 0 == v15) {
        *((_DWORD *)this + 14) = v25;
      }
      if (*((void *)this + 1) == *((void *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + _Block_object_dispose(va, 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }

    int v7 = TagFallback & 7;
LABEL_17:
    if (v7 == 4) {
      return 1LL;
    }
  }

void sub_100706590(_Unwind_Exception *a1)
{
}

uint64_t sub_1007065A4( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    goto LABEL_7;
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A15A8 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 28) & 2) != 0)
  {
LABEL_7:
    uint64_t v8 = *(void *)(v5 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A15A8 + 16);
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  }

  return result;
}

uint64_t sub_100706620(uint64_t a1, unint64_t a2)
{
  if (!*(_BYTE *)(a1 + 28))
  {
    uint64_t v3 = 0LL;
    goto LABEL_18;
  }

  if ((*(_BYTE *)(a1 + 28) & 1) == 0)
  {
    uint64_t v3 = 0LL;
    if ((*(_BYTE *)(a1 + 28) & 2) == 0) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_1019A15A8 + 8);
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1001BDBD0(v4, a2);
  int v6 = (int)v5;
  else {
    int v7 = 1;
  }
  uint64_t v3 = (v6 + v7 + 1);
  if ((*(_DWORD *)(a1 + 28) & 2) != 0)
  {
LABEL_12:
    uint64_t v8 = *(void *)(a1 + 16);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A15A8 + 16);
    }
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1007074DC(v8, a2);
    int v11 = (int)v9;
    else {
      int v12 = 1;
    }
    uint64_t v3 = (v3 + v11 + v12 + 1);
  }

void sub_1007066F0(uint64_t a1, void *lpsrc)
{
}

void sub_10070673C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v17,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenLogEntry.pb.cc",  1084LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v17,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v16, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v17);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 52);
  if (!(_BYTE)v5) {
    return;
  }
  if ((*(_BYTE *)(a2 + 52) & 1) != 0)
  {
    *(_DWORD *)(a1 + 52) |= 1u;
    int v6 = *(char **)(a1 + 8);
    if (!v6)
    {
      int v6 = (char *)operator new(0x28uLL);
      *(void *)int v6 = off_10184C678;
      *(_OWORD *)(v6 + _Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(v6 + sub_10000AE14(v9 + 24) = 0u;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
    }

    uint64_t v7 = *(void *)(a2 + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A15B0 + 8);
    }
    sub_1007069B8((uint64_t)v6, v7);
    int v5 = *(_DWORD *)(a2 + 52);
  }

  if ((v5 & 2) != 0)
  {
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    if ((sub_100706978(v8) & 1) == 0) {
      sub_101246388();
    }
    *(_DWORD *)(a1 + 52) |= 2u;
    *(_DWORD *)(a1 + 16) = v8;
    int v5 = *(_DWORD *)(a2 + 52);
  }

  if ((v5 & 4) != 0)
  {
    char v9 = *(_BYTE *)(a2 + 20);
    *(_DWORD *)(a1 + 52) |= 4u;
    *(_BYTE *)(a1 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
    int v5 = *(_DWORD *)(a2 + 52);
    if ((v5 & 8) == 0)
    {
LABEL_15:
      if ((v5 & 0x10) == 0) {
        goto LABEL_16;
      }
LABEL_23:
      int v12 = *(const std::string **)(a2 + 32);
      *(_DWORD *)(a1 + 52) |= 0x10u;
      unsigned int v13 = *(std::string **)(a1 + 32);
      if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        unsigned int v13 = (std::string *)operator new(0x18uLL);
        v13->__r_.__value_.__l.__size_ = 0LL;
        v13->__r_.__value_.__l.__cap_ = 0LL;
        v13->__r_.__value_.__r.__words[0] = 0LL;
        *(void *)(a1 + 32) = v13;
      }

      std::string::operator=(v13, v12);
      int v5 = *(_DWORD *)(a2 + 52);
      if ((v5 & 0x20) == 0)
      {
LABEL_17:
        if ((v5 & 0x40) == 0) {
          return;
        }
        goto LABEL_28;
      }

      goto LABEL_26;
    }
  }

  else if ((v5 & 8) == 0)
  {
    goto LABEL_15;
  }

  unsigned int v10 = *(const std::string **)(a2 + 24);
  *(_DWORD *)(a1 + 52) |= 8u;
  int v11 = *(std::string **)(a1 + 24);
  if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    int v11 = (std::string *)operator new(0x18uLL);
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    *(void *)(a1 + sub_10000AE14(v9 + 24) = v11;
  }

  std::string::operator=(v11, v10);
  int v5 = *(_DWORD *)(a2 + 52);
  if ((v5 & 0x10) != 0) {
    goto LABEL_23;
  }
LABEL_16:
  if ((v5 & 0x20) == 0) {
    goto LABEL_17;
  }
LABEL_26:
  unsigned int v14 = *(_DWORD *)(a2 + 40);
  if (v14 >= 4) {
    sub_101246360();
  }
  *(_DWORD *)(a1 + 52) |= 0x20u;
  *(_DWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v14;
  if ((*(_DWORD *)(a2 + 52) & 0x40) != 0)
  {
LABEL_28:
    unsigned int v15 = *(_DWORD *)(a2 + 44);
    if (v15 >= 3) {
      sub_101246338();
    }
    *(_DWORD *)(a1 + 52) |= 0x40u;
    *(_DWORD *)(a1 + 44) = v15;
  }

void sub_100706948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100706960()
{
  return 1LL;
}

void *sub_100706968@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.Raven.LogEntry");
}

uint64_t sub_100706978(unsigned int a1)
{
  uint64_t result = 1LL;
  if (a1 >= 0x30)
  {
    unsigned int v3 = a1 - 50;
    if (v3 > 0x32 || ((1LL << v3) & 0x4001FFFFFFFFFLL) == 0) {
      return 0LL;
    }
  }

  return result;
}

double sub_1007069B8(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPRavenLogEntry.pb.cc",  696LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      double result = *(double *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(double *)(a1 + _Block_object_dispose(va, 8) = result;
      int v6 = *(_DWORD *)(a2 + 36);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + sub_10000AE14(v9 + 24) = result;
  }

  return result;
}

void sub_100706A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100706AA0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C678;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100706AB0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C678;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100706AD0()
{
  v0 = (char *)operator new(0x28uLL);
  *(void *)v0 = off_10184C678;
  double result = 0.0;
  *(_OWORD *)(v0 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v0 + sub_10000AE14(v9 + 24) = 0u;
  return result;
}

uint64_t sub_100706B00(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + sub_10000AE14(v9 + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100706B18( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        int v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v7 = TagFallback >> 3;
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_27;
        }
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v12) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + _Block_object_dispose(va, 8) = v12;
        *(_DWORD *)(a1 + 36) |= 1u;
        char v9 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v9 < *((void *)this + 2) && *v9 == 17)
        {
          *((void *)this + 1) = v9 + 1;
LABEL_17:
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v12) & 1) == 0) {
            return 0LL;
          }
          *(void *)(a1 + 16) = v12;
          *(_DWORD *)(a1 + 36) |= 2u;
          unsigned int v10 = (_BYTE *)*((void *)this + 1);
          if ((unint64_t)v10 < *((void *)this + 2) && *v10 == 25)
          {
            *((void *)this + 1) = v10 + 1;
            goto LABEL_21;
          }
        }
      }

      if (v7 == 2)
      {
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_27;
        }
        goto LABEL_17;
      }

      if (v7 != 3)
      {
        int v8 = TagFallback & 7;
        goto LABEL_27;
      }

      int v8 = TagFallback & 7;
      if (v8 == 1) {
        break;
      }
LABEL_27:
      if (v8 == 4) {
        return 1LL;
      }
    }

uint64_t sub_100706CD0( uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 36);
  if ((v5 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  a2,  *(double *)(result + 8),  a3);
    int v5 = *(_DWORD *)(v4 + 36);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(double *)(v4 + 24),  a3);
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  a2,  *(double *)(v4 + 16),  a3);
  if ((*(_DWORD *)(v4 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(double *)(v4 + 24),  a3);
  }
  return result;
}

uint64_t sub_100706D48(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 36);
  if (*(_BYTE *)(a1 + 36))
  {
    unsigned int v2 = ((int)((_DWORD)v1 << 31) >> 31) & 9;
    if ((v1 & 2) != 0) {
      v2 += 9;
    }
    if ((v1 & 4) != 0) {
      uint64_t v1 = v2 + 9;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 32) = v1;
  return v1;
}

double sub_100706D80(uint64_t a1, void *lpsrc)
{
  return sub_1007069B8(a1, (uint64_t)lpsrc);
}

uint64_t sub_100706DCC()
{
  return 1LL;
}

void *sub_100706DD4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.Raven.RavenPlatformInfo.TimeStamp");
}

void sub_100706DE4(void *a1)
{
  uint64_t v2 = a1[3];
  if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v2 != 0)
  {
    operator delete((void *)v2);
  }

  uint64_t v4 = a1[4];
  if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v4 != 0)
  {
    operator delete((void *)v4);
  }

  if ((void *)qword_1019A15B0 != a1)
  {
    uint64_t v6 = a1[1];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

void sub_100706E90(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C6F0;
  sub_100706DE4(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100706EC0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_10184C6F0;
  sub_100706DE4(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

void *sub_100706EF4()
{
  uint64_t result = operator new(0x38uLL);
  *uint64_t result = off_10184C6F0;
  result[1] = 0LL;
  *((_DWORD *)result + 4) = 0;
  *((_BYTE *)result + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  result[3] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[4] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  result[5] = 0LL;
  result[6] = 0LL;
  return result;
}

uint64_t sub_100706F30( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + _Block_object_dispose(va, 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_25;
        }
        *(_DWORD *)(a1 + 52) |= 1u;
        int v8 = *(char **)(a1 + 8);
        if (!v8)
        {
          int v8 = (char *)operator new(0x28uLL);
          *(void *)int v8 = off_10184C678;
          *(_OWORD *)(v8 + _Block_object_dispose(va, 8) = 0u;
          *(_OWORD *)(v8 + sub_10000AE14(v9 + 24) = 0u;
          *(void *)(a1 + _Block_object_dispose(va, 8) = v8;
        }

        char v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v39)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v39 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v19 = *((_DWORD *)this + 14);
        int v20 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v19 + 1;
        if (v19 >= v20) {
          return 0LL;
        }
        int v21 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v39);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v21);
        int v23 = *((_DWORD *)this + 14);
        BOOL v24 = __OFSUB__(v23, 1);
        int v25 = v23 - 1;
        if (v25 < 0 == v24) {
          *((_DWORD *)this + 14) = v25;
        }
        int v26 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        int v11 = v26 + 1;
        *((void *)this + 1) = v11;
        goto LABEL_38;
      case 2u:
        int v7 = TagFallback & 7;
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_38:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v39);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v27 = v39;
        }

        else
        {
          unsigned int v27 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        if (sub_100706978(v27))
        {
          *(_DWORD *)(a1 + 52) |= 2u;
          *(_DWORD *)(a1 + 16) = v27;
        }

        double v29 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        unsigned int v13 = v29 + 1;
        *((void *)this + 1) = v13;
LABEL_48:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v39);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v30 = v39;
          double v31 = (_BYTE *)*((void *)this + 1);
          unint64_t v12 = *((void *)this + 2);
        }

        else
        {
          unsigned int v30 = *v13;
          double v31 = v13 + 1;
          *((void *)this + 1) = v31;
        }

        *(_BYTE *)(a1 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v30 != 0;
        int v14 = *(_DWORD *)(a1 + 52) | 4;
        *(_DWORD *)(a1 + 52) = v14;
        *((void *)this + 1) = v31 + 1;
LABEL_56:
        *(_DWORD *)(a1 + 52) = v14 | 8;
        __int16 v32 = *(void **)(a1 + 24);
        if (v32 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        {
          __int16 v32 = operator new(0x18uLL);
          v32[1] = 0LL;
          v32[2] = 0LL;
          *__int16 v32 = 0LL;
          *(void *)(a1 + sub_10000AE14(v9 + 24) = v32;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v32);
        if (!(_DWORD)result) {
          return result;
        }
        double v33 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v33 + 1;
LABEL_62:
        *(_DWORD *)(a1 + 52) |= 0x10u;
        __int16 v34 = *(void **)(a1 + 32);
        if (v34 == (void *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        {
          __int16 v34 = operator new(0x18uLL);
          v34[1] = 0LL;
          v34[2] = 0LL;
          *__int16 v34 = 0LL;
          *(void *)(a1 + 32) = v34;
        }

        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v34);
        if (!(_DWORD)result) {
          return result;
        }
        double v35 = (_BYTE *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        char v16 = v35 + 1;
        *((void *)this + 1) = v16;
LABEL_68:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v39);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v36 = v39;
        }

        else
        {
          unsigned int v36 = *v16;
          *((void *)this + 1) = v16 + 1;
        }

        if (v36 <= 3)
        {
          *(_DWORD *)(a1 + 52) |= 0x20u;
          *(_DWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v36;
        }

        double v37 = (_BYTE *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        __int128 v18 = v37 + 1;
        *((void *)this + 1) = v18;
LABEL_78:
        if ((unint64_t)v18 >= v17 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v39);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v38 = v39;
        }

        else
        {
          unsigned int v38 = *v18;
          *((void *)this + 1) = v18 + 1;
        }

        if (v38 <= 2)
        {
          *(_DWORD *)(a1 + 52) |= 0x40u;
          *(_DWORD *)(a1 + 44) = v38;
        }

        if (*((void *)this + 1) != *((void *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }

        *((_DWORD *)this + _Block_object_dispose(va, 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        break;
      case 3u:
        int v7 = TagFallback & 7;
        unsigned int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_48;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_25;
        }
        int v14 = *(_DWORD *)(a1 + 52);
        goto LABEL_56;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_62;
        }
        goto LABEL_25;
      case 6u:
        int v7 = TagFallback & 7;
        char v16 = (char *)*((void *)this + 1);
        unint64_t v15 = *((void *)this + 2);
        goto LABEL_68;
      case 7u:
        int v7 = TagFallback & 7;
        __int128 v18 = (char *)*((void *)this + 1);
        unint64_t v17 = *((void *)this + 2);
        goto LABEL_78;
      default:
        int v7 = TagFallback & 7;
LABEL_25:
        if (v7 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_1007073E4( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A15B0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 52);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 52);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }

uint64_t sub_1007074DC(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 52);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    goto LABEL_59;
  }

  if ((*(_BYTE *)(a1 + 52) & 1) == 0)
  {
    LODWORD(v4) = 0;
    if ((*(_BYTE *)(a1 + 52) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  uint64_t v5 = *(void *)(a1 + 8);
  if (!v5) {
    uint64_t v5 = *(void *)(qword_1019A15B0 + 8);
  }
  int v6 = *(unsigned __int8 *)(v5 + 36);
  if (*(_BYTE *)(v5 + 36))
  {
    int v7 = (v6 << 31 >> 31) & 9;
    if ((v6 & 2) != 0) {
      v7 += 9;
    }
    if ((v6 & 4) != 0) {
      int v6 = v7 + 9;
    }
    else {
      int v6 = v7;
    }
  }

  *(_DWORD *)(v5 + 32) = v6;
  LODWORD(v4) = v6 + 2;
  int v3 = *(_DWORD *)(a1 + 52);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v8 & 0x80000000) != 0)
    {
      int v9 = 11;
    }

    else if (v8 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 52);
    }

    else
    {
      int v9 = 2;
    }

    LODWORD(v4) = v9 + v4;
  }

void sub_1007076D8(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100707724()
{
  return 1LL;
}

void *sub_10070772C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.Raven.RavenPlatformInfo");
}

uint64_t sub_100707740(uint64_t a1, char a2, char a3, char a4, uint64_t a5, double a6, double a7, double a8)
{
  *(_BYTE *)a1 = a2;
  *(_BYTE *)(a1 + 1) = a4;
  *(_BYTE *)(a1 + 2) = a3;
  double v9 = a6;
  if (a6 < 0.0) {
    double v9 = 0.0;
  }
  *(double *)(a1 + _Block_object_dispose(va, 8) = v9;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a5;
  *(void *)(a1 + 32) = *(void *)(a5 + 16);
  *(void *)a5 = 0LL;
  *(void *)(a5 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a5 + 16) = 0LL;
  *(double *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a7;
  *(double *)(a1 + 4_Block_object_dispose(va, 8) = a8;
  if (*(double *)(a1 + 8) < 0.0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v10 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 134218496;
      uint64_t v24 = a1;
      __int16 v25 = 2048;
      uint64_t v26 = v11;
      __int16 v27 = 2048;
      uint64_t v28 = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning %p Scan delay of %Lf secs is invalid. Setting to the minimum of %Lf secs",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      uint64_t v13 = *(void *)(a1 + 8);
      int v17 = 134218496;
      uint64_t v18 = a1;
      __int16 v19 = 2048;
      uint64_t v20 = v13;
      __int16 v21 = 2048;
      uint64_t v22 = 0LL;
      LODWORD(v16) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning %p Scan delay of %Lf secs is invalid. Setting to the minimum of %Lf secs",  &v17,  v16);
      int v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLOldWifiScanner::WifiConfiguration::WifiConfiguration(CLWifiService_Type::ScanType, PassiveActiveType, Priority Type, cl::chrono::secondsf, std::vector<CLWifiService_Type::Notification>, cl::chrono::secondsf, cl::chrono::secondsf)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

  return a1;
}

void sub_10070796C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + sub_10000AE14(v9 + 24) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100707990(uint64_t result, uint64_t a2, double a3)
{
  *(void *)uint64_t result = 0LL;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(result + 16) = 0LL;
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(double *)(result + sub_10000AE14(v9 + 24) = a3;
  return result;
}

uint64_t sub_1007079B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  sub_10001B72C( (void *)(a1 + 16),  *(const void **)(a2 + 16),  *(void *)(a2 + 24),  (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 2);
  *(_OWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 40);
  sub_100709668((_BYTE *)(a1 + 56), a3);
  return a1;
}

void sub_100707A28(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + sub_10000AE14(v9 + 24) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100707A48(uint64_t a1, uint64_t a2, __int128 *a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v5 = (uint64_t *)(a1 + 8);
  *(_WORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0x10000000000000LL;
  __int128 v6 = *a3;
  *(void *)(a1 + 64) = 0LL;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v6;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  sub_10001B72C( (void *)(a1 + 64),  *((const void **)a3 + 2),  *((void *)a3 + 3),  (uint64_t)(*((void *)a3 + 3) - *((void *)a3 + 2)) >> 2);
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = *(__int128 *)((char *)a3 + 40);
  sub_100709668((_BYTE *)(a1 + 104), (uint64_t)a3 + 56);
  id v7 = objc_msgSend(objc_msgSend(*(id *)a1, "silo"), "newTimer");
  *(void *)(a1 + sub_10000AE14(v9 + 24) = v7;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  _DWORD v20[2] = sub_100707DDC;
  v20[3] = &unk_10181D3D0;
  v20[4] = a1;
  [v7 setHandler:v20];
  sub_10034FF34((uint64_t)sub_100707F98, a1, *(void **)a1, buf);
  uint64_t v8 = *(void *)buf;
  *(void *)std::stringbuf::string_type buf = 0LL;
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = *(void *)buf;
    *(void *)std::stringbuf::string_type buf = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  if (*(_BYTE *)(a1 + 136))
  {
    sub_1004EEF6C((uint64_t)sub_100708170, a1, *(void **)a1, buf);
    uint64_t v11 = *(void *)buf;
    *(void *)std::stringbuf::string_type buf = 0LL;
    uint64_t v12 = *v5;
    *uint64_t v5 = v11;
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      uint64_t v13 = *(void *)buf;
      *(void *)std::stringbuf::string_type buf = 0LL;
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10184C7A0);
  }
  unint64_t v14 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v15 = *(unsigned __int8 *)(a1 + 32);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(void *)&uint8_t buf[4] = a1;
    __int16 v26 = 1024;
    int v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%p INITIAL isWifiPowered=%d", buf, 0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    int v17 = *(unsigned __int8 *)(a1 + 32);
    int v21 = 134218240;
    uint64_t v22 = a1;
    __int16 v23 = 1024;
    int v24 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p INITIAL isWifiPowered=%d",  &v21,  18);
    __int16 v19 = (char *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLOldWifiScanner::CLOldWifiScanner(id<CLIntersiloUniverse>, CLOldWifiScanner::ScanningPolicy)",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

  return a1;
}

void sub_100707D68(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 16);
  *(void *)(v1 + sub_100708348(v2 - 16) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *v3;
  uint64_t *v3 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  _Unwind_Resume(a1);
}

void sub_100707DDC(uint64_t a1)
{
}

void sub_100707DE4(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10184C7A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134217984;
    uint64_t v8 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "%p TIMER TRIGGERED", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    int v5 = 134217984;
    uint64_t v6 = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p TIMER TRIGGERED",  &v5);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOldWifiScanner::onTimerTrigger()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_100708894(a1, *(double *)(a1 + 56));
}

void sub_100707F98(uint64_t a1, int *a2, unsigned __int8 *a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184C7C0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOldWifiScanner::onWifiNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184C7C0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      __int16 v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOldWifiScanner::onWifiNotification, event:%{public, location:escape_only}s, thi s:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100708EE0((uint64_t)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100708150( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100708170(uint64_t a1, _DWORD *a2, uint64_t a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184C7C0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOldWifiScanner::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184C7C0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      __int16 v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOldWifiScanner::onLocationNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100708C8C((uint64_t)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100708328( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100708348(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    uint64_t v2 = *(void **)(a1 + 56);
    if (v2)
    {
      *(void *)(a1 + 64) = v2;
      operator delete(v2);
    }
  }

  int v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + sub_10000AE14(v9 + 24) = v3;
    operator delete(v3);
  }

  return a1;
}

uint64_t sub_100708394(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 136))
  {
    uint64_t v2 = *(void **)(a1 + 104);
    if (v2)
    {
      *(void *)(a1 + 112) = v2;
      operator delete(v2);
    }
  }

  int v3 = *(void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 72) = v3;
    operator delete(v3);
  }

  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return a1;
}

void sub_100708424(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 33))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v2 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      uint64_t v11 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "%p Stop monitor for active scanning", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      int v8 = 134217984;
      uint64_t v9 = a1;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p Stop monitor for active scanning",  &v8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOldWifiScanner::stop()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:1];
    [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:4];
    [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:5];
    int v3 = *(unsigned int **)(a1 + 64);
    uint64_t v4 = *(unsigned int **)(a1 + 72);
    while (v3 != v4)
    {
      unsigned int v5 = *v3++;
      [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:v5];
    }

    if (*(_BYTE *)(a1 + 136)) {
      [*(id *)(*(void *)(a1 + 8) + 16) unregister:*(void *)(*(void *)(a1 + 8) + 8) forNotification:4];
    }
    *(_BYTE *)(a1 + 33) = 0;
    sub_100708894(a1, 1.79769313e308);
  }

void sub_100708654(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 33))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v2 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      uint64_t v11 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%p Start monitor for active scanning",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      int v8 = 134217984;
      uint64_t v9 = a1;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p Start monitor for active scanning",  &v8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOldWifiScanner::start()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:1 registrationInfo:0];
    [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:4 registrationInfo:0];
    [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:5 registrationInfo:0];
    int v3 = *(unsigned int **)(a1 + 64);
    uint64_t v4 = *(unsigned int **)(a1 + 72);
    while (v3 != v4)
    {
      unsigned int v5 = *v3++;
      [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:v5 registrationInfo:0];
    }

    if (*(_BYTE *)(a1 + 136)) {
      [*(id *)(*(void *)(a1 + 8) + 16) register:*(void *)(*(void *)(a1 + 8) + 8) forNotification:4 registrationInfo:0];
    }
    *(_BYTE *)(a1 + 33) = 1;
    sub_100708894(a1, *(double *)(a1 + 56));
  }

void sub_100708894(uint64_t a1, double a2)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (*(_BYTE *)(a1 + 33))
  {
    double v5 = Current_1;
    double v6 = a2 + *(double *)(a1 + 40);
    if (Current_1 < v6)
    {
      [*(id *)(a1 + 24) setNextFireDelay:v6 - Current_1];
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      int v8 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        [*(id *)(a1 + 24) nextFireTime];
        *(_DWORD *)std::stringbuf::string_type buf = 134218240;
        uint64_t v24 = a1;
        __int16 v25 = 2048;
        double v26 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%p WIFI SCAN SCHEDULED FOR %f", buf, 0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10184C7A0);
        }
        uint64_t v12 = qword_101934A78;
        [*(id *)(a1 + 24) nextFireTime];
        int v17 = 134218240;
        uint64_t v18 = a1;
        __int16 v19 = 2048;
        double v20 = v13;
        LODWORD(vsub_100708348(v2 - 16) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  2LL,  "%p WIFI SCAN SCHEDULED FOR %f",  &v17,  v16);
        int v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::scheduleNextScan(cl::chrono::secondsf)",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      uint64_t v7 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 134218496;
        uint64_t v24 = a1;
        __int16 v25 = 2048;
        double v26 = v5;
        __int16 v27 = 2048;
        double v28 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%p WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10184C7A0);
        }
        int v17 = 134218496;
        uint64_t v18 = a1;
        __int16 v19 = 2048;
        double v20 = v5;
        __int16 v21 = 2048;
        double v22 = v6;
        LODWORD(vsub_100708348(v2 - 16) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f",  &v17,  v16);
        uint64_t v11 = (uint8_t *)v10;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::scheduleNextScan(cl::chrono::secondsf)",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      *(double *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v5;
      sub_1007095C0(a1);
      [*(id *)(a1 + 24) setNextFireDelay:a2];
    }
  }

  else
  {
    [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  }

void sub_100708C8C(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (!*(_BYTE *)(a1 + 136)) {
    sub_1012463B0();
  }
  if ((*a3 | 4) == 4)
  {
    uint64_t v5 = *(void *)(a1 + 104);
    uint64_t v6 = *(void *)(a1 + 112);
    if (v5 == v6)
    {
      BOOL v10 = 1;
    }

    else
    {
      int v7 = *(_DWORD *)(a4 + 96);
      uint64_t v8 = v5 + 4;
      do
      {
        int v9 = *(_DWORD *)(v8 - 4);
        BOOL v11 = v9 == v7;
        BOOL v10 = v9 != v7;
        BOOL v11 = v11 || v8 == v6;
        v8 += 4LL;
      }

      while (!v11);
    }

    double v12 = *(double *)(a4 + 20);
    if (v12 > 0.0)
    {
      if (!v10)
      {
        *(CFAbsoluteTime *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = j__CFAbsoluteTimeGetCurrent_1();
        sub_100708894(a1, *(double *)(a1 + 56));
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10184C7A0);
        }
        double v13 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          [*(id *)(a1 + 24) nextFireTime];
          *(_DWORD *)std::stringbuf::string_type buf = 134218240;
          uint64_t v25 = a1;
          __int16 v26 = 2048;
          uint64_t v27 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%p Good GPS location received, hold off wifi scan, nextFire=%f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10184C7A0);
          }
          uint64_t v15 = qword_101934A78;
          [*(id *)(a1 + 24) nextFireTime];
          int v20 = 134218240;
          uint64_t v21 = a1;
          __int16 v22 = 2048;
          uint64_t v23 = v16;
          LODWORD(v19) = 22;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  2LL,  "%p Good GPS location received, hold off wifi scan, nextFire=%f",  &v20,  v19);
          uint64_t v18 = (uint8_t *)v17;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLo cationProvider_Type::NotificationData &)",  "%s\n",  v17);
          if (v18 != buf) {
            free(v18);
          }
        }
      }
    }
  }

void sub_100708EE0(uint64_t a1, uint64_t a2, int *a3, unsigned __int8 *a4)
{
  int v5 = *a3;
  if (*a3 == 5)
  {
    double v14 = *(double *)(a1 + 88);
    *(CFAbsoluteTime *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = j__CFAbsoluteTimeGetCurrent_1();
    sub_100708894(a1, v14);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v15 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      [*(id *)(a1 + 24) nextFireTime];
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      uint64_t v40 = a1;
      __int16 v41 = 2048;
      v42[0] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "%p WIFI NOTIFICATION SCAN BUSY, nextFire=%f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v17 = qword_101934A78;
    [*(id *)(a1 + 24) nextFireTime];
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  2LL,  "%p WIFI NOTIFICATION SCAN BUSY, nextFire=%f",  &v35);
LABEL_34:
    uint64_t v23 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type: :NotificationData &)",  "%s\n",  v18);
    if (v23 == buf) {
      return;
    }
    goto LABEL_54;
  }

  if (v5 == 4)
  {
    double v19 = *(double *)(a1 + 96);
    *(CFAbsoluteTime *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = j__CFAbsoluteTimeGetCurrent_1();
    sub_100708894(a1, v19);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    int v20 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      [*(id *)(a1 + 24) nextFireTime];
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      uint64_t v40 = a1;
      __int16 v41 = 2048;
      v42[0] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "%p WIFI NOTIFICATION SCAN ERROR, nextFire=%f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    uint64_t v22 = qword_101934A78;
    [*(id *)(a1 + 24) nextFireTime];
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  2LL,  "%p WIFI NOTIFICATION SCAN ERROR, nextFire=%f",  &v35);
    goto LABEL_34;
  }

  if (v5 == 1)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    int v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *a4;
      [*(id *)(a1 + 24) nextFireTime];
      *(_DWORD *)std::stringbuf::string_type buf = 134218496;
      uint64_t v40 = a1;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v8;
      WORD2(v42[0]) = 2048;
      *(void *)((char *)v42 + 6) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%p WIFI POWER NOTIFICATION RECEIVED, power=%d nextFire=%f",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10184C7A0);
      }
      uint64_t v28 = qword_101934A78;
      int v29 = *a4;
      [*(id *)(a1 + 24) nextFireTime];
      int v35 = 134218496;
      uint64_t v36 = a1;
      __int16 v37 = 1024;
      v38[0] = v29;
      LOWORD(v38[1]) = 2048;
      *(void *)((char *)&v38[1] + 2) = v30;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  2LL,  "%p WIFI POWER NOTIFICATION RECEIVED, power=%d nextFire=%f",  &v35,  28);
      __int16 v32 = (uint8_t *)v31;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Typ e::NotificationData &)",  "%s\n",  v31);
      if (v32 != buf) {
        free(v32);
      }
    }

    int v10 = *(unsigned __int8 *)(a1 + 32);
    int v11 = *a4;
    if (v10 != v11)
    {
      BOOL v12 = v10 != 0;
      if (*a4) {
        BOOL v13 = v10 != 0;
      }
      else {
        BOOL v13 = 1;
      }
      if (*a4) {
        BOOL v12 = 0;
      }
      if (!v12 && v13) {
        sub_10124651C();
      }
    }

    *(_BYTE *)(a1 + 32) = v11;
    return;
  }

  for (uint64_t i = *(_DWORD **)(a1 + 64); i != *(_DWORD **)(a1 + 72); ++i)
  {
    if (v5 == *i)
    {
      double v27 = *(double *)(a1 + 56);
      *(CFAbsoluteTime *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = j__CFAbsoluteTimeGetCurrent_1();
      sub_100708894(a1, v27);
      return;
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10184C7A0);
  }
  uint64_t v25 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v26 = (char)a4[1];
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    uint64_t v40 = a1;
    __int16 v41 = 1024;
    LODWORD(v42[0]) = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "%p UNHANDLED WIFI NOTIFICATION, type=%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10184C7A0);
    }
    int v33 = (char)a4[1];
    int v35 = 134218240;
    uint64_t v36 = a1;
    __int16 v37 = 1024;
    v38[0] = v33;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "%p UNHANDLED WIFI NOTIFICATION, type=%d",  &v35,  18);
    uint64_t v23 = (uint8_t *)v34;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOldWifiScanner::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type: :NotificationData &)",  "%s\n",  v34);
    if (v23 != buf) {
LABEL_54:
    }
      free(v23);
  }

id sub_1007095C0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 32)) {
    return objc_msgSend( objc_msgSend( objc_msgSend(*(id *)a1, "vendor", *(double *)(a1 + 56)),  "proxyForService:",  @"CLWifiService"),  "syncgetStartScanWithType:lowPriority:passive:requester:",  *(char *)(a1 + 48),  *(unsigned __int8 *)(a1 + 49),  *(unsigned __int8 *)(a1 + 50),  "oldscanner");
  }
  else {
    return 0LL;
  }
}

void sub_10070963C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

_BYTE *sub_100709668(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[32] = 0;
  sub_1007096B0((uint64_t)a1, a2);
  return a1;
}

void sub_100709694(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 32)) {
    sub_101233EA0(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_1007096B0(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 32))
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
    sub_10001B72C( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    double result = *(double *)(a2 + 24);
    *(double *)(a1 + sub_10000AE14(v9 + 24) = result;
    *(_BYTE *)(a1 + 32) = 1;
  }

  return result;
}

void sub_100709704(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100709730(uint64_t a1, __int128 *a2)
{
  *(void *)a1 = off_10184C7F0;
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 24), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + sub_10000AE14(v9 + 24) = v4;
  }

  else {
    size_t v5 = *((void *)a2 + 1);
  }
  uint64_t v6 = sub_1000392EC(a1 + 48, v5 + 13);
  else {
    int v7 = *(void **)(a1 + 48);
  }
  if (v5)
  {
    else {
      int v8 = *(const void **)a2;
    }
    memmove(v7, v8, v5);
  }

  strcpy((char *)v7 + v5, "TimeRemaining");
  return a1;
}

void sub_10070981C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100709838(uint64_t a1)
{
  *(void *)a1 = off_10184C7F0;
  sub_100709F20(a1);
  uint64_t v2 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v2 + 944LL))(v2);
  return a1;
}

void sub_1007098A0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100709838(a1);
  operator delete(v1);
}

double sub_1007098B4(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  double v3 = sub_1007098FC(a1);
  if (!v2) {
    return v3 - (sub_101171D4C() - *(double *)(a1 + 16));
  }
  return v3;
}

double sub_1007098FC(uint64_t a1)
{
  double v5 = 0.0;
  uint64_t v2 = sub_1002F8DDC();
  double v3 = (const char *)(a1 + 48);
  sub_1002A82BC(v2, v3, &v5);
  return v5;
}

BOOL sub_100709948(uint64_t a1, double a2)
{
  double v12 = a2;
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10184C820);
  }
  __int128 v4 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
  {
    double v5 = (void *)(a1 + 24);
    *(_DWORD *)std::stringbuf::string_type buf = 136315394;
    uint64_t v18 = v5;
    __int16 v19 = 2048;
    double v20 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "NonInterruptingTimer, %s, totalTime, %.2f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10184C820);
    }
    uint64_t v9 = (void *)(a1 + 24);
    int v13 = 136315394;
    double v14 = v9;
    __int16 v15 = 2048;
    double v16 = a2;
    LODWORD(v11) = 22;
    int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "NonInterruptingTimer, %s, totalTime, %.2f",  (const char *)&v13,  v11);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNonInterruptingTimer::setTotalTime(CFTimeInterval)", "%s\n", v10);
  }

  uint64_t v6 = sub_1002F8DDC();
  int v7 = (const char *)(a1 + 48);
  return sub_1002AC7B8(v6, v7, &v12);
}

uint64_t sub_100709B54(uint64_t a1)
{
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10184C820);
  }
  uint64_t v2 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
  {
    double v3 = (void *)(a1 + 24);
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    double v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "NonInterruptingTimer, %s, persist", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10184C820);
    }
    int v7 = (void *)(a1 + 24);
    int v9 = 136315138;
    int v10 = v7;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "NonInterruptingTimer, %s, persist",  (const char *)&v9);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNonInterruptingTimer::persistTime()", "%s\n", v8);
  }

  if (!*(_DWORD *)(a1 + 8))
  {
    double v4 = sub_1007098B4(a1);
    sub_100709948(a1, v4);
  }

  uint64_t v5 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 944LL))(v5);
}

void sub_100709D44(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8))
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10184C820);
    }
    uint64_t v2 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
    {
      double v3 = (void *)(a1 + 24);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      int v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "NonInterruptingTimer, %s, startTimer", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10184C820);
      }
      double v4 = (void *)(a1 + 24);
      int v7 = 136315138;
      int v8 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "NonInterruptingTimer, %s, startTimer",  (const char *)&v7);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLNonInterruptingTimer::startTimer()", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
    }

    *(double *)(a1 + sub_100708348(v2 - 16) = sub_101171D4C();
    *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = 0;
  }

uint64_t sub_100709F20(uint64_t result)
{
  if (*(_DWORD *)(result + 8) != 1)
  {
    uint64_t v1 = result;
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10184C820);
    }
    uint64_t v2 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
    {
      double v3 = (void *)(v1 + 24);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      double v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "NonInterruptingTimer, %s, stopTimer", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10184C820);
      }
      uint64_t v5 = (void *)(v1 + 24);
      int v8 = 136315138;
      int v9 = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "NonInterruptingTimer, %s, stopTimer",  (const char *)&v8);
      int v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLNonInterruptingTimer::stopTimer()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    double v4 = sub_1007098B4(v1);
    double result = sub_100709948(v1, v4);
    *(_DWORD *)(v1 + _Block_object_dispose(va, 8) = 1;
  }

  return result;
}

void sub_10070A10C(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void *sub_10070A138(void *result, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  *double result = off_10184C850;
  result[1] = v3;
  result[2] = v2;
  if (v2)
  {
    double v4 = (unint64_t *)(v2 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  return result;
}

uint64_t sub_10070A168(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16LL))(*(void *)(a1 + 8));
}

uint64_t sub_10070A178(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32LL))(*(void *)(a1 + 8));
}

uint64_t sub_10070A188(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40LL))(*(void *)(a1 + 8));
}

uint64_t sub_10070A198(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56LL))(*(void *)(a1 + 8));
}

void *sub_10070A1A8(void *a1)
{
  *a1 = off_10184C850;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_10070A1D8(void *a1)
{
  *a1 = off_10184C850;
  sub_10000AE14((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_10070A208(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v6 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  void *v6 = off_10184C8C0;
  v6[6] = off_10182F180;
  int v7 = operator new(0x20uLL);
  v7[2] = 0LL;
  *((_DWORD *)v7 + 6) = 31337;
  *int v7 = off_10182F1B8;
  v7[1] = 0LL;
  *(void *)(a1 + 56) = v7 + 3;
  *(void *)(a1 + 64) = v7;
  *(_BYTE *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0xBFF0000000000000LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0xBFF0000000000000LL;
  *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0xFFFFFFFFLL;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = a1 + 136;
  return a1;
}

void sub_10070A2A0(_Unwind_Exception *a1)
{
}

uint64_t sub_10070A2B8(uint64_t a1)
{
  *(void *)a1 = off_10184C8C0;
  uint64_t v2 = sub_100B0B6F4();
  sub_100B0BD04(v2, a1, 0, 0LL);
  double Current = CFAbsoluteTimeGetCurrent();
  if (*(_BYTE *)(a1 + 72))
  {
    *(void *)&__int128 v10 = 0LL;
    *((void *)&v10 + 1) = 0xBFF0000000000000LL;
    *(void *)&__int128 v11 = 0xBFF0000000000000LL;
    *((void *)&v11 + 1) = 0xFFFFFFFFLL;
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    double v12 = &v13;
    *(_OWORD *)(a1 + 72) = v10;
    double v4 = (void **)(a1 + 88);
    *(_OWORD *)double v4 = 0uLL;
    *(void *)(a1 + 104) = 0LL;
    uint64_t v6 = a1 + 136;
    unint64_t v5 = *(char **)(a1 + 136);
    *(_OWORD *)(a1 + 112) = v11;
    sub_1000229D4(a1 + 128, v5);
    uint64_t v7 = v13;
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = v12;
    *(void *)(a1 + 136) = v7;
    uint64_t v8 = v14;
    *(void *)(a1 + 144) = v14;
    if (v8)
    {
      *(void *)(v7 + sub_100708348(v2 - 16) = v6;
      uint64_t v7 = 0LL;
      double v12 = &v13;
      uint64_t v13 = 0LL;
      uint64_t v14 = 0LL;
    }

    else
    {
      *(void *)(a1 + 12_Block_object_dispose(va, 8) = v6;
    }

    sub_1000229D4((uint64_t)&v12, (char *)v7);
  }

  sub_1000229D4(a1 + 128, *(char **)(a1 + 136));
  sub_1002B729C((void *)(a1 + 48));
  return sub_100C6AB50(a1);
}

void sub_10070A428(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10070A2B8(a1);
  operator delete(v1);
}

void *sub_10070A43C@<X0>(uint64_t a1@<X8>)
{
  v6[0] = &off_10184C9A8;
  v6[1] = sub_10070A598;
  v6[2] = 0LL;
  uint64_t v7 = v6;
  sub_1010DDBC0(__p, "kCLConnectionMessageGesture");
  sub_10070BCDC((uint64_t)v10, (uint64_t)v6);
  sub_10070C0CC(a1, (unsigned __int8 *)__p, 1LL);
  uint64_t v2 = v11;
  if (v11 == v10)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = v10;
  }

  else
  {
    if (!v11) {
      goto LABEL_6;
    }
    uint64_t v3 = 5LL;
  }

  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  double result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    double result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_10070A54C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13)
{
  uint64_t v14 = a12;
  if (a12 == &a9)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(a1);
}

void sub_10070A598(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_101934530 != -1) {
    dispatch_once(&qword_101934530, &stru_10184C978);
  }
  uint64_t v7 = (os_log_s *)qword_101934538;
  if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = *(void *)(a1 + 24);
    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Received Gesture request,client,%{public}@,subscribe,%{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934530 != -1) {
      dispatch_once(&qword_101934530, &stru_10184C978);
    }
    uint64_t v28 = *(void *)(a1 + 24);
    *(_DWORD *)__int16 v48 = 138543618;
    *(void *)&v48[4] = v28;
    *(_WORD *)&v48[12] = 1026;
    *(_DWORD *)&v48[14] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "Received Gesture request,client,%{public}@,subscribe,%{public}d",  v48,  18);
    uint64_t v30 = (char *)v29;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)",  "%s\n",  v29);
    if (v30 != buf) {
      free(v30);
    }
  }

  sub_100C6AC8C(a1);
  if (a2)
  {
    if ((sub_1002A7CB0(a3, "kCLConnectionMessagePriorityKey", &v45) & 1) == 0)
    {
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      char v9 = (os_log_s *)qword_101934538;
      if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Priority not set", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934530 != -1) {
          dispatch_once(&qword_101934530, &stru_10184C978);
        }
        *(_WORD *)__int16 v48 = 0;
        LODWORD(v42) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  17LL,  "Priority not set",  v48,  v42);
        unsigned int v38 = (char *)v37;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)",  "%s\n",  v37);
        if (v38 != buf) {
          free(v38);
        }
      }

      int v45 = 0;
    }

    if (qword_101934530 != -1) {
      dispatch_once(&qword_101934530, &stru_10184C978);
    }
    __int128 v10 = (os_log_s *)qword_101934538;
    if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void *)(a1 + 24);
      *(_DWORD *)std::stringbuf::string_type buf = 67240450;
      *(_DWORD *)&uint8_t buf[4] = v45;
      *(_WORD *)&uint8_t buf[8] = 2114;
      *(void *)&buf[10] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Got gesture subscription request, priority = %{public}d, Client = %{public}@",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      uint64_t v34 = *(void *)(a1 + 24);
      *(_DWORD *)__int16 v48 = 67240450;
      *(_DWORD *)&v48[4] = v45;
      *(_WORD *)&v48[8] = 2114;
      *(void *)&v48[10] = v34;
      LODWORD(v42) = 18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "Got gesture subscription request, priority = %{public}d, Client = %{public}@",  v48,  v42);
      uint64_t v36 = (char *)v35;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)",  "%s\n",  v35);
      if (v36 != buf) {
        free(v36);
      }
    }

    id v12 = [*(id *)(a1 + 8) silo];
    sub_1002B68E8(a1 + 48, v48);
    uint64_t v13 = sub_100B0B6F4();
    int v14 = v45;
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3321888768LL;
    v43[2] = sub_10070B944;
    v43[3] = &unk_10184C918;
    v43[4] = v12;
    v43[5] = a1;
    v43[6] = *(void *)v48;
    __int16 v44 = *(std::__shared_weak_count **)&v48[8];
    if (*(void *)&v48[8])
    {
      uint64_t v15 = (unint64_t *)(*(void *)&v48[8] + 16LL);
      do
        unint64_t v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }

    sub_100B0BD04(v13, a1, v14, (uint64_t)v43);
    if (!*(_BYTE *)(a1 + 72))
    {
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      uint64_t v17 = (os_log_s *)qword_101934538;
      if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = *(void *)(a1 + 24);
        *(_DWORD *)std::stringbuf::string_type buf = 138543362;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "starting metric session (MotionTrigger) for %{public}@",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934530 != -1) {
          dispatch_once(&qword_101934530, &stru_10184C978);
        }
        uint64_t v39 = *(void *)(a1 + 24);
        int v46 = 138543362;
        uint64_t v47 = v39;
        LODWORD(v42) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "starting metric session (MotionTrigger) for %{public}@",  &v46,  v42);
        __int16 v41 = (char *)v40;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)",  "%s\n",  v40);
        if (v41 != buf) {
          free(v41);
        }
      }

      *(_BYTE *)(a1 + 72) = 1;
      *(CFAbsoluteTime *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = CFAbsoluteTimeGetCurrent();
      sub_100C6AE50(a1, buf);
      __int16 v19 = (void **)(a1 + 88);
      *(_OWORD *)__int16 v19 = *(_OWORD *)buf;
      *(void *)(a1 + 104) = *(void *)&buf[16];
      *(_DWORD *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    }

    if (v44) {
      std::__shared_weak_count::__release_weak(v44);
    }
    if (*(void *)&v48[8]) {
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v48[8]);
    }
  }

  else
  {
    if (qword_101934530 != -1) {
      dispatch_once(&qword_101934530, &stru_10184C978);
    }
    double v20 = (os_log_s *)qword_101934538;
    if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(void *)(a1 + 24);
      *(_DWORD *)std::stringbuf::string_type buf = 138543362;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "Got gesture unsubscription request, Client = %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      uint64_t v31 = *(void *)(a1 + 24);
      *(_DWORD *)__int16 v48 = 138543362;
      *(void *)&v48[4] = v31;
      LODWORD(v42) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "Got gesture unsubscription request, Client = %{public}@",  v48,  v42);
      int v33 = (char *)v32;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)",  "%s\n",  v32);
      if (v33 != buf) {
        free(v33);
      }
    }

    uint64_t v22 = sub_100B0B6F4();
    sub_100B0BD04(v22, a1, 0, 0LL);
    if (*(_BYTE *)(a1 + 72))
    {
      *(void *)std::stringbuf::string_type buf = 0LL;
      *(void *)&uint8_t buf[8] = 0xBFF0000000000000LL;
      *(void *)&uint8_t buf[16] = 0LL;
      *(void *)&buf[24] = 0LL;
      uint64_t v50 = 0LL;
      *(void *)&__int128 v51 = 0xBFF0000000000000LL;
      *((void *)&v51 + 1) = 0xFFFFFFFFLL;
      uint64_t v53 = 0LL;
      uint64_t v54 = 0LL;
      __int16 v52 = &v53;
      *(_OWORD *)(a1 + 72) = *(_OWORD *)buf;
      uint64_t v23 = (void **)(a1 + 88);
      *(_OWORD *)uint64_t v23 = *(_OWORD *)&buf[16];
      *(void *)(a1 + 104) = v50;
      HIBYTE(v5sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      uint8_t buf[16] = 0;
      uint64_t v25 = *(char **)(a1 + 136);
      uint64_t v24 = (void *)(a1 + 136);
      *(_OWORD *)(v24 - 3) = v51;
      sub_1000229D4((uint64_t)(v24 - 1), v25);
      uint64_t v26 = v53;
      *(v24 - 1) = v52;
      *uint64_t v24 = v26;
      uint64_t v27 = v54;
      v24[1] = v54;
      if (v27)
      {
        *(void *)(v26 + sub_100708348(v2 - 16) = v24;
        uint64_t v26 = 0LL;
        __int16 v52 = &v53;
        uint64_t v53 = 0LL;
        uint64_t v54 = 0LL;
      }

      else
      {
        *(v24 - 1) = v24;
      }

      sub_1000229D4((uint64_t)&v52, (char *)v26);
      if (SHIBYTE(v50) < 0) {
        operator delete(*(void **)&buf[16]);
      }
    }
  }
}

void sub_10070AEC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, std::__shared_weak_count *a24)
{
  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10070AF3C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 16);
  if (v4 == 1)
  {
    sub_1010DDBC0(&buf, "GestureCanceled");
    sub_1002ACD58((uint64_t)v31, "kCLConnectionMessageNameKey", (char *)&buf);
  }

  else
  {
    if (v4) {
      goto LABEL_7;
    }
    sub_1010DDBC0(&buf, "GestureDetected");
    sub_1002ACD58((uint64_t)v31, "kCLConnectionMessageNameKey", (char *)&buf);
  }

  if (SHIBYTE(v43) < 0) {
    operator delete((void *)buf);
  }
LABEL_7:
  *(void *)&__int128 buf = sub_1002A59CC((uint64_t)v31);
  sub_10070B89C(a1, &buf);
  if (qword_101934530 != -1) {
    dispatch_once(&qword_101934530, &stru_10184C978);
  }
  uint64_t v5 = (os_log_s *)qword_101934538;
  if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf) = 136380675;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Sent ear gesture message (prototype %{private}s)",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934530 != -1) {
      dispatch_once(&qword_101934530, &stru_10184C978);
    }
    int v34 = 136380675;
    *(void *)int v35 = a2;
    LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934538,  1LL,  "Sent ear gesture message (prototype %{private}s)",  &v34,  v30);
    __int16 v19 = (char *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::onEarGestureNotification(const CLEarGestureNotifier::CMEarGestureData &)",  "%s\n",  v18);
  }

  if (*(_BYTE *)(a1 + 72))
  {
    int v34 = -1;
    *(_OWORD *)&double v35[4] = 0u;
    *(_OWORD *)uint64_t v36 = 0u;
    __int128 v37 = 0u;
    *(_OWORD *)unsigned int v38 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int16 v41 = 0;
    unsigned int v6 = objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:",  @"CLAppMonitor"),  "syncgetForegroundApp:",  &v34);
    HIBYTE(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
    unsigned int v7 = objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:",  @"CLTelephonyService"),  "syncgetActiveCall:",  (char *)&v30 + 7);
    if (HIBYTE(v30)) {
      unsigned int v8 = v7;
    }
    else {
      unsigned int v8 = 0;
    }
    HIBYTE(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v8;
    if (v6)
    {
      if (!std::string::compare((const std::string *)&v35[4], "com.apple.mobilephone")) {
        goto LABEL_30;
      }
      unsigned int v8 = HIBYTE(v30);
    }

    if (!v8)
    {
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      char v9 = (os_log_s *)qword_101934538;
      if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "counting metric for non-phone pick-up",  (uint8_t *)&buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934530 != -1) {
          dispatch_once(&qword_101934530, &stru_10184C978);
        }
        LOWORD(__p[0]) = 0;
        LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "counting metric for non-phone pick-up",  __p,  v30);
        uint64_t v21 = (char *)v20;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::onEarGestureNotification(const CLEarGestureNotifier::CMEarGestureData &)",  "%s\n",  v20);
      }

      ++*(_DWORD *)(a1 + 124);
      sub_1010DDBC0(__p, (char *)a2);
      __int128 buf = *(_OWORD *)__p;
      uint64_t v43 = v33;
      __p[1] = 0LL;
      uint64_t v33 = 0LL;
      __p[0] = 0LL;
      int v44 = 0;
      __int128 v10 = sub_10070C4AC((uint64_t **)(a1 + 128), (const void **)&buf, (uint64_t)&buf);
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)buf);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete(__p[0]);
      }
      ++*((_DWORD *)v10 + 14);
LABEL_35:
      double Current = CFAbsoluteTimeGetCurrent();
      if (Current - *(double *)(a1 + 80) > 21600.0)
      {
        if (qword_101934530 != -1) {
          dispatch_once(&qword_101934530, &stru_10184C978);
        }
        uint64_t v13 = (os_log_s *)qword_101934538;
        if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v14 = *(void *)(a1 + 24);
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "ending metric session (MotionTrigger) for %{public}@",  (uint8_t *)&buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934530 != -1) {
            dispatch_once(&qword_101934530, &stru_10184C978);
          }
          uint64_t v24 = *(void **)(a1 + 24);
          LODWORD(__p[0]) = 138543362;
          *(void **)((char *)__p + 4) = v24;
          LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "ending metric session (MotionTrigger) for %{public}@",  __p,  v30);
          uint64_t v26 = (char *)v25;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::onEarGestureNotification(const CLEarGestureNotifier::CMEarGestureData &)",  "%s\n",  v25);
        }

        *(double *)(a1 + 112) = Current;
        if (qword_101934530 != -1) {
          dispatch_once(&qword_101934530, &stru_10184C978);
        }
        uint64_t v15 = (os_log_s *)qword_101934538;
        if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v16 = *(void *)(a1 + 24);
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "starting metric session (MotionTrigger) for %{public}@",  (uint8_t *)&buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934530 != -1) {
            dispatch_once(&qword_101934530, &stru_10184C978);
          }
          uint64_t v27 = *(void **)(a1 + 24);
          LODWORD(__p[0]) = 138543362;
          *(void **)((char *)__p + 4) = v27;
          LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934538,  2LL,  "starting metric session (MotionTrigger) for %{public}@",  __p,  v30);
          int v29 = (char *)v28;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::onEarGestureNotification(const CLEarGestureNotifier::CMEarGestureData &)",  "%s\n",  v28);
        }

        *(double *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = Current;
        *(_DWORD *)(a1 + 1sub_10000AE14(v9 + 24) = 0;
      }

      if (SHIBYTE(v40) < 0) {
        operator delete(*((void **)&v39 + 1));
      }
      if (SBYTE7(v39) < 0) {
        operator delete(v38[0]);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[1]);
      }
      if (SHIBYTE(v36[0]) < 0) {
        operator delete(*(void **)&v35[4]);
      }
      return sub_1002A5590(v31);
    }

void sub_10070B800( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
}

void sub_10070B89C(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10070B930(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10070B944(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768LL;
  v7[2] = sub_10070BA28;
  v7[3] = &unk_10184C8E0;
  __int128 v8 = *(_OWORD *)(a1 + 40);
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  char v9 = v4;
  if (v4)
  {
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_weak_owners);
    while (__stxr(v6 + 1, p_shared_weak_owners));
  }

  __int128 v10 = *a2;
  int v11 = *((_DWORD *)a2 + 4);
  [v3 async:v7];
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_10070BA10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10070BA28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v8 = 0LL;
  char v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  char v11 = 0;
  uint64_t v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472LL;
  uint64_t v15 = sub_10070BC70;
  uint64_t v16 = &unk_10184AAE0;
  __int128 v19 = *(_OWORD *)(a1 + 56);
  int v20 = *(_DWORD *)(a1 + 72);
  uint64_t v17 = &v8;
  uint64_t v18 = v2;
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3 {
    || *(void *)(v3 + 8) == -1LL
  }
    || (sub_10070AF3C(v2, (uint64_t)&v19), *(_BYTE *)(v17[1] + sub_10000AE14(v9 + 24) = 1, !*((_BYTE *)v9 + 24)))
  {
    if (qword_101934530 != -1) {
      dispatch_once(&qword_101934530, &stru_10184C978);
    }
    int v4 = (os_log_s *)qword_101934538;
    if (os_log_type_enabled((os_log_t)qword_101934538, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning CLDaemonClient got ear gesture callback after destruction... ignoring",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934530 != -1) {
        dispatch_once(&qword_101934530, &stru_10184C978);
      }
      v7[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934538,  0LL,  "#Warning CLDaemonClient got ear gesture callback after destruction... ignoring",  v7,  2);
      unint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGestureSubscription::handleRequestGesture(BOOL, const CLNameValuePair &)_block_invoke",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  _Block_object_dispose(&v8, 8);
}

void sub_10070BC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10070BC70(uint64_t a1)
{
  uint64_t result = sub_10070AF3C(*(void *)(a1 + 40), a1 + 48);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t sub_10070BCA8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void sub_10070BCCC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_10070BCDC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + sub_10000AE14(v9 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + sub_10000AE14(v9 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  void *v3 = 0LL;
  return a1;
}

void sub_10070BD40(id a1)
{
  qword_101934538 = (uint64_t)os_log_create("com.apple.locationd.Motion", "EarGesture");
}

__n128 sub_10070BD6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10184C9A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_10070BDA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10184C9A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_10070BDCC(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_10070BDD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10070BE10()
{
}

void sub_10070BE1C(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_10070BEA0(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10070BE88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10070BEA0(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      uint64_t v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10184CA18);
    }
    char v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int128 v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10184CA18);
      }
    }

    id v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int128 v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_10070C084( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10070C0A0(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

uint64_t sub_10070C0CC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_10070C144(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_10070C130(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10070C144(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unsigned int v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_10070C3C4(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *uint64_t v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + sub_100708348(v2 - 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_10070C3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_10070C3C4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_10070C438(v8 + 2, a3);
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 1;
  return result;
}

void sub_10070C420(_Unwind_Exception *a1)
{
}

void *sub_10070C438(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_10070C490(_Unwind_Exception *exception_object)
{
}

_OWORD *sub_10070C4AC(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_1000227E8((uint64_t)a1, &v9, a2);
  __int128 v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    __int128 v6 = operator new(0x40uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + sub_100708348(v2 - 16) = 0LL;
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    sub_1000085FC(a1, v9, v7, (uint64_t *)v6);
  }

  return v6;
}

double sub_10070C544(float64x2_t *a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = vmulq_f64(a1[1], (float64x2_t)xmmword_10130FB00);
  v5[0] = vmulq_f64(*a1, (float64x2_t)xmmword_10130FAF0);
  v5[1] = v2;
  unint64_t v6 = 0xC000EF2C2B73F950LL;
  double v3 = 0.0;
  do
  {
    double v3 = v3 + *(double *)((char *)v5 + v1);
    v1 += 8LL;
  }

  while (v1 != 40);
  return 1.0 / (exp(-v3) + 1.0);
}

double sub_10070C5C4(float64x2_t *a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = vmulq_f64(a1[1], (float64x2_t)xmmword_10130FB20);
  v8[0] = vmulq_f64(*a1, (float64x2_t)xmmword_10130FB10);
  v8[1] = v2;
  float64x2_t v3 = vmulq_f64(a1[3], (float64x2_t)xmmword_10130FB40);
  v8[2] = vmulq_f64(a1[2], (float64x2_t)xmmword_10130FB30);
  v8[3] = v3;
  float64x2_t v4 = vmulq_f64(a1[5], (float64x2_t)xmmword_10130FB60);
  id v8[4] = vmulq_f64(a1[4], (float64x2_t)xmmword_10130FB50);
  v8[5] = v4;
  float64x2_t v5 = vmulq_f64(a1[7], (float64x2_t)xmmword_10130FB80);
  v8[6] = vmulq_f64(a1[6], (float64x2_t)xmmword_10130FB70);
  v8[7] = v5;
  v8[8] = vmulq_f64(a1[8], (float64x2_t)xmmword_10130FB90);
  v5.f64[0] = a1[9].f64[0] * -0.615337343;
  uint64_t v10 = 0x4013EBD26D9FF6D3LL;
  double v6 = 0.0;
  float64_t v9 = v5.f64[0];
  do
  {
    double v6 = v6 + *(double *)((char *)v8 + v1);
    v1 += 8LL;
  }

  while (v1 != 160);
  return 1.0 / (exp(-v6) + 1.0);
}

double sub_10070C6CC(double a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = (double *)qword_10130FD80;
  do
  {
    if (*v2 > a1) {
      break;
    }
    ++v1;
    v2 += 3;
  }

  while (v1 != 2499);
  return *(double *)&qword_10130FD80[3 * v1 + 1];
}

double sub_10070C70C(float64x2_t *a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = vmulq_f64(a1[1], (float64x2_t)xmmword_10130FBB0);
  v6[0] = vmulq_f64(*a1, (float64x2_t)xmmword_10130FBA0);
  v6[1] = v2;
  float64x2_t v3 = vmulq_f64(a1[3], (float64x2_t)xmmword_10130FBD0);
  v6[2] = vmulq_f64(a1[2], (float64x2_t)xmmword_10130FBC0);
  void v6[3] = v3;
  v6[4] = vmulq_f64(a1[4], (float64x2_t)xmmword_10130FBE0);
  uint64_t v7 = 0x40222EEE9DDA3655LL;
  double v4 = 0.0;
  do
  {
    double v4 = v4 + *(double *)((char *)v6 + v1);
    v1 += 8LL;
  }

  while (v1 != 88);
  return 1.0 / (exp(-v4) + 1.0);
}

double sub_10070C7C0(double a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = (double *)qword_10131E7E0;
  do
  {
    if (*v2 > a1) {
      break;
    }
    ++v1;
    v2 += 3;
  }

  while (v1 != 299);
  return *(double *)&qword_10131E7E0[3 * v1 + 1];
}

double sub_10070C800(float64x2_t *a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = vmulq_f64(a1[1], (float64x2_t)xmmword_10130FC00);
  v5[0] = vmulq_f64(*a1, (float64x2_t)xmmword_10130FBF0);
  v5[1] = v2;
  unint64_t v6 = 0xC015D1D42AF120ABLL;
  double v3 = 0.0;
  do
  {
    double v3 = v3 + *(double *)((char *)v5 + v1);
    v1 += 8LL;
  }

  while (v1 != 40);
  return 1.0 / (exp(-v3) + 1.0);
}

double sub_10070C880(double a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = (double *)qword_101320400;
  do
  {
    if (*v2 > a1) {
      break;
    }
    ++v1;
    v2 += 3;
  }

  while (v1 != 299);
  return *(double *)&qword_101320400[3 * v1 + 1];
}

double sub_10070C8C0(float64x2_t *a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = vmulq_f64(a1[1], (float64x2_t)xmmword_10130FC20);
  v12[0] = vmulq_f64(*a1, (float64x2_t)xmmword_10130FC10);
  v12[1] = v2;
  float64x2_t v3 = vmulq_f64(a1[3], (float64x2_t)xmmword_10130FC40);
  v12[2] = vmulq_f64(a1[2], (float64x2_t)xmmword_10130FC30);
  v12[3] = v3;
  float64x2_t v4 = vmulq_f64(a1[5], (float64x2_t)xmmword_10130FC60);
  v12[4] = vmulq_f64(a1[4], (float64x2_t)xmmword_10130FC50);
  v12[5] = v4;
  float64x2_t v5 = vmulq_f64(a1[7], (float64x2_t)xmmword_10130FC80);
  v12[6] = vmulq_f64(a1[6], (float64x2_t)xmmword_10130FC70);
  v12[7] = v5;
  float64x2_t v6 = vmulq_f64(a1[9], (float64x2_t)xmmword_10130FCA0);
  _WORD v12[8] = vmulq_f64(a1[8], (float64x2_t)xmmword_10130FC90);
  void v12[9] = v6;
  float64x2_t v7 = vmulq_f64(a1[11], (float64x2_t)xmmword_10130FCC0);
  v12[10] = vmulq_f64(a1[10], (float64x2_t)xmmword_10130FCB0);
  v12[11] = v7;
  float64x2_t v8 = vmulq_f64(a1[13], (float64x2_t)xmmword_10130FCE0);
  v12[12] = vmulq_f64(a1[12], (float64x2_t)xmmword_10130FCD0);
  v12[13] = v8;
  float64x2_t v9 = vmulq_f64(a1[14], (float64x2_t)xmmword_10130FCF0);
  uint64_t v13 = 0x3FFB75EBE7714AE1LL;
  double v10 = 0.0;
  v12[14] = v9;
  do
  {
    double v10 = v10 + *(double *)((char *)v12 + v1);
    v1 += 8LL;
  }

  while (v1 != 248);
  return 1.0 / (exp(-v10) + 1.0);
}

double sub_10070CA1C(double a1)
{
  uint64_t v1 = 0LL;
  float64x2_t v2 = (double *)qword_101322020;
  do
  {
    if (*v2 > a1) {
      break;
    }
    ++v1;
    v2 += 3;
  }

  while (v1 != 999);
  return *(double *)&qword_101322020[3 * v1 + 1];
}

void sub_10070CA5C(uint64_t a1, double a2)
{
  __int128 v8 = xmmword_101327F20;
  __int128 v9 = unk_101327F30;
  if (*(_BYTE *)(a1 + 56))
  {
    double v4 = sub_10070CB80(dbl_101327DE0, dbl_101327E20, *(float *)(a1 + 20), 0.0, 0.0);
    double v5 = sub_10070CB80(dbl_101327DE0, dbl_101327E60, *(float *)(a1 + 20), 0.167, 0.239);
    double v6 = sub_10070CB80(dbl_101327DE0, dbl_101327EA0, *(float *)(a1 + 20), 0.26, 0.368);
    double v7 = sub_10070CB80(dbl_101327DE0, dbl_101327EE0, *(float *)(a1 + 20), 0.58, 0.61);
    *(double *)&__int128 v8 = v4;
    *((double *)&v8 + 1) = v5;
    *(double *)&__int128 v9 = v6;
    *((double *)&v9 + 1) = v7;
  }

  sub_10070CC28((double *)&v8, dbl_101327F40, a2, 0.0, 100.0);
}

double sub_10070CB80(double *a1, double *a2, double a3, double a4, double a5)
{
  if (*a1 > a3) {
    return *a2;
  }
  if (a1[7] < a3) {
    return a2[7];
  }
  uint64_t v6 = 0LL;
  if (a1[1] >= a3)
  {
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = 7LL;
    while (v6 != 5)
    {
      double v8 = a1[v6++ + 2];
      if (v8 >= a3)
      {
        uint64_t v7 = v6 + 1;
        goto LABEL_12;
      }
    }

    LODWORD(v6) = 6;
  }

double sub_10070CC28(double *a1, double *a2, double a3, double a4, double a5)
{
  if (*a1 > a3) {
    return *a2;
  }
  if (a1[3] < a3) {
    return a2[3];
  }
  double v6 = a1[1];
  if (v6 >= a3)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 1LL;
  }

  else
  {
    double v6 = a1[2];
    uint64_t v7 = 1LL;
    uint64_t v8 = 2LL;
    if (v6 < a3)
    {
      double v6 = a1[3];
      uint64_t v8 = 3LL;
      uint64_t v7 = 2LL;
    }
  }

  double v9 = a2[v7];
  double v10 = a1[v7];
  double v11 = (a2[v8] - v9) / (v6 - v10);
  double result = v9 - v11 * v10 + a3 * v11;
  if (result <= a4) {
    double result = a4;
  }
  if (result >= a5) {
    return a5;
  }
  return result;
}

uint64_t sub_10070CCC0(uint64_t a1)
{
  float64x2_t v1 = *(float64x2_t *)(a1 + 8);
  double v2 = *(double *)(a1 + 16);
  if (v1.f64[0] != -INFINITY)
  {
    if (v2 == -INFINITY) {
      return 0LL;
    }
    v3.f64[0] = *(float64_t *)(a1 + 24);
    if (v3.f64[0] != -INFINITY && *(double *)(a1 + 32) != -INFINITY)
    {
      v3.f64[1] = *(float64_t *)(a1 + 32);
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32( (int32x4_t)vcgtq_f64( (float64x2_t)xmmword_10130FD00,  v1),  (int32x4_t)vcgtq_f64( (float64x2_t)xmmword_10130FD10,  v3))))) & 1) == 0 && *(double *)a1 != -INFINITY && *(double *)a1 >= 50.0)
      {
        return 1LL;
      }
    }
  }

  if (v2 != -INFINITY)
  {
    double v5 = *(double *)(a1 + 24);
    if (v5 != -INFINITY)
    {
      double v6 = *(double *)(a1 + 32);
      if (v6 != -INFINITY)
      {
        double v7 = *(double *)(a1 + 40);
        if (v7 != -INFINITY && v6 < 2000.0)
        {
          double v8 = *(double *)a1;
          BOOL v9 = v5 < 5000.0 && v2 < 4.0;
          BOOL v10 = !v9 || v7 <= 31.0;
          BOOL v11 = v10 || v8 == -INFINITY;
          if (!v11 && v8 >= 50.0) {
            return 1LL;
          }
        }
      }
    }
  }

  return 0LL;
}

double sub_10070CDF4(double *a1, double a2)
{
  double v3 = *a1;
  double v2 = a1[1];
  double v4 = a1[2];
  double v5 = 1.0;
  if (a2 >= 50.0)
  {
    double v5 = 0.0;
    if (a2 <= 75.0) {
      double v5 = fmin(fmax(a2 * -0.04 + 3.0, 0.0), 1.0);
    }
  }

  double v6 = fmax(v4 + -3165.0, 0.0);
  double v7 = fmax(v3 + -1.4, 0.0) * 6.0 + 0.0;
  if (v3 == -INFINITY) {
    double v8 = 0.0;
  }
  else {
    double v8 = v7;
  }
  double v9 = fmax(v2 + -2.0, 0.0);
  BOOL v10 = v2 == -INFINITY;
  double v11 = -0.0;
  if (!v10) {
    double v11 = v9;
  }
  double v12 = v8 + v11;
  if (v4 == -INFINITY) {
    double v13 = v12;
  }
  else {
    double v13 = v12 + v6 * 0.002;
  }
  return a2 + v5 * fmin(v13, 15.0);
}

float sub_10070CEC4(double *a1)
{
  float v1 = a1[1] * (a1[3] + a1[3]) - *a1 * (a1[2] + a1[2]);
  return -v1;
}

double sub_10070CF10(double *a1, double *a2, double *a3)
{
  double v4 = a2[2];
  double v3 = a2[3];
  double v5 = a3[2];
  double v6 = a3[3];
  double v7 = *a2;
  double v8 = *a3;
  a1[1] = v3 * v5 + *a2 * a3[1] - v4 * v6 + a2[1] * *a3;
  double v9 = a3[1];
  double v10 = a2[1];
  a1[2] = v7 * v5 - v3 * v9 + v10 * v6 + v4 * v8;
  double v11 = a2[2];
  double v12 = a3[2];
  a1[3] = v11 * v9 - v10 * v12 + v7 * v6 + v3 * v8;
  double result = -(v11 * v12) - v10 * v9 - a2[3] * a3[3] + v7 * v8;
  *a1 = result;
  return result;
}

double sub_10070CF8C(double *a1)
{
  double v1 = a1[2];
  return -atan2(a1[1] * (a1[3] + a1[3]) - *a1 * (v1 + v1), 1.0 - a1[1] * (a1[1] + a1[1]) - v1 * (v1 + v1));
}

double sub_10070CFCC(double *a1)
{
  return asin(*a1 * (a1[1] + a1[1]) + a1[2] * (a1[3] + a1[3]));
}

double sub_10070CFE8(double *a1)
{
  double v1 = a1[3];
  return -atan2(a1[1] * (a1[2] + a1[2]) - *a1 * (v1 + v1), 1.0 - a1[1] * (a1[1] + a1[1]) - v1 * (v1 + v1));
}

double sub_10070D028(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 1);
  double result = *((double *)a2 + 3);
  double v3 = *(double *)a2;
  *(double *)(a1 + sub_100708348(v2 - 16) = result;
  *(double *)(a1 + sub_10000AE14(v9 + 24) = v3;
  return result;
}

double sub_10070D040(double *a1, double *a2)
{
  double v2 = *a2;
  double v3 = a2[1];
  double v4 = v2 + v2;
  double v5 = v3 + v3;
  double v6 = a2[2];
  double v7 = v6 + v6;
  double v8 = v3 * (v3 + v3);
  double v9 = v6 * (v6 + v6);
  *a1 = 1.0 - v8 - v9;
  double v10 = 1.0 - v2 * (v2 + v2);
  a1[4] = v10 - v9;
  a1[8] = v10 - v8;
  double v11 = v7 * a2[1];
  double v12 = v4 * a2[3];
  a1[7] = v11 - v12;
  a1[5] = v11 + v12;
  double v13 = v5 * *a2;
  double v14 = v7 * a2[3];
  a1[3] = v13 - v14;
  a1[1] = v13 + v14;
  double v15 = v7 * *a2;
  double v16 = v5 * a2[3];
  a1[2] = v15 - v16;
  double result = v15 + v16;
  a1[6] = result;
  return result;
}

double sub_10070D0E8(double *a1)
{
  return a1[3] * (a1[1] + a1[1]) - *a1 * (a1[2] + a1[2]);
}

double sub_10070D104(double *a1)
{
  return -(a1[3] * (*a1 + *a1)) - a1[1] * (a1[2] + a1[2]);
}

double sub_10070D120(double *a1)
{
  return *a1 * (*a1 + *a1) + -1.0 + a1[1] * (a1[1] + a1[1]);
}

uint64_t sub_10070D13C(uint64_t result, double *a2, double *a3, double *a4)
{
  double v4 = sqrt(*a3 * *a3 + *a2 * *a2 + *a4 * *a4);
  double v5 = -*a3 / v4;
  *(double *)double result = v5;
  double v6 = *a2 / v4;
  *(double *)(result + _Block_object_dispose(va, 8) = v6;
  *(void *)(result + sub_100708348(v2 - 16) = 0LL;
  double v7 = sqrt((1.0 - *a4 / v4) * 0.5);
  *(double *)(result + sub_10000AE14(v9 + 24) = v7;
  double v8 = v6 * v6 + v5 * v5;
  if (v8 <= 0.000001)
  {
    if (*a4 <= 0.0)
    {
      *(void *)double result = 0LL;
      *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(result + sub_100708348(v2 - 16) = 0LL;
      *(void *)(result + sub_10000AE14(v9 + 24) = 0x3FF0000000000000LL;
    }

    else
    {
      *(void *)double result = 0x3FF0000000000000LL;
      *(void *)(result + sub_100708348(v2 - 16) = 0LL;
      *(void *)(result + sub_10000AE14(v9 + 24) = 0LL;
      *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
    }
  }

  else
  {
    double v9 = sqrt((1.0 - v7 * v7) / v8);
    *(double *)double result = v5 * v9;
    *(float64x2_t *)(result + _Block_object_dispose(va, 8) = vmulq_n_f64((float64x2_t)*(unint64_t *)&v6, v9);
  }

  return result;
}

double sub_10070D208(uint64_t a1, uint64_t a2)
{
  *(float64x2_t *)a1 = vnegq_f64(*(float64x2_t *)a2);
  uint64_t v2 = *(void *)(a2 + 24);
  double result = -*(double *)(a2 + 16);
  *(double *)(a1 + sub_100708348(v2 - 16) = result;
  *(void *)(a1 + sub_10000AE14(v9 + 24) = v2;
  return result;
}

double sub_10070D224(double *a1, double *a2, double *a3)
{
  double v4 = a2[2];
  double v3 = a2[3];
  double v5 = a3[1];
  double v6 = a2[1];
  double v7 = a3[2];
  double v8 = a3[3];
  *a1 = v4 * v5 + v3 * *a3 - v6 * v7 + *a2 * v8;
  double v9 = *a3;
  double v10 = *a2;
  a1[1] = v3 * v5 - v4 * *a3 + *a2 * v7 + v6 * v8;
  double v11 = a2[1];
  double v12 = a3[1];
  a1[2] = v11 * v9 - v10 * v12 + v3 * v7 + v4 * v8;
  double result = -(v11 * v12) - v10 * v9 - a2[2] * a3[2] + v3 * v8;
  a1[3] = result;
  return result;
}

float sub_10070D2A0(float *a1, float *a2, float *a3)
{
  float v3 = a2[2];
  float v4 = a3[2];
  *a1 = (float)(a2[1] * v4) - (float)(v3 * a3[1]);
  float v5 = *a3;
  float v6 = *a2;
  a1[1] = (float)(v3 * *a3) - (float)(*a2 * v4);
  float result = (float)(v6 * a3[1]) - (float)(a2[1] * v5);
  a1[2] = result;
  return result;
}

float sub_10070D2E0(float *a1)
{
  float v1 = a1[1];
  float v2 = a1[2];
  float v3 = sqrtf((float)((float)(v1 * v1) + (float)(*a1 * *a1)) + (float)(v2 * v2));
  *a1 = *a1 / v3;
  a1[1] = v1 / v3;
  float result = v2 / v3;
  a1[2] = v2 / v3;
  return result;
}

void sub_10070D310(uint64_t a1, float a2, double a3)
{
  if (a3 >= 0.0)
  {
    _DWORD v23[4] = v8;
    v23[5] = v7;
    v23[6] = v6;
    v23[7] = v5;
    v23[10] = v3;
    v23[11] = v4;
    double v11 = *(double *)(a1 + 16);
    double v12 = *(double *)(a1 + 24) + *(double *)(a1 + 24);
    double v13 = *(double *)(a1 + 8);
    float v14 = v13 * v12 - *(double *)a1 * (v11 + v11);
    float v15 = (v13 + v13) * *(double *)a1 + v11 * v12;
    float v16 = 1.0 - v13 * (v13 + v13) - v11 * (v11 + v11);
    __double2 v17 = __sincos_stret(a2 * -0.5 * 0.0174532924);
    v23[0] = v17.__cosval;
    v23[1] = v17.__sinval * v14;
    v23[2] = v17.__sinval * v15;
    v23[3] = v17.__sinval * v16;
    sub_10070CF10((double *)v22, v23, (double *)a1);
    __int128 v18 = v22[1];
    *(_OWORD *)a1 = v22[0];
    *(_OWORD *)(a1 + sub_100708348(v2 - 16) = v18;
    float v19 = *(float *)(a1 + 76);
    if (v19 >= 0.0)
    {
      float v20 = v19 + a2;
      *(float *)(a1 + 76) = v20;
      float v21 = 360.0;
      if (v20 >= 360.0)
      {
        float v21 = -360.0;
      }

      else if (v20 >= 0.0)
      {
        return;
      }

      *(float *)(a1 + 76) = v20 + v21;
    }
  }

double sub_10070D420(double *a1, float *a2, float *a3, float *a4)
{
  *a1 = 1.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  double v4 = a1 + 2;
  a1[3] = 0.0;
  double v5 = a1 + 3;
  float v6 = *a2;
  float v7 = a3[1];
  if (*a2 <= v7 || (float v8 = a4[2], v6 <= v8))
  {
    float v11 = a4[2];
    if (v7 <= v6 || v7 <= v11)
    {
      double v13 = sqrt(v11 + 1.0 - v6 - v7);
      double result = v13 + v13;
      if (result <= 1.0e-10) {
        return result;
      }
      float v14 = a2[2];
      float v15 = *a3 - a2[1];
      float v16 = *a4;
      a1[3] = result * 0.25;
      *a1 = v15 / result;
      a1[1] = (float)(v16 + v14) / result;
      __double2 v17 = a3 + 2;
      a3 = a4 + 1;
      a4 = v17;
      double v5 = v4;
    }

    else
    {
      double v18 = sqrt(v7 + 1.0 - v11 - v6);
      double result = v18 + v18;
      if (result <= 1.0e-10) {
        return result;
      }
      float v19 = a4[1];
      *a1 = (float)(a2[2] - *a4) / result;
      double v20 = (float)(a3[2] + v19) / result;
      a1[2] = result * 0.25;
      a1[3] = v20;
      a4 = a2 + 1;
      double v5 = a1 + 1;
    }
  }

  else
  {
    double v9 = sqrt(v6 + 1.0 - v7 - v8);
    double result = v9 + v9;
    if (result <= 1.0e-10) {
      return result;
    }
    *a1 = (float)(a4[1] - a3[2]) / result;
    a1[1] = result * 0.25;
    a1[2] = (float)(a2[1] + *a3) / result;
    a3 = a2 + 2;
  }

  double result = (float)(*a4 + *a3) / result;
  *double v5 = result;
  return result;
}

std::string *sub_10070D5E8@<X0>(int a1@<W0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  if (a1 > 65663)
  {
    if (a1 > 589887)
    {
      if (a1 > 851979)
      {
        if (a1 >= 0x100000)
        {
          if (a1 == 0x100000)
          {
            float v2 = "kTypeMachineWorkout";
            return std::string::assign(a2, v2);
          }

          if (a1 == 0x200000)
          {
            float v2 = "kTypeWorkout";
            return std::string::assign(a2, v2);
          }
        }

        else
        {
          if (a1 == 851980)
          {
            float v2 = "kTypeSemiStationaryPocket";
            return std::string::assign(a2, v2);
          }

          if (a1 == 917516)
          {
            float v2 = "kTypeSemiStationaryArm";
            return std::string::assign(a2, v2);
          }
        }
      }

      else if (a1 > 720911)
      {
        if (a1 == 720912)
        {
          float v2 = "kTypeWalkingLeg";
          return std::string::assign(a2, v2);
        }

        if (a1 == 786448)
        {
          float v2 = "kTypeWalkingArm";
          return std::string::assign(a2, v2);
        }
      }

      else
      {
        if (a1 == 589888)
        {
          float v2 = "kTypeRunningLeg";
          return std::string::assign(a2, v2);
        }

        if (a1 == 655424)
        {
          float v2 = "kTypeRunningArm";
          return std::string::assign(a2, v2);
        }
      }
    }

    else if (a1 > 327807)
    {
      if (a1 >= 462848)
      {
        if (a1 == 462848)
        {
          float v2 = "kTypeDrivingArm";
          return std::string::assign(a2, v2);
        }

        if (a1 == 528384)
        {
          float v2 = "kTypeDrivingStowed";
          return std::string::assign(a2, v2);
        }
      }

      else
      {
        if (a1 == 327808)
        {
          float v2 = "kTypeCyclingTorso";
          return std::string::assign(a2, v2);
        }

        if (a1 == 397312)
        {
          float v2 = "kTypeDrivingSeat";
          return std::string::assign(a2, v2);
        }
      }
    }

    else if (a1 >= 196608)
    {
      if (a1 == 196608)
      {
        float v2 = "kTypeCyclingLeg";
        return std::string::assign(a2, v2);
      }

      if (a1 == 262272)
      {
        float v2 = "kTypeCyclingArm";
        return std::string::assign(a2, v2);
      }
    }

    else
    {
      if (a1 == 65664)
      {
        float v2 = "kTypeCyclingSeat";
        return std::string::assign(a2, v2);
      }

      if (a1 == 131200)
      {
        float v2 = "kTypeCyclingChassis";
        return std::string::assign(a2, v2);
      }
    }

void sub_10070D98C(_Unwind_Exception *exception_object)
{
}

void sub_10070DA4C(id a1)
{
  qword_1019982C8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLCatherineNotifierSilo");
}

uint64_t sub_10070DB00(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10070DCA0;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_1019982E0 != -1) {
    dispatch_once(&qword_1019982E0, block);
  }
  return qword_1019A15C0;
}

uint64_t sub_10070DCA0(uint64_t a1)
{
  float v2 = operator new(0x100uLL);
  uint64_t result = sub_10070DCEC((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A15C0 = (uint64_t)v2;
  return result;
}

void sub_10070DCD8(_Unwind_Exception *a1)
{
}

uint64_t sub_10070DCEC(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_10070DE1C(a1, "CLCatherineNotifier", a2);
  *(void *)uint64_t v3 = off_10184CAA0;
  *(_OWORD *)(v3 + 112) = xmmword_101327F80;
  *(_OWORD *)(v3 + 12_Block_object_dispose(va, 8) = unk_101327F90;
  *(_OWORD *)(v3 + 144) = xmmword_101327FA0;
  *(_OWORD *)(v3 + 156) = *(__int128 *)((char *)&xmmword_101327FA0 + 12);
  *(void *)(a1 + 176) = [*(id *)(v3 + 40) newTimer];
  *(void *)(a1 + 184) = 0LL;
  *(_BYTE *)(a1 + 192) = 0;
  *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  sub_100AD558C(a1 + 208, (uint64_t)"MotionStreamingHeartRate", a1, 0.0);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _OWORD v5[2] = nullsub_300;
  v5[3] = &unk_10181D3D0;
  v5[4] = a1;
  [*(id *)(a1 + 176) setHandler:v5];
  return a1;
}

void sub_10070DDBC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  sub_100AD5650(v3);
  uint64_t v5 = *(void *)(v1 + 200);
  *(void *)(v1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *(void *)(v1 + 184);
  *(void *)(v1 + 184) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  sub_10070DEBC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10070DE1C(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10184CC48;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_10070DE9C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10070DEBC(uint64_t a1)
{
  *(void *)a1 = off_10184CC48;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_10070DF30(void *a1)
{
  *a1 = off_10184CAA0;
  sub_10070DFB4((uint64_t)a1);
  sub_100AD5650(a1 + 26);
  uint64_t v2 = a1[25];
  a1[25] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[23];
  a1[23] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return sub_10070DEBC((uint64_t)a1);
}

void sub_10070DFA0(void *a1)
{
  uint64_t v1 = (void *)sub_10070DF30(a1);
  operator delete(v1);
}

BOOL sub_10070DFB4(uint64_t a1)
{
  if (qword_101934640 != -1) {
    dispatch_once(&qword_101934640, &stru_10184CC18);
  }
  uint64_t v2 = (os_log_s *)qword_101934648;
  if (os_log_type_enabled((os_log_t)qword_101934648, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "CLCatherineNotifier is shutting down.", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934640 != -1) {
      dispatch_once(&qword_101934640, &stru_10184CC18);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934648,  2LL,  "CLCatherineNotifier is shutting down.",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLCatherineNotifier::shutdown()", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  [*(id *)(a1 + 176) invalidate];

  *(void *)(a1 + 176) = 0LL;
  sub_10070E170(a1);
  BOOL result = sub_100AD5D38(a1 + 208);
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 1;
  return result;
}

void sub_10070E170(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 192))
  {
    *(_BYTE *)(a1 + 192) = 0;
    [*(id *)(a1 + 176) setNextFireDelay:3.0];
    if (qword_101934640 != -1) {
      dispatch_once(&qword_101934640, &stru_10184CC18);
    }
    uint64_t v1 = (os_log_s *)qword_101934648;
    if (os_log_type_enabled((os_log_t)qword_101934648, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "HR streaming turned off", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934640 != -1) {
        dispatch_once(&qword_101934640, &stru_10184CC18);
      }
      v4[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934648,  0LL,  "HR streaming turned off",  v4,  2);
      uint64_t v3 = (uint8_t *)v2;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCatherineNotifier::turnOffActiveCatherine()", "%s\n", v2);
      if (v3 != buf) {
        free(v3);
      }
    }
  }

uint64_t sub_10070E30C(uint64_t a1, uint64_t a2, int *a3)
{
  int v4 = a2;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, int *, void *))(*(void *)a1 + 96LL))(a1, a2, a3, &unk_101939F10);
  sub_10070E37C(a1, v4, a3, 1);
  return v6;
}

uint64_t sub_10070E368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101939F10);
}

void sub_10070E37C(uint64_t a1, int a2, int *a3, int a4)
{
  int v12 = a2;
  if (qword_101934640 != -1) {
    dispatch_once(&qword_101934640, &stru_10184CC18);
  }
  float v7 = (os_log_s *)qword_101934648;
  if (os_log_type_enabled((os_log_t)qword_101934648, OS_LOG_TYPE_DEFAULT))
  {
    if (a4) {
      float v8 = "Registration";
    }
    else {
      float v8 = "Unregistration";
    }
    *(void *)__int128 buf = &v12;
    id v9 = objc_msgSend( objc_msgSend( sub_10023311C((uint64_t **)(a1 + 80), &v12, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[8],  "description"),  "UTF8String");
    int v10 = *a3;
    *(_DWORD *)__int128 buf = v10;
    int v11 = sub_100247620(a1, (int *)buf, 1LL);
    *(_DWORD *)__int128 buf = 68290050;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v14 = 2082;
    float v15 = "";
    __int16 v16 = 2082;
    __double2 v17 = v8;
    __int16 v18 = 2082;
    id v19 = v9;
    __int16 v20 = 1026;
    int v21 = v10;
    __int16 v22 = 1026;
    int v23 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:HeartRate, action:%{public, location:escape_only}s, client:%{public, location:esc ape_only}s, notification:%{public}d, notificationClientCount:%{public}d}",  buf,  0x32u);
  }

BOOL sub_10070E4F8(char *a1, int a2, int *a3)
{
  BOOL v6 = sub_10070E544(a1, a2, a3);
  sub_10070E37C((uint64_t)a1, a2, a3, 0);
  return v6;
}

BOOL sub_10070E544(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      float v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          float v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        __int16 v14 = (char *)*((void *)v8 + 6);
        int v12 = v8 + 48;
        double v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          __int16 v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              id v19 = (char **)v13;
            }
            else {
              id v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              __int16 v16 = v13;
            }
            double v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            __int16 v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                __int16 v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184CBF8);
              }
              uint64_t v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v27 = a1 + 8;
                if (a1[31] < 0) {
                  uint64_t v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  uint64_t v28 = __p;
                }
                else {
                  uint64_t v28 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                __int128 v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10184CBF8);
                }
                int v29 = a1 + 8;
                if (a1[31] < 0) {
                  int v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  uint64_t v31 = buf;
                }
                else {
                  uint64_t v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                __int128 v40 = v29;
                __int16 v41 = 2082;
                uint64_t v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                uint64_t v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::Notification Data>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCatherineNotifier_Ty pe::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

void *sub_10070E8CC@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_10070E944(uint64_t a1)
{
  uint64_t v3 = 0x100000004LL;
  int v4 = 9;
  if ((int)sub_100247620(a1, (int *)&v3, 3LL) >= 1 && !*(_BYTE *)(a1 + 192))
  {
    *(_BYTE *)(a1 + 192) = 1;
    [*(id *)(a1 + 176) setNextFireDelay:3.0];
  }

  return 1LL;
}

uint64_t sub_10070E9DC(uint64_t a1)
{
  int v7 = 9;
  int v2 = sub_100247620(a1, &v7, 1LL);
  int v6 = 1;
  int v3 = sub_100247620(a1, &v6, 1LL);
  int v5 = 4;
  return 1LL;
}

void sub_10070EA6C(uint64_t a1, void *a2)
{
  uint64_t v9 = 0LL;
  BOOL v10 = &v9;
  uint64_t v11 = 0x7012000000LL;
  int v12 = sub_10070EB9C;
  double v13 = nullsub_301;
  __int16 v14 = &unk_10175E27B;
  uint64_t v15 = 0x200000004LL;
  [a2 catherine];
  uint64_t v16 = v4;
  [a2 confidence];
  uint64_t v17 = v5;
  char v18 = 0;
  [a2 timestamp];
  uint64_t v19 = v6;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v21 = 0LL;
  int v22 = 0;
  sub_10070EBB4(a1, (_OWORD *)v10 + 3);
  sub_10070EC38(a1, (_OWORD *)v10 + 3);
  int v7 = *(void **)(a1 + 40);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_10070ECC0;
  v8[3] = &unk_101840030;
  id v8[4] = &v9;
  v8[5] = a1;
  [v7 async:v8];
  [*(id *)(a1 + 176) setNextFireDelay:3.0];
  _Block_object_dispose(&v9, 8);
}

void sub_10070EB84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

__n128 sub_10070EB9C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  __int128 v3 = *(_OWORD *)(a2 + 64);
  __int128 v4 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v4;
  *(__n128 *)(a1 + 4_Block_object_dispose(va, 8) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

uint64_t sub_10070EBB4(uint64_t a1, _OWORD *a2)
{
  __int128 v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  __int128 v4 = a2[3];
  v7[2] = a2[2];
  v7[3] = v4;
  int v6 = 0;
  (*(void (**)(uint64_t, int *, _OWORD *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v6,  v7,  0LL,  0xFFFFFFFFLL,  0LL);
  int v6 = 1;
  return (*(uint64_t (**)(uint64_t, int *, _OWORD *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v6,  v7,  0LL,  0xFFFFFFFFLL,  0LL);
}

uint64_t sub_10070EC38(uint64_t a1, _OWORD *a2)
{
  __int128 v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  __int128 v4 = a2[3];
  v7[2] = a2[2];
  v7[3] = v4;
  int v6 = 5;
  (*(void (**)(uint64_t, int *, _OWORD *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v6,  v7,  0LL,  0xFFFFFFFFLL,  0LL);
  int v6 = 4;
  return (*(uint64_t (**)(uint64_t, int *, _OWORD *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v6,  v7,  0LL,  0xFFFFFFFFLL,  0LL);
}

void sub_10070ECC0(uint64_t a1)
{
}

void sub_10070ECD0(uint64_t a1, uint64_t a2)
{
  __int128 v3 = objc_autoreleasePoolPush();
  __int128 v4 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
  -[ALActivityLog setAllDayHeartRate:]( v4,  "setAllDayHeartRate:",  objc_alloc_init(&OBJC_CLASS___ALCLAllDayHeartRate));
  -[ALCLAllDayHeartRate setStartTime:]( -[ALActivityLog allDayHeartRate](v4, "allDayHeartRate"),  "setStartTime:",  *(double *)(a2 + 40));
  -[ALCLAllDayHeartRate setMode:]( -[ALActivityLog allDayHeartRate](v4, "allDayHeartRate"),  "setMode:",  *(_DWORD *)(a2 + 56) == 5);
  float v5 = *(double *)(a2 + 16);
  int v6 = -[ALActivityLog allDayHeartRate](v4, "allDayHeartRate");
  *(float *)&double v7 = v5;
  -[ALCLAllDayHeartRate setConfidence:](v6, "setConfidence:", v7);
  float v8 = *(double *)(a2 + 8);
  uint64_t v9 = -[ALActivityLog allDayHeartRate](v4, "allDayHeartRate");
  *(float *)&double v10 = v8;
  -[ALCLAllDayHeartRate setHeartRate:](v9, "setHeartRate:", v10);
  objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v4);
  objc_autoreleasePoolPop(v3);
}

id sub_10070EDB8(uint64_t a1)
{
  return objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLCatherineNotifier"),  "syncgetDoSync:",  a1);
}

void sub_10070EDF0(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  float v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLCatherineNotifier");
  sub_10070EEB8((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *float v8 = off_10184CB80;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10070EE8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10070EEB8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_10184CD98;
  *(void *)(a1 + _Block_object_dispose(va, 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + sub_10000AE14(v9 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    int v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + sub_100708348(v2 - 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_10070EF8C(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184CBF8);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10184CBF8);
        }
        int v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        id v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::r emoveClient(int) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNot ifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_10070F200(uint64_t a1, int a2, int *a3, char *a4)
{
  int v42 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v43 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          BOOL v24 = (uint64_t *)v18;
        }
        else {
          BOOL v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v41 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)__int128 buf = &v42;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        memset(buf, 0, sizeof(buf));
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          __int16 v36 = sub_1007115B8(buf);
          sub_100710BE0((_BYTE *)a1, (uint64_t)v43, (uint64_t)&v41, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v41 = a1 + 64;
        char v30 = byte_101939F11;
        HIDWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v17;
        *(void *)__int128 buf = (char *)&v40 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v30;
        HIDWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *a3;
        *(void *)__int128 buf = (char *)&v40 + 4;
        uint64_t v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *a3;
        *(void *)__int128 buf = (char *)&v40 + 4;
        uint64_t v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)__int128 buf = &v42;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)__int128 buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v43 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184CBF8);
  }
  id v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184CBF8);
    }
    __int128 v37 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v43 = 136446466;
    *(void *)&v43[4] = v37;
    __int16 v44 = 1026;
    int v45 = a2;
    LODWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v43,
      v40);
    int v39 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::regis terForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCatherineNotifier_ Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, Re gistrationInfo_T = char]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_10070F664(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184CBF8);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      char v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184CBF8);
      }
      int v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      uint64_t v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      BOOL v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::cli entRegistered(int, const Notification_T &) [Notification_T = CLCatherineNotifier_Type::Notification, Notificatio nData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10070F8E4(uint64_t a1, int *a2, _OWORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      uint64_t v10 = (uint64_t *)v4;
    }
    else {
      uint64_t v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(__int128 **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  __int128 v12 = *v11;
  __int128 v13 = v11[1];
  __int128 v14 = v11[3];
  a3[2] = v11[2];
  a3[3] = v14;
  *a3 = v12;
  a3[1] = v13;
  return 1LL;
}

uint64_t sub_10070F94C(uint64_t a1, int *a2, _OWORD *a3)
{
  int v6 = (char *)operator new(0x58uLL);
  __int128 v7 = a3[1];
  *(_OWORD *)(v6 + sub_10000AE14(v9 + 24) = *a3;
  *(_OWORD *)(v6 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v7;
  __int128 v8 = a3[3];
  *(_OWORD *)(v6 + 56) = a3[2];
  *((void *)v6 + 2) = 0LL;
  *(void *)int v6 = off_10184CD28;
  *((void *)v6 + 1) = 0LL;
  *(_OWORD *)(v6 + 72) = v8;
  *(void *)&__int128 v15 = v6 + 24;
  *((void *)&v15 + 1) = v6;
  int v14 = *a2;
  uint64_t v16 = &v14;
  BOOL v9 = sub_10023347C((uint64_t **)(a1 + 56), &v14, (uint64_t)&unk_1012CF090, &v16);
  sub_10005F550((uint64_t)(v9 + 8), &v15);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)&v15 + 1);
  if (*((void *)&v15 + 1))
  {
    int v11 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return 1LL;
}

void sub_10070FA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10070FA44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v5,  a3,  a4,  0LL);
}

void sub_10070FA84(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184CBF8);
    }
    int v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v12 = (void *)(a1 + 8);
      __int128 v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v69 = 2082;
      __int128 v70 = v12;
      __int16 v71 = 2050;
      __int16 v72 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    __int128 v15 = (__n128 *)(a1 + 64);
    int v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        BOOL v20 = (__n128 **)v14;
      }
      else {
        BOOL v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      int v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)uint64_t v73 = &v73[8];
      memset(&v73[8], 0, 24);
      __int16 v74 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v73);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      uint64_t v21 = v72;
      if (v72)
      {
        p_shared_owners = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v74;
      if (v74)
      {
        int v25 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v73, *(void **)&v73[8]);
    }

    if (a4)
    {
      __int16 v27 = (char *)operator new(0x58uLL);
      __int128 v28 = a3[1];
      *(_OWORD *)(v27 + sub_10000AE14(v9 + 24) = *a3;
      *(_OWORD *)(v27 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v28;
      __int128 v29 = a3[3];
      *(_OWORD *)(v27 + 56) = a3[2];
      *((void *)v27 + 2) = 0LL;
      *(void *)__int16 v27 = off_10184CD28;
      *((void *)v27 + 1) = 0LL;
      *(_OWORD *)(v27 + 72) = v29;
      *(void *)__int128 buf = v27 + 24;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      char v30 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        __int16 v31 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v33 = sub_100710780(a3);
    if (a5 == -1)
    {
      sub_100710808((void *)a1, (int *)a2, v33);
    }

    else
    {
      uint64_t v34 = a1 + 88;
      uint64_t v35 = *(void *)(a1 + 88);
      if (!v35) {
        goto LABEL_48;
      }
      uint64_t v36 = a1 + 88;
      do
      {
        int v37 = *(_DWORD *)(v35 + 32);
        BOOL v38 = v37 < a5;
        if (v37 >= a5) {
          int v39 = (uint64_t *)v35;
        }
        else {
          int v39 = (uint64_t *)(v35 + 8);
        }
        if (!v38) {
          uint64_t v36 = v35;
        }
        uint64_t v35 = *v39;
      }

      while (*v39);
      if (v36 == v34 || *(_DWORD *)(v36 + 32) > a5) {
LABEL_48:
      }
        uint64_t v36 = a1 + 88;
      uint64_t v66 = v36;
      unint64_t v40 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v41 = *a2;
      int v42 = (__n128 *)(a1 + 64);
      do
      {
        int v43 = *(_DWORD *)(v40 + 32);
        BOOL v44 = v43 < v41;
        if (v43 >= v41) {
          int v45 = (unint64_t *)v40;
        }
        else {
          int v45 = (unint64_t *)(v40 + 8);
        }
        if (!v44) {
          int v42 = (__n128 *)v40;
        }
        unint64_t v40 = *v45;
      }

      while (*v45);
      if (v42 == v15 || v41 < (signed __int32)v42[2].n128_u32[0])
      {
LABEL_59:
        double v65 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10184CBF8);
        }
        int v46 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          __int128 v47 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v73, a1, a2);
          if (v73[23] >= 0) {
            __int128 v48 = v73;
          }
          else {
            __int128 v48 = *(_BYTE **)v73;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)&uint8_t buf[4] = v47;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v48;
          _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v73[23] & 0x80000000) != 0) {
            operator delete(*(void **)v73);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_10184CBF8);
          }
          double v49 = (void *)(a1 + 8);
          uint64_t v50 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v64 >= 0) {
            __int128 v51 = __p;
          }
          else {
            __int128 v51 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v73 = 136315650;
          *(void *)&v73[4] = v49;
          *(_WORD *)&v73[12] = 1024;
          *(_DWORD *)&v73[14] = a5;
          *(_WORD *)&v73[18] = 2080;
          *(void *)&v73[20] = v51;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v50,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v73,
            28,
            v62);
          uint64_t v53 = v52;
          if (v64 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>: :notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, N otificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v53);
          if (v53 != buf) {
            free(v53);
          }
        }

        goto LABEL_83;
      }

      double v65 = v42;
      if (v36 == v34) {
        goto LABEL_60;
      }
      uint64_t v56 = v42[3].n128_i64[0];
      uint64_t v54 = v42 + 3;
      double v55 = (__n128 *)v56;
      if (!v56) {
        goto LABEL_60;
      }
      int v57 = *(_DWORD *)(v36 + 32);
      __int16 v58 = v54;
      do
      {
        int v59 = v55[1].n128_i32[3];
        BOOL v60 = v59 < v57;
        if (v59 >= v57) {
          uint64_t v61 = v55;
        }
        else {
          uint64_t v61 = (__n128 *)&v55->n128_i8[8];
        }
        if (!v60) {
          __int16 v58 = v55;
        }
        double v55 = (__n128 *)v61->n128_u64[0];
      }

      while (v61->n128_u64[0]);
      sub_100710BE0((_BYTE *)a1, (uint64_t)&v66, (uint64_t)&v65, v33);
    }

void sub_1007100CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100710118(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184CBF8);
    }
    int v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136315138;
      int v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184CBF8);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      int v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::lis tClients() [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Ty pe::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184CBF8);
    }
    __int128 v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315394;
      int v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184CBF8);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      char v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::lis tClients() [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Ty pe::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    uint64_t v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      int v11 = (void *)(a1 + 8);
      do
      {
        unint64_t v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10184CBF8);
            }
            __int128 v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              int v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)__int128 buf = 136315650;
              int v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184CBF8);
              }
              BOOL v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationDa ta>::listClients() [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCath erineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                unint64_t v12 = v18;
              }

              while (!v19);
            }

            unint64_t v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            uint64_t v10 = v26;
          }

          while (!v19);
        }

        uint64_t v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_1007106C8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100711558(a1);
  operator delete(v1);
}

id sub_1007106DC(uint64_t a1, int a2, void *a3)
{
  id result = sub_100710D0C(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100710728(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100710754(id a1)
{
  qword_101934648 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HeartRate");
}

CLCppContainer *sub_100710780(_OWORD *a1)
{
  int v2 = operator new(0x40uLL);
  __int128 v3 = a1[1];
  *int v2 = *a1;
  v2[1] = v3;
  __int128 v4 = a1[3];
  v2[2] = a1[2];
  v2[3] = v4;
  int v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472LL;
  __int128 v8 = sub_100710CFC;
  uint64_t v9 = &unk_10181D3D0;
  uint64_t v10 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100710808(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          unint64_t v12 = (uint64_t *)v4;
        }
        else {
          unint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        __int128 v51 = v9;
        id v13 = sub_100710D0C(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100710BE0(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              __int128 v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  __int128 v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              __int128 v51 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      int v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      int v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  int v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      int v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184CBF8);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)__int128 buf = 136446466;
                int v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10184CBF8);
                }
                int v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                uint64_t v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                __int128 v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::i nvokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCatherineNotifier_T ype::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

_BYTE *sub_100710BE0(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100710D0C(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    unint64_t v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_100710CBC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184CD28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100710CD0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184CD28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100710CFC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_100710D0C(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppEncodableDataContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100710D84(a1);
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_10071110C(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100710D84(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_1007114B8((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    __int128 v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x8000000101328102LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v_Block_object_dispose(va, 8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    int v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x8000000101328102LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v_Block_object_dispose(va, 8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLCatherineNotifier_Type::NotificationData, Call back = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_10071110C(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    __int128 v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x8000000101328102LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    int v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x8000000101328102LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184CD68);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLCatherineNotifier_Type::NotificationData, Call back = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_1007114B8(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D3830))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)64) {
      sub_101246810();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_10071152C(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t sub_100711558(uint64_t a1)
{
  *(void *)a1 = off_10184CD98;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
  return a1;
}

CLCppContainer *sub_1007115B8(_OWORD *a1)
{
  id v2 = operator new(0x40uLL);
  __int128 v3 = a1[1];
  *id v2 = *a1;
  v2[1] = v3;
  __int128 v4 = a1[3];
  v2[2] = a1[2];
  v2[3] = v4;
  int v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472LL;
  uint64_t v8 = sub_100711640;
  uint64_t v9 = &unk_10181D3D0;
  id v10 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100711640(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_100711650()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1019982B0, (void *)&_mh_execute_header);
}

void *sub_100711694(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10184CDC0;
  a1[9] = off_10184CE78;
  sub_100B14CF0(a1 + 41, 0LL, 0LL);
  sub_100B14CF0(a1 + 43, 0LL, 0LL);
  a1[45] = 0LL;
  a1[46] = 0LL;
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_10071174C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100711778(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + sub_10000AE14(v9 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_10182BDA0;
  *(void *)a1 = off_10184CF38;
  *(void *)(a1 + 72) = off_10184CFE0;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10184CF38;
  *(void *)(a1 + 72) = off_10184CFE0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 24_Block_object_dispose(va, 8) = 12000;
  __int16 v13 = (int *)(a1 + 248);
  *(void *)(a1 + 256) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 264));
  *(void *)(a1 + 264) = &off_10182BDA0;
  uint64_t v14 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v14 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 248));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    *__int16 v13 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184CF08);
  }
  int v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v13;
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    int v24 = *v13;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    int v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLExerciseMinuteData>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, c onst CLSqliteDatabase::SqlitePropertyPersistence) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB:: ClassCDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100711B20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[32] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_100210A00(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100711BC4()
{
}

void *sub_100711BCC(void *a1)
{
  a1[9] = off_10184CFE0;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10184CF38;
  a1[32] = off_10182BD58;
  sub_1001B9C98(a1 + 33);
  sub_100210A00(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100711C48(void *a1)
{
  *a1 = off_10184CDC0;
  a1[9] = off_10184CE78;
  sub_100711C8C((uint64_t)a1, 0LL, 0LL);
  return sub_100711BCC(a1);
}

void sub_100711C8C(uint64_t a1, void *a2, const void *a3)
{
  if ((a2 != 0LL) == (a3 != 0LL))
  {

    *(void *)(a1 + 36sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a2;
    char v6 = *(const void **)(a1 + 368);
    if (v6) {
      _Block_release(v6);
    }
    if (a3) {
      *(void *)(a1 + 36_Block_object_dispose(va, 8) = _Block_copy(a3);
    }
  }

  else
  {
    uint64_t v7 = sub_101246980();
    sub_100711D00(v7);
  }

void *sub_100711D04(uint64_t a1)
{
  return sub_100711C48((void *)(a1 - 72));
}

void sub_100711D0C(void *a1)
{
  uint64_t v1 = sub_100711C48(a1);
  operator delete(v1);
}

void sub_100711D20(uint64_t a1)
{
  uint64_t v1 = sub_100711C48((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100711D38(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v20 = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v21 = 256;
  if (*(double *)(*(void *)(a2 + 8) - 16LL) != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    __int16 v13 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "ExerciseMinute, Failed to expire records.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      __int16 v19 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "ExerciseMinute, Failed to expire records.",  &v19,  2);
      int v18 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual long CLExerciseMinuteRecorderDb::aggregateRecords(const CLAggregationRules &)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }

    goto LABEL_10;
  }

  if (!sub_100D8A92C(a1 + 72))
  {
LABEL_10:
    uint64_t v12 = -1LL;
    goto LABEL_17;
  }

  sub_1003C0454(*(void *)(a1 + 80));
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM ExerciseMinuteHistory WHERE startTime < ?", buf);
  uint64_t v7 = *(void *)buf;
  uint64_t v8 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003B7480(v8, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v9 = *(void *)(a1 + 80);
    id v10 = (sqlite3_stmt *)sub_100019240(v7);
    sub_1003BB2BC(v9, v10);
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    *(_DWORD *)(a1 + 132) = v11;
    uint64_t v12 = v11;
  }

  else
  {
    uint64_t v12 = -1LL;
  }

  sub_1003C05BC(*(void *)(a1 + 80));
  uint64_t v14 = *(void *)(a1 + 80);
  else {
    uint64_t v15 = *(void *)(v14 + 88);
  }
  sub_1003C1EC0(v14, v15);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
LABEL_17:
  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v12;
}

void sub_100711FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100712034(uint64_t a1, uint64_t a2)
{
  return sub_100711D38(a1 - 72, a2);
}

uint64_t sub_10071203C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v4 = a1 + 112;
  uint64_t v6 = v4 - 40;
  uint64_t v25 = v4;
  (*(void (**)(void))(v5 + 16))();
  __int16 v27 = 256;
  sub_1003C0D54(*(void *)(a1 + 80), "SELECT * FROM ExerciseMinuteHistory ORDER BY startTime ASC", v23);
  uint64_t v7 = v23[0];
  uint64_t v24 = v23[0];
  while (1)
  {
    uint64_t result = sub_100712264(&v24, (uint64_t)v23);
    if ((_DWORD)result) {
      break;
    }
    int v9 = v23[0];
    uint64_t v10 = v23[1];
    uint64_t v12 = *(void **)(a2 + 8);
    unint64_t v11 = *(void *)(a2 + 16);
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = *(void **)a2;
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v12 - *(void *)a2) >> 3);
      unint64_t v16 = v15 + 1;
      if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v14) >> 3);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0x555555555555555LL) {
        unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        __int16 v19 = (char *)sub_10000701C(a2 + 16, v18);
        uint64_t v14 = *(void **)a2;
        uint64_t v12 = *(void **)(a2 + 8);
      }

      else
      {
        __int16 v19 = 0LL;
      }

      uint64_t v20 = &v19[24 * v15];
      *(_DWORD *)uint64_t v20 = v9;
      *((void *)v20 + 1) = v10;
      __int16 v21 = v20;
      if (v12 != v14)
      {
        do
        {
          __int128 v22 = *(_OWORD *)(v12 - 3);
          *((void *)v21 - 1) = *(v12 - 1);
          *(_OWORD *)(v21 - sub_10000AE14(v9 + 24) = v22;
          v21 -= 24;
          v12 -= 3;
        }

        while (v12 != v14);
        uint64_t v14 = *(void **)a2;
      }

      __int16 v13 = v20 + 24;
      *(void *)a2 = v21;
      *(void *)(a2 + _Block_object_dispose(va, 8) = v20 + 24;
      *(void *)(a2 + sub_100708348(v2 - 16) = &v19[24 * v18];
      if (v14) {
        operator delete(v14);
      }
    }

    else
    {
      *(_DWORD *)uint64_t v12 = v23[0];
      v12[1] = v10;
      __int16 v13 = (char *)(v12 + 3);
    }

    *(void *)(a2 + _Block_object_dispose(va, 8) = v13;
  }

  if (v7) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  if (HIBYTE(v27))
  {
LABEL_24:
    if ((_BYTE)v27) {
      return pthread_mutex_unlock(v26);
    }
    else {
      return (*(uint64_t (**)(uint64_t))(*(void *)v25 + 24LL))(v25);
    }
  }

  return result;
}

void sub_100712228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100712264(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)a2 = sqlite3_column_int(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  double v8 = sqlite3_column_double(v7, 1);
  uint64_t result = 0LL;
  *(double *)(a2 + _Block_object_dispose(va, 8) = v8;
  return result;
}

uint64_t sub_1007122DC(uint64_t *a1, uint64_t a2, void **a3)
{
  uint64_t v7 = a1[14];
  uint64_t v6 = a1 + 14;
  double v8 = v6 - 5;
  uint64_t v63 = v6;
  (*(void (**)(void))(v7 + 16))();
  __int16 v65 = 256;
  if ((sub_100D8A92C(v8) & 1) == 0)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    __int16 v31 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "ExerciseMinute, DB not accessible.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      LOWORD(v59[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "ExerciseMinute, DB not accessible.",  v59,  2);
      uint64_t v53 = (uint8_t *)v52;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLExerciseMinuteRecorderDb::queryExerciseMinuteDataSince(CLExerciseMinuteData &, std::vector<CLExerciseM inuteData> &) const",  "%s\n",  v52);
      if (v53 != buf) {
        free(v53);
      }
    }

    uint64_t v32 = 109LL;
    goto LABEL_67;
  }

  int v9 = (const __CFString *)sub_1003B76B4(a1[10]);
  if (!v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    uint64_t v33 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_FAULT,  "ExerciseMinute, DB UUID un-initialized",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      LOWORD(v59[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "ExerciseMinute, DB UUID un-initialized",  v59,  2);
      int v55 = (uint8_t *)v54;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLExerciseMinuteRecorderDb::queryExerciseMinuteDataSince(CLExerciseMinuteData &, std::vector<CLExerciseM inuteData> &) const",  "%s\n",  v54);
      if (v55 != buf) {
        free(v55);
      }
    }

    uint64_t v32 = 103LL;
LABEL_67:
    if ((_BYTE)v65) {
      pthread_mutex_unlock(v64);
    }
    else {
      (*(void (**)(uint64_t *))(*v63 + 24))(v63);
    }
    return v32;
  }

  sub_1003C0D54(a1[10], "SELECT * FROM ExerciseMinuteHistory WHERE id >= ? ORDER BY id ASC LIMIT ?", buf);
  uint64_t v10 = *(void *)buf;
  uint64_t v62 = *(void *)buf;
  unint64_t v11 = *(const __CFString **)(a2 + 16);
  if (v11 && CFStringCompare(v11, v9, 1uLL)
    || !(*(unsigned int (**)(uint64_t *, _DWORD *))(*a1 + 104))(a1, v59) && v59[0] < *(_DWORD *)a2)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    uint64_t v12 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      int v13 = *(_DWORD *)a2;
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v59[0];
      __int16 v70 = 1024;
      int v71 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "ExerciseMinute, Potential DB reset / roll back, returning all records to clients,mru.recordId,%d,record.recordId,%d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      int v56 = *(_DWORD *)a2;
      v66[0] = 67109376;
      v66[1] = v59[0];
      __int16 v67 = 1024;
      int v68 = v56;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "ExerciseMinute, Potential DB reset / roll back, returning all records to clients,mru.recordId,%d,record.recordId,%d",  v66,  14);
      __int16 v58 = (uint8_t *)v57;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLExerciseMinuteRecorderDb::queryExerciseMinuteDataSince(CLExerciseMinuteData &, std::vector<CLExerciseM inuteData> &) const",  "%s\n",  v57);
      if (v58 != buf) {
        free(v58);
      }
    }

    uint64_t v14 = (sqlite3_stmt *)sub_100019240(v10);
    if (sub_1003C28BC(v14, 1, 1))
    {
      unint64_t v15 = (sqlite3_stmt *)sub_100019240(v10);
      if (sub_1003C28BC( v15,  2,  (int)objc_msgSend( +[CMExerciseMinuteData maxExerciseMinuteDataEntries]( CMExerciseMinuteData,  "maxExerciseMinuteDataEntries"),  "intValue")))
      {
        while (!sub_100712264(&v62, (uint64_t)&v60))
        {
          int v16 = v60;
          uint64_t v17 = v61;
          __int16 v19 = (char *)a3[1];
          unint64_t v18 = (char *)a3[2];
          if (v19 >= v18)
          {
            unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (_BYTE *)*a3) >> 3);
            unint64_t v22 = v21 + 1;
            if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_83;
            }
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v18 - (_BYTE *)*a3) >> 3);
            if (2 * v23 > v22) {
              unint64_t v22 = 2 * v23;
            }
            if (v23 >= 0x555555555555555LL) {
              unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24) {
              uint64_t v25 = (char *)sub_10000701C((uint64_t)(a3 + 2), v24);
            }
            else {
              uint64_t v25 = 0LL;
            }
            int v26 = &v25[24 * v21];
            *(_DWORD *)int v26 = v16;
            *((void *)v26 + 1) = v17;
            *((void *)v26 + 2) = v9;
            uint64_t v28 = (char *)*a3;
            __int16 v27 = (char *)a3[1];
            uint64_t v29 = v26;
            if (v27 != *a3)
            {
              do
              {
                __int128 v30 = *(_OWORD *)(v27 - 24);
                *((void *)v29 - 1) = *((void *)v27 - 1);
                *(_OWORD *)(v29 - sub_10000AE14(v9 + 24) = v30;
                v29 -= 24;
                v27 -= 24;
              }

              while (v27 != v28);
              __int16 v27 = (char *)*a3;
            }

            uint64_t v20 = v26 + 24;
            *a3 = v29;
            a3[1] = v26 + 24;
            a3[2] = &v25[24 * v24];
            if (v27) {
              operator delete(v27);
            }
          }

          else
          {
            *(_DWORD *)__int16 v19 = v60;
            *((void *)v19 + 1) = v17;
            uint64_t v20 = v19 + 24;
            *((void *)v19 + 2) = v9;
          }

          a3[1] = v20;
        }
      }
    }
  }

  else
  {
    uint64_t v34 = (sqlite3_stmt *)sub_100019240(v10);
    if (sub_1003C28BC(v34, 1, *(_DWORD *)a2))
    {
      uint64_t v35 = (sqlite3_stmt *)sub_100019240(v10);
      if (sub_1003C28BC( v35,  2,  (int)objc_msgSend( +[CMExerciseMinuteData maxExerciseMinuteDataEntries]( CMExerciseMinuteData,  "maxExerciseMinuteDataEntries"),  "intValue")))
      {
        while (!sub_100712264(&v62, (uint64_t)&v60))
        {
          int v36 = v60;
          uint64_t v37 = v61;
          int v39 = (char *)a3[1];
          BOOL v38 = (char *)a3[2];
          if (v39 >= v38)
          {
            unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((v39 - (_BYTE *)*a3) >> 3);
            unint64_t v42 = v41 + 1;
            if (v41 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_83:
            }
              sub_100007008();
            unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((v38 - (_BYTE *)*a3) >> 3);
            if (2 * v43 > v42) {
              unint64_t v42 = 2 * v43;
            }
            if (v43 >= 0x555555555555555LL) {
              unint64_t v44 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v44 = v42;
            }
            if (v44) {
              int v45 = (char *)sub_10000701C((uint64_t)(a3 + 2), v44);
            }
            else {
              int v45 = 0LL;
            }
            int v46 = &v45[24 * v41];
            *(_DWORD *)int v46 = v36;
            *((void *)v46 + 1) = v37;
            *((void *)v46 + 2) = v9;
            __int128 v48 = (char *)*a3;
            __int128 v47 = (char *)a3[1];
            uint64_t v49 = v46;
            if (v47 != *a3)
            {
              do
              {
                __int128 v50 = *(_OWORD *)(v47 - 24);
                *((void *)v49 - 1) = *((void *)v47 - 1);
                *(_OWORD *)(v49 - sub_10000AE14(v9 + 24) = v50;
                v49 -= 24;
                v47 -= 24;
              }

              while (v47 != v48);
              __int128 v47 = (char *)*a3;
            }

            int v40 = v46 + 24;
            *a3 = v49;
            a3[1] = v46 + 24;
            a3[2] = &v45[24 * v44];
            if (v47) {
              operator delete(v47);
            }
          }

          else
          {
            *(_DWORD *)int v39 = v60;
            *((void *)v39 + 1) = v37;
            int v40 = v39 + 24;
            *((void *)v39 + 2) = v9;
          }

          a3[1] = v40;
        }
      }
    }
  }

  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  uint64_t v32 = 100LL;
  if (HIBYTE(v65)) {
    goto LABEL_67;
  }
  return v32;
}

void sub_100712ADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100712B38(uint64_t a1)
{
  uint64_t v3 = v8;
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100712BD8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100712BFC(uint64_t a1)
{
  return sub_100712B38(a1 - 72);
}

void sub_100712C04(uint64_t a1)
{
  if (sub_1003C1048(*(void *)(a1 + 80)))
  {
    sub_1003B59A0( *(void *)(a1 + 80),  "ExerciseMinuteHistory",  (const char **)&qword_1019982E8,  (const std::string::value_type **)&qword_101998378,  0);
    *(void *)(a1 + 32_Block_object_dispose(va, 8) = sub_1003BF158( *(void *)(a1 + 80),  "INSERT INTO ExerciseMinuteHistory (startTime) VALUES (?)");
    *(void *)(a1 + 336) = v2;
    *(void *)(a1 + 344) = sub_1003BF158( *(void *)(a1 + 80),  "SELECT * FROM ExerciseMinuteHistory ORDER BY startTime DESC LIMIT 1");
    *(void *)(a1 + 352) = v3;
    *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    uint64_t v4 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "ExerciseMinute, Device is locked and we are unable to open the database",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      v7[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "ExerciseMinute, Device is locked and we are unable to open the database",  v7,  2);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLExerciseMinuteRecorderDb::prepareSQLStatements()",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

uint64_t sub_100712DFC(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM ExerciseMinuteHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    *(_DWORD *)(a1 + 132) = 0;
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100712E94(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100712EB4(uint64_t a1)
{
  return sub_100712DFC(a1 - 72);
}

uint64_t sub_100712EBC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM ExerciseMinuteHistory WHERE startTime > ?", buf);
    uint64_t v5 = *(void *)buf;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 8)))
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
      *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160LL))(a1);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      int v9 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "ExerciseMinute, Failed to delete records",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        v14[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "ExerciseMinute, Failed to delete records",  v14,  2);
        int v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLExerciseMinuteRecorderDb::deleteRecordsAfterInsertUL(const CLExerciseMinuteData &)",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
      }
    }

    uint64_t v10 = *(void *)(a1 + 80);
    else {
      uint64_t v11 = *(void *)(v10 + 88);
    }
    uint64_t result = sub_1003C1EC0(v10, v11);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100713100(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071312C(uint64_t a1, double a2)
{
  if (sub_100D8A92C(a1 + 72))
  {
    sub_1003C0D54(*(void *)(a1 + 80), "UPDATE ExerciseMinuteHistory SET startTime = startTime + ?", buf);
    uint64_t v4 = *(void *)buf;
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003B7480(v5, 1, a2))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v4);
      sub_1003BB2BC(v6, v7);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      uint64_t v8 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "ExerciseMinute, Failed to shift records",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        v11[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "ExerciseMinute, Failed to shift records",  v11,  2);
        uint64_t v10 = (uint8_t *)v9;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLExerciseMinuteRecorderDb::shiftRecordsByUL(CFTimeInterval)",  "%s\n",  v9);
        if (v10 != buf) {
          free(v10);
        }
      }
    }

    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

void sub_100713334(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100713360(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 328), &v16);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v16);
    if (sub_1003B7480(v5, 1, *(double *)(a2 + 8)))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v16);
      sub_1003BB2BC(v6, v7);
      ++*(_DWORD *)(a1 + 132);
      if (*(void *)(a1 + 360))
      {
        if (*(void *)(a1 + 368))
        {
          uint64_t v17 = *(void *)(a2 + 4);
          int v18 = *(_DWORD *)(a2 + 12);
          int v8 = sub_1003C1068(*(void *)(a1 + 80));
          uint64_t v9 = sub_1003B76B4(*(void *)(a1 + 80));
          uint64_t v10 = *(void **)(a1 + 360);
          v11[0] = _NSConcreteStackBlock;
          v11[1] = 3221225472LL;
          v11[2] = sub_1007134E4;
          v11[3] = &unk_101832DF8;
          v11[4] = a1;
          int v12 = v8;
          uint64_t v13 = v17;
          int v14 = v18;
          uint64_t v15 = v9;
          [v10 async:v11];
        }
      }
    }

    uint64_t result = v16;
    uint64_t v16 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_1007134B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 8LL))(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007134E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 368LL);
  uint64_t v4 = *(void *)(a1 + 56);
  __int128 v3 = *(_OWORD *)(a1 + 40);
  return (*(uint64_t (**)(uint64_t, __int128 *))(v1 + 16))(v1, &v3);
}

uint64_t sub_100713524(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100712264(&v9, (uint64_t)&v7);
  if (!(_DWORD)v4)
  {
    *(_DWORD *)a2 = v7;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v8;
  }

  uint64_t v5 = v9;
  uint64_t v9 = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v4;
}

void sub_1007135AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007135D0(void *a1, void **a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v40);
  if ((SHIBYTE(v41) & 0x80000000) == 0)
  {
    if (HIBYTE(v41)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_101246AE0(v10);
    goto LABEL_40;
  }

  uint64_t v4 = (std::stringbuf *)v40[1];
  operator delete(v40[0]);
  if (!v4) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v40);
  uint64_t v11 = sub_10000CF44(&v41, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  int v14 = sub_10000CF44(v11, (uint64_t)p_p, size);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  uint64_t v15 = a1[10];
  uint64_t v4 = &v42;
  std::stringbuf::str(&__p, &v42);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v16 = &__p;
  }
  else {
    uint64_t v16 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v15, (char *)v16, &v37);
  uint64_t v5 = v37;
  uint64_t v37 = 0LL;
  uint64_t v38 = v5;
  uint64_t v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    int v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v38, (uint64_t)&__p);
        if ((_DWORD)v19) {
          break;
        }
        unint64_t v21 = (char *)a2[1];
        uint64_t v20 = (char *)a2[2];
        if (v21 >= v20)
        {
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((v21 - (_BYTE *)*a2) >> 3);
          unint64_t v25 = v24 + 1;
          if (v24 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_100007008();
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v20 - (_BYTE *)*a2) >> 3);
          if (2 * v26 > v25) {
            unint64_t v25 = 2 * v26;
          }
          if (v26 >= 0x555555555555555LL) {
            unint64_t v27 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            uint64_t v28 = (char *)sub_10000701C((uint64_t)(a2 + 2), v27);
          }
          else {
            uint64_t v28 = 0LL;
          }
          uint64_t v29 = &v28[24 * v24];
          __int128 v30 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v29 + 2) = __p.__r_.__value_.__l.__cap_;
          *(_OWORD *)uint64_t v29 = v30;
          uint64_t v32 = (char *)*a2;
          __int16 v31 = (char *)a2[1];
          uint64_t v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *(_OWORD *)(v31 - 24);
              *((void *)v33 - 1) = *((void *)v31 - 1);
              *(_OWORD *)(v33 - sub_10000AE14(v9 + 24) = v34;
              v33 -= 24;
              v31 -= 24;
            }

            while (v31 != v32);
            __int16 v31 = (char *)*a2;
          }

          unint64_t v23 = v29 + 24;
          *a2 = v33;
          a2[1] = v29 + 24;
          a2[2] = &v28[24 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v21 + 2) = __p.__r_.__value_.__l.__cap_;
          *(_OWORD *)unint64_t v21 = v22;
          unint64_t v23 = v21 + 24;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v38;
      goto LABEL_42;
    }
  }

void sub_100713910( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100713978(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)unint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&uint64_t v44[6] = "";
      __int16 v45 = 2082;
      int v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      int v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)__int128 buf = 134349056;
        *(void *)unint64_t v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        uint64_t v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLExerciseMinuteData>::setDatabaseAccessible() [T = CLExerciseMinuteData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)unint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&uint64_t v44[6] = "";
      __int16 v45 = 2082;
      int v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0xAA));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 24 * (v13 % 0xAA);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0xAA)) + 24 * (v22 % 0xAA);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10184D020);
      }
      unint64_t v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10184D020);
        }
        LOWORD(v41) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        unint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLExerciseMinuteData>::setDatabaseAccessible() [T = CLExerciseMinuteData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 24LL;
      if (v17 - *v16 == 4080)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184CF08);
    }
    int v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)unint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&uint64_t v44[6] = "";
      __int16 v45 = 2082;
      int v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
    }

    uint64_t v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      unint64_t v21 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)unint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&uint64_t v44[6] = "";
      __int16 v45 = 2082;
      int v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  uint64_t v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 2sub_100708348(v2 - 16) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      uint64_t v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 85LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 170LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v32;
LABEL_61:
  uint64_t v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_1007140A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_1007140D8(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

id *sub_1007140EC(uint64_t a1, __int128 *a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 104LL))(a1, v32);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLExerciseMinuteData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLExer ciseMinuteData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *((double *)a2 + 1);
    double v8 = v33;
    double v9 = v7 - v33;
    if (v7 - v33 < 0.0) {
      double v9 = -(v7 - v33);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 1);
        *(_DWORD *)__int128 buf = 134349312;
        double v40 = v33;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        uint64_t v23 = *((void *)a2 + 1);
        int v35 = 134349312;
        double v36 = v33;
        __int16 v37 = 2050;
        uint64_t v38 = v23;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        unint64_t v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLExerciseMinuteData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLExer ciseMinuteData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *((double *)a2 + 1);
      double v8 = v33;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 1);
          *(_DWORD *)__int128 buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184CF08);
          }
          double v26 = *((double *)a2 + 1);
          int v35 = 134217984;
          double v36 = v26;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          uint64_t v28 = (uint8_t *)v27;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLExerciseMinuteData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLEx erciseMinuteData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        (*(void (**)(uint64_t, __int128 *))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v31 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10184CF08);
        double v18 = v31;
      }

      double v19 = v17 - v18;
      uint64_t v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 134217984;
        double v40 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184CF08);
        }
        int v35 = 134217984;
        double v36 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        unint64_t v30 = (uint8_t *)v29;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLExerciseMinuteData>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLExer ciseMinuteData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, char *, uint64_t, __int128 *))(*(void *)a1 + 144LL))(a1, v32, a1 + 224, a2);
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100714830( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_10071485C(uint64_t a1)
{
  return sub_100713978(a1 - 72);
}

void sub_100714864(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100714890(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v34);
  if ((SHIBYTE(v35) & 0x80000000) == 0)
  {
    if (HIBYTE(v35)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_101246C48(v4);
LABEL_44:
    sub_100007008();
  }

  unint64_t v30 = v34[1];
  operator delete(v34[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v34);
    int v6 = sub_10000CF44(&v35, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t *))(*a1 + 64))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v36);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v31);
    uint64_t v12 = v31;
    uint64_t v31 = 0LL;
    uint64_t v32 = v12;
    sub_1003C0454(a1[10]);
    while (!sub_1001BA11C((uint64_t)a1, &v32, (uint64_t)&__p))
    {
      unint64_t v14 = (unint64_t)a2[1];
      unint64_t v13 = (unint64_t)a2[2];
      if (v14 >= v13)
      {
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - (void)*a2) >> 3);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_44;
        }
        unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)*a2) >> 3);
        if (2 * v19 > v18) {
          unint64_t v18 = 2 * v19;
        }
        if (v19 >= 0x555555555555555LL) {
          unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          __int128 v21 = (char *)sub_10000701C((uint64_t)(a2 + 2), v20);
        }
        else {
          __int128 v21 = 0LL;
        }
        unint64_t v22 = &v21[24 * v17];
        __int128 v23 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((void *)v22 + 2) = __p.__r_.__value_.__l.__cap_;
        *(_OWORD *)unint64_t v22 = v23;
        unint64_t v25 = *a2;
        unint64_t v24 = a2[1];
        double v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *(_OWORD *)(v24 - 24);
            *((void *)v26 - 1) = *((void *)v24 - 1);
            *(_OWORD *)(v26 - sub_10000AE14(v9 + 24) = v27;
            v26 -= 24;
            v24 -= 24;
          }

          while (v24 != v25);
          unint64_t v24 = *a2;
        }

        uint64_t v16 = v22 + 24;
        *a2 = v26;
        a2[1] = v22 + 24;
        a2[2] = &v21[24 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v14 + sub_100708348(v2 - 16) = __p.__r_.__value_.__l.__cap_;
        *(_OWORD *)unint64_t v14 = v15;
        uint64_t v16 = (char *)(v14 + 24);
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v32;
    uint64_t v32 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v34
    uint64_t v35 = v29;
    std::streambuf::~streambuf(&v36);
    return std::ios::~ios(&v37);
  }

  return result;
}

void sub_100714B8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100714BF4(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    unint64_t v20 = (_Unwind_Exception *)sub_101246DB0(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  unint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100714E54(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101246F18(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_10071508C(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101247080(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_1007152B4(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

  ;
}

void sub_1007152F4()
{
  qword_1019982E8 = (uint64_t)"id";
  dword_1019982F0 = 1;
  word_1019982F4 = 257;
  byte_1019982F8 = 0;
  byte_101998310 = 0;
  qword_101998318 = (uint64_t)"startTime";
  dword_101998320 = 2;
  word_101998324 = 0;
  byte_101998328 = 0;
  byte_101998340 = 0;
  qword_101998348 = 0LL;
  dword_101998350 = 5;
  word_101998354 = 0;
  byte_101998358 = 0;
  byte_101998370 = 0;
  qword_101998378 = (uint64_t)"startTime";
  unk_101998380 = 0LL;
}

uint64_t sub_10071542C()
{
  if (qword_101998388 != -1) {
    dispatch_once(&qword_101998388, &stru_10184D040);
  }
  return qword_1019A15C8;
}

void sub_10071546C(id a1)
{
  uint64_t v1 = (CFRunLoopTimerRef *)operator new(0x40uLL);
  sub_1007154B8(v1, 3, 1);
  qword_1019A15C8 = (uint64_t)v1;
}

void sub_1007154A4(_Unwind_Exception *a1)
{
}

CFRunLoopTimerRef *sub_1007154B8(CFRunLoopTimerRef *a1, int a2, char a3)
{
  *a1 = (CFRunLoopTimerRef)off_10184D070;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  *((_DWORD *)a1 + _Block_object_dispose(va, 8) = a2;
  a1[5] = 0LL;
  *((_BYTE *)a1 + 4_Block_object_dispose(va, 8) = a3;
  *((_DWORD *)a1 + 13) = 0;
  a1[7] = 0LL;
  context.version = 0LL;
  context.info = a1;
  memset(&context.retain, 0, 24);
  CFRunLoopTimerRef v4 = CFRunLoopTimerCreate( kCFAllocatorDefault,  1.79769313e308,  1.79769313e308,  0LL,  0LL,  (CFRunLoopTimerCallBack)sub_100715584,  &context);
  a1[7] = v4;
  if (v4)
  {
    sub_1006E27E8();
    uint64_t v5 = (__CFRunLoop *)sub_1006E2AB4();
    CFRunLoopAddTimer(v5, a1[7], kCFRunLoopCommonModes);
  }

  return a1;
}

void sub_10071556C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100715584(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10071558C(uint64_t a1)
{
  *(void *)a1 = off_10184D070;
  uint64_t v2 = *(__CFRunLoopTimer **)(a1 + 56);
  if (v2)
  {
    CFRunLoopTimerInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 56));
  }

  sub_1007155F0(a1);
  CFRunLoopTimerRef v4 = (void **)(a1 + 8);
  sub_10071B474(&v4);
  return a1;
}

void sub_1007155F0(uint64_t a1)
{
  double Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (void *)sub_1006E2AB4())
  {
    sub_1012471E8();
LABEL_10:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    goto LABEL_5;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    sub_1006E27E8();
    uint64_t v4 = sub_1006E2AB4();
    IOHIDEventSystemClientUnscheduleWithRunLoop(v3, v4, kCFRunLoopDefaultMode);
    IOHIDEventSystemClientUnregisterEventCallback(*(void *)(a1 + 40), sub_100715EE8, a1, 0LL);
    IOHIDEventSystemClientUnregisterResetCallback(*(void *)(a1 + 40), sub_100715EEC, a1, 0LL);
    IOHIDEventSystemClientUnregisterDeviceMatchingCallback(*(void *)(a1 + 40), sub_100715EF0, a1, 0LL);
    CFRelease(*(CFTypeRef *)(a1 + 40));
    *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  double Current = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
    goto LABEL_10;
  }
LABEL_5:
  uint64_t v5 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Hid interface closed",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (Current[150] != -1LL) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    v7[0] = 0;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Hid interface closed",  v7,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::closeHid()", "%s\n", v6);
  }

void sub_100715814(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10071558C(a1);
  operator delete(v1);
}

void **sub_100715828(uint64_t *a1, void *a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_101247348(qword_1019344B0 == -1);
    __break(1u);
LABEL_25:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_22:
    uint64_t v25 = p_vtable[151];
    int v26 = *(_DWORD *)(*a2 + 16LL);
    int v27 = *(_DWORD *)(*a2 + 20LL);
    v30[0] = 67240448;
    v30[1] = v27;
    __int16 v31 = 1026;
    int v32 = v26;
    uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  0LL,  "[CLIoHidInterface] Adding new Device with usage pair {%{public}d, %{public}d}",  v30,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::addDevice(std::shared_ptr<CLIoHidInterface::Device>)",  "%s\n",  v28);
    goto LABEL_7;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  int v6 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(*a2 + 16LL);
    int v8 = *(_DWORD *)(*a2 + 20LL);
    *(_DWORD *)__int128 buf = 67240448;
    *(_DWORD *)&uint8_t buf[4] = v8;
    LOWORD(v34) = 1026;
    *(_DWORD *)((char *)&v34 + 2) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Adding new Device with usage pair {%{public}d, %{public}d}",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 == -1) {
      goto LABEL_22;
    }
    goto LABEL_25;
  }

void sub_100715AF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100715B28(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (void *)sub_1006E2AB4())
  {
    sub_1012474BC();
LABEL_20:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_7:
    int v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Event system client initialized successfully",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (Current[150] != -1LL) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      v10[0] = 0;
      int v8 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Event system client initialized successfully",  v10,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::initializeHidIfNecessary()", "%s\n");
LABEL_24:
      if (v8 != buf) {
        free(v8);
      }
      return;
    }

    return;
  }

  if (*(void *)(a1 + 40)) {
    return;
  }
  unint64_t v12 = @"HighFrequency";
  uint64_t v3 = &__kCFBooleanTrue;
  if (!*(_BYTE *)(a1 + 48)) {
    uint64_t v3 = &__kCFBooleanFalse;
  }
  uint64_t v13 = v3;
  uint64_t v4 = IOHIDEventSystemClientCreateWithType( kCFAllocatorDefault,  *(unsigned int *)(a1 + 32),  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v13,  &v12,  1LL));
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v4;
  if (v4)
  {
    uint64_t v5 = v4;
    sub_1006E27E8();
    uint64_t v6 = sub_1006E2AB4();
    IOHIDEventSystemClientScheduleWithRunLoop(v5, v6, kCFRunLoopDefaultMode);
    IOHIDEventSystemClientRegisterEventCallback(*(void *)(a1 + 40), sub_100715EE8, a1, 0LL);
    IOHIDEventSystemClientRegisterResetCallback(*(void *)(a1 + 40), sub_100715EEC, a1, 0LL);
    IOHIDEventSystemClientRegisterDeviceMatchingCallback(*(void *)(a1 + 40), sub_100715EF0, a1, "ADDED");
    sub_100715EF4((void *)a1);
    IOHIDEventSystemClientSetProperty( *(IOHIDEventSystemClientRef *)(a1 + 40),  @"PreserveTimestamp",  kCFBooleanTrue);
    CFRunLoopRef Current = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019344B0 == -1) {
      goto LABEL_7;
    }
    goto LABEL_20;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  __int128 v9 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[CLIoHidInterface] Could not create event system client. All bets are off",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    v10[0] = 0;
    int v8 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "[CLIoHidInterface] Could not create event system client. All bets are off",  v10,  2);
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLIoHidInterface::initializeHidIfNecessary()", "%s\n");
    goto LABEL_24;
  }

void sub_100715EF4(void *a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_10124761C();
    __break(1u);
LABEL_55:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_47:
    int v26 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134349056;
      v36[0] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Setting matching multiple for %{public}lu events",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      LODWORD(v37) = 134349056;
      *(void *)((char *)&v37 + 4) = v2;
      LODWORD(v2_Block_object_dispose(va, 8) = 12;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Setting matching multiple for %{public}lu events",  &v37,  v28);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::setMatchingForDevices()", "%s\n", v27);
    }

    IOHIDEventSystemClientSetMatchingMultiple( a1[5],  +[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v1));
    objc_autoreleasePoolPop(context);
    goto LABEL_51;
  }

  CFRunLoopTimerContext context = objc_autoreleasePoolPush();
  uint64_t v5 = sub_1004F97F4();
  uint64_t v1 = +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  (uint64_t)(a1[2] - a1[1]) >> 4);
  uint64_t v6 = (uint64_t *)a1[1];
  int v7 = (uint64_t *)a1[2];
  if (v6 == v7)
  {
    uint64_t v2 = 0LL;
LABEL_46:
    if (qword_1019344B0 == -1) {
      goto LABEL_47;
    }
    goto LABEL_55;
  }

  uint64_t v2 = 0LL;
  while (1)
  {
    int v8 = (std::__shared_weak_count *)v6[1];
    if (v8) {
      break;
    }
LABEL_35:
    v6 += 2;
    if (v6 == v7) {
      goto LABEL_46;
    }
  }

  uint64_t v9 = *v6;
  p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
  do
    unint64_t v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  unint64_t v12 = std::__shared_weak_count::lock(v8);
  *((void *)&v37 + 1) = v12;
  if (!v12)
  {
    std::__shared_weak_count::__release_weak(v8);
    goto LABEL_35;
  }

  uint64_t v13 = v12;
  *(void *)&__int128 v37 = v9;
  if (v9)
  {
    if ((v5 & 0x800000000000LL) == 0 && *(_DWORD *)(v9 + 20) == 65280 && *(_DWORD *)(v9 + 16) == 8)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      unint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "[CLIoHidInterface] Prox: remove set matching multiple",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        LOWORD(v32[0]) = 0;
        LODWORD(v2_Block_object_dispose(va, 8) = 2;
        uint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "[CLIoHidInterface] Prox: remove set matching multiple",  v32,  v28);
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::setMatchingForDevices()", "%s\n", v25);
      }

      IOHIDEventSystemClientSetMatchingMultiple(a1[5], 0LL);
      sub_100717184((uint64_t)a1);
      sub_1007165A8((uint64_t)a1, 0LL);
      LODWORD(v9) = 0;
      int v15 = 1;
    }

    else
    {
      if (*(void *)(v9 + 48))
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        uint64_t v16 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          int v18 = *(_DWORD *)(v9 + 16);
          int v17 = *(_DWORD *)(v9 + 20);
          *(_DWORD *)__int128 buf = 67240448;
          LODWORD(v36[0]) = v17;
          WORD2(v36[0]) = 1026;
          *(_DWORD *)((char *)v36 + 6) = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Adding match entry for usage pair {%{public}d, %{public}d}",  buf,  0xEu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          int v23 = *(_DWORD *)(v9 + 16);
          int v22 = *(_DWORD *)(v9 + 20);
          v32[0] = 67240448;
          v32[1] = v22;
          __int16 v33 = 1026;
          int v34 = v23;
          LODWORD(v2_Block_object_dispose(va, 8) = 14;
          uint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Adding match entry for usage pair {%{public}d, %{public}d}",  v32,  v28);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::setMatchingForDevices()", "%s\n", v24);
        }

        v30[0] = @"PrimaryUsagePage";
        unint64_t v19 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v9 + 20));
        v30[1] = @"PrimaryUsage";
        v31[0] = v19;
        v31[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v9 + 16));
        -[NSMutableArray setObject:atIndexedSubscript:]( v1,  "setObject:atIndexedSubscript:",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v31,  v30,  2LL),  v2);
        int v15 = 0;
        ++v2;
      }

      else
      {
        int v15 = 0;
      }

      LODWORD(v9) = 1;
    }
  }

  else
  {
    int v15 = 9;
  }

  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    unint64_t v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }

  std::__shared_weak_count::__release_weak(v8);
  if (v15 == 9 || !v15) {
    goto LABEL_35;
  }
  objc_autoreleasePoolPop(context);
  if ((_DWORD)v9)
  {
LABEL_51:
    sub_100717184((uint64_t)a1);
    sub_1007165A8((uint64_t)a1, 0LL);
  }

void sub_10071657C(_Unwind_Exception *a1)
{
}

void sub_1007165A8(uint64_t a1, __IOHIDServiceClient *a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    if (qword_1019344B0 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101247784(qword_1019344B0 == -1);
    __break(1u);
  }

  dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_3:
  uint64_t v4 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "[CLIoHidInterface] Refreshing service refs",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    LOWORD(v34) = 0;
    uint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "[CLIoHidInterface] Refreshing service refs",  &v34,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::refreshDeviceServiceRefs(const IOHIDServiceClientRef)",  "%s\n",  v25);
    if (v25 != buf) {
      free(v25);
    }
  }

  CFArrayRef obj = IOHIDEventSystemClientCopyServices(*(IOHIDEventSystemClientRef *)(a1 + 40));
  if (obj)
  {
    CFRunLoopTimerContext context = objc_autoreleasePoolPush();
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    id v5 = -[__CFArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v30,  v42,  16LL);
    if (v5)
    {
      uint64_t v6 = *(void *)v31;
      do
      {
        int v7 = 0LL;
        do
        {
          if (*(void *)v31 != v6) {
            objc_enumerationMutation(obj);
          }
          int v8 = *(__IOHIDServiceClient **)(*((void *)&v30 + 1) + 8LL * (void)v7);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v9 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(v8, @"PrimaryUsagePage"),  "intValue");
            unsigned int v10 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(v8, @"PrimaryUsage"),  "intValue");
            unsigned int v11 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(v8, @"LocationID"),  "intValue");
            if (qword_1019344B0 != -1) {
              dispatch_once(&qword_1019344B0, &stru_10184D0D8);
            }
            unint64_t v12 = (os_log_s *)qword_1019344B8;
            if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 134284289;
              *(void *)&uint8_t buf[4] = v8;
              *(_WORD *)&_BYTE buf[12] = 1026;
              *(_DWORD *)&buf[14] = v9;
              __int16 v44 = 1026;
              unsigned int v45 = v10;
              __int16 v46 = 1026;
              unsigned int v47 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Check service ref %{private}p with usage pair {%{public}d, %{public}d} locationID %{p ublic}d as a potential match",  buf,  0x1Eu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019344B0 != -1) {
                dispatch_once(&qword_1019344B0, &stru_10184D0D8);
              }
              int v34 = 134284289;
              uint64_t v35 = v8;
              __int16 v36 = 1026;
              unsigned int v37 = v9;
              __int16 v38 = 1026;
              unsigned int v39 = v10;
              __int16 v40 = 1026;
              unsigned int v41 = v11;
              LODWORD(v26) = 30;
              int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Check service ref %{private}p with usage pair {%{public}d, %{public}d} locationID %{public}d as a potential match",  &v34,  v26);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::refreshDeviceServiceRefs(const IOHIDServiceClientRef)",  "%s\n",  v23);
              if (v23 != buf) {
                free(v23);
              }
            }
          }

          if (v8 != a2)
          {
            unint64_t v14 = *(uint64_t **)(a1 + 8);
            uint64_t v13 = *(uint64_t **)(a1 + 16);
            while (v14 != v13)
            {
              int v15 = (std::__shared_weak_count *)v14[1];
              if (v15)
              {
                uint64_t v16 = *v14;
                p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
                do
                  unint64_t v18 = __ldxr(p_shared_weak_owners);
                while (__stxr(v18 + 1, p_shared_weak_owners));
                unint64_t v19 = std::__shared_weak_count::lock(v15);
                *(void *)&uint8_t buf[8] = v19;
                if (v19)
                {
                  uint64_t v20 = v19;
                  *(void *)__int128 buf = v16;
                  if (v16)
                  {
                    if ((sub_100716B44(v16, v8) & 1) != 0)
                    {
                      sub_100716B88(v16, v8, 0);
                      if (*(void *)(v16 + 80)) {
                        IOHIDServiceClientRegisterRemovalCallback(v8, sub_100717180, a1, "REMOVED");
                      }
                    }
                  }

                  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
                  do
                    unint64_t v22 = __ldaxr(p_shared_owners);
                  while (__stlxr(v22 - 1, p_shared_owners));
                  if (!v22)
                  {
                    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
                    std::__shared_weak_count::__release_weak(v20);
                  }
                }

                std::__shared_weak_count::__release_weak(v15);
              }

              v14 += 2;
            }
          }

          int v7 = (char *)v7 + 1;
        }

        while (v7 != v5);
        id v24 = -[__CFArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v30,  v42,  16LL);
        id v5 = v24;
      }

      while (v24);
    }

    objc_autoreleasePoolPop(context);
  }

void sub_100716B20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
}

uint64_t sub_100716B44(uint64_t a1, IOHIDServiceClientRef service)
{
  uint64_t result = IOHIDServiceClientConformsTo(service, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 16));
  if ((_DWORD)result) {
    return sub_10071AE74(service, *(void **)(a1 + 152));
  }
  return result;
}

void sub_100716B88(uint64_t a1, void *a2, int a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t v8 = sub_1006E2AB4();
  if (Current != (CFRunLoopRef)v8)
  {
    sub_1012478F8();
LABEL_33:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_19:
    int v15 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 16);
      int v16 = *(_DWORD *)(a1 + 20);
      unint64_t v18 = *(void **)(a1 + 152);
      *(_DWORD *)__int128 buf = 67240963;
      *(_DWORD *)&uint8_t buf[4] = v16;
      __int16 v43 = 1026;
      int v44 = v17;
      __int16 v45 = 2049;
      __int16 v46 = a2;
      __int16 v47 = 2113;
      uint64_t v48 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Service ref with usage pair {%{public}d, %{public}d} is %{private}p with matching properties %{private}@",  buf,  0x22u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      int v22 = *(_DWORD *)(a1 + 16);
      int v21 = *(_DWORD *)(a1 + 20);
      int v23 = *(void **)(a1 + 152);
      int v32 = 67240963;
      int v33 = v21;
      __int16 v34 = 1026;
      int v35 = v22;
      __int16 v36 = 2049;
      unsigned int v37 = a2;
      __int16 v38 = 2113;
      unsigned int v39 = v23;
      id v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Service ref with usage pair {%{public}d, %{public}d} is %{private}p with matchi ng properties %{private}@",  &v32,  34);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::Device::updateServiceRef(IOHIDServiceClientRef, BOOL)",  "%s\n",  v24);
    }

    *(void *)(a1 + sub_10000AE14(v9 + 24) = CFRetain(a2);
    if (!a3) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  unsigned int v9 = *(void **)(a1 + 24);
  if (v9 == a2) {
    return;
  }
  if (!v9)
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019344B0 == -1) {
      goto LABEL_19;
    }
    goto LABEL_33;
  }

  if (!a3) {
    return;
  }
  if (*(_BYTE *)(a1 + 40)
    && !sub_1007179F8(v8, *(__IOHIDServiceClient **)(a1 + 24), @"ReportInterval", &off_1018D3848))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    unsigned int v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "[CLIoHidInterface] Failed to stop streaming from the old service before switching to the new one",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      LOWORD(v32) = 0;
      __int128 v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "[CLIoHidInterface] Failed to stop streaming from the old service before switching to the new one",  &v32,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLIoHidInterface::Device::updateServiceRef(IOHIDServiceClientRef, BOOL)",  "%s\n",  v29);
    }
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  unsigned int v11 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)(a1 + 16);
    int v12 = *(_DWORD *)(a1 + 20);
    uint64_t v14 = *(void *)(a1 + 152);
    *(_DWORD *)__int128 buf = 67241219;
    *(_DWORD *)&uint8_t buf[4] = v12;
    __int16 v43 = 1026;
    int v44 = v13;
    __int16 v45 = 2049;
    __int16 v46 = v9;
    __int16 v47 = 2049;
    uint64_t v48 = a2;
    __int16 v49 = 2113;
    uint64_t v50 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Device,usagePage,%{public}d,usage,%{public}d,hidserviceref,old,%{private}p,new,%{private}p,matc hingProperties,%{private}@",  buf,  0x2Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v26 = *(_DWORD *)(a1 + 16);
    int v25 = *(_DWORD *)(a1 + 20);
    uint64_t v27 = *(void *)(a1 + 152);
    int v32 = 67241219;
    int v33 = v25;
    __int16 v34 = 1026;
    int v35 = v26;
    __int16 v36 = 2049;
    unsigned int v37 = v9;
    __int16 v38 = 2049;
    unsigned int v39 = a2;
    __int16 v40 = 2113;
    uint64_t v41 = v27;
    LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 44;
    uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Device,usagePage,%{public}d,usage,%{public}d,hidserviceref,old,%{private}p,new,%{ private}p,matchingProperties,%{private}@",  &v32,  v30);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::Device::updateServiceRef(IOHIDServiceClientRef, BOOL)",  "%s\n",  v28);
  }

  sub_100717400(a1);
  *(void *)(a1 + sub_10000AE14(v9 + 24) = CFRetain(a2);
LABEL_23:
  sub_100717CF4(*(void *)(a1 + 32));
LABEL_24:
  if (*(void *)(a1 + 112))
  {
    RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID((IOHIDServiceClientRef)a2);
    CFNumberGetValue(RegistryID, kCFNumberSInt64Type, buf);
    if (*(void *)buf != *(void *)(a1 + 8)) {
      (*(void (**)(void))(a1 + 112))(*(void *)(a1 + 120));
    }
  }

  if (*(void *)(a1 + 64) && ((a3 & 1) != 0 || *(_BYTE *)(a1 + 40)))
  {
    uint64_t v20 = sub_1006E27E8();
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 3221225472LL;
    void v31[2] = sub_10071B430;
    v31[3] = &unk_10181D3D0;
    v31[4] = a1;
    sub_1006E2970(v20, (uint64_t)v31);
  }

void sub_100717184(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    if (qword_1019344B0 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101247A58(qword_1019344B0 == -1);
    __break(1u);
  }

  dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_3:
  uint64_t v3 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLIoHidInterface] Invalidating hid service refs",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    v15[0] = 0;
    uint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "[CLIoHidInterface] Invalidating hid service refs",  v15,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::invalidateDeviceServiceRefs()", "%s\n", v14);
  }

  uint64_t v4 = *(uint64_t **)(a1 + 8);
  id v5 = *(uint64_t **)(a1 + 16);
  while (v4 != v5)
  {
    uint64_t v6 = (std::__shared_weak_count *)v4[1];
    if (v6)
    {
      uint64_t v7 = *v4;
      p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
      unsigned int v10 = std::__shared_weak_count::lock(v6);
      int v17 = v10;
      if (v10)
      {
        unsigned int v11 = v10;
        *(void *)__int128 buf = v7;
        if (v7)
        {
          sub_100717400(v7);
          sub_100717500(v7);
          sub_100717710(v7);
        }

        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v13 = __ldaxr(p_shared_owners);
        while (__stlxr(v13 - 1, p_shared_owners));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }

      std::__shared_weak_count::__release_weak(v6);
    }

    v4 += 2;
  }

void sub_1007173DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

id sub_100717400(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + sub_10000AE14(v9 + 24) = 0LL;
  }

  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  uint64_t v3 = *(void **)(a1 + 160);
  id result = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (result)
  {
    id v5 = result;
    uint64_t v6 = *(void *)v9;
    do
    {
      uint64_t v7 = 0LL;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(v3);
        }
        objc_msgSend( objc_msgSend( *(id *)(a1 + 160),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v8 + 1) + 8 * (void)v7)),  "setDirty:",  1);
        uint64_t v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id result = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
      id v5 = result;
    }

    while (result);
  }

  return result;
}

void sub_100717500(uint64_t a1)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  uint64_t v2 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v3 = *(_DWORD *)(a1 + 20);
    BOOL v5 = *(void *)(a1 + 48) != 0LL;
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 buf = 67240961;
    int v20 = v3;
    __int16 v21 = 1026;
    int v22 = v4;
    __int16 v23 = 1026;
    BOOL v24 = v5;
    __int16 v25 = 2049;
    uint64_t v26 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Device,hidUsagePage,%{public}d,hidUsage,%{public}d,hasCallback,%{public}d,serviceRef,%{private}p",  buf,  0x1Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v8 = *(_DWORD *)(a1 + 16);
    int v7 = *(_DWORD *)(a1 + 20);
    BOOL v9 = *(void *)(a1 + 48) != 0LL;
    uint64_t v10 = *(void *)(a1 + 24);
    v12[0] = 67240961;
    v12[1] = v7;
    __int16 v13 = 1026;
    int v14 = v8;
    __int16 v15 = 1026;
    BOOL v16 = v9;
    __int16 v17 = 2049;
    uint64_t v18 = v10;
    __int128 v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Device,hidUsagePage,%{public}d,hidUsage,%{public}d,hasCallback,%{public}d,serviceRef,%{private}p",  v12,  30);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::Device::print() const", "%s\n", v11);
  }

id sub_100717710(uint64_t a1)
{
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  id result = (id)os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    int v4 = *(void **)(a1 + 160);
    id result = [v4 countByEnumeratingWithState:&v18 objects:v34 count:16];
    if (result)
    {
      id v5 = result;
      uint64_t v6 = *(void *)v19;
      do
      {
        int v7 = 0LL;
        do
        {
          if (*(void *)v19 != v6) {
            objc_enumerationMutation(v4);
          }
          uint64_t v8 = *(void *)(*((void *)&v18 + 1) + 8LL * (void)v7);
          id v9 = [*(id *)(a1 + 160) objectForKeyedSubscript:v8];
          uint64_t v10 = (os_log_s *)qword_1019344B8;
          if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
          {
            id v11 = [v9 value];
            unsigned int v12 = [v9 dirty];
            *(_DWORD *)__int128 buf = 138543874;
            uint64_t v29 = v8;
            __int16 v30 = 2114;
            id v31 = v11;
            p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
            __int16 v32 = 1026;
            unsigned int v33 = v12;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] \tProperty: %{public}@ = %{public}@,dirty,%{public}d",  buf,  0x1Cu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            uint64_t v13 = qword_1019344B8;
            id v14 = [v9 value];
            unsigned int v15 = [v9 dirty];
            int v22 = 138543874;
            uint64_t v23 = v8;
            __int16 v24 = 2114;
            id v25 = v14;
            __int16 v26 = 1026;
            unsigned int v27 = v15;
            LODWORD(v17) = 28;
            BOOL v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  2LL,  "[CLIoHidInterface] \tProperty: %{public}@ = %{public}@,dirty,%{public}d",  &v22,  v17);
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::Device::printProperties() const", "%s\n", v16);
            p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          }

          int v7 = (char *)v7 + 1;
        }

        while (v5 != v7);
        id result = [v4 countByEnumeratingWithState:&v18 objects:v34 count:16];
        id v5 = result;
      }

      while (result);
    }
  }

  return result;
}

BOOL sub_1007179F8(uint64_t a1, __IOHIDServiceClient *a2, const __CFString *p_vtable, const void *a4)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_101247BCC();
    goto LABEL_19;
  }

  if (!a2)
  {
    p_vtable = (const __CFString *)&OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019344B0 == -1)
    {
LABEL_6:
      id v9 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[CLIoHidInterface] Property can not be set for null hidServiceRef",  buf,  2u);
      }

      BOOL v10 = sub_1002921D0(115, 0);
      BOOL result = 0LL;
      if (!v10) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      v13[0] = 0;
      id v11 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "[CLIoHidInterface] Property can not be set for null hidServiceRef",  v13,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLIoHidInterface::setPropertyIoHid(IOHIDServiceClientRef, CFStringRef, CFTypeRef)",  "%s\n");
LABEL_23:
      if (v11 != buf) {
        free(v11);
      }
      return 0LL;
    }

void sub_100717CF4(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    if (qword_1019344B0 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101247D2C(qword_1019344B0 == -1);
    __break(1u);
  }

  dispatch_once(&qword_1019344B0, &stru_10184D0D8);
LABEL_3:
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  int v4 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Apply all dirty device properties",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    LOWORD(v73) = 0;
    int v57 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Apply all dirty device properties",  &v73,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::applyAllDirtyDeviceProperties()", "%s\n", v57);
  }

  id v5 = *(void **)(a1 + 8);
  uint64_t v6 = *(void **)(a1 + 16);
  if (v5 == v6) {
    goto LABEL_61;
  }
  char v7 = 1;
  uint64_t v64 = a1;
  int v60 = *(void **)(a1 + 16);
  do
  {
    uint64_t v8 = v5[1];
    if (v8)
    {
      uint64_t v9 = *v5;
      uint64_t v63 = (std::__shared_weak_count *)v5[1];
      BOOL v10 = (unint64_t *)(v8 + 16);
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
      unsigned int v12 = std::__shared_weak_count::lock(v63);
      __int16 v72 = v12;
      if (v12)
      {
        uint64_t v71 = v9;
        uint64_t v61 = v12;
        uint64_t v62 = v5;
        if (v9)
        {
          __int128 v69 = 0u;
          __int128 v70 = 0u;
          __int128 v67 = 0u;
          __int128 v68 = 0u;
          id obj = *(id *)(v9 + 160);
          id v13 = [obj countByEnumeratingWithState:&v67 objects:v81 count:16];
          if (v13)
          {
            uint64_t v66 = *(void *)v68;
            do
            {
              id v14 = 0LL;
              do
              {
                if (*(void *)v68 != v66) {
                  objc_enumerationMutation(obj);
                }
                unsigned int v15 = *(const __CFString **)(*((void *)&v67 + 1) + 8LL * (void)v14);
                id v16 = [*(id *)(v9 + 160) objectForKeyedSubscript:v15];
                if ([v16 dirty])
                {
                  if (!*(void *)(v9 + 24)) {
                    sub_1007165A8(a1, 0LL);
                  }
                  if (*(int *)(a1 + 52) >= 10 && *(_BYTE *)(v9 + 40))
                  {
                    char v7 = 1;
                  }

                  else
                  {
                    uint64_t v17 = *(__IOHIDServiceClient **)(v9 + 24);
                    if (v17)
                    {
                      id v18 = [v16 value];
                      objc_msgSend(v16, "setDirty:", !sub_1007179F8((uint64_t)v18, v17, v15, v18));
                      if ((v7 & 1) != 0) {
                        unsigned int v19 = [v16 dirty] ^ 1;
                      }
                      else {
                        unsigned int v19 = 0;
                      }
                      if (qword_1019344B0 != -1) {
                        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                      }
                      uint64_t v23 = (os_log_s *)p_vtable[151];
                      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                      {
                        int v25 = *(_DWORD *)(v9 + 16);
                        int v24 = *(_DWORD *)(v9 + 20);
                        id v26 = [v16 value];
                        unsigned int v27 = [v16 dirty];
                        *(_DWORD *)__int128 buf = 67241218;
                        uint64_t v28 = "successfully";
                        if (v27) {
                          uint64_t v28 = "unsuccessfully";
                        }
                        *(_DWORD *)uint64_t v83 = v24;
                        *(_WORD *)&v83[4] = 1026;
                        *(_DWORD *)&v83[6] = v25;
                        __int16 v84 = 2114;
                        unint64_t v85 = v15;
                        __int16 v86 = 2114;
                        id v87 = v26;
                        __int16 v88 = 2082;
                        double v89 = v28;
                        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Property for usage pair {%{public}d, %{public}d}: {%{public}@ = %{public}@} was set %{public}s",  buf,  0x2Cu);
                        a1 = v64;
                        p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
                      }

                      char v7 = v19;
                      if (sub_1002921D0(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        HIDWORD(v59) = v19;
                        if (qword_1019344B0 != -1) {
                          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                        }
                        uint64_t v29 = p_vtable[151];
                        int v31 = *(_DWORD *)(v9 + 16);
                        int v30 = *(_DWORD *)(v9 + 20);
                        id v32 = [v16 value];
                        unsigned int v33 = [v16 dirty];
                        int v73 = 67241218;
                        __int16 v34 = "successfully";
                        if (v33) {
                          __int16 v34 = "unsuccessfully";
                        }
                        *(_DWORD *)__int16 v74 = v30;
                        *(_WORD *)&v74[4] = 1026;
                        *(_DWORD *)&v74[6] = v31;
                        __int16 v75 = 2114;
                        __int16 v76 = v15;
                        __int16 v77 = 2114;
                        id v78 = v32;
                        __int16 v79 = 2082;
                        double v80 = v34;
                        LODWORD(v59) = 44;
                        int v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v29,  0LL,  "[CLIoHidInterface] Property for usage pair {%{public}d, %{public}d}: {%{public}@ = %{public}@} was set %{public}s",  &v73,  v59);
                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::applyAllDirtyDeviceProperties()",  "%s\n",  v35);
                        a1 = v64;
                        p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
                        char v7 = BYTE4(v58);
                      }
                    }

                    else
                    {
                      if (qword_1019344B0 != -1) {
                        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                      }
                      __int128 v20 = (os_log_s *)p_vtable[151];
                      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                      {
                        int v22 = *(_DWORD *)(v9 + 16);
                        int v21 = *(_DWORD *)(v9 + 20);
                        *(_DWORD *)__int128 buf = 67240448;
                        *(_DWORD *)uint64_t v83 = v21;
                        *(_WORD *)&v83[4] = 1026;
                        *(_DWORD *)&v83[6] = v22;
                        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Service for device with usage pair {%{public}d, %{public}d} is not ready",  buf,  0xEu);
                      }

                      if (sub_1002921D0(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_1019344B0 != -1) {
                          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                        }
                        __int16 v36 = p_vtable[151];
                        int v38 = *(_DWORD *)(v9 + 16);
                        int v37 = *(_DWORD *)(v9 + 20);
                        int v73 = 67240448;
                        *(_DWORD *)__int16 v74 = v37;
                        *(_WORD *)&v74[4] = 1026;
                        *(_DWORD *)&v74[6] = v38;
                        LODWORD(v5_Block_object_dispose(va, 8) = 14;
                        unsigned int v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  0LL,  "[CLIoHidInterface] Service for device with usage pair {%{public}d, %{public}d} is not ready",  &v73,  v58);
                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::applyAllDirtyDeviceProperties()",  "%s\n",  v39);
                      }

                      char v7 = 0;
                    }
                  }
                }

                id v14 = (char *)v14 + 1;
              }

              while (v13 != v14);
              id v40 = [obj countByEnumeratingWithState:&v67 objects:v81 count:16];
              id v13 = v40;
            }

            while (v40);
          }
        }

        p_shared_owners = (unint64_t *)&v61->__shared_owners_;
        do
          unint64_t v42 = __ldaxr(p_shared_owners);
        while (__stlxr(v42 - 1, p_shared_owners));
        id v5 = v62;
        uint64_t v6 = v60;
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }

      std::__shared_weak_count::__release_weak(v63);
    }

    v5 += 2;
  }

  while (v5 != v6);
  if ((v7 & 1) != 0)
  {
LABEL_61:
    *(_DWORD *)(a1 + 52) = 0;
LABEL_62:
    double v43 = 1.79769313e308;
    goto LABEL_63;
  }

  int v44 = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 52) = v44 + 1;
  if (v44 <= 4)
  {
    double v45 = CFAbsoluteTimeGetCurrent();
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    __int16 v46 = (os_log_s *)p_vtable[151];
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134349056;
      *(void *)uint64_t v83 = 0x3FD0000000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now",  buf,  0xCu);
    }

    BOOL v47 = sub_1002921D0(115, 2);
    double v43 = v45 + 0.25;
    if (v47)
    {
      double v48 = v45 + 0.25;
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      int v73 = 134349056;
      *(void *)__int16 v74 = 0x3FD0000000000000LL;
      LODWORD(v5_Block_object_dispose(va, 8) = 12;
      __int16 v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now",  &v73,  v58);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::applyAllDirtyDeviceProperties()", "%s\n", v49);
      a1 = v64;
      double v43 = v48;
    }

    goto LABEL_63;
  }

  if (v44 > 9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v55 = (os_log_s *)p_vtable[151];
    if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_FAULT,  "[CLIoHidInterface] Could not set all properties after too many retries. Giving up.",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_62;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    LOWORD(v73) = 0;
    LODWORD(v5_Block_object_dispose(va, 8) = 2;
    int v56 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "[CLIoHidInterface] Could not set all properties after too many retries. Giving up.",  &v73,  v58);
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLIoHidInterface::applyAllDirtyDeviceProperties()", "%s\n", v56);
    double v43 = 1.79769313e308;
LABEL_96:
    a1 = v64;
    goto LABEL_63;
  }

  double v50 = CFAbsoluteTimeGetCurrent();
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  __int128 v51 = (os_log_s *)p_vtable[151];
  if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 134349056;
    *(void *)uint64_t v83 = 0x4004000000000000LL;
    _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_INFO,  "[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now",  buf,  0xCu);
  }

  BOOL v52 = sub_1002921D0(115, 2);
  double v43 = v50 + 2.5;
  if (v52)
  {
    double v53 = v50 + 2.5;
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v73 = 134349056;
    *(void *)__int16 v74 = 0x4004000000000000LL;
    LODWORD(v5_Block_object_dispose(va, 8) = 12;
    __int16 v54 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now",  &v73,  v58);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::applyAllDirtyDeviceProperties()", "%s\n", v54);
    double v43 = v53;
    goto LABEL_96;
  }

void sub_100718884( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1007188C4(uint64_t a1, uint64_t a2, __IOHIDServiceClient *a3, uint64_t a4)
{
  if (a3)
  {
    int Type = IOHIDEventGetType(a4);
    if (Type)
    {
      uint64_t v9 = *(uint64_t **)(a1 + 8);
      BOOL v10 = *(uint64_t **)(a1 + 16);
      if (v9 != v10)
      {
        int v11 = Type;
        do
        {
          unsigned int v12 = (std::__shared_weak_count *)v9[1];
          if (v12)
          {
            uint64_t v13 = *v9;
            p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
            do
              unint64_t v15 = __ldxr(p_shared_weak_owners);
            while (__stxr(v15 + 1, p_shared_weak_owners));
            id v16 = std::__shared_weak_count::lock(v12);
            *(void *)&uint8_t buf[8] = v16;
            if (v16)
            {
              uint64_t v17 = v16;
              *(void *)__int128 buf = v13;
              if (v13)
              {
                id v18 = *(void (**)(void, uint64_t, __IOHIDServiceClient *, uint64_t))(v13 + 48);
                if (v18)
                {
                  if (*(__IOHIDServiceClient **)(v13 + 24) == a3 || (int v19 = *(_DWORD *)(v13 + 144)) != 0 && v19 == v11) {
                    v18(*(void *)(v13 + 56), a2, a3, a4);
                  }
                }
              }

              p_shared_owners = (unint64_t *)&v17->__shared_owners_;
              do
                unint64_t v21 = __ldaxr(p_shared_owners);
              while (__stlxr(v21 - 1, p_shared_owners));
              if (!v21)
              {
                ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
                std::__shared_weak_count::__release_weak(v17);
              }
            }

            std::__shared_weak_count::__release_weak(v12);
          }

          v9 += 2;
        }

        while (v9 != v10);
      }
    }

    else
    {
      RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(a3);
      CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      int v24 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 134283777;
        *(void *)&uint8_t buf[4] = a3;
        *(_WORD *)&_BYTE buf[12] = 2050;
        *(void *)&buf[14] = valuePtr;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "[CLIoHidInterface] Got null event,sender %{private}p,registryID %{public}llx",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        *(_DWORD *)double v48 = 134283777;
        *(void *)&v48[4] = a3;
        *(_WORD *)&v48[12] = 2050;
        *(void *)&v48[14] = valuePtr;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "[CLIoHidInterface] Got null event,sender %{private}p,registryID %{public}llx",  v48,  22);
        int v44 = (char *)v43;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)",  "%s\n",  v43);
        if (v44 != buf) {
          free(v44);
        }
      }

      id v26 = *(uint64_t **)(a1 + 8);
      for (uint64_t i = *(uint64_t **)(a1 + 16); v26 != i; v26 += 2)
      {
        unsigned int v27 = (std::__shared_weak_count *)v26[1];
        if (v27)
        {
          uint64_t v28 = *v26;
          uint64_t v29 = (unint64_t *)&v27->__shared_weak_owners_;
          do
            unint64_t v30 = __ldxr(v29);
          while (__stxr(v30 + 1, v29));
          int v31 = std::__shared_weak_count::lock(v27);
          *(void *)&v48[8] = v31;
          if (v31)
          {
            id v32 = v31;
            *(void *)double v48 = v28;
            if (v28)
            {
              if (*(void *)(v28 + 8) == valuePtr && *(void *)(v28 + 128))
              {
                if (qword_1019344B0 != -1) {
                  dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                }
                unsigned int v33 = (os_log_s *)qword_1019344B8;
                if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)__int128 buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Fetching historical events",  buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1019344B0 != -1) {
                    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                  }
                  __int16 v46 = 0;
                  LODWORD(v45) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Fetching historical events",  &v46,  v45);
                  id v40 = (char *)v39;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)",  "%s\n",  v39);
                  if (v40 != buf) {
                    free(v40);
                  }
                }

                (*(void (**)(void))(v28 + 128))(*(void *)(v28 + 136));
              }

              else
              {
                if (qword_1019344B0 != -1) {
                  dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                }
                __int16 v34 = (os_log_s *)qword_1019344B8;
                if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)__int128 buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Did not fetch historical events",  buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1019344B0 != -1) {
                    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
                  }
                  __int16 v46 = 0;
                  LODWORD(v45) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Did not fetch historical events",  &v46,  v45);
                  int v38 = (char *)v37;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)",  "%s\n",  v37);
                  if (v38 != buf) {
                    free(v38);
                  }
                }
              }
            }

            int v35 = (unint64_t *)&v32->__shared_owners_;
            do
              unint64_t v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
          }

          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v22 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] Received null sender",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      *(_WORD *)double v48 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] Received null sender",  v48,  2);
      unint64_t v42 = (char *)v41;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)",  "%s\n",  v41);
      if (v42 != buf) {
        free(v42);
      }
    }
  }

void sub_100718FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100719008(uint64_t a1)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
  }
  uint64_t v2 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] It looks like our HID event system just become available (again)",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] It looks like our HID event system just become available (again)",  v7,  2);
    id v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLIoHidInterface::onEventSystemReset(void *)", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  uint64_t v3 = sub_1006E27E8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1007191D4;
  void v6[3] = &unk_10181D3D0;
  v6[4] = a1;
  sub_1006E2970(v3, (uint64_t)v6);
}

void sub_1007191D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1007165A8(v1, 0LL);
  uint64_t v2 = *(uint64_t **)(v1 + 8);
  uint64_t v3 = *(uint64_t **)(v1 + 16);
  while (v2 != v3)
  {
    int v4 = (std::__shared_weak_count *)v2[1];
    if (v4)
    {
      uint64_t v5 = *v2;
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_weak_owners);
      while (__stxr(v7 + 1, p_shared_weak_owners));
      uint64_t v8 = std::__shared_weak_count::lock(v4);
      if (v8)
      {
        uint64_t v9 = v8;
        if (v5)
        {
          BOOL v10 = *(void (**)(void))(v5 + 96);
          if (v10) {
            v10(*(void *)(v5 + 104));
          }
        }

        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          unint64_t v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }

      std::__shared_weak_count::__release_weak(v4);
    }

    v2 += 2;
  }

void sub_1007192AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1007192C8(uint64_t a1, char *a2, __IOHIDServiceClient *a3)
{
  if (a2 == "ADDED")
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v6 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(a3, @"PrimaryUsagePage"),  "intValue");
      unsigned int v7 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(a3, @"PrimaryUsage"),  "intValue");
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      uint64_t v8 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 67240448;
        *(_DWORD *)&uint8_t buf[4] = v6;
        LOWORD(v25) = 1026;
        *(_DWORD *)((char *)&v25 + 2) = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "[CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%{public}d, %{public}d} just became available.",  buf,  0xEu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        v21[0] = 67240448;
        v21[1] = v6;
        __int16 v22 = 1026;
        unsigned int v23 = v7;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "[CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%{public}d, %{public}d} just became available.",  v21,  14);
        __int128 v20 = (uint8_t *)v19;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onServiceRegistration(void *, IOHIDServiceClientRef)",  "%s\n",  v19);
        if (v20 != buf) {
          free(v20);
        }
      }
    }

    uint64_t v9 = *(uint64_t **)(a1 + 8);
    for (uint64_t i = *(uint64_t **)(a1 + 16); v9 != i; v9 += 2)
    {
      int v11 = (std::__shared_weak_count *)v9[1];
      if (v11)
      {
        uint64_t v12 = *v9;
        p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
        do
          unint64_t v14 = __ldxr(p_shared_weak_owners);
        while (__stxr(v14 + 1, p_shared_weak_owners));
        unint64_t v15 = std::__shared_weak_count::lock(v11);
        int v25 = v15;
        if (v15)
        {
          id v16 = v15;
          *(void *)__int128 buf = v12;
          if (v12)
          {
            if ((sub_100716B44(v12, a3) & 1) != 0)
            {
              sub_100716B88(v12, a3, 1);
              if (*(void *)(v12 + 80)) {
                IOHIDServiceClientRegisterRemovalCallback(a3, sub_100717180, a1, "REMOVED");
              }
            }
          }

          p_shared_owners = (unint64_t *)&v16->__shared_owners_;
          do
            unint64_t v18 = __ldaxr(p_shared_owners);
          while (__stlxr(v18 - 1, p_shared_owners));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }

        std::__shared_weak_count::__release_weak(v11);
      }
    }

    objc_autoreleasePoolPop(v5);
  }

void sub_100719600( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void sub_100719624(uint64_t a1, char *a2, __IOHIDServiceClient *a3)
{
  if (a2 == "REMOVED")
  {
    CFRunLoopTimerContext context = objc_autoreleasePoolPush();
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v5 = *(uint64_t **)(a1 + 16);
    if (v6 != v5)
    {
      while (1)
      {
        unsigned int v7 = (std::__shared_weak_count *)v6[1];
        if (v7) {
          break;
        }
LABEL_34:
        v6 += 2;
        if (v6 == v5) {
          goto LABEL_45;
        }
      }

      uint64_t v8 = *v6;
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        unint64_t v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      int v11 = std::__shared_weak_count::lock(v7);
      if (!v11)
      {
LABEL_33:
        std::__shared_weak_count::__release_weak(v7);
        goto LABEL_34;
      }

      uint64_t v12 = v11;
      if (v8 && *(void *)(v8 + 80) && (__IOHIDServiceClient *)sub_100719C6C(v8) == a3)
      {
        unsigned int v13 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(a3, @"PrimaryUsagePage"),  "intValue");
        unsigned int v14 = objc_msgSend( (id)(id)IOHIDServiceClientCopyProperty(a3, @"PrimaryUsage"),  "intValue");
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        unint64_t v15 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = *(void *)(v8 + 152);
          *(_DWORD *)__int128 buf = 134284291;
          uint64_t v43 = (uint64_t)a3;
          __int16 v44 = 1026;
          unsigned int v45 = v13;
          __int16 v46 = 1026;
          unsigned int v47 = v14;
          __int16 v48 = 2113;
          uint64_t v49 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] onServiceRemoval - IOHIDServiceClientRef for service %{private}p with usage pair {%{publi c}d, %{public}d} and property %{private}@ will be removed.",  buf,  0x22u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          uint64_t v28 = *(void *)(v8 + 152);
          int v34 = 134284291;
          uint64_t v35 = (uint64_t)a3;
          __int16 v36 = 1026;
          unsigned int v37 = v13;
          __int16 v38 = 1026;
          unsigned int v39 = v14;
          __int16 v40 = 2113;
          uint64_t v41 = v28;
          LODWORD(v32) = 34;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] onServiceRemoval - IOHIDServiceClientRef for service %{private}p with usage pair {%{publi c}d, %{public}d} and property %{private}@ will be removed.",  &v34,  v32);
          unint64_t v30 = (uint8_t *)v29;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)",  "%s\n",  v29);
          if (v30 != buf) {
            free(v30);
          }
        }

        (*(void (**)(void))(v8 + 80))(*(void *)(v8 + 88));
        sub_100717400(v8);
        sub_1007165A8(a1, a3);
        if (sub_100719C6C(v8))
        {
          sub_100717CF4(a1);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          uint64_t v17 = (os_log_s *)qword_1019344B8;
          if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v18 = sub_100719C6C(v8);
            uint64_t v19 = *(void *)(v8 + 152);
            *(_DWORD *)__int128 buf = 134284291;
            uint64_t v43 = v18;
            __int16 v44 = 1026;
            unsigned int v45 = v13;
            __int16 v46 = 1026;
            unsigned int v47 = v14;
            __int16 v48 = 2113;
            uint64_t v49 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] onServiceRemoval - successfully switch to service %{private}p with usage pair {%{public }d, %{public}d} and property %{private}@.",  buf,  0x22u);
          }

          if (!sub_1002921D0(115, 2)) {
            goto LABEL_29;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          uint64_t v20 = qword_1019344B8;
          uint64_t v21 = sub_100719C6C(v8);
          uint64_t v22 = *(void *)(v8 + 152);
          int v34 = 134284291;
          uint64_t v35 = v21;
          __int16 v36 = 1026;
          unsigned int v37 = v13;
          __int16 v38 = 1026;
          unsigned int v39 = v14;
          __int16 v40 = 2113;
          uint64_t v41 = v22;
          LODWORD(v32) = 34;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  0LL,  "[CLIoHidInterface] onServiceRemoval - successfully switch to service %{private}p with usage pair {%{public}d , %{public}d} and property %{private}@.",  &v34,  v32);
          int v24 = (uint8_t *)v23;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)",  "%s\n",  v23);
        }

        else
        {
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          int v25 = (os_log_s *)qword_1019344B8;
          if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] onServiceRemoval - no available alternatives",  buf,  2u);
          }

          if (!sub_1002921D0(115, 2)) {
            goto LABEL_29;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          LOWORD(v34) = 0;
          LODWORD(v32) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] onServiceRemoval - no available alternatives",  &v34,  v32);
          int v24 = (uint8_t *)v31;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)",  "%s\n",  v31);
        }

        if (v24 != buf) {
          free(v24);
        }
      }

void sub_100719C2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100719C6C(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4()) {
    return *(void *)(a1 + 24);
  }
  uint64_t v4 = sub_101247EA0();
  return sub_100719CA8(v4, v5, v6, v7, v8);
}

uint64_t sub_100719CA8(uint64_t a1, int a2, int a3, char a4, uint64_t a5)
{
  *(void *)a1 = off_10184D090;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + sub_100708348(v2 - 16) = a3;
  *(_DWORD *)(a1 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a2;
  *(void *)(a1 + sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a4;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_10000AE14(v2 - 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 144) = -1;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  return a1;
}

uint64_t sub_100719D0C(uint64_t a1)
{
  *(void *)a1 = off_10184D090;

  *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }

  *(void *)(a1 + 152) = 0LL;
  return a1;
}

void sub_100719D64(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100719D0C(a1);
  operator delete(v1);
}

void sub_100719D78(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_100715B28(a1[4]);
    BOOL v7 = a1[6] != 0;
    a1[6] = a2;
    a1[7] = a3;
    if ((((a2 == 0) ^ v7) & 1) == 0) {
      sub_100715EF4((void *)a1[4]);
    }
  }

  else
  {
    uint64_t v8 = sub_101248000(a1);
    sub_100719E00(v8);
  }

uint64_t sub_100719E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t result = sub_1006E2AB4();
  if (Current == (CFRunLoopRef)result)
  {
    *(void *)(a1 + 64) = a2;
    *(void *)(a1 + 72) = a3;
  }

  else
  {
    uint64_t v8 = sub_101248170(a1);
    return sub_100719E50(v8);
  }

  return result;
}

uint64_t sub_100719E50(void *a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    a1[10] = a2;
    a1[11] = a3;
    uint64_t result = a1[3];
    if (result) {
      return IOHIDServiceClientRegisterRemovalCallback(result, sub_100717180, a1[4], "REMOVED");
    }
  }

  else
  {
    uint64_t v8 = sub_1012482E0(a1);
    return sub_100719ECC(v8, v9, v10);
  }

  return result;
}

uint64_t sub_100719ECC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t result = sub_1006E2AB4();
  if (Current == (CFRunLoopRef)result)
  {
    *(void *)(a1 + 96) = a2;
    *(void *)(a1 + 104) = a3;
  }

  else
  {
    uint64_t v8 = sub_101248450(a1);
    return sub_100719F1C(v8);
  }

  return result;
}

void sub_100719F1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (void *)sub_1006E2AB4())
  {
    sub_1012485C0(a1);
LABEL_10:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    goto LABEL_5;
  }

  sub_100715B28(*(void *)(a1 + 32));
  if (a3)
  {
    objc_msgSend( *(id *)(a1 + 160),  "setObject:forKeyedSubscript:",   -[CLPropertyValue initWithValue:dirty:]( [CLPropertyValue alloc],  "initWithValue:dirty:",  a3,  1),  a2);
    goto LABEL_8;
  }

  CFRunLoopRef Current = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
    goto LABEL_10;
  }
LABEL_5:
  BOOL v7 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    uint64_t v13 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "[CLIoHidInterface] Could not set property value for %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (Current[150] != -1LL) {
      dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    }
    int v10 = 138543362;
    uint64_t v11 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "[CLIoHidInterface] Could not set property value for %{public}@",  &v10,  12);
    uint64_t v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLIoHidInterface::Device::setProperty(NSString *, id)",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

CFTypeRef sub_10071A130(uint64_t a1, const __CFString *a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    if (sub_10071A1A0(a1)) {
      return IOHIDServiceClientCopyProperty(*(IOHIDServiceClientRef *)(a1 + 24), a2);
    }
    else {
      return 0LL;
    }
  }

  else
  {
    uint64_t v6 = sub_101248730(a1);
    return (CFTypeRef)sub_10071A1A0(v6);
  }

BOOL sub_10071A1A0(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_1012488A0();
LABEL_16:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    goto LABEL_7;
  }

  sub_100715B28(*(void *)(a1 + 32));
  if (*(void *)(a1 + 24)) {
    return 1LL;
  }
  sub_1007165A8(*(void *)(a1 + 32), 0LL);
  if (*(void *)(a1 + 24)) {
    return 1LL;
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
    goto LABEL_16;
  }
LABEL_7:
  int v5 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 16);
    int v6 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)__int128 buf = 67240448;
    int v15 = v6;
    __int16 v16 = 1026;
    int v17 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Service for usage pair {%{public}d, %{public}d} is not ready",  buf,  0xEu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    int v9 = *(_DWORD *)(a1 + 16);
    int v8 = *(_DWORD *)(a1 + 20);
    v11[0] = 67240448;
    v11[1] = v8;
    __int16 v12 = 1026;
    int v13 = v9;
    int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Service for usage pair {%{public}d, %{public}d} is not ready",  v11,  14);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLIoHidInterface::Device::initializeServiceRef()", "%s\n", v10);
    return 0LL;
  }

  return result;
}

void sub_10071A3B0(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current == (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_100715B28(*(void *)(a1 + 32));
    uint64_t v4 = *(unsigned int *)(a1 + 144);
    if ((_DWORD)v4)
    {
      IOHIDServiceClientCopyEvent(*(void *)(a1 + 24), v4, 0LL, 0LL);
      return;
    }
  }

  else
  {
    uint64_t v3 = sub_101248B60();
  }

  uint64_t v5 = sub_101248A00(v3);
  sub_10071A408(v5, v6, v7);
}

void sub_10071A408(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4())
  {
    sub_101248CC0(a1);
LABEL_13:
    dispatch_once(&qword_1019344B0, &stru_10184D0D8);
    goto LABEL_5;
  }

  if (*(void *)(a1 + 112) == a2 && *(void *)(a1 + 120) == a3) {
    return;
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
    goto LABEL_13;
  }
LABEL_5:
  int v8 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
  {
    int v9 = "Opening";
    if (!*(void *)(a1 + 112)) {
      int v9 = "Closing";
    }
    int v11 = *(_DWORD *)(a1 + 16);
    int v10 = *(_DWORD *)(a1 + 20);
    uint64_t v12 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 buf = 136446979;
    unint64_t v27 = v9;
    __int16 v28 = 1026;
    int v29 = v10;
    __int16 v30 = 1026;
    int v31 = v11;
    __int16 v32 = 2049;
    uint64_t v33 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "%{public}s hid driver interface for usage pair {%{public}d, %{public}d}, hidServiceRef %{private}p",  buf,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v13 = "Opening";
    if (!*(void *)(a1 + 112)) {
      int v13 = "Closing";
    }
    int v15 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    uint64_t v16 = *(void *)(a1 + 24);
    int v18 = 136446979;
    uint64_t v19 = v13;
    __int16 v20 = 1026;
    int v21 = v14;
    __int16 v22 = 1026;
    int v23 = v15;
    __int16 v24 = 2049;
    uint64_t v25 = v16;
    int v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "%{public}s hid driver interface for usage pair {%{public}d, %{public}d}, hidServiceRef %{private}p",  &v18,  34);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::Device::setRegistryIDChangedCallback(OnRegistryIDChanged, void *)",  "%s\n",  v17);
  }

  *(void *)(a1 + sub_10000AE14(v2 - 112) = a2;
  *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a3;
}

uint64_t sub_10071A684(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t result = sub_1006E2AB4();
  if (Current == (CFRunLoopRef)result)
  {
    BOOL v8 = a2 != 0;
    BOOL v9 = a3 != 0;
    BOOL v10 = !v8 || !v9;
    if (v8 && v9) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = 0LL;
    }
    if (v10) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = a3;
    }
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = v11;
    *(void *)(a1 + 136) = v12;
  }

  else
  {
    uint64_t v13 = sub_101248E30(a1);
    return sub_10071A6F0(v13);
  }

  return result;
}

uint64_t sub_10071A6F0(uint64_t a1, int a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t result = sub_1006E2AB4();
  if (Current == (CFRunLoopRef)result)
  {
    *(_DWORD *)(a1 + 144) = a2;
  }

  else
  {
    uint64_t v6 = sub_101248FA0(a1);
    return sub_10071A73C(v6, v7);
  }

  return result;
}

uint64_t sub_10071A73C(uint64_t a1, double a2)
{
  double v2 = rint(a2 * 1000000.0);
  if (a2 < 0.0) {
    uint64_t v3 = 0LL;
  }
  else {
    uint64_t v3 = (uint64_t)v2;
  }
  return sub_10071A75C(a1, v3);
}

uint64_t sub_10071A75C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", a2);
  (*(void (**)(uint64_t, const __CFString *, NSNumber *))(*(void *)a1 + 16LL))( a1,  @"ReportInterval",  v4);

  return a2;
}

uint64_t sub_10071A7C0(uint64_t a1, double a2)
{
  uint64_t v3 = (uint64_t)rint(a2 * 1000000.0);
  if (v3 >= 1000000) {
    uint64_t v3 = 1000000LL;
  }
  if (v3 <= 10000) {
    uint64_t v4 = 10000LL;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t v5 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", v4);
  (*(void (**)(uint64_t, const __CFString *, NSNumber *))(*(void *)a1 + 16LL))( a1,  @"BatchInterval",  v5);

  return v4;
}

void sub_10071A850(uint64_t a1, void *a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (void *)sub_1006E2AB4())
  {
    sub_101249110();
    goto LABEL_33;
  }

  if ([a2 isEqualToDictionary:*(void *)(a1 + 152)])
  {
    CFRunLoopRef Current = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019344B0 == -1)
    {
LABEL_4:
      uint64_t v5 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 152);
        *(_DWORD *)__int128 buf = 138477827;
        uint64_t v30 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] setMatchingProperties - Early return for identical properties %{private}@",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (Current[150] != -1LL) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        uint64_t v7 = *(void *)(a1 + 152);
        int v25 = 138477827;
        uint64_t v26 = v7;
        BOOL v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] setMatchingProperties - Early return for identical properties %{private}@",  &v25,  12);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLIoHidInterface::Device::setMatchingProperties(NSDictionary<NSString *,id> *)",  "%s\n",  v8);
      }

      return;
    }

BOOL sub_10071AE74(__IOHIDServiceClient *a1, void *a2)
{
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v4 = [a2 countByEnumeratingWithState:&v20 objects:v36 count:16];
  if (!v4) {
    return 1LL;
  }
  id v5 = v4;
  uint64_t v6 = *(void *)v21;
  while (2)
  {
    for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v21 != v6) {
        objc_enumerationMutation(a2);
      }
      BOOL v8 = *(const __CFString **)(*((void *)&v20 + 1) + 8LL * (void)i);
      id v9 = [a2 objectForKeyedSubscript:v8];
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D0D8);
      }
      BOOL v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543875;
        __int16 v31 = v8;
        __int16 v32 = 2113;
        id v33 = v9;
        __int16 v34 = 2049;
        uint64_t v35 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Checking matching property %{public}@ = %{private}@ for service ref %{private}p",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        int v24 = 138543875;
        int v25 = v8;
        __int16 v26 = 2113;
        id v27 = v9;
        __int16 v28 = 2049;
        int v29 = a1;
        LODWORD(v19) = 32;
        uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Checking matching property %{public}@ = %{private}@ for service ref %{private}p",  &v24,  v19);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)",  "%s\n",  v13);
      }

      CFTypeRef v11 = IOHIDServiceClientCopyProperty(a1, v8);
      if (!v11)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        int v15 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543875;
          __int16 v31 = v8;
          __int16 v32 = 2114;
          id v33 = v9;
          __int16 v34 = 2049;
          uint64_t v35 = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Invalid matching property %{public}@ = %{public}@ for service ref %{private}p",  buf,  0x20u);
        }

        BOOL result = sub_1002921D0(115, 2);
        if (!result) {
          return result;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        int v24 = 138543875;
        int v25 = v8;
        __int16 v26 = 2114;
        id v27 = v9;
        __int16 v28 = 2049;
        int v29 = a1;
        LODWORD(v19) = 32;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Invalid matching property %{public}@ = %{public}@ for service ref %{private}p",  &v24,  v19);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)",  "%s\n",  v16);
        return 0LL;
      }

      uint64_t v12 = (void *)v11;
      if (!CFEqual(v11, v9))
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10184D0D8);
        }
        uint64_t v17 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543875;
          __int16 v31 = v8;
          __int16 v32 = 2114;
          id v33 = v12;
          __int16 v34 = 2049;
          uint64_t v35 = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "[CLIoHidInterface] Property mismatch! %{public}@ = %{public}@ for service ref %{private}p",  buf,  0x20u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10184D0D8);
          }
          int v24 = 138543875;
          int v25 = v8;
          __int16 v26 = 2114;
          id v27 = v12;
          __int16 v28 = 2049;
          int v29 = a1;
          LODWORD(v19) = 32;
          uint64_t v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "[CLIoHidInterface] Property mismatch! %{public}@ = %{public}@ for service ref %{private}p",  &v24,  v19);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)",  "%s\n",  v18);
        }

        CFRelease(v12);
        return 0LL;
      }

      CFRelease(v12);
    }

    id v5 = [a2 countByEnumeratingWithState:&v20 objects:v36 count:16];
    BOOL result = 1LL;
    if (v5) {
      continue;
    }
    break;
  }

  return result;
}

void sub_10071B408(uint64_t a1)
{
  *(void *)(a1 + 152) = 0LL;
}

uint64_t sub_10071B430(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  double v2 = *(uint64_t (**)(void))(v1 + 64);
  if (v2) {
    return v2(*(void *)(v1 + 72));
  }
  return result;
}

void sub_10071B448(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_10071B474(void ***a1)
{
  double v2 = *a1;
  if (*v2)
  {
    sub_10071B4B4((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_10071B4B4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16LL)
  {
    id v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  a1[1] = v2;
}

uint64_t sub_10071B4FC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10071B570((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10071B570(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _DWORD v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      __int128 v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0LL;
      a3[1] = 0LL;
      *((void *)&v15 + 1) = v8;
      v7 -= 16LL;
      --v8;
    }

    while (a3 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  sub_10071B600((uint64_t)v12);
  return v10;
}

uint64_t sub_10071B600(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10071B634(a1);
  }
  return a1;
}

void sub_10071B634(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    v1 += 16LL;
  }

void **sub_10071B674(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10071B6A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + sub_100708348(v2 - 16) = v1 - 16;
    id v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }

    else
    {
      v1 -= 16LL;
    }
  }

void sub_10071B734( void *a1, int a2, int a3, int a4, const char *a5, const char *a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

void sub_10071B754( void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

void sub_10071B768( void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

void sub_10071B77C(uint64_t a1@<X8>)
{
  *(void *)(v1 - 72) = a1;
}

void sub_10071BD38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10071C210(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_10071C23C(id a1)
{
  byte_101998390 = 1;
}

void sub_10071C24C(uint64_t a1)
{
  uint64_t v2 = sub_100749340(a1);
  *(void *)uint64_t v2 = off_10184D148;
  *(_DWORD *)(v2 + 132) = 0;
  *(_BYTE *)(v2 + 136) = 1;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v2 + 169) = 0u;
  *(_OWORD *)(v2 + 192) = 0u;
  *(_OWORD *)(v2 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v2 + 2sub_10000AE14(v9 + 24) = 0u;
  *(_OWORD *)(v2 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v2 + 256) = xmmword_1012E0070;
  *(_BYTE *)(v2 + 272) = 0;
  *(void *)(v2 + 284) = 0LL;
  *(void *)(v2 + 276) = 0LL;
  *(_DWORD *)(v2 + 292) = 0;
  if ((sub_1004F97F4() & 0x10) != 0)
  {
    uint64_t v3 = (void *)sub_1006E2838();
    sub_10043AC3C((uint64_t)sub_10071C3D0, a1, v3, &v7);
    uint64_t v4 = v7;
    uint64_t v7 = 0LL;
    uint64_t v5 = *(void *)(a1 + 288);
    *(void *)(a1 + 28_Block_object_dispose(va, 8) = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      uint64_t v6 = v7;
      uint64_t v7 = 0LL;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
    }
  }

  else
  {
    sub_10124943C();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Motion/Notifiers/Compass/CLCompass7.mm",  56,  "CLCompass7");
    __break(1u);
  }

void sub_10071C36C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 288);
  *(void *)(v1 + 28_Block_object_dispose(va, 8) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_10000AE14(v1 + 168);
  sub_10000AE14(v1 + 152);
  uint64_t v5 = *v2;
  *uint64_t v2 = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_10074A2B0(v1);
  _Unwind_Resume(a1);
}

void sub_10071C3D0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
}

void *sub_10071C410(void *a1)
{
  *a1 = off_10184D148;
  sub_10071C484((uint64_t)a1);
  uint64_t v2 = a1[36];
  a1[36] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_10000AE14((uint64_t)(a1 + 21));
  sub_10000AE14((uint64_t)(a1 + 19));
  uint64_t v3 = a1[18];
  a1[18] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return sub_10074A2B0((uint64_t)a1);
}

void sub_10071C484(uint64_t a1)
{
  uint64_t v2 = *(__CFRunLoopTimer **)(a1 + 192);
  if (v2)
  {
    CFRunLoopTimerInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 192));
    *(void *)(a1 + 192) = 0LL;
  }

void sub_10071C4BC(void *a1)
{
  uint64_t v1 = sub_10071C410(a1);
  operator delete(v1);
}

unint64_t sub_10071C4D0()
{
  if ((sub_1004F97F4() & 0x20) != 0) {
    return 1LL;
  }
  else {
    return ((unint64_t)sub_1004F97F4() >> 4) & 1;
  }
}

uint64_t sub_10071C4F8(uint64_t result, double *a2)
{
  double v2 = a2[7];
  if (v2 == -1.0)
  {
    uint64_t v6 = 0LL;
    __int128 v4 = 0u;
    __int128 v5 = 0u;
    __int128 v3 = 0u;
    double v2 = -1.0;
  }

  else
  {
    __int128 v3 = *(_OWORD *)a2;
    __int128 v4 = *((_OWORD *)a2 + 1);
    __int128 v5 = *((_OWORD *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 6);
  }

  *(_OWORD *)(result + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v3;
  *(_OWORD *)(result + 2sub_100708348(v2 - 16) = v4;
  *(_OWORD *)(result + 232) = v5;
  *(void *)(result + 24_Block_object_dispose(va, 8) = v6;
  *(double *)(result + 256) = v2;
  return result;
}

id sub_10071C564(uint64_t a1, int a2)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184D1B0);
  }
  __int128 v4 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67240192;
    int v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Compass for AOP started. CoverAttached %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    v8[0] = 67240192;
    v8[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  0LL,  "Compass for AOP started. CoverAttached %{public}d",  v8,  8);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLCompass7::start(BOOL)", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  *(_BYTE *)(a1 + 272) = a2;
  return [*(id *)(*(void *)(a1 + 288) + 16) register:*(void *)(*(void *)(a1 + 288) + 8) forNotification:31 registrationInfo:0];
}

id sub_10071C728(uint64_t a1)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184D1B0);
  }
  double v2 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Compass for AOP stopped.", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  0LL,  "Compass for AOP stopped.",  v6,  2);
    __int128 v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLCompass7::stop()", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return [*(id *)(*(void *)(a1 + 288) + 16) unregister:*(void *)(*(void *)(a1 + 288) + 8) forNotification:31];
}

double sub_10071C8C8(uint64_t a1, int a2, double *a3)
{
  if (!a2)
  {
    if (*a3 <= 0.0)
    {
      if (*(_BYTE *)(a1 + 184)) {
        sub_10071C94C(a1);
      }
      if (*(void *)(a1 + 192)) {
        uint64_t v7 = (double *)&unk_101328208;
      }
      else {
        uint64_t v7 = a3;
      }
      uint64_t v6 = a1;
    }

    else
    {
      uint64_t v6 = a1;
      uint64_t v7 = a3;
    }

    sub_10071CCAC(v6, v7);
  }

  *(double *)(a1 + 264) = *a3;
  return *a3;
}

void sub_10071C94C(uint64_t a1)
{
  *(_BYTE *)(a1 + 184) = 0;
  sub_10071C484(a1);
  context.version = 0LL;
  context.info = (void *)a1;
  memset(&context.retain, 0, 24);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFRunLoopTimerRef v3 = CFRunLoopTimerCreate( kCFAllocatorDefault,  Current + 600.0,  0.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)sub_10071D230,  &context);
  *(void *)(a1 + 192) = v3;
  if (v3)
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    __int128 v4 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134349056;
      uint64_t v15 = 0x4082C00000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Keeping compass on for %{public}.0f seconds",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184D1B0);
      }
      int v12 = 134349056;
      uint64_t v13 = 0x4082C00000000000LL;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Keeping compass on for %{public}.0f seconds",  &v12,  12);
      uint64_t v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompass7::startTurnOffTimer()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    sub_1006E27E8();
    __int128 v5 = (__CFRunLoop *)sub_1006E2AB4();
    CFRunLoopAddTimer(v5, *(CFRunLoopTimerRef *)(a1 + 192), kCFRunLoopCommonModes);
  }

  else
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    uint64_t v6 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Could not create turn-off timer", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184D1B0);
      }
      LOWORD(v12) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not create turn-off timer",  &v12,  2);
      int v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLCompass7::startTurnOffTimer()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    sub_10071CCAC(a1, (double *)(a1 + 264));
  }

uint64_t sub_10071CCAC(uint64_t a1, double *a2)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184D1B0);
  }
  __int128 v4 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEFAULT))
  {
    double v5 = *a2;
    *(_DWORD *)__int128 buf = 134349056;
    *(double *)&uint8_t buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Setting compass update interval to %{public}f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    uint64_t v16 = *(void *)a2;
    int v21 = 134349056;
    uint64_t v22 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  0LL,  "Setting compass update interval to %{public}f",  &v21,  12);
    uint64_t v18 = (uint8_t *)v17;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCompass7::setDeviceMotionServiceUpdateInterval(const CFTimeInterval &)",  "%s\n",  v17);
    if (v18 != buf) {
      free(v18);
    }
  }

  if (*(_BYTE *)(a1 + 136))
  {
    char v6 = sub_1004F97F4();
    uint64_t v7 = (uint64_t *)(a1 + 168);
    if ((v6 & 0x20) != 0) {
      uint64_t v8 = (uint64_t **)(a1 + 168);
    }
    else {
      uint64_t v8 = (uint64_t **)(a1 + 152);
    }
    if ((v6 & 0x20) != 0) {
      int v9 = 8;
    }
    else {
      int v9 = 4;
    }
    if ((v6 & 0x20) != 0) {
      uint64_t v7 = (uint64_t *)(a1 + 152);
    }
  }

  else
  {
    uint64_t v7 = (uint64_t *)(a1 + 168);
    uint64_t v8 = (uint64_t **)(a1 + 152);
    int v9 = 4;
  }

  if (*v7) {
    sub_10071A73C(*v7, 0.0);
  }
  int v10 = *v8;
  if (!*v8)
  {
    CFTypeRef v11 = (uint64_t *)sub_10071542C();
    v19[0] = 65292;
    v19[1] = v9;
    char v20 = 0;
    sub_10121B774(v11, (uint64_t)v19, (uint64_t *)buf);
    sub_10005F550((uint64_t)v8, (__int128 *)buf);
    int v12 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    sub_100719D78(*v8, (uint64_t)sub_10071D060, a1);
    int v10 = *v8;
  }

  return sub_10071A73C((uint64_t)v10, *a2);
}

uint64_t sub_10071CF38(uint64_t result, int a2, unint64_t a3, unint64_t a4)
{
  if (!a2 && a3 < a4)
  {
    uint64_t v4 = result;
    if (!*(_BYTE *)(result + 184))
    {
      uint64_t result = sub_1006DDCF4(result, 0);
      double v5 = (void *)result;
      uint64_t v7 = v6;
      if ((void *)result != v6)
      {
        while (1)
        {
          uint64_t v8 = (void *)(*(uint64_t (**)(void))(*(void *)v5[4] + 32LL))(v5[4]);
          uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSDictionary);
          uint64_t result = objc_opt_isKindOfClass(v8, v9);
          if ((result & 1) != 0)
          {
            id v10 = [v8 objectForKeyedSubscript:@"ClientName"];
            uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSString);
            uint64_t result = objc_opt_isKindOfClass(v10, v11);
            if ((result & 1) != 0)
            {
              uint64_t result = (uint64_t)[v10 isEqualToString:@"com.apple.NanoMaps"];
              if ((result & 1) != 0) {
                break;
              }
            }
          }

          int v12 = (void *)v5[1];
          if (v12)
          {
            do
            {
              uint64_t v13 = v12;
              int v12 = (void *)*v12;
            }

            while (v12);
          }

          else
          {
            do
            {
              uint64_t v13 = (void *)v5[2];
              BOOL v14 = *v13 == (void)v5;
              double v5 = v13;
            }

            while (!v14);
          }

          double v5 = v13;
          if (v13 == v7)
          {
            double v5 = v7;
            break;
          }
        }
      }

      *(_BYTE *)(v4 + 184) = v5 != v7;
    }
  }

  return result;
}

void sub_10071D060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  IOHIDEventGetVendorDefinedData(a4, &v13, &v12);
  if (v13) {
    BOOL v6 = v12 <= 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10184D238);
    }
    uint64_t v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Empty payload, returning", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10184D238);
      }
      v11[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Empty payload, returning",  v11,  2);
      uint64_t v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLCompass7::onDeviceMotionServiceIohidEvent(void *, void *, void *, IOHIDEventRef)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  else
  {
    unint64_t TimeStamp = IOHIDEventGetTimeStamp(a4);
    *(void *)__int128 buf = sub_101171C7C(TimeStamp);
    sub_10071D268(a1, v13, v12, (double *)buf);
  }

void sub_10071D230(uint64_t a1, uint64_t a2)
{
}

void sub_10071D268(uint64_t a1, _BYTE *a2, size_t a3, double *a4)
{
  BOOL v6 = *(void **)(a1 + 144);
  if (!v6)
  {
    BOOL v6 = operator new(0x70uLL);
    void *v6 = &off_10184D1E0;
    *(void *)(a1 + 144) = v6;
  }

  sub_10031377C(__dst, v6);
  uint64_t v7 = *(void *)(a1 + 144);
  __int128 v8 = *(_OWORD *)(v7 + 8);
  __int128 v9 = *(_OWORD *)(v7 + 56);
  __int128 v10 = *(_OWORD *)(v7 + 88);
  __int128 v28 = *(_OWORD *)(v7 + 72);
  __int128 v29 = v10;
  int v30 = *(_DWORD *)(v7 + 104);
  __int128 v11 = *(_OWORD *)(v7 + 24);
  v25[0] = v8;
  v25[1] = v11;
  __int128 v26 = *(_OWORD *)(v7 + 40);
  __int128 v27 = v9;
  uint64_t v12 = *(unsigned int *)(a1 + 132);
  if (!(_DWORD)v12 || *(void *)((char *)v25 + 4) == v12)
  {
    sub_10071D3A4(a1, (uint64_t)v25, a4, (uint64_t)v23);
    if ((WORD1(v25[0]) & 0x100) != 0)
    {
      double v13 = *a4;
      __int128 v16 = v23[2];
      __int128 v17 = v23[3];
      __int128 v18 = v23[4];
      __int128 v14 = v23[0];
      __int128 v15 = v23[1];
      uint64_t v19 = v24;
      int v20 = HIDWORD(v25[0]);
      float v21 = sqrtf( (float)((float)(*(float *)&v27 * *(float *)&v27) + (float)(*((float *)&v26 + 3) * *((float *)&v26 + 3)))
            + (float)(*((float *)&v27 + 1) * *((float *)&v27 + 1)));
      char v22 = *(_BYTE *)(a1 + 28);
      sub_1006DD528(a1, 0LL, (uint64_t)&v13, 112LL);
    }
  }

void sub_10071D3A4(uint64_t a1@<X0>, uint64_t a2@<X1>, double *a3@<X2>, uint64_t a4@<X8>)
{
  __int16 v79 = a3;
  float32x4_t v82 = *(float32x4_t *)(a2 + 28);
  sub_100833700(&v82, v82);
  float v7 = sub_100833470(v82.f32);
  float v9 = v8;
  float v11 = v10;
  LODWORD(v74) = *(_DWORD *)(a2 + 92);
  HIDWORD(v74) = *(_DWORD *)(a2 + 88);
  HIDWORD(v73) = *(_DWORD *)(a2 + 96);
  float v12 = *(float *)(a2 + 16);
  float v13 = v12 - *(float *)(a2 + 76);
  double v78 = *(double *)(a2 + 20);
  float v14 = *(float *)&v78 - *(float *)(a2 + 80);
  float v15 = *((float *)&v78 + 1) - *(float *)(a2 + 84);
  *(float *)&double v80 = v13;
  *((float *)&v80 + 1) = v14;
  *(float *)&double v81 = v15;
  float v16 = sub_100833520(v82.f32);
  double v77 = COERCE_DOUBLE(__PAIR64__(LODWORD(v16), v17));
  HIDWORD(v76) = v18;
  uint64_t v19 = 0LL;
  float v20 = 0.0;
  do
  {
    float v20 = v20 + (float)(*(float *)((char *)&v80 + v19) * *(float *)((char *)&v80 + v19));
    v19 += 4LL;
  }

  while (v19 != 12);
  LODWORD(v76) = sqrtf(v20);
  *(float *)&double v75 = (float)((float)((float)(v11 * v15) + (float)(v9 * v14)) + (float)(v7 * v13)) / *(float *)&v76;
  *((float *)&v75 + 1) = *(float *)&v76 * sqrtf(1.0 - (float)(*(float *)&v75 * *(float *)&v75));
  sub_10071DE3C(a1, *(float *)(a2 + 72), fabsf(*((float *)&v75 + 1)));
  float v22 = v21;
  char v23 = *(_BYTE *)(a2 + 1);
  float v24 = *(float *)(a2 + 68);
  float v25 = -1.0;
  if (*(_BYTE *)(a1 + 129)) {
    char v26 = 0;
  }
  else {
    char v26 = v23;
  }
  if (*(_BYTE *)(a1 + 129)) {
    float v22 = -1.0;
  }
  unsigned int v27 = *(unsigned __int16 *)(a2 + 2);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184D1B0);
  }
  __int128 v28 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 136324098;
    double v29 = *(float *)(a2 + 32);
    double v86 = *(float *)(a2 + 28);
    double v88 = v29;
    LODWORD(v29) = *(_DWORD *)(a2 + 40);
    double v90 = *(float *)(a2 + 36);
    double v92 = *(float *)&v29;
    double v94 = *((float *)&v74 + 1);
    double v96 = *(float *)&v74;
    double v98 = *((float *)&v73 + 1);
    double v100 = *((float *)&v77 + 1);
    double v102 = *((float *)&v76 + 1);
    double v104 = *(float *)&v77;
    double v106 = v12;
    double v108 = *(float *)&v78;
    double v110 = *((float *)&v78 + 1);
    double v112 = v7;
    double v114 = v9;
    double v116 = v11;
    double v118 = v24;
    double v120 = v25;
    double v122 = v22;
    double v30 = *v79;
    __int16 v84 = "GyroCompass";
    __int16 v85 = 2048;
    __int16 v87 = 2048;
    __int16 v89 = 2048;
    __int16 v91 = 2048;
    __int16 v93 = 2048;
    __int16 v95 = 2048;
    __int16 v97 = 2048;
    __int16 v99 = 2048;
    __int16 v101 = 2048;
    __int16 v103 = 2048;
    __int16 v105 = 2048;
    __int16 v107 = 2048;
    __int16 v109 = 2048;
    __int16 v111 = 2048;
    __int16 v113 = 2048;
    __int16 v115 = 2048;
    __int16 v117 = 2048;
    __int16 v119 = 2048;
    __int16 v121 = 2048;
    __int16 v123 = 1024;
    int v124 = v26;
    __int16 v125 = 1024;
    int v126 = (v27 >> 4) & 1;
    __int16 v127 = 1024;
    int v128 = (v27 >> 3) & 1;
    __int16 v129 = 1024;
    int v130 = (v27 >> 2) & 1;
    __int16 v131 = 1024;
    int v132 = (v27 >> 5) & 1;
    __int16 v133 = 1024;
    int v134 = (v27 >> 6) & 1;
    __int16 v135 = 1024;
    int v136 = (v27 >> 8) & 1;
    __int16 v137 = 1024;
    int v138 = (v27 >> 1) & 1;
    __int16 v139 = 1024;
    int v140 = v27 & 1;
    __int16 v141 = 1024;
    int v142 = (v27 >> 10) & 1;
    __int16 v143 = 1024;
    int v144 = (v27 >> 9) & 1;
    __int16 v145 = 1024;
    int v146 = (v27 >> 11) & 1;
    __int16 v147 = 1024;
    int v148 = (v27 >> 12) & 1;
    __int16 v149 = 1024;
    int v150 = (v27 >> 13) & 1;
    __int16 v151 = 1024;
    int v152 = (v27 >> 14) & 1;
    __int16 v153 = 2048;
    double v154 = v30;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,magBiasEstVar.x,%.8f,.y,%.8f,.z,%.8f,calibrated.x,%.8f,.y,%.8f,.z, %.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1 f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrectio n,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,no rth,%d,visualLocalization,%d,timestamp,%f",  buf,  0x12Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    double v65 = *(float *)(a2 + 28);
    double v66 = *(float *)(a2 + 32);
    double v67 = *(float *)(a2 + 36);
    double v68 = *(float *)(a2 + 40);
    uint64_t v69 = *(void *)v79;
    *(_DWORD *)v158 = 136324098;
    *(void *)&v158[4] = "GyroCompass";
    *(_WORD *)&v158[12] = 2048;
    *(double *)&v158[14] = v65;
    __int16 v159 = 2048;
    double v160 = v66;
    *(_WORD *)v161 = 2048;
    *(double *)&v161[2] = v67;
    *(_WORD *)&v161[10] = 2048;
    *(double *)&v161[12] = v68;
    *(_WORD *)&v161[20] = 2048;
    *(double *)&v161[22] = *((float *)&v74 + 1);
    *(_WORD *)&v161[30] = 2048;
    *(double *)&v161[32] = *(float *)&v74;
    *(_WORD *)v162 = 2048;
    *(double *)&v162[2] = *((float *)&v73 + 1);
    *(_WORD *)&v162[10] = 2048;
    double v163 = *((float *)&v77 + 1);
    *(_WORD *)v164 = 2048;
    *(double *)&v164[2] = *((float *)&v76 + 1);
    __int16 v165 = 2048;
    double v166 = *(float *)&v77;
    __int16 v167 = 2048;
    double v168 = v12;
    __int16 v169 = 2048;
    double v170 = *(float *)&v78;
    __int16 v171 = 2048;
    double v172 = *((float *)&v78 + 1);
    __int16 v173 = 2048;
    double v174 = v7;
    __int16 v175 = 2048;
    double v176 = v9;
    __int16 v177 = 2048;
    double v178 = v11;
    __int16 v179 = 2048;
    double v180 = v24;
    __int16 v181 = 2048;
    double v182 = v25;
    __int16 v183 = 2048;
    double v184 = v22;
    __int16 v185 = 1024;
    int v186 = v26;
    __int16 v187 = 1024;
    int v188 = (v27 >> 4) & 1;
    __int16 v189 = 1024;
    int v190 = (v27 >> 3) & 1;
    __int16 v191 = 1024;
    int v192 = (v27 >> 2) & 1;
    __int16 v193 = 1024;
    int v194 = (v27 >> 5) & 1;
    __int16 v195 = 1024;
    int v196 = (v27 >> 6) & 1;
    __int16 v197 = 1024;
    int v198 = (v27 >> 8) & 1;
    __int16 v199 = 1024;
    int v200 = (v27 >> 1) & 1;
    __int16 v201 = 1024;
    int v202 = v27 & 1;
    __int16 v203 = 1024;
    int v204 = (v27 >> 10) & 1;
    __int16 v205 = 1024;
    int v206 = (v27 >> 9) & 1;
    __int16 v207 = 1024;
    int v208 = (v27 >> 11) & 1;
    __int16 v209 = 1024;
    int v210 = (v27 >> 12) & 1;
    __int16 v211 = 1024;
    int v212 = (v27 >> 13) & 1;
    __int16 v213 = 1024;
    int v214 = (v27 >> 14) & 1;
    __int16 v215 = 2048;
    uint64_t v216 = v69;
    LODWORD(v72) = 302;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,magBiasEstVar.x,%.8f,.y,%.8f,.z,%.8f,calibrated.x,%.8f,.y,%.8f,.z, %.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1 f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrectio n,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,no rth,%d,visualLocalization,%d,timestamp,%f",  v158,  v72,  COERCE_DOUBLE(&v204),  v73,  v74,  v75,  v76,  v77,  v78,  *(double *)&v79,  v80,  v81,  *(double *)v82.i64,  *(double *)&v82.i64[1]);
    uint64_t v71 = (uint8_t *)v70;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMotionTypeCompass CLCompass7::populateMotionType(const CMDeviceMotionReport::Compass &, const CFTimeInterval &)",  "%s\n",  v70);
    if (v71 != buf) {
      free(v71);
    }
  }

  if (*(_BYTE *)(a1 + 29))
  {
    *(void *)v158 = &off_101857C70;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    double v32 = *v79;
    *(CFAbsoluteTime *)&v158[8] = Current;
    double v160 = v32;
    *(_OWORD *)v161 = *(_OWORD *)(a2 + 28);
    *(void *)&v161[16] = *(void *)(a2 + 56);
    LODWORD(Current) = *(_DWORD *)(a2 + 64);
    *(float32x2_t *)&v161[28] = vmul_f32(*(float32x2_t *)(a2 + 44), (float32x2_t)vdup_n_s32(0x42652EE1u));
    *(float *)&double v32 = *(float *)(a2 + 52) * 57.296;
    *(_DWORD *)&v161[24] = LODWORD(Current);
    *(_DWORD *)&v161[36] = LODWORD(v32);
    *(float *)v162 = v12;
    *(double *)&v162[4] = v78;
    LOBYTE(v163) = v26;
    *((float *)&v163 + 1) = v24;
    *(float *)v164 = v25;
    *(float *)&v164[4] = v22;
    int v33 = *(_DWORD *)(a1 + 132);
    LODWORD(v166) = 2;
    HIDWORD(v166) = v33;
    __int16 v167 = *(_WORD *)(a2 + 2);
    uint64_t v34 = sub_100E00E14();
    sub_100E022E0(v34, (uint64_t)v158);
    sub_101125260(buf);
    sub_10113A980(buf);
    v157 |= 1u;
    uint64_t v155 = *(void *)&v158[8];
    uint64_t v35 = v156;
    uint64_t v36 = *(void *)v79;
    *(_DWORD *)(v156 + 124) |= 0x10u;
    *(void *)(v35 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v36;
    uint64_t v37 = v156;
    double v38 = *(float *)(a2 + 28);
    *(_DWORD *)(v156 + 124) |= 2u;
    *(double *)(v37 + sub_100708348(v2 - 16) = v38;
    uint64_t v39 = v156;
    double v40 = *(float *)(a2 + 32);
    *(_DWORD *)(v156 + 124) |= 4u;
    *(double *)(v39 + sub_10000AE14(v9 + 24) = v40;
    uint64_t v41 = v156;
    double v42 = *(float *)(a2 + 36);
    *(_DWORD *)(v156 + 124) |= 8u;
    *(double *)(v41 + 32) = v42;
    uint64_t v43 = v156;
    double v44 = *(float *)(a2 + 40);
    *(_DWORD *)(v156 + 124) |= 1u;
    *(double *)(v43 + _Block_object_dispose(va, 8) = v44;
    uint64_t v45 = v156;
    LODWORD(v44) = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(v156 + 124) |= 0x40000u;
    *(_DWORD *)(v45 + 10sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = LODWORD(v44);
    uint64_t v46 = v156;
    LODWORD(v44) = *(_DWORD *)(a2 + 60);
    *(_DWORD *)(v156 + 124) |= 0x80000u;
    *(_DWORD *)(v46 + 104) = LODWORD(v44);
    uint64_t v47 = v156;
    LODWORD(v44) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(v156 + 124) |= 0x100000u;
    *(_DWORD *)(v47 + 10_Block_object_dispose(va, 8) = LODWORD(v44);
    uint64_t v48 = v156;
    *(float *)&double v44 = *(float *)(a2 + 44) * 57.296;
    *(_DWORD *)(v156 + 124) |= 0x2000u;
    *(_DWORD *)(v48 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = LODWORD(v44);
    uint64_t v49 = v156;
    *(float *)&double v44 = *(float *)(a2 + 48) * 57.296;
    *(_DWORD *)(v156 + 124) |= 0x4000u;
    *(_DWORD *)(v49 + 84) = LODWORD(v44);
    uint64_t v50 = v156;
    *(float *)&double v44 = *(float *)(a2 + 52) * 57.296;
    *(_DWORD *)(v156 + 124) |= 0x8000u;
    *(_DWORD *)(v50 + 8_Block_object_dispose(va, 8) = LODWORD(v44);
    uint64_t v51 = v156;
    *(_DWORD *)(v156 + 124) |= 0x100u;
    *(float *)(v51 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v12;
    uint64_t v52 = v156;
    *(_DWORD *)(v156 + 124) |= 0x200u;
    *(_DWORD *)(v52 + 64) = LODWORD(v78);
    uint64_t v53 = v156;
    *(_DWORD *)(v156 + 124) |= 0x400u;
    *(_DWORD *)(v53 + 6_Block_object_dispose(va, 8) = HIDWORD(v78);
    uint64_t v54 = v156;
    *(_DWORD *)(v156 + 124) |= 0x80u;
    *(_DWORD *)(v54 + 56) = v26;
    uint64_t v55 = v156;
    *(_DWORD *)(v156 + 124) |= 0x800u;
    *(float *)(v55 + 72) = v24;
    uint64_t v56 = v156;
    *(_DWORD *)(v156 + 124) |= 0x20000u;
    *(float *)(v56 + 96) = v25;
    uint64_t v57 = v156;
    *(_DWORD *)(v156 + 124) |= 0x20u;
    *(float *)(v57 + 4_Block_object_dispose(va, 8) = v22;
    uint64_t v58 = v156;
    *(_DWORD *)(v156 + 124) |= 0x1000u;
    *(_DWORD *)(v58 + 76) = 2;
    uint64_t v59 = v156;
    int v60 = *(_DWORD *)(a1 + 132);
    *(_DWORD *)(v156 + 124) |= 0x40u;
    *(_DWORD *)(v59 + 52) = v60;
    uint64_t v61 = v156;
    int v62 = *(unsigned __int16 *)(a2 + 2);
    *(_DWORD *)(v156 + 124) |= 0x10000u;
    *(_DWORD *)(v61 + 92) = v62;
    if (qword_1019A1D00 != -1) {
      dispatch_once(&qword_1019A1D00, &stru_10184D258);
    }
    if (qword_1019A1D08) {
      sub_1011CF3D0(qword_1019A1D08, (uint64_t)buf);
    }
    sub_101127D00((PB::Base *)buf);
  }

  float v63 = acosf(*(float *)&v75);
  *(_DWORD *)a4 = HIDWORD(v77);
  *(_DWORD *)(a4 + 4) = HIDWORD(v76);
  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = LODWORD(v77);
  *(double *)(a4 + 12) = v80;
  *(_DWORD *)(a4 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = LODWORD(v81);
  *(float *)(a4 + sub_10000AE14(v9 + 24) = v24;
  *(float *)(a4 + 2_Block_object_dispose(va, 8) = v25;
  *(float *)(a4 + 32) = v22;
  *(_DWORD *)(a4 + 36) = v26;
  *(_BYTE *)(a4 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(_DWORD *)(a4 + 44) = LODWORD(v76);
  *(float *)(a4 + 4_Block_object_dispose(va, 8) = (float)(v63 * -57.296) + 90.0;
  *(_DWORD *)(a4 + 52) = HIDWORD(v75);
  float v64 = v82.f32[2];
  *(double *)(a4 + 56) = v82.f32[3];
  *(float64x2_t *)(a4 + 64) = vcvtq_f64_f32(*(float32x2_t *)v82.f32);
  *(double *)(a4 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v64;
}

void sub_10071DE1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_10071DE3C(uint64_t a1, float a2, float a3)
{
  if (a2 != -1.0 && *(_BYTE *)(a1 + 272) && a3 > 0.0) {
    asinf(5.0 / a3);
  }
}

void sub_10071DEB4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 31)
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184D1B0);
    }
    BOOL v6 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)(a4 + 984);
      *(_DWORD *)__int128 buf = 67109120;
      int v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "visionARSessionState.state,%d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184D1B0);
      }
      int v10 = *(_DWORD *)(a4 + 984);
      v15[0] = 67109120;
      v15[1] = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  0LL,  "visionARSessionState.state,%d",  v15);
      float v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCompass7::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProv ider_Type::NotificationData &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    BOOL v8 = *(_DWORD *)(a4 + 984) != 1;
    uint64_t v9 = sub_1006E27E8();
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    _OWORD v13[2] = sub_10071E0C0;
    v13[3] = &unk_101833458;
    v13[4] = a1;
    BOOL v14 = v8;
    sub_1006E28B8(v9, (uint64_t)v13);
  }

uint64_t sub_10071E0C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(unsigned __int8 *)(result + 136) != v3)
  {
    *(_BYTE *)(result + 136) = v3;
    return sub_10071CCAC(result, (double *)(result + 264));
  }

  return result;
}

void sub_10071E0E8(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

__n128 sub_10071E114(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  *(_OWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a2[2];
  *(_OWORD *)(a1 + sub_10000AE14(v9 + 24) = v3;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = v2;
  __n128 result = (__n128)a2[3];
  __int128 v5 = a2[4];
  __int128 v6 = a2[5];
  *(_DWORD *)(a1 + 104) = *((_DWORD *)a2 + 24);
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = v6;
  *(_OWORD *)(a1 + 72) = v5;
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_10071E148(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_10071E178()
{
  unsigned int v0 = sub_1002A6FD4((uint64_t)v3, (uint64_t)@"SOSNewtonTriggersEmergencySOSKey", &v4);
  if (v4) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  sub_1002F14C8(v3);
  return v1;
}

void sub_10071E1E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10071E2B4(id a1)
{
  qword_1019983B8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLFallNotifierSilo");
}

uint64_t sub_10071E368(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10072B4D8;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_1019983D8 != -1) {
    dispatch_once(&qword_1019983D8, block);
  }
  return qword_1019A15D0;
}

void sub_10071E508(id a1)
{
}

unint64_t sub_10071E52C()
{
  if ((sub_1004F97F4() & 0x4000000000LL) != 0) {
    return 1LL;
  }
  sub_1004F2598();
  return ((unint64_t)sub_1004F97F4() >> 39) & 1;
}

uint64_t sub_10071E580(uint64_t a1, uint64_t a2)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  BOOL v4 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134349056;
    uint64_t v11 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Simulating event: %{public}lu.", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v8 = 134349056;
    uint64_t v9 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Simulating event: %{public}lu.",  &v8,  12);
    int v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::simulateEvent(CMFallEventType)", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return sub_1007275FC(a1, a2);
}

uint64_t sub_10071E75C(uint64_t a1, int a2)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  BOOL v4 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67240192;
    int v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Changing hgal capture mode: %{public}u.",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    v8[0] = 67240192;
    v8[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Changing hgal capture mode: %{public}u.",  v8,  8);
    int v7 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::setHgalCaptureMode(uint8_t)", "%s\n", v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  *(_BYTE *)(a1 + 109) = a2;
  return sub_1007275FC(a1, 0);
}

void sub_10071E988( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10071F064()
{
  unsigned __int8 v1 = 0;
  sub_1012049AC(v2, "FallStatsSensorRecordingEnabled", &v1, 0);
  return v2[1];
}

uint64_t sub_10071F09C()
{
  BOOL v9 = 0;
  LOBYTE(v6) = 0;
  sub_1012049AC(v8, "AnomalyDetectorEnabledKey", (unsigned __int8 *)&v6, 0);
  sub_1002F0B04(&v6);
  char v0 = sub_1002A6F64(v6, "AnomalyDetectorEnabledKey", &v9);
  char v1 = v0;
  __int128 v2 = v7;
  if (!v7) {
    goto LABEL_5;
  }
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    unint64_t v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((v1 & 1) != 0) {
      return v9;
    }
  }

  else
  {
LABEL_5:
    if ((v0 & 1) != 0) {
      return v9;
    }
  }

  sub_1004F2598();
  if ((sub_1004F97F4() & 0x8000000000LL) != 0) {
    return sub_10071E178();
  }
  else {
    return 0LL;
  }
}

void sub_10071F168(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10071F480(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_BYTE *)(a2 + 156))
  {
    *(_BYTE *)(a2 + 156) = a3;
    *(_BYTE *)(a2 + 157) = 2;
    sub_10071F508(a1, a2);
    if (sub_10071FC64(a1))
    {
    }
  }

void sub_10071F508(uint64_t a1, uint64_t a2)
{
  float v4 = sub_100734D60((float *)(a2 + 27));
  if (*(_BYTE *)(a2 + 16))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int128 v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      LODWORD(v37[0]) = 0;
      WORD2(v37[0]) = 2082;
      *(void *)((char *)v37 + 6) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received Near Fall event}",  buf,  0x12u);
    }
  }

  if ((*(_BYTE *)(a2 + 16) | ((LODWORD(v4) & 0x7FFFFFFFu) > 0x7F7FFFFF)) | ((*(unsigned __int8 *)(a2 + 18) | (v4 >= *(float *)(a1 + 7480))) != 0))
  {
    v24[0] = &off_101858158;
    char v25 = 3;
    uint64_t v6 = *(void *)(a2 + 174);
    v24[1] = *(void *)(a2 + 158);
    v24[3] = v6;
    uint64_t v7 = *(void *)(a2 + 19);
    uint64_t v26 = *(void *)(a2 + 4);
    uint64_t v27 = v7;
    char v28 = *(_BYTE *)(a2 + 15);
    char v29 = *(_BYTE *)(a2 + 13);
    __int16 v30 = *(_WORD *)(a2 + 156);
    uint64_t v31 = *(void *)(a2 + 182);
    char v32 = *(_BYTE *)(a2 + 190);
    char v33 = *(_BYTE *)(a2 + 17);
    memset(&__p, 0, sizeof(__p));
    sub_100805ED4((uint64_t)v24, &__p);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 136315138;
      v37[0] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      float v13 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        float v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      int v34 = 136315138;
      uint64_t v35 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "%s",  (const char *)&v34);
      float v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallState(const CLFall_Types::ImpactEvent &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    if ((sub_100726A64(a1) & 1) != 0 || (sub_100726B2C() & 1) != 0 || sub_100726B94())
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v10 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Logging impact update to logger.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v34) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact update to logger.",  &v34,  2);
        int v17 = (uint8_t *)v16;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallState(const CLFall_Types::ImpactEvent &)",  "%s\n",  v16);
        if (v17 != buf) {
          free(v17);
        }
      }

      [*(id *)(a1 + 136) logImpactEventState:a2];
    }

    LOBYTE(v34) = 0;
    sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)&v34, 0);
    if (buf[1])
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v11 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Logging impact update for user studies.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v34) = 0;
        LODWORD(v22) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact update for user studies.",  &v34,  v22);
        uint64_t v19 = (uint8_t *)v18;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallState(const CLFall_Types::ImpactEvent &)",  "%s\n",  v18);
        if (v19 != buf) {
          free(v19);
        }
      }

      objc_msgSend( *(id *)(a1 + 176),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", v24));
    }
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v12 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Impact does not meet logging threshold requirement, will disregard state.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v24[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Impact does not meet logging threshold requirement, will disregard state.",  v24,  2);
      float v21 = (uint8_t *)v20;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallState(const CLFall_Types::ImpactEvent &)",  "%s\n",  v20);
      if (v21 != buf) {
        free(v21);
      }
    }
  }

void sub_10071FC34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10071FC64(uint64_t a1)
{
  if ((sub_1007269F4() & 1) != 0) {
    return 1LL;
  }
  if (sub_100726C58(a1)) {
    return 0LL;
  }
  return sub_100726BFC();
}

void sub_10071FCAC(uint64_t a1, unint64_t a2, unsigned int a3, unint64_t a4)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v8 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134349568;
    v317 = (const char *)a2;
    __int16 v318 = 1026;
    unsigned int v319 = a3;
    __int16 v320 = 2050;
    unint64_t v321 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received reason for canceling (impact:%{public}llu, operatingMode:%{public}u, reason:0x%{public}llx)",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v310 = 134349568;
    v311 = (const char *)a2;
    __int16 v312 = 1026;
    unsigned int v313 = a3;
    __int16 v314 = 2050;
    unint64_t v315 = a4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Received reason for canceling (impact:%{public}llu, operatingMode:%{public}u, reason:0x%{public}llx)",  &v310,  28);
    int v140 = (uint8_t *)v139;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v139);
    if (v140 != buf) {
      free(v140);
    }
  }

  if ((a4 & 1) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    BOOL v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactStart";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactStart";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v142 = (uint8_t *)v141;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v141);
      if (v142 != buf) {
        free(v142);
      }
    }
  }

  if ((a4 & 2) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactReplacedBecauseOfNewImpact";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactReplacedBecauseOfNewImpact";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v144 = (uint8_t *)v143;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v143);
      if (v144 != buf) {
        free(v144);
      }
    }
  }

  if ((a4 & 0x20) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v11 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfMaxAccelNorm";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfMaxAccelNorm";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v146 = (uint8_t *)v145;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v145);
      if (v146 != buf) {
        free(v146);
      }
    }
  }

  if ((a4 & 0x40) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v12 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfOtherHardThresholds";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfOtherHardThresholds";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v148 = (uint8_t *)v147;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v147);
      if (v148 != buf) {
        free(v148);
      }
    }
  }

  if ((a4 & 0x80) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v13 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfMultiPeaks";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfMultiPeaks";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v150 = (uint8_t *)v149;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v149);
      if (v150 != buf) {
        free(v150);
      }
    }
  }

  if ((a4 & 0x100) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    BOOL v14 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfNaiveBayes";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfNaiveBayes";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v152 = (uint8_t *)v151;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v151);
      if (v152 != buf) {
        free(v152);
      }
    }
  }

  if ((a4 & 0x200) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v15 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfCyclingImpactThresholds";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfCyclingImpactThresholds";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v154 = (uint8_t *)v153;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v153);
      if (v154 != buf) {
        free(v154);
      }
    }
  }

  if ((a4 & 0x400) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v16 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfExistingAlert";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfExistingAlert";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      uint64_t v156 = (uint8_t *)v155;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v155);
      if (v156 != buf) {
        free(v156);
      }
    }
  }

  if ((a4 & 0x800) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v17 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "ImpactCanceledBecauseOfDisabledStateMachine";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "ImpactCanceledBecauseOfDisabledStateMachine";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v158 = (uint8_t *)v157;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v157);
      if (v158 != buf) {
        free(v158);
      }
    }
  }

  if ((a4 & 0x100000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v18 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfHighFrequencyFFT";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfHighFrequencyFFT";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v160 = (uint8_t *)v159;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v159);
      if (v160 != buf) {
        free(v160);
      }
    }
  }

  if ((a4 & 0x200000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v19 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfLowFrequencyFFT";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfLowFrequencyFFT";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v162 = (uint8_t *)v161;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v161);
      if (v162 != buf) {
        free(v162);
      }
    }
  }

  if ((a4 & 0x400000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v20 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfDecimatedLowFrequencyFFT";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfDecimatedLowFrequencyFFT";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v164 = (uint8_t *)v163;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v163);
      if (v164 != buf) {
        free(v164);
      }
    }
  }

  if ((a4 & 0x800000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v21 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfFFT";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfFFT";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v166 = (uint8_t *)v165;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v165);
      if (v166 != buf) {
        free(v166);
      }
    }
  }

  if ((a4 & 0x1000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v22 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfPeaksIQR";
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfPeaksIQR";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v168 = (uint8_t *)v167;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v167);
      if (v168 != buf) {
        free(v168);
      }
    }
  }

  if ((a4 & 0x2000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v23 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfOffBody";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfOffBody";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v170 = (uint8_t *)v169;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v169);
      if (v170 != buf) {
        free(v170);
      }
    }
  }

  if ((a4 & 0x4000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v24 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfRepetitiveMotion";
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfRepetitiveMotion";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v172 = (uint8_t *)v171;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v171);
      if (v172 != buf) {
        free(v172);
      }
    }
  }

  if ((a4 & 0x8000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v25 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfAbsenceOfQuiessence";
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfAbsenceOfQuiessence";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v174 = (uint8_t *)v173;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v173);
      if (v174 != buf) {
        free(v174);
      }
    }
  }

  if ((a4 & 0x10000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v26 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfOffWristPre";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfOffWristPre";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v176 = (uint8_t *)v175;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v175);
      if (v176 != buf) {
        free(v176);
      }
    }
  }

  if ((a4 & 0x20000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v27 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfOffWristPost";
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfOffWristPost";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v178 = (uint8_t *)v177;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v177);
      if (v178 != buf) {
        free(v178);
      }
    }
  }

  if ((a4 & 0x40000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v28 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfFeatureDisabled";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfFeatureDisabled";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v180 = (uint8_t *)v179;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v179);
      if (v180 != buf) {
        free(v180);
      }
    }
  }

  if ((a4 & 0x80000000) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v29 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfOnCharger";
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfOnCharger";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v182 = (uint8_t *)v181;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v181);
      if (v182 != buf) {
        free(v182);
      }
    }
  }

  if ((a4 & 0x100000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int16 v30 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfAlreadyGatedBefore";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfAlreadyGatedBefore";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      double v184 = (uint8_t *)v183;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v183);
      if (v184 != buf) {
        free(v184);
      }
    }
  }

  if ((a4 & 0x200000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v31 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfSimilarPeaks";
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfSimilarPeaks";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v186 = (uint8_t *)v185;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v185);
      if (v186 != buf) {
        free(v186);
      }
    }
  }

  if ((a4 & 0x400000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v32 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfLockedNoMotionBeforeImpact";
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfLockedNoMotionBeforeImpact";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v188 = (uint8_t *)v187;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v187);
      if (v188 != buf) {
        free(v188);
      }
    }
  }

  if ((a4 & 0x800000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v33 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfReferee";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfReferee";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v190 = (uint8_t *)v189;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v189);
      if (v190 != buf) {
        free(v190);
      }
    }
  }

  if ((a4 & 0x1000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v34 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseStand";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseStand";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v192 = (uint8_t *)v191;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v191);
      if (v192 != buf) {
        free(v192);
      }
    }
  }

  if ((a4 & 0x2000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v35 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseActive";
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseActive";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v194 = (uint8_t *)v193;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v193);
      if (v194 != buf) {
        free(v194);
      }
    }
  }

  if ((a4 & 0x4000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v36 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseSteps";
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseSteps";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v196 = (uint8_t *)v195;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v195);
      if (v196 != buf) {
        free(v196);
      }
    }
  }

  if ((a4 & 0x8000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v37 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfDistanceTraveledPostImpact";
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfDistanceTraveledPostImpact";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v198 = (uint8_t *)v197;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v197);
      if (v198 != buf) {
        free(v198);
      }
    }
  }

  if ((a4 & 0x10000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v38 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "AlertCanceledBecauseOfDistanceCyclingPostImpact";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "AlertCanceledBecauseOfDistanceCyclingPostImpact";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v200 = (uint8_t *)v199;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v199);
      if (v200 != buf) {
        free(v200);
      }
    }
  }

  if ((a4 & 0x800000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v39 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "RecoveryCanceledBecauseOfReferee";
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "RecoveryCanceledBecauseOfReferee";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v202 = (uint8_t *)v201;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v201);
      if (v202 != buf) {
        free(v202);
      }
    }
  }

  if ((a4 & 0x4000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v40 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseUserResponse";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseUserResponse";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v204 = (uint8_t *)v203;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v203);
      if (v204 != buf) {
        free(v204);
      }
    }
  }

  if ((a4 & 0x8000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v41 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseOffWrist";
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseOffWrist";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v206 = (uint8_t *)v205;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v205);
      if (v206 != buf) {
        free(v206);
      }
    }
  }

  if ((a4 & 0x10000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v42 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseStand";
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseStand";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v208 = (uint8_t *)v207;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v207);
      if (v208 != buf) {
        free(v208);
      }
    }
  }

  if ((a4 & 0x20000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v43 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseActive";
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseActive";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v210 = (uint8_t *)v209;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v209);
      if (v210 != buf) {
        free(v210);
      }
    }
  }

  if ((a4 & 0x40000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v44 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseSteps";
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseSteps";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v212 = (uint8_t *)v211;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v211);
      if (v212 != buf) {
        free(v212);
      }
    }
  }

  if ((a4 & 0x80000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v45 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseAbsenceOfLongLie";
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseAbsenceOfLongLie";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      int v214 = (uint8_t *)v213;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v213);
      if (v214 != buf) {
        free(v214);
      }
    }
  }

  if ((a4 & 0x100000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v46 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCanceledBecauseOfReferee";
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCanceledBecauseOfReferee";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      uint64_t v216 = (uint8_t *)v215;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v215);
      if (v216 != buf) {
        free(v216);
      }
    }
  }

  if ((a4 & 0x2000000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v47 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCallConsidered";
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCallConsidered";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v218 = (uint8_t *)v217;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v217);
      if (v218 != buf) {
        free(v218);
      }
    }
  }

  if ((a4 & 0x4000000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v48 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCallScheduled";
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCallScheduled";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v220 = (uint8_t *)v219;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v219);
      if (v220 != buf) {
        free(v220);
      }
    }
  }

  if ((a4 & 0x8000000000000000LL) != 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v49 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v317 = "SOSCallPlaced";
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "         reason: %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v310 = 136315138;
      v311 = "SOSCallPlaced";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "         reason: %s",  (const char *)&v310);
      v224 = (uint8_t *)v223;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v223);
      if (v224 != buf) {
        free(v224);
      }
    }
  }

  if (a3 < 4 || a3 == 255)
  {
    sub_100D99C28(*(void *)(a1 + 128), a2, a4);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v50 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "Logging reason for canceling in AWD", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      LODWORD(v309) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging reason for canceling in AWD",  &v310,  v309);
      v222 = (uint8_t *)v221;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v221);
      if (v222 != buf) {
        free(v222);
      }
    }

    uint64_t v51 = (a4 >> 1) & 1;
    if ((a4 & 2) != 0)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v53 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactReplacedBecauseOfNewImpact",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
        LODWORD(v309) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactReplacedBecauseOfNewImpact",  &v310,  v309);
        v234 = (uint8_t *)v233;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v233);
        if (v234 != buf) {
          free(v234);
        }
      }

      uint64_t v54 = sub_1008D9630();
      sub_100737D00(v54);
      if ((a4 & 0x20) == 0)
      {
LABEL_262:
        if ((a4 & 0x40) == 0) {
          goto LABEL_263;
        }
        goto LABEL_284;
      }
    }

    else if ((a4 & 0x20) == 0)
    {
      goto LABEL_262;
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v55 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMaxAccelNorm",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      LODWORD(v309) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMaxAccelNorm",  &v310,  v309);
      v236 = (uint8_t *)v235;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v235);
      if (v236 != buf) {
        free(v236);
      }
    }

    uint64_t v56 = sub_1008D9630();
    sub_100737D54(v56);
    LODWORD(v51) = 1;
    if ((a4 & 0x40) == 0)
    {
LABEL_263:
      if ((a4 & 0x80) == 0) {
        goto LABEL_264;
      }
      goto LABEL_290;
    }

LABEL_284:
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v57 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfOtherHardThresholds",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      LODWORD(v309) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfOtherHardThresholds",  &v310,  v309);
      v238 = (uint8_t *)v237;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v237);
      if (v238 != buf) {
        free(v238);
      }
    }

    uint64_t v58 = sub_1008D9630();
    sub_100737DB0(v58);
    LODWORD(v51) = 1;
    if ((a4 & 0x80) == 0)
    {
LABEL_264:
      if ((a4 & 0x100) == 0) {
        goto LABEL_265;
      }
      goto LABEL_296;
    }

LABEL_290:
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v59 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMultiPeaks",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      LODWORD(v309) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMultiPeaks",  &v310,  v309);
      v240 = (uint8_t *)v239;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v239);
      if (v240 != buf) {
        free(v240);
      }
    }

    uint64_t v60 = sub_1008D9630();
    sub_100737E0C(v60);
    LODWORD(v51) = 1;
    if ((a4 & 0x100) == 0)
    {
LABEL_265:
      if ((a4 & 0x400) == 0) {
        goto LABEL_266;
      }
      goto LABEL_302;
    }

                *(void *)(a1 + sub_100708348(v2 - 16) = v30;
              }

              else
              {
                __n128 result = PB::Reader::skip(this, v20, v11 & 7, 0);
                if (!(_DWORD)result) {
                  return result;
                }
              }

LABEL_296:
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v61 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfNaiveBayes",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      LODWORD(v309) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfNaiveBayes",  &v310,  v309);
      v242 = (uint8_t *)v241;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v241);
      if (v242 != buf) {
        free(v242);
      }
    }

    uint64_t v62 = sub_1008D9630();
    sub_100737E68(v62);
    LODWORD(v51) = 1;
    if ((a4 & 0x400) == 0)
    {
LABEL_266:
      if ((a4 & 0x200) == 0) {
        goto LABEL_267;
      }
      goto LABEL_308;
    }

          *(_DWORD *)(a1 + 18sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v90;
          goto LABEL_351;
        case 8u:
          *(_WORD *)(a1 + 192) |= 0x100u;
          uint64_t v93 = *((void *)this + 1);
          uint64_t v94 = *((void *)this + 2);
          __int16 v95 = *(void *)this;
          if (v93 <= 0xFFFFFFFFFFFFFFF5LL && v93 + 10 <= v94)
          {
            uint64_t v96 = 0;
            __int16 v97 = 0;
            uint64_t v98 = 0LL;
            do
            {
              __int16 v99 = v93 + 1;
              *((void *)this + 1) = v93 + 1;
              uint64_t v100 = *(_BYTE *)(v95 + v93);
              v98 |= (unint64_t)(v100 & 0x7F) << v96;
              if ((v100 & 0x80) == 0) {
                goto LABEL_299;
              }
              v96 += 7;
              uint64_t v93 = v99;
              uint64_t v19 = v97++ > 8;
            }

            while (!v19);
LABEL_231:
            LODWORD(v9_Block_object_dispose(va, 8) = 0;
            goto LABEL_299;
          }

          double v154 = 0;
          uint64_t v155 = 0;
          uint64_t v98 = 0LL;
          if (v94 <= v93) {
            uint64_t v94 = *((void *)this + 1);
          }
          while (2)
          {
            if (v94 == v93)
            {
              LODWORD(v9_Block_object_dispose(va, 8) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              uint64_t v156 = v93 + 1;
              char v157 = *(_BYTE *)(v95 + v93);
              *((void *)this + 1) = v156;
              v98 |= (unint64_t)(v157 & 0x7F) << v154;
              if (v157 < 0)
              {
                v154 += 7;
                uint64_t v93 = v156;
                uint64_t v19 = v155++ > 8;
                if (v19) {
                  goto LABEL_231;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v9_Block_object_dispose(va, 8) = 0;
              }
            }

            break;
          }

          float v4 = *((void *)this + 1);
          __int128 v5 = *((void *)this + 2);
          uint64_t v6 = *((unsigned __int8 *)this + 24);
          if (v4 >= v5 || v6 != 0) {
            return v6 == 0;
          }
          break;
        default:
          if ((PB::Reader::skip(this, v18 >> 3, v18 & 7, 0) & 1) == 0) {
            return 0LL;
          }
          goto LABEL_296;
      }
    }

    uint64_t v22 = 0;
    char v23 = 0;
    int v18 = 0LL;
    if (v4 > v5) {
      __int128 v5 = v4;
    }
    while (v5 != v4)
    {
      float v24 = v4 + 1;
      char v25 = *(_BYTE *)(v15 + v4);
      *((void *)this + 1) = v24;
      v18 |= (unint64_t)(v25 & 0x7F) << v22;
      if ((v25 & 0x80) == 0) {
        goto LABEL_21;
      }
      v22 += 7;
      float v4 = v24;
      if (v23++ >= 9)
      {
LABEL_20:
        int v18 = 0LL;
        goto LABEL_21;
      }
    }

    uint64_t v6 = 1;
    *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
  }

  return v6 == 0;
}

            PB::Reader::recallMark(this, v288);
          }

          else
          {
            __int16 v177 = *(char **)(a1 + 64);
            double v176 = *(void *)(a1 + 72);
            if ((unint64_t)v177 >= v176)
            {
              int v214 = (char *)*v280;
              __int16 v215 = (v177 - (_BYTE *)*v280) >> 2;
              uint64_t v216 = v215 + 1;
              if ((unint64_t)(v215 + 1) >> 62) {
LABEL_488:
              }
                sub_100007008();
              v217 = v176 - (void)v214;
              if (v217 >> 1 > v216) {
                uint64_t v216 = v217 >> 1;
              }
              else {
                v218 = v216;
              }
              if (v218)
              {
                v219 = (char *)sub_10000956C((uint64_t)v10, v218);
                int v214 = *(char **)(a1 + 56);
                __int16 v177 = *(char **)(a1 + 64);
              }

              else
              {
                v219 = 0LL;
              }

              v264 = &v219[4 * v215];
              *(_DWORD *)v264 = 0;
              __int16 v171 = v264 + 4;
              while (v177 != v214)
              {
                v265 = *((_DWORD *)v177 - 1);
                v177 -= 4;
                *((_DWORD *)v264 - 1) = v265;
                v264 -= 4;
              }

              *(void *)(a1 + 56) = v264;
              *(void *)(a1 + 64) = v171;
              *(void *)(a1 + 72) = &v219[4 * v218];
              if (v214) {
                operator delete(v214);
              }
            }

            else
            {
              *(_DWORD *)__int16 v177 = 0;
              __int16 v171 = v177 + 4;
            }

            *(void *)(a1 + 64) = v171;
            v266 = *((void *)this + 1);
            v267 = *((void *)this + 2);
            v268 = *(void *)this;
            v269 = 0;
            v270 = 0;
            if (v266 > 0xFFFFFFFFFFFFFFF5LL || v266 + 10 > v267)
            {
              v237 = 0LL;
              if (v267 <= v266) {
                v267 = *((void *)this + 1);
              }
              while (v267 != v266)
              {
                v272 = v266 + 1;
                v273 = *(_BYTE *)(v268 + v266);
                *((void *)this + 1) = v272;
                v237 |= (unint64_t)(v273 & 0x7F) << v269;
                if ((v273 & 0x80) == 0)
                {
LABEL_464:
                  if (*((_BYTE *)this + 24)) {
                    LODWORD(v237) = 0;
                  }
                  goto LABEL_471;
                }

                v269 += 7;
                v266 = v272;
                float32x4_t v82 = v270++ > 8;
                if (v82)
                {
LABEL_470:
                  LODWORD(v237) = 0;
                  goto LABEL_471;
                }
              }

LABEL_320:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v69 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledAggregate",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
          LODWORD(v309) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledAggregate",  &v310,  v309);
          v226 = (uint8_t *)v225;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v225);
          if (v226 != buf) {
            free(v226);
          }
        }

        uint64_t v70 = sub_1008D9630();
        sub_100737FC8(v70);
        if ((a4 & 0x100000) == 0)
        {
LABEL_270:
          int v52 = 0;
          if ((a4 & 0x200000) == 0) {
            goto LABEL_338;
          }
          goto LABEL_332;
        }

LABEL_326:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v71 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfHighFrequencyFFT",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
          LODWORD(v309) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfHighFrequencyFFT",  &v310,  v309);
          v250 = (uint8_t *)v249;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v249);
          if (v250 != buf) {
            free(v250);
          }
        }

        uint64_t v72 = sub_1008D9630();
        sub_100738024(v72);
        int v52 = 1;
        if ((a4 & 0x200000) == 0)
        {
LABEL_338:
          if ((a4 & 0x400000) != 0)
          {
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            double v76 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDecimatedLowFrequencyFFT",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              LODWORD(v309) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDecimatedLowFrequencyFFT",  &v310,  v309);
              v254 = (uint8_t *)v253;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v253);
              if (v254 != buf) {
                free(v254);
              }
            }

            uint64_t v77 = sub_1008D9630();
            sub_1007380DC(v77);
            int v52 = 1;
            if ((a4 & 0x800000) == 0)
            {
LABEL_340:
              int v75 = 0;
              if ((a4 & 0x1000000) == 0) {
                goto LABEL_360;
              }
              goto LABEL_354;
            }
          }

          else if ((a4 & 0x800000) == 0)
          {
            goto LABEL_340;
          }

          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          double v78 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFFT",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
            LODWORD(v309) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFFT",  &v310,  v309);
            v256 = (uint8_t *)v255;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v255);
            if (v256 != buf) {
              free(v256);
            }
          }

          uint64_t v79 = sub_1008D9630();
          sub_100738138(v79);
          int v75 = 1;
          if ((a4 & 0x1000000) == 0)
          {
LABEL_360:
            if ((a4 & 0x2000000) != 0)
            {
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              float32x4_t v82 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffBody",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffBody",  &v310,  v309);
                v260 = (uint8_t *)v259;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v259);
                if (v260 != buf) {
                  free(v260);
                }
              }

              uint64_t v83 = sub_1008D9630();
              sub_1007381E8(v83);
              int v75 = 1;
              if ((a4 & 0x4000000) == 0)
              {
LABEL_362:
                if ((a4 & 0x8000000) == 0) {
                  goto LABEL_363;
                }
                goto LABEL_378;
              }
            }

            else if ((a4 & 0x4000000) == 0)
            {
              goto LABEL_362;
            }

            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            __int16 v84 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfRepetitiveMotion",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              LODWORD(v309) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfRepetitiveMotion",  &v310,  v309);
              v262 = (uint8_t *)v261;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v261);
              if (v262 != buf) {
                free(v262);
              }
            }

            uint64_t v85 = sub_1008D9630();
            sub_100738244(v85);
            int v75 = 1;
            if ((a4 & 0x8000000) == 0)
            {
LABEL_363:
              if ((a4 & 0x10000000) == 0) {
                goto LABEL_364;
              }
              goto LABEL_384;
            }

    v251 = 0;
    uint64_t v56 = 0;
    v257 = 0;
    v248 = 1;
  }

  *(double *)(v165 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a6;
  *(_DWORD *)(v165 + 4_Block_object_dispose(va, 8) = v168;
  *(double *)(v165 + sub_100708348(v2 - 16) = v17;
  if ((*(_BYTE *)(v156 + 160) & 0x80) != 0 || *(_BYTE *)(v156 + 176))
  {
    *(_DWORD *)(a5 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = sub_1005164B8((uint64_t)v320, v156, (_DWORD *)v165);
    *(_DWORD *)(a5 + 84) = 0;
    *(double *)(a5 + 72) = a6;
  }

          *(_DWORD *)(a1 + 14_Block_object_dispose(va, 8) = v95;
          goto LABEL_294;
        case 0x1Du:
          *(void *)(a1 + 216) |= 0x1000000000uLL;
          uint64_t v98 = *((void *)this + 1);
          __int16 v99 = *((void *)this + 2);
          uint64_t v100 = *(void *)this;
          if (v98 <= 0xFFFFFFFFFFFFFFF5LL && v98 + 10 <= v99)
          {
            __int16 v101 = 0;
            uint64_t v102 = 0;
            __int16 v103 = 0LL;
            do
            {
              uint64_t v104 = v98 + 1;
              *((void *)this + 1) = v98 + 1;
              __int16 v105 = *(_BYTE *)(v100 + v98);
              v103 |= (unint64_t)(v105 & 0x7F) << v101;
              if ((v105 & 0x80) == 0) {
                goto LABEL_330;
              }
              v101 += 7;
              uint64_t v98 = v104;
              BOOL v14 = v102++ > 8;
            }

            while (!v14);
LABEL_270:
            LODWORD(v103) = 0;
            goto LABEL_330;
          }

          __int16 v175 = 0;
          double v176 = 0;
          __int16 v103 = 0LL;
          if (v99 <= v98) {
            __int16 v99 = *((void *)this + 1);
          }
          while (2)
          {
            if (v99 == v98)
            {
              LODWORD(v103) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              __int16 v177 = v98 + 1;
              double v178 = *(_BYTE *)(v100 + v98);
              *((void *)this + 1) = v177;
              v103 |= (unint64_t)(v178 & 0x7F) << v175;
              if (v178 < 0)
              {
                v175 += 7;
                uint64_t v98 = v177;
                BOOL v14 = v176++ > 8;
                if (v14) {
                  goto LABEL_270;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v103) = 0;
              }
            }

            break;
          }

              *(_DWORD *)(a1 + 96) = v108;
              goto LABEL_282;
            case 0x11u:
              *(void *)(a1 + 164) |= 0x40000uLL;
              __int16 v111 = *((void *)this + 1);
              if (v111 > 0xFFFFFFFFFFFFFFFBLL || v111 + 4 > *((void *)this + 2)) {
                goto LABEL_170;
              }
              *(_DWORD *)(a1 + 104) = *(_DWORD *)(*(void *)this + v111);
              goto LABEL_281;
            case 0x12u:
              *(void *)(a1 + 164) |= 0x4000uLL;
              uint64_t v112 = *((void *)this + 1);
              if (v112 > 0xFFFFFFFFFFFFFFFBLL || v112 + 4 > *((void *)this + 2)) {
                goto LABEL_170;
              }
              *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = *(_DWORD *)(*(void *)this + v112);
              goto LABEL_281;
            case 0x13u:
              *(void *)(a1 + 164) |= 0x40uLL;
              __int16 v113 = *((void *)this + 1);
              if (v113 > 0xFFFFFFFFFFFFFFFBLL || v113 + 4 > *((void *)this + 2)) {
                goto LABEL_170;
              }
              *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(void *)this + v113);
              goto LABEL_281;
            case 0x14u:
              *(void *)(a1 + 164) |= 0x80uLL;
              uint64_t v114 = *((void *)this + 1);
              __int16 v115 = *((void *)this + 2);
              uint64_t v116 = *(void *)this;
              if (v114 <= 0xFFFFFFFFFFFFFFF5LL && v114 + 10 <= v115)
              {
                __int16 v117 = 0;
                uint64_t v118 = 0;
                __int16 v119 = 0LL;
                do
                {
                  uint64_t v120 = v114 + 1;
                  *((void *)this + 1) = v114 + 1;
                  __int16 v121 = *(_BYTE *)(v116 + v114);
                  v119 |= (unint64_t)(v121 & 0x7F) << v117;
                  if ((v121 & 0x80) == 0) {
                    goto LABEL_330;
                  }
                  v117 += 7;
                  uint64_t v114 = v120;
                  BOOL v14 = v118++ > 8;
                }

                while (!v14);
LABEL_258:
                LODWORD(v119) = 0;
                goto LABEL_330;
              }

              int v196 = 0;
              __int16 v197 = 0;
              __int16 v119 = 0LL;
              if (v115 <= v114) {
                __int16 v115 = *((void *)this + 1);
              }
              while (2)
              {
                if (v115 == v114)
                {
                  LODWORD(v119) = 0;
                  *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
                }

                else
                {
                  int v198 = v114 + 1;
                  __int16 v199 = *(_BYTE *)(v116 + v114);
                  *((void *)this + 1) = v198;
                  v119 |= (unint64_t)(v199 & 0x7F) << v196;
                  if (v199 < 0)
                  {
                    v196 += 7;
                    uint64_t v114 = v198;
                    BOOL v14 = v197++ > 8;
                    if (v14) {
                      goto LABEL_258;
                    }
                    continue;
                  }

                  if (*((_BYTE *)this + 24)) {
                    LODWORD(v119) = 0;
                  }
                }

                break;
              }

LABEL_378:
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            double v86 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAbsenceOfQuiessence",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              LODWORD(v309) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAbsenceOfQuiessence",  &v310,  v309);
              v264 = (uint8_t *)v263;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v263);
              if (v264 != buf) {
                free(v264);
              }
            }

            uint64_t v87 = sub_1008D9630();
            sub_1007382A0(v87);
            int v75 = 1;
            if ((a4 & 0x10000000) == 0)
            {
LABEL_364:
              if ((a4 & 0x20000000) == 0) {
                goto LABEL_396;
              }
              goto LABEL_390;
            }

      __int128 v2 = *((void *)this + 1);
      __int128 v3 = *((void *)this + 2);
      float v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }

    float v16 = 0;
    int v17 = 0;
    float v12 = 0LL;
    if (v2 > v3) {
      __int128 v3 = v2;
    }
    while (v3 != v2)
    {
      int v18 = v2 + 1;
      uint64_t v19 = *(_BYTE *)(v9 + v2);
      *((void *)this + 1) = v18;
      v12 |= (unint64_t)(v19 & 0x7F) << v16;
      if ((v19 & 0x80) == 0) {
        goto LABEL_21;
      }
      v16 += 7;
      __int128 v2 = v18;
      if (v17++ >= 9)
      {
LABEL_20:
        float v12 = 0LL;
        goto LABEL_21;
      }
    }

    float v4 = 1;
    *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
  }

  return v4 == 0;
}

LABEL_429:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v99 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAlreadyGatedBefore",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAlreadyGatedBefore",  &v310,  v309);
                v274 = (uint8_t *)v273;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v273);
                if (v274 != buf) {
                  free(v274);
                }
              }

              uint64_t v100 = sub_1008D9630();
              sub_1007384B8(v100);
              LODWORD(v94) = 1;
              if ((a4 & 0x200000000LL) == 0)
              {
LABEL_407:
                if ((a4 & 0x400000000LL) == 0) {
                  goto LABEL_408;
                }
                goto LABEL_441;
              }

LABEL_435:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v101 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfSimilarPeaks",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfSimilarPeaks",  &v310,  v309);
                v276 = (uint8_t *)v275;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v275);
                if (v276 != buf) {
                  free(v276);
                }
              }

              uint64_t v102 = sub_1008D9630();
              sub_100738514(v102);
              LODWORD(v94) = 1;
              if ((a4 & 0x400000000LL) == 0)
              {
LABEL_408:
                if ((a4 & 0x800000000LL) == 0) {
                  goto LABEL_409;
                }
                goto LABEL_447;
              }

LABEL_441:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v103 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLockedNoMotionBeforeImpact",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLockedNoMotionBeforeImpact",  &v310,  v309);
                v278 = (uint8_t *)v277;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v277);
                if (v278 != buf) {
                  free(v278);
                }
              }

              uint64_t v104 = sub_1008D9630();
              sub_100738570(v104);
              LODWORD(v94) = 1;
              if ((a4 & 0x800000000LL) == 0)
              {
LABEL_409:
                if ((a4 & 0x1000000000LL) == 0) {
                  goto LABEL_410;
                }
                goto LABEL_453;
              }

LABEL_447:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v105 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfReferee",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfReferee",  &v310,  v309);
                v280 = (uint8_t *)v279;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v279);
                if (v280 != buf) {
                  free(v280);
                }
              }

              uint64_t v106 = sub_1008D9630();
              sub_1007385C4(v106);
              LODWORD(v94) = 1;
              if ((a4 & 0x1000000000LL) == 0)
              {
LABEL_410:
                if ((a4 & 0x2000000000LL) == 0) {
                  goto LABEL_411;
                }
                goto LABEL_459;
              }

LABEL_453:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v107 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseStand",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseStand",  &v310,  v309);
                v282 = (uint8_t *)v281;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v281);
                if (v282 != buf) {
                  free(v282);
                }
              }

              uint64_t v108 = sub_1008D9630();
              sub_100738620(v108);
              LODWORD(v94) = 1;
              if ((a4 & 0x2000000000LL) == 0)
              {
LABEL_411:
                if ((a4 & 0x4000000000LL) == 0) {
                  goto LABEL_412;
                }
                goto LABEL_465;
              }

LABEL_459:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v109 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v109,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseActive",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseActive",  &v310,  v309);
                v284 = (uint8_t *)v283;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v283);
                if (v284 != buf) {
                  free(v284);
                }
              }

              uint64_t v110 = sub_1008D9630();
              sub_10073867C(v110);
              LODWORD(v94) = 1;
              if ((a4 & 0x4000000000LL) == 0)
              {
LABEL_412:
                if ((a4 & 0x8000000000LL) == 0) {
                  goto LABEL_413;
                }
                goto LABEL_471;
              }

          *(void *)(a1 + 96) = v34;
          goto LABEL_544;
        case 2u:
          *(_DWORD *)(a1 + 212) |= 0x80000000;
          uint64_t v37 = *((void *)this + 1);
          if (v37 >= *((void *)this + 2))
          {
            double v40 = 0;
            *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
          }

          else
          {
            double v38 = v37 + 1;
            uint64_t v39 = *(unsigned __int8 *)(*(void *)this + v37);
            *((void *)this + 1) = v38;
            double v40 = v39 != 0;
          }

          *(_BYTE *)(a1 + 211) = v40;
          goto LABEL_544;
        case 3u:
          *(_DWORD *)(a1 + 212) |= 1u;
          uint64_t v41 = *((void *)this + 1);
          if (v41 > 0xFFFFFFFFFFFFFFF7LL || v41 + 8 > *((void *)this + 2)) {
            goto LABEL_540;
          }
          *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)(*(void *)this + v41);
          goto LABEL_523;
        case 4u:
          if ((_DWORD)v28 == 2)
          {
            if ((PB::Reader::placeMark(this, v361, v28, a4) & 1) != 0) {
              return 0LL;
            }
            double v42 = *((void *)this + 1);
            uint64_t v43 = *((void *)this + 2);
            while (v42 < v43 && !*((_BYTE *)this + 24))
            {
              uint64_t v45 = *(char **)(a1 + 16);
              double v44 = *(void *)(a1 + 24);
              if ((unint64_t)v45 >= v44)
              {
                uint64_t v47 = (char *)*v14;
                uint64_t v48 = (v45 - (_BYTE *)*v14) >> 3;
                uint64_t v49 = v48 + 1;
                uint64_t v50 = v44 - (void)v47;
                if (v50 >> 2 > v49) {
                  uint64_t v49 = v50 >> 2;
                }
                else {
                  uint64_t v51 = v49;
                }
                if (v51)
                {
                  int v52 = (char *)sub_1000071BC(v15, v51);
                  uint64_t v47 = *(char **)(a1 + 8);
                  uint64_t v45 = *(char **)(a1 + 16);
                }

                else
                {
                  int v52 = 0LL;
                }

                uint64_t v53 = &v52[8 * v48];
                *(void *)uint64_t v53 = 0LL;
                uint64_t v46 = v53 + 8;
                while (v45 != v47)
                {
                  uint64_t v54 = *((void *)v45 - 1);
                  v45 -= 8;
                  *((void *)v53 - 1) = v54;
                  v53 -= 8;
                }

                *(void *)(a1 + _Block_object_dispose(va, 8) = v53;
                *(void *)(a1 + sub_100708348(v2 - 16) = v46;
                *(void *)(a1 + sub_10000AE14(v9 + 24) = &v52[8 * v51];
                if (v47) {
                  operator delete(v47);
                }
              }

              else
              {
                *(void *)uint64_t v45 = 0LL;
                uint64_t v46 = v45 + 8;
              }

              *(void *)(a1 + sub_100708348(v2 - 16) = v46;
              uint64_t v55 = *((void *)this + 1);
              if (v55 > 0xFFFFFFFFFFFFFFF7LL || v55 + 8 > *((void *)this + 2)) {
                goto LABEL_412;
              }
              *(v46 - 1) = *(void *)(*(void *)this + v55);
              uint64_t v43 = *((void *)this + 2);
              double v42 = *((void *)this + 1) + 8LL;
              *((void *)this + 1) = v42;
            }

            goto LABEL_413;
          }

          v253 = *(char **)(a1 + 16);
          v252 = *(void *)(a1 + 24);
          if ((unint64_t)v253 >= v252)
          {
            v332 = (char *)*v14;
            v333 = (v253 - (_BYTE *)*v14) >> 3;
            v334 = v333 + 1;
            if ((unint64_t)(v333 + 1) >> 61) {
LABEL_554:
            }
              sub_100007008();
            v335 = v252 - (void)v332;
            if (v335 >> 2 > v334) {
              v334 = v335 >> 2;
            }
            else {
              v336 = v334;
            }
            if (v336)
            {
              v337 = (char *)sub_1000071BC(v15, v336);
              v332 = *(char **)(a1 + 8);
              v253 = *(char **)(a1 + 16);
            }

            else
            {
              v337 = 0LL;
            }

            v350 = &v337[8 * v333];
            *(void *)v350 = 0LL;
            v254 = v350 + 8;
            while (v253 != v332)
            {
              v351 = *((void *)v253 - 1);
              v253 -= 8;
              *((void *)v350 - 1) = v351;
              v350 -= 8;
            }

            *(void *)(a1 + _Block_object_dispose(va, 8) = v350;
            *(void *)(a1 + sub_100708348(v2 - 16) = v254;
            *(void *)(a1 + sub_10000AE14(v9 + 24) = &v337[8 * v336];
            if (v332) {
              operator delete(v332);
            }
          }

          else
          {
            *(void *)v253 = 0LL;
            v254 = v253 + 8;
          }

          *(void *)(a1 + sub_100708348(v2 - 16) = v254;
          v352 = *((void *)this + 1);
          if (v352 <= 0xFFFFFFFFFFFFFFF7LL && v352 + 8 <= *((void *)this + 2))
          {
            *(v254 - 1) = *(void *)(*(void *)this + v352);
LABEL_523:
            v353 = *((void *)this + 1) + 8LL;
            goto LABEL_543;
          }

          goto LABEL_540;
        case 5u:
          if ((_DWORD)v28 != 2)
          {
            v256 = *(char **)(a1 + 64);
            v255 = *(void *)(a1 + 72);
            if ((unint64_t)v256 >= v255)
            {
              v338 = (char *)*v12;
              v339 = (v256 - (_BYTE *)*v12) >> 2;
              v340 = v339 + 1;
              if ((unint64_t)(v339 + 1) >> 62) {
LABEL_555:
              }
                sub_100007008();
              v341 = v255 - (void)v338;
              if (v341 >> 1 > v340) {
                v340 = v341 >> 1;
              }
              else {
                v342 = v340;
              }
              if (v342)
              {
                v343 = (char *)sub_10000956C(v13, v342);
                v338 = *(char **)(a1 + 56);
                v256 = *(char **)(a1 + 64);
              }

              else
              {
                v343 = 0LL;
              }

              v354 = &v343[4 * v339];
              *(_DWORD *)v354 = 0;
              v257 = v354 + 4;
              while (v256 != v338)
              {
                v355 = *((_DWORD *)v256 - 1);
                v256 -= 4;
                *((_DWORD *)v354 - 1) = v355;
                v354 -= 4;
              }

              *(void *)(a1 + 56) = v354;
              *(void *)(a1 + 64) = v257;
              *(void *)(a1 + 72) = &v343[4 * v342];
              if (v338) {
                operator delete(v338);
              }
            }

            else
            {
              *(_DWORD *)v256 = 0;
              v257 = v256 + 4;
            }

            *(void *)(a1 + 64) = v257;
            goto LABEL_538;
          }

          if ((PB::Reader::placeMark(this, v361, v28, a4) & 1) != 0) {
            return 0LL;
          }
          uint64_t v56 = *((void *)this + 1);
          uint64_t v57 = *((void *)this + 2);
          while (v56 < v57 && !*((_BYTE *)this + 24))
          {
            uint64_t v59 = *(char **)(a1 + 64);
            uint64_t v58 = *(void *)(a1 + 72);
            if ((unint64_t)v59 >= v58)
            {
              uint64_t v61 = (char *)*v12;
              uint64_t v62 = (v59 - (_BYTE *)*v12) >> 2;
              float v63 = v62 + 1;
              uint64_t v64 = v58 - (void)v61;
              if (v64 >> 1 > v63) {
                float v63 = v64 >> 1;
              }
              else {
                double v65 = v63;
              }
              if (v65)
              {
                uint64_t v66 = (char *)sub_10000956C(v13, v65);
                uint64_t v61 = *(char **)(a1 + 56);
                uint64_t v59 = *(char **)(a1 + 64);
              }

              else
              {
                uint64_t v66 = 0LL;
              }

              double v67 = &v66[4 * v62];
              *(_DWORD *)double v67 = 0;
              uint64_t v60 = v67 + 4;
              while (v59 != v61)
              {
                uint64_t v68 = *((_DWORD *)v59 - 1);
                v59 -= 4;
                *((_DWORD *)v67 - 1) = v68;
                v67 -= 4;
              }

              *(void *)(a1 + 56) = v67;
              *(void *)(a1 + 64) = v60;
              *(void *)(a1 + 72) = &v66[4 * v65];
              if (v61) {
                operator delete(v61);
              }
            }

            else
            {
              *(_DWORD *)uint64_t v59 = 0;
              uint64_t v60 = v59 + 4;
            }

            *(void *)(a1 + 64) = v60;
            uint64_t v69 = *((void *)this + 1);
            if (v69 > 0xFFFFFFFFFFFFFFFBLL || v69 + 4 > *((void *)this + 2)) {
              goto LABEL_412;
            }
            *(v60 - 1) = *(_DWORD *)(*(void *)this + v69);
            uint64_t v57 = *((void *)this + 2);
            uint64_t v56 = *((void *)this + 1) + 4LL;
            *((void *)this + 1) = v56;
          }

          goto LABEL_413;
        case 6u:
          if ((_DWORD)v28 == 2)
          {
            if ((PB::Reader::placeMark(this, v361, v28, a4) & 1) != 0) {
              return 0LL;
            }
            uint64_t v70 = *((void *)this + 1);
            uint64_t v71 = *((void *)this + 2);
            while (v70 < v71 && !*((_BYTE *)this + 24))
            {
              double v73 = *(char **)(a1 + 40);
              uint64_t v72 = *(void *)(a1 + 48);
              if ((unint64_t)v73 >= v72)
              {
                int v75 = (char *)*v10;
                double v76 = (v73 - (_BYTE *)*v10) >> 2;
                uint64_t v77 = v76 + 1;
                double v78 = v72 - (void)v75;
                if (v78 >> 1 > v77) {
                  uint64_t v77 = v78 >> 1;
                }
                else {
                  uint64_t v79 = v77;
                }
                if (v79)
                {
                  double v80 = (char *)sub_10000956C(v11, v79);
                  int v75 = *(char **)(a1 + 32);
                  double v73 = *(char **)(a1 + 40);
                }

                else
                {
                  double v80 = 0LL;
                }

                uint64_t v81 = &v80[4 * v76];
                *(_DWORD *)uint64_t v81 = 0;
                uint64_t v74 = v81 + 4;
                while (v73 != v75)
                {
                  float32x4_t v82 = *((_DWORD *)v73 - 1);
                  v73 -= 4;
                  *((_DWORD *)v81 - 1) = v82;
                  v81 -= 4;
                }

                *(void *)(a1 + 32) = v81;
                *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v74;
                *(void *)(a1 + 4_Block_object_dispose(va, 8) = &v80[4 * v79];
                if (v75) {
                  operator delete(v75);
                }
              }

              else
              {
                *(_DWORD *)double v73 = 0;
                uint64_t v74 = v73 + 4;
              }

              *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v74;
              uint64_t v83 = *((void *)this + 1);
              if (v83 > 0xFFFFFFFFFFFFFFFBLL || v83 + 4 > *((void *)this + 2))
              {
LABEL_412:
                *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
                break;
              }

              *(v74 - 1) = *(_DWORD *)(*(void *)this + v83);
              uint64_t v71 = *((void *)this + 2);
              uint64_t v70 = *((void *)this + 1) + 4LL;
              *((void *)this + 1) = v70;
            }

LABEL_465:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v111 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseSteps",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseSteps",  &v310,  v309);
                v286 = (uint8_t *)v285;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v285);
                if (v286 != buf) {
                  free(v286);
                }
              }

              uint64_t v112 = sub_1008D9630();
              sub_1007386D8(v112);
              LODWORD(v94) = 1;
              if ((a4 & 0x8000000000LL) == 0)
              {
LABEL_413:
                if ((a4 & 0x10000000000LL) == 0)
                {
                  if (!(_DWORD)v94)
                  {
                    if ((a4 & 0x800000000000LL) == 0) {
                      goto LABEL_500;
                    }
                    goto LABEL_489;
                  }

          *(_DWORD *)(a1 + 172) = v106;
          goto LABEL_544;
        case 0xCu:
          *(_DWORD *)(a1 + 212) |= 0x40000u;
          __int16 v109 = *((void *)this + 1);
          uint64_t v110 = *((void *)this + 2);
          __int16 v111 = *(void *)this;
          if (v109 <= 0xFFFFFFFFFFFFFFF5LL && v109 + 10 <= v110)
          {
            uint64_t v112 = 0;
            __int16 v113 = 0;
            uint64_t v114 = 0LL;
            do
            {
              __int16 v115 = v109 + 1;
              *((void *)this + 1) = v109 + 1;
              uint64_t v116 = *(_BYTE *)(v111 + v109);
              v114 |= (unint64_t)(v116 & 0x7F) << v112;
              if ((v116 & 0x80) == 0) {
                goto LABEL_468;
              }
              v112 += 7;
              __int16 v109 = v115;
              uint64_t v22 = v113++ > 8;
            }

            while (!v22);
LABEL_304:
            LODWORD(v114) = 0;
            goto LABEL_468;
          }

          v268 = 0;
          v269 = 0;
          uint64_t v114 = 0LL;
          if (v110 <= v109) {
            uint64_t v110 = *((void *)this + 1);
          }
          while (2)
          {
            if (v110 == v109)
            {
              LODWORD(v114) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              v270 = v109 + 1;
              v271 = *(_BYTE *)(v111 + v109);
              *((void *)this + 1) = v270;
              v114 |= (unint64_t)(v271 & 0x7F) << v268;
              if (v271 < 0)
              {
                v268 += 7;
                __int16 v109 = v270;
                uint64_t v22 = v269++ > 8;
                if (v22) {
                  goto LABEL_304;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v114) = 0;
              }
            }

            break;
          }

LABEL_483:
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  __int16 v117 = (os_log_s *)qword_1019345D8;
                  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledOtherAggregate",  buf,  2u);
                  }

                  if (sub_1002921D0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                    LODWORD(v309) = 2;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledOtherAggregate",  &v310,  v309);
                    v228 = (uint8_t *)v227;
                    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types: :FallCancelReason)",  "%s\n",  v227);
                    if (v228 != buf) {
                      free(v228);
                    }
                  }

                  uint64_t v118 = sub_1008D9630();
                  sub_1007387E4(v118);
                  if ((a4 & 0x800000000000LL) == 0)
                  {
LABEL_500:
                    uint64_t v123 = (a4 >> 50) & 1;
                    if ((a4 & 0x4000000000000LL) != 0)
                    {
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      int v124 = (os_log_s *)qword_1019345D8;
                      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                      {
                        *(_WORD *)__int128 buf = 0;
                        _os_log_impl( (void *)&_mh_execute_header,  v124,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseUserResponse",  buf,  2u);
                      }

                      if (sub_1002921D0(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_1019345D0 != -1) {
                          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                        }
                        LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                        LODWORD(v309) = 2;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseUserResponse",  &v310,  v309);
                        v296 = (uint8_t *)v295;
                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Ty pes::FallCancelReason)",  "%s\n",  v295);
                        if (v296 != buf) {
                          free(v296);
                        }
                      }

                      uint64_t v125 = sub_1008D9630();
                      sub_1007388F0(v125);
                      if ((a4 & 0x8000000000000LL) == 0)
                      {
LABEL_502:
                        if ((a4 & 0x10000000000000LL) == 0) {
                          goto LABEL_503;
                        }
                        goto LABEL_520;
                      }
                    }

                    else if ((a4 & 0x8000000000000LL) == 0)
                    {
                      goto LABEL_502;
                    }

                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    int v126 = (os_log_s *)qword_1019345D8;
                    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseOffWrist",  buf,  2u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                      LODWORD(v309) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseOffWrist",  &v310,  v309);
                      v298 = (uint8_t *)v297;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Type s::FallCancelReason)",  "%s\n",  v297);
                      if (v298 != buf) {
                        free(v298);
                      }
                    }

                    uint64_t v127 = sub_1008D9630();
                    sub_10073894C(v127);
                    LODWORD(v123) = 1;
                    if ((a4 & 0x10000000000000LL) == 0)
                    {
LABEL_503:
                      if ((a4 & 0x20000000000000LL) == 0) {
                        goto LABEL_504;
                      }
                      goto LABEL_526;
                    }

          *(_DWORD *)(a1 + 14_Block_object_dispose(va, 8) = v154;
          goto LABEL_544;
        case 0x12u:
          *(_DWORD *)(a1 + 212) |= 0x100000u;
          char v157 = *((void *)this + 1);
          v158 = *((void *)this + 2);
          __int16 v159 = *(void *)this;
          if (v157 <= 0xFFFFFFFFFFFFFFF5LL && v157 + 10 <= v158)
          {
            double v160 = 0;
            v161 = 0;
            v162 = 0LL;
            do
            {
              double v163 = v157 + 1;
              *((void *)this + 1) = v157 + 1;
              v164 = *(_BYTE *)(v159 + v157);
              v162 |= (unint64_t)(v164 & 0x7F) << v160;
              if ((v164 & 0x80) == 0) {
                goto LABEL_486;
              }
              v160 += 7;
              char v157 = v163;
              uint64_t v22 = v161++ > 8;
            }

            while (!v22);
LABEL_346:
            LODWORD(v162) = 0;
            goto LABEL_486;
          }

          v292 = 0;
          v293 = 0;
          v162 = 0LL;
          if (v158 <= v157) {
            v158 = *((void *)this + 1);
          }
          while (2)
          {
            if (v158 == v157)
            {
              LODWORD(v162) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              v294 = v157 + 1;
              v295 = *(_BYTE *)(v159 + v157);
              *((void *)this + 1) = v294;
              v162 |= (unint64_t)(v295 & 0x7F) << v292;
              if (v295 < 0)
              {
                v292 += 7;
                char v157 = v294;
                uint64_t v22 = v293++ > 8;
                if (v22) {
                  goto LABEL_346;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v162) = 0;
              }
            }

            break;
          }

LABEL_520:
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    int v128 = (os_log_s *)qword_1019345D8;
                    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseStand",  buf,  2u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                      LODWORD(v309) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseStand",  &v310,  v309);
                      v300 = (uint8_t *)v299;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Type s::FallCancelReason)",  "%s\n",  v299);
                      if (v300 != buf) {
                        free(v300);
                      }
                    }

                    uint64_t v129 = sub_1008D9630();
                    sub_1007389A8(v129);
                    LODWORD(v123) = 1;
                    if ((a4 & 0x20000000000000LL) == 0)
                    {
LABEL_504:
                      if ((a4 & 0x40000000000000LL) == 0) {
                        goto LABEL_505;
                      }
                      goto LABEL_532;
                    }

LABEL_526:
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    int v130 = (os_log_s *)qword_1019345D8;
                    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseActive",  buf,  2u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                      LODWORD(v309) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseActive",  &v310,  v309);
                      v302 = (uint8_t *)v301;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Type s::FallCancelReason)",  "%s\n",  v301);
                      if (v302 != buf) {
                        free(v302);
                      }
                    }

                    uint64_t v131 = sub_1008D9630();
                    sub_1007389FC(v131);
                    LODWORD(v123) = 1;
                    if ((a4 & 0x40000000000000LL) == 0)
                    {
LABEL_505:
                      if ((a4 & 0x80000000000000LL) == 0)
                      {
                        if (!(_DWORD)v123) {
                          return;
                        }
                        goto LABEL_544;
                      }

LABEL_538:
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      int v134 = (os_log_s *)qword_1019345D8;
                      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                      {
                        *(_WORD *)__int128 buf = 0;
                        _os_log_impl( (void *)&_mh_execute_header,  v134,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseAbsenceOfLongLie",  buf,  2u);
                      }

                      if (sub_1002921D0(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_1019345D0 != -1) {
                          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                        }
                        LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                        LODWORD(v309) = 2;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseAbsenceOfLongLie",  &v310,  v309);
                        v306 = (uint8_t *)v305;
                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Ty pes::FallCancelReason)",  "%s\n",  v305);
                        if (v306 != buf) {
                          free(v306);
                        }
                      }

                      uint64_t v135 = sub_1008D9630();
                      sub_100738AB4(v135);
LABEL_544:
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      int v136 = (os_log_s *)qword_1019345D8;
                      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                      {
                        *(_WORD *)__int128 buf = 0;
                        _os_log_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledAggregate",  buf,  2u);
                      }

                      if (sub_1002921D0(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_1019345D0 != -1) {
                          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                        }
                        LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                        LODWORD(v309) = 2;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledAggregate",  &v310,  v309);
                        v230 = (uint8_t *)v229;
                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Ty pes::FallCancelReason)",  "%s\n",  v229);
                        if (v230 != buf) {
                          free(v230);
                        }
                      }

                      uint64_t v137 = sub_1008D9630();
                      sub_100738B10(v137);
                      return;
                    }

LABEL_532:
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    int v132 = (os_log_s *)qword_1019345D8;
                    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseSteps",  buf,  2u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1019345D0 != -1) {
                        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                      }
                      LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                      LODWORD(v309) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseSteps",  &v310,  v309);
                      v304 = (uint8_t *)v303;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Type s::FallCancelReason)",  "%s\n",  v303);
                      if (v304 != buf) {
                        free(v304);
                      }
                    }

                    uint64_t v133 = sub_1008D9630();
                    sub_100738A58(v133);
                    if ((a4 & 0x80000000000000LL) == 0) {
                      goto LABEL_544;
                    }
                    goto LABEL_538;
                  }

LABEL_489:
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  __int16 v119 = (os_log_s *)qword_1019345D8;
                  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledBecauseOfReferee",  buf,  2u);
                  }

                  if (sub_1002921D0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                    LODWORD(v309) = 2;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledBecauseOfReferee",  &v310,  v309);
                    v292 = (uint8_t *)v291;
                    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types: :FallCancelReason)",  "%s\n",  v291);
                    if (v292 != buf) {
                      free(v292);
                    }
                  }

                  uint64_t v120 = sub_1008D9630();
                  sub_100738840(v120);
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  __int16 v121 = (os_log_s *)qword_1019345D8;
                  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledAggregate",  buf,  2u);
                  }

                  if (sub_1002921D0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1019345D0 != -1) {
                      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                    }
                    LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                    LODWORD(v309) = 2;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledAggregate",  &v310,  v309);
                    v294 = (uint8_t *)v293;
                    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types: :FallCancelReason)",  "%s\n",  v293);
                    if (v294 != buf) {
                      free(v294);
                    }
                  }

                  uint64_t v122 = sub_1008D9630();
                  sub_100738894(v122);
                  goto LABEL_500;
                }

          *(_DWORD *)(a1 + 192) = v171;
          goto LABEL_544;
        case 0x15u:
          *(_DWORD *)(a1 + 212) |= 0x20u;
          double v174 = *((void *)this + 1);
          __int16 v175 = *((void *)this + 2);
          double v176 = *(void *)this;
          if (v174 <= 0xFFFFFFFFFFFFFFF5LL && v174 + 10 <= v175)
          {
            __int16 v177 = 0;
            double v178 = 0;
            __int16 v179 = 0LL;
            do
            {
              double v180 = v174 + 1;
              *((void *)this + 1) = v174 + 1;
              __int16 v181 = *(_BYTE *)(v176 + v174);
              v179 |= (unint64_t)(v181 & 0x7F) << v177;
              if ((v181 & 0x80) == 0) {
                goto LABEL_492;
              }
              v177 += 7;
              double v174 = v180;
              uint64_t v22 = v178++ > 8;
            }

            while (!v22);
LABEL_360:
            LODWORD(v179) = 0;
            goto LABEL_492;
          }

          v300 = 0;
          v301 = 0;
          __int16 v179 = 0LL;
          if (v175 <= v174) {
            __int16 v175 = *((void *)this + 1);
          }
          while (2)
          {
            if (v175 == v174)
            {
              LODWORD(v179) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              v302 = v174 + 1;
              v303 = *(_BYTE *)(v176 + v174);
              *((void *)this + 1) = v302;
              v179 |= (unint64_t)(v303 & 0x7F) << v300;
              if (v303 < 0)
              {
                v300 += 7;
                double v174 = v302;
                uint64_t v22 = v301++ > 8;
                if (v22) {
                  goto LABEL_360;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v179) = 0;
              }
            }

            break;
          }

LABEL_477:
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                __int16 v115 = (os_log_s *)qword_1019345D8;
                if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)__int128 buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v115,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceCyclingPostImpact",  buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                  LODWORD(v309) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceCyclingPostImpact",  &v310,  v309);
                  v290 = (uint8_t *)v289;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::F allCancelReason)",  "%s\n",  v289);
                  if (v290 != buf) {
                    free(v290);
                  }
                }

                uint64_t v116 = sub_1008D9630();
                sub_100738788(v116);
                goto LABEL_483;
              }

          *(_DWORD *)(a1 + 156) = v138;
          goto LABEL_544;
        case 0x10u:
          *(_DWORD *)(a1 + 212) |= 0x4000u;
          __int16 v141 = *((void *)this + 1);
          int v142 = *((void *)this + 2);
          __int16 v143 = *(void *)this;
          if (v141 <= 0xFFFFFFFFFFFFFFF5LL && v141 + 10 <= v142)
          {
            int v144 = 0;
            __int16 v145 = 0;
            int v146 = 0LL;
            do
            {
              __int16 v147 = v141 + 1;
              *((void *)this + 1) = v141 + 1;
              int v148 = *(_BYTE *)(v143 + v141);
              v146 |= (unint64_t)(v148 & 0x7F) << v144;
              if ((v148 & 0x80) == 0) {
                goto LABEL_480;
              }
              v144 += 7;
              __int16 v141 = v147;
              uint64_t v22 = v145++ > 8;
            }

            while (!v22);
LABEL_332:
            LODWORD(v146) = 0;
            goto LABEL_480;
          }

          v284 = 0;
          v285 = 0;
          int v146 = 0LL;
          if (v142 <= v141) {
            int v142 = *((void *)this + 1);
          }
          while (2)
          {
            if (v142 == v141)
            {
              LODWORD(v146) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              v286 = v141 + 1;
              v287 = *(_BYTE *)(v143 + v141);
              *((void *)this + 1) = v286;
              v146 |= (unint64_t)(v287 & 0x7F) << v284;
              if (v287 < 0)
              {
                v284 += 7;
                __int16 v141 = v286;
                uint64_t v22 = v285++ > 8;
                if (v22) {
                  goto LABEL_332;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v146) = 0;
              }
            }

            break;
          }

LABEL_471:
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v113 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceTraveledPostImpact",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceTraveledPostImpact",  &v310,  v309);
                v288 = (uint8_t *)v287;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v287);
                if (v288 != buf) {
                  free(v288);
                }
              }

              uint64_t v114 = sub_1008D9630();
              sub_10073872C(v114);
              if ((a4 & 0x10000000000LL) == 0) {
                goto LABEL_483;
              }
              goto LABEL_477;
            }

          *(_DWORD *)(a1 + 164) = v122;
          goto LABEL_544;
        case 0xEu:
          *(_DWORD *)(a1 + 212) |= 0x10000u;
          uint64_t v125 = *((void *)this + 1);
          int v126 = *((void *)this + 2);
          uint64_t v127 = *(void *)this;
          if (v125 <= 0xFFFFFFFFFFFFFFF5LL && v125 + 10 <= v126)
          {
            int v128 = 0;
            uint64_t v129 = 0;
            int v130 = 0LL;
            do
            {
              uint64_t v131 = v125 + 1;
              *((void *)this + 1) = v125 + 1;
              int v132 = *(_BYTE *)(v127 + v125);
              v130 |= (unint64_t)(v132 & 0x7F) << v128;
              if ((v132 & 0x80) == 0) {
                goto LABEL_474;
              }
              v128 += 7;
              uint64_t v125 = v131;
              uint64_t v22 = v129++ > 8;
            }

            while (!v22);
LABEL_318:
            LODWORD(v13sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
            goto LABEL_474;
          }

          v276 = 0;
          v277 = 0;
          int v130 = 0LL;
          if (v126 <= v125) {
            int v126 = *((void *)this + 1);
          }
          while (2)
          {
            if (v126 == v125)
            {
              LODWORD(v13sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              v278 = v125 + 1;
              v279 = *(_BYTE *)(v127 + v125);
              *((void *)this + 1) = v278;
              v130 |= (unint64_t)(v279 & 0x7F) << v276;
              if (v279 < 0)
              {
                v276 += 7;
                uint64_t v125 = v278;
                uint64_t v22 = v277++ > 8;
                if (v22) {
                  goto LABEL_318;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v13sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              }
            }

            break;
          }

          *(_DWORD *)(a1 + 336) = v31;
          goto LABEL_562;
        case 2u:
          *(_BYTE *)(a1 + 340) |= 4u;
          int v34 = *((void *)this + 1);
          if (v34 > 0xFFFFFFFFFFFFFFF7LL || v34 + 8 > *((void *)this + 2)) {
            goto LABEL_558;
          }
          *(void *)(a1 + 312) = *(void *)(*(void *)this + v34);
          goto LABEL_560;
        case 3u:
          *(_BYTE *)(a1 + 340) |= 1u;
          uint64_t v35 = *((void *)this + 1);
          if (v35 > 0xFFFFFFFFFFFFFFF7LL || v35 + 8 > *((void *)this + 2)) {
            goto LABEL_558;
          }
          *(void *)(a1 + 296) = *(void *)(*(void *)this + v35);
          goto LABEL_560;
        case 4u:
          *(_BYTE *)(a1 + 340) |= 8u;
          uint64_t v36 = *((void *)this + 1);
          if (v36 > 0xFFFFFFFFFFFFFFF7LL || v36 + 8 > *((void *)this + 2)) {
            goto LABEL_558;
          }
          *(void *)(a1 + 32sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)(*(void *)this + v36);
          goto LABEL_560;
        case 5u:
          *(_BYTE *)(a1 + 340) |= 2u;
          uint64_t v37 = *((void *)this + 1);
          if (v37 > 0xFFFFFFFFFFFFFFF7LL || v37 + 8 > *((void *)this + 2)) {
            goto LABEL_558;
          }
          *(void *)(a1 + 304) = *(void *)(*(void *)this + v37);
          goto LABEL_560;
        case 6u:
          if ((_DWORD)v25 != 2)
          {
            int v214 = *(char **)(a1 + 184);
            __int16 v213 = *(void *)(a1 + 192);
            if ((unint64_t)v214 >= v213)
            {
              v238 = (char *)*v12;
              v239 = (v214 - (_BYTE *)*v12) >> 3;
              v240 = v239 + 1;
              if ((unint64_t)(v239 + 1) >> 61) {
LABEL_572:
              }
                sub_100007008();
              v241 = v213 - (void)v238;
              if (v241 >> 2 > v240) {
                v240 = v241 >> 2;
              }
              else {
                v242 = v240;
              }
              if (v242)
              {
                v243 = (char *)sub_1000071BC(v337, v242);
                v238 = *(char **)(a1 + 176);
                int v214 = *(char **)(a1 + 184);
              }

              else
              {
                v243 = 0LL;
              }

              int v310 = &v243[8 * v239];
              *(void *)int v310 = 0LL;
              __int16 v215 = v310 + 8;
              while (v214 != v238)
              {
                v311 = *((void *)v214 - 1);
                v214 -= 8;
                *((void *)v310 - 1) = v311;
                v310 -= 8;
              }

              *(void *)(a1 + 176) = v310;
              *(void *)(a1 + 184) = v215;
              *(void *)(a1 + 192) = &v243[8 * v242];
              if (v238) {
                operator delete(v238);
              }
            }

            else
            {
              *(void *)int v214 = 0LL;
              __int16 v215 = v214 + 8;
            }

            *(void *)(a1 + 184) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          double v38 = *((void *)this + 1);
          uint64_t v39 = *((void *)this + 2);
          while (v38 < v39 && !*((_BYTE *)this + 24))
          {
            uint64_t v41 = *(char **)(a1 + 184);
            double v40 = *(void *)(a1 + 192);
            if ((unint64_t)v41 >= v40)
            {
              uint64_t v43 = (char *)*v12;
              double v44 = (v41 - (_BYTE *)*v12) >> 3;
              uint64_t v45 = v44 + 1;
              uint64_t v46 = v40 - (void)v43;
              if (v46 >> 2 > v45) {
                uint64_t v45 = v46 >> 2;
              }
              else {
                uint64_t v47 = v45;
              }
              if (v47)
              {
                uint64_t v48 = (char *)sub_1000071BC(v337, v47);
                uint64_t v43 = *(char **)(a1 + 176);
                uint64_t v41 = *(char **)(a1 + 184);
              }

              else
              {
                uint64_t v48 = 0LL;
              }

              uint64_t v49 = &v48[8 * v44];
              *(void *)uint64_t v49 = 0LL;
              double v42 = v49 + 8;
              while (v41 != v43)
              {
                uint64_t v50 = *((void *)v41 - 1);
                v41 -= 8;
                *((void *)v49 - 1) = v50;
                v49 -= 8;
              }

              *(void *)(a1 + 176) = v49;
              *(void *)(a1 + 184) = v42;
              *(void *)(a1 + 192) = &v48[8 * v47];
              if (v43) {
                operator delete(v43);
              }
            }

            else
            {
              *(void *)uint64_t v41 = 0LL;
              double v42 = v41 + 8;
            }

            *(void *)(a1 + 184) = v42;
            uint64_t v51 = *((void *)this + 1);
            if (v51 > 0xFFFFFFFFFFFFFFF7LL || v51 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v42 - 1) = *(void *)(*(void *)this + v51);
            uint64_t v39 = *((void *)this + 2);
            double v38 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v38;
          }

          goto LABEL_333;
        case 7u:
          if ((_DWORD)v25 != 2)
          {
            v217 = *(char **)(a1 + 112);
            uint64_t v216 = *(void *)(a1 + 120);
            if ((unint64_t)v217 >= v216)
            {
              v244 = (char *)*v11;
              v245 = (v217 - (_BYTE *)*v11) >> 3;
              v246 = v245 + 1;
              if ((unint64_t)(v245 + 1) >> 61) {
LABEL_573:
              }
                sub_100007008();
              v247 = v216 - (void)v244;
              if (v247 >> 2 > v246) {
                v246 = v247 >> 2;
              }
              else {
                v248 = v246;
              }
              if (v248)
              {
                v249 = (char *)sub_1000071BC(v338, v248);
                v244 = *(char **)(a1 + 104);
                v217 = *(char **)(a1 + 112);
              }

              else
              {
                v249 = 0LL;
              }

              __int16 v312 = &v249[8 * v245];
              *(void *)__int16 v312 = 0LL;
              __int16 v215 = v312 + 8;
              while (v217 != v244)
              {
                unsigned int v313 = *((void *)v217 - 1);
                v217 -= 8;
                *((void *)v312 - 1) = v313;
                v312 -= 8;
              }

              *(void *)(a1 + 104) = v312;
              *(void *)(a1 + sub_10000AE14(v2 - 112) = v215;
              *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = &v249[8 * v248];
              if (v244) {
                operator delete(v244);
              }
            }

            else
            {
              *(void *)v217 = 0LL;
              __int16 v215 = v217 + 8;
            }

            *(void *)(a1 + sub_10000AE14(v2 - 112) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          int v52 = *((void *)this + 1);
          uint64_t v53 = *((void *)this + 2);
          while (v52 < v53 && !*((_BYTE *)this + 24))
          {
            uint64_t v55 = *(char **)(a1 + 112);
            uint64_t v54 = *(void *)(a1 + 120);
            if ((unint64_t)v55 >= v54)
            {
              uint64_t v57 = (char *)*v11;
              uint64_t v58 = (v55 - (_BYTE *)*v11) >> 3;
              uint64_t v59 = v58 + 1;
              uint64_t v60 = v54 - (void)v57;
              if (v60 >> 2 > v59) {
                uint64_t v59 = v60 >> 2;
              }
              else {
                uint64_t v61 = v59;
              }
              if (v61)
              {
                uint64_t v62 = (char *)sub_1000071BC(v338, v61);
                uint64_t v57 = *(char **)(a1 + 104);
                uint64_t v55 = *(char **)(a1 + 112);
              }

              else
              {
                uint64_t v62 = 0LL;
              }

              float v63 = &v62[8 * v58];
              *(void *)float v63 = 0LL;
              uint64_t v56 = v63 + 8;
              while (v55 != v57)
              {
                uint64_t v64 = *((void *)v55 - 1);
                v55 -= 8;
                *((void *)v63 - 1) = v64;
                v63 -= 8;
              }

              *(void *)(a1 + 104) = v63;
              *(void *)(a1 + sub_10000AE14(v2 - 112) = v56;
              *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = &v62[8 * v61];
              if (v57) {
                operator delete(v57);
              }
            }

            else
            {
              *(void *)uint64_t v55 = 0LL;
              uint64_t v56 = v55 + 8;
            }

            *(void *)(a1 + sub_10000AE14(v2 - 112) = v56;
            double v65 = *((void *)this + 1);
            if (v65 > 0xFFFFFFFFFFFFFFF7LL || v65 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v56 - 1) = *(void *)(*(void *)this + v65);
            uint64_t v53 = *((void *)this + 2);
            int v52 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v52;
          }

          goto LABEL_333;
        case 8u:
          if ((_DWORD)v25 != 2)
          {
            v219 = *(char **)(a1 + 280);
            v218 = *(void *)(a1 + 288);
            if ((unint64_t)v219 >= v218)
            {
              v250 = (char *)*v10;
              v251 = (v219 - (_BYTE *)*v10) >> 3;
              v252 = v251 + 1;
              if ((unint64_t)(v251 + 1) >> 61) {
LABEL_574:
              }
                sub_100007008();
              v253 = v218 - (void)v250;
              if (v253 >> 2 > v252) {
                v252 = v253 >> 2;
              }
              else {
                v254 = v252;
              }
              if (v254)
              {
                v255 = (char *)sub_1000071BC(v339, v254);
                v250 = *(char **)(a1 + 272);
                v219 = *(char **)(a1 + 280);
              }

              else
              {
                v255 = 0LL;
              }

              __int16 v314 = &v255[8 * v251];
              *(void *)__int16 v314 = 0LL;
              __int16 v215 = v314 + 8;
              while (v219 != v250)
              {
                unint64_t v315 = *((void *)v219 - 1);
                v219 -= 8;
                *((void *)v314 - 1) = v315;
                v314 -= 8;
              }

              *(void *)(a1 + 272) = v314;
              *(void *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
              *(void *)(a1 + 28_Block_object_dispose(va, 8) = &v255[8 * v254];
              if (v250) {
                operator delete(v250);
              }
            }

            else
            {
              *(void *)v219 = 0LL;
              __int16 v215 = v219 + 8;
            }

            *(void *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          uint64_t v66 = *((void *)this + 1);
          double v67 = *((void *)this + 2);
          while (v66 < v67 && !*((_BYTE *)this + 24))
          {
            uint64_t v69 = *(char **)(a1 + 280);
            uint64_t v68 = *(void *)(a1 + 288);
            if ((unint64_t)v69 >= v68)
            {
              uint64_t v71 = (char *)*v10;
              uint64_t v72 = (v69 - (_BYTE *)*v10) >> 3;
              double v73 = v72 + 1;
              uint64_t v74 = v68 - (void)v71;
              if (v74 >> 2 > v73) {
                double v73 = v74 >> 2;
              }
              else {
                int v75 = v73;
              }
              if (v75)
              {
                double v76 = (char *)sub_1000071BC(v339, v75);
                uint64_t v71 = *(char **)(a1 + 272);
                uint64_t v69 = *(char **)(a1 + 280);
              }

              else
              {
                double v76 = 0LL;
              }

              uint64_t v77 = &v76[8 * v72];
              *(void *)uint64_t v77 = 0LL;
              uint64_t v70 = v77 + 8;
              while (v69 != v71)
              {
                double v78 = *((void *)v69 - 1);
                v69 -= 8;
                *((void *)v77 - 1) = v78;
                v77 -= 8;
              }

              *(void *)(a1 + 272) = v77;
              *(void *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v70;
              *(void *)(a1 + 28_Block_object_dispose(va, 8) = &v76[8 * v75];
              if (v71) {
                operator delete(v71);
              }
            }

            else
            {
              *(void *)uint64_t v69 = 0LL;
              uint64_t v70 = v69 + 8;
            }

            *(void *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v70;
            uint64_t v79 = *((void *)this + 1);
            if (v79 > 0xFFFFFFFFFFFFFFF7LL || v79 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v70 - 1) = *(void *)(*(void *)this + v79);
            double v67 = *((void *)this + 2);
            uint64_t v66 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v66;
          }

          goto LABEL_333;
        case 9u:
          if ((_DWORD)v25 != 2)
          {
            v221 = *(char **)(a1 + 16);
            v220 = *(void *)(a1 + 24);
            if ((unint64_t)v221 >= v220)
            {
              v256 = (char *)*v349;
              v257 = (v221 - (_BYTE *)*v349) >> 3;
              v258 = v257 + 1;
              if ((unint64_t)(v257 + 1) >> 61) {
LABEL_575:
              }
                sub_100007008();
              v259 = v220 - (void)v256;
              if (v259 >> 2 > v258) {
                v258 = v259 >> 2;
              }
              else {
                v260 = v258;
              }
              if (v260)
              {
                v261 = (char *)sub_1000071BC(v340, v260);
                v256 = *(char **)(a1 + 8);
                v221 = *(char **)(a1 + 16);
              }

              else
              {
                v261 = 0LL;
              }

              v316 = &v261[8 * v257];
              *(void *)v316 = 0LL;
              __int16 v215 = v316 + 8;
              while (v221 != v256)
              {
                v317 = *((void *)v221 - 1);
                v221 -= 8;
                *((void *)v316 - 1) = v317;
                v316 -= 8;
              }

              *(void *)(a1 + _Block_object_dispose(va, 8) = v316;
              *(void *)(a1 + sub_100708348(v2 - 16) = v215;
              *(void *)(a1 + sub_10000AE14(v9 + 24) = &v261[8 * v260];
              if (v256) {
                operator delete(v256);
              }
            }

            else
            {
              *(void *)v221 = 0LL;
              __int16 v215 = v221 + 8;
            }

            *(void *)(a1 + sub_100708348(v2 - 16) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          double v80 = *((void *)this + 1);
          uint64_t v81 = *((void *)this + 2);
          while (v80 < v81 && !*((_BYTE *)this + 24))
          {
            uint64_t v83 = *(char **)(a1 + 16);
            float32x4_t v82 = *(void *)(a1 + 24);
            if ((unint64_t)v83 >= v82)
            {
              uint64_t v85 = (char *)*v349;
              double v86 = (v83 - (_BYTE *)*v349) >> 3;
              uint64_t v87 = v86 + 1;
              double v88 = v82 - (void)v85;
              if (v88 >> 2 > v87) {
                uint64_t v87 = v88 >> 2;
              }
              else {
                uint64_t v89 = v87;
              }
              if (v89)
              {
                double v90 = (char *)sub_1000071BC(v340, v89);
                uint64_t v85 = *(char **)(a1 + 8);
                uint64_t v83 = *(char **)(a1 + 16);
              }

              else
              {
                double v90 = 0LL;
              }

              uint64_t v91 = &v90[8 * v86];
              *(void *)uint64_t v91 = 0LL;
              __int16 v84 = v91 + 8;
              while (v83 != v85)
              {
                double v92 = *((void *)v83 - 1);
                v83 -= 8;
                *((void *)v91 - 1) = v92;
                v91 -= 8;
              }

              *(void *)(a1 + _Block_object_dispose(va, 8) = v91;
              *(void *)(a1 + sub_100708348(v2 - 16) = v84;
              *(void *)(a1 + sub_10000AE14(v9 + 24) = &v90[8 * v89];
              if (v85) {
                operator delete(v85);
              }
            }

            else
            {
              *(void *)uint64_t v83 = 0LL;
              __int16 v84 = v83 + 8;
            }

            *(void *)(a1 + sub_100708348(v2 - 16) = v84;
            uint64_t v93 = *((void *)this + 1);
            if (v93 > 0xFFFFFFFFFFFFFFF7LL || v93 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v84 - 1) = *(void *)(*(void *)this + v93);
            uint64_t v81 = *((void *)this + 2);
            double v80 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v80;
          }

          goto LABEL_333;
        case 0xAu:
          if ((_DWORD)v25 != 2)
          {
            v223 = *(char **)(a1 + 232);
            v222 = *(void *)(a1 + 240);
            if ((unint64_t)v223 >= v222)
            {
              v262 = (char *)*v350;
              v263 = (v223 - (_BYTE *)*v350) >> 3;
              v264 = v263 + 1;
              if ((unint64_t)(v263 + 1) >> 61) {
LABEL_576:
              }
                sub_100007008();
              v265 = v222 - (void)v262;
              if (v265 >> 2 > v264) {
                v264 = v265 >> 2;
              }
              else {
                v266 = v264;
              }
              if (v266)
              {
                v267 = (char *)sub_1000071BC(v341, v266);
                v262 = *(char **)(a1 + 224);
                v223 = *(char **)(a1 + 232);
              }

              else
              {
                v267 = 0LL;
              }

              __int16 v318 = &v267[8 * v263];
              *(void *)__int16 v318 = 0LL;
              __int16 v215 = v318 + 8;
              while (v223 != v262)
              {
                unsigned int v319 = *((void *)v223 - 1);
                v223 -= 8;
                *((void *)v318 - 1) = v319;
                v318 -= 8;
              }

              *(void *)(a1 + 2sub_10000AE14(v9 + 24) = v318;
              *(void *)(a1 + 232) = v215;
              *(void *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = &v267[8 * v266];
              if (v262) {
                operator delete(v262);
              }
            }

            else
            {
              *(void *)v223 = 0LL;
              __int16 v215 = v223 + 8;
            }

            *(void *)(a1 + 232) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          uint64_t v94 = *((void *)this + 1);
          __int16 v95 = *((void *)this + 2);
          while (v94 < v95 && !*((_BYTE *)this + 24))
          {
            __int16 v97 = *(char **)(a1 + 232);
            uint64_t v96 = *(void *)(a1 + 240);
            if ((unint64_t)v97 >= v96)
            {
              __int16 v99 = (char *)*v350;
              uint64_t v100 = (v97 - (_BYTE *)*v350) >> 3;
              __int16 v101 = v100 + 1;
              uint64_t v102 = v96 - (void)v99;
              if (v102 >> 2 > v101) {
                __int16 v101 = v102 >> 2;
              }
              else {
                __int16 v103 = v101;
              }
              if (v103)
              {
                uint64_t v104 = (char *)sub_1000071BC(v341, v103);
                __int16 v99 = *(char **)(a1 + 224);
                __int16 v97 = *(char **)(a1 + 232);
              }

              else
              {
                uint64_t v104 = 0LL;
              }

              __int16 v105 = &v104[8 * v100];
              *(void *)__int16 v105 = 0LL;
              uint64_t v98 = v105 + 8;
              while (v97 != v99)
              {
                uint64_t v106 = *((void *)v97 - 1);
                v97 -= 8;
                *((void *)v105 - 1) = v106;
                v105 -= 8;
              }

              *(void *)(a1 + 2sub_10000AE14(v9 + 24) = v105;
              *(void *)(a1 + 232) = v98;
              *(void *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = &v104[8 * v103];
              if (v99) {
                operator delete(v99);
              }
            }

            else
            {
              *(void *)__int16 v97 = 0LL;
              uint64_t v98 = v97 + 8;
            }

            *(void *)(a1 + 232) = v98;
            __int16 v107 = *((void *)this + 1);
            if (v107 > 0xFFFFFFFFFFFFFFF7LL || v107 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v98 - 1) = *(void *)(*(void *)this + v107);
            __int16 v95 = *((void *)this + 2);
            uint64_t v94 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v94;
          }

          goto LABEL_333;
        case 0xBu:
          if ((_DWORD)v25 != 2)
          {
            v225 = *(char **)(a1 + 160);
            v224 = *(void *)(a1 + 168);
            if ((unint64_t)v225 >= v224)
            {
              v268 = (char *)*v351;
              v269 = (v225 - (_BYTE *)*v351) >> 3;
              v270 = v269 + 1;
              if ((unint64_t)(v269 + 1) >> 61) {
LABEL_577:
              }
                sub_100007008();
              v271 = v224 - (void)v268;
              if (v271 >> 2 > v270) {
                v270 = v271 >> 2;
              }
              else {
                v272 = v270;
              }
              if (v272)
              {
                v273 = (char *)sub_1000071BC(v342, v272);
                v268 = *(char **)(a1 + 152);
                v225 = *(char **)(a1 + 160);
              }

              else
              {
                v273 = 0LL;
              }

              __int16 v320 = &v273[8 * v269];
              *(void *)__int16 v320 = 0LL;
              __int16 v215 = v320 + 8;
              while (v225 != v268)
              {
                unint64_t v321 = *((void *)v225 - 1);
                v225 -= 8;
                *((void *)v320 - 1) = v321;
                v320 -= 8;
              }

              *(void *)(a1 + 152) = v320;
              *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
              *(void *)(a1 + 16_Block_object_dispose(va, 8) = &v273[8 * v272];
              if (v268) {
                operator delete(v268);
              }
            }

            else
            {
              *(void *)v225 = 0LL;
              __int16 v215 = v225 + 8;
            }

            *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          uint64_t v108 = *((void *)this + 1);
          __int16 v109 = *((void *)this + 2);
          while (v108 < v109 && !*((_BYTE *)this + 24))
          {
            __int16 v111 = *(char **)(a1 + 160);
            uint64_t v110 = *(void *)(a1 + 168);
            if ((unint64_t)v111 >= v110)
            {
              __int16 v113 = (char *)*v351;
              uint64_t v114 = (v111 - (_BYTE *)*v351) >> 3;
              __int16 v115 = v114 + 1;
              uint64_t v116 = v110 - (void)v113;
              if (v116 >> 2 > v115) {
                __int16 v115 = v116 >> 2;
              }
              else {
                __int16 v117 = v115;
              }
              if (v117)
              {
                uint64_t v118 = (char *)sub_1000071BC(v342, v117);
                __int16 v113 = *(char **)(a1 + 152);
                __int16 v111 = *(char **)(a1 + 160);
              }

              else
              {
                uint64_t v118 = 0LL;
              }

              __int16 v119 = &v118[8 * v114];
              *(void *)__int16 v119 = 0LL;
              uint64_t v112 = v119 + 8;
              while (v111 != v113)
              {
                uint64_t v120 = *((void *)v111 - 1);
                v111 -= 8;
                *((void *)v119 - 1) = v120;
                v119 -= 8;
              }

              *(void *)(a1 + 152) = v119;
              *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v112;
              *(void *)(a1 + 16_Block_object_dispose(va, 8) = &v118[8 * v117];
              if (v113) {
                operator delete(v113);
              }
            }

            else
            {
              *(void *)__int16 v111 = 0LL;
              uint64_t v112 = v111 + 8;
            }

            *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v112;
            __int16 v121 = *((void *)this + 1);
            if (v121 > 0xFFFFFFFFFFFFFFF7LL || v121 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v112 - 1) = *(void *)(*(void *)this + v121);
            __int16 v109 = *((void *)this + 2);
            uint64_t v108 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v108;
          }

          goto LABEL_333;
        case 0xCu:
          if ((_DWORD)v25 != 2)
          {
            v227 = *(char **)(a1 + 136);
            v226 = *(void *)(a1 + 144);
            if ((unint64_t)v227 >= v226)
            {
              v274 = (char *)*v352;
              v275 = (v227 - (_BYTE *)*v352) >> 3;
              v276 = v275 + 1;
              if ((unint64_t)(v275 + 1) >> 61) {
LABEL_578:
              }
                sub_100007008();
              v277 = v226 - (void)v274;
              if (v277 >> 2 > v276) {
                v276 = v277 >> 2;
              }
              else {
                v278 = v276;
              }
              if (v278)
              {
                v279 = (char *)sub_1000071BC(v343, v278);
                v274 = *(char **)(a1 + 128);
                v227 = *(char **)(a1 + 136);
              }

              else
              {
                v279 = 0LL;
              }

              v322 = &v279[8 * v275];
              *(void *)v322 = 0LL;
              __int16 v215 = v322 + 8;
              while (v227 != v274)
              {
                v323 = *((void *)v227 - 1);
                v227 -= 8;
                *((void *)v322 - 1) = v323;
                v322 -= 8;
              }

              *(void *)(a1 + 12_Block_object_dispose(va, 8) = v322;
              *(void *)(a1 + 136) = v215;
              *(void *)(a1 + 144) = &v279[8 * v278];
              if (v274) {
                operator delete(v274);
              }
            }

            else
            {
              *(void *)v227 = 0LL;
              __int16 v215 = v227 + 8;
            }

            *(void *)(a1 + 136) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          uint64_t v122 = *((void *)this + 1);
          uint64_t v123 = *((void *)this + 2);
          while (v122 < v123 && !*((_BYTE *)this + 24))
          {
            uint64_t v125 = *(char **)(a1 + 136);
            int v124 = *(void *)(a1 + 144);
            if ((unint64_t)v125 >= v124)
            {
              uint64_t v127 = (char *)*v352;
              int v128 = (v125 - (_BYTE *)*v352) >> 3;
              uint64_t v129 = v128 + 1;
              int v130 = v124 - (void)v127;
              if (v130 >> 2 > v129) {
                uint64_t v129 = v130 >> 2;
              }
              else {
                uint64_t v131 = v129;
              }
              if (v131)
              {
                int v132 = (char *)sub_1000071BC(v343, v131);
                uint64_t v127 = *(char **)(a1 + 128);
                uint64_t v125 = *(char **)(a1 + 136);
              }

              else
              {
                int v132 = 0LL;
              }

              uint64_t v133 = &v132[8 * v128];
              *(void *)uint64_t v133 = 0LL;
              int v126 = v133 + 8;
              while (v125 != v127)
              {
                int v134 = *((void *)v125 - 1);
                v125 -= 8;
                *((void *)v133 - 1) = v134;
                v133 -= 8;
              }

              *(void *)(a1 + 12_Block_object_dispose(va, 8) = v133;
              *(void *)(a1 + 136) = v126;
              *(void *)(a1 + 144) = &v132[8 * v131];
              if (v127) {
                operator delete(v127);
              }
            }

            else
            {
              *(void *)uint64_t v125 = 0LL;
              int v126 = v125 + 8;
            }

            *(void *)(a1 + 136) = v126;
            uint64_t v135 = *((void *)this + 1);
            if (v135 > 0xFFFFFFFFFFFFFFF7LL || v135 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v126 - 1) = *(void *)(*(void *)this + v135);
            uint64_t v123 = *((void *)this + 2);
            uint64_t v122 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v122;
          }

          goto LABEL_333;
        case 0xDu:
          if ((_DWORD)v25 != 2)
          {
            v229 = *(char **)(a1 + 256);
            v228 = *(void *)(a1 + 264);
            if ((unint64_t)v229 >= v228)
            {
              v280 = (char *)*v353;
              v281 = (v229 - (_BYTE *)*v353) >> 3;
              v282 = v281 + 1;
              if ((unint64_t)(v281 + 1) >> 61) {
LABEL_579:
              }
                sub_100007008();
              v283 = v228 - (void)v280;
              if (v283 >> 2 > v282) {
                v282 = v283 >> 2;
              }
              else {
                v284 = v282;
              }
              if (v284)
              {
                v285 = (char *)sub_1000071BC(v344, v284);
                v280 = *(char **)(a1 + 248);
                v229 = *(char **)(a1 + 256);
              }

              else
              {
                v285 = 0LL;
              }

              v324 = &v285[8 * v281];
              *(void *)v324 = 0LL;
              __int16 v215 = v324 + 8;
              while (v229 != v280)
              {
                v325 = *((void *)v229 - 1);
                v229 -= 8;
                *((void *)v324 - 1) = v325;
                v324 -= 8;
              }

              *(void *)(a1 + 24_Block_object_dispose(va, 8) = v324;
              *(void *)(a1 + 256) = v215;
              *(void *)(a1 + 264) = &v285[8 * v284];
              if (v280) {
                operator delete(v280);
              }
            }

            else
            {
              *(void *)v229 = 0LL;
              __int16 v215 = v229 + 8;
            }

            *(void *)(a1 + 256) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          int v136 = *((void *)this + 1);
          uint64_t v137 = *((void *)this + 2);
          while (v136 < v137 && !*((_BYTE *)this + 24))
          {
            __int16 v139 = *(char **)(a1 + 256);
            int v138 = *(void *)(a1 + 264);
            if ((unint64_t)v139 >= v138)
            {
              __int16 v141 = (char *)*v353;
              int v142 = (v139 - (_BYTE *)*v353) >> 3;
              __int16 v143 = v142 + 1;
              int v144 = v138 - (void)v141;
              if (v144 >> 2 > v143) {
                __int16 v143 = v144 >> 2;
              }
              else {
                __int16 v145 = v143;
              }
              if (v145)
              {
                int v146 = (char *)sub_1000071BC(v344, v145);
                __int16 v141 = *(char **)(a1 + 248);
                __int16 v139 = *(char **)(a1 + 256);
              }

              else
              {
                int v146 = 0LL;
              }

              __int16 v147 = &v146[8 * v142];
              *(void *)__int16 v147 = 0LL;
              int v140 = v147 + 8;
              while (v139 != v141)
              {
                int v148 = *((void *)v139 - 1);
                v139 -= 8;
                *((void *)v147 - 1) = v148;
                v147 -= 8;
              }

              *(void *)(a1 + 24_Block_object_dispose(va, 8) = v147;
              *(void *)(a1 + 256) = v140;
              *(void *)(a1 + 264) = &v146[8 * v145];
              if (v141) {
                operator delete(v141);
              }
            }

            else
            {
              *(void *)__int16 v139 = 0LL;
              int v140 = v139 + 8;
            }

            *(void *)(a1 + 256) = v140;
            __int16 v149 = *((void *)this + 1);
            if (v149 > 0xFFFFFFFFFFFFFFF7LL || v149 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v140 - 1) = *(void *)(*(void *)this + v149);
            uint64_t v137 = *((void *)this + 2);
            int v136 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v136;
          }

          goto LABEL_333;
        case 0xEu:
          if ((_DWORD)v25 != 2)
          {
            v231 = *(char **)(a1 + 40);
            v230 = *(void *)(a1 + 48);
            if ((unint64_t)v231 >= v230)
            {
              v286 = (char *)*v354;
              v287 = (v231 - (_BYTE *)*v354) >> 3;
              v288 = v287 + 1;
              if ((unint64_t)(v287 + 1) >> 61) {
LABEL_580:
              }
                sub_100007008();
              v289 = v230 - (void)v286;
              if (v289 >> 2 > v288) {
                v288 = v289 >> 2;
              }
              else {
                v290 = v288;
              }
              if (v290)
              {
                v291 = (char *)sub_1000071BC(v345, v290);
                v286 = *(char **)(a1 + 32);
                v231 = *(char **)(a1 + 40);
              }

              else
              {
                v291 = 0LL;
              }

              v326 = &v291[8 * v287];
              *(void *)v326 = 0LL;
              __int16 v215 = v326 + 8;
              while (v231 != v286)
              {
                v327 = *((void *)v231 - 1);
                v231 -= 8;
                *((void *)v326 - 1) = v327;
                v326 -= 8;
              }

              *(void *)(a1 + 32) = v326;
              *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
              *(void *)(a1 + 4_Block_object_dispose(va, 8) = &v291[8 * v290];
              if (v286) {
                operator delete(v286);
              }
            }

            else
            {
              *(void *)v231 = 0LL;
              __int16 v215 = v231 + 8;
            }

            *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          int v150 = *((void *)this + 1);
          __int16 v151 = *((void *)this + 2);
          while (v150 < v151 && !*((_BYTE *)this + 24))
          {
            __int16 v153 = *(char **)(a1 + 40);
            int v152 = *(void *)(a1 + 48);
            if ((unint64_t)v153 >= v152)
            {
              uint64_t v155 = (char *)*v354;
              uint64_t v156 = (v153 - (_BYTE *)*v354) >> 3;
              char v157 = v156 + 1;
              v158 = v152 - (void)v155;
              if (v158 >> 2 > v157) {
                char v157 = v158 >> 2;
              }
              else {
                __int16 v159 = v157;
              }
              if (v159)
              {
                double v160 = (char *)sub_1000071BC(v345, v159);
                uint64_t v155 = *(char **)(a1 + 32);
                __int16 v153 = *(char **)(a1 + 40);
              }

              else
              {
                double v160 = 0LL;
              }

              v161 = &v160[8 * v156];
              *(void *)v161 = 0LL;
              double v154 = v161 + 8;
              while (v153 != v155)
              {
                v162 = *((void *)v153 - 1);
                v153 -= 8;
                *((void *)v161 - 1) = v162;
                v161 -= 8;
              }

              *(void *)(a1 + 32) = v161;
              *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v154;
              *(void *)(a1 + 4_Block_object_dispose(va, 8) = &v160[8 * v159];
              if (v155) {
                operator delete(v155);
              }
            }

            else
            {
              *(void *)__int16 v153 = 0LL;
              double v154 = v153 + 8;
            }

            *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v154;
            double v163 = *((void *)this + 1);
            if (v163 > 0xFFFFFFFFFFFFFFF7LL || v163 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v154 - 1) = *(void *)(*(void *)this + v163);
            __int16 v151 = *((void *)this + 2);
            int v150 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v150;
          }

          goto LABEL_333;
        case 0xFu:
          if ((_DWORD)v25 != 2)
          {
            v233 = *(char **)(a1 + 208);
            v232 = *(void *)(a1 + 216);
            if ((unint64_t)v233 >= v232)
            {
              v292 = (char *)*v355;
              v293 = (v233 - (_BYTE *)*v355) >> 3;
              v294 = v293 + 1;
              if ((unint64_t)(v293 + 1) >> 61) {
LABEL_581:
              }
                sub_100007008();
              v295 = v232 - (void)v292;
              if (v295 >> 2 > v294) {
                v294 = v295 >> 2;
              }
              else {
                v296 = v294;
              }
              if (v296)
              {
                v297 = (char *)sub_1000071BC(v346, v296);
                v292 = *(char **)(a1 + 200);
                v233 = *(char **)(a1 + 208);
              }

              else
              {
                v297 = 0LL;
              }

              v328 = &v297[8 * v293];
              *(void *)v328 = 0LL;
              __int16 v215 = v328 + 8;
              while (v233 != v292)
              {
                v329 = *((void *)v233 - 1);
                v233 -= 8;
                *((void *)v328 - 1) = v329;
                v328 -= 8;
              }

              *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v328;
              *(void *)(a1 + 20_Block_object_dispose(va, 8) = v215;
              *(void *)(a1 + 2sub_100708348(v2 - 16) = &v297[8 * v296];
              if (v292) {
                operator delete(v292);
              }
            }

            else
            {
              *(void *)v233 = 0LL;
              __int16 v215 = v233 + 8;
            }

            *(void *)(a1 + 20_Block_object_dispose(va, 8) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          v164 = *((void *)this + 1);
          __int16 v165 = *((void *)this + 2);
          while (v164 < v165 && !*((_BYTE *)this + 24))
          {
            __int16 v167 = *(char **)(a1 + 208);
            double v166 = *(void *)(a1 + 216);
            if ((unint64_t)v167 >= v166)
            {
              __int16 v169 = (char *)*v355;
              double v170 = (v167 - (_BYTE *)*v355) >> 3;
              __int16 v171 = v170 + 1;
              double v172 = v166 - (void)v169;
              if (v172 >> 2 > v171) {
                __int16 v171 = v172 >> 2;
              }
              else {
                __int16 v173 = v171;
              }
              if (v173)
              {
                double v174 = (char *)sub_1000071BC(v346, v173);
                __int16 v169 = *(char **)(a1 + 200);
                __int16 v167 = *(char **)(a1 + 208);
              }

              else
              {
                double v174 = 0LL;
              }

              __int16 v175 = &v174[8 * v170];
              *(void *)__int16 v175 = 0LL;
              double v168 = v175 + 8;
              while (v167 != v169)
              {
                double v176 = *((void *)v167 - 1);
                v167 -= 8;
                *((void *)v175 - 1) = v176;
                v175 -= 8;
              }

              *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v175;
              *(void *)(a1 + 20_Block_object_dispose(va, 8) = v168;
              *(void *)(a1 + 2sub_100708348(v2 - 16) = &v174[8 * v173];
              if (v169) {
                operator delete(v169);
              }
            }

            else
            {
              *(void *)__int16 v167 = 0LL;
              double v168 = v167 + 8;
            }

            *(void *)(a1 + 20_Block_object_dispose(va, 8) = v168;
            __int16 v177 = *((void *)this + 1);
            if (v177 > 0xFFFFFFFFFFFFFFF7LL || v177 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v168 - 1) = *(void *)(*(void *)this + v177);
            __int16 v165 = *((void *)this + 2);
            v164 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v164;
          }

          goto LABEL_333;
        case 0x10u:
          if ((_DWORD)v25 != 2)
          {
            v235 = *(char **)(a1 + 88);
            v234 = *(void *)(a1 + 96);
            if ((unint64_t)v235 >= v234)
            {
              v298 = (char *)*v356;
              v299 = (v235 - (_BYTE *)*v356) >> 3;
              v300 = v299 + 1;
              if ((unint64_t)(v299 + 1) >> 61) {
LABEL_582:
              }
                sub_100007008();
              v301 = v234 - (void)v298;
              if (v301 >> 2 > v300) {
                v300 = v301 >> 2;
              }
              else {
                v302 = v300;
              }
              if (v302)
              {
                v303 = (char *)sub_1000071BC(v347, v302);
                v298 = *(char **)(a1 + 80);
                v235 = *(char **)(a1 + 88);
              }

              else
              {
                v303 = 0LL;
              }

              v330 = &v303[8 * v299];
              *(void *)v330 = 0LL;
              __int16 v215 = v330 + 8;
              while (v235 != v298)
              {
                v331 = *((void *)v235 - 1);
                v235 -= 8;
                *((void *)v330 - 1) = v331;
                v330 -= 8;
              }

              *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v330;
              *(void *)(a1 + 8_Block_object_dispose(va, 8) = v215;
              *(void *)(a1 + 96) = &v303[8 * v302];
              if (v298) {
                operator delete(v298);
              }
            }

            else
            {
              *(void *)v235 = 0LL;
              __int16 v215 = v235 + 8;
            }

            *(void *)(a1 + 8_Block_object_dispose(va, 8) = v215;
            goto LABEL_556;
          }

          if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
            return 0LL;
          }
          double v178 = *((void *)this + 1);
          __int16 v179 = *((void *)this + 2);
          while (v178 < v179 && !*((_BYTE *)this + 24))
          {
            __int16 v181 = *(char **)(a1 + 88);
            double v180 = *(void *)(a1 + 96);
            if ((unint64_t)v181 >= v180)
            {
              __int16 v183 = (char *)*v356;
              double v184 = (v181 - (_BYTE *)*v356) >> 3;
              __int16 v185 = v184 + 1;
              int v186 = v180 - (void)v183;
              if (v186 >> 2 > v185) {
                __int16 v185 = v186 >> 2;
              }
              else {
                __int16 v187 = v185;
              }
              if (v187)
              {
                int v188 = (char *)sub_1000071BC(v347, v187);
                __int16 v183 = *(char **)(a1 + 80);
                __int16 v181 = *(char **)(a1 + 88);
              }

              else
              {
                int v188 = 0LL;
              }

              __int16 v189 = &v188[8 * v184];
              *(void *)__int16 v189 = 0LL;
              double v182 = v189 + 8;
              while (v181 != v183)
              {
                int v190 = *((void *)v181 - 1);
                v181 -= 8;
                *((void *)v189 - 1) = v190;
                v189 -= 8;
              }

              *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v189;
              *(void *)(a1 + 8_Block_object_dispose(va, 8) = v182;
              *(void *)(a1 + 96) = &v188[8 * v187];
              if (v183) {
                operator delete(v183);
              }
            }

            else
            {
              *(void *)__int16 v181 = 0LL;
              double v182 = v181 + 8;
            }

            *(void *)(a1 + 8_Block_object_dispose(va, 8) = v182;
            __int16 v191 = *((void *)this + 1);
            if (v191 > 0xFFFFFFFFFFFFFFF7LL || v191 + 8 > *((void *)this + 2)) {
              goto LABEL_332;
            }
            *(v182 - 1) = *(void *)(*(void *)this + v191);
            __int16 v179 = *((void *)this + 2);
            double v178 = *((void *)this + 1) + 8LL;
            *((void *)this + 1) = v178;
          }

          goto LABEL_333;
        case 0x11u:
          if ((_DWORD)v25 == 2)
          {
            if ((PB::Reader::placeMark(this, v358, v25, a4) & 1) != 0) {
              return 0LL;
            }
            int v192 = *((void *)this + 1);
            __int16 v193 = *((void *)this + 2);
            while (v192 < v193 && !*((_BYTE *)this + 24))
            {
              __int16 v195 = *(char **)(a1 + 64);
              int v194 = *(void *)(a1 + 72);
              if ((unint64_t)v195 >= v194)
              {
                __int16 v197 = (char *)*v357;
                int v198 = (v195 - (_BYTE *)*v357) >> 3;
                __int16 v199 = v198 + 1;
                int v200 = v194 - (void)v197;
                if (v200 >> 2 > v199) {
                  __int16 v199 = v200 >> 2;
                }
                else {
                  __int16 v201 = v199;
                }
                if (v201)
                {
                  int v202 = (char *)sub_1000071BC(v348, v201);
                  __int16 v197 = *(char **)(a1 + 56);
                  __int16 v195 = *(char **)(a1 + 64);
                }

                else
                {
                  int v202 = 0LL;
                }

                __int16 v203 = &v202[8 * v198];
                *(void *)__int16 v203 = 0LL;
                int v196 = v203 + 8;
                while (v195 != v197)
                {
                  int v204 = *((void *)v195 - 1);
                  v195 -= 8;
                  *((void *)v203 - 1) = v204;
                  v203 -= 8;
                }

                *(void *)(a1 + 56) = v203;
                *(void *)(a1 + 64) = v196;
                *(void *)(a1 + 72) = &v202[8 * v201];
                if (v197) {
                  operator delete(v197);
                }
              }

              else
              {
                *(void *)__int16 v195 = 0LL;
                int v196 = v195 + 8;
              }

              *(void *)(a1 + 64) = v196;
              __int16 v205 = *((void *)this + 1);
              if (v205 > 0xFFFFFFFFFFFFFFF7LL || v205 + 8 > *((void *)this + 2))
              {
LABEL_332:
                *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
                break;
              }

              *(v196 - 1) = *(void *)(*(void *)this + v205);
              __int16 v193 = *((void *)this + 2);
              int v192 = *((void *)this + 1) + 8LL;
              *((void *)this + 1) = v192;
            }

            *(v171 - 1) = v237;
          }

LABEL_354:
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          double v80 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfPeaksIQR",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
            LODWORD(v309) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfPeaksIQR",  &v310,  v309);
            v258 = (uint8_t *)v257;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v257);
            if (v258 != buf) {
              free(v258);
            }
          }

          uint64_t v81 = sub_1008D9630();
          sub_10073818C(v81);
          int v75 = 1;
          goto LABEL_360;
        }

          *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v117;
          goto LABEL_313;
        case 0x1Eu:
          *(void *)(a1 + 212) |= 8uLL;
          uint64_t v120 = *((void *)this + 1);
          __int16 v121 = *((void *)this + 2);
          uint64_t v122 = *(void *)this;
          if (v120 <= 0xFFFFFFFFFFFFFFF5LL && v120 + 10 <= v121)
          {
            uint64_t v123 = 0;
            int v124 = 0;
            uint64_t v125 = 0LL;
            do
            {
              int v126 = v120 + 1;
              *((void *)this + 1) = v120 + 1;
              uint64_t v127 = *(_BYTE *)(v122 + v120);
              v125 |= (unint64_t)(v127 & 0x7F) << v123;
              if ((v127 & 0x80) == 0) {
                goto LABEL_358;
              }
              v123 += 7;
              uint64_t v120 = v126;
              BOOL v14 = v124++ > 8;
            }

            while (!v14);
LABEL_278:
            uint64_t v125 = 0LL;
            goto LABEL_358;
          }

          int v212 = 0;
          __int16 v213 = 0;
          uint64_t v125 = 0LL;
          if (v121 <= v120) {
            __int16 v121 = *((void *)this + 1);
          }
          while (2)
          {
            if (v121 == v120)
            {
              uint64_t v125 = 0LL;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              int v214 = v120 + 1;
              __int16 v215 = *(_BYTE *)(v122 + v120);
              *((void *)this + 1) = v214;
              v125 |= (unint64_t)(v215 & 0x7F) << v212;
              if (v215 < 0)
              {
                v212 += 7;
                uint64_t v120 = v214;
                BOOL v14 = v213++ > 8;
                if (v14) {
                  goto LABEL_278;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                uint64_t v125 = 0LL;
              }
            }

            break;
          }

LABEL_332:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        double v73 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLowFrequencyFFT",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
          LODWORD(v309) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLowFrequencyFFT",  &v310,  v309);
          v252 = (uint8_t *)v251;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v251);
          if (v252 != buf) {
            free(v252);
          }
        }

        uint64_t v74 = sub_1008D9630();
        sub_100738080(v74);
        int v52 = 1;
        goto LABEL_338;
      }

LABEL_314:
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      double v67 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfDisabledStateMachine",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v31sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
        LODWORD(v309) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfDisabledStateMachine",  &v310,  v309);
        v248 = (uint8_t *)v247;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v247);
        if (v248 != buf) {
          free(v248);
        }
      }

      uint64_t v68 = sub_1008D9630();
      sub_100737F74(v68);
      goto LABEL_320;
    }

  if ((v122 & 0x2000) != 0) {
    v4 += 3;
  }
  if ((v122 & 0x4000) != 0)
  {
    __int16 v165 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 372);
    if (v165 >= 0x80)
    {
      double v166 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v165, a2) + 2;
      uint64_t v122 = *(_DWORD *)(a1 + 400);
    }

    else
    {
      double v166 = 3;
    }

    v4 += v166;
  }

  if ((v122 & 0x8000) != 0)
  {
    __int16 v167 = *(void *)(a1 + 376);
    if (!v167) {
      __int16 v167 = *(void *)(qword_1019A1D38 + 376);
    }
    double v168 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_10061D594(v167, a2);
    __int16 v169 = (int)v168;
    else {
      double v170 = 1;
    }
    v4 += v169 + v170 + 2;
    uint64_t v122 = *(_DWORD *)(a1 + 400);
  }

          *(void *)(a1 + sub_10000AE14(v9 + 24) = v64;
          goto LABEL_294;
        case 0x13u:
          *(void *)(a1 + 216) |= 0x10uLL;
          double v67 = *((void *)this + 1);
          if (v67 > 0xFFFFFFFFFFFFFFFBLL || v67 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 36) = *(_DWORD *)(*(void *)this + v67);
          goto LABEL_293;
        case 0x14u:
          *(void *)(a1 + 216) |= 0x800000uLL;
          uint64_t v68 = *((void *)this + 1);
          if (v68 > 0xFFFFFFFFFFFFFFFBLL || v68 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + sub_10000AE14(v2 - 112) = *(_DWORD *)(*(void *)this + v68);
          goto LABEL_293;
        case 0x15u:
          *(void *)(a1 + 216) |= 0x80uLL;
          uint64_t v69 = *((void *)this + 1);
          if (v69 > 0xFFFFFFFFFFFFFFFBLL || v69 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_DWORD *)(*(void *)this + v69);
          goto LABEL_293;
        case 0x16u:
          *(void *)(a1 + 216) |= 0x40uLL;
          uint64_t v70 = *((void *)this + 1);
          if (v70 > 0xFFFFFFFFFFFFFFFBLL || v70 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(void *)this + v70);
          goto LABEL_293;
        case 0x17u:
          *(void *)(a1 + 216) |= 0x100000uLL;
          uint64_t v71 = *((void *)this + 1);
          if (v71 > 0xFFFFFFFFFFFFFFFBLL || v71 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 10sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)(*(void *)this + v71);
          goto LABEL_293;
        case 0x18u:
          *(void *)(a1 + 216) |= 0x80000uLL;
          uint64_t v72 = *((void *)this + 1);
          if (v72 > 0xFFFFFFFFFFFFFFFBLL || v72 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 96) = *(_DWORD *)(*(void *)this + v72);
          goto LABEL_293;
        case 0x19u:
          *(void *)(a1 + 216) |= 0x40000000uLL;
          double v73 = *((void *)this + 1);
          if (v73 > 0xFFFFFFFFFFFFFFFBLL || v73 + 4 > *((void *)this + 2)) {
            goto LABEL_214;
          }
          *(_DWORD *)(a1 + 14sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)(*(void *)this + v73);
          goto LABEL_293;
        case 0x1Au:
          *(void *)(a1 + 216) |= 0x1000uLL;
          uint64_t v74 = *((void *)this + 1);
          int v75 = *((void *)this + 2);
          double v76 = *(void *)this;
          if (v74 <= 0xFFFFFFFFFFFFFFF5LL && v74 + 10 <= v75)
          {
            uint64_t v77 = 0;
            double v78 = 0;
            uint64_t v79 = 0LL;
            do
            {
              double v80 = v74 + 1;
              *((void *)this + 1) = v74 + 1;
              uint64_t v81 = *(_BYTE *)(v76 + v74);
              v79 |= (unint64_t)(v81 & 0x7F) << v77;
              if ((v81 & 0x80) == 0) {
                goto LABEL_318;
              }
              v77 += 7;
              uint64_t v74 = v80;
              BOOL v14 = v78++ > 8;
            }

            while (!v14);
LABEL_249:
            LODWORD(v79) = 0;
            goto LABEL_318;
          }

          double v163 = 0;
          v164 = 0;
          uint64_t v79 = 0LL;
          if (v75 <= v74) {
            int v75 = *((void *)this + 1);
          }
          while (2)
          {
            if (v75 == v74)
            {
              LODWORD(v79) = 0;
              *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
            }

            else
            {
              __int16 v165 = v74 + 1;
              double v166 = *(_BYTE *)(v76 + v74);
              *((void *)this + 1) = v165;
              v79 |= (unint64_t)(v166 & 0x7F) << v163;
              if (v166 < 0)
              {
                v163 += 7;
                uint64_t v74 = v165;
                BOOL v14 = v164++ > 8;
                if (v14) {
                  goto LABEL_249;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v79) = 0;
              }
            }

            break;
          }

              *(void *)(a1 + 32) = v83;
              goto LABEL_282;
            case 0xDu:
              *(void *)(a1 + 164) |= 4uLL;
              double v86 = *((void *)this + 1);
              uint64_t v87 = *((void *)this + 2);
              double v88 = *(void *)this;
              if (v86 <= 0xFFFFFFFFFFFFFFF5LL && v86 + 10 <= v87)
              {
                uint64_t v89 = 0;
                double v90 = 0;
                uint64_t v91 = 0LL;
                do
                {
                  double v92 = v86 + 1;
                  *((void *)this + 1) = v86 + 1;
                  uint64_t v93 = *(_BYTE *)(v88 + v86);
                  v91 |= (unint64_t)(v93 & 0x7F) << v89;
                  if ((v93 & 0x80) == 0) {
                    goto LABEL_318;
                  }
                  v89 += 7;
                  double v86 = v92;
                  BOOL v14 = v90++ > 8;
                }

                while (!v14);
LABEL_237:
                uint64_t v91 = 0LL;
                goto LABEL_318;
              }

              double v184 = 0;
              __int16 v185 = 0;
              uint64_t v91 = 0LL;
              if (v87 <= v86) {
                uint64_t v87 = *((void *)this + 1);
              }
              while (2)
              {
                if (v87 == v86)
                {
                  uint64_t v91 = 0LL;
                  *((_BYTE *)this + sub_10000AE14(v9 + 24) = 1;
                }

                else
                {
                  int v186 = v86 + 1;
                  __int16 v187 = *(_BYTE *)(v88 + v86);
                  *((void *)this + 1) = v186;
                  v91 |= (unint64_t)(v187 & 0x7F) << v184;
                  if (v187 < 0)
                  {
                    v184 += 7;
                    double v86 = v186;
                    BOOL v14 = v185++ > 8;
                    if (v14) {
                      goto LABEL_237;
                    }
                    continue;
                  }

                  if (*((_BYTE *)this + 24)) {
                    uint64_t v91 = 0LL;
                  }
                }

                break;
              }

uint64_t sub_1007269F4()
{
  uint64_t result = objc_opt_class(&OBJC_CLASS___MCProfileConnection);
  if (result)
  {
    if (objc_msgSend( +[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"),  "isHealthDataSubmissionAllowed"))
    {
      return 1LL;
    }

    else
    {
      unsigned __int8 v1 = 0;
      sub_1012049AC(v2, "FallForceIHAOptIn", &v1, 0);
      return v2[1] != 0;
    }
  }

  return result;
}

unint64_t sub_100726A64(uint64_t a1)
{
  unint64_t result = sub_10071E52C();
  if ((_DWORD)result)
  {
    if (CFAbsoluteTimeGetCurrent() >= 654764400.0)
    {
      return 0LL;
    }

    else if ((sub_10071F09C() & 1) != 0 || (unint64_t result = sub_100726AD0(), (_DWORD)result))
    {
      unint64_t result = sub_1007269F4();
      if ((_DWORD)result) {
        return *(double *)(a1 + 248) <= 240.0;
      }
    }
  }

  return result;
}

uint64_t sub_100726AD0()
{
  unsigned __int8 v1 = 0;
  sub_1012049AC(v2, "FallStatsBackgroundSensorDataLoggingEnabled", &v1, 0);
  if (v2[1]) {
    return 1LL;
  }
  sub_1004F2598();
  if ((sub_1004F97F4() & 0x20000000000LL) != 0) {
    return sub_1007269F4();
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100726B2C()
{
  uint64_t result = sub_1004F8A40();
  if ((_DWORD)result)
  {
    unsigned __int8 v1 = 1;
    sub_1012049AC(v2, "FallStatsTapToRadarAllowedFall", &v1, 0);
    if (v2[1])
    {
      if ((sub_10071E178() & 1) != 0) {
        return 1LL;
      }
      else {
        return sub_1007269F4();
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100726B94()
{
  uint64_t result = sub_1004F8A40();
  if ((_DWORD)result)
  {
    unsigned __int8 v1 = 1;
    sub_1012049AC(v2, "FallStatsTapToRadarAllowedNearFall", &v1, 0);
    if (v2[1])
    {
      if ((sub_10071E178() & 1) != 0) {
        return 1LL;
      }
      else {
        return sub_1007269F4();
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100726BFC()
{
  unsigned __int8 v1 = 0;
  sub_1012049AC(v2, "FallStatsBackgroundAWDLoggingEnabled", &v1, 0);
  if (v2[1]) {
    return 1LL;
  }
  sub_1004F2598();
  if ((sub_1004F97F4() & 0x10000000000LL) != 0) {
    return sub_1007269F4();
  }
  else {
    return 0LL;
  }
}

BOOL sub_100726C58(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 444) && (sub_10071F09C() & 1) != 0) {
    return 1LL;
  }
  unsigned __int8 v2 = 0;
  sub_1012049AC(v3, "FallStatsEnabled", &v2, 0);
  return v3[1] != 0;
}

unint64_t sub_100726CB0()
{
  unint64_t result = sub_10071E52C();
  if ((_DWORD)result)
  {
    unint64_t result = sub_1007269F4();
    if ((_DWORD)result) {
      return sub_10071F09C() ^ 1;
    }
  }

  return result;
}

uint64_t sub_100726CD8(uint64_t a1)
{
  int v2 = sub_10071E178();
  if (sub_100726C58(a1)) {
    return v2 ^ 1u;
  }
  if (sub_100726C58(a1)) {
    return 0LL;
  }
  uint64_t result = sub_100726BFC();
  if ((_DWORD)result) {
    return v2 ^ 1u;
  }
  return result;
}

uint64_t sub_100726D28(uint64_t a1)
{
  if ((sub_100726A64(a1) & 1) != 0) {
    return 1LL;
  }
  unsigned __int8 v2 = 0;
  sub_1012049AC(v3, "FallStatsEnabled", &v2, 0);
  if (v3[1] || (sub_100726B2C() & 1) != 0) {
    return 1LL;
  }
  else {
    return sub_100726B94();
  }
}

uint64_t sub_100726D80(uint64_t a1, uint64_t a2, char a3)
{
  unsigned __int8 v17 = a3 & 1;
  BOOL v16 = (a3 & 2) != 0;
  uint64_t v5 = sub_1006E27E8();
  sub_100413284(v5, &v14);
  sub_1002AB3FC(v14, "FallStatsEnabled", &v17);
  uint64_t v6 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  uint64_t v9 = sub_1006E27E8();
  sub_100413284(v9, &v14);
  sub_1002AB3FC(v14, "FallStatsPressureEnabled", &v16);
  int v10 = v15;
  if (v15)
  {
    uint64_t v11 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return sub_100726E98(a1, a2, v17);
}

void sub_100726E80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100726E98(uint64_t a1, uint64_t a2, int a3)
{
  float v4 = *(void **)(a1 + 256);
  if (a3 == 1)
  {
    [v4 addObject:a2];
  }

  else
  {
    [v4 removeObject:a2];
    if (a3)
    {
      if (![*(id *)(a1 + 256) count])
      {
        [*(id *)(a1 + 136) clearAllLogs];
        [*(id *)(a1 + 168) clearLogs];
        [*(id *)(a1 + 176) clearLogs];
        [*(id *)(a1 + 184) clearLogs];
        [*(id *)(a1 + 192) clearLogs];
        [*(id *)(a1 + 200) clearLogs];
        [*(id *)(a1 + 208) clearLogs];
        [*(id *)(a1 + 216) clearLogs];
        [*(id *)(a1 + 224) clearLogs];
        [*(id *)(a1 + 232) clearLogs];
      }
    }

    else
    {
      [*(id *)(a1 + 136) stopLogging];
    }
  }

  if ([*(id *)(a1 + 256) count])
  {
    +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  +[NSSet setWithSet:](&OBJC_CLASS___NSSet, "setWithSet:", *(void *)(a1 + 256)),  1LL,  0LL);
    uint64_t v6 = sub_1002F8DDC();
    sub_1002AB3DC(v6);
  }

  else
  {
    uint64_t v9 = sub_1002F8DDC();
    sub_1002A66DC(v9);
    uint64_t v10 = sub_1006E27E8();
    sub_100413284(v10, &v22);
    sub_1002A667C(v22, "FallStatsEnabled", 0xFFFFFFFFLL);
    uint64_t v11 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    uint64_t v14 = sub_1006E27E8();
    sub_100413284(v14, &v22);
    sub_1002A667C(v22, "FallStatsPressureEnabled", 0xFFFFFFFFLL);
    float v15 = v23;
    if (v23)
    {
      BOOL v16 = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }

    uint64_t v18 = sub_1006E27E8();
    sub_100413284(v18, &v22);
    sub_1002A667C(v22, "AnomalyDetectorEnabledKey", 0xFFFFFFFFLL);
    uint64_t v19 = v23;
    if (v23)
    {
      float v20 = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }

  uint64_t v7 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v7 + 944LL))(v7);
  sub_1007275FC(a1, 0);
  return *(void *)(a1 + 7816);
}

void sub_1007270E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

NSDictionary *sub_1007270FC(uint64_t a1, void *a2)
{
  float v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v31 = 0LL;
  id v5 =  -[NSArray mutableCopy]( -[NSFileManager contentsOfDirectoryAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "contentsOfDirectoryAtPath:error:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  &v31),  "mutableCopy");
  if (v31)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138543362;
      uint64_t v37 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Unable to get contents of logging directory, error: %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v34 = 138543362;
      uint64_t v35 = v31;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  16LL,  "Unable to get contents of logging directory, error: %{public}@",  &v34,  12);
      uint64_t v26 = (uint8_t *)v25;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "NSDictionary *CLFallNotifier::moveFallStatsToFile(NSFileHandle *)",  "%s\n",  v25);
      if (v26 != buf) {
        free(v26);
      }
    }

    v32[0] = CMErrorMessage;
    v32[1] = CMReturnCode;
    v33[0] = &off_1018D3860;
    v33[1] = &__kCFBooleanFalse;
    return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v33,  v32,  2LL);
  }

  else
  {
    unint64_t v8 = v5;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    char v28 = sub_1007275B4;
    char v29 = &unk_10184D2C0;
    id v30 = v5;
    uint64_t v9 = *(void **)(a1 + 168);
    [v9 flushToFile];
    id v10 = [v9 currentFilename];
    if (v10) {
      [v8 removeObject:v10];
    }
    uint64_t v11 = *(void **)(a1 + 176);
    [v11 flushToFile];
    id v12 = [v11 currentFilename];
    if (v12) {
      [v8 removeObject:v12];
    }
    unint64_t v13 = *(void **)(a1 + 184);
    [v13 flushToFile];
    id v14 = [v13 currentFilename];
    if (v14) {
      [v8 removeObject:v14];
    }
    float v15 = *(void **)(a1 + 192);
    [v15 flushToFile];
    id v16 = [v15 currentFilename];
    if (v16) {
      [v8 removeObject:v16];
    }
    unint64_t v17 = *(void **)(a1 + 200);
    [v17 flushToFile];
    id v18 = [v17 currentFilename];
    if (v18) {
      [v8 removeObject:v18];
    }
    sub_1007275B4((uint64_t)v27, *(void **)(a1 + 208));
    v28((uint64_t)v27, *(void **)(a1 + 216));
    v28((uint64_t)v27, *(void **)(a1 + 224));
    v28((uint64_t)v27, *(void **)(a1 + 232));
    uint64_t v19 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v8 count]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  v19,  CMFallSetStatsNumberOfAvailableFiles);
    if ([v8 count])
    {
      id v20 = objc_msgSend( @"/var/root/Library/Caches/locationd/logs/newtonStats",  "stringByAppendingPathComponent:",  objc_msgSend(v8, "objectAtIndexedSubscript:", 0));
      unint64_t v21 = +[NSFileHandle fileHandleForReadingAtPath:](&OBJC_CLASS___NSFileHandle, "fileHandleForReadingAtPath:", v20);
      id v22 = +[CMMotionUtils copyDataFrom:to:](&OBJC_CLASS___CMMotionUtils, "copyDataFrom:to:", v21, a2);
      -[NSFileHandle closeFile](v21, "closeFile");
      [a2 closeFile];
      id v23 = [v8 objectAtIndexedSubscript:0];
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  v23,  CMFallSetStatsNameOfCurrentFile);
      float v24 = +[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v22);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  v24,  CMFallSetStatsSizeOfCurrentFile);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  CMReturnCode);
      -[NSFileManager removeItemAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtPath:error:",  v20,  0LL);
    }

    else
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  &__kCFBooleanFalse,  CMReturnCode);
    }

    return (NSDictionary *)-[NSMutableDictionary copy](v4, "copy");
  }

id sub_1007275B4(uint64_t a1, void *a2)
{
  id result = [a2 currentFilename];
  if (result) {
    return [*(id *)(a1 + 32) removeObject:result];
  }
  return result;
}

uint64_t sub_1007275FC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 7832) != v23)
  {
    if ((_BYTE)v23)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      __int128 v3 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Enabling Sensor Recorder", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v24[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  1LL,  "Enabling Sensor Recorder",  v24,  2);
        uint64_t v19 = (uint8_t *)v18;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMMotionCoprocessorCommand::Configure::FallStatsConfig CLFallNotifier::updateConfig(CMSPUFall_Types::SimulatedType)",  "%s\n",  v18);
        if (v19 != buf) {
          free(v19);
        }
      }

      sub_100729918(a1);
      [*(id *)(*(void *)(a1 + 10872) + 16) register:*(void *)(*(void *)(a1 + 10872) + 8) forNotification:4 registrationInfo:0];
    }

    else
    {
      [*(id *)(a1 + 160) cleanUp:0.0];
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      float v4 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Disabling Sensor Recorder", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v24[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  1LL,  "Disabling Sensor Recorder",  v24,  2);
        unint64_t v21 = (uint8_t *)v20;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMMotionCoprocessorCommand::Configure::FallStatsConfig CLFallNotifier::updateConfig(CMSPUFall_Types::SimulatedType)",  "%s\n",  v20);
        if (v21 != buf) {
          free(v21);
        }
      }

      sub_100729F60((id *)a1);
      [*(id *)(*(void *)(a1 + 10872) + 16) unregister:*(void *)(*(void *)(a1 + 10872) + 8) forNotification:4];
    }
  }

  if (!sub_10071F09C() || *(_BYTE *)(a1 + 445))
  {
    *(_OWORD *)(a1 + 78sub_100708348(v2 - 16) = v22;
    *(void *)(a1 + 7832) = v23;
    id v5 = (const void *)sub_1008FA854(0);
    if (v5)
    {
      if (v6) {
        sub_10035F798((uint64_t)v6, (__int128 *)(a1 + 7816));
      }
    }

    char v7 = sub_10071FC64(a1);
    sub_100DEACC0(a1 + 10568, v7);
    int v8 = sub_10071E52C();
    sub_100DEACC8(a1 + 10568, v8);
    int v9 = sub_10071E178();
    sub_100DEACE4(a1 + 10568, v9);
    int v10 = sub_100726CD8(a1);
    sub_100DEAD00(a1 + 10568, v10);
    int v11 = sub_1007269F4();
    sub_100DEAD1C(a1 + 10568, v11);
    sub_100DEADA0(a1 + 10568);
    int v12 = sub_100726CD8(a1);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    unint64_t v13 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v26 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "CLFitnessTrackingAllDayAWD: Updating didEnableBackgroundAllDayAnomalyDetection %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v24[0] = 67109120;
      v24[1] = v12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  1LL,  "CLFitnessTrackingAllDayAWD: Updating didEnableBackgroundAllDayAnomalyDetection %d",  v24);
      unint64_t v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMMotionCoprocessorCommand::Configure::FallStatsConfig CLFallNotifier::updateConfig(CMSPUFall_Types::SimulatedType)",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    uint64_t v14 = sub_1008D9630();
    sub_1008DB434(v14, v12);
  }

  return *(void *)(a1 + 7816);
}

void sub_100727B3C(uint64_t a1, uint64_t a2, char a3)
{
  if (!*(void *)(a2 + 19)) {
    return;
  }
  if (*(id *)(a2 + 19) == sub_100728FA8())
  {
    sub_10071F480(a1, a2, 6);
    return;
  }

  uint64_t v6 = (unsigned __int8 *)(a1 + 7608);
  if (*(unsigned __int8 *)(a2 + 157) - 1 <= 1)
  {
    __int128 v7 = *(_OWORD *)a2;
    __int128 v8 = *(_OWORD *)(a2 + 16);
    __int128 v9 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 6935) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 6951) = v9;
    *(_OWORD *)(a1 + 6903) = v7;
    *(_OWORD *)(a1 + 6919) = v8;
    __int128 v10 = *(_OWORD *)(a2 + 64);
    __int128 v11 = *(_OWORD *)(a2 + 80);
    __int128 v12 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 6999) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 7015) = v12;
    *(_OWORD *)(a1 + 6967) = v10;
    *(_OWORD *)(a1 + 6983) = v11;
    __int128 v13 = *(_OWORD *)(a2 + 128);
    __int128 v14 = *(_OWORD *)(a2 + 144);
    __int128 v15 = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 707_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 175);
    *(_OWORD *)(a1 + 7047) = v14;
    *(_OWORD *)(a1 + 7063) = v15;
    *(_OWORD *)(a1 + 7031) = v13;
  }

  float v16 = sub_100734D60((float *)(a2 + 27));
  if (*(_BYTE *)(a2 + 18) && *(_BYTE *)(a2 + 18) != 7)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    id v30 = (os_log_s *)qword_1019345D8;
    if (!os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_29;
    }
    int v31 = *v6;
    int v32 = *(unsigned __int8 *)(a1 + 7610);
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 1026;
    *(_DWORD *)&buf[20] = v31;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v32;
    char v33 = "{msg%{public}.0s:Skipping impact check against on/off wrist status and on/off charger for simulated even"
          "t, Received state:%{public}hhd, Gating enabled:%{public}hhd}";
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v33, buf, 0x1Eu);
    goto LABEL_29;
  }

  if (!*v6)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    id v30 = (os_log_s *)qword_1019345D8;
    if (!os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_29;
    }
    int v34 = *v6;
    int v35 = *(unsigned __int8 *)(a1 + 7610);
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 1026;
    *(_DWORD *)&buf[20] = v34;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v35;
    char v33 = "{msg%{public}.0s:Skipping impact check against on/off wrist status and on/off charger as we did not rece"
          "ive a state yet, Received state:%{public}hhd, Gating enabled:%{public}hhd}";
    goto LABEL_28;
  }

  double v17 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 7624);
  if (v17 <= 0.0) {
    double v18 = 0.0;
  }
  else {
    double v18 = v17;
  }
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v19 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v20 = *v6;
    int v21 = *(unsigned __int8 *)(a1 + 7610);
    BOOL v22 = *(_DWORD *)(a1 + 7640) != 0;
    *(_DWORD *)__int128 buf = 68290051;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 1026;
    *(_DWORD *)&buf[20] = v20;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v21;
    *(_WORD *)&buf[30] = 1025;
    *(_DWORD *)&uint8_t buf[32] = v22;
    *(_WORD *)&buf[36] = 2049;
    *(double *)&buf[38] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Checking impact against on/off wrist status, Received state:%{public}hhd, Gating en abled:%{public}hhd, status:%{private}hhd, duration:%{private}f}",  buf,  0x2Eu);
  }

  double v23 = *(double *)(a2 + 166);
  sub_101204164(buf, "FallOffWristLookbackBeforeImpactStartOfIntervalKey", &qword_101328780, 0);
  double v24 = *(double *)&buf[8];
  sub_101204164(buf, "FallOffWristLookbackBeforeImpactEndOfIntervalKey", &qword_1013287C0, 0);
  double v25 = *(double *)&buf[8];
  sub_101204164(buf, "FallOnWristAfterImpactStartOfIntervalKey", &qword_1013287F8, 0);
  double v26 = *(double *)&buf[8];
  sub_101204164(buf, "FallOnWristAfterImpactEndOfIntervalKey", &qword_101328828, 0);
  double v27 = *(double *)&buf[8];
  sub_101204164(buf, "FallLockedLookbackBeforeImpactStartOfIntervalKey", &qword_101328868, 0);
  double v28 = *(double *)&buf[8];
  sub_101204164(buf, "FallLockedLookbackBeforeImpactEndOfIntervalKey", &qword_1013288A0, 0);
  int v29 = sub_100F70A10(a1 + 7608, a2, v23, v24, v25, v26, v27, v28, *(double *)&buf[8]);
  switch(v29)
  {
    case 1:
      sub_100728FEC(*(void *)(a2 + 19));
      sub_10071F480(a1, a2, 9);
      return;
    case 3:
      sub_100728FEC(*(void *)(a2 + 19));
      sub_10071F480(a1, a2, 12);
      return;
    case 2:
      sub_100728FEC(*(void *)(a2 + 19));
      sub_10071F480(a1, a2, 10);
      return;
  }

  *(_DWORD *)double v76 = 25;
  sub_10023AE2C(buf, "FallMinimumOffChargerDurationKey", v76, 0);
  if (sub_100F70E5C(a1 + 7608, *(int *)&buf[4]))
  {
    sub_100728FEC(*(void *)(a2 + 19));
    sub_10071F480(a1, a2, 11);
    double Current = CFAbsoluteTimeGetCurrent();
    double v65 = *(double *)(a1 + 7616);
    *(_DWORD *)double v76 = 25;
    sub_10023AE2C(buf, "FallMinimumOffChargerDurationKey", v76, 0);
    double v66 = fmax(Current - v65, 0.0);
    if (v66 >= (double)*(int *)&buf[4])
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v71 = qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        int v72 = v6[3];
        *(_DWORD *)__int128 buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 1025;
        *(_DWORD *)&buf[20] = v72;
        *(_WORD *)&buf[24] = 2049;
        *(double *)&buf[26] = v66;
        uint64_t v56 = "{msg%{public}.0s:Avoided event dispatch with watch on charger, status:%{private}d, duration"
              ":%{private}f}";
        uint64_t v57 = (os_log_s *)v71;
        uint32_t v58 = 34;
        goto LABEL_60;
      }
    }

    else
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v67 = qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        int v68 = v6[3];
        *(_DWORD *)double v76 = 25;
        sub_10023AE2C(buf, "FallMinimumOffChargerDurationKey", v76, 0);
        int v69 = *(_DWORD *)&buf[4];
        *(_DWORD *)__int128 buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 1025;
        *(_DWORD *)&buf[20] = v68;
        *(_WORD *)&buf[24] = 2049;
        *(double *)&buf[26] = v66;
        *(_WORD *)&buf[34] = 1025;
        *(_DWORD *)&buf[36] = v69;
        uint64_t v56 = "{msg%{public}.0s:Avoided event dispatch with watch off charger for too short, status:%{private"
              "}d, duration:%{private}f, threshold:%{private}d}";
        uint64_t v57 = (os_log_s *)v67;
        uint32_t v58 = 40;
        goto LABEL_60;
      }
    }

    return;
  }

void sub_1007289C0(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)(v1 + 191);
  if (v3)
  {
    *(void *)(v1 + 199) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1007289E4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 446))
  {
    if (!*(_BYTE *)(a1 + 449) || !*(_BYTE *)(a1 + 448))
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v19 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289026;
        int v26 = 0;
        __int16 v27 = 2082;
        double v28 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Flush handler being invoked - did not see an alert - cleared payloads}",  buf,  0x12u);
      }

      goto LABEL_18;
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v26 = 0;
      __int16 v27 = 2082;
      double v28 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Flush handler being invoked - checking if near fall payloads should be sent to server or listeners}",  buf,  0x12u);
    }

    id v3 = [sub_100731100(a1) mutableCopy];
    float v4 = *(void **)(a1 + 136);
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472LL;
    void v23[2] = sub_10073532C;
    v23[3] = &unk_10184D450;
    _DWORD v23[4] = a1;
    id v5 = v23;
LABEL_17:
    [v4 flushData:v5 userProfile:v3];

LABEL_18:
    [*(id *)(a1 + 136) clearAllLogs];
    [*(id *)(a1 + 320) setNextFireDelay:1.79769313e308];
    __int128 v7 = *(void **)(a1 + 144);
    v22[0] = 0;
    sub_1012049AC(buf, "FallFullMslLoggingInSensorKitEnabled", v22, 0);
    [v7 cleanUpIncludingDerivedFeatures:buf[1]];
    *(_DWORD *)(a1 + 446) = 0;
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int128 v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 7568);
      uint64_t v10 = *(void *)(a1 + 7576);
      uint64_t v11 = *(void *)(a1 + 7584);
      uint64_t v12 = *(void *)(a1 + 7592);
      uint64_t v13 = *(void *)(a1 + 7600);
      *(_DWORD *)__int128 buf = 68290306;
      int v26 = 0;
      __int16 v27 = 2082;
      double v28 = "";
      __int16 v29 = 2050;
      *(void *)id v30 = v9;
      *(_WORD *)&v30[8] = 2050;
      uint64_t v31 = v10;
      __int16 v32 = 2050;
      uint64_t v33 = v11;
      __int16 v34 = 2050;
      uint64_t v35 = v12;
      __int16 v36 = 2050;
      uint64_t v37 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Logged item count, Accel800Sample:%{public}llu, Gyro200:%{public}llu, Quatern ion6:%{public}llu, Pressure:%{public}llu, HgalSample:%{public}llu}",  buf,  0x44u);
    }

    *(void *)(a1 + 760sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    *(_OWORD *)(a1 + 7584) = 0u;
    *(_OWORD *)(a1 + 756_Block_object_dispose(va, 8) = 0u;
    if (*(int *)(a1 + 280) >= 1)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v14 = a1 + 272;
      __int128 v15 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Releasing power assertion", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        *(_WORD *)BOOL v22 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Releasing power assertion",  v22,  2);
        int v21 = (uint8_t *)v20;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::flushLoggerManager()", "%s\n", v20);
        if (v21 != buf) {
          free(v21);
        }
      }

      sub_100AD5D38(v14);
    }

    return;
  }

  if ((*(_BYTE *)(a1 + 447) || (sub_10071F09C() & 1) == 0) && *(_BYTE *)(a1 + 448))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    unsigned __int8 v2 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v26 = 0;
      __int16 v27 = 2082;
      double v28 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Flush handler being invoked - checking if fall payloads should be sent to server or listeners}",  buf,  0x12u);
    }

    id v3 = [sub_100731100(a1) mutableCopy];
    float v4 = *(void **)(a1 + 136);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    _OWORD v24[2] = sub_100735200;
    v24[3] = &unk_10184D450;
    _DWORD v24[4] = a1;
    id v5 = v24;
    goto LABEL_17;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  float v16 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(unsigned __int8 *)(a1 + 447);
    int v18 = *(unsigned __int8 *)(a1 + 448);
    *(_DWORD *)__int128 buf = 68289539;
    int v26 = 0;
    __int16 v27 = 2082;
    double v28 = "";
    __int16 v29 = 1025;
    *(_DWORD *)id v30 = v17;
    *(_WORD *)&v30[4] = 1025;
    *(_DWORD *)&v30[6] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Flush handler being invoked - did not meet all conditions for flushing yet, fHasReceive dResolutionSinceLastFlush:%{private}hhd, fHasReceivedFlushPacket:%{private}hhd}",  buf,  0x1Eu);
  }

id sub_100728FA8()
{
  uint64_t v0 = sub_1002F8DDC();
  else {
    return 0LL;
  }
}

uint64_t sub_100728FEC(uint64_t a1)
{
  uint64_t v1 = sub_1002F8DDC();
  sub_1002AB3DC(v1);
  uint64_t v2 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 944LL))(v2);
}

uint64_t sub_10072904C(uint64_t a1, const __CFString *a2)
{
  uint64_t v3 = sub_1002F8DDC();
  uint64_t v4 = sub_1002AB3DC(v3);
  if ((v4 & 1) != 0)
  {
    uint64_t v5 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v5 + 944LL))(v5);
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      CStringPtr = CFStringGetCStringPtr(a2, 0x8000100u);
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Failed to persist timestamp , for key:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
    }

    __int128 v7 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      __int128 v8 = CFStringGetCStringPtr(a2, 0x8000100u);
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      CStringPtr = v8;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Failed to persist timestamp ",  "{msg%{public}.0s:Failed to persist timestamp , for key:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
    }
  }

  return v4;
}

id sub_10072924C(uint64_t a1, uint64_t a2)
{
  CFTypeRef v5 = 0LL;
  uint64_t v3 = sub_1002F8DDC();
  id result = (id)sub_1002A6F20(v3, a2, &v5);
  if ((_DWORD)result)
  {
    if (v5) {
      return objc_msgSend( +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(NSDate),  v5,  0),  "timeIntervalSinceReferenceDate");
    }
  }

  return result;
}

void sub_1007292E4(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = sub_1004F97F4();
  uint64_t v7 = *(void *)(a1 + 10640);
  sub_1004F2598();
  uint64_t v8 = sub_1004F97F4();
  sub_1004F2598();
  uint64_t v9 = sub_1004F97F4();
  int v10 = sub_1007269F4();
  float v11 = *(float *)(a1 + 404);
  LOBYTE(v46[0]) = 0;
  sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)v46, 0);
  int v12 = buf[1];
  LOBYTE(v46[0]) = 0;
  sub_1012049AC(buf, "FallStatsPressureEnabled", (unsigned __int8 *)v46, 0);
  int v45 = buf[1];
  if ((v6 & 0x4000000000LL) != 0)
  {
    if ((v10 & 1) != 0) {
      goto LABEL_7;
    }
  }

  else if ((sub_10071F09C() & v10 & 1) != 0)
  {
LABEL_7:
    int v13 = 1;
    goto LABEL_8;
  }

  if ((sub_100726AD0() & 1) != 0) {
    goto LABEL_7;
  }
  LOBYTE(v46[0]) = 0;
  sub_1012049AC(buf, "FallStatsSensorRecordingEnabled", (unsigned __int8 *)v46, 0);
  if (buf[1]) {
    goto LABEL_7;
  }
  LOBYTE(v46[0]) = 0;
  sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)v46, 0);
  if (v7) {
    int v28 = v10;
  }
  else {
    int v28 = 0;
  }
  if (buf[1]) {
    int v13 = 1;
  }
  else {
    int v13 = v28;
  }
LABEL_8:
  uint64_t v14 = v6 & 0x4000000000LL;
  double v15 = *(double *)(a1 + 248);
  if (v15 > 240.0)
  {
    LOBYTE(v46[0]) = 0;
    sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)v46, 0);
    BOOL v16 = buf[1] != 0;
  }

  else
  {
    BOOL v16 = 1;
  }

  unint64_t v43 = v8 & 0x40000000000LL;
  uint64_t v17 = v9 & 0x80000000000LL;
  if (v14) {
    int v18 = v10;
  }
  else {
    int v18 = 0;
  }
  int v19 = v13 | v18;
  if (v12) {
    int v20 = 1;
  }
  else {
    int v20 = v19;
  }
  unint64_t v41 = v14;
  if (sub_100726C58(a1))
  {
    int v21 = 1;
  }

  else if (sub_100726C58(a1))
  {
    int v21 = 0;
  }

  else
  {
    int v21 = sub_100726BFC();
  }

  if (v43) {
    char v22 = 2;
  }
  else {
    char v22 = 3;
  }
  if (v17) {
    char v22 = 1;
  }
  if (v20 | v21) {
    char v23 = v22;
  }
  else {
    char v23 = 3;
  }
  unsigned __int8 v44 = v23;
  int v40 = v20;
  unint64_t v39 = v17;
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v24 = v13 & v16;
  double v25 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    int v38 = v10;
    uint64_t v26 = *(void *)(a1 + 6731);
    LOBYTE(v46[0]) = 0;
    sub_1012049AC(buf, "FallStatsSensorRecordingEnabled", (unsigned __int8 *)v46, 0);
    int v27 = buf[1];
    *(_DWORD *)__int128 buf = 67244289;
    int v80 = v44;
    int v24 = v13 & v16;
    __int16 v81 = 1026;
    int v82 = v13;
    __int16 v83 = 1026;
    int v84 = v13 & v16;
    __int16 v85 = 1026;
    int v86 = a2;
    __int16 v87 = 1026;
    int v88 = v45;
    __int16 v89 = 1026;
    int v90 = v21;
    __int16 v91 = 2050;
    uint64_t v92 = v26;
    int v10 = v38;
    __int16 v93 = 1026;
    int v94 = v40;
    __int16 v95 = 1026;
    int v96 = v41 >> 38;
    __int16 v97 = 1026;
    int v98 = v39 >> 43;
    __int16 v99 = 1026;
    int v100 = v43 >> 42;
    __int16 v101 = 1026;
    int v102 = v38;
    __int16 v103 = 1025;
    int v104 = (int)v11;
    __int16 v105 = 1026;
    BOOL v106 = v15 <= 240.0;
    __int16 v107 = 1026;
    BOOL v108 = v16;
    __int16 v109 = 1026;
    int v110 = v12;
    __int16 v111 = 1026;
    int v112 = v27;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "config{ mode=%{public}d, sensorRecordingEnabled=%{public}d, sensorRecordingActive=%{public}d, simulateEvent=%{publ ic}d, userStudyPressureDataCollection=%{public}d, detectorEnabled=%{public}d, lastReplyAopTimestamp=%{public}llu - > variables{ enableFallStats=%{public}d, alwaysOn=%{public}d, supportsFallStatsModeBW190=%{public}d, supportsFallS tatsModeBW400=%{public}d, optin=%{public}d, age=%{private}d, underRateLimit=%{public}d, shouldLogSensorData=%{publ ic}d},keys{ FallStatsEnabled=%{public}d, FallStatsSensorRecordingEnabled=%{public}d}",  buf,  0x6Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v36 = v13;
    char v37 = a2;
    HIDWORD(v34) = v24;
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v29 = *(void *)(a1 + 6731);
    unint64_t v30 = v41 >> 38;
    uint64_t v42 = qword_1019345D8;
    int v31 = sub_10071F064();
    v46[0] = 67244289;
    v46[1] = v44;
    __int16 v47 = 1026;
    int v48 = v36;
    __int16 v49 = 1026;
    int v50 = HIDWORD(v34);
    __int16 v51 = 1026;
    int v52 = a2;
    __int16 v53 = 1026;
    int v54 = v45;
    __int16 v55 = 1026;
    int v56 = v21;
    __int16 v57 = 2050;
    uint64_t v58 = v29;
    __int16 v59 = 1026;
    int v60 = v40;
    __int16 v61 = 1026;
    int v62 = v30;
    __int16 v63 = 1026;
    int v64 = v39 >> 43;
    __int16 v65 = 1026;
    int v66 = v43 >> 42;
    __int16 v67 = 1026;
    int v68 = v10;
    __int16 v69 = 1025;
    int v70 = (int)v11;
    __int16 v71 = 1026;
    BOOL v72 = v15 <= 240.0;
    __int16 v73 = 1026;
    BOOL v74 = v16;
    __int16 v75 = 1026;
    int v76 = v12;
    __int16 v77 = 1026;
    int v78 = v31;
    LODWORD(v34) = 108;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v42,  0LL,  "config{ mode=%{public}d, sensorRecordingEnabled=%{public}d, sensorRecordingActive=%{public}d, simulateEvent=%{publ ic}d, userStudyPressureDataCollection=%{public}d, detectorEnabled=%{public}d, lastReplyAopTimestamp=%{public}llu - > variables{ enableFallStats=%{public}d, alwaysOn=%{public}d, supportsFallStatsModeBW190=%{public}d, supportsFallS tatsModeBW400=%{public}d, optin=%{public}d, age=%{private}d, underRateLimit=%{public}d, shouldLogSensorData=%{publ ic}d},keys{ FallStatsEnabled=%{public}d, FallStatsSensorRecordingEnabled=%{public}d}",  v46,  v34);
    uint64_t v33 = (uint8_t *)v32;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::Config CLFallNotifier::generateConfig(CMSPUFall_Types::SimulatedType) const",  "%s\n",  v32);
    if (v33 != buf) {
      free(v33);
    }
    LOBYTE(v13) = v36;
    LOBYTE(a2) = v37;
    LOBYTE(vsub_10000AE14(v9 + 24) = v35;
  }

  *(void *)a3 = *(void *)(a1 + 6731);
  *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = v44;
  *(_BYTE *)(a3 + 9) = v24;
  *(_BYTE *)(a3 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a2;
  *(_BYTE *)(a3 + 11) = v45;
  *(_BYTE *)(a3 + 12) = v21;
  *(_BYTE *)(a3 + 13) = *(_BYTE *)(a1 + 109);
  *(_BYTE *)(a3 + sub_100708348(v2 - 16) = v13;
}

id sub_100729918(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Setting up sensor recording", (uint8_t *)buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    LOWORD(v2_Block_object_dispose(va, 8) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Setting up sensor recording",  &v28,  2);
    int v24 = (char *)v23;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::enableSensorRecording()", "%s\n", v23);
  }

  *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = -[CLFallServer initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallServer),  "initInUniverse:",  *(void *)(a1 + 32));
  *(void *)(a1 + 144) = -[CLFallMslSink initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallMslSink),  "initInUniverse:",  *(void *)(a1 + 32));

  *(void *)(a1 + 152) = -[CLFallMslSink initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallMslSink),  "initInUniverse:",  *(void *)(a1 + 32));
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472LL;
  void v32[2] = sub_1007320D4;
  v32[3] = &unk_10184D450;
  _DWORD v32[4] = a1;

  *(void *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = [v32 copy];
  *(_DWORD *)(a1 + 446) = 0;
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 3221225472LL;
  void v31[2] = sub_10073260C;
  v31[3] = &unk_10181D3D0;
  v31[4] = a1;
  [*(id *)(a1 + 328) setHandler:v31];
  uint64_t v3 = sub_1006E27E8();
  sub_100413284(v3, buf);
  int v4 = sub_1002A7CB0(*(uint64_t *)&buf[0], "ServerCleanUpTimerFireInterval", &v28);
  double v5 = (double)v28;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    uint64_t v7 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (v4) {
    double v9 = v5;
  }
  else {
    double v9 = 21600.0;
  }
  [*(id *)(a1 + 328) setNextFireDelay:1.0 interval:v9];
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  void v30[2] = sub_100732658;
  v30[3] = &unk_10181D3D0;
  v30[4] = a1;
  [*(id *)(a1 + 336) setHandler:v30];
  *(void *)&buf[0] = 0x40F5180000000000LL;
  sub_101204164((unsigned __int8 *)&v28, "StatsRateLimitInterval", buf, 0);
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v11 = sub_1002F8DDC();
  double v12 = v29;
  int v13 = sub_1002A82BC(v11, "StatsRateLimitLastZeroed", buf);
  double v14 = Current - v12;
  if (v13) {
    double v14 = *(double *)buf;
  }
  double v15 = Current - v14;
  if (v15 >= 0.0)
  {
    double v20 = v29 - v15;
    if (v29 < v20) {
      double v20 = v29;
    }
    double v17 = fmax(v20, 2.0);
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    BOOL v16 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Time moved backwards. Reset timer immediately.",  (uint8_t *)buf,  2u);
    }

    double v17 = 2.0;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v33) = 0;
      LODWORD(v27) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Time moved backwards. Reset timer immediately.",  &v33,  v27);
      int v19 = (char *)v18;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::enableSensorRecording()", "%s\n", v18);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v21 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 134217984;
    *(double *)((char *)buf + 4) = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Setting next fire time for stats rate limiter (%f)",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v33 = 134217984;
    double v34 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Setting next fire time for stats rate limiter (%f)",  COERCE_DOUBLE(&v33));
    uint64_t v26 = (char *)v25;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::enableSensorRecording()", "%s\n", v25);
  }

  return [*(id *)(a1 + 336) setNextFireDelay:v17 interval:v29];
}

void sub_100729F44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_100729F60(id *a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Tearing down sensor recording to server.",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Tearing down sensor recording to server.",  v5,  2);
    int v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::disableSensorRecording()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  [a1[41] invalidate];

  a1[41] = 0LL;
  [a1[42] invalidate];

  a1[42] = 0LL;
  a1[20] = 0LL;

  a1[18] = 0LL;
  a1[19] = 0LL;
}

uint64_t sub_10072A13C(uint64_t a1, double a2)
{
  if (a2 <= 0.0)
  {
    uint64_t v9 = sub_1002F8DDC();
    *(void *)__int128 buf = CFAbsoluteTimeGetCurrent();
    sub_1002AC7B8(v9, "StatsRateLimitLastZeroed", buf);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void *)(a1 + 248);
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v26 = 1024;
      LODWORD(v27) = 240;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Clearing fall stats rate limit counter, was %f out of %d allowed",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      double v15 = *(double *)(a1 + 248);
      int v19 = 134218240;
      double v20 = v15;
      __int16 v21 = 1024;
      LODWORD(v22) = 240;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Clearing fall stats rate limit counter, was %f out of %d allowed",  COERCE_DOUBLE(&v19),  18);
      double v17 = (char *)v16;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::updateRateLimitCounter(NSTimeInterval)", "%s\n", v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
  }

  else
  {
    *(double *)(a1 + 24_Block_object_dispose(va, 8) = *(double *)(a1 + 248) + a2;
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v4 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = *(void *)(a1 + 248);
      *(_DWORD *)__int128 buf = 134218496;
      *(double *)&uint8_t buf[4] = a2;
      __int16 v26 = 2048;
      uint64_t v27 = v5;
      __int16 v28 = 1024;
      int v29 = 240;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Fall stats rate limit counter incremented by %f for a total %f out of %d allowed",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v6 = *(void *)(a1 + 248);
      int v19 = 134218496;
      double v20 = a2;
      __int16 v21 = 2048;
      uint64_t v22 = v6;
      __int16 v23 = 1024;
      int v24 = 240;
      LODWORD(v1_Block_object_dispose(va, 8) = 28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Fall stats rate limit counter incremented by %f for a total %f out of %d allowed",  COERCE_DOUBLE(&v19),  v18);
      unint64_t v8 = (char *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::updateRateLimitCounter(NSTimeInterval)", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  uint64_t v12 = sub_1002F8DDC();
  sub_1002AC7B8(v12, "StatsRateLimitCounter", (const void *)(a1 + 248));
  uint64_t v13 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v13 + 944LL))(v13);
  return sub_1007275FC(a1, 0LL);
}

uint64_t sub_10072A50C(uint64_t a1, int *a2)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v4 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a2;
    v8[0] = 68289282;
    v8[1] = 0;
    __int16 v9 = 2082;
    int v10 = "";
    __int16 v11 = 1026;
    int v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Added first client, notification:%{public}d}",  (uint8_t *)v8,  0x18u);
  }

  if (*a2 == 2)
  {
    sub_1007275FC(a1, 0);
  }

  else if (*a2 == 1)
  {
    v8[0] = 1;
    BOOL v6 = sub_100247620(a1, v8, 1LL) != 0;
    sub_10072A650(a1, v6);
  }

  return 1LL;
}

uint64_t sub_10072A650(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 444) == a2)
  {
    if (a2)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v3 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        int v4 = *(unsigned __int8 *)(a1 + 444);
        *(_DWORD *)__int128 buf = 68289283;
        int v15 = 0;
        __int16 v16 = 2082;
        double v17 = "";
        __int16 v18 = 1025;
        int v19 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Making sure the timer will not be trigger, current status:%{private}hhd}",  buf,  0x18u);
      }

      sub_10072AADC(a1);
    }

    return 1LL;
  }

  if (a2)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *(unsigned __int8 *)(a1 + 444);
      *(_DWORD *)__int128 buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      double v17 = "";
      __int16 v18 = 1025;
      int v19 = 1;
      __int16 v20 = 1025;
      int v21 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Client registered, now allowing algorithms to run, current sta tus:%{private}hhd, previous status:%{private}hhd}",  buf,  0x1Eu);
    }

    sub_10072AADC(a1);
    *(_BYTE *)(a1 + 444) = 1;
LABEL_25:
    sub_10072AB10(a1);
    return 1LL;
  }

  if (!sub_10071F09C())
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *(unsigned __int8 *)(a1 + 444);
      *(_DWORD *)__int128 buf = 68289283;
      int v15 = 0;
      __int16 v16 = 2082;
      double v17 = "";
      __int16 v18 = 1025;
      int v19 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Last client unregistered, making sure detector is stopped, cur rent status:%{private}hhd}",  buf,  0x18u);
    }

    *(_BYTE *)(a1 + 444) = 0;
    goto LABEL_25;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v7 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v8 = *(unsigned __int8 *)(a1 + 444);
    int v13 = 300;
    sub_10023AE2C(buf, "FallDelayBeforeShuttingDownAlgorithmsAfterLastClientDisconnect", &v13, 0);
    int v9 = v15;
    *(_DWORD *)__int128 buf = 68289795;
    int v15 = 0;
    __int16 v16 = 2082;
    double v17 = "";
    __int16 v18 = 1025;
    int v19 = 0;
    __int16 v20 = 1025;
    int v21 = v8;
    __int16 v22 = 1026;
    int v23 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Last client unregistered, setting timer for stopping detector, c urrent status:%{private}hhd, previous status:%{private}hhd, timer duration:%{public}d}",  buf,  0x24u);
  }

  sub_10072AC50(a1);
  return 1LL;
}

uint64_t sub_10072A998(uint64_t a1, int *a2)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v4 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *a2;
    v8[0] = 68289282;
    v8[1] = 0;
    __int16 v9 = 2082;
    int v10 = "";
    __int16 v11 = 1026;
    int v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Removed last client, notification:%{public}d}",  (uint8_t *)v8,  0x18u);
  }

  if (*a2 == 2)
  {
    sub_1007275FC(a1, 0);
  }

  else if (*a2 == 1)
  {
    v8[0] = 1;
    BOOL v6 = sub_100247620(a1, v8, 1LL) != 0;
    sub_10072A650(a1, v6);
  }

  return 1LL;
}

void sub_10072AADC(uint64_t a1)
{
  uint64_t v2 = *(dispatch_source_s **)(a1 + 352);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 352));
    *(void *)(a1 + 352) = 0LL;
  }

uint64_t sub_10072AB10(uint64_t a1)
{
  uint64_t v2 = *(dispatch_source_s **)(a1 + 360);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 360));
    *(void *)(a1 + 36sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  if (!*(_BYTE *)(a1 + 445))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v3 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(unsigned __int8 *)(a1 + 444);
      v6[0] = 68289282;
      v6[1] = 0;
      __int16 v7 = 2082;
      int v8 = "";
      __int16 v9 = 1026;
      int v10 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Registration monitor - Finished clients discovery, has client(s):%{public}hhd}",  (uint8_t *)v6,  0x18u);
    }
  }

  *(_BYTE *)(a1 + 445) = 1;
  [*(id *)(*(void *)(a1 + 10888) + 16) unregister:*(void *)(*(void *)(a1 + 10888) + 8) forNotification:2];
  [*(id *)(*(void *)(a1 + 10888) + 16) register:*(void *)(*(void *)(a1 + 10888) + 8) forNotification:2 registrationInfo:0];
  return sub_1007275FC(a1, 0);
}

void sub_10072AC50(uint64_t a1)
{
  uint64_t v2 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  2uLL,  0,  (dispatch_queue_t)objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "queue"));
  *(void *)(a1 + 352) = v2;
  int v6 = 300;
  sub_10023AE2C(v7, "FallDelayBeforeShuttingDownAlgorithmsAfterLastClientDisconnect", &v6, 0);
  dispatch_time_t v3 = dispatch_time(0x8000000000000000LL, 1000000000LL * v8);
  dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  int v4 = *(dispatch_source_s **)(a1 + 352);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10072AD34;
  handler[3] = &unk_10181D3D0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v4, handler);
  dispatch_resume(*(dispatch_object_t *)(a1 + 352));
}

void sub_10072AD34(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    int v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Registration monitor - Stopping algorithms after timer fire}",  (uint8_t *)v3,  0x12u);
  }

  sub_10072AADC(v1);
  *(_BYTE *)(v1 + 444) = 0;
}

unsigned __int8 *sub_10072AE18(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Checking debug profile presence", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    *(_WORD *)int v13 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Checking debug profile presence",  v13,  2);
    int v12 = (uint8_t *)v11;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::checkDebugProfilePresence()", "%s\n", v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  unsigned int v3 = sub_10072B0E4();
  v13[0] = 0;
  id result = sub_1012049AC(buf, "FallAdditionalProfileLoggingEnabled", v13, 0);
  uint64_t v5 = buf[1];
  if (v3 != (buf[1] != 0))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v15 = 0;
      __int16 v16 = 2082;
      double v17 = "";
      __int16 v18 = 1026;
      unsigned int v19 = v3;
      __int16 v20 = 1026;
      int v21 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Debug profile presence has been changed, wiping subject UUID, Presence before:%{pub lic}hhd, Presence now:%{public}hhd}",  buf,  0x1Eu);
    }

    __int16 v7 = *(void **)(a1 + 160);
    if (v7)
    {
      [v7 clearUUID];
    }

    else
    {
      id v8 = -[CLFallServer initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallServer),  "initInUniverse:",  *(void *)(a1 + 32));
      [v8 clearUUID];
    }

    +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%d", v5);
    uint64_t v9 = sub_1002F8DDC();
    sub_1002AB3DC(v9);
    uint64_t v10 = sub_1002F8DDC();
    return (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 944LL))(v10);
  }

  return result;
}

id sub_10072B0E4()
{
  uint64_t v0 = sub_1002F8DDC();
  id result = (id)sub_1002A6F20(v0, (uint64_t)@"LastFallAdditionalProfileLoggingEnabled", (CFTypeRef *)&v2);
  if ((_DWORD)result) {
    return [v2 BOOLValue];
  }
  return result;
}

id sub_10072B120(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 10616) && *(void *)(a1 + 10664))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v2 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 10680);
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v18 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "MaxMETs, on charger, setting timer interval to %f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v12 = *(void *)(a1 + 10680);
      int v15 = 134217984;
      uint64_t v16 = v12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "MaxMETs, on charger, setting timer interval to %f",  COERCE_DOUBLE(&v15));
      double v14 = (uint8_t *)v13;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::scheduleMetMinuteStatsCompute()", "%s\n", v13);
      if (v14 != buf) {
        free(v14);
      }
    }

    __int16 v4 = *(void **)(a1 + 10656);
    double v5 = *(double *)(a1 + 10680);
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 10704);
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v18 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "MaxMETs, off charger, setting timer interval to %f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v9 = *(void *)(a1 + 10704);
      int v15 = 134217984;
      uint64_t v16 = v9;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "MaxMETs, off charger, setting timer interval to %f",  COERCE_DOUBLE(&v15));
      __int16 v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::scheduleMetMinuteStatsCompute()", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    __int16 v4 = *(void **)(a1 + 10656);
    double v5 = *(double *)(a1 + 10704);
  }

  return [v4 setNextFireDelay:v5 interval:v5];
}

uint64_t sub_10072B450(uint64_t a1)
{
  double v2 = v1;
  if ((sub_10071F09C() & 1) == 0)
  {
    uint64_t v3 = sub_1002F8DDC();
    sub_1002A66DC(v3);
    uint64_t v4 = sub_1002F8DDC();
    sub_1002A66DC(v4);
  }

  uint64_t result = sub_10071F09C();
  if ((_DWORD)result)
  {
    if (v2 == 1.79769313e308)
    {
      CFAbsoluteTimeGetCurrent();
      return sub_10072904C(v6, @"FallDetectionOptInTime");
    }
  }

  return result;
}

double sub_10072B4D8(uint64_t a1)
{
  double v2 = operator new(0x2AA8uLL);
  sub_10072BED4((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A15D0 = (uint64_t)v2;
  sub_1007275FC((uint64_t)v2, 0);
  return sub_10072B534(qword_1019A15D0);
}

void sub_10072B520(_Unwind_Exception *a1)
{
}

double sub_10072B534(uint64_t a1)
{
  if (*(float *)(a1 + 404) == 30.0 && sub_1008FA854(0))
  {
    uint64_t v2 = sub_1008FA854(0);
    if ((*(unsigned int (**)(uint64_t, uint8_t *))(*(void *)(v2 + 56) + 56LL))(v2 + 56, buf)
      && *(float *)&buf[20] != 30.0)
    {
      *(_OWORD *)(a1 + 4sub_100708348(v2 - 16) = *(_OWORD *)&buf[32];
      *(_OWORD *)(a1 + 42_Block_object_dispose(va, 8) = *(_OWORD *)&buf[44];
      __int128 v4 = *(_OWORD *)&buf[16];
      *(_OWORD *)(a1 + 384) = *(_OWORD *)buf;
      *(_OWORD *)(a1 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v4;
      sub_100734EAC(a1, *(float *)(a1 + 404));
    }
  }

  __int128 v53 = xmmword_1012E52C0;
  __int128 v54 = xmmword_1012E52E0;
  *(void *)&__int128 v55 = 0x4100000041A00000LL;
  *((void *)&v55 + 1) = 0xA00000018LL;
  __int128 v56 = xmmword_1012E52F0;
  *(_DWORD *)__int16 v57 = 1110704128;
  HIDWORD(sub_1012279C0(0LL, v4, v5) = 2;
  *(_OWORD *)&v57[4] = xmmword_1012E5300;
  *(_DWORD *)&v57[20] = 0;
  *(_DWORD *)&v57[23] = 0;
  double v52 = NAN;
  uint64_t v6 = *(void *)(a1 + 10664);
  if (v6)
  {
    if ((sub_1004956CC(v6, &v52, 0.9) & 1) != 0)
    {
      uint64_t v7 = sub_1004958B8(*(void *)(a1 + 10664));
      goto LABEL_17;
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    id v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to get user mets percentile.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      __src[0] = 0;
      LODWORD(v3_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Failed to get user mets percentile.",  __src,  v38);
      char v37 = (uint8_t *)v36;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::selectFallModels()", "%s\n", v36);
      if (v37 != buf) {
        free(v37);
      }
    }
  }

  uint64_t v7 = 0LL;
LABEL_17:
  LODWORD(sub_1012279C0(0LL, v4, v5) = *(_DWORD *)(a1 + 404);
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Age",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v5));
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Gender",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 384)));
  LODWORD(v9) = *(_DWORD *)(a1 + 392);
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Height",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v9));
  LODWORD(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)(a1 + 396);
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Weight",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v10));
  LODWORD(v11) = *(_DWORD *)(a1 + 420);
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Pal",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v11));
  LODWORD(v12) = *(_DWORD *)(a1 + 400);
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Vo2max",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12));
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"MetMinPercentile",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v52));
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"MetMinCount",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v7));
  int v13 = *(void **)(a1 + 8072);
  if (sub_100726C58(a1)) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = sub_100726BFC();
  }
  objc_msgSend( v13,  "setSelectionFeatureValue:value:",  @"BackgroundAWDLoggingEnabled",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v14));
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"Workout",  +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(void *)(a1 + 10640)));
  objc_msgSend( *(id *)(a1 + 8072),  "setSelectionFeatureValue:value:",  @"HKWorkout",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 10648)));
  if (([*(id *)(a1 + 8072) selectModels] & 1) == 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v15 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Could not select model based in provided features - Falling back to defaults",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      __src[0] = 0;
      LODWORD(v3_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  17LL,  "Could not select model based in provided features - Falling back to defaults",  __src,  v38);
      char v35 = (uint8_t *)v34;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLFallNotifier::selectFallModels()", "%s\n", v34);
      if (v35 != buf) {
        free(v35);
      }
    }
  }

  [*(id *)(a1 + 8072) fillTripFallModel:buf];
  [*(id *)(a1 + 8072) fillSlipFallModel:__src];
  [*(id *)(a1 + 8072) fillOtherFallModel:v58];
  [*(id *)(a1 + 8072) fillFallThresholds:&v53];
  sub_101206C88(v50, "FallCyclingImpactGravityVarianceThreshold", "\n=FallCyclingImpactCrownVarianceThreshold", 0);
  if (v50[0]) {
    DWORD1(v56) = v51;
  }
  sub_101206C88(v48, "FallCyclingImpactCrownVarianceThreshold", "\n=FallCyclingImpactMaxAbsYThreshold", 0);
  if (v48[0]) {
    DWORD2(v56) = v49;
  }
  sub_101206C88(v46, "FallCyclingImpactMaxAbsYThreshold", &dword_101328520, 0);
  if (v46[0]) {
    HIDWORD(v56) = v47;
  }
  sub_101206C88(v44, "FallCyclingDistanceTraveledPostImpactThreshold", &dword_101328554, 0);
  if (v44[0]) {
    *(_DWORD *)__int16 v57 = v45;
  }
  sub_10023AE2C(v42, "FallCyclingEpochsDetectedPostImpactThreshold", "\b", 0);
  if (v42[0]) {
    *(_DWORD *)&v57[4] = v43;
  }
  LODWORD(v6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_10023AE2C(v41, "FallRefereeOperatingModeOverride", &v60, 0);
  if (v41[0]) {
    v57[23] = v41[4];
  }
  LODWORD(v6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_10023AE2C(v40, "FallAllDayStateMachineOperatingModeOverride", &v60, 0);
  if (v40[0]) {
    v57[24] = v40[4];
  }
  LOBYTE(v6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(v39, "FallCyclingStateMachineEnabledOverride", (unsigned __int8 *)&v60, 0);
  if (v39[1]) {
    char v16 = 1;
  }
  else {
    char v16 = 2;
  }
  if (v39[0]) {
    char v17 = v16;
  }
  else {
    char v17 = 0;
  }
  v57[25] = v17;
  LOBYTE(v6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC((unsigned __int8 *)&v38 + 6, "FallAllDayStateMachineEnabledOverride", (unsigned __int8 *)&v60, 0);
  if (HIBYTE(v38)) {
    char v18 = 1;
  }
  else {
    char v18 = 2;
  }
  if (BYTE6(v38)) {
    char v19 = v18;
  }
  else {
    char v19 = 0;
  }
  v57[26] = v19;
  __int16 v20 = (const void *)sub_1008FA854(0);
  if (v20)
  {
    if (v21)
    {
      uint64_t v22 = (uint64_t)v21;
      sub_10035F968();
      sub_10035FAEC(v22, &v53);
    }
  }

  int v23 = (float *)(a1 + 7476);
  sub_1002C3734(a1 + 7476, (uint64_t)&v53);
  if (sub_10071FC64(a1))
  {
    sub_100DEAD80(a1 + 10568, *(float *)(a1 + 7476));
    float v24 = v52;
    sub_100DEAD54(a1 + 10568, v24);
    sub_100DEADA0(a1 + 10568);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v25 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v60 = 68289282LL;
      __int16 v61 = 2082;
      int v62 = "";
      __int16 v63 = 2050;
      double v64 = v52;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLFitnessTrackingAllDayAWD: Updating user max mets, value:%{public}f}",  (uint8_t *)&v60,  0x1Cu);
    }

    uint64_t v26 = sub_1008D9630();
    float v27 = v52;
    sub_1008DAEDC(v26, v27);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int16 v28 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      double v29 = *v23;
      uint64_t v60 = 68289282LL;
      __int16 v61 = 2082;
      int v62 = "";
      __int16 v63 = 2050;
      double v64 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLFitnessTrackingAllDayAWD: Updating user behavioral threshold, value:%{public}f}",  (uint8_t *)&v60,  0x1Cu);
    }

    uint64_t v30 = sub_1008D9630();
    sub_1008DAD64(v30, *v23);
  }

  memcpy((void *)(a1 + 8080), buf, 0x31CuLL);
  memcpy((void *)(a1 + 8876), __src, 0x31CuLL);
  memcpy((void *)(a1 + 9672), v58, 0x31CuLL);
  __int128 v31 = v56;
  *(_OWORD *)(a1 + 1050sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v55;
  *(_OWORD *)(a1 + 105sub_100708348(v2 - 16) = v31;
  *(_OWORD *)(a1 + 10532) = *(_OWORD *)v57;
  *(_OWORD *)(a1 + 10543) = *(_OWORD *)&v57[11];
  __int128 v32 = v54;
  *(_OWORD *)(a1 + 1046_Block_object_dispose(va, 8) = v53;
  *(_OWORD *)(a1 + 10484) = v32;
  double result = v52;
  *(double *)(a1 + 1056sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v52;
  return result;
}

uint64_t sub_10072BED4(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_10072D578(a1, "CLFallNotifier", a2);
  *(void *)uint64_t v4 = off_10184D2F0;
  *(_BYTE *)(v4 + 109) = 0;
  *(_DWORD *)(v4 + sub_10000AE14(v2 - 112) = -1;
  double v5 = (int *)(v4 + 112);
  *(void *)(v4 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(a1 + 136) = -[CLFallLoggerManager initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallLoggerManager),  "initInUniverse:",  a2);
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"newtonStats",  0LL);
  *(void *)(a1 + 176) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"newtonState",  0LL);
  *(void *)(a1 + 184) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"newtonSensors",  0LL);
  *(void *)(a1 + 192) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"pressure",  0LL);
  *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"heartRate",  0LL);
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"wristState",  0LL);
  *(void *)(a1 + 2sub_100708348(v2 - 16) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"odometer",  0LL);
  *(void *)(a1 + 2sub_10000AE14(v9 + 24) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"falsePositiveSuppressionFeatures",  0LL);
  *(void *)(a1 + 232) = -[CLFallLogger initToDirectory:prefix:rotation:]( objc_alloc(&OBJC_CLASS___CLFallLogger),  "initToDirectory:prefix:rotation:",  @"/var/root/Library/Caches/locationd/logs/newtonStats",  @"hgal",  0LL);
  *(void *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  uint64_t v6 = sub_1002F8DDC();
  int v7 = sub_1002A82BC(v6, "StatsRateLimitCounter", buf);
  double v8 = *(double *)buf;
  if (!v7) {
    double v8 = 0.0;
  }
  *(double *)(a1 + 24_Block_object_dispose(va, 8) = v8;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 264) = -[CLFallTap2Radar initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallTap2Radar),  "initInUniverse:",  a2);
  sub_100AD558C(a1 + 272, (uint64_t)"CLFallNotifier", a1, 0.0);
  *(void *)(a1 + 32sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 32_Block_object_dispose(va, 8) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 336) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 344) = [*(id *)(a1 + 40) newTimer];
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 36_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 384) = xmmword_101328414;
  *(_OWORD *)(a1 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = unk_101328424;
  *(_OWORD *)(a1 + 4sub_100708348(v2 - 16) = xmmword_101328434;
  *(_OWORD *)(a1 + 42_Block_object_dispose(va, 8) = *(__int128 *)((char *)&xmmword_101328434 + 12);
  *(_DWORD *)(a1 + 444) = 0;
  *(_DWORD *)(a1 + 447) = 0;
  *(void *)(a1 + 456) = 0x18600000000LL;
  *(_OWORD *)(a1 + 6704) = 0u;
  *(_OWORD *)(a1 + 672sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_DWORD *)(a1 + 6735) = 0;
  *(_OWORD *)(a1 + 6739) = xmmword_1013282E0;
  *(void *)(a1 + 6755) = 0xFF7FFFFF7F7FFFFFLL;
  *(_DWORD *)(a1 + 6763) = -8388609;
  *(void *)(a1 + 6767) = 0LL;
  *(void *)(a1 + 6775) = 0x7F7FFFFF00000000LL;
  *(_DWORD *)(a1 + 6783) = 2139095039;
  *(_DWORD *)(a1 + 6835) = 0;
  *(_OWORD *)(a1 + 6819) = 0u;
  *(_OWORD *)(a1 + 6803) = 0u;
  *(_OWORD *)(a1 + 6787) = 0u;
  int32x4_t v9 = vdupq_n_s32(0x7F7FFFFFu);
  *(int32x4_t *)(a1 + 6839) = v9;
  *(_DWORD *)(a1 + 6855) = -8388609;
  *(_WORD *)(a1 + 6859) = 1;
  *(_BYTE *)(a1 + 6861) = 0;
  *(_OWORD *)(a1 + 686_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 6884) = 0u;
  *(_OWORD *)(a1 + 690sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 6914) = 0u;
  *(_OWORD *)(a1 + 693sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = xmmword_1013282E0;
  *(void *)(a1 + 6946) = 0xFF7FFFFF7F7FFFFFLL;
  *(_DWORD *)(a1 + 6954) = -8388609;
  *(void *)(a1 + 695_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 6966) = 0x7F7FFFFF00000000LL;
  *(_DWORD *)(a1 + 6974) = 2139095039;
  *(_DWORD *)(a1 + 7026) = 0;
  *(_OWORD *)(a1 + 701sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 6994) = 0u;
  *(_OWORD *)(a1 + 697_Block_object_dispose(va, 8) = 0u;
  *(int32x4_t *)(a1 + 703sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
  *(_DWORD *)(a1 + 7046) = -8388609;
  *(_WORD *)(a1 + 705sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
  *(_BYTE *)(a1 + 7052) = 0;
  *(_OWORD *)(a1 + 7105) = 0u;
  *(_OWORD *)(a1 + 7091) = 0u;
  *(_OWORD *)(a1 + 7075) = 0u;
  *(_OWORD *)(a1 + 7059) = 0u;
  *(_OWORD *)(a1 + 7121) = xmmword_1013282E0;
  *(void *)(a1 + 7137) = 0xFF7FFFFF7F7FFFFFLL;
  *(_DWORD *)(a1 + 7145) = -8388609;
  *(void *)(a1 + 7149) = 0LL;
  *(void *)(a1 + 7157) = 0x7F7FFFFF00000000LL;
  *(_DWORD *)(a1 + 7165) = 2139095039;
  *(_DWORD *)(a1 + 7217) = 0;
  *(_OWORD *)(a1 + 7201) = 0u;
  *(_OWORD *)(a1 + 7185) = 0u;
  *(_OWORD *)(a1 + 7169) = 0u;
  *(int32x4_t *)(a1 + 7221) = v9;
  *(_DWORD *)(a1 + 7237) = -8388609;
  *(_WORD *)(a1 + 7241) = 1;
  *(_BYTE *)(a1 + 7243) = 0;
  *(_OWORD *)(a1 + 7296) = 0u;
  *(_OWORD *)(a1 + 7282) = 0u;
  *(_OWORD *)(a1 + 7266) = 0u;
  *(_OWORD *)(a1 + 725sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 7312) = xmmword_1013282E0;
  *(void *)(a1 + 732_Block_object_dispose(va, 8) = 0xFF7FFFFF7F7FFFFFLL;
  *(_DWORD *)(a1 + 7336) = -8388609;
  *(void *)(a1 + 734sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a1 + 734_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 7352) = v9.i64[0];
  *(_DWORD *)(a1 + 740_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 7392) = 0u;
  *(_OWORD *)(a1 + 7376) = 0u;
  *(_OWORD *)(a1 + 736sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(int32x4_t *)(a1 + 7412) = v9;
  *(_DWORD *)(a1 + 742_Block_object_dispose(va, 8) = -8388609;
  *(_WORD *)(a1 + 7432) = 1;
  *(_BYTE *)(a1 + 7434) = 0;
  *(_DWORD *)(a1 + 7472) = 0;
  *(_OWORD *)(a1 + 7457) = 0u;
  *(_OWORD *)(a1 + 7441) = 0u;
  sub_1002C37D4(a1 + 7476);
  *(void *)(a1 + 760sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_OWORD *)(a1 + 7584) = 0u;
  *(_OWORD *)(a1 + 756_Block_object_dispose(va, 8) = 0u;
  sub_100F703F0(a1 + 7608);
  *(_BYTE *)(a1 + 7832) = 0;
  *(_OWORD *)(a1 + 7792) = 0u;
  *(void *)(a1 + 7807) = 0LL;
  *(void *)(a1 + 78sub_100708348(v2 - 16) = 0LL;
  *(void *)(a1 + 7822) = 0LL;
  *(_OWORD *)(a1 + 784sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 7856) = 0u;
  *(_OWORD *)(a1 + 7872) = 0u;
  *(_OWORD *)(a1 + 788_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 7904) = 0u;
  *(_OWORD *)(a1 + 792sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 7936) = 0u;
  *(_OWORD *)(a1 + 7952) = 0u;
  *(_OWORD *)(a1 + 796_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 7984) = 0u;
  *(_OWORD *)(a1 + 800sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 80sub_100708348(v2 - 16) = 0u;
  *(_OWORD *)(a1 + 8032) = 0u;
  *(void *)(a1 + 804_Block_object_dispose(va, 8) = a1 + 8048;
  *(void *)(a1 + 8056) = a1 + 8048;
  *(void *)(a1 + 8064) = 0LL;
  *(void *)(a1 + 8072) = objc_alloc_init(&OBJC_CLASS___CLFallModelSelector);
  double v10 = sub_1002C37D4(a1 + 10468);
  *(void *)(a1 + 1056sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0x7FF8000000000000LL;
  sub_100DEAC60(a1 + 10568, *(void *)(a1 + 40), v10);
  *(_BYTE *)(a1 + 106sub_100708348(v2 - 16) = 0;
  *(void *)(a1 + 106sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 1064sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a1 + 1064_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 10656) = [*(id *)(a1 + 40) newTimer];
  double v11 = (void **)(a1 + 10664);
  *(void *)(a1 + 10664) = 0LL;
  *(void *)__int128 buf = 0x4066800000000000LL;
  sub_101204164((unsigned __int8 *)(a1 + 10672), "FallMetMinuteStatsComputeInterval", buf, 0);
  *(void *)__int128 buf = 0x40AC200000000000LL;
  sub_101204164((unsigned __int8 *)(a1 + 10696), "FallMetMinuteStatsComputeIntervalOffCharger", buf, 0);
  *(_WORD *)(a1 + 1072sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(_BYTE *)(a1 + 10722) = 0;
  uint64_t v12 = a1 + 10728;
  *(_OWORD *)(a1 + 1072_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 10744) = 0u;
  *(_OWORD *)(a1 + 1076sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 10776) = 0u;
  *(_OWORD *)(a1 + 10792) = 0u;
  *(_OWORD *)(a1 + 1080_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 108sub_10000AE14(v9 + 24) = 0u;
  *(_OWORD *)(a1 + 1084sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(a1 + 10856) = 0u;
  *(_OWORD *)(a1 + 10872) = 0u;
  *(_OWORD *)(a1 + 1088_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 10904) = 0u;
  int v13 = operator new(0x40uLL);
  sub_100D99B34(v13, (uint64_t)a2);
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = v13;
  int v118 = 600;
  sub_10023AE2C(buf, "FallDelayBeforeBeforeReportingImpactCancelReason", &v118, 0);
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472LL;
  aBlock[2] = sub_10072D614;
  aBlock[3] = &unk_10184D3C0;
  aBlock[4] = a1;
  sub_100D99BD0((uint64_t)v13, aBlock, (double)*(int *)&buf[4]);
  uint64_t v14 = (dispatch_queue_s *)[*(id *)(a1 + 40) queue];
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10072DFFC;
  handler[3] = &unk_101832780;
  handler[4] = a1;
  notify_register_dispatch("SOSNewtonStateChangedNotification", v5, v14, handler);
  uint64_t v15 = sub_1002F8DDC();
  else {
    uint64_t v16 = 0LL;
  }
  uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSSet);
  char v18 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v17,  objc_opt_class(&OBJC_CLASS___NSString),  0LL,  a1 + 10568,  a1 + 272);
  if (v16) {
    char v19 = (NSMutableSet *)objc_msgSend( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v18,  v16,  0),  "mutableCopy");
  }
  else {
    char v19 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  }
  int v20 = 0;
  *(void *)(a1 + 256) = v19;
  do
  {
    unsigned int v21 = v20;
    [*(id *)(a1 + 136) addLogger:v20++];
  }

  while (v21 < 0xB);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v22 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      BOOL v23 = 0;
    }
    *(_DWORD *)__int128 buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v121 = 1026;
    BOOL v122 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Setting up logger manager, enabled:%{public}hhd}",  buf,  0x18u);
  }

  float v24 = *(void **)(a1 + 136);
  else {
    BOOL v25 = 0LL;
  }
  [v24 setLoggingEnabled:v25];
  if (sub_1008FA854(0))
  {
    uint64_t v26 = operator new(0x38uLL);
    sub_1003DE40C(v26, *(void **)(a1 + 40), (uint64_t)sub_10072E104, a1, 0LL);
    *(void *)(a1 + 10736) = v26;
    uint64_t v27 = sub_1008FA854(0);
    sub_1006DCB40(v27, 10, *(void *)(a1 + 10736), -1.0);
    __int16 v28 = operator new(0x38uLL);
    sub_1003DE40C(v28, *(void **)(a1 + 40), (uint64_t)sub_10072E2D4, a1, 0LL);
    *(void *)(a1 + 10744) = v28;
    uint64_t v29 = sub_1008FA854(0);
    sub_1006DCB40(v29, 11, *(void *)(a1 + 10744), -1.0);
    uint64_t v30 = operator new(0x48uLL);
    sub_101212380((uint64_t)v30, *(void **)(a1 + 40), (uint64_t)sub_10072E4A4, 0x10u, a1);
    *(void *)(a1 + 10752) = v30;
    uint64_t v31 = sub_1008FA854(0);
    sub_1006DCB40(v31, 15, *(void *)(a1 + 10752), -1.0);
    __int128 v32 = operator new(0x48uLL);
    sub_101212380((uint64_t)v32, *(void **)(a1 + 40), (uint64_t)sub_10072E67C, 0xFu, a1);
    *(void *)(a1 + 1076sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v32;
    uint64_t v33 = sub_1008FA854(0);
    sub_1006DCB40(v33, 19, *(void *)(a1 + 10760), -1.0);
    double v34 = operator new(0x38uLL);
    sub_1003DE40C(v34, *(void **)(a1 + 40), (uint64_t)sub_10072E854, a1, 0LL);
    *(void *)(a1 + 1076_Block_object_dispose(va, 8) = v34;
    uint64_t v35 = sub_1008FA854(0);
    sub_1006DCB40(v35, 16, *(void *)(a1 + 10768), -1.0);
    int v36 = operator new(0x38uLL);
    sub_1003DE40C(v36, *(void **)(a1 + 40), (uint64_t)sub_10072EA24, a1, 0LL);
    *(void *)(a1 + 10776) = v36;
    uint64_t v37 = sub_1008FA854(0);
    sub_1006DCB40(v37, 17, *(void *)(a1 + 10776), -1.0);
    uint64_t v38 = operator new(0x38uLL);
    sub_1003DE40C(v38, *(void **)(a1 + 40), (uint64_t)sub_10072EBF4, a1, 0LL);
    *(void *)(a1 + 10832) = v38;
    uint64_t v39 = sub_1008FA854(0);
    sub_1006DCB40(v39, 14, *(void *)(a1 + 10832), -1.0);
    int v40 = operator new(0x38uLL);
    sub_1003DE40C(v40, *(void **)(a1 + 40), (uint64_t)sub_10072EDB4, a1, 0LL);
    *(void *)(a1 + 10784) = v40;
    uint64_t v41 = sub_1008FA854(0);
    sub_1006DCB40(v41, 18, *(void *)(a1 + 10784), -1.0);
    uint64_t v42 = operator new(0x38uLL);
    sub_1003DE40C(v42, *(void **)(a1 + 40), (uint64_t)sub_10072EF84, a1, 0LL);
    *(void *)(a1 + 10792) = v42;
    uint64_t v43 = sub_1008FA854(0);
    sub_1006DCB40(v43, 23, *(void *)(a1 + 10792), -1.0);
    unsigned __int8 v44 = operator new(0x38uLL);
    sub_1003DE40C(v44, *(void **)(a1 + 40), (uint64_t)sub_10072F154, a1, 0LL);
    *(void *)(a1 + 1080sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v44;
    uint64_t v45 = sub_1008FA854(0);
    sub_1006DCB40(v45, 24, *(void *)(a1 + 10800), -1.0);
    int v46 = operator new(0x38uLL);
    sub_1003DE40C(v46, *(void **)(a1 + 40), (uint64_t)sub_10072F324, a1, 0LL);
    *(void *)(a1 + 1080_Block_object_dispose(va, 8) = v46;
    uint64_t v47 = sub_1008FA854(0);
    sub_1006DCB40(v47, 25, *(void *)(a1 + 10808), -1.0);
    int v48 = operator new(0x38uLL);
    sub_1003DE40C(v48, *(void **)(a1 + 40), (uint64_t)sub_10072F4F4, a1, 0LL);
    *(void *)(a1 + 108sub_100708348(v2 - 16) = v48;
    uint64_t v49 = sub_1008FA854(0);
    sub_1006DCB40(v49, 22, *(void *)(a1 + 10816), -1.0);
    int v50 = operator new(0x38uLL);
    sub_1003DE40C(v50, *(void **)(a1 + 40), (uint64_t)sub_10072F6C8, a1, 0LL);
    *(void *)(a1 + 1084sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v50;
    uint64_t v51 = sub_1008FA854(0);
    sub_1006DCB40(v51, 21, *(void *)(a1 + 10840), -1.0);
    sub_1004F2598();
    if ((sub_1004F97F4() & 0x100000000000LL) != 0)
    {
      double v52 = operator new(0x38uLL);
      sub_1003DE40C(v52, *(void **)(a1 + 40), (uint64_t)sub_10072F898, a1, 0LL);
      *(void *)(a1 + 108sub_10000AE14(v9 + 24) = v52;
      uint64_t v53 = sub_1008FA854(0);
      sub_1006DCB40(v53, 26, *(void *)(a1 + 10824), -1.0);
    }
  }

  sub_1005C4E40((uint64_t)sub_10072FA68, a1, *(void **)(a1 + 32), buf);
  uint64_t v54 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v55 = *(void *)(a1 + 10848);
  *(void *)(a1 + 1084_Block_object_dispose(va, 8) = v54;
  if (v55)
  {
    (*(void (**)(uint64_t))(*(void *)v55 + 8LL))(v55);
    uint64_t v56 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v56) {
      (*(void (**)(uint64_t))(*(void *)v56 + 8LL))(v56);
    }
  }

  [*(id *)(*(void *)(a1 + 10848) + 16) register:*(void *)(*(void *)(a1 + 10848) + 8) forNotification:1 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 10848) + 16) register:*(void *)(*(void *)(a1 + 10848) + 8) forNotification:2 registrationInfo:0];
  sub_100D96A2C((uint64_t)sub_10072FC40, a1, *(void **)(a1 + 32), buf);
  uint64_t v57 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v58 = *(void *)(a1 + 10856);
  *(void *)(a1 + 10856) = v57;
  if (v58)
  {
    (*(void (**)(uint64_t))(*(void *)v58 + 8LL))(v58);
    uint64_t v59 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v59) {
      (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
    }
  }

  [*(id *)(*(void *)(a1 + 10856) + 16) register:*(void *)(*(void *)(a1 + 10856) + 8) forNotification:8 registrationInfo:0];
  sub_10070EDF0((uint64_t)sub_10072FE18, a1, *(void **)(a1 + 32), buf);
  uint64_t v60 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v61 = *(void *)(a1 + 10880);
  *(void *)(a1 + 1088sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v60;
  if (v61)
  {
    (*(void (**)(uint64_t))(*(void *)v61 + 8LL))(v61);
    uint64_t v62 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v62) {
      (*(void (**)(uint64_t))(*(void *)v62 + 8LL))(v62);
    }
  }

  sub_100E18F18((uint64_t)sub_10072FFF0, a1, *(void **)(a1 + 32), buf);
  uint64_t v63 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v64 = *(void *)(a1 + 10888);
  *(void *)(a1 + 1088_Block_object_dispose(va, 8) = v63;
  if (v64)
  {
    (*(void (**)(uint64_t))(*(void *)v64 + 8LL))(v64);
    uint64_t v65 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v65) {
      (*(void (**)(uint64_t))(*(void *)v65 + 8LL))(v65);
    }
  }

  [*(id *)(*(void *)(a1 + 10888) + 16) register:*(void *)(*(void *)(a1 + 10888) + 8) forNotification:2 registrationInfo:0];
  sub_100ACD980((uint64_t)sub_1007301C8, a1, *(void **)(a1 + 32), buf);
  uint64_t v66 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v67 = *(void *)(a1 + 10896);
  *(void *)(a1 + 10896) = v66;
  if (v67)
  {
    (*(void (**)(uint64_t))(*(void *)v67 + 8LL))(v67);
    uint64_t v68 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v68) {
      (*(void (**)(uint64_t))(*(void *)v68 + 8LL))(v68);
    }
  }

  [*(id *)(*(void *)(a1 + 10896) + 16) register:*(void *)(*(void *)(a1 + 10896) + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 10896) + 16) register:*(void *)(*(void *)(a1 + 10896) + 8) forNotification:1 registrationInfo:0];
  sub_1005C4E40((uint64_t)sub_1007303A0, a1, *(void **)(a1 + 32), buf);
  uint64_t v69 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v70 = *(void *)(a1 + 10904);
  *(void *)(a1 + 10904) = v69;
  if (v70)
  {
    (*(void (**)(uint64_t))(*(void *)v70 + 8LL))(v70);
    uint64_t v71 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v71) {
      (*(void (**)(uint64_t))(*(void *)v71 + 8LL))(v71);
    }
  }

  [*(id *)(*(void *)(a1 + 10904) + 16) register:*(void *)(*(void *)(a1 + 10904) + 8) forNotification:0 registrationInfo:0];
  sub_100468458((uint64_t)sub_100730578, a1, *(void **)(a1 + 32), buf);
  uint64_t v72 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v73 = *(void *)(a1 + 10864);
  *(void *)(a1 + 10864) = v72;
  if (v73)
  {
    (*(void (**)(uint64_t))(*(void *)v73 + 8LL))(v73);
    uint64_t v74 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v74) {
      (*(void (**)(uint64_t))(*(void *)v74 + 8LL))(v74);
    }
  }

  [*(id *)(*(void *)(a1 + 10864) + 16) register:*(void *)(*(void *)(a1 + 10864) + 8) forNotification:2 registrationInfo:0];
  sub_10027EB5C((uint64_t)sub_100730750, a1, a2, buf);
  uint64_t v75 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v76 = *(void *)(a1 + 10872);
  *(void *)(a1 + 10872) = v75;
  if (v76)
  {
    (*(void (**)(uint64_t))(*(void *)v76 + 8LL))(v76);
    uint64_t v77 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v77) {
      (*(void (**)(uint64_t))(*(void *)v77 + 8LL))(v77);
    }
  }

  sub_1003CC884((uint64_t)sub_100730928, a1, *(void **)(a1 + 32), buf);
  uint64_t v78 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v79 = *(void *)(a1 + 10912);
  *(void *)(a1 + 10912) = v78;
  if (v79)
  {
    (*(void (**)(uint64_t))(*(void *)v79 + 8LL))(v79);
    uint64_t v80 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v80) {
      (*(void (**)(uint64_t))(*(void *)v80 + 8LL))(v80);
    }
  }

  [*(id *)(*(void *)(a1 + 10912) + 16) register:*(void *)(*(void *)(a1 + 10912) + 8) forNotification:7 registrationInfo:0];
  if (&MCEffectiveSettingsChangedNotification)
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_100730B20,  MCEffectiveSettingsChangedNotification,  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  }

  v114[5] = a1;
  v115[0] = _NSConcreteStackBlock;
  v115[1] = 3221225472LL;
  v115[2] = sub_100730D40;
  v115[3] = &unk_10181D3D0;
  v115[4] = a1;
  v114[0] = _NSConcreteStackBlock;
  v114[1] = 3221225472LL;
  v114[2] = sub_100730EF0;
  v114[3] = &unk_10184AF10;
  v114[4] = v115;
  [*(id *)(a1 + 320) setHandler:v114];
  int v82 = *(void **)(a1 + 344);
  v113[0] = _NSConcreteStackBlock;
  v113[1] = 3221225472LL;
  v113[2] = sub_1007310B4;
  v113[3] = &unk_10181D3D0;
  v113[4] = a1;
  [v82 setHandler:v113];
  __int16 v83 = (const void *)sub_1008FA854(0);
  if (v83)
  {
    if (v84)
    {
      uint64_t v85 = (uint64_t)v84;
      v112[0] = _NSConcreteStackBlock;
      v112[1] = 3221225472LL;
      v112[2] = sub_100731574;
      v112[3] = &unk_10184D3E8;
      v112[4] = v115;
      v112[5] = a1;
      sub_10035CD94((uint64_t)v84, v112);
      v111[0] = _NSConcreteStackBlock;
      v111[1] = 3221225472LL;
      v111[2] = sub_100731714;
      v111[3] = &unk_10184D430;
      v111[4] = a1;
      sub_10035CCF0(v85, v111);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v86 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v87 = *(void *)(a1 + 248);
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)&uint8_t buf[4] = v87;
    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEBUG, "StatsRateLimitCounter set to %f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v105 = *(void *)(a1 + 248);
    int v118 = 134217984;
    uint64_t v119 = v105;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "StatsRateLimitCounter set to %f",  COERCE_DOUBLE(&v118));
    __int16 v107 = (char *)v106;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)", "%s\n", v106);
    if (v107 != buf) {
      free(v107);
    }
  }

  int v88 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  2uLL,  0,  (dispatch_queue_t)objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "queue"));
  *(void *)(a1 + 36sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v88;
  int v118 = 30;
  sub_10023AE2C(buf, "FallDelayBeforeSendingSPUConfiguration", &v118, 0);
  dispatch_time_t v89 = dispatch_time(0x8000000000000000LL, 1000000000LL * *(int *)&buf[4]);
  dispatch_source_set_timer(v88, v89, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  int v90 = *(dispatch_source_s **)(a1 + 360);
  v110[0] = _NSConcreteStackBlock;
  v110[1] = 3221225472LL;
  v110[2] = sub_1007317D4;
  v110[3] = &unk_10181D3D0;
  v110[4] = a1;
  dispatch_source_set_event_handler(v90, v110);
  dispatch_resume(*(dispatch_object_t *)(a1 + 360));
  sub_100EE2800((uint64_t)sub_1007318B4, a1, *(void **)(a1 + 32), buf);
  uint64_t v91 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v92 = *(void *)v12;
  *(void *)uint64_t v12 = v91;
  if (v92)
  {
    (*(void (**)(uint64_t))(*(void *)v92 + 8LL))(v92);
    uint64_t v93 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v93) {
      (*(void (**)(uint64_t))(*(void *)v93 + 8LL))(v93);
    }
  }

  [*(id *)(*(void *)v12 + 16) register:*(void *)(*(void *)v12 + 8) forNotification:9 registrationInfo:0];
  [*(id *)(*(void *)v12 + 16) register:*(void *)(*(void *)v12 + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)v12 + 16) register:*(void *)(*(void *)v12 + 8) forNotification:10 registrationInfo:0];
  int v94 = objc_alloc_init(&OBJC_CLASS___CLFallNotifierClientAdapter);
  *(void *)(a1 + 106sub_10000AE14(v9 + 24) = v94;
  -[CLFallNotifierClientAdapter setValid:](v94, "setValid:", 1LL);
  id v95 = objc_msgSend(objc_msgSend(a2, "vendor"), "proxyForService:", @"CLNatalimetryNotifier");
  *(void *)(a1 + 10632) = v95;
  objc_msgSend(v95, "registerDelegate:inSilo:", *(void *)(a1 + 10624), objc_msgSend(a2, "silo"));
  int v96 = operator new(0x40uLL);
  sub_1004956C8((uint64_t)v96, *(void *)(a1 + 10632));
  *(void *)__int128 buf = 0LL;
  __int16 v97 = *v11;
  *double v11 = v96;
  if (v97)
  {
    sub_100741594(a1 + 10664, v97);
    int v98 = *(void **)buf;
    *(void *)__int128 buf = 0LL;
    if (v98) {
      sub_100741594((int)buf, v98);
    }
  }

  v109[0] = _NSConcreteStackBlock;
  v109[1] = 3221225472LL;
  v109[2] = sub_100731A84;
  v109[3] = &unk_10181D3D0;
  v109[4] = a1;
  [*(id *)(a1 + 10656) setHandler:v109];
  sub_10072B120(a1);
  __int16 v99 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  2uLL,  0,  (dispatch_queue_t)objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "queue"));
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = v99;
  int v100 = sub_100731C10();
  dispatch_time_t v101 = dispatch_time(0x8000000000000000LL, 1000000000LL * v100);
  dispatch_source_set_timer(v99, v101, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  int v102 = *(dispatch_source_s **)(a1 + 368);
  v108[0] = _NSConcreteStackBlock;
  v108[1] = 3221225472LL;
  v108[2] = sub_100731C6C;
  v108[3] = &unk_10181D3D0;
  v108[4] = a1;
  dispatch_source_set_event_handler(v102, v108);
  dispatch_resume(*(dispatch_object_t *)(a1 + 368));
  __int16 v103 = sub_10072AE18(a1);
  sub_10072B450((uint64_t)v103);
  return a1;
}

void sub_10072D320( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v17 = v12[1364];
  v12[1364] = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  uint64_t v18 = v12[1363];
  v12[1363] = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  uint64_t v19 = v12[1362];
  v12[1362] = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  uint64_t v20 = v12[1361];
  v12[1361] = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  uint64_t v21 = v12[1360];
  v12[1360] = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  uint64_t v22 = v12[1359];
  v12[1359] = 0LL;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
  }
  uint64_t v23 = v12[1358];
  v12[1358] = 0LL;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
  }
  uint64_t v24 = v12[1357];
  v12[1357] = 0LL;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
  }
  uint64_t v25 = v12[1356];
  v12[1356] = 0LL;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
  }
  uint64_t v26 = *v15;
  uint64_t *v15 = 0LL;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
  }
  uint64_t v27 = *v14;
  *uint64_t v14 = 0LL;
  if (v27) {
    sub_100741594((int)v14, v27);
  }
  sub_100DEACA8(a11);
  sub_1001B4C40(v13);
  sub_100210A00(v12 + 962);
  sub_100210A00(v12 + 956);
  sub_100AD5650(a12);
  sub_100731D64((uint64_t)v12);
  _Unwind_Resume(a1);
}

uint64_t sub_10072D578(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10184D5D8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_10072D5F8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10072D614(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t result = sub_10071FC64(v5);
  if (!(_DWORD)result) {
    return result;
  }
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v7 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v39 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "CLFallImpactMetrics: Logging impact at time %llu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v36 = 134217984;
    uint64_t v37 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFallImpactMetrics: Logging impact at time %llu",  &v36);
    uint64_t v23 = (uint8_t *)v22;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v22);
    if (v23 != buf) {
      free(v23);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a3 + 16LL))(a3);
  uint64_t v8 = sub_1000F0F50(a3);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int32x4_t v9 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v39 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging impact cancelation reason 0x%llx",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v36 = 134217984;
    uint64_t v37 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging impact cancelation reason 0x%llx",  &v36);
    uint64_t v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  uint64_t v10 = sub_1008D9630();
  uint64_t result = sub_1008D9CD8(v10, v8);
  uint64_t v11 = *(void *)(v5 + 10640);
  if (v11 <= 14)
  {
    if (!v11) {
      return result;
    }
    if (v11 != 4)
    {
LABEL_42:
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v20 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        uint64_t v39 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging other workout impact cancelation reason 0x%llx",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        int v36 = 134217984;
        uint64_t v37 = v8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging other workout impact cancelation reason 0x%llx",  &v36);
        uint64_t v35 = (uint8_t *)v34;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v34);
        if (v35 != buf) {
          free(v35);
        }
      }

      uint64_t v21 = sub_1008D9630();
      return sub_1008DAAA0(v21, v8);
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v14 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v39 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging outdoor cycling impact cancelation reason 0x%llx",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v36 = 134217984;
      uint64_t v37 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging outdoor cycling impact cancelation reason 0x%llx",  &v36);
      uint64_t v29 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v28);
      if (v29 != buf) {
        free(v29);
      }
    }

    uint64_t v15 = sub_1008D9630();
    return sub_1008D9F98(v15, v8);
  }

  else
  {
    switch(v11)
    {
      case 15LL:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v16 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134217984;
          uint64_t v39 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging outdoor walking impact cancelation reason 0x%llx",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          int v36 = 134217984;
          uint64_t v37 = v8;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging outdoor walking impact cancelation reason 0x%llx",  &v36);
          uint64_t v31 = (uint8_t *)v30;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v30);
          if (v31 != buf) {
            free(v31);
          }
        }

        uint64_t v17 = sub_1008D9630();
        return sub_1008DA25C(v17, v8);
      case 17LL:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v18 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134217984;
          uint64_t v39 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging outdoor running impact cancelation reason 0x%llx",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          int v36 = 134217984;
          uint64_t v37 = v8;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging outdoor running impact cancelation reason 0x%llx",  &v36);
          uint64_t v33 = (uint8_t *)v32;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v32);
          if (v33 != buf) {
            free(v33);
          }
        }

        uint64_t v19 = sub_1008D9630();
        return sub_1008DA51C(v19, v8);
      case 24LL:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v12 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134217984;
          uint64_t v39 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "CLFitnessTrackingAllDayAWD: Logging hiking impact cancelation reason 0x%llx",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          int v36 = 134217984;
          uint64_t v37 = v8;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFitnessTrackingAllDayAWD: Logging hiking impact cancelation reason 0x%llx",  &v36);
          uint64_t v27 = (uint8_t *)v26;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v26);
          if (v27 != buf) {
            free(v27);
          }
        }

        uint64_t v13 = sub_1008D9630();
        return sub_1008DA7E0(v13, v8);
      default:
        goto LABEL_42;
    }
  }

uint64_t sub_10072DFFC(uint64_t a1)
{
  return sub_10072E004(*(void *)(a1 + 32));
}

uint64_t sub_10072E004(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 68289283;
    v5[1] = 0;
    __int16 v6 = 2082;
    int v7 = "";
    __int16 v8 = 1025;
    int v9 = sub_10071E178();
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Bridge settings were toggled, enabled:%{private}d}",  (uint8_t *)v5,  0x18u);
  }

  sub_10072B534(a1);
  sub_10072B450(v3);
  return sub_1007275FC(a1, 0);
}

void sub_10072E104(uint64_t *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFallStatsData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFallStatsData, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_1007338C0(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072E2B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072E2D4(__int128 *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFallEventData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFallEventData, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100735458(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072E484( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072E4A4(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v9 = 1;
    __int16 v6 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onImpactDataAccel800",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v6, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    char v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      uint64_t v15 = "activity";
      __int16 v16 = 2050;
      uint64_t v17 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onImpactDataAccel800, event:%{public, location:escape_only}s, thi s:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v9 = 0;
  }

  sub_100735898((unsigned __int8 *)a3, a1, a2);
  if (v9) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072E65C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072E67C(uint64_t a1, int a2, uint64_t a3)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v9 = 1;
    __int16 v6 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onImpactDataHgal",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v6, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    char v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      uint64_t v15 = "activity";
      __int16 v16 = 2050;
      uint64_t v17 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onImpactDataHgal, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v9 = 0;
  }

  sub_100735B80((unsigned __int8 *)a3, a1, a2);
  if (v9) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072E834( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072E854(uint64_t *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onImpactDataGyro200",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onImpactDataGyro200, event:%{public, location:escape_only}s, this :%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100735E14(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072EA04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072EA24(uint64_t *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onImpactDataQuaternion6",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onImpactDataQuaternion6, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100736190(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072EBD4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072EBF4(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v6 = 1;
    uint64_t v3 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onImpactDataStart",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v3, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v4 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v8 = 0;
      __int16 v9 = 2082;
      __int16 v10 = "";
      __int16 v11 = 2082;
      __int16 v12 = "activity";
      __int16 v13 = 2050;
      uint64_t v14 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onImpactDataStart, event:%{public, location:escape_only}s, this :%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v6 = 0;
  }

  sub_10073BD8C(a2);
  if (v6) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072ED94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072EDB4(__int128 *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFalsePositiveSuppressionFeatures",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFalsePositiveSuppressionFeatures, event:%{public, location:escape _only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100736508(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072EF64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072EF84(std::string::value_type *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFeatureDistributionMaxAccelNorm",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFeatureDistributionMaxAccelNorm, event:%{public, location:escape_ only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100736920(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072F134( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072F154(unsigned __int8 *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFeatureDistributionJerkVectorMagnitude",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFeatureDistributionJerkVectorMagnitude, event:%{public, location: escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100736FCC(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072F304( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072F324(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFeatureDistributionMaxAbsXYZ",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFeatureDistributionMaxAbsXYZ, event:%{public, location:escape_onl y}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100737680(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072F4D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072F4F4(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFallCancelReason",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFallCancelReason, event:%{public, location:escape_only}s, this :%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_10071FCAC(a2, *(void *)(a1 + 16), *(_DWORD *)(a1 + 32), *(void *)(a1 + 24));
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072F6A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072F6C8(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onPressureData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onPressureData, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_10073BF98(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072F878( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072F898(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onFallDistance",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2082;
      __int16 v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onFallDistance, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100D9A2FC(*(void *)(a2 + 128), a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072FA48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072FA68(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onWatchOrientationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onWatchOrientationNotification, event:%{public, location:escape_onl y}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C244(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072FC20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072FC40(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onAppMonitorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onAppMonitorNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C508(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072FDF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072FE18(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onHeartRateNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onHeartRateNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C588((unsigned __int8 *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10072FFD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072FFF0(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onUserInfoNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onUserInfoNotification, event:%{public, location:escape_only}s, t his:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C798(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1007301A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007301C8(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onDataProtectionNotification, event:%{public, location:escape_only} s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C820((void *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730380( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007303A0(uint64_t a1, _DWORD *a2, void *a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onWatchOrientationSettingsNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onWatchOrientationSettingsNotification, event:%{public, location:es cape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10073C970(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730558( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100730578(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onMotionStateMediatorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onMotionStateMediatorNotification, event:%{public, location:escape_ only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100732BDC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730730( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100730750(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onOdometerUpdate",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onOdometerUpdate, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100733194(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730908( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100730928(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onBatteryNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onBatteryNotification, event:%{public, location:escape_only}s, th is:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  if (*a2 == 7)
  {
    int v9 = *(unsigned __int8 *)(a3 + 9);
    if (*(unsigned __int8 *)(a4 + 10616) != v9)
    {
      *(_BYTE *)(a4 + 106sub_100708348(v2 - 16) = v9;
      sub_10072B120(a4);
    }
  }

  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730B00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100730B20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    __int16 v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onDataCollectionChangedNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    char v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onDataCollectionChangedNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_100740750;
  v13[3] = &unk_10182D1B8;
  v13[4] = a2;
  void v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  _WORD v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100730D20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100730D40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Unregistering for HR Notifications", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Unregistering for HR Notifications",  v5,  2);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  [*(id *)(*(void *)(v1 + 10880) + 16) unregister:*(void *)(*(void *)(v1 + 10880) + 8) forNotification:4];
  *(_BYTE *)(v1 + 44_Block_object_dispose(va, 8) = 1;
  sub_1007289E4(v1);
}

id sub_100730EF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v3 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Fail safe sensor recording handler", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Fail safe sensor recording handler",  v7,  2);
    char v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  if (*(_BYTE *)(v2 + 446)) {
    *(_WORD *)(v2 + 447) = 257;
  }
  [*(id *)(v2 + 40) async:*(void *)(a1 + 32)];
  return [*(id *)(v2 + 320) setNextFireDelay:1.79769313e308];
}

void sub_1007310B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [sub_100731100(v1) mutableCopy];
  [v2 setObject:&off_1018D3878 forKey:@"isADLImpact"];

  *(_BYTE *)(v1 + 45sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
}

id sub_100731100(uint64_t a1)
{
  id v2 = objc_msgSend( objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLNatalimetryNotifier"),  "syncgetUserProfile"),  "mutableCopy");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", CFAbsoluteTimeGetCurrent()),  @"CMTimestamp");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_10071F09C()),  @"CMIsFallDetectionFeatureEnabled");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_10071F09C()),  @"CMFallDetectionShouldEnableFallDetection");
  LODWORD(v3) = *(_DWORD *)(a1 + 7476);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v3),  @"CMImpactMaxAccelNormAlertThreshold");
  LODWORD(v4) = *(_DWORD *)(a1 + 7480);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v4),  @"CMImpactMaxAccelNormLoggingStatsThreshold");
  LODWORD(sub_1012279C0(0LL, v4, v5) = *(_DWORD *)(a1 + 7484);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v5),  @"CMImpactMaxAccelNormLoggingHeartRateThreshold");
  LODWORD(v6) = *(_DWORD *)(a1 + 7488);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v6),  @"CMImpactMaxAccelNormLoggingHighResolutionSensorDataThreshold");
  LODWORD(v7) = *(_DWORD *)(a1 + 7492);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v7),  @"CMTripFallPosteriorRatioDetectionThreshold");
  LODWORD(v_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 7496);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v8),  @"CMSlipFallPosteriorRatioDetectionThreshold");
  LODWORD(v9) = *(_DWORD *)(a1 + 7500);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v9),  @"CMOtherFallPosteriorRatioDetectionThreshold");
  LODWORD(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)(a1 + 7504);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v10),  @"CMTripNearFallPosteriorRatioDetectionThreshold");
  LODWORD(v11) = *(_DWORD *)(a1 + 7508);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v11),  @"CMSlipNearFallPosteriorRatioDetectionThreshold");
  LODWORD(v12) = *(_DWORD *)(a1 + 7512);
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12),  @"CMOtherNearFallPosteriorRatioDetectionThreshold");
  double v22 = NAN;
  uint64_t v23 = 0x7FF8000000000000LL;
  double v20 = NAN;
  double v21 = NAN;
  uint64_t v13 = *(void *)(a1 + 10664);
  if (v13)
  {
    sub_1004956CC(v13, (double *)&v23, 0.9);
    sub_1004956CC(*(void *)(a1 + 10664), &v22, 0.9);
    sub_1004956CC(*(void *)(a1 + 10664), &v21, 0.95);
    sub_1004956CC(*(void *)(a1 + 10664), &v20, 0.98);
    double v14 = *(double *)&v23;
  }

  else
  {
    double v14 = NAN;
  }

  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v14),  @"CMMetMinutePercentileActual");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v22),  @"CMMetMinutePercentile90");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v21),  @"CMMetMinutePercentile95");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v20),  @"CMMetMinutePercentile98");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(void *)(a1 + 10640)),  @"CMWorkoutType");
  if (!*(_BYTE *)(a1 + 446) || !*(_BYTE *)(a1 + 447) || (double v15 = 0.0, !*(_BYTE *)(a1 + 448)))
  {
    if (!*(_BYTE *)(a1 + 449) || (double v15 = 1.0, !*(_BYTE *)(a1 + 448))) {
      double v15 = 0.0;
    }
  }

  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v15),  @"CMIsNearFall");
  objc_msgSend( v2,  "setObject:forKey:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_10071F09C()),  @"isFallDetectionFeatureEnabled");
  __int16 v16 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v2);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v17 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    __int16 v18 = -[NSString UTF8String](v16, "UTF8String");
    *(_DWORD *)__int128 buf = 68289283;
    int v25 = 0;
    __int16 v26 = 2082;
    uint64_t v27 = "";
    __int16 v28 = 2081;
    uint64_t v29 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:User Profile Dictionnary, content:%{private, location:escape_only}s}",  buf,  0x1Cu);
  }

  return v2;
}

id sub_100731574(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  double v3 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Received fall buffer flush packet", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Received fall buffer flush packet",  v7,  2);
    double v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  return [*(id *)(v2 + 40) async:*(void *)(a1 + 32)];
}

id sub_100731714(uint64_t a1, char a2, uint64_t a3, uint64_t a4, unsigned int a5, double a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  double v10 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a4, a5);
  double v11 = *(void **)(v9 + 40);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_1007317B8;
  v13[3] = &unk_10184D410;
  char v14 = a2;
  v13[4] = v10;
  void v13[5] = v9;
  *(double *)&v13[6] = a6;
  v13[7] = a3;
  return [v11 async:v13];
}

id sub_1007317B8(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 40) + 136) logSensorType:*(unsigned __int8 *)(a1 + 64) data:*(void *)(a1 + 32) startTime:*(void *)(a1 + 56) timestamp:*(double *)(a1 + 48)];
}

uint64_t sub_1007317D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    double v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Client discovery is now considered complete}",  (uint8_t *)v4,  0x12u);
  }

  return sub_10072AB10(v1);
}

void sub_1007318B4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    double v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFallNotifier::onDarwinNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    double v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      char v14 = "";
      __int16 v15 = 2082;
      __int16 v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFallNotifier::onDarwinNotification, event:%{public, location:escape_only}s, thi s:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  sub_10073E138((unsigned __int8 *)a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100731A64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

double sub_100731A84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 10664);
  if (v2 && !sub_100495954(v2, 1800.0, 0.9))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int16 v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 68289026;
      int v7 = 0;
      __int16 v8 = 2082;
      uint64_t v9 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MaxMETs, Done computing stats.}",  (uint8_t *)&v6,  0x12u);
    }

    return sub_10072B534(v1);
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v3 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 68289026;
      int v7 = 0;
      __int16 v8 = 2082;
      uint64_t v9 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MaxMETs, Queuing stats compute.}",  (uint8_t *)&v6,  0x12u);
    }
  }

  return result;
}

uint64_t sub_100731C10()
{
  int v1 = 25;
  sub_10023AE2C(v2, "FallMinimumOffChargerDurationKey", &v1, 0);
  int v1 = v3;
  sub_10023AE2C(v2, "FallDelayBeforeWristAndChargerGating", &v1, 0);
  return v3;
}

void sub_100731C6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 368));
  dispatch_release(*(dispatch_object_t *)(v1 + 368));
  *(void *)(v1 + 36_Block_object_dispose(va, 8) = 0LL;
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    __int16 v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Wrist/Charger gating is now enabled}",  (uint8_t *)v3,  0x12u);
  }

  *(_BYTE *)(v1 + 761sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
}

uint64_t sub_100731D64(uint64_t a1)
{
  *(void *)a1 = off_10184D5D8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100731DD8(void *a1)
{
  *a1 = off_10184D2F0;
  sub_100732664((uint64_t)a1);
  uint64_t v2 = a1[1364];
  a1[1364] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[1363];
  a1[1363] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = a1[1362];
  a1[1362] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = a1[1361];
  a1[1361] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = a1[1360];
  a1[1360] = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = a1[1359];
  a1[1359] = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = a1[1358];
  a1[1358] = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = a1[1357];
  a1[1357] = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  uint64_t v10 = a1[1356];
  a1[1356] = 0LL;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  uint64_t v11 = a1[1341];
  a1[1341] = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  int v12 = (void *)a1[1333];
  a1[1333] = 0LL;
  if (v12) {
    sub_100741594((_DWORD)a1 + 10664, v12);
  }
  sub_100DEACA8(a1 + 1321);
  sub_1001B4C40(a1 + 1006);
  sub_100210A00(a1 + 962);
  sub_100210A00(a1 + 956);
  sub_100AD5650(a1 + 34);
  return sub_100731D64((uint64_t)a1);
}

void sub_100731F50(void *a1)
{
  uint64_t v1 = (void *)sub_100731DD8(a1);
  operator delete(v1);
}

uint64_t sub_100731F64(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v7 = 0;
    sub_1012049AC(buf, "FallStatsEnabled", &v7, 0);
    int v3 = buf[1];
    unsigned __int8 v7 = 0;
    sub_1012049AC(buf, "FallStatsPressureEnabled", &v7, 0);
    int v4 = buf[1];
    unsigned __int8 v7 = 0;
    sub_1012049AC(buf, "FallStatsSensorRecordingEnabled", &v7, 0);
    int v5 = buf[1];
    *(_DWORD *)__int128 buf = 68289795;
    int v9 = 0;
    __int16 v10 = 2082;
    uint64_t v11 = "";
    __int16 v12 = 1025;
    int v13 = v3;
    __int16 v14 = 1025;
    int v15 = v4;
    __int16 v16 = 1025;
    int v17 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Data collection setting was toggled, stats:%{private}d, presssure:%{private}d,  sensor:%{private}d}",  buf,  0x24u);
  }

  sub_10072B534(a1);
  return sub_1007275FC(a1, 0);
}

void sub_1007320D4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (a2)
  {
    if (sub_100726A64(*(void *)(a1 + 32)))
    {
      [a3 timeIntervalSinceDate:a2];
      double v11 = v10;
      if (v10 < 30.0)
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v12 = qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289538;
          int v32 = 0;
          __int16 v33 = 2082;
          double v34 = "";
          __int16 v35 = 2050;
          double v36 = v11;
          __int16 v37 = 1026;
          int v38 = 30;
          int v13 = "{msg%{public}.0s:Flush handler being invoked - payload is too short to be sent, actual duratio"
                "n:%{public}f, required duration:%{public}d}";
          __int16 v14 = (os_log_s *)v12;
          uint32_t v15 = 34;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
          goto LABEL_24;
        }

        goto LABEL_24;
      }

      if ([*(id *)(v5 + 160) sendData:a4 metaData:a5 start:a2 end:a3])
      {
        sub_10072A13C(v5, v11);
        goto LABEL_24;
      }

      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v18 = qword_1019345D8;
      if (!os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:
        if (*(_BYTE *)(v5 + 446) && *(_BYTE *)(v5 + 447) && *(_BYTE *)(v5 + 448)
          || !*(_BYTE *)(v5 + 449)
          || !*(_BYTE *)(v5 + 448))
        {
          char v19 = 0;
        }

        else
        {
          if (*(void *)(v5 + 10640))
          {
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            __int16 v16 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 68289026;
              int v32 = 0;
              __int16 v33 = 2082;
              double v34 = "";
              int v17 = "{msg%{public}.0s:Avoiding tap to radar for near falls during workouts.}";
              goto LABEL_34;
            }

            goto LABEL_39;
          }

          char v19 = 1;
        }

        double v20 = *(void **)(v5 + 264);
        uint64_t v21 = *(unsigned __int8 *)(v5 + 6868);
        uint64_t v22 = v5;
        uint64_t v23 = *(unsigned __int8 *)(v5 + 6869);
        char v24 = sub_100726B2C();
        BYTE2(v29) = sub_100726B94();
        BYTE1(v29) = v24;
        LOBYTE(v29) = v19;
        uint64_t v25 = v23;
        uint64_t v5 = v22;
        objc_msgSend( v20,  "trigger:metaData:start:end:response:resolution:isNearFall:isFallSubmissionAllowed:isNearFallSubmissionAllowed:",  a4,  a5,  a2,  a3,  v21,  v25,  v29);
LABEL_37:
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        goto LABEL_39;
      }

      *(_DWORD *)__int128 buf = 68289026;
      int v32 = 0;
      __int16 v33 = 2082;
      double v34 = "";
      int v13 = "{msg%{public}.0s:Flush handler being invoked - payload was not sent because watch has not been unlocke"
            "d since last boot}";
    }

    else
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v18 = qword_1019345D8;
      if (!os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
      *(_DWORD *)__int128 buf = 68289026;
      int v32 = 0;
      __int16 v33 = 2082;
      double v34 = "";
      int v13 = "{msg%{public}.0s:Flush handler being invoked - no payload to be sent as opt-in data collection is not enabled}";
    }

    __int16 v14 = (os_log_s *)v18;
    uint32_t v15 = 18;
    goto LABEL_17;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  __int16 v16 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289026;
    int v32 = 0;
    __int16 v33 = 2082;
    double v34 = "";
    int v17 = "{msg%{public}.0s:Flush handler being invoked - no GM payload to be sent}";
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, buf, 0x12u);
    goto LABEL_37;
  }

id sub_10073260C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_101204164(v3, "ServerCleanUpFileStalenessThreshold", &qword_101328478, 0);
  return [*(id *)(v1 + 160) cleanUp:v4];
}

uint64_t sub_100732658(uint64_t a1)
{
  return sub_10072A13C(*(void *)(a1 + 32), 0.0);
}

void sub_100732664(uint64_t a1)
{
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;

  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 184) = 0LL;

  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 2sub_100708348(v2 - 16) = 0LL;

  *(void *)(a1 + 2sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 232) = 0LL;

  *(void *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  uint64_t v2 = *(void *)(a1 + 10856);
  *(void *)(a1 + 10856) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 10880);
  *(void *)(a1 + 1088sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 10888);
  *(void *)(a1 + 1088_Block_object_dispose(va, 8) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 10896);
  *(void *)(a1 + 10896) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  [*(id *)(*(void *)(a1 + 10864) + 16) unregister:*(void *)(*(void *)(a1 + 10864) + 8) forNotification:2];
  uint64_t v6 = *(void *)(a1 + 10864);
  *(void *)(a1 + 10864) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  [*(id *)(*(void *)(a1 + 10872) + 16) unregister:*(void *)(*(void *)(a1 + 10872) + 8) forNotification:4];
  uint64_t v7 = *(void *)(a1 + 10872);
  *(void *)(a1 + 10872) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  if (*(int *)(a1 + 280) >= 1)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Releasing power assertion due to Fall Notifier destruction.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v34[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Releasing power assertion due to Fall Notifier destruction.",  v34,  2);
      __int16 v33 = (uint8_t *)v32;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLFallNotifier::shutdown()", "%s\n", v32);
      if (v33 != buf) {
        free(v33);
      }
    }

    sub_100AD5D38(a1 + 272);
  }

  *(void *)(a1 + 264) = 0LL;
  [*(id *)(a1 + 320) invalidate];

  *(void *)(a1 + 32sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  sub_10072AADC(a1);
  int v9 = (const void *)sub_1008FA854(0);
  if (v9)
  {
    if (v10)
    {
      uint64_t v11 = (uint64_t)v10;
      sub_10035CD94((uint64_t)v10, 0LL);
      sub_10035CCF0(v11, 0LL);
    }
  }

  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 1;

  *(void *)(a1 + 256) = 0LL;
  if (sub_1008FA854(0))
  {
    uint64_t v12 = sub_1008FA854(0);
    sub_1006DD2A0(v12, 10, *(void *)(a1 + 10736));
    uint64_t v13 = *(void *)(a1 + 10736);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
    *(void *)(a1 + 10736) = 0LL;
    uint64_t v14 = sub_1008FA854(0);
    sub_1006DD2A0(v14, 18, *(void *)(a1 + 10784));
    uint64_t v15 = *(void *)(a1 + 10784);
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    *(void *)(a1 + 10784) = 0LL;
    uint64_t v16 = sub_1008FA854(0);
    sub_1006DD2A0(v16, 23, *(void *)(a1 + 10792));
    uint64_t v17 = *(void *)(a1 + 10792);
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    }
    *(void *)(a1 + 10792) = 0LL;
    uint64_t v18 = sub_1008FA854(0);
    sub_1006DD2A0(v18, 24, *(void *)(a1 + 10800));
    uint64_t v19 = *(void *)(a1 + 10800);
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    }
    *(void *)(a1 + 1080sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    uint64_t v20 = sub_1008FA854(0);
    sub_1006DD2A0(v20, 25, *(void *)(a1 + 10808));
    uint64_t v21 = *(void *)(a1 + 10808);
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
    *(void *)(a1 + 1080_Block_object_dispose(va, 8) = 0LL;
    uint64_t v22 = sub_1008FA854(0);
    sub_1006DD2A0(v22, 22, *(void *)(a1 + 10816));
    uint64_t v23 = *(void *)(a1 + 10816);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    }
    *(void *)(a1 + 108sub_100708348(v2 - 16) = 0LL;
    uint64_t v24 = sub_1008FA854(0);
    sub_1006DD2A0(v24, 21, *(void *)(a1 + 10840));
    uint64_t v25 = *(void *)(a1 + 10840);
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
    }
    *(void *)(a1 + 1084sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    uint64_t v26 = sub_1008FA854(0);
    sub_1006DD2A0(v26, 26, *(void *)(a1 + 10824));
    uint64_t v27 = *(void *)(a1 + 10824);
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
    }
    *(void *)(a1 + 108sub_10000AE14(v9 + 24) = 0LL;
  }

  sub_100729F60((id *)a1);
  notify_cancel(*(_DWORD *)(a1 + 112));

  *(void *)(a1 + 8072) = 0LL;
  *(void *)(a1 + 106sub_10000AE14(v9 + 24) = 0LL;

  *(void *)(a1 + 10632) = 0LL;
  [*(id *)(a1 + 10656) invalidate];

  __int16 v28 = *(void **)(a1 + 10664);
  *(_OWORD *)(a1 + 10656) = 0u;
  if (v28) {
    sub_100741594(a1 + 10664, v28);
  }
  uint64_t v29 = *(dispatch_source_s **)(a1 + 360);
  if (v29)
  {
    dispatch_source_cancel(v29);
    dispatch_release(*(dispatch_object_t *)(a1 + 360));
    *(void *)(a1 + 36sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  uint64_t v30 = *(dispatch_source_s **)(a1 + 368);
  if (v30)
  {
    dispatch_source_cancel(v30);
    dispatch_release(*(dispatch_object_t *)(a1 + 368));
    *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  }

  if (*(void *)(a1 + 128))
  {
    uint64_t v31 = (void *)sub_100D99BCC();
    operator delete(v31);
  }

  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
}

void sub_100732BDC(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  if (*a3 == 2)
  {
    __int128 v6 = a4[13];
    __int128 v54 = a4[12];
    __int128 v55 = v6;
    uint64_t v56 = *((void *)a4 + 28);
    __int128 v7 = a4[9];
    __int128 v50 = a4[8];
    __int128 v51 = v7;
    __int128 v8 = a4[10];
    __int128 v53 = a4[11];
    __int128 v52 = v8;
    __int128 v9 = a4[5];
    __int128 v46 = a4[4];
    __int128 v47 = v9;
    __int128 v10 = a4[6];
    __int128 v49 = a4[7];
    __int128 v48 = v10;
    __int128 v11 = a4[1];
    __int128 v42 = *a4;
    __int128 v43 = v11;
    __int128 v12 = a4[2];
    __int128 v45 = a4[3];
    __int128 v44 = v12;
    int v13 = sub_100BEF640((uint64_t)&v42);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v14 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134218752;
      *(void *)__int16 v37 = v43;
      *(_WORD *)&v37[8] = 2048;
      *(void *)&v37[10] = v49;
      __int16 v38 = 2048;
      uint64_t v39 = v13;
      __int16 v40 = 2048;
      uint64_t v41 = v50;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Received a workout event of type: %ld, with workout of type: %ld, workout state: %ld and healthkit workout of type: %ld",  buf,  0x2Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v28 = 134218752;
      uint64_t v29 = v43;
      __int16 v30 = 2048;
      uint64_t v31 = v49;
      __int16 v32 = 2048;
      uint64_t v33 = v13;
      __int16 v34 = 2048;
      uint64_t v35 = v50;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Received a workout event of type: %ld, with workout of type: %ld, workout state: %ld and healthkit workout of type: %ld",  &v28,  42);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, co nst CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }

    if (v13 == 2)
    {
      if (!*(void *)(a1 + 10640))
      {
LABEL_30:
        sub_1000B072C(*(void **)(a1 + 128), *(void *)(a1 + 10640));
        return;
      }

      if (sub_10071FC64(a1))
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v19 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v20 = *(void *)(a1 + 10640);
          *(_DWORD *)__int128 buf = 134218496;
          *(void *)__int16 v37 = v20;
          *(_WORD *)&v37[8] = 2048;
          *(void *)&v37[10] = (uint64_t)*(double *)&v42;
          __int16 v38 = 2048;
          uint64_t v39 = (uint64_t)*((double *)&v42 + 1);
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Updating end stats with workout type: %ld, start time: %ld, end time: %ld",  buf,  0x20u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          uint64_t v24 = *(void *)(a1 + 10640);
          int v28 = 134218496;
          uint64_t v29 = v24;
          __int16 v30 = 2048;
          uint64_t v31 = (uint64_t)*(double *)&v42;
          __int16 v32 = 2048;
          uint64_t v33 = (uint64_t)*((double *)&v42 + 1);
          LODWORD(v27) = 32;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Updating end stats with workout type: %ld, start time: %ld, end time: %ld",  &v28,  v27);
          uint64_t v26 = (uint8_t *)v25;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification & , const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v25);
          if (v26 != buf) {
            free(v26);
          }
        }

        uint64_t v21 = sub_1008D9630();
        sub_1008DB224(v21, *(void *)(a1 + 10640), *(double *)&v42, *((double *)&v42 + 1));
      }

      int v16 = 0;
      *(void *)(a1 + 1064sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    }

    else
    {
      if (v13 != 1) {
        goto LABEL_30;
      }
      uint64_t v15 = v49;
      if (*(void *)(a1 + 10640) == (void)v49) {
        goto LABEL_30;
      }
      *(void *)(a1 + 1064sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v49;
      if (v15 == 14) {
        int v16 = *((_DWORD *)a4 + 32);
      }
      else {
        int v16 = 0;
      }
    }

    *(_DWORD *)(a1 + 1064_Block_object_dispose(va, 8) = v16;
    sub_10072B534(a1);
    sub_1007275FC(a1, 0);
    goto LABEL_30;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v17 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)__int16 v37 = 0;
    *(_WORD *)&v37[4] = 2082;
    *(void *)&v37[6] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Received a un-subscribed notification}",  buf,  0x12u);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
  }

  uint64_t v18 = (os_log_s *)qword_1019345D8;
  if (os_signpost_enabled((os_log_t)qword_1019345D8))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)__int16 v37 = 0;
    *(_WORD *)&v37[4] = 2082;
    *(void *)&v37[6] = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received a un-subscribed notification",  "{msg%{public}.0s:Received a un-subscribed notification}",  buf,  0x12u);
  }

void sub_100733194(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  if (*a3 == 4)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    __int128 v8 = a4[9];
    __int128 v83 = a4[8];
    __int128 v84 = v8;
    __int128 v9 = a4[11];
    __int128 v85 = a4[10];
    __int128 v86 = v9;
    __int128 v10 = a4[5];
    __int128 v79 = a4[4];
    __int128 v80 = v10;
    __int128 v11 = a4[7];
    __int128 v81 = a4[6];
    __int128 v82 = v11;
    __int128 v12 = a4[1];
    __int128 v75 = *a4;
    __int128 v76 = v12;
    BOOL v13 = *(double *)(a1 + 7840) == 0.0;
    __int128 v14 = a4[3];
    __int128 v77 = a4[2];
    __int128 v78 = v14;
    if (!v13)
    {
      *(CFAbsoluteTime *)&__int128 v63 = Current;
      *((CFAbsoluteTime *)&v63 + 1) = v7;
      __int128 v15 = a4[9];
      *(_OWORD *)&v71[16] = a4[8];
      __int128 v72 = v15;
      __int128 v16 = a4[11];
      __int128 v73 = a4[10];
      __int128 v74 = v16;
      __int128 v17 = a4[5];
      __int128 v68 = a4[4];
      __int128 v69 = v17;
      __int128 v18 = a4[7];
      __int128 v70 = a4[6];
      *(_OWORD *)uint64_t v71 = v18;
      __int128 v19 = a4[1];
      __int128 v64 = *a4;
      __int128 v65 = v19;
      __int128 v20 = a4[3];
      __int128 v66 = a4[2];
      __int128 v67 = v20;
      *((double *)&v65 + 1) = *((double *)&v65 + 1) - *(double *)(a1 + 7880);
      double v21 = *(double *)v71 - *(double *)(a1 + 7968);
      *(double *)&__int128 v70 = *(double *)&v70 - *(double *)(a1 + 7952);
      *(double *)uint64_t v71 = v21;
      v52[1] = CFAbsoluteTimeGetCurrent();
      __int128 v53 = v64;
      __int128 v54 = v65;
      __int128 v55 = v66;
      __int128 v56 = v67;
      uint64_t v57 = v68;
      int32x2_t v58 = vrev64_s32(*(int32x2_t *)&v69);
      __int128 v59 = v70;
      double v60 = v21;
      v52[0] = &off_101858600;
      __int128 v61 = *(_OWORD *)&v71[8];
      uint64_t v62 = *(void *)&v71[24];
      memset(&__p, 0, sizeof(__p));
      sub_100806A64((uint64_t)v52, &__p);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v22 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 136315138;
        int v90 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        __int128 v43 = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int128 v43 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        int v87 = 136315138;
        int v88 = v43;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "%s",  (const char *)&v87);
        __int128 v45 = (uint8_t *)v44;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onOdometerUpdate(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNoti fier_Type::NotificationData &)",  "%s\n",  v44);
        if (v45 != buf) {
          free(v45);
        }
      }

      if (((sub_100726A64(a1) & 1) != 0 || (sub_100726B2C() & 1) != 0 || sub_100726B94())
        && *(void *)(a1 + 7576))
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v24 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Logging odometer to logger.", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v87) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging odometer to logger.",  &v87,  2);
          __int128 v49 = (uint8_t *)v48;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onOdometerUpdate(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNo tifier_Type::NotificationData &)",  "%s\n",  v48);
          if (v49 != buf) {
            free(v49);
          }
        }

        [*(id *)(a1 + 136) logOdometer:&v63];
      }

      LOBYTE(v87) = 0;
      sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)&v87, 0);
      if (buf[1])
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v25 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "Logging odometer for user studies.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v87) = 0;
          LODWORD(v5sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging odometer for user studies.",  &v87,  v50);
          __int128 v47 = (uint8_t *)v46;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onOdometerUpdate(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNo tifier_Type::NotificationData &)",  "%s\n",  v46);
          if (v47 != buf) {
            free(v47);
          }
        }

        objc_msgSend( *(id *)(a1 + 216),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", v52));
      }

      uint64_t v26 = operator new(0xE0uLL);
      __int128 v27 = v73;
      v26[11] = v72;
      v26[12] = v27;
      v26[13] = v74;
      __int128 v28 = v70;
      v26[7] = v69;
      v26[8] = v28;
      __int128 v29 = *(_OWORD *)&v71[16];
      v26[9] = *(_OWORD *)v71;
      v26[10] = v29;
      __int128 v30 = v66;
      v26[3] = v65;
      v26[4] = v30;
      __int128 v31 = v68;
      v26[5] = v67;
      v26[6] = v31;
      __int128 v32 = v64;
      v26[1] = v63;
      _OWORD v26[2] = v32;
      uint64_t v33 = *(void *)(a1 + 8048);
      *(void *)uint64_t v26 = v33;
      *((void *)v26 + 1) = a1 + 8048;
      *(void *)(v33 + _Block_object_dispose(va, 8) = v26;
      unint64_t v34 = *(void *)(a1 + 8064) + 1LL;
      *(void *)(a1 + 804_Block_object_dispose(va, 8) = v26;
      for (*(void *)(a1 + 8064) = v34; ; unint64_t v34 = *(void *)(a1 + 8064))
      {
        int v87 = 10;
        sub_10023AE2C(buf, "FallOdometerHistorySize", &v87, 0);
        uint64_t v35 = *(uint64_t **)(a1 + 8056);
        uint64_t v36 = *v35;
        *(void *)(v36 + _Block_object_dispose(va, 8) = v35[1];
        *(void *)v35[1] = v36;
        --*(void *)(a1 + 8064);
        operator delete(v35);
      }
    }

    *(CFAbsoluteTime *)(a1 + 784sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = Current;
    *(CFAbsoluteTime *)(a1 + 784_Block_object_dispose(va, 8) = v7;
    __int128 v37 = v84;
    *(_OWORD *)(a1 + 7984) = v83;
    *(_OWORD *)(a1 + 800sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v37;
    __int128 v38 = v86;
    *(_OWORD *)(a1 + 80sub_100708348(v2 - 16) = v85;
    *(_OWORD *)(a1 + 8032) = v38;
    __int128 v39 = v80;
    *(_OWORD *)(a1 + 792sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v79;
    *(_OWORD *)(a1 + 7936) = v39;
    __int128 v40 = v82;
    *(_OWORD *)(a1 + 7952) = v81;
    *(_OWORD *)(a1 + 796_Block_object_dispose(va, 8) = v40;
    __int128 v41 = v76;
    *(_OWORD *)(a1 + 7856) = v75;
    *(_OWORD *)(a1 + 7872) = v41;
    __int128 v42 = v78;
    *(_OWORD *)(a1 + 788_Block_object_dispose(va, 8) = v77;
    *(_OWORD *)(a1 + 7904) = v42;
  }

void sub_100733894( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007338C0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 7107;
  if ((!sub_10071E52C() || CFAbsoluteTimeGetCurrent() >= 654764400.0)
    && [*(id *)(a1 + 136) isLoggingEnabled])
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Logger manager was enabled whereas data collection date is passed - Disabling logger manager}",  buf,  0x12u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
    }

    __int128 v6 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Logger manager was enabled whereas data collection date is passed - Disabling logger manager",  "{msg%{public}.0s:Logger manager was enabled whereas data collection date is passed - Disabling logger manager}",  buf,  0x12u);
    }

    [*(id *)(a1 + 136) setLoggingEnabled:0];
    [*(id *)(a1 + 136) clearAllLogs];
    [*(id *)(a1 + 160) cleanUp:0.0];
    sub_100729F60((id *)a1);
  }

  *(void *)unint64_t v34 = *a2;
  *(void *)&v34[5] = *(uint64_t *)((char *)a2 + 5);
  int v7 = *((unsigned __int8 *)a2 + 13);
  char v8 = *((_BYTE *)a2 + 14);
  char v9 = *((_BYTE *)a2 + 15);
  __int16 v32 = *((_WORD *)a2 + 8);
  char v33 = *((_BYTE *)a2 + 18);
  uint64_t v10 = *(uint64_t *)((char *)a2 + 19);
  __int128 v11 = *(_OWORD *)((char *)a2 + 27);
  __int128 v12 = *(_OWORD *)((char *)a2 + 43);
  __int128 v13 = *(_OWORD *)((char *)a2 + 75);
  __int128 v38 = *(_OWORD *)((char *)a2 + 59);
  __int128 v39 = v13;
  *(_OWORD *)__int128 buf = v11;
  *(_OWORD *)&uint8_t buf[16] = v12;
  __int128 v14 = *(_OWORD *)((char *)a2 + 91);
  __int128 v15 = *(_OWORD *)((char *)a2 + 107);
  __int128 v16 = *(_OWORD *)((char *)a2 + 123);
  *(_OWORD *)((char *)v42 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)((char *)a2 + 133);
  __int128 v41 = v15;
  v42[0] = v16;
  __int128 v40 = v14;
  int v17 = *((unsigned __int8 *)a2 + 149);
  *(_OWORD *)&v36[9] = *(_OWORD *)((char *)a2 + 175);
  __int128 v35 = *(_OWORD *)((char *)a2 + 150);
  *(_OWORD *)uint64_t v36 = *(_OWORD *)((char *)a2 + 166);
  uint64_t v18 = *(void *)(a1 + 7304);
  if (v18 == v10 && *(unsigned __int8 *)(v4 + 327) == v17)
  {
    goto LABEL_28;
  }

  BOOL v19 = *(void *)(v4 + 6) != v10 || *(unsigned __int8 *)(v4 + 136) != v17;
  if (v18 != v10 || *(unsigned __int8 *)(v4 + 327) != v17)
  {
    if (!v19) {
      return;
    }
    LOBYTE(v21) = v9 & 1;
    goto LABEL_27;
  }

  int v20 = *(unsigned __int8 *)(v4 + 191);
  int v21 = v20 != v7;
  if (v20 != v7 || !v19)
  {
    if (!v19) {
      goto LABEL_31;
    }
LABEL_27:
    uint64_t v22 = *a2;
    int v23 = *((_DWORD *)a2 + 2);
    char v24 = *((_BYTE *)a2 + 12);
    __int128 v25 = v41;
    *(_OWORD *)(a1 + 7185) = v40;
    *(_OWORD *)(a1 + 7201) = v25;
    *(_OWORD *)(a1 + 7217) = v42[0];
    *(_OWORD *)(a1 + 7227) = *(_OWORD *)((char *)v42 + 10);
    __int128 v26 = *(_OWORD *)&buf[16];
    *(_OWORD *)(a1 + 7121) = *(_OWORD *)buf;
    *(_OWORD *)(a1 + 7137) = v26;
    __int128 v27 = v39;
    *(_OWORD *)(a1 + 7153) = v38;
    *(_OWORD *)(a1 + 7169) = v27;
    *(_OWORD *)(a1 + 7269) = *(_OWORD *)&v36[9];
    *(_OWORD *)(a1 + 726sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)v36;
    *(_BYTE *)(a1 + 7106) = v24;
    *(_DWORD *)(a1 + 7102) = v23;
    *(void *)(a1 + 7094) = v22;
    *(_BYTE *)uint64_t v4 = v7;
    *(_BYTE *)(v4 + 1) = v8;
    *(_BYTE *)(v4 + 2) = v9;
    *(_WORD *)(a1 + 711sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v32;
    *(_BYTE *)(a1 + 7sub_10000AE14(v2 - 112) = v33;
    *(void *)(v4 + 6) = v10;
    *(_BYTE *)(v4 + 136) = v17;
    *(_OWORD *)(a1 + 7244) = v35;
    char v28 = v8;
    sub_100733CF0(a1, a1 + 7094);
    sub_10071F508(a1, a1 + 7094);
    char v8 = v28;
    if ((v21 & 1) == 0) {
      return;
    }
    goto LABEL_28;
  }

  int v21 = v9 & 1;
  if (v19) {
    goto LABEL_27;
  }
LABEL_31:
  if (!v21) {
    return;
  }
LABEL_28:
  *(void *)(a1 + 7285) = *(void *)v34;
  *(void *)(a1 + 729sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)&v34[5];
  *(_BYTE *)(v4 + 191) = v7;
  *(_BYTE *)(v4 + 192) = v8;
  *(_BYTE *)(v4 + 193) = v9;
  *(_WORD *)(a1 + 7301) = v32;
  *(_BYTE *)(a1 + 7303) = v33;
  *(void *)(a1 + 7304) = v10;
  *(_OWORD *)(a1 + 740_Block_object_dispose(va, 8) = v42[0];
  __int128 v29 = v40;
  *(_OWORD *)(a1 + 7392) = v41;
  *(_OWORD *)(a1 + 7376) = v29;
  __int128 v30 = v38;
  *(_OWORD *)(a1 + 736sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v39;
  *(_OWORD *)(a1 + 7344) = v30;
  __int128 v31 = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 732_Block_object_dispose(va, 8) = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 7312) = v31;
  *(_OWORD *)(a1 + 741_Block_object_dispose(va, 8) = *(_OWORD *)((char *)v42 + 10);
  *(_BYTE *)(v4 + 327) = v17;
  *(_OWORD *)(a1 + 746sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)&v36[9];
  *(_OWORD *)(a1 + 7451) = *(_OWORD *)v36;
  *(_OWORD *)(a1 + 7435) = v35;
  sub_10071F508(a1, a1 + 7285);
}

void sub_100733CF0(uint64_t a1, uint64_t a2)
{
  float v4 = sub_100734D60((float *)(a2 + 27));
  if ((*(_BYTE *)(a2 + 16) | ((LODWORD(v4) & 0x7FFFFFFFu) > 0x7F7FFFFF)) | ((*(unsigned __int8 *)(a2 + 18) | (v4 >= *(float *)(a1 + 7480))) != 0))
  {
    if (*(unsigned __int8 *)(a2 + 13) | *(unsigned __int8 *)(a2 + 2))
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v5 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Impact stats logged in previous state, will disregard duplicate logging.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        v48[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Impact stats logged in previous state, will disregard duplicate logging.",  v48,  2);
        int v7 = (uint8_t *)v6;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v6);
LABEL_19:
        if (v7 != buf) {
          free(v7);
        }
      }
    }

    else
    {
      if (sub_100726D28(a1))
      {
        if (*(int *)(a1 + 280) <= 0 && v4 >= *(float *)(a1 + 7488))
        {
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          uint64_t v10 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Taking power assertion due to significant impact event subscription.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            v48[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  1LL,  "Taking power assertion due to significant impact event subscription.",  v48,  2);
            __int128 v45 = (uint8_t *)v44;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v44);
            if (v45 != buf) {
              free(v45);
            }
          }

          sub_1010DDBC0(__p, "Fall Stats triggered high resolution sensor read");
          sub_100AD5668(a1 + 272, (uint64_t *)__p);
          if (v50 < 0) {
            operator delete(__p[0]);
          }
        }

        [*(id *)(a1 + 320) nextFireDelay];
        if (v11 == 1.79769313e308)
        {
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          __int128 v12 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Setting fail safe timer for 180s.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            v48[0] = 0;
            LODWORD(v46) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Setting fail safe timer for 180s.",  v48,  v46);
            __int128 v41 = (uint8_t *)v40;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v40);
            if (v41 != buf) {
              free(v41);
            }
          }

          [*(id *)(a1 + 320) setNextFireDelay:180.0];
        }

        float v13 = *(float *)(a1 + 7476);
        if (v4 >= v13)
        {
          if (*(_BYTE *)(a2 + 16)) {
            BOOL v14 = 1;
          }
          else {
            BOOL v14 = *(_BYTE *)(a2 + 15) != 0;
          }
        }

        else
        {
          BOOL v14 = 0;
        }

        if (*(_DWORD *)(a1 + 7640) != 1) {
          BOOL v14 = 0;
        }
        BOOL v15 = (*(unsigned __int8 *)(a2 + 18) | v14) != 0;
        if ((sub_100734E18() & v15) == 1)
        {
          [*(id *)(*(void *)(a1 + 10880) + 16) register:*(void *)(*(void *)(a1 + 10880) + 8) forNotification:4 registrationInfo:0];
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          __int128 v16 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "High impact event HR subscription.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            v48[0] = 0;
            LODWORD(v46) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "High impact event HR subscription.",  v48,  v46);
            __int128 v43 = (uint8_t *)v42;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v42);
            if (v43 != buf) {
              free(v43);
            }
          }
        }
      }

      sub_100740784((uint64_t)v48, a2);
      memset(&v47, 0, sizeof(v47));
      sub_100804C08((uint64_t)v48, &v47);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      int v17 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = &v47;
        if ((v47.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v18 = (std::string *)v47.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 136315138;
        __int128 v54 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        __int128 v26 = &v47;
        if ((v47.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int128 v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
        }
        int v51 = 136315138;
        __int128 v52 = v26;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "%s",  (const char *)&v51);
        char v28 = (uint8_t *)v27;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v27);
        if (v28 != buf) {
          free(v28);
        }
      }

      if ((char)v47.__r_.__value_.__s.__size_ < 0)
      {
        *v47.__r_.__value_.__l.__data_ = 0;
        v47.__r_.__value_.__l.__size_ = 0LL;
      }

      else
      {
        v47.__r_.__value_.__s.__data_[0] = 0;
        v47.__r_.__value_.__s.__size_ = 0;
      }

      sub_100804CC8((uint64_t)v48, &v47);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      BOOL v19 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        int v20 = &v47;
        if ((v47.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          int v20 = (std::string *)v47.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 136315138;
        __int128 v54 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        __int128 v29 = &v47;
        if ((v47.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int128 v29 = (std::string *)v47.__r_.__value_.__r.__words[0];
        }
        int v51 = 136315138;
        __int128 v52 = v29;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "%s",  (const char *)&v51);
        __int128 v31 = (uint8_t *)v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v30);
        if (v31 != buf) {
          free(v31);
        }
      }

      if (*(_BYTE *)(a2 + 16)) {
        *(_BYTE *)(a1 + 449) = 1;
      }
      if ((sub_100726A64(a1) & 1) != 0 || (sub_100726B2C() & 1) != 0 || sub_100726B94())
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        int v21 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Logging impact stats to logger.", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v51) = 0;
          LODWORD(v46) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact stats to logger.",  &v51,  v46);
          char v33 = (uint8_t *)v32;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v32);
          if (v33 != buf) {
            free(v33);
          }
        }

        [*(id *)(a1 + 136) logImpactEvent:a2];
      }

      LOBYTE(v51) = 0;
      sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)&v51, 0);
      if (buf[1])
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        uint64_t v22 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "Logging impact stats for user studies.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v51) = 0;
          LODWORD(v46) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact stats for user studies.",  &v51,  v46);
          __int128 v35 = (uint8_t *)v34;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v34);
          if (v35 != buf) {
            free(v35);
          }
        }

        objc_msgSend( *(id *)(a1 + 168),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", v48));
      }

      if (sub_10071FC64(a1))
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        int v23 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Logging impact stats to AWD", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v51) = 0;
          LODWORD(v46) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact stats to AWD",  &v51,  v46);
          __int128 v37 = (uint8_t *)v36;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v36);
          if (v37 != buf) {
            free(v37);
          }
        }

        uint64_t v24 = sub_1008D9630();
        sub_1008D99F0(v24, a2);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        __int128 v25 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "Logging impact stats to CoreAnalytics",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10184D4F8);
          }
          LOWORD(v51) = 0;
          LODWORD(v46) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging impact stats to CoreAnalytics",  &v51,  v46);
          __int128 v39 = (uint8_t *)v38;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v38);
          if (v39 != buf) {
            free(v39);
          }
        }

        sub_100D99FFC(*(void *)(a1 + 128), a2);
      }
    }
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Impact does not meet logging threshold requirement, will disregard stats.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v48[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Impact does not meet logging threshold requirement, will disregard stats.",  v48,  2);
      int v7 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)",  "%s\n",  v9);
      goto LABEL_19;
    }
  }

void sub_100734D10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float sub_100734D60(float *a1)
{
  float v2 = *a1;
  float v1 = a1[1];
  if (v1 >= 0.0) {
    float v3 = a1[1];
  }
  else {
    float v3 = -v1;
  }
  if (v2 >= 0.0) {
    float v4 = *a1;
  }
  else {
    float v4 = -v2;
  }
  if (v2 < 0.0) {
    float v2 = -v2;
  }
  if (v1 < 0.0) {
    float v1 = -v1;
  }
  if (v3 <= v4) {
    float v1 = v2;
  }
  float v6 = a1[2];
  float v5 = a1[3];
  if (v5 >= 0.0) {
    float v7 = a1[3];
  }
  else {
    float v7 = -v5;
  }
  if (v6 >= 0.0) {
    float v8 = a1[2];
  }
  else {
    float v8 = -v6;
  }
  if (v7 <= v8)
  {
    float v5 = a1[2];
    if (v6 < 0.0) {
      float v5 = -v6;
    }
  }

  else if (v5 < 0.0)
  {
    float v5 = -v5;
  }

  float v10 = a1[4];
  float v9 = a1[5];
  if (v9 >= 0.0) {
    float v11 = a1[5];
  }
  else {
    float v11 = -v9;
  }
  if (v10 >= 0.0) {
    float v12 = a1[4];
  }
  else {
    float v12 = -v10;
  }
  if (v10 < 0.0) {
    float v10 = -v10;
  }
  if (v9 < 0.0) {
    float v9 = -v9;
  }
  if (v11 <= v12) {
    float v9 = v10;
  }
  return sqrtf((float)((float)(v5 * v5) + (float)(v1 * v1)) + (float)(v9 * v9));
}

uint64_t sub_100734E18()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019983E8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1019983E8))
  {
    unsigned __int8 v2 = 0;
    sub_1012049AC(v3, "FallStatsHeartRateEnabled", &v2, 0);
    byte_1019983E4 = v3[1];
    __cxa_guard_release(&qword_1019983E8);
  }

  return byte_1019983E4;
}

void sub_100734E94(_Unwind_Exception *a1)
{
}

void sub_100734EAC(uint64_t a1, float a2)
{
  if (sub_10071FC64(a1))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v4 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Logging age group to AWD and CoreAnalytics",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v16[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging age group to AWD and CoreAnalytics",  v16,  2);
      BOOL v15 = (uint8_t *)v14;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logUserAge(const float)", "%s\n", v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    if (a2 != 30.0)
    {
      int v5 = (int)a2;
      else {
        int v6 = (int)a2;
      }
      if (v5 <= 64) {
        int v7 = 5 * (v5 / 5);
      }
      else {
        int v7 = v6;
      }
      float v8 = (float)v7;
      uint64_t v9 = a1 + 10568;
      sub_100DEAD38(v9, (int)(float)v7);
      sub_100DEADA0(v9);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      float v10 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 68289283;
        int v18 = 0;
        __int16 v19 = 2082;
        int v20 = "";
        __int16 v21 = 1025;
        LODWORD(v22) = a2 >= 65.0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingAllDayAWD: Updating user age group, belongsToOlderGroup:%{private}hhd}",  buf,  0x18u);
      }

      uint64_t v11 = sub_1008D9630();
      sub_1008D9CC8(v11, a2 >= 65.0);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      float v12 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 68289283;
        int v18 = 0;
        __int16 v19 = 2082;
        int v20 = "";
        __int16 v21 = 2049;
        double v22 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingAllDayAWD: Updating user age bin, value:%{private}f}",  buf,  0x1Cu);
      }

      uint64_t v13 = sub_1008D9630();
      sub_1008DAE14(v13, v8);
    }
  }

uint64_t sub_100735200(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 240))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    unsigned __int8 v2 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = *(void *)(v1 + 10640);
      v4[0] = 68289282;
      v4[1] = 0;
      __int16 v5 = 2082;
      int v6 = "";
      __int16 v7 = 2050;
      uint64_t v8 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Impact during, Workout type :%{public}llu}",  (uint8_t *)v4,  0x1Cu);
    }

    return (*(uint64_t (**)(void))(*(void *)(v1 + 240) + 16LL))();
  }

  return result;
}

uint64_t sub_10073532C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 240))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    unsigned __int8 v2 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = *(void *)(v1 + 10640);
      v4[0] = 68289282;
      v4[1] = 0;
      __int16 v5 = 2082;
      int v6 = "";
      __int16 v7 = 2050;
      uint64_t v8 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Impact during, Workout type :%{public}llu}",  (uint8_t *)v4,  0x1Cu);
    }

    return (*(uint64_t (**)(void))(*(void *)(v1 + 240) + 16LL))();
  }

  return result;
}

void sub_100735458(uint64_t a1, __int128 *a2)
{
  unsigned __int8 v2 = (unsigned __int8 *)(a1 + 6725);
  if (*(_BYTE *)(a1 + 7828))
  {
    __int16 v5 = (_OWORD *)(a1 + 6712);
    if (*(void *)(a1 + 6731) == *(void *)((char *)a2 + 19))
    {
      if (*v2 == *((unsigned __int8 *)a2 + 13))
      {
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        int v6 = (os_log_s *)qword_1019345D8;
        if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(void *)((char *)a2 + 19);
          int v8 = *((unsigned __int8 *)a2 + 149);
          uint64_t v9 = *(void *)((char *)a2 + 166);
          uint64_t v10 = *(void *)((char *)a2 + 158);
          int v11 = *((unsigned __int8 *)a2 + 13);
          int v12 = *((unsigned __int8 *)a2 + 156);
          int v13 = *((unsigned __int8 *)a2 + 157);
          int v14 = v2[177];
          int v53 = 68291331;
          int v54 = 0;
          __int16 v55 = 2082;
          __int128 v56 = "";
          __int16 v57 = 2082;
          int32x2_t v58 = "downstream";
          __int16 v59 = 2050;
          uint64_t v60 = v7;
          __int16 v61 = 1025;
          int v62 = v8;
          __int16 v63 = 2049;
          uint64_t v64 = v9;
          __int16 v65 = 2049;
          uint64_t v66 = v10;
          __int16 v67 = 1025;
          int v68 = v11;
          __int16 v69 = 1025;
          int v70 = v12;
          __int16 v71 = 1025;
          int v72 = v13;
          __int16 v73 = 1025;
          int v74 = v14;
          BOOL v15 = "{msg%{public}.0s:Notifier - Received anomaly event notification (already seen it), direction"
                ":%{public, location:escape_only}s, aop timestamp:%{public}llu, operatingMode:%{private}u, anom"
                "aly timestamp:%{private}f, update timestamp:%{private}f, state:%{private}d, response"
                ":%{private}d, resolution:%{private}d, sos_state:%{private}d}";
LABEL_12:
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v53, 0x58u);
          return;
        }

        return;
      }

      __int16 v33 = *(_WORD *)(a1 + 6868);
      double v34 = *(double *)(a1 + 6870);
      __int128 v35 = a2[8];
      __int128 v36 = a2[9];
      __int128 v37 = a2[10];
      *(_OWORD *)(a1 + 6887) = *(__int128 *)((char *)a2 + 175);
      *(_OWORD *)(a1 + 6856) = v36;
      *(_OWORD *)(a1 + 6872) = v37;
      __int128 v38 = *a2;
      __int128 v39 = a2[1];
      __int128 v40 = a2[3];
      *(_OWORD *)(a1 + 6744) = a2[2];
      *(_OWORD *)(a1 + 676sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v40;
      *__int16 v5 = v38;
      *(_OWORD *)(a1 + 672_Block_object_dispose(va, 8) = v39;
      __int128 v41 = a2[4];
      __int128 v42 = a2[5];
      __int128 v43 = a2[7];
      *(_OWORD *)(a1 + 680_Block_object_dispose(va, 8) = a2[6];
      *(_OWORD *)(a1 + 68sub_10000AE14(v9 + 24) = v43;
      *(_OWORD *)(a1 + 6776) = v41;
      *(_OWORD *)(a1 + 6792) = v42;
      *(_OWORD *)(a1 + 684sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v35;
      *(_WORD *)(a1 + 686_Block_object_dispose(va, 8) = v33;
      *(double *)(a1 + 687sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v34;
    }

    else
    {
      __int128 v24 = *a2;
      __int128 v25 = a2[1];
      __int128 v26 = a2[3];
      *(_OWORD *)(a1 + 6744) = a2[2];
      *(_OWORD *)(a1 + 676sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v26;
      *__int16 v5 = v24;
      *(_OWORD *)(a1 + 672_Block_object_dispose(va, 8) = v25;
      __int128 v27 = a2[4];
      __int128 v28 = a2[5];
      __int128 v29 = a2[7];
      *(_OWORD *)(a1 + 680_Block_object_dispose(va, 8) = a2[6];
      *(_OWORD *)(a1 + 68sub_10000AE14(v9 + 24) = v29;
      *(_OWORD *)(a1 + 6776) = v27;
      *(_OWORD *)(a1 + 6792) = v28;
      __int128 v30 = a2[8];
      __int128 v31 = a2[9];
      __int128 v32 = a2[10];
      *(_OWORD *)(a1 + 6887) = *(__int128 *)((char *)a2 + 175);
      *(_OWORD *)(a1 + 6856) = v31;
      *(_OWORD *)(a1 + 6872) = v32;
      *(_OWORD *)(a1 + 684sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v30;
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int128 v44 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v45 = *(void *)(v2 + 6);
      int v46 = v2[136];
      uint64_t v47 = *(void *)(v2 + 153);
      uint64_t v48 = *(void *)(v2 + 145);
      int v49 = *v2;
      int v50 = v2[143];
      int v51 = v2[144];
      int v52 = v2[177];
      int v53 = 68291331;
      int v54 = 0;
      __int16 v55 = 2082;
      __int128 v56 = "";
      __int16 v57 = 2082;
      int32x2_t v58 = "downstream";
      __int16 v59 = 2050;
      uint64_t v60 = v45;
      __int16 v61 = 1025;
      int v62 = v46;
      __int16 v63 = 2049;
      uint64_t v64 = v47;
      __int16 v65 = 2049;
      uint64_t v66 = v48;
      __int16 v67 = 1025;
      int v68 = v49;
      __int16 v69 = 1025;
      int v70 = v50;
      __int16 v71 = 1025;
      int v72 = v51;
      __int16 v73 = 1025;
      int v74 = v52;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Notifier - Received anomaly event notification, direction:%{public, location:escape _only}s, aop timestamp:%{public}llu, operatingMode:%{private}u, anomaly timestamp:%{private}f,  update timestamp:%{private}f, state:%{private}d, response:%{private}d, resolution:%{private}d, sos_state:%{private}d}",  (uint8_t *)&v53,  0x58u);
    }

    sub_1007275FC(a1, 0);
    sub_100727B3C(a1, (uint64_t)v5, 0);
    return;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v6 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(v2 + 6);
    int v17 = v2[136];
    uint64_t v18 = *(void *)(v2 + 153);
    uint64_t v19 = *(void *)(v2 + 145);
    int v20 = *v2;
    int v21 = v2[143];
    int v22 = v2[144];
    int v23 = v2[177];
    int v53 = 68291331;
    int v54 = 0;
    __int16 v55 = 2082;
    __int128 v56 = "";
    __int16 v57 = 2082;
    int32x2_t v58 = "downstream";
    __int16 v59 = 2050;
    uint64_t v60 = v16;
    __int16 v61 = 1025;
    int v62 = v17;
    __int16 v63 = 2049;
    uint64_t v64 = v18;
    __int16 v65 = 2049;
    uint64_t v66 = v19;
    __int16 v67 = 1025;
    int v68 = v20;
    __int16 v69 = 1025;
    int v70 = v21;
    __int16 v71 = 1025;
    int v72 = v22;
    __int16 v73 = 1025;
    int v74 = v23;
    BOOL v15 = "{msg%{public}.0s:Notifier - Received anomaly event notification while detector is disabled - ignoring,"
          " direction:%{public, location:escape_only}s, aop timestamp:%{public}llu, operatingMode:%{private}u"
          ", anomaly timestamp:%{private}f, update timestamp:%{private}f, state:%{private}d, respon"
          "se:%{private}d, resolution:%{private}d, sos_state:%{private}d}";
    goto LABEL_12;
  }

unsigned __int8 *sub_100735898(unsigned __int8 *result, uint64_t *a2, unsigned int a3)
{
  uint64_t v5 = (uint64_t)result;
  int v6 = (char *)(result + 10720);
  uint64_t v7 = *((void *)result + 946);
  if (!v7)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Receiving Accel800", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      *(_WORD *)int v14 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving Accel800",  v14,  2);
      int v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataAccel800(const CLMotionCoprocessorInterface::NotificationData *, unsigned int)",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    *(CFAbsoluteTime *)(v5 + 6704) = CFAbsoluteTimeGetCurrent();
    if ((sub_100726A64(v5) & 1) != 0 || (sub_100726B2C() & 1) != 0) {
      char v9 = 1;
    }
    else {
      char v9 = sub_100726B94();
    }
    char *v6 = v9;
    v14[0] = 0;
    double result = sub_1012049AC(buf, "FallStatsEnabled", v14, 0);
    v6[1] = buf[1];
    _DWORD v6[2] = 0;
    uint64_t v7 = *(void *)(v5 + 7568);
  }

  *(void *)(v5 + 756_Block_object_dispose(va, 8) = v7 + a3;
  if (a3)
  {
    uint64_t v10 = a3;
    do
    {
      if (*v6) {
        double result = (unsigned __int8 *)[*(id *)(v5 + 136) logImpactSensorData:a2];
      }
      if (v6[1])
      {
        uint64_t v11 = a2[1];
        uint64_t v16 = *a2;
        uint64_t v17 = v11;
        uint64_t v19 = *(uint64_t *)((char *)a2 + 17);
        int v20 = *(_DWORD *)((char *)a2 + 25);
        *(void *)__int128 buf = &off_1018581B0;
        uint64_t v18 = *(uint64_t *)((char *)a2 + 33);
        double result = (unsigned __int8 *)objc_msgSend( *(id *)(v5 + 184),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:]( CLFallLoggerManager,  "encodeBinaryLog:",  buf));
      }

      if (v6[2])
      {
        [*(id *)(v5 + 144) logAccel800:a2];
        double result = (unsigned __int8 *)[*(id *)(v5 + 152) logAccel800:a2];
        if (!*(_BYTE *)(v5 + 450))
        {
          *(_BYTE *)(v5 + 45sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
          double result = (unsigned __int8 *)[*(id *)(v5 + 344) setNextFireDelay:1.0];
        }
      }

      a2 += 28;
      --v10;
    }

    while (v10);
  }

  return result;
}

unsigned __int8 *sub_100735B80(unsigned __int8 *result, uint64_t a2, int a3)
{
  LODWORD(v3) = a3;
  uint64_t v5 = (uint64_t)result;
  int v6 = (char *)(result + 10720);
  uint64_t v7 = *((void *)result + 950);
  if (!v7)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Receiving Hgal", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      *(_WORD *)int v14 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving Hgal",  v14,  2);
      int v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataHgal(const CLMotionCoprocessorInterface::NotificationData *, unsigned int)",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    if ((sub_100726A64(v5) & 1) != 0 || (sub_100726B2C() & 1) != 0) {
      char v9 = 1;
    }
    else {
      char v9 = sub_100726B94();
    }
    char *v6 = v9;
    v14[0] = 0;
    double result = sub_1012049AC(buf, "FallStatsEnabled", v14, 0);
    v6[1] = buf[1];
    _DWORD v6[2] = 0;
    uint64_t v7 = *(void *)(v5 + 7600);
  }

  *(void *)(v5 + 760sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v7 + v3;
  if ((_DWORD)v3)
  {
    uint64_t v3 = v3;
    uint64_t v10 = (uint64_t *)(a2 + 17);
    do
    {
      if (v6[1])
      {
        uint64_t v11 = *(uint64_t *)((char *)v10 - 9);
        uint64_t v16 = *(uint64_t *)((char *)v10 - 17);
        uint64_t v17 = v11;
        uint64_t v19 = *v10;
        int v20 = *((_DWORD *)v10 + 2);
        *(void *)__int128 buf = &off_101858340;
        uint64_t v18 = v10[2];
        double result = (unsigned __int8 *)objc_msgSend( *(id *)(v5 + 232),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:]( CLFallLoggerManager,  "encodeBinaryLog:",  buf));
      }

      v10 += 28;
      --v3;
    }

    while (v3);
  }

  return result;
}

void sub_100735E14(uint64_t a1, uint64_t *a2)
{
  if (!(_BYTE)dword_1019983E0++)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Receiving sensor data due to high impact",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v14[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving sensor data due to high impact",  v14,  2);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataGyro200(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  if (!*(void *)(a1 + 7576))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Receiving Gyro200", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v14[0] = 0;
      LODWORD(v13) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving Gyro200",  v14,  v13);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataGyro200(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  ++*(void *)(a1 + 7576);
  if (*(_BYTE *)(a1 + 10720)) {
    [*(id *)(a1 + 136) logImpactSensorData:a2];
  }
  if (*(_BYTE *)(a1 + 10721))
  {
    uint64_t v7 = a2[1];
    uint64_t v16 = *a2;
    uint64_t v17 = v7;
    uint64_t v8 = *(uint64_t *)((char *)a2 + 17);
    int v20 = *(_DWORD *)((char *)a2 + 25);
    *(void *)__int128 buf = &off_101858220;
    uint64_t v18 = *(uint64_t *)((char *)a2 + 33);
    uint64_t v19 = v8;
    objc_msgSend( *(id *)(a1 + 184),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", buf));
  }

  if (*(_BYTE *)(a1 + 10722)) {
    [*(id *)(a1 + 144) logGyro200:a2];
  }
}

void sub_100736190(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(a1 + 7584))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    float v4 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Receiving DeviceMotion100", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v12[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving DeviceMotion100",  v12,  2);
      uint64_t v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataQuaternion6(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    if (!*(void *)(a1 + 120))
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v5 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Creating sensor data collection OS transaction",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        v12[0] = 0;
        LODWORD(v11) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Creating sensor data collection OS transaction",  v12,  v11);
        uint64_t v10 = (uint8_t *)v9;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataQuaternion6(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v9);
        if (v10 != buf) {
          free(v10);
        }
      }

      *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = os_transaction_create("com.apple.locationd.fall.logging");
    }
  }

  ++*(void *)(a1 + 7584);
  if (*(_BYTE *)(a1 + 10720)) {
    [*(id *)(a1 + 136) logImpactSensorData:a2];
  }
  if (*(_BYTE *)(a1 + 10721))
  {
    uint64_t v6 = a2[1];
    uint64_t v14 = *a2;
    uint64_t v15 = v6;
    __int128 v17 = *(_OWORD *)((char *)a2 + 17);
    *(void *)__int128 buf = &off_101858278;
    uint64_t v16 = *(uint64_t *)((char *)a2 + 33);
    objc_msgSend( *(id *)(a1 + 184),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", buf));
  }

  if (*(_BYTE *)(a1 + 10722)) {
    [*(id *)(a1 + 144) logDeviceMotion:a2];
  }
}

void sub_100736508(uint64_t a1, __int128 *a2)
{
  v14[0] = &off_1018582E8;
  char v21 = 3;
  uint64_t v4 = *(void *)((char *)a2 + 76);
  v14[1] = *(void *)((char *)a2 + 68);
  v14[3] = v4;
  v14[4] = *((void *)a2 + 2);
  __int128 v15 = *a2;
  __int16 v16 = *((_WORD *)a2 + 12);
  uint64_t v17 = *(void *)((char *)a2 + 26);
  int v18 = *(_DWORD *)((char *)a2 + 34);
  int v19 = *(_DWORD *)((char *)a2 + 38);
  int v20 = *(_DWORD *)((char *)a2 + 42);
  char v22 = *(_DWORD *)((char *)a2 + 46);
  __int128 v23 = *(__int128 *)((char *)a2 + 50);
  memset(&__p, 0, sizeof(__p));
  sub_100806420((uint64_t)v14, &__p);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v5 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v27 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v8 = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    int v24 = 136315138;
    __int128 v25 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "%s",  (const char *)&v24);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFalsePositiveSuppressionFeatures(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  if (*(_BYTE *)(a1 + 10720)) {
    [*(id *)(a1 + 136) logFalsePositiveSuppressionFeatures:a2];
  }
  if (*(_BYTE *)(a1 + 10721))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v7 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Logging false positive suppression features.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(vsub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Logging false positive suppression features.",  &v24,  2);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFalsePositiveSuppressionFeatures(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    objc_msgSend( *(id *)(a1 + 184),  "logData:",  +[CLFallLoggerManager encodeBinaryLog:](CLFallLoggerManager, "encodeBinaryLog:", v14));
  }

  if (*(_BYTE *)(a1 + 10722)) {
    [*(id *)(a1 + 144) logSuppressionFeartures:a2];
  }
}

void sub_1007368FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100736920(uint64_t a1, std::string::value_type *a2)
{
  uint64_t result = sub_10071FC64(a1);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v20);
    uint64_t v4 = sub_10000CF44(&v21, (uint64_t)"type,", 5LL);
    buf[0].__r_.__value_.__s.__data_[0] = *a2;
    uint64_t v5 = sub_10000CF44(v4, (uint64_t)buf, 1LL);
    sub_10000CF44(v5, (uint64_t)",bins,", 6LL);
    for (uint64_t i = 1LL; i != 25; ++i)
    {
      if (i == 1) {
        uint64_t v7 = "";
      }
      else {
        uint64_t v7 = " ";
      }
      uint64_t v8 = sub_10000CF44(&v21, (uint64_t)v7, i != 1);
      std::ostream::operator<<(v8, a2[i]);
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Logging Max Accel Norm feature distribution to awd.",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v24.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Logging Max Accel Norm feature distribution to awd.",  &v24,  2);
      __int128 v15 = (std::stringbuf::string_type *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionMaxAccelNorm(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str(buf, &v22);
      uint64_t v11 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? buf
          : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
      LODWORD(v24.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&v24, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v16 = qword_1019345D8;
      std::stringbuf::str(&v24, &v22);
      if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v17 = &v24;
      }
      else {
        uint64_t v17 = (std::stringbuf::string_type *)v24.__r_.__value_.__r.__words[0];
      }
      int v25 = 136315138;
      __int128 v26 = v17;
      _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v16, 2LL, "%s", (const char *)&v25);
      int v19 = v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionMaxAccelNorm(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  (const char *)v19);
      if (v19 != buf) {
        free(v19);
      }
    }

    uint64_t v12 = sub_1008D9630();
    sub_100736D90(v12, a2);
    *(void *)((char *)v20
    uint64_t v21 = v13;
    std::streambuf::~streambuf(&v22);
    return std::ios::~ios(&v23);
  }

  return result;
}

void sub_100736D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100736D90(uint64_t a1, _BYTE *a2)
{
  uint64_t v4 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  int v5 = *a2;
  if (v5 == 1)
  {
    uint64_t v7 = 0LL;
    *(_BYTE *)(a1 + 396) = 1;
    do
    {
      *(_WORD *)(a1 + 397 + 2 * v7) += (char)a2[v7 + 1];
      ++v7;
    }

    while (v7 != 24);
  }

  else if (*a2)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v11,  0x18u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
    }

    char v9 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unsupported update for feature distribution type",  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v11,  0x18u);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    *(_BYTE *)(a1 + 344) = 0;
    do
    {
      *(_WORD *)(a1 + 345 + 2 * v6) += (char)a2[v6 + 1];
      ++v6;
    }

    while (v6 != 24);
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
}

void sub_100736FC0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_100736FCC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result = sub_10071FC64(a1);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v20);
    uint64_t v4 = sub_10000CF44(&v21, (uint64_t)"type,", 5LL);
    buf[0].__r_.__value_.__s.__data_[0] = *a2;
    int v5 = sub_10000CF44(v4, (uint64_t)buf, 1LL);
    sub_10000CF44(v5, (uint64_t)",bins,", 6LL);
    for (uint64_t i = 1LL; i != 35; ++i)
    {
      if (i == 1) {
        uint64_t v7 = "";
      }
      else {
        uint64_t v7 = " ";
      }
      uint64_t v8 = sub_10000CF44(&v21, (uint64_t)v7, i != 1);
      std::ostream::operator<<(v8, (char)a2[i]);
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Logging Jerk Vector Magnitude feature distribution to awd.",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v24.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Logging Jerk Vector Magnitude feature distribution to awd.",  &v24,  2);
      __int16 v15 = (std::stringbuf::string_type *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionJerkVectorMagnitude(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str(buf, &v22);
      int v11 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? buf
          : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
      LODWORD(v24.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&v24, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v16 = qword_1019345D8;
      std::stringbuf::str(&v24, &v22);
      if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v17 = &v24;
      }
      else {
        uint64_t v17 = (std::stringbuf::string_type *)v24.__r_.__value_.__r.__words[0];
      }
      int v25 = 136315138;
      __int128 v26 = v17;
      _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v16, 2LL, "%s", (const char *)&v25);
      int v19 = v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionJerkVectorMagnitude(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  (const char *)v19);
      if (v19 != buf) {
        free(v19);
      }
    }

    uint64_t v12 = sub_1008D9630();
    sub_10073743C(v12, a2);
    *(void *)((char *)v20
    uint64_t v21 = v13;
    std::streambuf::~streambuf(&v22);
    return std::ios::~ios(&v23);
  }

  return result;
}

void sub_10073740C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_10073743C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  int v5 = *a2;
  if (v5 == 3)
  {
    uint64_t v7 = 0LL;
    *(_BYTE *)(a1 + 52sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 3;
    do
    {
      *(_WORD *)(a1 + 521 + 2 * v7) += (char)a2[v7 + 1];
      ++v7;
    }

    while (v7 != 34);
  }

  else if (v5 == 2)
  {
    uint64_t v6 = 0LL;
    *(_BYTE *)(a1 + 44_Block_object_dispose(va, 8) = 2;
    do
    {
      *(_WORD *)(a1 + 449 + 2 * v6) += (char)a2[v6 + 1];
      ++v6;
    }

    while (v6 != 34);
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v11,  0x18u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
    }

    char v9 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unsupported update for feature distribution type",  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v11,  0x18u);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
}

void sub_100737674(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_100737680(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10071FC64(a1);
  if ((_DWORD)result)
  {
    uint64_t v4 = *(__int16 *)(a2 + 101);
    sub_10000CE18((uint64_t)v21);
    int v5 = sub_10000CF44(&v22, (uint64_t)"type,", 5LL);
    buf[0].__r_.__value_.__s.__data_[0] = *(_BYTE *)a2;
    uint64_t v6 = sub_10000CF44(v5, (uint64_t)buf, 1LL);
    sub_10000CF44(v6, (uint64_t)",bins,", 6LL);
    if ((_DWORD)v4)
    {
      for (uint64_t i = 0LL; i != v4; ++i)
      {
        if (i) {
          uint64_t v8 = " ";
        }
        else {
          uint64_t v8 = "";
        }
        char v9 = sub_10000CF44(&v22, (uint64_t)v8, i != 0);
        std::ostream::operator<<(v9, *(__int16 *)(a2 + 1 + 2 * i));
      }
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Logging Max Abs XYZ feature distribution to awd.",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v25.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Logging Max Abs XYZ feature distribution to awd.",  &v25,  2);
      int v16 = (std::stringbuf::string_type *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionMaxAbsXYZ(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v11 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str(buf, &v23);
      int v12 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
          ? buf
          : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
      LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&v25, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v17 = qword_1019345D8;
      std::stringbuf::str(&v25, &v23);
      if ((v25.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v18 = &v25;
      }
      else {
        int v18 = (std::stringbuf::string_type *)v25.__r_.__value_.__r.__words[0];
      }
      int v26 = 136315138;
      __int128 v27 = v18;
      _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v17, 2LL, "%s", (const char *)&v26);
      int v20 = v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onFeatureDistributionMaxAbsXYZ(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  (const char *)v20);
      if (v20 != buf) {
        free(v20);
      }
    }

    uint64_t v13 = sub_1008D9630();
    sub_100737AFC(v13, (unsigned __int8 *)a2);
    *(void *)((char *)v21
    uint64_t v22 = v14;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

void sub_100737ACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100737AFC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  int v5 = *a2;
  if (v5 == 4)
  {
    uint64_t v6 = *(__int16 *)(a2 + 101);
    *(_BYTE *)(a1 + 592) = 4;
    if (v6)
    {
      uint64_t v7 = (__int16 *)(a2 + 1);
      do
      {
        uint64_t v8 = *v7++;
        ++*(_WORD *)(a1 + 593 + 2 * v8);
        --v6;
      }

      while (v6);
    }
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    char v9 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT))
    {
      int v12 = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 1026;
      int v17 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v12,  0x18u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
    }

    uint64_t v10 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      int v12 = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 1026;
      int v17 = v5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unsupported update for feature distribution type",  "{msg%{public}.0s:Unsupported update for feature distribution type, type:%{public}d}",  (uint8_t *)&v12,  0x18u);
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
}

void sub_100737CF4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_100737D00(uint64_t a1)
{
  uint64_t v1 = a1 + 66280;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 544) + 24LL))(v2);
}

uint64_t sub_100737D54(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66284);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100737DB0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66288);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100737E0C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66292);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100737E68(uint64_t a1)
{
  uint64_t v1 = a1 + 66296;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 528) + 24LL))(v2);
}

uint64_t sub_100737EBC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66304);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100737F18(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66300);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100737F74(uint64_t a1)
{
  uint64_t v1 = a1 + 66312;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 512) + 24LL))(v2);
}

uint64_t sub_100737FC8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66308);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738024(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66316);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738080(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66320);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007380DC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66324);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738138(uint64_t a1)
{
  uint64_t v1 = a1 + 66328;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 496) + 24LL))(v2);
}

uint64_t sub_10073818C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66332);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007381E8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66336);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738244(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66340);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007382A0(uint64_t a1)
{
  uint64_t v1 = a1 + 66344;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 480) + 24LL))(v2);
}

uint64_t sub_1007382F4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66348);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738350(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66352);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007383AC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66356);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738408(uint64_t a1)
{
  uint64_t v1 = a1 + 66360;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 464) + 24LL))(v2);
}

uint64_t sub_10073845C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66364);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007384B8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66368);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738514(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66372);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738570(uint64_t a1)
{
  uint64_t v1 = a1 + 66376;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 448) + 24LL))(v2);
}

uint64_t sub_1007385C4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66380);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738620(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66384);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_10073867C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66388);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007386D8(uint64_t a1)
{
  uint64_t v1 = a1 + 66392;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 432) + 24LL))(v2);
}

uint64_t sub_10073872C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66396);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738788(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66400);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007387E4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66404);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738840(uint64_t a1)
{
  uint64_t v1 = a1 + 66408;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 416) + 24LL))(v2);
}

uint64_t sub_100738894(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66412);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007388F0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66416);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_10073894C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66420);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_1007389A8(uint64_t a1)
{
  uint64_t v1 = a1 + 66424;
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)v1;
  return (*(uint64_t (**)(uint64_t))(*(void *)(v1 + 400) + 24LL))(v2);
}

uint64_t sub_1007389FC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66428);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738A58(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66432);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738AB4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66436);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t sub_100738B10(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  ++*(_DWORD *)(a1 + 66444);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

NSDictionary *sub_100738B6C(uint64_t a1)
{
  v23[0] = CMFallDefaults;
  v21[0] = CMFallDefaults_isHeartRateDataCollectionEnabled;
  v22[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100734E18());
  v21[1] = CMFallDefaults_fallFullMslLoggingInSensorKitEnabled;
  LOBYTE(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(&v6, "FallFullMslLoggingInSensorKitEnabled", (unsigned __int8 *)&v10, 0);
  v22[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7);
  void v21[2] = CMFallDefaults_fallOffWristLookbackBeforeImpactStartOfInterval;
  sub_101204164(&v6, "FallOffWristLookbackBeforeImpactStartOfIntervalKey", &qword_101328780, 0);
  _OWORD v22[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  uint64_t v21[3] = CMFallDefaults_fallOffWristLookbackBeforeImpactEndOfInterval;
  sub_101204164(&v6, "FallOffWristLookbackBeforeImpactEndOfIntervalKey", &qword_1013287C0, 0);
  v22[3] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  v21[4] = CMFallDefaults_fallOnWristAfterImpactStartOfInterval;
  sub_101204164(&v6, "FallOnWristAfterImpactStartOfIntervalKey", &qword_1013287F8, 0);
  v22[4] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  void v21[5] = CMFallDefaults_fallOnWristAfterImpactEndOfInterval;
  sub_101204164(&v6, "FallOnWristAfterImpactEndOfIntervalKey", &qword_101328828, 0);
  v22[5] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  v21[6] = CMFallDefaults_fallLockedLookbackBeforeImpactStartOfInterval;
  sub_101204164(&v6, "FallLockedLookbackBeforeImpactStartOfIntervalKey", &qword_101328868, 0);
  v22[6] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  v21[7] = CMFallDefaults_fallLockedLookbackBeforeImpactEndOfInterval;
  sub_101204164(&v6, "FallLockedLookbackBeforeImpactEndOfIntervalKey", &qword_1013288A0, 0);
  v22[7] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9);
  v21[8] = CMFallDefaults_fallMinimumOffChargerDurationBeforeGatingAlert;
  int v10 = 25;
  sub_10023AE2C(&v6, "FallMinimumOffChargerDurationKey", &v10, 0);
  v22[8] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8);
  v21[9] = CMFallDefaults_fallDelayBeforeWristAndChargerGating;
  v22[9] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_100731C10());
  v21[10] = CMFallDefaults_fallDelayBeforeShuttingDownAlgorithmsAfterLastClientDisconnect;
  int v10 = 300;
  sub_10023AE2C(&v6, "FallDelayBeforeShuttingDownAlgorithmsAfterLastClientDisconnect", &v10, 0);
  v22[10] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8);
  v21[11] = CMFallDefaults_fallDelayBeforeSendingSPUConfiguration;
  int v10 = 30;
  sub_10023AE2C(&v6, "FallDelayBeforeSendingSPUConfiguration", &v10, 0);
  v22[11] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8);
  v24[0] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v22,  v21,  12LL);
  v23[1] = CMFallConfiguration;
  v19[0] = CMFallConfiguration_isFallDetectionFeatureEnabled;
  v20[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10071F09C());
  v19[1] = CMFallConfiguration_isBridgeToggleEnabled;
  v20[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10071E178());
  _DWORD v19[2] = CMFallConfiguration_userStudyFallStatsEnabled;
  LOBYTE(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(&v6, "FallStatsEnabled", (unsigned __int8 *)&v10, 0);
  void v20[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7);
  v19[3] = CMFallConfiguration_userStudyPressureDataCollection;
  LOBYTE(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(&v6, "FallStatsPressureEnabled", (unsigned __int8 *)&v10, 0);
  v20[3] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7);
  v19[4] = CMFallConfiguration_shouldDetectorBeRunning;
  v20[4] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726C58(a1));
  v24[1] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v20,  v19,  5LL);
  void v23[2] = CMFallState;
  v17[0] = CMFallState_isSensorRecordingEnabled;
  LOBYTE(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(&v6, "FallStatsSensorRecordingEnabled", (unsigned __int8 *)&v10, 0);
  v18[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7);
  v17[1] = CMFallState_isSensorKitLoggingEnabled;
  v18[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL);
  v17[2] = CMFallState_lastGatedAnomalyAOPTimestamp;
  v18[2] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  sub_100728FA8());
  _OWORD v24[2] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v18,  v17,  3LL);
  v23[3] = CMFallOptInsAndProfiles;
  v15[0] = CMFallOptInsAndProfiles_isImproveHealthAndFitnessOptInEnabled;
  v16[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_1007269F4());
  v15[1] = CMFallOptInsAndProfiles_lastFallAdditionalProfileLoggingEnabled;
  v16[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10072B0E4());
  v15[2] = CMFallOptInsAndProfiles_fallAdditionalProfileLoggingEnabled;
  LOBYTE(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_1012049AC(&v6, "FallAdditionalProfileLoggingEnabled", (unsigned __int8 *)&v10, 0);
  v16[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7);
  v15[3] = CMFallOptInsAndProfiles_isBackgroundSensorDataLoggingAllowed;
  v16[3] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726AD0());
  _DWORD v15[4] = CMFallOptInsAndProfiles_isTapToRadarFallSubmissionAllowed;
  v16[4] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726B2C());
  v15[5] = CMFallOptInsAndProfiles_isTapToRadarNearFallSubmissionAllowed;
  v16[5] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726B94());
  v15[6] = CMFallOptInsAndProfiles_isTapToRadarSubmissionAllowed;
  if ((sub_100726B2C() & 1) != 0) {
    uint64_t v2 = 1LL;
  }
  else {
    uint64_t v2 = sub_100726B94();
  }
  v16[6] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v2);
  v15[7] = CMFallOptInsAndProfiles_isAnyFallDataCollectionEnabled;
  v16[7] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726D28(a1));
  _WORD v15[8] = CMFallOptInsAndProfiles_isBackgroundAllDayAnomalyDetectionEnabled;
  _WORD v16[8] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726CD8(a1));
  v15[9] = CMFallOptInsAndProfiles_isBackgroundWorkoutAnomalyDetectionEnabled;
  v16[9] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726CB0());
  v24[3] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v16,  v15,  10LL);
  _DWORD v23[4] = CMFallFieldMetrics;
  v13[0] = CMFallFieldMetrics_isBackgroundFieldMetricsLoggingAllowed;
  v14[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726BFC());
  v13[1] = CMFallFieldMetrics_isBackgroundFieldMetricsLoggingEnabled;
  if (sub_100726C58(a1)) {
    uint64_t v3 = 0LL;
  }
  else {
    uint64_t v3 = sub_100726BFC();
  }
  v14[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v3);
  _OWORD v13[2] = CMFallFieldMetrics_isFieldMetricsLoggingEnabled;
  v14[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10071FC64(a1));
  _DWORD v24[4] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v14,  v13,  3LL);
  void v23[5] = CMFallHDSCollection;
  v11[0] = CMFallHDSCollection_isOptInDataLoggingAvailable;
  else {
    BOOL v4 = 0LL;
  }
  v12[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v4);
  v11[1] = CMFallHDSCollection_isOptInDataLoggingEnabled;
  v12[1] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100726A64(a1));
  _DWORD v11[2] = CMFallHDSCollection_isUnderRateLimit;
  _DWORD v12[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(double *)(a1 + 248) <= 240.0);
  void v24[5] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  3LL);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v24,  v23,  6LL);
}

__n128 sub_100739428@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 7047);
  *(_OWORD *)(a2 + 12_Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 7031);
  *(_OWORD *)(a2 + 144) = v2;
  *(_OWORD *)(a2 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a1 + 7063);
  *(_OWORD *)(a2 + 175) = *(_OWORD *)(a1 + 7078);
  __int128 v3 = *(_OWORD *)(a1 + 6983);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 6967);
  *(_OWORD *)(a2 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v3;
  __int128 v4 = *(_OWORD *)(a1 + 7015);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 6999);
  *(_OWORD *)(a2 + sub_10000AE14(v2 - 112) = v4;
  __int128 v5 = *(_OWORD *)(a1 + 6919);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 6903);
  *(_OWORD *)(a2 + sub_100708348(v2 - 16) = v5;
  __n128 result = *(__n128 *)(a1 + 6935);
  __int128 v7 = *(_OWORD *)(a1 + 6951);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = v7;
  return result;
}

NSDictionary *sub_10073946C()
{
  v87[0] = @"MaxAccelNormThreshold";
  uint64_t v0 = sub_1008D9630();
  *(float *)&double v1 = sub_1008DADBC(v0);
  v88[0] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v1);
  v87[1] = @"UserAgeBin";
  uint64_t v2 = sub_1008D9630();
  *(float *)&double v3 = sub_1008DAE74(v2);
  v88[1] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
  v87[2] = @"UserMaxMets";
  uint64_t v4 = sub_1008D9630();
  *(float *)&double v5 = sub_1008DAF34(v4);
  v88[2] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v5);
  v87[3] = @"numFallAlerts";
  uint64_t v6 = sub_1008D9630();
  v88[3] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A1C8(v6));
  v87[4] = @"numRecoveryEvents";
  uint64_t v7 = sub_1008D9630();
  v88[4] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A218(v7));
  v87[5] = @"numUserResponseConfirmedActionRequested";
  uint64_t v8 = sub_1008D9630();
  v88[5] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A268(v8));
  v87[6] = @"numUserResponseConfirmedNoActionRequested";
  uint64_t v9 = sub_1008D9630();
  v88[6] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A2B8(v9));
  v87[7] = @"numUserResponseDismissed";
  uint64_t v10 = sub_1008D9630();
  v88[7] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A308(v10));
  v87[8] = @"numUserResponseRejected";
  uint64_t v11 = sub_1008D9630();
  v88[8] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A358(v11));
  v87[9] = @"numUserResponseAutomaticActionRequested";
  uint64_t v12 = sub_1008D9630();
  v88[9] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A3A8(v12));
  v87[10] = @"numImpactReplacedBecauseOfNewImpact";
  uint64_t v13 = sub_1008D9630();
  v88[10] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A3F8(v13));
  v87[11] = @"numImpactCanceledBecauseOfMaxAccelNorm";
  uint64_t v14 = sub_1008D9630();
  v88[11] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A450(v14));
  v87[12] = @"numImpactCanceledBecauseOfOtherHardThresholds";
  uint64_t v15 = sub_1008D9630();
  v88[12] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A4A8(v15));
  v87[13] = @"numImpactCanceledBecauseOfMultiPeaks";
  uint64_t v16 = sub_1008D9630();
  v88[13] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A500(v16));
  v87[14] = @"numImpactCanceledBecauseOfNaiveBayes";
  uint64_t v17 = sub_1008D9630();
  v88[14] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A558(v17));
  v87[15] = @"numImpactCanceledBecauseOfCyclingImpactThresholds";
  uint64_t v18 = sub_1008D9630();
  v88[15] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A5B0(v18));
  v87[16] = @"numImpactCanceledBecauseOfExistingAlert";
  uint64_t v19 = sub_1008D9630();
  v88[16] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A608(v19));
  v87[17] = @"numImpactCanceledBecauseOfDisabledStateMachine";
  uint64_t v20 = sub_1008D9630();
  v88[17] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A660(v20));
  v87[18] = @"numImpactCanceledAggregate";
  uint64_t v21 = sub_1008D9630();
  v88[18] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A6B8(v21));
  v87[19] = @"numAlertCanceledBecauseOfHighFrequencyFFT";
  uint64_t v22 = sub_1008D9630();
  v88[19] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A710(v22));
  v87[20] = @"numAlertCanceledBecauseOfLowFrequencyFFT";
  uint64_t v23 = sub_1008D9630();
  v88[20] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A768(v23));
  v87[21] = @"numAlertCanceledBecauseOfDecimatedLowFrequencyFFT";
  uint64_t v24 = sub_1008D9630();
  v88[21] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A7C0(v24));
  v87[22] = @"numAlertCanceledBecauseOfFFT";
  uint64_t v25 = sub_1008D9630();
  v88[22] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A818(v25));
  v87[23] = @"numAlertCanceledBecauseOfPeaksIQR";
  uint64_t v26 = sub_1008D9630();
  v88[23] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A870(v26));
  v87[24] = @"numAlertCanceledBecauseOfOffBody";
  uint64_t v27 = sub_1008D9630();
  v88[24] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A8C8(v27));
  v87[25] = @"numAlertCanceledBecauseOfRepetitiveMotion";
  uint64_t v28 = sub_1008D9630();
  v88[25] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A920(v28));
  v87[26] = @"numAlertCanceledBecauseOfAbsenceOfQuiessence";
  uint64_t v29 = sub_1008D9630();
  v88[26] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A978(v29));
  v87[27] = @"numAlertCanceledBecauseOfOffWristPre";
  uint64_t v30 = sub_1008D9630();
  v88[27] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073A9D0(v30));
  v87[28] = @"numAlertCanceledBecauseOfOffWristPost";
  uint64_t v31 = sub_1008D9630();
  v88[28] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AA28(v31));
  v87[29] = @"numAlertCanceledAggregate";
  uint64_t v32 = sub_1008D9630();
  v88[29] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AA80(v32));
  v87[30] = @"numAlertCanceledBecauseOfFeatureDisabled";
  uint64_t v33 = sub_1008D9630();
  v88[30] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AAD8(v33));
  v87[31] = @"numAlertCanceledBecauseOfAlreadyGatedBefore";
  uint64_t v34 = sub_1008D9630();
  v88[31] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AB30(v34));
  v87[32] = @"numAlertCanceledBecauseOfOnCharger";
  uint64_t v35 = sub_1008D9630();
  v88[32] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AB88(v35));
  _BYTE v87[33] = @"numAlertCanceledBecauseOfSimilarPeaks";
  uint64_t v36 = sub_1008D9630();
  v88[33] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073ABE0(v36));
  v87[34] = @"numAlertCanceledBecauseOfLockedNoMotionBeforeImpact";
  uint64_t v37 = sub_1008D9630();
  v88[34] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AC38(v37));
  v87[35] = @"numAlertCanceledBecauseOfReferee";
  uint64_t v38 = sub_1008D9630();
  v88[35] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AC90(v38));
  v87[36] = @"numAlertCanceledBecauseStand";
  uint64_t v39 = sub_1008D9630();
  v88[36] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073ACE8(v39));
  v87[37] = @"numAlertCanceledBecauseActive";
  uint64_t v40 = sub_1008D9630();
  v88[37] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AD40(v40));
  v87[38] = @"numAlertCanceledBecauseSteps";
  uint64_t v41 = sub_1008D9630();
  v88[38] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AD98(v41));
  v87[39] = @"numAlertCanceledBecauseOfDistanceTraveledPostImpact";
  uint64_t v42 = sub_1008D9630();
  v88[39] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073ADF0(v42));
  v87[40] = @"numAlertCanceledBecauseOfDistanceCyclingPostImpact";
  uint64_t v43 = sub_1008D9630();
  v88[40] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AE48(v43));
  v87[41] = @"numAlertCanceledOtherAggregate";
  uint64_t v44 = sub_1008D9630();
  v88[41] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AEA0(v44));
  v87[42] = @"numRecoveryCanceledBecauseOfReferee";
  uint64_t v45 = sub_1008D9630();
  v88[42] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AEF8(v45));
  v87[43] = @"numRecoveryCanceledAggregate";
  uint64_t v46 = sub_1008D9630();
  v88[43] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AF50(v46));
  v87[44] = @"numSOSCanceledBecauseUserResponse";
  uint64_t v47 = sub_1008D9630();
  v88[44] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073AFA8(v47));
  v87[45] = @"numSOSCanceledBecauseOffWrist";
  uint64_t v48 = sub_1008D9630();
  v88[45] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B000(v48));
  v87[46] = @"numSOSCanceledBecauseStand";
  uint64_t v49 = sub_1008D9630();
  v88[46] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B058(v49));
  v87[47] = @"numSOSCanceledBecauseActive";
  uint64_t v50 = sub_1008D9630();
  v88[47] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B0B0(v50));
  v87[48] = @"numSOSCanceledBecauseSteps";
  uint64_t v51 = sub_1008D9630();
  v88[48] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B108(v51));
  v87[49] = @"numSOSCanceledBecauseAbsenceOfLongLie";
  uint64_t v52 = sub_1008D9630();
  v88[49] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B160(v52));
  v87[50] = @"numSOSCanceledBecauseOfReferee";
  uint64_t v53 = sub_1008D9630();
  v88[50] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B1B8(v53));
  v87[51] = @"numSOSCanceledAggregate";
  uint64_t v54 = sub_1008D9630();
  v88[51] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B210(v54));
  v87[52] = @"numSOSCallConsidered";
  uint64_t v55 = sub_1008D9630();
  v88[52] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B268(v55));
  v87[53] = @"numSOSCallScheduled";
  uint64_t v56 = sub_1008D9630();
  v88[53] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B2C4(v56));
  v87[54] = @"numSOSCallPlaced";
  uint64_t v57 = sub_1008D9630();
  v88[54] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B320(v57));
  v87[55] = @"numOutdoorCyclingFallAlerts";
  uint64_t v58 = sub_1008D9630();
  v88[55] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B37C(v58));
  v87[56] = @"numOutdoorCyclingRecoveryEvents";
  uint64_t v59 = sub_1008D9630();
  v88[56] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B3D8(v59));
  v87[57] = @"numOutdoorCyclingUserResponseConfirmedActionRequested";
  uint64_t v60 = sub_1008D9630();
  v88[57] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B434(v60));
  v87[58] = @"numOutdoorCyclingUserResponseConfirmedNoActionRequested";
  uint64_t v61 = sub_1008D9630();
  v88[58] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B490(v61));
  v87[59] = @"numOutdoorCyclingUserResponseDismissed";
  uint64_t v62 = sub_1008D9630();
  v88[59] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B4EC(v62));
  v87[60] = @"numOutdoorCyclingUserResponseRejected";
  uint64_t v63 = sub_1008D9630();
  v88[60] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B548(v63));
  v87[61] = @"numOutdoorCyclingUserResponseAutomaticActionRequested";
  uint64_t v64 = sub_1008D9630();
  v88[61] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B5A4(v64));
  v87[62] = @"numOutdoorWalkingFallAlerts";
  uint64_t v65 = sub_1008D9630();
  v88[62] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B600(v65));
  v87[63] = @"numOutdoorWalkingRecoveryEvents";
  uint64_t v66 = sub_1008D9630();
  v88[63] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B65C(v66));
  v87[64] = @"numOutdoorWalkingUserResponseConfirmedActionRequested";
  uint64_t v67 = sub_1008D9630();
  v88[64] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B6B8(v67));
  v87[65] = @"numOutdoorWalkingUserResponseConfirmedNoActionRequested";
  uint64_t v68 = sub_1008D9630();
  v88[65] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B714(v68));
  v87[66] = @"numOutdoorWalkingUserResponseDismissed";
  uint64_t v69 = sub_1008D9630();
  v88[66] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B770(v69));
  v87[67] = @"numOutdoorWalkingUserResponseRejected";
  uint64_t v70 = sub_1008D9630();
  v88[67] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B7CC(v70));
  v87[68] = @"numOutdoorWalkingUserResponseAutomaticActionRequested";
  uint64_t v71 = sub_1008D9630();
  v88[68] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B828(v71));
  v87[69] = @"numOutdoorRunningFallAlerts";
  uint64_t v72 = sub_1008D9630();
  v88[69] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B884(v72));
  v87[70] = @"numOutdoorRunningRecoveryEvents";
  uint64_t v73 = sub_1008D9630();
  v88[70] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B8E0(v73));
  v87[71] = @"numOutdoorRunningUserResponseConfirmedActionRequested";
  uint64_t v74 = sub_1008D9630();
  v88[71] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B93C(v74));
  v87[72] = @"numOutdoorRunningUserResponseConfirmedNoActionRequested";
  uint64_t v75 = sub_1008D9630();
  v88[72] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B998(v75));
  v87[73] = @"numOutdoorRunningUserResponseDismissed";
  uint64_t v76 = sub_1008D9630();
  v88[73] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073B9F4(v76));
  v87[74] = @"numOutdoorRunningUserResponseRejected";
  uint64_t v77 = sub_1008D9630();
  v88[74] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BA50(v77));
  v87[75] = @"numOutdoorRunningUserResponseAutomaticActionRequested";
  uint64_t v78 = sub_1008D9630();
  v88[75] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BAAC(v78));
  v87[76] = @"numHikingFallAlerts";
  uint64_t v79 = sub_1008D9630();
  v88[76] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BB08(v79));
  v87[77] = @"numHikingRecoveryEvents";
  uint64_t v80 = sub_1008D9630();
  v88[77] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BB64(v80));
  v87[78] = @"numHikingUserResponseConfirmedActionRequested";
  uint64_t v81 = sub_1008D9630();
  v88[78] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BBC0(v81));
  v87[79] = @"numHikingUserResponseConfirmedNoActionRequested";
  uint64_t v82 = sub_1008D9630();
  v88[79] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BC1C(v82));
  v87[80] = @"numHikingUserResponseDismissed";
  uint64_t v83 = sub_1008D9630();
  v88[80] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BC78(v83));
  v87[81] = @"numHikingUserResponseRejected";
  uint64_t v84 = sub_1008D9630();
  v88[81] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BCD4(v84));
  v87[82] = @"numHikingUserResponseAutomaticActionRequested";
  uint64_t v85 = sub_1008D9630();
  v88[82] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_10073BD30(v85));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v88,  v87,  83LL);
}

uint64_t sub_10073A1C8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 124);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A218(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 128);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A268(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 140);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A2B8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 144);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A308(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 148);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A358(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 152);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A3A8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 156);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A3F8(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66280);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 68) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A450(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66284);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A4A8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66288);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A500(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66292);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A558(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66296);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 66) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A5B0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66300);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A608(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66304);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A660(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66312);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 64) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A6B8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66308);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A710(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66316);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A768(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66320);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A7C0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66324);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A818(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66328);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 62) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A870(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66332);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A8C8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66336);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A920(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66340);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A978(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66344);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 60) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073A9D0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66348);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AA28(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66352);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AA80(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66356);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AAD8(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66360);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 58) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AB30(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66368);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AB88(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66364);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073ABE0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66372);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AC38(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66376);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 56) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AC90(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66380);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073ACE8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66384);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AD40(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66388);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AD98(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66392);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 54) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073ADF0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66396);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AE48(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66400);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AEA0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66404);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AEF8(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66408);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 52) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AF50(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66412);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073AFA8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66416);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B000(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66420);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B058(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66424);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 50) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B0B0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66428);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B108(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66432);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B160(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66436);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B1B8(uint64_t a1)
{
  double v1 = (unsigned int *)(a1 + 66440);
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *v1;
  (*(void (**)(uint64_t))(*((void *)v1 + 48) + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B210(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66444);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B268(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66712);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B2C4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66716);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B320(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66720);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B37C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66576);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B3D8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66580);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B434(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66584);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B490(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66588);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B4EC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66592);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B548(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66596);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B5A4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66600);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B600(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66604);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B65C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66608);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B6B8(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66612);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B714(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66616);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B770(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66620);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B7CC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66624);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B828(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66628);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B884(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66632);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B8E0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66636);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B93C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66640);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B998(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66644);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073B9F4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66648);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BA50(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66652);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BAAC(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66656);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BB08(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66660);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BB64(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66664);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BBC0(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66668);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BC1C(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66672);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BC78(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66676);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BCD4(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66680);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

uint64_t sub_10073BD30(uint64_t a1)
{
  uint64_t v2 = a1 + 66824;
  (*(void (**)(uint64_t))(*(void *)(a1 + 66824) + 16LL))(a1 + 66824);
  uint64_t v3 = *(unsigned int *)(a1 + 66684);
  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v3;
}

id sub_10073BD8C(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "An Impact sequence just started.", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    *(_WORD *)uint64_t v8 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  1LL,  "An Impact sequence just started.",  v8,  2);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onImpactDataStart(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(a1 + 136) clearAllLogs];
  uint64_t v3 = *(void **)(a1 + 144);
  v8[0] = 0;
  sub_1012049AC(buf, "FallFullMslLoggingInSensorKitEnabled", v8, 0);
  id result = [v3 cleanUpIncludingDerivedFeatures:buf[1]];
  for (uint64_t i = *(void *)(a1 + 8056); i != a1 + 8048; uint64_t i = *(void *)(i + 8))
  {
    if ((sub_100726A64(a1) & 1) == 0 && (sub_100726B2C() & 1) == 0)
    {
      id result = (id)sub_100726B94();
      if (!(_DWORD)result) {
        continue;
      }
    }

    id result = [*(id *)(a1 + 136) logOdometer:i + 16];
  }

  return result;
}

id sub_10073BF98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_BYTE *)(a1 + 10721);
  if (!*(void *)(a1 + 7592))
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    double v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Receiving Pressure", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      v19[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "Receiving Pressure",  v19,  2);
      uint64_t v18 = (char *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onPressureData(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

  ++*(void *)(a1 + 7592);
  *(void *)__int128 buf = *(void *)(a2 + 20);
  *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(a2 + 8);
  sub_100483268((unsigned __int16 *)(a1 + 456), buf);
  __int128 v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)__int128 buf = *(_OWORD *)a2;
  *(_OWORD *)&uint8_t buf[16] = v6;
  uint64_t v21 = *(void *)(a2 + 32);
  *(_DWORD *)&uint8_t buf[8] = 2143289344;
  int v7 = *(unsigned __int16 *)(a1 + 458);
  if (*(_WORD *)(a1 + 458))
  {
    uint64_t v8 = a1 + 464;
    unint64_t v9 = *(void *)&buf[12];
    uint64_t v10 = *(unsigned __int16 *)(a1 + 456);
    while (1)
    {
      unint64_t v11 = *(void *)(v8 + 16 * v10);
      unint64_t v12 = v9 - v11;
      if (v11 > v9) {
        unint64_t v12 = v11 - v9;
      }
      if (v12 <= 0x8CA0) {
        break;
      }
      if (v11 <= v9)
      {
        unint64_t v13 = v10 + 1;
        unint64_t v14 = *(unsigned int *)(a1 + 460);
        if (v13 < v14) {
          LOWORD(v14) = 0;
        }
        unsigned __int16 v15 = v13 - v14;
        uint64_t v10 = v15;
        *(_WORD *)(a1 + 456) = v15;
        *(_WORD *)(a1 + 45_Block_object_dispose(va, 8) = --v7;
        if ((_WORD)v7) {
          continue;
        }
      }

      goto LABEL_18;
    }

    *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(v8 + 16 * v10 + 8);
  }

void sub_10073C244(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned __int8 *a4)
{
  if (*a3 == 2)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v21 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *a4;
      int v23 = a4[1];
      int v24 = a4[2];
      int v25 = a4[3];
      int v26 = a4[4];
      int v27 = a4[5];
      int v28 = a4[6];
      uint64_t buf = 68290818LL;
      __int16 v32 = 2082;
      uint64_t v33 = "";
      __int16 v34 = 1026;
      *(_DWORD *)uint64_t v35 = v22;
      *(_WORD *)&double v35[4] = 1026;
      *(_DWORD *)&v35[6] = v23;
      *(_WORD *)uint64_t v36 = 1026;
      *(_DWORD *)&id v36[2] = v24;
      *(_WORD *)uint64_t v37 = 1026;
      *(_DWORD *)&id v37[2] = v25;
      *(_WORD *)uint64_t v38 = 1026;
      *(_DWORD *)&v38[2] = v26;
      *(_WORD *)uint64_t v39 = 1026;
      *(_DWORD *)&v39[2] = v27;
      *(_WORD *)uint64_t v40 = 1026;
      *(_DWORD *)&v40[2] = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received onWatchSystemState update, isPasscodeLockEnabled:%{public}hhd, isWaterLo ckEnabled:%{public}hhd, isSchoolModeEnabled:%{public}hhd, isSleepLockEnabled:%{public}hhd, isTheater ModeEnabled:%{public}hhd, isTourModeEnabled:%{public}hhd, isDepthModeEnabled:%{public}hhd}",  (uint8_t *)&buf,  0x3Cu);
    }

    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFAbsoluteTime v30 = CFAbsoluteTimeGetCurrent();
    LODWORD(buf) = *(_DWORD *)a4;
    *(_DWORD *)((char *)&buf + 3) = *(_DWORD *)(a4 + 3);
    *(CFAbsoluteTime *)(a1 + 7792) = Current;
    *(CFAbsoluteTime *)(a1 + 780sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v30;
    *(_DWORD *)(a1 + 780_Block_object_dispose(va, 8) = buf;
    *(_DWORD *)(a1 + 7811) = *(_DWORD *)((char *)&buf + 3);
  }

  else if (*a3 == 1)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int128 v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)a4 + 2);
      int v8 = *(_DWORD *)a4;
      int v9 = *((_DWORD *)a4 + 1);
      int v10 = *((_DWORD *)a4 + 2);
      int v11 = a4[24];
      int v12 = a4[25];
      int v13 = a4[26];
      uint64_t buf = 68290818LL;
      __int16 v32 = 2082;
      uint64_t v33 = "";
      __int16 v34 = 2050;
      *(void *)uint64_t v35 = v7;
      *(_WORD *)&v35[8] = 1026;
      *(_DWORD *)uint64_t v36 = v8;
      *(_WORD *)&v36[4] = 1026;
      *(_DWORD *)uint64_t v37 = v9;
      *(_WORD *)&v37[4] = 1026;
      *(_DWORD *)uint64_t v38 = v10;
      *(_WORD *)&_DWORD v38[4] = 1026;
      *(_DWORD *)uint64_t v39 = v11;
      *(_WORD *)&v39[4] = 1026;
      *(_DWORD *)uint64_t v40 = v12;
      *(_WORD *)&v40[4] = 1026;
      int v41 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received onWristMonitor update, timestamp:%{public}llu, onWrist:%{public}d, o nWristSensor:%{public}d, onWristConfidence:%{public}d, isOnCharger:%{public}hhd, isForcedOnWristEnab led:%{public}hhd, isWristDetectionEnabled:%{public}hhd}",  (uint8_t *)&buf,  0x40u);
    }

    int v14 = *(_DWORD *)a4;
    int v15 = a4[24];
    double v16 = CFAbsoluteTimeGetCurrent();
    sub_100F703F4(a1 + 7608, v14, v15, v16);
    CFAbsoluteTime v17 = CFAbsoluteTimeGetCurrent();
    CFAbsoluteTime v18 = CFAbsoluteTimeGetCurrent();
    __int128 v20 = *(_OWORD *)a4;
    __int128 v19 = *((_OWORD *)a4 + 1);
    *(CFAbsoluteTime *)(a1 + 7744) = v17;
    *(CFAbsoluteTime *)(a1 + 7752) = v18;
    *(_OWORD *)(a1 + 776sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v20;
    *(_OWORD *)(a1 + 7776) = v19;
  }

uint64_t sub_10073C508(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 8)
  {
    uint64_t v4 = result;
    uint64_t v7 = *(void *)(a4 + 8);
    uint64_t v5 = a4 + 8;
    uint64_t v6 = v7;
    else {
      uint64_t v8 = v6;
    }
    int v9 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8);
    if (-[NSString isEqualToString:]( -[NSString pathExtension](v9, "pathExtension"),  "isEqualToString:",  @"watchkitapp"))
    {
      int v9 = -[NSString stringByDeletingPathExtension](v9, "stringByDeletingPathExtension");
    }

    return sub_100726E98(v4, (uint64_t)v9, 2);
  }

  return result;
}

unsigned __int8 *sub_10073C588(unsigned __int8 *result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 4)
  {
    uint64_t v5 = result;
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v6 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a4 + 8);
      *(_DWORD *)uint64_t buf = 134217984;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received post event HR : %f", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v8 = *(void *)(a4 + 8);
      int v11 = 134217984;
      uint64_t v12 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Received post event HR : %f",  COERCE_DOUBLE(&v11));
      int v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onHeartRateNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCather ineNotifier_Type::NotificationData &)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    [*((id *)v5 + 17) logHeartRate:a4];
    LOBYTE(v11) = 0;
    id result = sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)&v11, 0);
    if (buf[1]) {
      return (unsigned __int8 *)objc_msgSend( *((id *)v5 + 25),  "logData:",  +[CLFallLoggerManager encodeHeartRate:]( CLFallLoggerManager,  "encodeHeartRate:",  a4));
    }
  }

  return result;
}

void sub_10073C798(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  if (*a3 == 2 && (*((float *)a4 + 5) != 30.0 || *(float *)(a1 + 404) == 30.0))
  {
    __int128 v5 = *a4;
    __int128 v6 = a4[1];
    __int128 v7 = a4[2];
    *(_OWORD *)(a1 + 42_Block_object_dispose(va, 8) = *(__int128 *)((char *)a4 + 44);
    *(_OWORD *)(a1 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v6;
    *(_OWORD *)(a1 + 4sub_100708348(v2 - 16) = v7;
    *(_OWORD *)(a1 + 384) = v5;
    sub_10072B534(a1);
    sub_1007275FC(a1, 0);
    sub_100734EAC(a1, *(float *)(a1 + 404));
  }

void *sub_10073C820(void *result, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4 = result;
  if (*a3 == 1)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    __int128 v7 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 68289026;
      v8[1] = 0;
      __int16 v9 = 2082;
      int v10 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received CLDataProtectionManager notification, will no register to natalimetry}",  (uint8_t *)v8,  0x12u);
    }

    [*(id *)(v4[1361] + 16) unregister:*(void *)(v4[1361] + 8) forNotification:2];
    return [*(id *)(v4[1361] + 16) register:*(void *)(v4[1361] + 8) forNotification:2 registrationInfo:0];
  }

  else if (!*a3)
  {
    BOOL v5 = *a4 == 1;
    double Current = CFAbsoluteTimeGetCurrent();
    return (void *)sub_100F70860((uint64_t)(v4 + 951), v5, Current);
  }

  return result;
}

id *sub_10073C970(id *result, uint64_t a2, _DWORD *a3, void *a4)
{
  if (!*a3) {
    return (id *)_[result[17] setOrientation:*a4];
  }
  return result;
}

id sub_10073C9AC(uint64_t a1)
{
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v3 = &OBJC_METACLASS___CLPrivacyManager.vtable;
  uint64_t v4 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "CLFallNotifier Logging Internal State:",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    LOWORD(v161) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "CLFallNotifier Logging Internal State:",  &v161,  2);
    int v102 = (uint8_t *)v101;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v101);
    if (v102 != buf) {
      free(v102);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  BOOL v5 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(unsigned __int8 *)(a1 + 7824);
    int v7 = *(unsigned __int8 *)(a1 + 7825);
    int v8 = *(unsigned __int8 *)(a1 + 7826);
    int v9 = *(unsigned __int8 *)(a1 + 7827);
    int v10 = *(unsigned __int8 *)(a1 + 7828);
    uint64_t v11 = *(void *)(a1 + 7816);
    *(_DWORD *)uint64_t buf = 68290563;
    *(_DWORD *)int v202 = 0;
    *(_WORD *)&v202[4] = 2082;
    *(void *)&v202[6] = "";
    *(_WORD *)&v202[14] = 1025;
    *(_DWORD *)&v202[16] = v6;
    *(_WORD *)&v202[20] = 1025;
    *(_DWORD *)&v202[22] = v7;
    *(_WORD *)&v202[26] = 1025;
    *(_DWORD *)&v202[28] = v8;
    *(_WORD *)&v202[32] = 1025;
    *(_DWORD *)&v202[34] = v9;
    *(_WORD *)&v202[38] = 1025;
    *(_DWORD *)&v202[40] = v10;
    *(_WORD *)&v202[44] = 2049;
    *(void *)&v202[46] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CMFallConfig, CMFallStatsMode:%{private}u, CMFallStatsSensorRecordingActive:%{pri vate}u, CMFallStatsSimulateFall:%{private}u, CMFallStatsUserStudyPressureDataCollection:%{private}u, CMA nomalyDetectorEnabled:%{private}u, CMFallLastReplyAopTimestamp:%{private}llu}",  buf,  0x3Au);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
  }

  uint64_t v12 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    double v13 = *(float *)(a1 + 404);
    uint64_t v14 = *(void *)(a1 + 10560);
    double v15 = *(float *)(a1 + 10468);
    double v16 = *(float *)(a1 + 10472);
    double v17 = *(float *)(a1 + 10476);
    double v18 = *(float *)(a1 + 10480);
    *(_DWORD *)uint64_t buf = 68290563;
    *(_DWORD *)int v202 = 0;
    *(_WORD *)&v202[4] = 2082;
    *(void *)&v202[6] = "";
    *(_WORD *)&v202[14] = 2049;
    *(double *)&v202[16] = v13;
    *(_WORD *)&v202[24] = 2049;
    *(void *)&v202[26] = v14;
    *(_WORD *)&v202[34] = 2049;
    *(double *)&v202[36] = v15;
    *(_WORD *)&v202[44] = 2049;
    *(double *)&v202[46] = v16;
    *(_WORD *)&v202[54] = 2049;
    *(double *)&v202[56] = v17;
    *(_WORD *)&v202[64] = 2049;
    *(double *)&v202[66] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CMFallBehavioralConfig, CMFallConfigUserAge:%{private}f, CMFallConfigUserMets :%{private}f, CMFallImpactAlertThreshold:%{private}f, CMFallImpactLoggingStatsThreshold:%{privat e}f, CMFallImpactLoggingHeartRateThreshold:%{private}f, CMFallImpactLoggingHighResolutionSensorDataThr eshold:%{private}f}",  buf,  0x4Eu);
  }

  __int128 v19 = sub_100738B6C(a1);
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  __int128 v20 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v21 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallDefaults);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallDefaults: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v103 = qword_1019345D8;
    id v104 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallDefaults);
    int v161 = 138477827;
    id v162 = v104;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v103,  0LL,  "CMFallInternalNotifierState::CMFallDefaults: %{private}@",  &v161,  v131);
    BOOL v106 = (uint8_t *)v105;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v105);
    if (v106 != buf) {
      free(v106);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v22 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v23 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallConfiguration);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallConfiguration: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v107 = qword_1019345D8;
    id v108 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallConfiguration);
    int v161 = 138477827;
    id v162 = v108;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v107,  0LL,  "CMFallInternalNotifierState::CMFallConfiguration: %{private}@",  &v161,  v131);
    int v110 = (uint8_t *)v109;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v109);
    if (v110 != buf) {
      free(v110);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v24 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v25 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallState);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallState: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v111 = qword_1019345D8;
    id v112 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallState);
    int v161 = 138477827;
    id v162 = v112;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v111,  0LL,  "CMFallInternalNotifierState::CMFallState: %{private}@",  &v161,  v131);
    uint64_t v114 = (uint8_t *)v113;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v113);
    if (v114 != buf) {
      free(v114);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v26 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v27 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallOptInsAndProfiles);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v27;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallOptInsAndProfiles: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v115 = qword_1019345D8;
    id v116 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallOptInsAndProfiles);
    int v161 = 138477827;
    id v162 = v116;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v115,  0LL,  "CMFallInternalNotifierState::CMFallOptInsAndProfiles: %{private}@",  &v161,  v131);
    int v118 = (uint8_t *)v117;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v117);
    if (v118 != buf) {
      free(v118);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  int v28 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v29 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallFieldMetrics);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallFieldMetrics: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v119 = qword_1019345D8;
    id v120 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallFieldMetrics);
    int v161 = 138477827;
    id v162 = v120;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v119,  0LL,  "CMFallInternalNotifierState::CMFallFieldMetrics: %{private}@",  &v161,  v131);
    BOOL v122 = (uint8_t *)v121;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v121);
    if (v122 != buf) {
      free(v122);
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  CFAbsoluteTime v30 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    id v31 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallHDSCollection);
    *(_DWORD *)uint64_t buf = 138477827;
    *(void *)int v202 = v31;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalNotifierState::CMFallHDSCollection: %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v123 = qword_1019345D8;
    id v124 = -[NSDictionary objectForKeyedSubscript:](v19, "objectForKeyedSubscript:", CMFallHDSCollection);
    int v161 = 138477827;
    id v162 = v124;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v123,  0LL,  "CMFallInternalNotifierState::CMFallHDSCollection: %{private}@",  &v161,  v131);
    int v126 = (uint8_t *)v125;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v125);
    if (v126 != buf) {
      free(v126);
    }
  }

  int v132 = sub_10073946C();
  __int16 v32 = -[NSDictionary allKeys](v132, "allKeys");
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
  }
  uint64_t v33 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
  {
    NSUInteger v34 = -[NSArray count](v32, "count");
    *(_DWORD *)uint64_t buf = 134283521;
    *(void *)int v202 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "CMFallInternalMetricState: (%{private}lu)",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    uint64_t v127 = qword_1019345D8;
    id v128 = -[NSArray count](v32, "count");
    int v161 = 134283521;
    id v162 = v128;
    LODWORD(v131) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v127,  0LL,  "CMFallInternalMetricState: (%{private}lu)",  &v161,  v131);
    int v130 = (uint8_t *)v129;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v129);
    if (v130 != buf) {
      free(v130);
    }
  }

  id result = -[NSArray count](v32, "count");
  if (result)
  {
    unint64_t v36 = 0LL;
    uint64_t v37 = @"nil";
    do
    {
      uint64_t v38 = (os_log_s *)v3[187];
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        log = v38;
        id v157 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36);
        id v155 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36));
        NSUInteger v39 = -[NSArray count](v32, "count");
        uint64_t v40 = v37;
        if (v36 + 1 < v39) {
          uint64_t v40 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 1);
        }
        __int16 v153 = v40;
        NSUInteger v41 = -[NSArray count](v32, "count");
        uint64_t v42 = v37;
        if (v36 + 1 < v41) {
          uint64_t v42 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 1));
        }
        __int16 v151 = v42;
        NSUInteger v43 = -[NSArray count](v32, "count");
        uint64_t v44 = v37;
        if (v36 + 2 < v43) {
          uint64_t v44 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 2);
        }
        __int16 v149 = v44;
        NSUInteger v45 = -[NSArray count](v32, "count");
        uint64_t v46 = v37;
        if (v36 + 2 < v45) {
          uint64_t v46 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 2));
        }
        __int16 v147 = v46;
        NSUInteger v47 = -[NSArray count](v32, "count");
        uint64_t v48 = v37;
        if (v36 + 3 < v47) {
          uint64_t v48 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 3);
        }
        __int16 v145 = v48;
        NSUInteger v49 = -[NSArray count](v32, "count");
        uint64_t v50 = v37;
        if (v36 + 3 < v49) {
          uint64_t v50 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 3));
        }
        __int16 v143 = v50;
        NSUInteger v51 = -[NSArray count](v32, "count");
        uint64_t v52 = v37;
        if (v36 + 4 < v51) {
          uint64_t v52 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 4);
        }
        __int16 v141 = v52;
        NSUInteger v53 = -[NSArray count](v32, "count");
        uint64_t v54 = v37;
        if (v36 + 4 < v53) {
          uint64_t v54 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 4));
        }
        __int16 v139 = v54;
        NSUInteger v55 = -[NSArray count](v32, "count");
        uint64_t v56 = v37;
        if (v36 + 5 < v55) {
          uint64_t v56 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 5);
        }
        uint64_t v137 = v56;
        NSUInteger v57 = -[NSArray count](v32, "count");
        uint64_t v58 = v37;
        if (v36 + 5 < v57) {
          uint64_t v58 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 5));
        }
        uint64_t v135 = v58;
        NSUInteger v59 = -[NSArray count](v32, "count");
        uint64_t v60 = v37;
        if (v36 + 6 < v59) {
          uint64_t v60 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 6);
        }
        uint64_t v133 = v60;
        uint64_t v61 = v37;
        if (v36 + 6 < -[NSArray count](v32, "count")) {
          uint64_t v61 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 6));
        }
        uint64_t v62 = v37;
        if (v36 + 7 < -[NSArray count](v32, "count")) {
          uint64_t v62 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 7);
        }
        uint64_t v63 = v37;
        if (v36 + 7 < -[NSArray count](v32, "count")) {
          uint64_t v63 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 7));
        }
        uint64_t v64 = v37;
        if (v36 + 8 < -[NSArray count](v32, "count")) {
          uint64_t v37 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 8);
        }
        uint64_t v65 = v64;
        if (v36 + 8 < -[NSArray count](v32, "count")) {
          uint64_t v65 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 8));
        }
        uint64_t v66 = v64;
        if (v36 + 9 < -[NSArray count](v32, "count")) {
          uint64_t v66 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 9);
        }
        NSUInteger v67 = -[NSArray count](v32, "count");
        uint64_t v68 = v64;
        if (v36 + 9 < v67) {
          uint64_t v68 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 9));
        }
        *(_DWORD *)uint64_t buf = 138482691;
        *(void *)int v202 = v157;
        *(_WORD *)&v202[8] = 2113;
        *(void *)&v202[10] = v155;
        *(_WORD *)&v202[18] = 2113;
        *(void *)&v202[20] = v153;
        *(_WORD *)&v202[28] = 2113;
        *(void *)&v202[30] = v151;
        *(_WORD *)&v202[38] = 2113;
        *(void *)&v202[40] = v149;
        *(_WORD *)&v202[48] = 2113;
        *(void *)&v202[50] = v147;
        *(_WORD *)&v202[58] = 2113;
        *(void *)&v202[60] = v145;
        *(_WORD *)&v202[68] = 2113;
        *(void *)&v202[70] = v143;
        __int16 v203 = 2113;
        int v204 = v141;
        __int16 v205 = 2113;
        int v206 = v139;
        __int16 v207 = 2113;
        int v208 = v137;
        __int16 v209 = 2113;
        int v210 = v135;
        __int16 v211 = 2113;
        int v212 = v133;
        __int16 v213 = 2113;
        int v214 = v61;
        __int16 v215 = 2113;
        uint64_t v216 = v62;
        __int16 v217 = 2113;
        v218 = v63;
        __int16 v219 = 2113;
        v220 = v37;
        __int16 v221 = 2113;
        v222 = v65;
        __int16 v223 = 2113;
        v224 = v66;
        __int16 v225 = 2113;
        v226 = v68;
        _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "    %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{ private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{privat e}@: %{private}@, %{private}@: %{private}@",  buf,  0xCAu);
        p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
        uint64_t v3 = &OBJC_METACLASS___CLPrivacyManager.vtable;
        uint64_t v37 = v64;
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        os_log_t loga = (os_log_t)v3[187];
        id v158 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36);
        id v156 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36));
        NSUInteger v69 = -[NSArray count](v32, "count");
        uint64_t v70 = v37;
        if (v36 + 1 < v69) {
          uint64_t v70 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 1);
        }
        double v154 = v70;
        NSUInteger v71 = -[NSArray count](v32, "count");
        uint64_t v72 = v37;
        if (v36 + 1 < v71) {
          uint64_t v72 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 1));
        }
        int v152 = v72;
        NSUInteger v73 = -[NSArray count](v32, "count");
        uint64_t v74 = v37;
        if (v36 + 2 < v73) {
          uint64_t v74 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 2);
        }
        int v150 = v74;
        NSUInteger v75 = -[NSArray count](v32, "count");
        uint64_t v76 = v37;
        if (v36 + 2 < v75) {
          uint64_t v76 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 2));
        }
        int v148 = v76;
        NSUInteger v77 = -[NSArray count](v32, "count");
        uint64_t v78 = v37;
        if (v36 + 3 < v77) {
          uint64_t v78 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 3);
        }
        int v146 = v78;
        NSUInteger v79 = -[NSArray count](v32, "count");
        uint64_t v80 = v37;
        if (v36 + 3 < v79) {
          uint64_t v80 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 3));
        }
        int v144 = v80;
        NSUInteger v81 = -[NSArray count](v32, "count");
        uint64_t v82 = v37;
        if (v36 + 4 < v81) {
          uint64_t v82 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 4);
        }
        int v142 = v82;
        NSUInteger v83 = -[NSArray count](v32, "count");
        uint64_t v84 = v37;
        if (v36 + 4 < v83) {
          uint64_t v84 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 4));
        }
        int v140 = v84;
        NSUInteger v85 = -[NSArray count](v32, "count");
        __int128 v86 = v37;
        if (v36 + 5 < v85) {
          __int128 v86 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 5);
        }
        int v138 = v86;
        NSUInteger v87 = -[NSArray count](v32, "count");
        int v88 = v37;
        if (v36 + 5 < v87) {
          int v88 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 5));
        }
        int v136 = v88;
        NSUInteger v89 = -[NSArray count](v32, "count");
        int v90 = v37;
        if (v36 + 6 < v89) {
          int v90 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 6);
        }
        int v134 = v90;
        uint64_t v91 = v37;
        if (v36 + 6 < -[NSArray count](v32, "count")) {
          uint64_t v91 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 6));
        }
        uint64_t v92 = v37;
        if (v36 + 7 < -[NSArray count](v32, "count")) {
          uint64_t v92 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 7);
        }
        uint64_t v93 = v37;
        if (v36 + 7 < -[NSArray count](v32, "count")) {
          uint64_t v93 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 7));
        }
        int v94 = v37;
        if (v36 + 8 < -[NSArray count](v32, "count")) {
          int v94 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 8);
        }
        id v95 = v37;
        if (v36 + 8 < -[NSArray count](v32, "count")) {
          id v95 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 8));
        }
        int v96 = v37;
        if (v36 + 9 < -[NSArray count](v32, "count")) {
          uint64_t v37 = -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 9);
        }
        NSUInteger v97 = -[NSArray count](v32, "count");
        int v98 = v96;
        if (v36 + 9 < v97) {
          int v98 = -[NSDictionary objectForKeyedSubscript:]( v132,  "objectForKeyedSubscript:",  -[NSArray objectAtIndexedSubscript:](v32, "objectAtIndexedSubscript:", v36 + 9));
        }
        int v161 = 138482691;
        id v162 = v158;
        __int16 v163 = 2113;
        id v164 = v156;
        __int16 v165 = 2113;
        double v166 = v154;
        __int16 v167 = 2113;
        double v168 = v152;
        __int16 v169 = 2113;
        double v170 = v150;
        __int16 v171 = 2113;
        double v172 = v148;
        __int16 v173 = 2113;
        double v174 = v146;
        __int16 v175 = 2113;
        double v176 = v144;
        __int16 v177 = 2113;
        double v178 = v142;
        __int16 v179 = 2113;
        double v180 = v140;
        __int16 v181 = 2113;
        double v182 = v138;
        __int16 v183 = 2113;
        double v184 = v136;
        __int16 v185 = 2113;
        int v186 = v134;
        __int16 v187 = 2113;
        int v188 = v91;
        __int16 v189 = 2113;
        int v190 = v92;
        __int16 v191 = 2113;
        int v192 = v93;
        __int16 v193 = 2113;
        int v194 = v94;
        __int16 v195 = 2113;
        int v196 = v95;
        __int16 v197 = 2113;
        int v198 = v37;
        __int16 v199 = 2113;
        int v200 = v98;
        LODWORD(v131) = 202;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  loga,  0LL,  "    %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{ private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{privat e}@: %{private}@, %{private}@: %{private}@",  &v161,  v131);
        int v100 = (uint8_t *)v99;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFallNotifier::logInternalState()", "%s\n", v99);
        if (v100 != buf) {
          free(v100);
        }
        p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        uint64_t v3 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        uint64_t v37 = v96;
      }

      v36 += 10LL;
      id result = -[NSArray count](v32, "count");
    }

    while (v36 < (unint64_t)result);
  }

  return result;
}

unsigned __int8 *sub_10073E138(unsigned __int8 *result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *a3;
  if (!*a3)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received daemon settings notification",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return sub_10072AE18((uint64_t)v3);
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    LOWORD(v22) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Received daemon settings notification",  &v22,  2);
    goto LABEL_48;
  }

  if (v4 == 10)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    int v10 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received managed configuration change notification",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return sub_10072AE18((uint64_t)v3);
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    LOWORD(v22) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Received managed configuration change notification",  &v22,  2);
LABEL_48:
    double v16 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifier _Type::NotificationData &)",  "%s\n",  v9);
    if (v16 != buf) {
      free(v16);
    }
    return sub_10072AE18((uint64_t)v3);
  }

  if (v4 == 9)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10184D4F8);
    }
    BOOL v5 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Received sysdiagnose event", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      LOWORD(v22) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Received sysdiagnose event",  &v22,  2);
      double v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifi er_Type::NotificationData &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    LOBYTE(v22) = 0;
    sub_1012049AC(buf, "FallAdditionalProfileLoggingEnabled", (unsigned __int8 *)&v22, 0);
    if (buf[1])
    {
      int v6 = (void *)*((void *)v3 + 20);
      if (v6)
      {
        id v7 = [v6 getUUID];
      }

      else
      {
        id v11 = -[CLFallServer initInUniverse:]( objc_alloc(&OBJC_CLASS___CLFallServer),  "initInUniverse:",  *((void *)v3 + 4));
        id v7 = [v11 getUUID];
      }

      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      uint64_t v12 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 138543362;
        id v25 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Additional logging profile installed - Subject UUID: %{public}@",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        int v22 = 138543362;
        id v23 = v7;
        LODWORD(v21) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Additional logging profile installed - Subject UUID: %{public}@",  &v22,  v21);
        double v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNoti fier_Type::NotificationData &)",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }

      sub_10073C9AC((uint64_t)v3);
    }

    sub_1004F2598();
    id result = (unsigned __int8 *)sub_1004F8A40();
    if ((_DWORD)result)
    {
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10184D4F8);
      }
      double v13 = (os_log_s *)qword_1019345D8;
      if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Logging anomaly info...", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345D0 != -1) {
          dispatch_once(&qword_1019345D0, &stru_10184D4F8);
        }
        LOWORD(v22) = 0;
        LODWORD(v21) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  0LL,  "Logging anomaly info...",  &v22,  v21);
        __int128 v20 = (uint8_t *)v19;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNoti fier_Type::NotificationData &)",  "%s\n",  v19);
        if (v20 != buf) {
          free(v20);
        }
      }

      return (unsigned __int8 *)+[CLFallNotifierSysdiagnoseLogCollector writeAnomalyInfoToFileWithLastFallEvent:writeMask:fallNotifierConfig:stateLogger:statsLogger:sensorsLogger:pressureLogger:heartRateLogger:wristStateLogger:odometerLogger:falsePositiveSuppressionFeaturesLogger:hgalLogger:logDirectory:logFilePrefix:]( &OBJC_CLASS___CLFallNotifierSysdiagnoseLogCollector,  "writeAnomalyInfoToFileWithLastFallEvent:writeMask:fallNotifierConfig:stateLogger:stats Logger:sensorsLogger:pressureLogger:heartRateLogger:wristStateLogger:odometerLogger:fa lsePositiveSuppressionFeaturesLogger:hgalLogger:logDirectory:logFilePrefix:",  v3 + 6712,  4094LL,  v3 + 7816,  *((void *)v3 + 22),  *((void *)v3 + 21),  *((void *)v3 + 23),  *((void *)v3 + 24),  *((void *)v3 + 25),  *((void *)v3 + 26),  *((void *)v3 + 27),  *((void *)v3 + 28),  *((void *)v3 + 29),  +[CLFallNotifierSysdiagnoseLogCollector getSysdiagnoseOutputPath]( &OBJC_CLASS___CLFallNotifierSysdiagnoseLogCollector,  "getSysdiagnoseOutputPath"),  +[CLFallNotifierSysdiagnoseLogCollector getSysdiagnoseOutputFilename]( &OBJC_CLASS___CLFallNotifierSysdiagnoseLogCollector,  "getSysdiagnoseOutputFilename"));
    }
  }

  return result;
}

uint64_t sub_10073E858(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_10184D6F8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + sub_10000AE14(v9 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + sub_100708348(v2 - 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_10073E92C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  int v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLFallNotifier");
  sub_10073E858((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *int v8 = &off_10184D480;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10073E9C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_10073E9F4(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)uint64_t buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184D518);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        id v11 = (void *)(a1 + 8);
        *(_DWORD *)uint64_t buf = 136446466;
        uint64_t v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10184D518);
        }
        uint64_t v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        double v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        id v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::removeClient(int) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, Noti ficationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_10073EC68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_10193A038);
}

BOOL sub_10073EC7C(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v40 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          int v23 = (uint64_t *)v17;
        }
        else {
          int v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          int v28 = (uint64_t *)v24;
        }
        else {
          int v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)uint64_t v42 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        char v34 = *a4;
        *(void *)uint64_t buf = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v25 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v34;
        *(void *)uint64_t buf = 0LL;
        *(void *)&uint8_t buf[8] = 0LL;
        *(_DWORD *)&buf[23] = 0;
        *(void *)&uint8_t buf[16] = 0LL;
        __int128 v46 = xmmword_1013282E0;
        unint64_t v47 = 0xFF7FFFFF7F7FFFFFLL;
        int v48 = -8388609;
        uint64_t v49 = 0LL;
        uint64_t v50 = 0x7F7FFFFF00000000LL;
        int v51 = 2139095039;
        __int128 v52 = 0u;
        __int128 v53 = 0u;
        __int128 v54 = 0u;
        int v55 = 0;
        int32x4_t v56 = vdupq_n_s32(0x7F7FFFFFu);
        int v57 = -8388609;
        __int16 v58 = 1;
        char v59 = 0;
        memset(v62, 0, sizeof(v62));
        __int128 v61 = 0u;
        __int128 v60 = 0u;
        if (v20 == v18)
        {
          if ((*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
          {
            uint64_t v35 = sub_10074162C((uint64_t)buf);
            sub_100740D70((_BYTE *)a1, (uint64_t)&v40, (uint64_t)v42, v35);
          }

          if (*(void *)&v62[3])
          {
            *(void *)&v62[11] = *(void *)&v62[3];
            operator delete(*(void **)&v62[3]);
          }
        }

        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)uint64_t v42 = a1 + 64;
        char v29 = byte_10193A039;
        HIDWORD(v39) = v16;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v29;
        HIDWORD(v39) = *a3;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        CFAbsoluteTime v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        char v31 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)uint64_t buf = (char *)&v39 + 4;
        __int16 v32 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)uint64_t buf = &v41;
        *((_BYTE *)sub_1004EF3D4(v32 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v31;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)uint64_t buf = *a3;
        sub_10004A8FC((uint64_t **)(v40 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184D518);
  }
  id v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    unint64_t v36 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&unsigned __int8 v42[4] = v36;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v42,
      v39);
    uint64_t v38 = (char *)v37;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::registerForNotificatio n(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFallNotifier_Type::Notification, No tificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
    return 0LL;
  }

  return result;
}

void sub_10073F170(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 191);
  if (v3)
  {
    *(void *)(v1 + 199) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_10073F198(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136446466;
      CFAbsoluteTime v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184D518);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      int v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      uint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::clientRegistered(int , const Notification_T &) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types ::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_10073F418(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184D518);
              }
              int v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)uint64_t buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                uint64_t v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10184D518);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                uint64_t v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                uint64_t v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::unregister ForNotification(int, const Notification_T &) [Notification_T = CLFallNotifier_Type::Notification, Noti ficationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_10073F7A0(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(__int128 **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  __int128 v12 = *v11;
  __int128 v13 = v11[1];
  __int128 v14 = v11[3];
  *(_OWORD *)(a3 + 32) = v11[2];
  *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = v14;
  *(_OWORD *)a3 = v12;
  *(_OWORD *)(a3 + sub_100708348(v2 - 16) = v13;
  __int128 v15 = v11[4];
  __int128 v16 = v11[5];
  __int128 v17 = v11[7];
  *(_OWORD *)(a3 + 96) = v11[6];
  *(_OWORD *)(a3 + sub_10000AE14(v2 - 112) = v17;
  *(_OWORD *)(a3 + 64) = v15;
  *(_OWORD *)(a3 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v16;
  __int128 v18 = v11[8];
  __int128 v19 = v11[9];
  __int128 v20 = v11[10];
  *(_OWORD *)(a3 + 175) = *(__int128 *)((char *)v11 + 175);
  *(_OWORD *)(a3 + 144) = v19;
  *(_OWORD *)(a3 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v20;
  *(_OWORD *)(a3 + 12_Block_object_dispose(va, 8) = v18;
  if (v11 != (__int128 *)a3) {
    sub_100741488( (void *)(a3 + 191),  *(char **)((char *)v11 + 191),  *(char **)((char *)v11 + 199),  *(void *)((char *)v11 + 199) - *(void *)((char *)v11 + 191));
  }
  return 1LL;
}

uint64_t sub_10073F858(uint64_t a1, int *a2, __int128 *a3)
{
  int v10 = *a2;
  __int128 v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  int v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    uint64_t v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_10073F904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10073F918(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v5 = xmmword_1013282E0;
  unint64_t v6 = 0xFF7FFFFF7F7FFFFFLL;
  int v7 = -8388609;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0x7F7FFFFF00000000LL;
  int v10 = 2139095039;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  int v14 = 0;
  int32x4_t v15 = vdupq_n_s32(0x7F7FFFFFu);
  int v16 = -8388609;
  __int16 v17 = 1;
  char v18 = 0;
  memset(v21, 0, sizeof(v21));
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  (*(void (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v4,  a3,  a4,  0LL);
  if (*(void *)&v21[3])
  {
    *(void *)&v21[11] = *(void *)&v21[3];
    operator delete(*(void **)&v21[3]);
  }

void sub_10073F9E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, __int128 a33)
{
}

void sub_10073FA0C(uint64_t a1, unsigned int *a2, __int128 *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    __int128 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = (void *)(a1 + 8);
      __int128 v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)uint64_t v66 = 0;
      *(_WORD *)&v66[4] = 2082;
      *(void *)&v66[6] = "";
      *(_WORD *)&v66[14] = 2082;
      *(void *)&v66[16] = "activity";
      __int16 v67 = 2082;
      uint64_t v68 = v12;
      __int16 v69 = 2050;
      uint64_t v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int32x4_t v15 = (__n128 *)(a1 + 64);
    int v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    __int16 v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        __int128 v20 = (__n128 **)v14;
      }
      else {
        __int128 v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        __int16 v17 = v14;
      }
      int v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)NSUInteger v71 = &v71[8];
      memset(&v71[8], 0, 24);
      uint64_t v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      __int16 v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&v66[4], *(void **)&v66[12]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      sub_100740E4C(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      __int16 v27 = *(std::__shared_weak_count **)&v66[4];
      if (*(void *)&v66[4])
      {
        int v28 = (unint64_t *)(*(void *)&v66[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_1007408B8((uint64_t)a3);
    if (a5 == -1)
    {
      sub_10074099C((void *)a1, (int *)a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          __int16 v36 = (uint64_t *)v32;
        }
        else {
          __int16 v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v63 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      int v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          uint64_t v42 = (unint64_t *)v37;
        }
        else {
          uint64_t v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          int v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        uint64_t v62 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10184D518);
        }
        __int16 v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          char v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            NSUInteger v45 = v71;
          }
          else {
            NSUInteger v45 = *(_BYTE **)v71;
          }
          *(_DWORD *)uint64_t buf = 136315650;
          *(void *)uint64_t v66 = v44;
          *(_WORD *)&v66[8] = 1024;
          *(_DWORD *)&v66[10] = a5;
          *(_WORD *)&v66[14] = 2080;
          *(void *)&v66[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_10184D518);
          }
          __int128 v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v61 >= 0) {
            int v48 = __p;
          }
          else {
            int v48 = (void **)__p[0];
          }
          *(_DWORD *)NSUInteger v71 = 136315650;
          *(void *)&v71[4] = v46;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v48;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v59);
          uint64_t v50 = v49;
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::notifyClientsWit hData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLFallNotifier_ Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, Registra tionInfo_T = char]",  "%s\n",  v50);
        }

        goto LABEL_83;
      }

      uint64_t v62 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v53 = v39[3].n128_i64[0];
      int v51 = v39 + 3;
      __int128 v52 = (__n128 *)v53;
      if (!v53) {
        goto LABEL_60;
      }
      int v54 = *(_DWORD *)(v33 + 32);
      int v55 = v51;
      do
      {
        int v56 = v52[1].n128_i32[3];
        BOOL v57 = v56 < v54;
        if (v56 >= v54) {
          __int16 v58 = v52;
        }
        else {
          __int16 v58 = (__n128 *)&v52->n128_i8[8];
        }
        if (!v57) {
          int v55 = v52;
        }
        __int128 v52 = (__n128 *)v58->n128_u64[0];
      }

      while (v58->n128_u64[0]);
      sub_100740D70((_BYTE *)a1, (uint64_t)&v63, (uint64_t)&v62, v30);
    }

void sub_100740028( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void *sub_100740074@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void sub_1007400EC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136315138;
      unint64_t v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184D518);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      unint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::listClients() [Notif ication_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, Notification Info_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184D518);
    }
    int v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315394;
      unint64_t v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10184D518);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::listClients() [Notif ication_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, Notification Info_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    int v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      __int128 v11 = (void *)(a1 + 8);
      do
      {
        __int128 v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10184D518);
            }
            __int128 v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              int v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)uint64_t buf = 136315650;
              unint64_t v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184D518);
              }
              __int128 v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::listClients() [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamDa ta, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            __int16 v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                __int16 v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                __int128 v12 = v18;
              }

              while (!v19);
            }

            __int128 v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            int v10 = v26;
          }

          while (!v19);
        }

        int v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100740698(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1007415CC(a1);
  operator delete(v1);
}

id sub_1007406AC(uint64_t a1, int a2, void *a3)
{
  id result = sub_100741064(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1007406F8(id a1)
{
  qword_1019345D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fall");
}

void sub_100740724(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100740750(uint64_t a1)
{
  return sub_100731F64(*(void *)(a1 + 32));
}

void sub_100740758(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100740784(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1018580A8;
  *(_BYTE *)(a1 + 32) = 11;
  *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)(a2 + 158);
  *(void *)(a1 + sub_10000AE14(v9 + 24) = *(void *)(a2 + 174);
  *(_WORD *)(a1 + 34) = *(_WORD *)a2;
  uint64_t v4 = *(void *)(a2 + 19);
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)(a2 + 4);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v4;
  *(_DWORD *)(a1 + 56) = -8388609;
  *(_OWORD *)(a1 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 27);
  *(void *)(a1 + 76) = *(void *)(a2 + 43);
  *(void *)(a1 + 84) = 0x80000000800000LL;
  *(_DWORD *)(a1 + 92) = -8388609;
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 51);
  *(void *)(a1 + 10sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0x80000000800000LL;
  *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = -8388609;
  *(void *)(a1 + sub_10000AE14(v2 - 112) = *(void *)(a2 + 55);
  __int128 v5 = *(_OWORD *)(a2 + 63);
  *((void *)&v5 + 1) = *(void *)(a2 + 75);
  *(_OWORD *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v5;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 83);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 14);
  *(_BYTE *)(a1 + 153) = *(_BYTE *)(a2 + 15);
  *(_BYTE *)(a1 + 18_Block_object_dispose(va, 8) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 154) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a1 + 155) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 156) = *(_BYTE *)(a2 + 3);
  *(_DWORD *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = -8388609;
  *(float *)(a1 + 164) = sub_100734D60((float *)(a2 + 27));
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0x80000000800000LL;
  *(void *)(a1 + 176) = *(void *)(a2 + 99);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 107);
  *(int8x16_t *)(a1 + 192) = vextq_s8(*(int8x16_t *)(a2 + 111), *(int8x16_t *)(a2 + 111), 4uLL);
  *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 71);
  *(_BYTE *)(a1 + 212) = *(_BYTE *)(a2 + 149);
  *(_OWORD *)(a1 + 2sub_100708348(v2 - 16) = *(_OWORD *)(a2 + 127);
  return a1;
}

CLCppContainer *sub_1007408B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0xD7uLL);
  __int128 v3 = *(_OWORD *)(a1 + 144);
  *((_OWORD *)v2 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 128);
  *((_OWORD *)v2 + 9) = v3;
  *((_OWORD *)v2 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v2 + 175) = *(_OWORD *)(a1 + 175);
  __int128 v4 = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 4) = *(_OWORD *)(a1 + 64);
  *((_OWORD *)v2 + 5) = v4;
  __int128 v5 = *(_OWORD *)(a1 + 112);
  *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 7) = v5;
  __int128 v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
  *((_OWORD *)v2 + 1) = v6;
  __int128 v7 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v2 + 3) = v7;
  *(void *)(v2 + 199) = 0LL;
  *(void *)(v2 + 207) = 0LL;
  uint64_t v8 = *(const void **)(a1 + 191);
  uint64_t v9 = *(void *)(a1 + 199);
  *(void *)(v2 + 191) = 0LL;
  sub_100740FAC(v2 + 191, v8, v9, v9 - (void)v8);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_100741024;
  void v11[3] = &unk_10181D3D0;
  v11[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v11,  0LL,  215LL);
}

void sub_100740988(_Unwind_Exception *a1)
{
}

void sub_10074099C(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    __int128 v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          __int128 v12 = (uint64_t *)v4;
        }
        else {
          __int128 v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        int v51 = v9;
        id v13 = sub_100741064(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100740D70(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              unint64_t v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  unint64_t v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              int v51 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                BOOL v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    BOOL v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  __int16 v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      __int16 v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      BOOL v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10184D518);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)uint64_t buf = 136446466;
                BOOL v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10184D518);
                }
                NSUInteger v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                uint64_t v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                int v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::invokeClientsWithD ata(const Notification_T &, CLCppContainer *) [Notification_T = CLFallNotifier_Type::Notification, Not ificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

_BYTE *sub_100740D70(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    __int128 v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100741064(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    __int128 v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

uint64_t sub_100740E4C@<X0>(__int128 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0xF0uLL);
  uint64_t result = sub_100740EA4((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_100740E90(_Unwind_Exception *a1)
{
}

uint64_t sub_100740EA4(uint64_t a1, __int128 *a2)
{
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  *(void *)a1 = off_10184D568;
  __int128 v3 = a2[8];
  __int128 v4 = a2[9];
  __int128 v5 = a2[10];
  __int128 v6 = *(__int128 *)((char *)a2 + 175);
  __int128 v7 = a2[4];
  __int128 v8 = a2[5];
  __int128 v9 = a2[6];
  __int128 v10 = a2[7];
  __int128 v11 = *a2;
  __int128 v12 = a2[1];
  __int128 v13 = a2[2];
  __int128 v14 = a2[3];
  *(_OWORD *)(a1 + 215) = 0u;
  int v15 = (void *)(a1 + 215);
  *(_OWORD *)((char *)v15 - 143) = v14;
  *(_OWORD *)((char *)v15 - 159) = v13;
  *(_OWORD *)((char *)v15 - 175) = v12;
  *(_OWORD *)((char *)v15 - 191) = v11;
  *(_OWORD *)((char *)v15 - 79) = v10;
  *(_OWORD *)((char *)v15 - 95) = v9;
  *(_OWORD *)((char *)v15 - 111) = v8;
  *(_OWORD *)((char *)v15 - 127) = v7;
  *((_OWORD *)v15 - 1) = v6;
  *(_OWORD *)((char *)v15 - 31) = v5;
  *(_OWORD *)((char *)v15 - 47) = v4;
  *(_OWORD *)((char *)v15 - 63) = v3;
  v15[2] = 0LL;
  sub_100740FAC( v15,  *(const void **)((char *)a2 + 191),  *(void *)((char *)a2 + 199),  *(void *)((char *)a2 + 199) - *(void *)((char *)a2 + 191));
  return a1;
}

void sub_100740F44(_Unwind_Exception *a1)
{
}

void sub_100740F58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10184D568;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100740F6C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10184D568;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100740F90(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 215);
  if (v2)
  {
    *(void *)(a1 + 223) = v2;
    operator delete(v2);
  }

void *sub_100740FAC(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    __int128 v6 = result;
    uint64_t result = sub_1006A33BC(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100741008(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100741024(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 191);
    if (v2)
    {
      *(void *)(v1 + 199) = v2;
      operator delete(v2);
    }

    operator delete((void *)v1);
  }

id sub_100741064(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1007410B0(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1007410B0(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184D5A8);
    }
    __int128 v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x8000000101328A56LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184D5A8);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184D5A8);
    }
    __int128 v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x8000000101328A56LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10184D5A8);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLFall_Types::ImpactStreamData, Callback = (lamb da at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_10074145C(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

void *sub_100741488(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  __int128 v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if ((a4 & 0x8000000000000000LL) != 0) {
      sub_100007008();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_1006A33BC(v7, v11);
    __int128 v9 = (char *)v7[1];
    goto LABEL_17;
  }

  uint64_t v12 = (_BYTE *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    int v15 = &v9[v16];
    goto LABEL_20;
  }

  unint64_t v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    __int128 v9 = (char *)v7[1];
  }

  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  int v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void sub_100741594(int a1, void *__p)
{
  if (__p)
  {
    __int128 v3 = (void *)__p[2];
    if (v3)
    {
      __p[3] = v3;
      operator delete(v3);
    }

    operator delete(__p);
  }

uint64_t sub_1007415CC(uint64_t a1)
{
  *(void *)a1 = &off_10184D6F8;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
  return a1;
}

CLCppContainer *sub_10074162C(uint64_t a1)
{
  id v2 = (char *)operator new(0xD7uLL);
  __int128 v3 = *(_OWORD *)(a1 + 144);
  *((_OWORD *)v2 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 128);
  *((_OWORD *)v2 + 9) = v3;
  *((_OWORD *)v2 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v2 + 175) = *(_OWORD *)(a1 + 175);
  __int128 v4 = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 4) = *(_OWORD *)(a1 + 64);
  *((_OWORD *)v2 + 5) = v4;
  __int128 v5 = *(_OWORD *)(a1 + 112);
  *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 7) = v5;
  __int128 v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)id v2 = *(_OWORD *)a1;
  *((_OWORD *)v2 + 1) = v6;
  __int128 v7 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v2 + 3) = v7;
  *(void *)(v2 + 199) = 0LL;
  *(void *)(v2 + 207) = 0LL;
  unint64_t v8 = *(const void **)(a1 + 191);
  uint64_t v9 = *(void *)(a1 + 199);
  *(void *)(v2 + 191) = 0LL;
  sub_100740FAC(v2 + 191, v8, v9, v9 - (void)v8);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_100741710;
  void v11[3] = &unk_10181D3D0;
  v11[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v11,  0LL,  215LL);
}

void sub_1007416FC(_Unwind_Exception *a1)
{
}

void sub_100741710(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id v2 = *(void **)(v1 + 191);
    if (v2)
    {
      *(void *)(v1 + 199) = v2;
      operator delete(v2);
    }

    operator delete((void *)v1);
  }

void sub_100741750( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

BOOL sub_100741770()
{
  return os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR);
}

  ;
}

void sub_100741798( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t sub_1007417B8()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1019983A0, (void *)&_mh_execute_header);
}

NSDictionary *sub_100741CE0(uint64_t a1)
{
  v6[0] = @"fenceId";
  v7[0] = [*(id *)(a1 + 32) fenceID];
  v6[1] = @"fenceRadius";
  [*(id *)(a1 + 32) radius];
  v7[1] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:");
  _DWORD v6[2] = @"totalDurationInFence";
  [*(id *)(a1 + 32) timeFenceExit];
  double v3 = v2;
  [*(id *)(a1 + 32) timeFenceStart];
  v7[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v3 - v4);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v7,  v6,  3LL);
}

int64_t sub_100742314(id a1, NSDictionary *a2, NSDictionary *a3)
{
  return (int64_t)objc_msgSend( -[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"timestamp"),  "compare:",  -[NSDictionary objectForKeyedSubscript:](a3, "objectForKeyedSubscript:", @"timestamp"));
}

uint64_t **sub_1007425A8(uint64_t **a1, unint64_t *a2)
{
  double v4 = a1 + 1;
  double v3 = a1[1];
  unint64_t v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        __int128 v6 = (uint64_t **)v3;
        unint64_t v7 = v3[4];
        if (v5 >= v7) {
          break;
        }
        double v3 = *v6;
        double v4 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }

      if (v7 >= v5) {
        break;
      }
      double v3 = v6[1];
      if (!v3)
      {
        double v4 = v6 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    __int128 v6 = a1 + 1;
LABEL_9:
    unint64_t v8 = (char *)operator new(0xB0uLL);
    *((void *)v8 + 4) = v5;
    *(_OWORD *)(v8 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 8_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v8 + 104) = 0u;
    *(_OWORD *)(v8 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
    *(_OWORD *)(v8 + 136) = 0u;
    *(_OWORD *)(v8 + 152) = 0u;
    *((void *)v8 + 21) = 0LL;
    sub_1000085FC(a1, (uint64_t)v6, v4, (uint64_t *)v8);
    __int128 v6 = (uint64_t **)v8;
  }

  return v6 + 5;
}

uint64_t sub_100743334(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_100744114(id a1)
{
  qword_101934788 = (uint64_t)os_log_create("com.apple.locationd.Motion", "PedestrianFence");
}

float *sub_100744140@<X0>(float *result@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  float v4 = a2[3];
  float v3 = a2[4];
  float v6 = result[3];
  float v5 = result[4];
  float v7 = a2[2];
  float v8 = result[2];
  float v9 = (float)(v6 * v3) - (float)(v5 * v4);
  float v10 = (float)(v5 * v7) - (float)(v8 * v3);
  float v11 = (float)(v8 * v4) - (float)(v6 * v7);
  float v12 = sqrtf((float)((float)(v10 * v10) + (float)(v9 * v9)) + (float)(v11 * v11));
  if (v12 > 0.0)
  {
    float v9 = v9 / v12;
    float v10 = v10 / v12;
    float v11 = v11 / v12;
  }

  float v13 = (float)(v4 * v11) - (float)(v3 * v10);
  float v14 = (float)(v3 * v9) - (float)(v7 * v11);
  float v15 = (float)(v7 * v10) - (float)(v4 * v9);
  float v16 = sqrtf((float)((float)(v14 * v14) + (float)(v13 * v13)) + (float)(v15 * v15));
  if (v16 > 0.0)
  {
    float v13 = v13 / v16;
    float v14 = v14 / v16;
    float v15 = v15 / v16;
  }

  float v17 = -v3;
  float v18 = -v7;
  float v19 = -v4;
  float v20 = sqrtf((float)((float)(v4 * v4) + (float)(v7 * v7)) + (float)(v3 * v3));
  if (v20 > 0.0)
  {
    float v18 = v18 / v20;
    float v19 = v19 / v20;
    float v17 = v17 / v20;
  }

  *(void *)a3 = &off_10184D780;
  *(void *)(a3 + _Block_object_dispose(va, 8) = &off_10184D7B0;
  *(float *)(a3 + sub_100708348(v2 - 16) = v13;
  *(float *)(a3 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v14;
  *(float *)(a3 + sub_10000AE14(v9 + 24) = v15;
  *(void *)(a3 + 32) = &off_10184D7B0;
  *(float *)(a3 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
  *(float *)(a3 + 44) = v10;
  *(float *)(a3 + 4_Block_object_dispose(va, 8) = v11;
  *(void *)(a3 + 56) = &off_10184D7B0;
  *(float *)(a3 + 64) = v18;
  *(float *)(a3 + 6_Block_object_dispose(va, 8) = v19;
  *(float *)(a3 + 72) = v17;
  return result;
}

uint64_t sub_100744238(float *a1, float *a2, float *a3, float *a4)
{
  float v8 = a1[6];
  float v9 = a1[12];
  if (v8 != 0.0 || (float v10 = 0.0, v9 != 0.0)) {
    float v10 = atan2f(v9, v8);
  }
  *a4 = v10;
  __float2 v11 = __sincosf_stret(v10);
  float v12 = (float)(v11.__sinval * a1[12]) + (float)(v11.__cosval * a1[6]);
  float v13 = a1[18];
  if (v12 == 0.0 && v13 == 0.0) {
    return 0LL;
  }
  *a3 = atan2f(v12, v13);
  float v14 = (float)(v11.__cosval * a1[11]) - (float)(v11.__sinval * a1[5]);
  float v15 = (float)(v11.__cosval * a1[10]) - (float)(v11.__sinval * a1[4]);
  if (v14 == 0.0 && v15 == 0.0) {
    return 0LL;
  }
  *a2 = atan2f(v15, v14);
  return 1LL;
}

uint64_t sub_100744310(float *a1, float *a2)
{
  uint64_t result = sub_100744238(a1, &v5, &v6, &v7);
  if ((_DWORD)result)
  {
    float v4 = (float)((float)-v5 - v7) * 57.2957795;
    if (v4 >= 0.0)
    {
      for (; v4 >= 360.0; float v4 = v4 + -360.0)
        ;
    }

    else
    {
      for (; v4 < -360.0; float v4 = v4 + 360.0)
        ;
      float v4 = v4 + 360.0;
    }

    *a2 = v4;
  }

  return result;
}

float sub_1007443E0(int a1, float result)
{
  if (result >= 0.0)
  {
    for (; result >= 360.0; uint64_t result = result + -360.0)
      ;
  }

  else
  {
    for (; result < -360.0; uint64_t result = result + 360.0)
      ;
    uint64_t result = result + 360.0;
  }

  if (result >= 180.0 && a1 == 1) {
    return result + -360.0;
  }
  return result;
}

BOOL sub_100744474(float *a1, float *a2, float *a3)
{
  float v3 = a2[2];
  float v4 = a2[3];
  float v5 = a2[4];
  float v6 = (float)((float)(a1[5] * v4) + (float)(a1[4] * v3)) + (float)(a1[6] * v5);
  float v7 = (float)((float)(v4 * a1[11]) + (float)(a1[10] * v3)) + (float)(a1[12] * v5);
  BOOL v8 = v7 != 0.0 || v6 != 0.0;
  if (v8)
  {
    float v10 = atan2f(-v7, v6) * 57.2957795;
    if (v10 >= 0.0)
    {
      for (; v10 >= 360.0; float v10 = v10 + -360.0)
        ;
    }

    else
    {
      for (; v10 < -360.0; float v10 = v10 + 360.0)
        ;
      float v10 = v10 + 360.0;
    }

    *a3 = v10;
  }

  return v8;
}

BOOL sub_10074456C(float *a1, float *a2, float *a3)
{
  int v28 = &off_10184D7B0;
  uint64_t v29 = 0LL;
  int v30 = 0;
  float v4 = a2[4];
  float v5 = fabsf(v4);
  float v6 = a2[2];
  float v7 = 0.0;
  if (v5 > fabsf(v6) && v5 > fabsf(a2[3]) && v4 > 0.0)
  {
    LODWORD(v29) = 1031798784;
    int v30 = 0;
    float v7 = 0.0625;
  }

  float v8 = a1[2];
  float v9 = a1[3];
  float v10 = a1[4];
  float v11 = sqrtf((float)((float)(v9 * v9) + (float)(v8 * v8)) + (float)(v10 * v10));
  if (v11 > 0.0)
  {
    float v8 = v8 / v11;
    float v9 = v9 / v11;
    float v10 = v10 / v11;
  }

  float v12 = (float)(v9 + (float)(v8 * 0.0)) + (float)(v10 * 0.0);
  float v13 = v9 * 0.0;
  int v23 = &off_10184D7B0;
  float v24 = v12;
  float v25 = (float)(v13 - v8) + (float)(v10 * 0.0);
  float v26 = v10 + (float)(v13 + (float)(v8 * 0.0));
  float v14 = a2[3];
  float v15 = sqrtf((float)((float)(v14 * v14) + (float)(v6 * v6)) + (float)(v4 * v4));
  if (v15 > 0.0)
  {
    float v6 = v6 / v15;
    float v14 = v14 / v15;
    float v4 = v4 / v15;
  }

  float v16 = (float)(v14 + (float)(v6 * 0.0)) + (float)(v4 * 0.0);
  float v17 = v14 * 0.0;
  float v19 = &off_10184D7B0;
  float v20 = v16;
  float v21 = (float)(v17 - v6) + (float)(v4 * 0.0);
  float v22 = v4 + (float)(v17 + (float)(v6 * 0.0));
  sub_100744140((float *)&v23, (float *)&v19, (uint64_t)v27);
  if (v7 == 0.0)
  {
    if ((sub_100744310(v27, a3) & 1) == 0) {
      return 0LL;
    }
  }

  else
  {
    BOOL result = sub_100744474(v27, (float *)&v28, a3);
    if (!result) {
      return result;
    }
  }

  return 1LL;
}

void sub_1007446E4(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 24584) = 0LL;
  double v2 = *(void ***)(a1 + 24600);
  uint64_t v3 = *(void *)(a1 + 24608);
  *(void *)(a1 + 24632) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      double v2 = (void **)(*(void *)(a1 + 24600) + 8LL);
      *(void *)(a1 + 2460sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v2;
      unint64_t v4 = *(void *)(a1 + 24608) - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v5 = 85LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v5 = 170LL;
  }

  *(void *)(a1 + 246sub_10000AE14(v9 + 24) = v5;
LABEL_8:
  *(void *)(a1 + 2464sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  float v6 = *(void ***)(a1 + 24656);
  uint64_t v7 = *(void *)(a1 + 24664);
  *(void *)(a1 + 2468_Block_object_dispose(va, 8) = 0LL;
  unint64_t v8 = v7 - (void)v6;
  if (v8 >= 0x11)
  {
    do
    {
      operator delete(*v6);
      float v6 = (void **)(*(void *)(a1 + 24656) + 8LL);
      *(void *)(a1 + 24656) = v6;
      unint64_t v8 = *(void *)(a1 + 24664) - (void)v6;
    }

    while (v8 > 0x10);
  }

  if (v8 >> 3 == 1)
  {
    uint64_t v9 = 85LL;
    goto LABEL_14;
  }

  if (v8 >> 3 == 2)
  {
    uint64_t v9 = 170LL;
LABEL_14:
    *(void *)(a1 + 2468sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
  }

  *(void *)(a1 + 24696) = 0LL;
}

void sub_1007447D0(unsigned __int16 *a1, uint64_t *a2, double a3)
{
  if (a3 > 0.0)
  {
    uint64_t v13 = v6;
    uint64_t v14 = v5;
    uint64_t v15 = v3;
    uint64_t v16 = v4;
    sub_100744838(a1, a3);
    uint64_t v10 = *a2;
    *(double *)&__int128 v11 = a3;
    *((void *)&v11 + 1) = v10;
    int v12 = *((_DWORD *)a2 + 2);
    sub_1002E5BC0(a1, &v11);
    sub_100744C7C((uint64_t)a1, a3);
  }

void sub_100744838(unsigned __int16 *a1, double a2)
{
  if (a1[1])
  {
    uint64_t v4 = a1 + 4;
    unint64_t v5 = a1[1] + (unint64_t)*a1 - 1;
    unint64_t v6 = *((unsigned int *)a1 + 1);
    if (v5 < v6) {
      unint64_t v6 = 0LL;
    }
    if (*(double *)&v4[12 * (v5 - v6)] + 1.0 < a2)
    {
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10184D7F0);
      }
      uint64_t v7 = (os_log_s *)off_101934808;
      if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
      {
        unint64_t v8 = *a1 + (unint64_t)a1[1] - 1;
        unint64_t v9 = *((unsigned int *)a1 + 1);
        if (v8 < v9) {
          unint64_t v9 = 0LL;
        }
        float v10 = a2 - *(double *)&v4[12 * (v8 - v9)];
        *(_DWORD *)uint64_t buf = 134217984;
        double v18 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Resetting detector, %.1f seconds without an accel sample",  buf,  0xCu);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_26;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10184D7F0);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Resetting detector, %.1f seconds without an accel sample");
LABEL_31:
      uint64_t v16 = (uint8_t *)v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CMChoreaDetection::checkForGap(CFAbsoluteTime)", "%s\n", v11);
      if (v16 != buf) {
        free(v16);
      }
LABEL_26:
      sub_1007446E4((uint64_t)a1);
      return;
    }
  }

  if (*((void *)a1 + 3079))
  {
    if (v12 + 600.0 < a2)
    {
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10184D7F0);
      }
      uint64_t v13 = (os_log_s *)off_101934808;
      if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
      {
        float v15 = a2 - v14;
        *(_DWORD *)uint64_t buf = 134217984;
        double v18 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Resetting detector, %.1f seconds without a tremor score",  buf,  0xCu);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_26;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10184D7F0);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Resetting detector, %.1f seconds without a tremor score");
      goto LABEL_31;
    }
  }

void sub_100744C7C(uint64_t a1, double a2)
{
  if (!*(void *)(a1 + 24584)) {
    *(void *)(a1 + 24584) = 2560 * (1000 * (uint64_t)a2 / 2560) + 2560;
  }
  if (*(_DWORD *)(a1 + 4) == *(unsigned __int16 *)(a1 + 2))
  {
    uint64_t v3 = (double *)sub_1002E6340((unsigned __int16 *)a1, 0x200uLL);
    uint64_t v4 = *(void *)(a1 + 24584);
    if (v4 >= 1)
    {
      double v5 = (double)v4 / 1000.0;
      if (*v3 >= v5)
      {
        if (*v3 < (double)(v4 + 1280) / 1000.0)
        {
          sub_1007451A8(a1, v5);
          uint64_t v4 = *(void *)(a1 + 24584);
        }

        *(void *)(a1 + 24584) = v4 + 2560;
      }
    }
  }

double sub_100744D3C(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[3075];
  unint64_t v5 = a1[3078];
  unint64_t v6 = (void *)(v4 + 8 * (v5 / 0xAA));
  uint64_t v7 = a1[3076];
  if (v7 == v4) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = (void *)(*v6 + 24 * (v5 % 0xAA));
  }
  while (1)
  {
    if (v7 == v4)
    {
      unint64_t v10 = 0LL;
    }

    else
    {
      unint64_t v9 = a1[3079] + a1[3078];
      unint64_t v10 = *(void *)(v4 + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
    }

    if (v8 == (void *)v10) {
      break;
    }
    sub_100744E50((uint64_t)v8, (uint64_t)a2);
    v8 += 3;
    if ((void *)((char *)v8 - *v6) == (void *)4080)
    {
      __int128 v11 = (void *)v6[1];
      ++v6;
      unint64_t v8 = v11;
    }

    uint64_t v4 = a1[3075];
    uint64_t v7 = a1[3076];
  }

  sub_100744EF8((uint64_t)a1);
  *(void *)&double result = sub_1007450FC(a1 + 3081, a2).n128_u64[0];
  return result;
}

uint64_t sub_100744E50(uint64_t result, uint64_t a2)
{
  if (*(double *)result + 1.5 > *(double *)a2 && *(double *)result < *(double *)a2 + 1.5)
  {
    int v3 = *(_DWORD *)(result + 20);
    int v4 = *(_DWORD *)(a2 + 8);
    if (v3 <= v4) {
      int v3 = *(_DWORD *)(a2 + 8);
    }
    *(_DWORD *)(result + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v3;
    if (v4 >= 1)
    {
      float v5 = *(float *)(result + 12);
      if (v5 > -0.2) {
        float v5 = -0.2;
      }
      *(float *)(result + 12) = v5;
      double v6 = *(float *)(a2 + 12);
      if (v6 <= 2.2) {
        int v7 = 3;
      }
      else {
        int v7 = 4;
      }
      if (v6 <= 0.1) {
        int v8 = 1;
      }
      else {
        int v8 = 2;
      }
      if (v6 <= 0.6) {
        int v7 = v8;
      }
      if (v3 <= v7) {
        int v3 = v7;
      }
      *(_DWORD *)(result + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v3;
    }
  }

  return result;
}

uint64_t sub_100744EF8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24632);
  if (v1)
  {
    uint64_t v2 = result;
    double v3 = *(double *)(result + 24696);
    uint64_t v4 = *(void *)(result + 24600);
    unint64_t v5 = *(void *)(result + 24624);
    double v6 = (unint64_t *)(v4 + 8 * (v5 / 0xAA));
    unint64_t v7 = *v6;
    unint64_t v8 = *v6 + 24 * (v5 % 0xAA);
    double v9 = *(double *)v8;
    if (v3 > *(double *)v8 + 60.0)
    {
      if (*(void *)(result + 24704))
      {
        int v10 = 0;
        uint64_t v11 = *(void *)(result + 24608);
        if (v11 == v4) {
          double v12 = 0LL;
        }
        else {
          double v12 = (double *)(*v6 + 24 * (v5 % 0xAA));
        }
        float v13 = 0.0;
        double v14 = (double *)*v6;
        uint64_t v15 = v4 + 8 * (v5 / 0xAA);
        uint64_t v16 = v12;
LABEL_8:
        uint64_t v17 = (char *)v14 - (char *)v16 + 4080;
        while (1)
        {
          unint64_t v18 = v11 == v4 ? 0LL : *(void *)(v4 + 8 * ((v5 + v1) / 0xAA)) + 24 * ((v5 + v1) % 0xAA);
          float v13 = v13 + *((float *)v16 + 3);
          ++v10;
          v16 += 3;
          v17 -= 24LL;
          if (!v17)
          {
            float v19 = *(double **)(v15 + 8);
            v15 += 8LL;
            double v14 = v19;
            uint64_t v16 = v19;
            goto LABEL_8;
          }
        }

        for (double i = *v12; i <= *(double *)(v2 + 24640); double i = *(double *)v8)
        {
          v8 += 24LL;
          if (v8 - v7 == 4080)
          {
            unint64_t v21 = v6[1];
            ++v6;
            unint64_t v7 = v21;
            unint64_t v8 = v21;
          }
        }

        double v22 = (v3 + v9) * 0.5;
        if (i <= v22)
        {
          BOOL v23 = (float)(v13 / (float)v10) > 0.16;
          do
          {
            uint64_t v24 = *(void *)(v8 + 16);
            __int128 v27 = *(_OWORD *)v8;
            uint64_t v28 = v24;
            DWORD2(v27) = v23;
            double v25 = *(double *)v8;
            v8 += 24LL;
            *(double *)(v2 + 2464sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v25;
            (*(void (**)(__int128 *, void, uint64_t))(v2 + 24704))(&v27, *(void *)(v2 + 24712), v17);
            if (v8 - *v6 == 4080)
            {
              unint64_t v26 = v6[1];
              ++v6;
              unint64_t v8 = v26;
            }
          }

          while (*(double *)v8 <= v22);
          unint64_t v5 = *(void *)(v2 + 24624);
          uint64_t v1 = *(void *)(v2 + 24632);
        }
      }

      *(void *)(v2 + 24632) = v1 - 1;
      *(void *)(v2 + 246sub_10000AE14(v9 + 24) = v5 + 1;
      return sub_100211164(v2 + 24592, 1);
    }
  }

  return result;
}

__n128 sub_1007450FC(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1007463D0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *unint64_t v8 = result;
  ++a1[5];
  return result;
}

void sub_1007451A8(uint64_t a1, double a2)
{
  if (*(_DWORD *)(a1 + 4) == *(unsigned __int16 *)(a1 + 2))
  {
    v46.n128_u64[1] = 0xFFFFFFFFLL;
    int v48 = -1;
    v46.n128_f64[0] = a2;
    sub_10074559C(a1, v51, (unsigned __int16 *)a1, 1);
    sub_10074559C(v3, v50, (unsigned __int16 *)a1, 16);
    sub_10074559C(v4, v49, (unsigned __int16 *)a1, 256);
    float v5 = 0.0;
    if (dword_1019983F0 < dword_1019983F4)
    {
      uint64_t v6 = (float *)&v51[dword_1019983F0];
      unint64_t v7 = (float *)&v50[dword_1019983F0];
      uint64_t v8 = dword_1019983F4 - (uint64_t)dword_1019983F0;
      float v9 = 0.0;
      float v10 = 0.0;
      float v11 = 0.0;
      double v12 = (float *)&v49[dword_1019983F0];
      do
      {
        float v13 = *v6++;
        float v14 = v13;
        float v15 = *v7++;
        float v9 = v9 + (float)(v14 * v14);
        float v10 = v10 + (float)(v15 * v15);
        float v16 = *v12++;
        float v11 = v11 + (float)(v16 * v16);
        --v8;
      }

      while (v8);
      float v5 = v11 + (float)(v10 + v9);
    }

    float v47 = v5;
    uint64_t v17 = operator new(0x14uLL);
    v45[0] = (uint64_t)v17;
    v45[2] = (uint64_t)(v17 + 5);
    v17[4] = 1069547520;
    *(_OWORD *)uint64_t v17 = xmmword_101328B5C;
    v45[1] = (uint64_t)(v17 + 5);
    float v18 = sub_1007457B4(a1, (uint64_t)v51);
    float v20 = v18 * sub_1009AF790(25, 0x80uLL);
    if (v20 > 0.0)
    {
      sub_100745990(v20, v19, (uint64_t)v51, v45);
      sub_100745990(v20, v21, (uint64_t)v50, v45);
      sub_100745990(v20, v22, (uint64_t)v49, v45);
    }

    float v23 = sub_100745CB0(v19, (uint64_t)v51);
    float v25 = sub_100745CB0(v24, (uint64_t)v50);
    float v27 = sub_100745CB0(v26, (uint64_t)v49);
    unint64_t v28 = (qword_1019A2008 - qword_1019A2000) >> 2;
    if (qword_1019A2008 != qword_1019A2000)
    {
      uint64_t v29 = 0LL;
      float v30 = (float)((float)(v23 + v25) + v27) / 3.0;
      if (v28 <= 1) {
        uint64_t v31 = 1LL;
      }
      else {
        uint64_t v31 = (qword_1019A2008 - qword_1019A2000) >> 2;
      }
      while (v30 >= *(float *)(qword_1019A2000 + 4 * v29))
      {
        if (v31 == ++v29) {
          goto LABEL_16;
        }
      }

      LODWORD(v2_Block_object_dispose(va, 8) = v29;
    }

void sub_100745578(_Unwind_Exception *a1)
{
}

void sub_10074559C(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, int a4)
{
  *(void *)uint64_t v31 = 0x10000000000LL;
  sub_100FBFFE8(v30);
  int v7 = 0;
  unint64_t v8 = 0LL;
  unint64_t v9 = -4LL;
  do
  {
    unint64_t v10 = v9 + 4;
    if (a4 == 256)
    {
      float v18 = *(float *)(sub_1002E6340(a3, v10) + 16);
      float v19 = *(float *)(sub_1002E6340(a3, v9 + 5) + 16);
      float v20 = *(float *)(sub_1002E6340(a3, v9 + 6) + 16);
      uint64_t v21 = sub_1002E6340(a3, v9 + 7);
      float v16 = (float)(v18 + v19) + v20;
      float v17 = *(float *)(v21 + 16);
    }

    else if (a4 == 16)
    {
      float v22 = *(float *)(sub_1002E6340(a3, v10) + 12);
      float v23 = *(float *)(sub_1002E6340(a3, v9 + 5) + 12);
      float v24 = *(float *)(sub_1002E6340(a3, v9 + 6) + 12);
      uint64_t v25 = sub_1002E6340(a3, v9 + 7);
      float v16 = (float)(v22 + v23) + v24;
      float v17 = *(float *)(v25 + 12);
    }

    else
    {
      float v11 = 0.0;
      if (a4 != 1) {
        goto LABEL_9;
      }
      float v12 = *(float *)(sub_1002E6340(a3, v10) + 8);
      float v13 = *(float *)(sub_1002E6340(a3, v9 + 5) + 8);
      float v14 = *(float *)(sub_1002E6340(a3, v9 + 6) + 8);
      uint64_t v15 = sub_1002E6340(a3, v9 + 7);
      float v16 = (float)(v12 + v13) + v14;
      float v17 = *(float *)(v15 + 8);
    }

    float v11 = (float)(v16 + v17) * 0.25;
LABEL_9:
    unint64_t v26 = v8 + (unsigned __int16)v7;
    if (v26 >= 0x100) {
      uint64_t v27 = -256LL;
    }
    else {
      uint64_t v27 = 0LL;
    }
    *(float *)&v31[2 * v27 + 4 + 2 * v26] = v11;
    if (v8 > 0xFF)
    {
      else {
        int v28 = 0;
      }
      int v29 = v7 + v28;
      int v7 = v29 + 1;
      v31[0] = v29 + 1;
    }

    else
    {
      v31[1] = ++v8;
    }

    v9 += 4LL;
  }

  while (v9 < 0x3FC);
  sub_100FBFFEC((uint64_t)v30, a2, v31);
}

float sub_1007457B4(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_101998408);
  if ((v3 & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_101998408);
    if ((_DWORD)a1)
    {
      float v27 = sub_1009AF760(25, 0x80uLL, 1.0);
      dword_101998400 = sub_1009AF58C(v27) - 1;
      __cxa_guard_release(&qword_101998408);
    }
  }

  unsigned __int8 v4 = atomic_load((unsigned __int8 *)&qword_101998418);
  if ((v4 & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_101998418);
    if ((_DWORD)a1)
    {
      float v28 = sub_1009AF760(25, 0x80uLL, 2.6667);
      dword_101998410 = sub_1009AF58C(v28);
      __cxa_guard_release(&qword_101998418);
    }
  }

  int v5 = dword_101998400;
  int v6 = dword_101998410;
  if (dword_101998400 >= dword_101998410)
  {
    int v13 = dword_101998400;
  }

  else
  {
    int v7 = (float *)(a2 + 4LL * dword_101998400);
    float v9 = *v7;
    unint64_t v8 = v7 + 1;
    double v10 = v9;
    int v11 = dword_101998400 + 1;
    uint64_t v12 = dword_101998410 - (uint64_t)dword_101998400;
    int v13 = dword_101998400;
    do
    {
      float v14 = *v8++;
      double v15 = v14;
      if (v10 < v14)
      {
        int v13 = v11;
        double v10 = v15;
      }

      ++v11;
      --v12;
    }

    while (v12);
  }

  float v16 = (float)v13 + -0.5;
  float v17 = (float)v13 + 0.5;
  float v19 = sub_100746130(v16, v17, a1, a2);
  float v21 = v20;
  if (v13 >= 0) {
    int v22 = v13;
  }
  else {
    int v22 = v13 + 1;
  }
  if (v5 < v22 >> 1)
  {
    float v23 = sub_100746130(v16 * 0.5, v17 * 0.5, v18, a2);
    if (v23 > v19)
    {
      float v19 = v23;
      float v21 = v24;
    }
  }

  if (v6 > 2 * v13 && sub_100746130(v16 + v16, v17 + v17, v18, a2) > v19) {
    return v25;
  }
  return v21;
}

void sub_100745968(_Unwind_Exception *a1)
{
}

void sub_100745990(float a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)&qword_101998428);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_101998428))
  {
    dword_101998420 = sub_1009AF790(25, 0x80uLL);
    __cxa_guard_release(&qword_101998428);
  }

  unint64_t v8 = 0LL;
  float v9 = 0LL;
  float v10 = *(float *)&dword_101998420;
  float v11 = a1 / *(float *)&dword_101998420;
  signed int v12 = llroundf(v11);
  float v13 = *(float *)(a3 + 4LL * v12);
  std::string __p = 0LL;
  __n128 v46 = 0LL;
  float v47 = 0LL;
  if (dword_1019983FC >= 2)
  {
    unint64_t v8 = 0LL;
    uint64_t v14 = 1LL;
    do
    {
      if (v8 >= (float *)v47)
      {
        double v15 = __p;
        uint64_t v16 = v8 - __p;
        unint64_t v17 = v16 + 1;
        uint64_t v18 = v47 - (char *)__p;
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          float v20 = (char *)sub_10000956C((uint64_t)&v47, v19);
          double v15 = __p;
          unint64_t v8 = v46;
        }

        else
        {
          float v20 = 0LL;
        }

        float v21 = (float *)&v20[4 * v16];
        float v10 = *(float *)(a3 + 4 * v14);
        *float v21 = v10;
        int v22 = v21 + 1;
        while (v8 != v15)
        {
          float v23 = *--v8;
          float v10 = v23;
          *--float v21 = v23;
        }

        std::string __p = v21;
        float v47 = &v20[4 * v19];
        if (v15) {
          operator delete(v15);
        }
        unint64_t v8 = v22;
      }

      else
      {
        float v10 = *(float *)(a3 + 4 * v14);
        *v8++ = v10;
      }

      __n128 v46 = v8;
      ++v14;
    }

    while (v14 < dword_1019983FC);
    float v9 = __p;
  }

  unint64_t v24 = (unint64_t)(v8 - v9) >> 1;
  float v25 = &v9[v24];
  if (v25 != v8)
  {
    sub_1002C3C90(v9, v25, v8, v10);
    float v9 = __p;
    unint64_t v24 = (unint64_t)(v46 - __p) >> 1;
  }

  uint64_t v26 = *a4;
  uint64_t v27 = a4[1];
  uint64_t v28 = v27 - *a4;
  if (v27 == *a4) {
    goto LABEL_48;
  }
  uint64_t v29 = 0LL;
  float v30 = v9[v24];
  unint64_t v31 = v28 >> 2;
  uint64_t v32 = dword_1019983FC;
  if (v31 <= 1) {
    unint64_t v31 = 1LL;
  }
  float v33 = 0.12 / *(float *)&dword_101998420;
  do
  {
    float v34 = v11 * *(float *)(v26 + 4 * v29);
    float v35 = floorf(v34 + -0.001);
    float v36 = ceilf(v34 - v33);
    if (v36 < v35) {
      float v35 = v36;
    }
    float v37 = ceilf(v34 + 0.001);
    int v38 = (int)v35;
    float v39 = floorf(v34 + v33);
    if (v37 >= v39) {
      float v39 = v37;
    }
    if (v38 <= (int)v39)
    {
      uint64_t v40 = v38;
      int v41 = (int)v39 - v38 + 1;
      do
      {
        if (v12 != v40 && v40 <= v32)
        {
          float v42 = *(float *)(a3 + 4 * v40) - v30;
          if (v42 >= v13) {
            float v43 = v13;
          }
          else {
            float v43 = *(float *)(a3 + 4 * v40) - v30;
          }
          float v44 = *(float *)(a3 + 4LL * v12);
          *(float *)(a3 + 4LL * v12) = v44 + v42;
          *(float *)(a3 + 4 * v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(float *)(a3 + 4 * v40) - v42;
        }

        ++v40;
        --v41;
      }

      while (v41);
    }

    ++v29;
  }

  while (v29 != v31);
  if (v9) {
LABEL_48:
  }
    operator delete(v9);
}

void sub_100745C78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
}

float sub_100745CB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = dword_1019983F8;
  int v3 = dword_1019983FC;
  double v4 = 0.0;
  if (dword_1019983FC > dword_1019983F8)
  {
    int v5 = (float *)(a2 + 4LL * dword_1019983F8);
    int v6 = (float *)&v15[dword_1019983F8];
    uint64_t v7 = dword_1019983FC - (uint64_t)dword_1019983F8;
    double v8 = 0.0;
    uint64_t v9 = v7;
    do
    {
      float v10 = *v5++;
      *v6++ = v10 * v10;
      double v8 = v8 + (float)(v10 * v10);
      --v9;
    }

    while (v9);
    float v11 = (float *)&v15[v2];
    double v4 = 0.0;
    do
    {
      float v12 = *v11++;
      float v13 = v12 / v8;
      double v4 = v4 - (float)(log2f(v13) * v13);
      --v7;
    }

    while (v7);
  }

  return v4 / log2((double)(v3 - (int)v2));
}

__n128 sub_100745DB8(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1007466E4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  double v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *double v8 = result;
  ++a1[5];
  return result;
}

unint64_t sub_100745E64(int64x2_t *a1, void *a2, char *a3)
{
  unint64_t v4 = a1[2].u64[0];
  uint64_t v5 = a1->i64[1];
  uint64_t v6 = (char **)(v5 + 8 * (v4 / 0xAA));
  if (a1[1].i64[0] == v5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = &(*v6)[24 * (v4 % 0xAA)];
  }
  if (a3 == v7) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = 170 * ((char **)a2 - v6)
  }
  v27[0].n128_u64[0] = v5 + 8 * (v4 / 0xAA);
  v27[0].n128_u64[1] = (unint64_t)v7;
  sub_10025BC20(v27, v8);
  uint64_t v9 = a1[2].i64[1];
  int64_t v10 = v27[0].n128_u64[1] - *(void *)v27[0].n128_u64[0];
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
  if (v8 <= (unint64_t)(v9 - 1) >> 1)
  {
    if (v10 < -23)
    {
      double v15 = (void *)(v27[0].n128_u64[0] - 8 * ((168 - v11) / 0xAA));
      uint64_t v16 = (char *)(*v15 + 24 * (170 * ((168 - v11) / 0xAA) - (168 - v11)) + 4056);
    }

    else
    {
      double v15 = (void *)(v27[0].n128_u64[0] + 8 * ((v11 + 1) / 0xAA));
      uint64_t v16 = (char *)(*v15 + 24 * ((v11 + 1) % 0xAA));
    }

    sub_1007469F8(v6, v7, (char **)v27[0].n128_u64[0], (char *)v27[0].n128_u64[1], v15, v16, v27);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012CE4D0);
    sub_100211164((uint64_t)a1, 1);
  }

  else
  {
    if (v10 < -23)
    {
      unint64_t v17 = 168 - v11;
      float v13 = (void *)(v27[0].n128_u64[0] - 8 * (v17 / 0xAA));
      uint64_t v14 = (_BYTE *)(*v13 + 24 * (170 * (v17 / 0xAA) - v17) + 4056);
    }

    else
    {
      unint64_t v12 = v11 + 1;
      float v13 = (void *)(v27[0].n128_u64[0] + 8 * (v12 / 0xAA));
      uint64_t v14 = (_BYTE *)(*v13 + 24 * (v12 % 0xAA));
    }

    unint64_t v18 = a1[2].i64[0] + v9;
    uint64_t v19 = a1->i64[1];
    float v20 = (_BYTE **)(v19 + 8 * (v18 / 0xAA));
    if (a1[1].i64[0] == v19) {
      float v21 = 0LL;
    }
    else {
      float v21 = &(*v20)[24 * (v18 % 0xAA)];
    }
    sub_100746BB0(v13, v14, v20, v21, (uint64_t)v27);
    --a1[2].i64[1];
    sub_10025BDF8(a1, 1);
  }

  unint64_t v22 = a1[2].u64[0];
  uint64_t v23 = a1->i64[1];
  unint64_t v24 = (void *)(v23 + 8 * (v22 / 0xAA));
  if (a1[1].i64[0] == v23) {
    unint64_t v25 = 0LL;
  }
  else {
    unint64_t v25 = *v24 + 24 * (v22 % 0xAA);
  }
  v27[0].n128_u64[0] = (unint64_t)v24;
  v27[0].n128_u64[1] = v25;
  sub_10025BC20(v27, v8);
  return v27[0].n128_u64[0];
}

float sub_100746130(float a1, float a2, uint64_t a3, uint64_t a4)
{
  int v4 = vcvtms_s32_f32(a1);
  signed int v5 = vcvtps_s32_f32(a2);
  double v6 = *(float *)(a4 + 4LL * v4);
  if (v4 < v5)
  {
    uint64_t v7 = v5;
    int v8 = v4 + 1;
    uint64_t v9 = v7 - v4;
    int64_t v10 = (float *)(a4 + 4LL * v4 + 4);
    double v11 = *(float *)(a4 + 4LL * v4);
    do
    {
      float v12 = *v10++;
      double v13 = v12;
      if (v11 < v12)
      {
        int v4 = v8;
        double v6 = v13;
        double v11 = v13;
      }

      ++v8;
      --v9;
    }

    while (v9);
  }

  float v14 = (float)v4;
  float v15 = (float)v4 + -0.5;
  if (v15 <= a1) {
    float v15 = a1;
  }
  else {
    float v16 = v14 + 0.5;
  }
  signed int v17 = vcvtmd_s64_f64(v15 * 0.5);
  signed int v18 = vcvtpd_s64_f64(v16 * 0.5);
  double v19 = *(float *)(a4 + 4LL * v17);
  if (v17 < v18)
  {
    uint64_t v20 = v17;
    uint64_t v21 = v18 - (uint64_t)v17;
    unint64_t v22 = (float *)(a4 + 4 * v20 + 4);
    double v23 = v19;
    do
    {
      float v24 = *v22++;
      double v25 = v24;
      if (v23 < v24)
      {
        double v19 = v25;
        double v23 = v25;
      }

      --v21;
    }

    while (v21);
  }

  int v26 = vcvtms_s32_f32(v15 + v15);
  signed int v27 = vcvtps_s32_f32(v16 + v16);
  double v28 = *(float *)(a4 + 4LL * v26);
  if (v26 < v27)
  {
    uint64_t v29 = v27;
    int v30 = v26 + 1;
    uint64_t v31 = v29 - v26;
    uint64_t v32 = (float *)(a4 + 4LL * v26 + 4);
    double v33 = *(float *)(a4 + 4LL * v26);
    do
    {
      float v34 = *v32++;
      double v35 = v34;
      if (v33 < v34)
      {
        int v26 = v30;
        double v28 = v35;
        double v33 = v35;
      }

      ++v30;
      --v31;
    }

    while (v31);
  }

  float v36 = (float)((float)v26 + -0.5) * 0.5;
  if (v15 >= v36) {
    float v36 = v15;
  }
  int v37 = vcvtms_s32_f32(v36 * 3.0);
  signed int v38 = vcvtps_s32_f32(v16 * 3.0);
  double v39 = *(float *)(a4 + 4LL * v37);
  if (v37 < v38)
  {
    uint64_t v40 = v38;
    int v41 = v37 + 1;
    uint64_t v42 = v40 - v37;
    float v43 = (float *)(a4 + 4LL * v37 + 4);
    double v44 = *(float *)(a4 + 4LL * v37);
    do
    {
      float v45 = *v43++;
      double v46 = v45;
      if (v44 < v45)
      {
        int v37 = v41;
        double v39 = v46;
        double v44 = v46;
      }

      ++v41;
      --v42;
    }

    while (v42);
  }

  float v47 = (float)((float)v37 + -0.5) / 3.0;
  if (v36 >= v47) {
    float v47 = v36;
  }
  signed int v48 = vcvtmd_s64_f64(v47 * 1.5);
  signed int v49 = vcvtpd_s64_f64(v16 * 1.5);
  double v50 = *(float *)(a4 + 4LL * v48);
  if (v48 < v49)
  {
    uint64_t v51 = v48;
    uint64_t v52 = v49 - (uint64_t)v48;
    uint64_t v53 = (float *)(a4 + 4 * v51 + 4);
    double v54 = v50;
    do
    {
      float v55 = *v53++;
      double v56 = v55;
      if (v54 < v55)
      {
        double v50 = v56;
        double v54 = v56;
      }

      --v52;
    }

    while (v52);
  }

  return v6 + v19 + v28 + v39 + v50;
}

void sub_1007463A4(id a1)
{
  off_101934808 = os_log_create("com.apple.locationd.Motion", "MovementDisorder");
}

void sub_1007463D0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    double v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float v34 = (char *)sub_1000071BC(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      signed int v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100746698( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1007466E4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    double v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float v34 = (char *)sub_1000071BC(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      signed int v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1007469AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_1007469F8@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    double v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    BOOL v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_100746AC4(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      BOOL v14 = v17 + 4080;
    }

    uint64_t v18 = *a1 + 4080;
    double v19 = a2;
  }

  sub_100746AC4(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_100746AC4@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  double v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      int64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a4[-v10] >> 3);
      v11 -= 24 * v12;
      a4 -= 24 * v12;
      if (v12) {
        __n128 result = memmove(a4, v11, 24 * v12 - 4);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a4 = (char *)(v14 + 4080);
    }

    if ((char *)(*v6 + 4080LL) == a4)
    {
      uint64_t v15 = (char *)v6[1];
      ++v6;
      a4 = v15;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_100746BB0(void *a1, _BYTE *a2, _BYTE **a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v7 = *(void ***)a5;
  int v8 = *(char **)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (double i = (_BYTE *)(*a1 + 4080LL); ; double i = v12 + 4080)
    {
      sub_100746C40(a2, v8, i, v7, &v14);
      int v8 = (char *)*((void *)&v15 + 1);
      uint64_t v7 = (void **)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + _Block_object_dispose(va, 8) = v8;
      if (v10 == a3) {
        break;
      }
      int64_t v12 = (_BYTE *)*v10++;
      a2 = v12;
    }

    a2 = *a3;
  }

  sub_100746C40(a2, v8, a4, v7, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void *sub_100746C40@<X0>( _BYTE *__src@<X1>, char *__dst@<X4>, _BYTE *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
  double v6 = a4;
  uint64_t v7 = __src;
  if (__src == a3)
  {
    uint64_t v9 = __src;
  }

  else
  {
    uint64_t v9 = a3;
    double v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v10 - __dst + 4080) >> 3);
      unint64_t v12 = (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0xAAAAAAAAAAAAAAABLL * ((v9 - v7) >> 3);
      if (v12) {
        double result = memmove(__dst, v7, 24 * v12 - 4);
      }
      v7 += 24 * v12;
      if (v7 == v9) {
        break;
      }
      uint64_t v14 = (char *)*v6++;
      uint64_t v10 = v14;
      __uuid_t dst = v14;
    }

    __dst += 24 * v12;
    else {
      --v6;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = __dst;
  return result;
}

uint64_t sub_100746D30()
{
  float v0 = sub_1009AF760(25, 0x80uLL, 1.0);
  dword_1019983F0 = sub_1009AF58C(v0);
  float v1 = sub_1009AF760(25, 0x80uLL, 3.0);
  dword_1019983F4 = sub_1009AF58C(v1);
  float v2 = sub_1009AF760(25, 0x80uLL, 0.25);
  dword_1019983F8 = sub_1009AF58C(v2);
  float v3 = sub_1009AF760(25, 0x80uLL, 7.25);
  uint64_t result = sub_1009AF58C(v3);
  dword_1019983FC = result;
  return result;
}

void *sub_100746DB0(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t result = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *uint64_t result = off_10184D820;
  result[6] = 0LL;
  result[7] = 0LL;
  return result;
}

uint64_t sub_100746DD4(void *a1)
{
  *a1 = off_10184D820;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[7];
  a1[7] = 0LL;
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    uint64_t v4 = a1[7];
    a1[7] = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

  uint64_t v5 = a1[6];
  a1[6] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return sub_100C6AB50((uint64_t)a1);
}

void sub_100746E64(void *a1)
{
  float v1 = (void *)sub_100746DD4(a1);
  operator delete(v1);
}

void *sub_100746E78@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_10184D8E8;
  v11[1] = sub_1007470E0;
  _DWORD v11[2] = 0LL;
  unint64_t v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageSidebandOverride");
  sub_100747BD4((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_10184D8E8;
  v9[1] = sub_100747410;
  v9[2] = 0LL;
  uint64_t v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageSidebandSensorFusionEnable");
  sub_100747BD4((uint64_t)v16, (uint64_t)v9);
  sub_100747E30(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      uint64_t v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  uint64_t v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_100747010( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  int64_t v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    int64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  __n128 v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    __n128 v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_1007470E0(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  sub_100C6AC8C(a1);
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v6 = [Dictionary objectForKeyedSubscript:CMOverrideSidebandOverride];
  id v7 = [Dictionary objectForKeyedSubscript:CMStateSidebandState];
  uint64_t v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0LL;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10184D898);
    }
    uint64_t v10 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Invalid message recieved from framework.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10184D898);
      }
      v18[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Invalid message recieved from framework.",  v18,  2);
      uint64_t v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSidebandSubscription::handleMessageSidebandOverride(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

  uint64_t v11 = sub_1008FA854(0);
  if ([v8 unsignedIntValue] > 8)
  {
    uint64_t v12 = 4LL;
LABEL_19:
    sub_100747990(a1, v12);
    goto LABEL_20;
  }

  if (!v11 || ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 80LL))(v11) & 1) == 0)
  {
    uint64_t v12 = 2LL;
    goto LABEL_19;
  }

  unsigned __int8 v13 = [v6 BOOLValue];
  uint64_t v14 = *(void *)(a1 + 48);
  if ((v13 & 1) != 0)
  {
    if (!v14)
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472LL;
      v17[2] = sub_100747B58;
      void v17[3] = &unk_10184D848;
      v17[4] = v8;
      v17[5] = a1;
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 88LL))(v11, v17);
      goto LABEL_20;
    }

    (*(void (**)(uint64_t, id))(*(void *)v14 + 16))(v14, [v8 unsignedIntValue]);
  }

  else
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    }
  }

  sub_100747990(a1, 0LL);
LABEL_20:
}

void sub_1007473D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100747410(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v6 = [Dictionary objectForKeyedSubscript:CMSidebandSensorFusionEnable];
  id v7 = [Dictionary objectForKeyedSubscript:CMSidebandSensorFusionLatency];
  id v8 = [Dictionary objectForKeyedSubscript:CMSidebandSensorFusionSnoop];
  BOOL v9 = v8;
  if (v6) {
    BOOL v10 = v7 == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10 && v8 != 0LL)
  {
    if (([v6 BOOLValue] & 1) != 0
      || ([v7 BOOLValue] & 1) != 0
      || [v9 BOOLValue])
    {
      uint64_t v15 = *(void *)(a1 + 56);
      if (!v15)
      {
        uint64_t v16 = sub_1008FA854(0);
        if (v16)
        {
          (*(void (**)(uint8_t *__return_ptr))(*(void *)v16 + 136LL))(buf);
          uint64_t v17 = *(void *)buf;
          *(void *)uint64_t buf = 0LL;
          uint64_t v18 = *(void *)(a1 + 56);
          *(void *)(a1 + 56) = v17;
          if (v18)
          {
            (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
            uint64_t v19 = *(void *)buf;
            *(void *)uint64_t buf = 0LL;
            if (v19) {
              (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
            }
          }
        }

        uint64_t v15 = *(void *)(a1 + 56);
        if (!v15)
        {
          if (qword_101934560 != -1) {
            dispatch_once(&qword_101934560, &stru_10184D8B8);
          }
          __n128 v22 = (os_log_s *)qword_101934568;
          if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v23 = [v6 BOOLValue];
            unsigned int v24 = [v9 BOOLValue];
            unsigned int v25 = [v7 BOOLValue];
            *(_DWORD *)uint64_t buf = 67240960;
            *(_DWORD *)&uint8_t buf[4] = v23;
            __int16 v39 = 1026;
            unsigned int v40 = v24;
            __int16 v41 = 1026;
            unsigned int v42 = v25;
            __int16 v43 = 1026;
            int v44 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "[SidebandSensorFusion] Request failed,enabled,%{public}d,snoop,%{public}d,latency,%{public}d,success,%{public}d",  buf,  0x1Au);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934560 != -1) {
              dispatch_once(&qword_101934560, &stru_10184D8B8);
            }
            uint64_t v26 = qword_101934568;
            v31[0] = 67240960;
            v31[1] = [v6 BOOLValue];
            __int16 v32 = 1026;
            unsigned int v33 = [v9 BOOLValue];
            __int16 v34 = 1026;
            unsigned int v35 = [v7 BOOLValue];
            __int16 v36 = 1026;
            int v37 = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "[SidebandSensorFusion] Request failed,enabled,%{public}d,snoop,%{public}d,latency,%{public}d,success,%{public}d",  v31,  26);
            uint64_t v28 = (uint8_t *)v27;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSidebandSubscription::handleMessageSidebandSensorFusionEnable(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v27);
            if (v28 != buf) {
              free(v28);
            }
          }

          uint64_t v20 = 0LL;
          goto LABEL_29;
        }
      }

      (*(void (**)(uint64_t, id))(*(void *)v15 + 16))(v15, [v6 BOOLValue]);
      (*(void (**)(void, id))(**(void **)(a1 + 56) + 32))( *(void *)(a1 + 56),  [v9 BOOLValue]);
      (*(void (**)(void, id))(**(void **)(a1 + 56) + 24))( *(void *)(a1 + 56),  [v7 BOOLValue]);
    }

    else
    {
      uint64_t v21 = *(void *)(a1 + 56);
      *(void *)(a1 + 56) = 0LL;
      if (v21) {
        (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
      }
    }

    uint64_t v20 = 1LL;
LABEL_29:
    uint64_t v29 = CMSidebandSensorFusionSuccess;
    __int128 v30 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v20);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL);
    CLConnectionMessage::sendReply(*a2);
    goto LABEL_30;
  }

  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_10184D8B8);
  }
  uint64_t v12 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "[SidebandSensorFusion] Wrong parameters were passed!",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10184D8B8);
    }
    LOWORD(v31[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  17LL,  "[SidebandSensorFusion] Wrong parameters were passed!",  v31,  2);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSidebandSubscription::handleMessageSidebandSensorFusionEnable(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

void sub_10074793C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100747990(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo"), "queue");
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1007479FC;
  v5[3] = &unk_101830538;
  _OWORD v5[4] = a1;
  void v5[5] = a2;
  dispatch_async(v4, v5);
}

uint64_t sub_1007479FC(uint64_t a1)
{
  uint64_t v4 = CMOverrideResult;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v5 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(a1 + 40));
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL);
  sub_100747AB0(v1, &v3);
  return sub_100C6AC8C(v1);
}

void sub_100747AB0(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100747B44(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100747B58(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *(void *)(v3 + 48);
  *(void *)(v3 + 4_Block_object_dispose(va, 8) = v4;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    uint64_t v4 = *(void *)(v3 + 48);
  }

  if (v4)
  {
    (*(void (**)(uint64_t, id))(*(void *)v4 + 16))(v4, [*(id *)(a1 + 32) unsignedIntValue]);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  sub_100747990(v3, v6);
}

uint64_t sub_100747BD4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + sub_10000AE14(v9 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + sub_10000AE14(v9 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  void *v3 = 0LL;
  return a1;
}

void sub_100747C38(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_100747C64(id a1)
{
  qword_101934568 = (uint64_t)os_log_create("com.apple.locationd.Motion", "DeviceMotion");
}

__n128 sub_100747C90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10184D8E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_100747CCC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10184D8E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_100747CF0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100747CF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100747D34()
{
}

void sub_100747D40(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  uint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    uint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  BOOL v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    unsigned __int8 v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100747E14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100747E30(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100747EA8(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100747E94(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100747EA8(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  id v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    unsigned __int8 v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100748128(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  __n128 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *__n128 v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + sub_100708348(v2 - 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100748110(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100748128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_10074819C(v8 + 2, a3);
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 1;
  return result;
}

void sub_100748184(_Unwind_Exception *a1)
{
}

void *sub_10074819C(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_1007481F4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100748210(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  __int128 v6 = a3[1];
  __int128 v5 = a3[2];
  __int128 v7 = *a3;
  *(_OWORD *)(a1 + 172) = *(__int128 *)((char *)a3 + 44);
  *(_OWORD *)(a1 + 144) = v6;
  *(_OWORD *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v5;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = v7;
  return 1LL;
}

uint64_t sub_100748250(void *a1)
{
  a1[8] = a1[7];
  a1[11] = a1[10];
  a1[14] = a1[13];
  return 1LL;
}

uint64_t sub_100748270(uint64_t a1, uint64_t a2)
{
  if (**(void **)(a2 + 48) != *(void *)(*(void *)(a2 + 48) + 8LL))
  {
    *(void *)&__int128 v108 = 0LL;
    uint64_t v109 = 26LL;
    *((void *)&v108 + 1) = *(void *)(a2 + 24);
    uuid_copy(dst, (const unsigned __int8 *)a2);
    uint64_t v4 = 0LL;
    *(void *)&__int128 v108 = *(void *)(a2 + 16);
    uint64_t v109 = *(void *)(a2 + 32);
    do
    {
      __int128 v5 = &__src[v4];
      *__int128 v5 = 0;
      *((void *)v5 + 7) = 0LL;
      v5[16] = 0;
      *((void *)v5 + 1) = 0LL;
      *((void *)v5 + 2) = 0LL;
      void v5[6] = 0;
      *((void *)v5 + 4) = 0LL;
      *((void *)v5 + 5) = 0LL;
      v5[12] = 0;
      *((void *)v5 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
      *((void *)v5 + 11) = 0LL;
      v4 += 24LL;
      *((void *)v5 + 9) = 0LL;
    }

    while (v4 != 336);
    for (uint64_t i = 0LL; i != 168; i += 12LL)
    {
      __int128 v7 = &v84[i];
      *(_DWORD *)__int128 v7 = 0;
      v7[7] = 0LL;
      *((_DWORD *)v7 + sub_100708348(v2 - 16) = 0;
      v7[1] = 0LL;
      v7[2] = 0LL;
      *((_DWORD *)v7 + 6) = 0;
      unsigned __int8 v7[4] = 0LL;
      v7[5] = 0LL;
      *((_DWORD *)v7 + 12) = 0;
      v7[10] = 0LL;
      v7[11] = 0LL;
      v7[9] = 0LL;
    }

    for (j = *(float **)(a1 + 32); j; j = *(float **)j)
    {
      uint64_t v9 = *((int *)j + 4);
      sub_100748B0C(a1, a2, (uint64_t)buf, (float)(j[5] * 60.0));
      __int128 v10 = v96;
      uint8x8_t v11 = &__src[24 * v9];
      _DWORD v11[2] = *(_OWORD *)&buf[32];
      void v11[3] = v10;
      __int128 v12 = v98;
      v11[4] = v97;
      void v11[5] = v12;
      __int128 v13 = *(_OWORD *)&buf[16];
      *uint8x8_t v11 = *(_OWORD *)buf;
      v11[1] = v13;
      unint64_t v14 = &v84[12 * v9];
      __int128 v15 = v102;
      *((_OWORD *)v14 + 2) = v101;
      *((_OWORD *)v14 + 3) = v15;
      __int128 v16 = v104;
      *((_OWORD *)v14 + 4) = v103;
      *((_OWORD *)v14 + 5) = v16;
      __int128 v17 = v100;
      *(_OWORD *)unint64_t v14 = v99;
      *((_OWORD *)v14 + 1) = v17;
    }

    unint64_t v18 = *(void *)(a1 + 120);
    unint64_t v19 = *(void *)(a1 + 112);
    if (v19 >= v18)
    {
      uint64_t v32 = *(void *)(a1 + 104);
      unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - v32) >> 3);
      unint64_t v34 = v33 + 1;
      if (v33 + 1 > 0x666666666666666LL) {
        sub_100007008();
      }
      unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - v32) >> 3);
      if (2 * v35 > v34) {
        unint64_t v34 = 2 * v35;
      }
      if (v35 >= 0x333333333333333LL) {
        unint64_t v36 = 0x666666666666666LL;
      }
      else {
        unint64_t v36 = v34;
      }
      if (v36) {
        int v37 = (char *)sub_100100EF8(a1 + 120, v36);
      }
      else {
        int v37 = 0LL;
      }
      signed int v38 = &v37[40 * v33];
      __int16 v39 = &v37[40 * v36];
      __int128 v40 = *(_OWORD *)dst;
      __int128 v41 = v108;
      *((void *)v38 + 4) = v109;
      *(_OWORD *)signed int v38 = v40;
      *((_OWORD *)v38 + 1) = v41;
      __n128 v22 = v38 + 40;
      __int16 v43 = *(char **)(a1 + 104);
      unsigned int v42 = *(char **)(a1 + 112);
      if (v42 != v43)
      {
        do
        {
          __int128 v44 = *(_OWORD *)(v42 - 40);
          __int128 v45 = *(_OWORD *)(v42 - 24);
          *((void *)v38 - 1) = *((void *)v42 - 1);
          *(_OWORD *)(v38 - sub_10000AE14(v9 + 24) = v45;
          *(_OWORD *)(v38 - 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v44;
          v38 -= 40;
          v42 -= 40;
        }

        while (v42 != v43);
        unsigned int v42 = *(char **)(a1 + 104);
      }

      *(void *)(a1 + 104) = v38;
      *(void *)(a1 + sub_10000AE14(v2 - 112) = v22;
      *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v39;
      if (v42) {
        operator delete(v42);
      }
    }

    else
    {
      __int128 v20 = *(_OWORD *)dst;
      __int128 v21 = v108;
      *(void *)(v19 + 32) = v109;
      *(_OWORD *)unint64_t v19 = v20;
      *(_OWORD *)(v19 + sub_100708348(v2 - 16) = v21;
      __n128 v22 = (char *)(v19 + 40);
    }

    unint64_t v46 = *(void *)(a1 + 72);
    *(void *)(a1 + sub_10000AE14(v2 - 112) = v22;
    unint64_t v47 = *(void *)(a1 + 64);
    if (v47 >= v46)
    {
      uint64_t v49 = *(void *)(a1 + 56);
      unint64_t v50 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v47 - v49) >> 6);
      if (v50 + 1 > 0x30C30C30C30C30LL) {
        sub_100007008();
      }
      unint64_t v51 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v46 - v49) >> 6);
      uint64_t v52 = 2 * v51;
      if (2 * v51 <= v50 + 1) {
        uint64_t v52 = v50 + 1;
      }
      if (v51 >= 0x18618618618618LL) {
        unint64_t v53 = 0x30C30C30C30C30LL;
      }
      else {
        unint64_t v53 = v52;
      }
      if (v53) {
        __int128 v54 = (char *)sub_1007490E0(a1 + 72, v53);
      }
      else {
        __int128 v54 = 0LL;
      }
      __int128 v55 = &v54[1344 * v50];
      double v56 = &v54[1344 * v53];
      memcpy(v55, __src, 0x540uLL);
      signed int v48 = v55 + 1344;
      __int16 v58 = *(char **)(a1 + 56);
      BOOL v57 = *(char **)(a1 + 64);
      if (v57 != v58)
      {
        do
        {
          v57 -= 1344;
          v55 -= 1344;
          memcpy(v55, v57, 0x540uLL);
        }

        while (v57 != v58);
        BOOL v57 = *(char **)(a1 + 56);
      }

      *(void *)(a1 + 56) = v55;
      *(void *)(a1 + 64) = v48;
      *(void *)(a1 + 72) = v56;
      if (v57) {
        operator delete(v57);
      }
    }

    else
    {
      memcpy(*(void **)(a1 + 64), __src, 0x540uLL);
      signed int v48 = (char *)(v47 + 1344);
    }

    unint64_t v59 = *(void *)(a1 + 96);
    *(void *)(a1 + 64) = v48;
    unint64_t v60 = *(void *)(a1 + 88);
    if (v60 >= v59)
    {
      uint64_t v62 = *(void *)(a1 + 80);
      unint64_t v63 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v60 - v62) >> 6);
      if (v63 + 1 > 0x30C30C30C30C30LL) {
        sub_100007008();
      }
      unint64_t v64 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v59 - v62) >> 6);
      uint64_t v65 = 2 * v64;
      if (2 * v64 <= v63 + 1) {
        uint64_t v65 = v63 + 1;
      }
      if (v64 >= 0x18618618618618LL) {
        unint64_t v66 = 0x30C30C30C30C30LL;
      }
      else {
        unint64_t v66 = v65;
      }
      if (v66) {
        __int16 v67 = (char *)sub_1007490E0(a1 + 96, v66);
      }
      else {
        __int16 v67 = 0LL;
      }
      uint64_t v68 = &v67[1344 * v63];
      __int16 v69 = &v67[1344 * v66];
      memcpy(v68, v84, 0x540uLL);
      char v61 = v68 + 1344;
      NSUInteger v71 = *(char **)(a1 + 80);
      uint64_t v70 = *(char **)(a1 + 88);
      if (v70 != v71)
      {
        do
        {
          v70 -= 1344;
          v68 -= 1344;
          memcpy(v68, v70, 0x540uLL);
        }

        while (v70 != v71);
        uint64_t v70 = *(char **)(a1 + 80);
      }

      *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v68;
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = v61;
      *(void *)(a1 + 96) = v69;
      if (v70) {
        operator delete(v70);
      }
    }

    else
    {
      memcpy(*(void **)(a1 + 88), v84, 0x540uLL);
      char v61 = (char *)(v60 + 1344);
    }

    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v61;
    uuid_unparse((const unsigned __int8 *)a2, out);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184D970);
    }
    uint64_t v72 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v73 = *(void *)(a2 + 16);
      uint64_t v74 = *(void *)(a2 + 24);
      uint64_t v75 = *(void *)(a2 + 32);
      uint64_t v76 = (uint64_t)(*(void *)(*(void *)(a2 + 48) + 8LL) - **(void **)(a2 + 48)) >> 6;
      *(_DWORD *)uint64_t buf = 134219010;
      *(void *)&uint8_t buf[4] = v73;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v74;
      *(_WORD *)&_BYTE buf[22] = 1024;
      *(_DWORD *)&buf[24] = v75;
      *(_WORD *)&_BYTE buf[28] = 2048;
      *(void *)&buf[30] = v76;
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = out;
      _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEBUG,  "CLCyclingFTPBoutStatsGenerator using session from, %f, to %f, workout_type, %d, size, %lu, session_id, %s",  buf,  0x30u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184D970);
    }
    uint64_t v78 = *(void *)(a2 + 16);
    uint64_t v79 = *(void *)(a2 + 24);
    uint64_t v80 = *(void *)(a2 + 32);
    uint64_t v81 = (uint64_t)(*(void *)(*(void *)(a2 + 48) + 8LL) - **(void **)(a2 + 48)) >> 6;
    int v85 = 134219010;
    uint64_t v86 = v78;
    __int16 v87 = 2048;
    uint64_t v88 = v79;
    __int16 v89 = 1024;
    int v90 = v80;
    __int16 v91 = 2048;
    uint64_t v92 = v81;
    __int16 v93 = 2080;
    int v94 = out;
    LODWORD(v83) = 48;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "CLCyclingFTPBoutStatsGenerator using session from, %f, to %f, workout_type, %d, size, %lu, session_id, %s",  COERCE_DOUBLE(&v85),  v83,  LODWORD(v84[0]),  v84[1],  v84[2]);
    __int128 v31 = (char *)v82;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCyclingFTPBoutStatsGenerator::processSession(const CLCyclingFTPHistory::Session &)",  "%s\n",  v82);
LABEL_73:
    if (v31 != buf) {
      free(v31);
    }
    return 1LL;
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_10184D970);
  }
  unint64_t v23 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v24 = *(void *)(a2 + 16);
    uint64_t v25 = *(void *)(a2 + 24);
    uint64_t v26 = *(void *)(a2 + 32);
    *(_DWORD *)uint64_t buf = 134218496;
    *(void *)&uint8_t buf[4] = v24;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v25;
    *(_WORD *)&_BYTE buf[22] = 1024;
    *(_DWORD *)&buf[24] = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "CLCyclingFTPBoutStatsGenerator Ignoring empty session from, %f, to %f, workout_type, %d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_10184D970);
    }
    uint64_t v27 = *(void *)(a2 + 16);
    uint64_t v28 = *(void *)(a2 + 24);
    uint64_t v29 = *(void *)(a2 + 32);
    __src[0] = 134218496;
    *(void *)&__src[1] = v27;
    LOWORD(__src[3]) = 2048;
    *(void *)((char *)&__src[3] + 2) = v28;
    HIWORD(__src[5]) = 1024;
    __src[6] = v29;
    LODWORD(v83) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "CLCyclingFTPBoutStatsGenerator Ignoring empty session from, %f, to %f, workout_type, %d",  COERCE_DOUBLE(__src),  v83,  LODWORD(v84[0]));
    __int128 v31 = (char *)v30;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCyclingFTPBoutStatsGenerator::processSession(const CLCyclingFTPHistory::Session &)",  "%s\n",  v30);
    goto LABEL_73;
  }

  return 1LL;
}

void sub_100748B0C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 56) = 0LL;
  *(_DWORD *)(a3 + 64) = 0;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a3 + sub_100708348(v2 - 16) = 0LL;
  *(_DWORD *)(a3 + sub_10000AE14(v9 + 24) = 0;
  *(void *)(a3 + 32) = 0LL;
  *(void *)(a3 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a3 + 4_Block_object_dispose(va, 8) = 0;
  *(void *)(a3 + 152) = 0LL;
  *(_DWORD *)(a3 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(void *)(a3 + 104) = 0LL;
  *(void *)(a3 + sub_10000AE14(v2 - 112) = 0LL;
  *(_DWORD *)(a3 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(void *)(a3 + 12_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a3 + 136) = 0LL;
  *(_DWORD *)(a3 + 144) = 0;
  *(void *)(a3 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a3 + 176) = 0LL;
  *(void *)(a3 + 184) = 0LL;
  double v5 = *(double *)(a2 + 16);
  double v6 = *(double *)(a2 + 24) - v5;
  *(void *)(a3 + 72) = 0LL;
  *(void *)(a3 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a3 + 96) = 0;
  *(void *)(a3 + 8_Block_object_dispose(va, 8) = 0LL;
  if (v6 >= a4)
  {
    int v39 = 0;
    double v46 = 0.0;
    int v47 = 0;
    double v41 = 0.0;
    int v42 = 0;
    double v43 = 0.0;
    double v44 = 0.0;
    int v45 = 0;
    double v49 = 0.0;
    uint64_t v50 = 0LL;
    double v48 = 0.0;
    double v40 = a4;
    unint64_t v8 = *(uint64_t **)(a2 + 48);
    uint64_t v10 = *v8;
    uint64_t v9 = v8[1];
    uint64_t v11 = v9 - *v8;
    if (v9 != *v8)
    {
      int v12 = 0;
      int v13 = 0;
      uint64_t v14 = 0LL;
      int v15 = 0;
      int v16 = 0;
      int v17 = 0;
      int v18 = 0;
      double v19 = 0.0;
      double v20 = 0.0;
      unint64_t v21 = v11 >> 6;
      double v22 = 0.0;
      double v23 = 0.0;
      do
      {
        uint64_t v24 = v10 + (v14 << 6);
        uint64_t v25 = v10 + ((uint64_t)v16 << 6);
        double v26 = *(double *)(v25 + 8);
        if (*(double *)(v24 + 8) - v26 <= a4)
        {
          float v33 = *(float *)(v24 + 16);
          float v34 = *(float *)(v24 + 20);
          float v35 = *(float *)(v24 + 28);
          float v36 = *(float *)(v24 + 32);
          int v39 = ++v17;
          if (v36 >= 0.0 && v36 <= 1500.0)
          {
            double v20 = v20 + v36;
            double v41 = v20;
            int v42 = ++v13;
          }

          double v37 = v34;
          if (v37 > 0.39)
          {
            double v22 = v22 + v33;
            double v19 = v19 + v37;
            double v43 = v22;
            double v44 = v19;
            int v45 = ++v12;
          }

          if (v35 > 0.0)
          {
            double v23 = v23 + v35;
            double v46 = v23;
            int v47 = ++v18;
          }
        }

        else
        {
          uint64_t v27 = v15 - 1LL;
          double v48 = v26 - v5;
          double v49 = v26;
          uint64_t v50 = *(void *)(v10 + (v27 << 6) + 8);
          sub_100748DB4(a1, (uint64_t)&v39, a3);
          float v28 = *(float *)(v25 + 16);
          float v29 = *(float *)(v25 + 20);
          float v30 = *(float *)(v25 + 28);
          float v31 = *(float *)(v25 + 32);
          int v39 = --v17;
          if (v31 >= 0.0 && v31 <= 1500.0)
          {
            double v20 = v20 - v31;
            double v41 = v20;
            int v42 = --v13;
          }

          double v32 = v29;
          if (v32 > 0.39)
          {
            double v22 = v22 - v28;
            double v19 = v19 - v32;
            double v43 = v22;
            double v44 = v19;
            int v45 = --v12;
          }

          if (v30 > 0.0)
          {
            double v23 = v23 - v30;
            double v46 = v23;
            int v47 = --v18;
          }

          ++v16;
          int v15 = v27;
        }

        int v38 = v15 + 1;
        if (v21 <= v15 + 1) {
          break;
        }
        uint64_t v14 = v38;
        ++v15;
      }

      while (v38 >= v16);
    }

    sub_100748DB4(a1, (uint64_t)&v39, a3);
  }

void *sub_100748DA8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_100748EA4(a2, a1 + 16);
}

__n128 sub_100748DB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result.n128_u64[0] = 0x40047AE147AE147BLL;
  int v4 = (int)(*(double *)(a2 + 8) / 2.56);
  if (*(_DWORD *)a2 > v4) {
    int v4 = *(_DWORD *)a2;
  }
  double v5 = (double)v4;
  if ((double)v4 * 0.75 <= (double)*(int *)(a2 + 24))
  {
    if (*(double *)(a2 + 16) > *(double *)(a3 + 16))
    {
      __int128 v6 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a2;
      *(_OWORD *)(a3 + sub_100708348(v2 - 16) = v6;
      __int128 v7 = *(_OWORD *)(a2 + 32);
      __int128 v8 = *(_OWORD *)(a2 + 48);
      __int128 v9 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a3 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
      *(_OWORD *)(a3 + 32) = v7;
      *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = v8;
      int v10 = *(_DWORD *)a2;
      double v5 = (double)v10;
    }

    result.n128_f64[0] = (double)*(int *)(a2 + 48);
    if (v5 * 0.5 <= result.n128_f64[0])
    {
      result.n128_u64[0] = *(void *)(a2 + 16);
      if (result.n128_f64[0] > *(double *)(a3 + 112))
      {
        __int128 v11 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)(a3 + 96) = *(_OWORD *)a2;
        *(_OWORD *)(a3 + sub_10000AE14(v2 - 112) = v11;
        __n128 result = *(__n128 *)(a2 + 32);
        __int128 v12 = *(_OWORD *)(a2 + 48);
        __int128 v13 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a3 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a3 + 176) = v13;
        *(__n128 *)(a3 + 12_Block_object_dispose(va, 8) = result;
        *(_OWORD *)(a3 + 144) = v12;
      }
    }
  }

  return result;
}

void sub_100748E78(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

void *sub_100748EA4(void *a1, uint64_t a2)
{
  int v4 = (void *)sub_100748FA0((uint64_t)a1, a2);
  v4[5] = 0LL;
  v4[6] = 0LL;
  v4[7] = 0LL;
  sub_100749014( v4 + 5,  *(const void **)(a2 + 40),  *(void *)(a2 + 48),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 6));
  a1[8] = 0LL;
  a1[9] = 0LL;
  a1[10] = 0LL;
  sub_100749014( a1 + 8,  *(const void **)(a2 + 64),  *(void *)(a2 + 72),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 6));
  a1[11] = 0LL;
  a1[12] = 0LL;
  a1[13] = 0LL;
  sub_1006099EC( a1 + 11,  *(const void **)(a2 + 88),  *(void *)(a2 + 96),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3));
  return a1;
}

void sub_100748F5C(_Unwind_Exception *a1)
{
  double v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 72) = v5;
    operator delete(v5);
  }

  __int128 v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 4_Block_object_dispose(va, 8) = v6;
    operator delete(v6);
  }

  sub_100019CEC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100748FA0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  return a1;
}

void sub_100748FFC(_Unwind_Exception *a1)
{
}

void *sub_100749014(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    __int128 v6 = result;
    __n128 result = sub_10074908C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100749070(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10074908C(void *a1, unint64_t a2)
{
  if (a2 >= 0x30C30C30C30C31LL) {
    sub_100007008();
  }
  __n128 result = (char *)sub_1007490E0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[1344 * v4];
  return result;
}

void *sub_1007490E0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x30C30C30C30C31LL) {
    sub_1000070D4();
  }
  return operator new(1344 * a2);
}

char *sub_100749128(char *result, size_t a2, unint64_t a3, uint64_t (*a4)(char *, char *))
{
  if (a3)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0LL;
    __int128 v9 = &result[a2];
    uint64_t v10 = 1LL;
    do
    {
      int v17 = &v15;
      __n128 result = (char *)__chkstk_darwin();
      int v15 = (char *)&v15 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v11 = v8;
      __int128 v12 = v9;
      uint64_t v13 = v10;
      uint64_t v16 = v8 + 1;
      if (v8 + 1 < a3)
      {
        do
        {
          __n128 result = (char *)a4(&v7[v11 * a2], v12);
          if ((_DWORD)result) {
            int v11 = v13;
          }
          ++v13;
          v12 += a2;
        }

        while (a3 != v13);
      }

      if (v8 != v11)
      {
        uint64_t v14 = v15;
        memcpy(v15, &v7[v11 * a2], a2);
        memcpy(&v7[v11 * a2], &v7[v8 * a2], a2);
        __n128 result = (char *)memcpy(&v7[v8 * a2], v14, a2);
      }

      ++v10;
      v9 += a2;
      uint64_t v8 = v16;
    }

    while (v16 != a3);
  }

  return result;
}

void sub_100749290()
{
  if (sub_10071C4D0())
  {
    float v0 = operator new(0x128uLL);
    sub_10071C40C((uint64_t)v0);
  }

  else
  {
    float v0 = operator new(0xD0uLL);
    sub_100514DA4((uint64_t)v0);
  }

  qword_1019A15D8 = (uint64_t)v0;
}

void sub_1007492E4(_Unwind_Exception *a1)
{
}

uint64_t sub_1007492FC()
{
  if (qword_101998430 != -1) {
    dispatch_once(&qword_101998430, &stru_10184D998);
  }
  return qword_1019A15D8;
}

uint64_t sub_100749340(uint64_t a1)
{
  uint64_t v2 = sub_1006DC9EC(a1, (uint64_t)"CLCompass", 2);
  *(void *)uint64_t v2 = off_10184D9C8;
  *(_WORD *)(v2 + 2_Block_object_dispose(va, 8) = 0;
  *(void *)(v2 + 32) = 0x3F847AE140000000LL;
  *(void *)(v2 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_BYTE *)(v2 + 4_Block_object_dispose(va, 8) = 0;
  *(void *)(v2 + 56) = 0LL;
  *(_BYTE *)(v2 + 64) = 0;
  *(void *)(v2 + 72) = 0LL;
  LOBYTE(buf[0]) = 0;
  sub_1012049AC((unsigned __int8 *)(v2 + 80), "ForceResetCompassOnChargingEvent", (unsigned __int8 *)buf, 0);
  LOBYTE(buf[0]) = 0;
  sub_1012049AC((unsigned __int8 *)(a1 + 83), "CompassForceCoverAttach", (unsigned __int8 *)buf, 0);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_WORD *)(a1 + 12_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(_BYTE *)(a1 + 104) = 0;
  uint64_t v3 = sub_1006E27E8();
  sub_100413284(v3, buf);
  char v4 = sub_1002A6F64(*(uint64_t *)&buf[0], "LogCompass", (BOOL *)(a1 + 29));
  char v5 = v4;
  __int128 v6 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_5;
  }
  uint64_t v7 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (v8)
  {
LABEL_5:
    if ((v4 & 1) != 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if ((v5 & 1) == 0) {
LABEL_6:
  }
    *(_BYTE *)(a1 + 29) = 0;
LABEL_7:
  if (sub_1004FAA50())
  {
    sub_1004F2598();
    if (sub_1004FBF20())
    {
      __int128 v9 = operator new(0x20uLL);
      *__int128 v9 = off_1018A2210;
      *__int128 v9 = &off_1018A42E0;
      v9[1] = 0LL;
      v9[2] = sub_100749DB0;
      void v9[3] = a1;
      *(void *)(a1 + 96) = v9;
      uint64_t v10 = sub_10099F510();
      sub_1006DCB40(v10, 0, *(void *)(a1 + 96), -1.0);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      int v11 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Registered for keyboard state notifications",  (uint8_t *)buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DAB0);
        }
        LOWORD(v42) = 0;
        float v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Registered for keyboard state notifications",  &v42,  2);
        sub_10029211C("Generic", 1LL, 0, 2LL, "CLCompass::CLCompass()", "%s\n", v36);
      }
    }

    sub_1004F2598();
    if ((sub_1004FC190() & 1) != 0 || *(_BYTE *)(a1 + 81))
    {
      __int128 v12 = (void *)sub_1006E2838();
      sub_1003CC884((uint64_t)sub_100749DC0, a1, v12, buf);
      uint64_t v13 = *(void *)&buf[0];
      *(void *)&buf[0] = 0LL;
      uint64_t v14 = *(void *)(a1 + 120);
      *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v13;
      if (v14)
      {
        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
        uint64_t v15 = *(void *)&buf[0];
        *(void *)&buf[0] = 0LL;
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
        }
      }

      [*(id *)(*(void *)(a1 + 120) + 16) register:*(void *)(*(void *)(a1 + 120) + 8) forNotification:7 registrationInfo:0];
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      uint64_t v16 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Registered for charging events.",  (uint8_t *)buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DAB0);
        }
        LOWORD(v42) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        float v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Registered for charging events.",  &v42,  v38);
        sub_10029211C("Generic", 1LL, 0, 2LL, "CLCompass::CLCompass()", "%s\n", v35);
      }
    }

    if (sub_1004FC6FC())
    {
      LOBYTE(v42) = 0;
      sub_1012049AC((unsigned __int8 *)buf, off_101936DD0[0], (unsigned __int8 *)&v42, 0);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100749DC8;
      block[3] = &unk_10184DA18;
      __int16 v40 = buf[0];
      char v41 = BYTE2(buf[0]);
      dispatch_async(global_queue, block);
    }

    sub_1004F2598();
    if (sub_1004FC2B8())
    {
      int v18 = operator new(0x20uLL);
      void *v18 = off_1018A2210;
      void *v18 = &off_10184DAF8;
      v18[1] = 0LL;
      v18[2] = sub_100749DFC;
      void v18[3] = a1;
      *(void *)(a1 + sub_10000AE14(v2 - 112) = v18;
      uint64_t v19 = sub_1006A64D8();
      sub_1006DCB40(v19, 4, *(void *)(a1 + 112), -1.0);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      double v20 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "Registered for keyboard attach and hall effect events.",  (uint8_t *)buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DAB0);
        }
        LOWORD(v42) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        double v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Registered for keyboard attach and hall effect events.",  &v42,  v38);
        sub_10029211C("Generic", 1LL, 0, 2LL, "CLCompass::CLCompass()", "%s\n", v37);
      }
    }
  }

  uint64_t v21 = sub_100A874F4();
  *(double *)(a1 + 72) = (*(double (**)(uint64_t))(*(void *)v21 + 56LL))(v21);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DAB0);
  }
  double v22 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v23 = *(void *)(a1 + 72);
    LODWORD(buf[0]) = 134217984;
    *(void *)((char *)buf + 4) = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "Retrieved cached cover state timestamp,%f",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    uint64_t v32 = *(void *)(a1 + 72);
    int v42 = 134217984;
    uint64_t v43 = v32;
    float v33 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Retrieved cached cover state timestamp,%f",  COERCE_DOUBLE(&v42));
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLCompass::CLCompass()", "%s\n", v33);
  }

  uint64_t v24 = operator new(0x20uLL);
  *uint64_t v24 = off_1018A2210;
  *uint64_t v24 = &off_1018A42E0;
  v24[1] = 0LL;
  _OWORD v24[2] = sub_100749FCC;
  v24[3] = a1;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v24;
  uint64_t v25 = sub_100A874F4();
  sub_1006DCB40(v25, 0, *(void *)(a1 + 88), -1.0);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DAB0);
  }
  double v26 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "Registered for cover state notifications",  (uint8_t *)buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    LOWORD(v42) = 0;
    LODWORD(v3_Block_object_dispose(va, 8) = 2;
    float v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Registered for cover state notifications",  &v42,  v38);
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLCompass::CLCompass()", "%s\n", v34);
  }

  uint64_t v27 = (void *)sub_1006E2838();
  sub_100A15BEC((uint64_t)sub_10074A274, a1, v27, buf);
  uint64_t v28 = *(void *)&buf[0];
  *(void *)&buf[0] = 0LL;
  uint64_t v29 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v28;
  if (v29)
  {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
    uint64_t v30 = *(void *)&buf[0];
    *(void *)&buf[0] = 0LL;
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
    }
  }

  return a1;
}

void sub_100749D0C(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[15];
  v1[15] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = v1[5];
  v1[5] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1006DCAA8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100749DB0(unsigned __int8 *a1, uint64_t a2)
{
  return sub_10074ABE8(a2, *a1);
}

uint64_t sub_100749DC0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_10074AE84(a4, a2, a3);
}

uint64_t sub_100749DC8(uint64_t a1)
{
  uint64_t v2 = sub_1008FA854(0);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 160LL))( v2,  *(unsigned __int8 *)(a1 + 32),  *(unsigned __int8 *)(a1 + 33));
}

void sub_100749DFC(char *a1)
{
  if (*a1 - 2 <= 2)
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    uint64_t v2 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      char v3 = *a1;
      *(_DWORD *)uint64_t buf = 16777472;
      char v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Resetting compass on hall effect event %hhu",  buf,  5u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      char v5 = *a1;
      int v7 = 16777472;
      char v8 = v5;
      __int128 v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Resetting compass on hall effect event %hhu",  &v7);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLCompass::onKeyboardHallEffect(const CLKeyboardMotionNotifier::HallEffectData *, void *)",  "%s\n",  v6);
    }

    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    dispatch_async(global_queue, &stru_10184DA58);
  }

void sub_100749FCC(_BYTE *a1, uint64_t a2)
{
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DAB0);
  }
  uint64_t v4 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    if (*a1) {
      char v5 = "open";
    }
    else {
      char v5 = "closed";
    }
    *(_DWORD *)uint64_t buf = 136315138;
    uint64_t v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Cover %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    if (*a1) {
      char v10 = "open";
    }
    else {
      char v10 = "closed";
    }
    int v13 = 136315138;
    uint64_t v14 = v10;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Cover %s",  (const char *)&v13);
    sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLCompass::onCoverState(const BOOL *, void *)", "%s\n", v11);
  }

  if (*a1)
  {
    if (*(_BYTE *)(a2 + 104))
    {
      uint64_t v6 = sub_1008FA854(0);
      (*(void (**)(uint64_t))(*(void *)(v6 + 80) + 16LL))(v6 + 80);
    }

    if (*(void *)(a2 + 56))
    {
      if (*(_BYTE *)(a2 + 48))
      {
        *(_BYTE *)(a2 + 2_Block_object_dispose(va, 8) = 0;
        (*(void (**)(uint64_t))(*(void *)a2 + 56LL))(a2);
        [*(id *)(*(void *)(a2 + 40) + 16) unregister:*(void *)(*(void *)(a2 + 40) + 8) forNotification:0];
        *(_BYTE *)(a2 + 64) = 1;
        int v7 = *(__CFRunLoopTimer **)(a2 + 56);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFRunLoopTimerSetNextFireDate(v7, Current + 3.0);
      }
    }

    *(CFAbsoluteTime *)(a2 + 72) = CFAbsoluteTimeGetCurrent();
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10074ABB8;
    block[3] = &unk_10181D3D0;
    void block[4] = a2;
    dispatch_async(global_queue, block);
  }

void sub_10074A274(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
}

void *sub_10074A2B0(uint64_t a1)
{
  *(void *)a1 = off_10184D9C8;
  if (*(void *)(a1 + 88))
  {
    CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 56));
    *(void *)(a1 + 56) = 0LL;
    uint64_t v2 = sub_100A874F4();
    sub_1006DD2A0(v2, 0, *(void *)(a1 + 88));
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  }

  if (*(void *)(a1 + 96))
  {
    uint64_t v4 = sub_10099F510();
    sub_1006DD2A0(v4, 0, *(void *)(a1 + 96));
    uint64_t v5 = *(void *)(a1 + 96);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    *(void *)(a1 + 96) = 0LL;
  }

  if (*(void *)(a1 + 112))
  {
    uint64_t v6 = sub_1006A64D8();
    sub_1006DD2A0(v6, 4, *(void *)(a1 + 112));
    uint64_t v7 = *(void *)(a1 + 112);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    *(void *)(a1 + sub_10000AE14(v2 - 112) = 0LL;
  }

  uint64_t v8 = *(void *)(a1 + 120);
  *(void *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  return sub_1006DCAA8((void *)a1);
}

void sub_10074A3B8(uint64_t a1)
{
  uint64_t v1 = sub_10074A2B0(a1);
  operator delete(v1);
}

double sub_10074A3CC(uint64_t a1, int a2, double *a3)
{
  double result = 0.0;
  if (!a2)
  {
    double v5 = *a3;
    if (*a3 <= 0.0)
    {
      *(_BYTE *)(a1 + 2_Block_object_dispose(va, 8) = 0;
      (*(void (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, v5);
      [*(id *)(*(void *)(a1 + 40) + 16) unregister:*(void *)(*(void *)(a1 + 40) + 8) forNotification:0];
      *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = 0;
    }

    else
    {
      sub_100A874F4();
      if (sub_100231608() && !*(void *)(a1 + 88))
      {
        context.version = 0LL;
        context.info = (void *)a1;
        memset(&context.retain, 0, 24);
        CFRunLoopTimerRef v6 = CFRunLoopTimerCreate( kCFAllocatorDefault,  1.79769313e308,  1.79769313e308,  0LL,  0LL,  (CFRunLoopTimerCallBack)sub_10074A644,  &context);
        *(void *)(a1 + 56) = v6;
        if (v6)
        {
          sub_1006E27E8();
          uint64_t v7 = (__CFRunLoop *)sub_1006E2AB4();
          CFRunLoopAddTimer(v7, *(CFRunLoopTimerRef *)(a1 + 56), kCFRunLoopCommonModes);
        }

        else
        {
          if (qword_101934580 != -1) {
            dispatch_once(&qword_101934580, &stru_10184DAB0);
          }
          uint64_t v8 = (os_log_s *)qword_101934588;
          if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Could not create timer", buf, 2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934580 != -1) {
              dispatch_once(&qword_101934580, &stru_10184DAB0);
            }
            __int16 v12 = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Could not create timer",  &v12,  2);
            int v11 = (uint8_t *)v10;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLCompass::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v10);
            if (v11 != buf) {
              free(v11);
            }
          }
        }

        uint64_t v9 = sub_100A874F4();
        *(double *)(a1 + 72) = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
      }

      *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = 1;
      if (!*(_BYTE *)(a1 + 64)) {
        sub_10074A674(a1);
      }
    }

    return *(double *)(a1 + 32);
  }

  return result;
}

uint64_t sub_10074A644(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 48)) {
    uint64_t result = sub_10074A674(a2);
  }
  *(_BYTE *)(a2 + 64) = 0;
  return result;
}

uint64_t sub_10074A674(uint64_t a1)
{
  BOOL v2 = sub_10074A86C(a1);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DAB0);
  }
  uint64_t v3 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *(unsigned __int8 *)(a1 + 83);
    *(_DWORD *)uint64_t buf = 67109376;
    BOOL v13 = v2;
    __int16 v14 = 1024;
    int v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Cover attached,%d,forced,%d", buf, 0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    int v6 = *(unsigned __int8 *)(a1 + 83);
    v9[0] = 67109376;
    v9[1] = v2;
    __int16 v10 = 1024;
    int v11 = v6;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Cover attached,%d,forced,%d",  v9,  14);
    uint64_t v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompass::startCompass()", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  [*(id *)(*(void *)(a1 + 40) + 16) register:*(void *)(*(void *)(a1 + 40) + 8) forNotification:0 registrationInfo:0];
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 48LL))(a1, v2);
}

BOOL sub_10074A86C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 83)) {
    return *(_BYTE *)(a1 + 84) != 0;
  }
  return CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 72) < 432000.0;
}

uint64_t sub_10074A8D0(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 104);
  sub_10099F510();
  int v3 = sub_1009A042C();
  if (*(_BYTE *)(a1 + 104))
  {
    if (v3 != 1104)
    {
      int v4 = IOServiceMatching("AppleOrionManager");
      io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
      if (MatchingService)
      {
        io_object_t v6 = MatchingService;
        BOOL v7 = sub_100E46198(buf, MatchingService, @"IOAccessoryDigitalID", (void **)6);
        if ((v14 & 1) != 0) {
          unsigned int v8 = 2;
        }
        else {
          unsigned int v8 = v2;
        }
        if (v7) {
          uint64_t v2 = v8;
        }
        else {
          uint64_t v2 = v2;
        }
        IOObjectRelease(v6);
      }
    }
  }

  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DAB0);
  }
  uint64_t v9 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109120;
    int v14 = v2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Keyboard coexSource,%d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    v12[0] = 67109120;
    v12[1] = v2;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Keyboard coexSource,%d",  v12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCompass_Type::CompassCoexSource CLCompass::checkForCompassCoexSource()",  "%s\n",  v11);
  }

  return v2;
}

void sub_10074AAFC(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  __int128 v4 = a4[1];
  __int128 v13 = *a4;
  __int128 v14 = v4;
  __int128 v5 = a4[3];
  __int128 v15 = a4[2];
  __int128 v16 = v5;
  if (!*a3)
  {
    uint64_t v7 = sub_1006E27E8();
    v8[1] = 3221225472LL;
    __int128 v9 = v13;
    __int128 v10 = v14;
    __int128 v11 = v15;
    v8[0] = _NSConcreteStackBlock;
    _DWORD v8[2] = sub_10074AB8C;
    unsigned __int8 v8[3] = &unk_10184DA38;
    _DWORD v8[4] = a1;
    __int128 v12 = v16;
    sub_1006E28B8(v7, (uint64_t)v8);
  }

uint64_t sub_10074AB8C(uint64_t a1)
{
  uint64_t v2 = *(_BYTE **)(a1 + 32);
  return (*(uint64_t (**)(_BYTE *, uint64_t))(*(void *)v2 + 72LL))(v2, a1 + 40);
}

uint64_t sub_10074ABB8(uint64_t a1)
{
  uint64_t v2 = sub_100A874F4();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 48LL))(v2, *(void *)(a1 + 32) + 72LL);
}

uint64_t sub_10074ABE8(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 104) != a2)
  {
    uint64_t v3 = result;
    *(_BYTE *)(result + 104) = a2;
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DAB0);
    }
    __int128 v4 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
    {
      __int128 v5 = "disconnected";
      if (a2) {
        __int128 v5 = "connected";
      }
      *(_DWORD *)uint64_t buf = 136315138;
      __int128 v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Keyboard %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      uint64_t v7 = "disconnected";
      if (a2) {
        uint64_t v7 = "connected";
      }
      int v9 = 136315138;
      __int128 v10 = v7;
      unsigned int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Keyboard %s",  (const char *)&v9);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompass::updateKeyboardState(BOOL)", "%s\n", v8);
    }

    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    dispatch_async(global_queue, &stru_10184DA78);
    uint64_t result = sub_10074A8D0(v3);
    *(_BYTE *)(v3 + 129) = (_DWORD)result == 2;
  }

  return result;
}

void sub_10074AE00(id a1)
{
  uint64_t v1 = sub_1008FA854(0);
  (*(void (**)(uint64_t))(*(void *)(v1 + 80) + 16LL))(v1 + 80);
}

uint64_t sub_10074AE20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 64LL))(a3, a1, a2);
}

void sub_10074AE3C(id a1)
{
  uint64_t v1 = sub_1008FA854(0);
  (*(void (**)(uint64_t))(*(void *)(v1 + 80) + 16LL))(v1 + 80);
}

uint64_t sub_10074AE5C()
{
  uint64_t v0 = sub_10099F510();
  int v1 = sub_1009A03D4(v0);
  if (v1 == 2) {
    return 2LL;
  }
  else {
    return v1 == 1;
  }
}

uint64_t sub_10074AE84(uint64_t result, _DWORD *a2, uint64_t a3)
{
  if (*a2 == 7)
  {
    uint64_t v3 = result;
    int v4 = *(unsigned __int8 *)(a3 + 9);
    if (v4 != *(unsigned __int8 *)(result + 128))
    {
      if ((sub_1004FAA50() & 1) == 0) {
        sub_101249A50(qword_101934580 == -1);
      }
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DAB0);
      }
      __int128 v5 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 67109120;
        int v10 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Resetting compass on charging event,charging,%d",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DAB0);
        }
        v8[0] = 67109120;
        v8[1] = v4;
        uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Resetting compass on charging event,charging,%d",  v8);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCompass::onDaemonStatus(const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)",  "%s\n",  v7);
      }

      uint64_t v6 = sub_1008FA854(0);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(v6 + 80) + 16LL))(v6 + 80);
      *(_BYTE *)(v3 + 12_Block_object_dispose(va, 8) = v4;
    }
  }

  return result;
}

void sub_10074B070(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

uint64_t sub_10074B09C(uint64_t a1, void *a2, char a3)
{
  *(void *)a1 = *a2;
  float v5 = 1.0 / *(double *)a2;
  *(float *)(a1 + _Block_object_dispose(va, 8) = v5;
  uint64_t v6 = a1 + 8;
  *(_BYTE *)(a1 + 12) = 0;
  uint64_t v7 = (BOOL *)(a1 + 12);
  *(_BYTE *)(a1 + 13) = a3;
  *(void *)(a1 + 14) = 0LL;
  unsigned int v8 = (BOOL *)(a1 + 14);
  *(void *)(a1 + 3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(a1 + 22) = 0LL;
  *(_WORD *)(a1 + 3_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0x3FF0000000000000LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = &off_10184D7B0;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &off_10184D7B0;
  *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0LL;
  sub_100787F94(a1 + 112, 10LL, 30LL, 61.056, 2.0);
  *(void *)(v6 + 36_Block_object_dispose(va, 8) = 0xF00000000LL;
  *(_DWORD *)(v6 + 376) = 15;
  float v9 = *(float *)v6;
  double v10 = *(float *)v6;
  unint64_t v11 = vcvtad_u64_f64(v10 * 0.125);
  *(void *)(v6 + 384) = off_10184DB68;
  *(void *)(v6 + 392) = v11;
  *(void *)(v6 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = off_10184DB98;
  *(void *)(v6 + 40_Block_object_dispose(va, 8) = v11;
  *(_OWORD *)(v6 + 4sub_100708348(v2 - 16) = 0u;
  *(_OWORD *)(v6 + 432) = 0u;
  *(_OWORD *)(v6 + 44_Block_object_dispose(va, 8) = 0u;
  *(void *)(v6 + 464) = 0LL;
  *(void *)(v6 + 472) = off_10184DB98;
  *(void *)(v6 + 48sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v11;
  *(_OWORD *)(v6 + 48_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 504) = 0u;
  *(_OWORD *)(v6 + 52sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(v6 + 536) = 0LL;
  *(void *)(v6 + 544) = off_10184DB98;
  *(void *)(v6 + 552) = v11;
  BOOL v122 = (int *)(v6 + 616);
  *(void *)(v6 + 62sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0xBF8000003F000000LL;
  __int128 v12 = (float *)(v6 + 620);
  *(_OWORD *)(v6 + 604) = 0u;
  *(_OWORD *)(v6 + 576) = 0u;
  *(_OWORD *)(v6 + 592) = 0u;
  *(_OWORD *)(v6 + 56sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_DWORD *)(v6 + 62_Block_object_dispose(va, 8) = -1082130432;
  *(void *)(v6 + 632) = off_10183B0F0;
  *(_DWORD *)(v6 + 64sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(_OWORD *)(v6 + 64_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 664) = 0u;
  *(_OWORD *)(v6 + 68sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(v6 + 704) = 0LL;
  *(void *)(v6 + 712) = 0LL;
  *(void *)(v6 + 696) = v6 + 704;
  *(void *)(v6 + 72sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = off_10183B0F0;
  *(_DWORD *)(v6 + 72_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(v6 + 752) = 0u;
  *(_OWORD *)(v6 + 76_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 736) = 0u;
  *(void *)(v6 + 80sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(v6 + 792) = 0LL;
  *(void *)(v6 + 784) = v6 + 792;
  unint64_t v13 = vcvtad_u64_f64(v10 * 0.05);
  *(void *)(v6 + 80_Block_object_dispose(va, 8) = off_10184DB68;
  *(void *)(v6 + 8sub_100708348(v2 - 16) = v13;
  *(void *)(v6 + 8sub_10000AE14(v9 + 24) = off_10184DB98;
  *(void *)(v6 + 832) = v13;
  *(_OWORD *)(v6 + 84sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v6 + 856) = 0u;
  *(_OWORD *)(v6 + 872) = 0u;
  *(void *)(v6 + 88_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v6 + 896) = off_10184DB98;
  *(void *)(v6 + 904) = v13;
  *(_OWORD *)(v6 + 912) = 0u;
  *(_OWORD *)(v6 + 92_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 944) = 0u;
  *(void *)(v6 + 96sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(void *)(v6 + 96_Block_object_dispose(va, 8) = off_10184DB98;
  *(void *)(v6 + 976) = v13;
  *(void *)(v6 + 1032) = 0LL;
  *(_OWORD *)(v6 + 10sub_100708348(v2 - 16) = 0u;
  *(_OWORD *)(v6 + 100sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v6 + 984) = 0u;
  *(void *)(v6 + 104sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = off_10184DB68;
  *(void *)(v6 + 104_Block_object_dispose(va, 8) = v13;
  *(void *)(v6 + 1056) = off_10184DB98;
  *(void *)(v6 + 1064) = v13;
  *(void *)(v6 + 112sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_OWORD *)(v6 + 108_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 1072) = 0u;
  *(_OWORD *)(v6 + 1104) = 0u;
  *(void *)(v6 + 112_Block_object_dispose(va, 8) = off_10184DB98;
  *(void *)(v6 + 1136) = v13;
  *(void *)(v6 + 1192) = 0LL;
  *(_OWORD *)(v6 + 1176) = 0u;
  *(_OWORD *)(v6 + 116sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v6 + 1144) = 0u;
  *(void *)(v6 + 120sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = off_10184DB98;
  *(void *)(v6 + 120_Block_object_dispose(va, 8) = v13;
  *(void *)(v6 + 1264) = 0LL;
  *(_OWORD *)(v6 + 124_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 1232) = 0u;
  *(_OWORD *)(v6 + 12sub_100708348(v2 - 16) = 0u;
  *(void *)(v6 + 1272) = &off_10184D7B0;
  *(void *)(v6 + 128sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(v6 + 128_Block_object_dispose(va, 8) = 0;
  *(void *)(v6 + 1296) = &off_10184D7B0;
  *(void *)(v6 + 1304) = 0LL;
  *(_DWORD *)(v6 + 1312) = 0;
  *(void *)(v6 + 132sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = &off_10184D7B0;
  *(void *)(v6 + 132_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v6 + 1336) = 0;
  *(void *)(v6 + 140_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(v6 + 1392) = 0u;
  *(_OWORD *)(v6 + 1376) = 0u;
  *(_OWORD *)(v6 + 1344) = 0u;
  *(_OWORD *)(v6 + 136sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(v6 + 14sub_100708348(v2 - 16) = 0xBFF0000000000000LL;
  unint64_t v14 = vcvtad_u64_f64(v10 * 0.5);
  *(void *)(v6 + 14sub_10000AE14(v9 + 24) = off_10184DB98;
  *(void *)(v6 + 1432) = v14;
  *(void *)(v6 + 148_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(v6 + 1472) = 0u;
  *(_OWORD *)(v6 + 1456) = 0u;
  *(_OWORD *)(v6 + 144sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(v6 + 1496) = off_10184DB98;
  *(void *)(v6 + 1504) = v14;
  *(void *)(v6 + 156sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_OWORD *)(v6 + 1544) = 0u;
  *(_OWORD *)(v6 + 152_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 1512) = 0u;
  *(void *)(v6 + 156_Block_object_dispose(va, 8) = off_10184DB98;
  *(void *)(v6 + 1576) = vcvtas_u32_f32(v9);
  *(void *)(v6 + 1632) = 0LL;
  *(_OWORD *)(v6 + 16sub_100708348(v2 - 16) = 0u;
  *(_OWORD *)(v6 + 160sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_OWORD *)(v6 + 1584) = 0u;
  sub_1007887D0(v6 + 1640);
  sub_1007887D0(a1 + 1976);
  *(_BYTE *)(a1 + 2304) = 0;
  unint64_t v15 = vcvtad_u64_f64(*(float *)(a1 + 8) * 0.2);
  *(void *)(a1 + 2312) = off_10184DB98;
  *(void *)(a1 + 232sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v15;
  *(void *)(a1 + 2376) = 0LL;
  *(_OWORD *)(a1 + 232_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 2344) = 0u;
  *(_OWORD *)(a1 + 236sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(a1 + 2384) = 0x3F800000BF800000LL;
  if (*(_BYTE *)(a1 + 13))
  {
    __int128 v16 = operator new(0x650uLL);
    sub_1007A9720(v16, a2);
    *(void *)(a1 + 104) = v16;
    v16[125] = v6 + 1568;
    *((_BYTE *)v16 + 5_Block_object_dispose(va, 8) = 1;
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DB38);
    }
    int v17 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "using attitude dependent KF calibrator",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DB38);
      }
      *(_WORD *)int v126 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "using attitude dependent KF calibrator",  v126,  2);
      __int16 v113 = (char *)v112;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)",  "%s\n",  v112);
      if (v113 != buf) {
        free(v113);
      }
    }
  }

  uint64_t v18 = sub_1006E27E8();
  sub_100413284(v18, buf);
  char v19 = sub_1002A6F64(*(uint64_t *)buf, "LogCompass", v7);
  char v20 = v19;
  uint64_t v21 = *(std::__shared_weak_count **)&buf[8];
  if (!*(void *)&buf[8]) {
    goto LABEL_11;
  }
  double v22 = (unint64_t *)(*(void *)&buf[8] + 8LL);
  do
    unint64_t v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (v23)
  {
LABEL_11:
    if ((v19 & 1) != 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
  std::__shared_weak_count::__release_weak(v21);
  if ((v20 & 1) == 0) {
LABEL_12:
  }
    *uint64_t v7 = 0;
LABEL_13:
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DB38);
  }
  uint64_t v24 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "compass ignoring database (1)", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DB38);
    }
    *(_WORD *)int v126 = 0;
    LODWORD(v119) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "compass ignoring database (1)",  v126,  *(void *)&v119);
    __int128 v97 = (char *)v96;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)",  "%s\n",  v96);
    if (v97 != buf) {
      free(v97);
    }
  }

  uint64_t v25 = sub_1006E27E8();
  sub_100413284(v25, buf);
  if (!sub_1002A6F64(*(uint64_t *)buf, "CompassManualCalibration", v8))
  {
    int v39 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      __int16 v40 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }

    goto LABEL_40;
  }

  BOOL v26 = *v8;
  uint64_t v27 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v28 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
      if (v26) {
        goto LABEL_24;
      }
LABEL_40:
      *unsigned int v8 = 0;
      goto LABEL_59;
    }
  }

  if (!v26) {
    goto LABEL_40;
  }
LABEL_24:
  uint64_t v30 = sub_1006E27E8();
  sub_100413284(v30, buf);
  float v31 = (float *)(v6 + 1344);
  uint64_t v32 = (float *)(v6 + 1348);
  __int16 v121 = (float *)(v6 + 1352);
  if (sub_1002A81F8(*(uint64_t *)buf, "CompassOffsetManualX", (float *)(v6 + 1344)))
  {
    uint64_t v33 = sub_1006E27E8();
    sub_100413284(v33, v126);
    if (sub_1002A81F8(*(uint64_t *)v126, "CompassOffsetManualY", (float *)(v6 + 1348)))
    {
      uint64_t v34 = sub_1006E27E8();
      sub_100413284(v34, &v124);
      int v35 = sub_1002A81F8(v124, "CompassOffsetManualZ", v121);
      float v36 = v125;
      if (v125)
      {
        p_shared_owners = (unint64_t *)&v125->__shared_owners_;
        do
          unint64_t v38 = __ldaxr(p_shared_owners);
        while (__stlxr(v38 - 1, p_shared_owners));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
    }

    else
    {
      int v35 = 0;
    }

    int v42 = *(std::__shared_weak_count **)&v126[8];
    if (*(void *)&v126[8])
    {
      uint64_t v43 = (unint64_t *)(*(void *)&v126[8] + 8LL);
      do
        unint64_t v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
  }

  else
  {
    int v35 = 0;
  }

  int v45 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    double v46 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  if (v35)
  {
    *(_DWORD *)(a1 + 1364) = 1;
    *(_DWORD *)(a1 + 384) = 0;
  }

  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_10184DB38);
  }
  double v48 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
  {
    double v49 = *v31;
    double v50 = *v32;
    double v51 = *v121;
    *(_DWORD *)uint64_t buf = 134218496;
    *(double *)&uint8_t buf[4] = v49;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = v50;
    __int16 v130 = 2048;
    double v131 = v51;
    _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEBUG,  "compass using manual bias (%.3f/%.3f/%.3f)",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DB38);
    }
    double v114 = *v31;
    double v115 = *v32;
    double v116 = *v121;
    *(_DWORD *)int v126 = 134218496;
    *(double *)&v126[4] = v114;
    *(_WORD *)&v126[12] = 2048;
    *(double *)&v126[14] = v115;
    __int16 v127 = 2048;
    double v128 = v116;
    LODWORD(v119) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "compass using manual bias (%.3f/%.3f/%.3f)",  COERCE_DOUBLE(v126),  v119,  v120);
    int v118 = (char *)v117;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)",  "%s\n",  v117);
    if (v118 != buf) {
      free(v118);
    }
  }

void sub_10074C340( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  v17[289] = off_10184DB98;
  sub_10046E180(v17 + 292);
  sub_100788898(a16);
  sub_100788898(a17);
  v17[197] = off_10184DB98;
  sub_10046E180(v17 + 200);
  v17[188] = off_10184DB98;
  sub_10046E180(v17 + 191);
  v17[179] = off_10184DB98;
  sub_10046E180(v17 + 182);
  sub_10074DF98((void *)(v18 + 1040));
  sub_10074DF98((void *)(v18 + 808));
  sub_10074DE20(a15);
  sub_10074DF98(a13);
  sub_100787FF4(a14);
  _Unwind_Resume(a1);
}

void *sub_10074C48C(void *a1)
{
  *a1 = off_10184DB98;
  sub_10046E180(a1 + 3);
  return a1;
}

void *sub_10074C4C8(void *a1)
{
  uint64_t v2 = a1[13];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    a1[13] = 0LL;
  }

  a1[289] = off_10184DB98;
  sub_10046E180(a1 + 292);
  sub_100788898(a1 + 247);
  sub_100788898(a1 + 206);
  a1[197] = off_10184DB98;
  sub_10046E180(a1 + 200);
  a1[188] = off_10184DB98;
  sub_10046E180(a1 + 191);
  a1[179] = off_10184DB98;
  sub_10046E180(a1 + 182);
  sub_10074DF98(a1 + 131);
  sub_10074DF98(a1 + 102);
  sub_10074DE20((uint64_t)(a1 + 78));
  sub_10074DF98(a1 + 49);
  sub_100787FF4(a1 + 14);
  return a1;
}

BOOL sub_10074C578(float32x2_t *a1, uint64_t *a2)
{
  __int128 v16 = &off_10184D7B0;
  uint64_t v17 = *a2;
  int v18 = *((_DWORD *)a2 + 2);
  __int32 v3 = a1[48].i32[0];
  if (v3)
  {
    a1[48].i32[0] = v3 - 1;
    if (v3 == 1) {
      a1[47].i32[0] = 0;
    }
  }

  else
  {
    sub_10074DC40((uint64_t)&a1[51], (float *)&v17);
    sub_10074DC40((uint64_t)&a1[60], (float *)&v17 + 1);
    sub_10074DC40((uint64_t)&a1[69], (float *)&v18);
    unint64_t v4 = (unint64_t)a1[59];
    float v5 = 0.0;
    float v6 = 0.0;
    if (v4) {
      float v6 = a1[53].f32[0] / (float)v4;
    }
    unint64_t v7 = (unint64_t)a1[68];
    if (v7) {
      float v5 = a1[62].f32[0] / (float)v7;
    }
    unint64_t v8 = (unint64_t)a1[77];
    if (v8) {
      float v9 = a1[71].f32[0] / (float)v8;
    }
    else {
      float v9 = 0.0;
    }
    a1[161].f32[0] = v6;
    a1[161].f32[1] = v5;
    a1[162].f32[0] = v9;
    a1[164].f32[0] = v6;
    a1[164].f32[1] = v5;
    a1[165].f32[0] = v9;
    a1[167].f32[0] = v6;
    a1[167].f32[1] = v5;
    a1[168].f32[0] = v9;
    float v10 = sub_10074C79C((uint64_t)a1);
    if (a1[1].i8[6])
    {
      float32x2_t v11 = a1[169];
      a1[161] = vsub_f32(a1[161], v11);
      float v12 = a1[170].f32[0];
      a1[162].f32[0] = a1[162].f32[0] - v12;
      a1[164] = vsub_f32(a1[164], v11);
      a1[165].f32[0] = a1[165].f32[0] - v12;
    }

    else
    {
      float32x2_t v13 = a1[13];
      unint64_t v15 = 0xBFF0000000000000LL;
      (*(void (**)(float32x2_t, uint64_t (***)(), float32x2_t *, unint64_t *, float))(**(void **)&v13 + 32LL))( v13,  &v16,  a1 + 2,  &v15,  v10);
      ++a1[47].i32[0];
      (*(void (**)(void, float32x2_t *, uint64_t))(**(void **)&a1[13] + 48LL))( *(void *)&a1[13],  a1 + 169,  (uint64_t)&a1[170] + 4);
      (*(void (**)(void, float32x2_t *, float32x2_t *, float32x2_t *))(**(void **)&a1[13] + 56LL))( *(void *)&a1[13],  a1 + 160,  a1 + 163,  a1 + 2);
      (*(void (**)(void, float32x2_t *, float32x2_t *))(**(void **)&a1[13] + 64LL))( *(void *)&a1[13],  a1 + 166,  a1 + 2);
      sub_10074C85C((uint64_t)a1);
      if ((*(unsigned int (**)(void))(**(void **)&a1[13] + 88LL))(*(void *)&a1[13]))
      {
        sub_100788FA4((uint64_t)&a1[206], 0);
        sub_100788FA4((uint64_t)&a1[247], 0);
      }
    }
  }

  return v3 == 0;
}

float sub_10074C79C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 13))
  {
    float v9 = sqrtf( (float)((float)(*(float *)(a1 + 60) * *(float *)(a1 + 60))
    sub_10074DC40(a1 + 1576, &v9);
    uint64_t v2 = a1 + 2312;
    __int32 v3 = &v9;
  }

  else
  {
    float v8 = sqrtf( (float)((float)(*(float *)(a1 + 84) * *(float *)(a1 + 84))
    sub_10074DC40(a1 + 1432, &v8);
    unint64_t v4 = *(void *)(a1 + 1496);
    if (v4) {
      float v5 = *(float *)(a1 + 1448) / (float)v4;
    }
    else {
      float v5 = 0.0;
    }
    float v7 = (float)(v8 - v5) * (float)(v8 - v5);
    uint64_t v2 = a1 + 1504;
    __int32 v3 = &v7;
  }

  return sub_10074DC40(v2, v3);
}

uint64_t sub_10074C85C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 72LL))(*(void *)(a1 + 104));
  if (!(_DWORD)result) {
    return result;
  }
  if (*(_BYTE *)(a1 + 13) && *(int *)(a1 + 1364) < 4)
  {
    float v3 = sqrtf( (float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))
    if (v3 > 500.0)
    {
LABEL_18:
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DB38);
      }
      float32x2_t v11 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
      {
        double v12 = sqrtf( (float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))
        *(_DWORD *)uint64_t buf = 134217984;
        double v34 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "magnitude max threshold exceeded (%+.3f), resetting calibration",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DB38);
        }
        double v20 = sqrtf( (float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))
        int v27 = 134217984;
        double v28 = v20;
        uint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "magnitude max threshold exceeded (%+.3f), resetting calibration",  COERCE_DOUBLE(&v27));
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompassCalculator::updateInterferenceChecks()", "%s\n", v21);
      }

      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 24LL))(*(void *)(a1 + 104));
      *(_DWORD *)(a1 + 384) = *(_DWORD *)(a1 + 380);
      float v10 = &qword_101329DD0;
LABEL_24:
      float v13 = *(double *)v10;
      *(float *)(a1 + sub_10000AE14(v2 - 112) = v13;
      return result;
    }

    float v5 = (float *)(a1 + 1280);
    goto LABEL_27;
  }

  float v3 = sqrtf( (float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))
  if (v3 >= 250.0 || v3 > 500.0) {
    goto LABEL_18;
  }
  float v5 = (float *)(a1 + 1280);
  if (*(_BYTE *)(a1 + 13))
  {
LABEL_27:
    *(float *)uint64_t buf = v3;
    sub_100788B78(a1 + 1648, (float *)buf);
    uint64_t result = sub_10074DC0C(a1);
    if ((_DWORD)result)
    {
      float v14 = sub_10074E070(v5, (float *)(a1 + 72)) * -57.2957795 + 90.0;
      *(float *)uint64_t buf = v14;
      return sub_100788B78(a1 + 1976, (float *)buf);
    }

    return result;
  }

  *(float *)uint64_t buf = v3;
  if (sub_100788B78(a1 + 1648, (float *)buf))
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_10184DB38);
    }
    float v6 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      double v7 = sub_1007890A0(a1 + 1648);
      double v8 = sub_1007890A8(a1 + 1648);
      float v9 = sub_1007890C8(a1 + 1648);
      *(_DWORD *)uint64_t buf = 134218496;
      double v34 = v7;
      __int16 v35 = 2048;
      double v36 = v8;
      __int16 v37 = 2048;
      double v38 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DB38);
      }
      uint64_t v22 = qword_101934588;
      int v27 = 134218496;
      double v28 = sub_1007890A0(a1 + 1648);
      __int16 v29 = 2048;
      double v30 = sub_1007890A8(a1 + 1648);
      __int16 v31 = 2048;
      double v32 = sub_1007890C8(a1 + 1648);
      LODWORD(v26) = 32;
      unint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  1LL,  "magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration",  COERCE_DOUBLE(&v27),  v26);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompassCalculator::updateInterferenceChecks()", "%s\n", v23);
    }

    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 24LL))(*(void *)(a1 + 104));
    *(_DWORD *)(a1 + 384) = *(_DWORD *)(a1 + 380);
    float v10 = &qword_101329DC0;
    goto LABEL_24;
  }

  uint64_t result = sub_10074DC0C(a1);
  if ((_DWORD)result)
  {
    float v15 = sub_10074E070((float *)(a1 + 1280), (float *)(a1 + 72)) * -57.2957795 + 90.0;
    *(float *)uint64_t buf = v15;
    uint64_t result = sub_100788B78(a1 + 1976, (float *)buf);
    if ((_DWORD)result)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 80LL))(*(void *)(a1 + 104));
      if ((_DWORD)result)
      {
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DB38);
        }
        __int128 v16 = (os_log_s *)qword_101934588;
        if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
        {
          double v17 = sub_1007890A0(a1 + 1976);
          double v18 = sub_1007890A8(a1 + 1976);
          float v19 = sub_1007890C8(a1 + 1976);
          *(_DWORD *)uint64_t buf = 134218496;
          double v34 = v17;
          __int16 v35 = 2048;
          double v36 = v18;
          __int16 v37 = 2048;
          double v38 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration",  buf,  0x20u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934580 != -1) {
            dispatch_once(&qword_101934580, &stru_10184DB38);
          }
          uint64_t v24 = qword_101934588;
          int v27 = 134218496;
          double v28 = sub_1007890A0(a1 + 1976);
          __int16 v29 = 2048;
          double v30 = sub_1007890A8(a1 + 1976);
          __int16 v31 = 2048;
          double v32 = sub_1007890C8(a1 + 1976);
          LODWORD(v26) = 32;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  1LL,  "inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration",  COERCE_DOUBLE(&v27),  v26);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCompassCalculator::updateInterferenceChecks()", "%s\n", v25);
        }

        uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 24LL))(*(void *)(a1 + 104));
        *(_DWORD *)(a1 + 384) = *(_DWORD *)(a1 + 380);
        float v10 = &qword_101329DC8;
        goto LABEL_24;
      }
    }
  }

  return result;
}

float sub_10074CFA4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 4);
  float result = *(float *)(a2 + 8);
  *(float *)(a1 + 8_Block_object_dispose(va, 8) = result;
  return result;
}

float sub_10074CFC0(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)(a1 + sub_100708348(v2 - 16) = *(_OWORD *)(a2 + 1);
  uint64_t v2 = *a2;
  *(void *)(a1 + 32) = a2[3];
  *(void *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v2;
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 11);
  *(_DWORD *)(a1 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *((_DWORD *)a2 + 12);
  float result = *((float *)a2 + 13);
  *(float *)(a1 + 64) = result;
  *(_BYTE *)(a1 + 96) = *((_BYTE *)a2 + 74);
  return result;
}

float sub_10074CFF8(uint64_t a1, double *a2)
{
  uint64_t v2 = (_OWORD *)(a1 + 1368);
  if (a2[7] == -1.0)
  {
    *(void *)(a1 + 14sub_100708348(v2 - 16) = 0LL;
    *(_OWORD *)(a1 + 1384) = 0u;
    *(_OWORD *)(a1 + 140sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
    *uint64_t v2 = 0u;
    *(void *)(a1 + 14sub_10000AE14(v9 + 24) = 0xBFF0000000000000LL;
    *(_BYTE *)(a1 + 1sub_100708348(v2 - 16) = 0;
    return sub_100788354(a1 + 112);
  }

  else
  {
    __int128 v3 = *(_OWORD *)a2;
    __int128 v4 = *((_OWORD *)a2 + 1);
    __int128 v5 = *((_OWORD *)a2 + 3);
    *(_OWORD *)(a1 + 140sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *((_OWORD *)a2 + 2);
    *(_OWORD *)(a1 + 14sub_100708348(v2 - 16) = v5;
    *uint64_t v2 = v3;
    *(_OWORD *)(a1 + 1384) = v4;
    *(_BYTE *)(a1 + 1sub_100708348(v2 - 16) = 1;
    *(float *)&__int128 v3 = a2[6];
    sub_100787FF8(a1 + 112, 10LL, 30LL, *(float *)&v3, 2.0);
  }

  return result;
}

uint64_t sub_10074D06C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 128LL))(*(void *)(a1 + 104));
}

BOOL sub_10074D07C( double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64_t a9, float *a10, float *a11, float *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  float v17 = a10[2];
  float v18 = a10[3];
  float v19 = a10[4];
  float v20 = a11[2];
  float v21 = a11[3];
  float v22 = a11[4];
  uint64_t v27 = 0x3F8000003F800000LL;
  v25.i64[0] = 0LL;
  v25.i64[1] = 0x3F80000000000000LL;
  BOOL v23 = sub_100833764( (float *)&v27,  &v25,  (uint64_t)v26,  v17,  v18,  v19,  v20,  v21,  v22,  a7,  a8,  (uint64_t)a12,  a13,  a14,  a15,  a16,  0x3F800000uLL,  0.0);
  if (v23) {
    *a12 = sub_1008348C4(v25.f32);
  }
  return v23;
}

BOOL sub_10074D120( uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  HIDWORD(v92) = 0;
  double v89 = &off_10184D7B0;
  double v18 = *(double *)(a1 + 1312);
  double v90 = v18;
  LODWORD(v1_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 1320);
  LODWORD(v91) = LODWORD(v18);
  if (*(_BYTE *)(a1 + 13))
  {
    double v18 = *(double *)(a1 + 1336);
    double v90 = v18;
    LODWORD(v1_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 1344);
    LODWORD(v91) = LODWORD(v18);
  }

  BOOL v19 = sub_10074D07C( v18,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a1,  (float *)&v89,  (float *)(a1 + 72),  (float *)&v92 + 1,  a13,  a14,  a15,  a16);
  float v20 = *((float *)&v92 + 1);
  BOOL v21 = *((float *)&v92 + 1) < 360.0 && v19;
  BOOL v22 = *((float *)&v92 + 1) >= 0.0 && v21;
  if (v22)
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 1288);
    *(void *)&__int128 v23 = *(void *)(a1 + 1292);
    *((void *)&v23 + 1) = *(void *)(a1 + 1312);
    *(_OWORD *)(a2 + 4) = v23;
    LODWORD(v23) = *(_DWORD *)(a1 + 1320);
    *(_DWORD *)(a2 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v23;
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 1364);
    *(float *)(a2 + 44) = sqrtf( vmlas_n_f32( COERCE_FLOAT(vmul_f32(*(float32x2_t *)(&v23 + 8), *(float32x2_t *)(&v23 + 8)).i32[1]),  *((float *)&v23 + 2),  *((float *)&v23 + 2))
                          + (float)(*(float *)&v23 * *(float *)&v23));
    *(_BYTE *)(a2 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    double v24 = -57.2957795;
    float v25 = sub_10074E070((float *)(a1 + 1304), (float *)(a1 + 72)) * -57.2957795 + 90.0;
    *(float *)(a2 + 4_Block_object_dispose(va, 8) = v25;
    float v26 = *(float *)(a2 + 44);
    float v27 = v25 * 0.0174532925;
    *(float *)(a2 + 52) = v26 * cosf(v27);
    *(void *)(a2 + 56) = *(void *)(a1 + 40);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 16);
    double v40 = *(double *)(a1 + 32);
    *(double *)(a2 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v40;
    if (*(_BYTE *)(a1 + 13))
    {
      *((float *)&v88 + 1) = v20;
      sub_10074D07C( v40,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v28,  (float *)(a1 + 1280),  (float *)(a1 + 72),  (float *)&v88 + 1,  v29,  v30,  v31,  v32);
      float v41 = *((float *)&v88 + 1);
      if (*(_BYTE *)(a1 + 2304))
      {
        float v42 = *(float *)(a1 + 2384);
      }

      else
      {
        *(_BYTE *)(a1 + 2304) = 1;
        float v42 = v41;
      }

      float v44 = v20;
      if (vabds_f32(v42, v20) > 270.0) {
        float v44 = dbl_101328EA0[(float)(v42 - v20) > 0.0] + v20;
      }
      float v45 = v41;
      if (vabds_f32(v42, v41) > 270.0) {
        float v45 = dbl_101328EA0[(float)(v42 - v41) > 0.0] + v41;
      }
      *(float *)&double v88 = v45;
      unint64_t v46 = *(void *)(a1 + 2376);
      float v47 = 0.0;
      float v48 = 0.0;
      if (v46 >= 2)
      {
        float v49 = (float)((float)v46 * *(float *)(a1 + 2332)) - (float)(*(float *)(a1 + 2328) * *(float *)(a1 + 2328));
        float v48 = v49 / (float)((v46 - 1) * v46);
        if (v49 < 0.0) {
          float v48 = 0.0;
        }
      }

      unint64_t v50 = *(void *)(a1 + 1640);
      if (v50) {
        float v47 = *(float *)(a1 + 1592) / (float)v50;
      }
      *(float *)&double v86 = v42 - v41;
      *((float *)&v86 + 1) = v42 - v20;
      float v51 = (float)(v47 + -0.06) * 0.55 / 2.94000006 + 0.1;
      float v52 = fmaxf(fminf(v51, 0.65), 0.1);
      *((float *)&v85 + 1) = v48;
      double v84 = v47;
      if (v48 >= 0.0015 || v47 >= 6.28318531)
      {
        float v54 = *(float *)(a1 + 2388) * 0.15 + 0.734964973;
        *(float *)(a1 + 238_Block_object_dispose(va, 8) = v54;
      }

      else
      {
        *((float *)&v83 + 1) = v41;
        float v53 = v44;
        float v54 = 1.0 - expf(v47 * -0.2);
        *(float *)(a1 + 238_Block_object_dispose(va, 8) = v54;
        if (v47 <= 1.0)
        {
          float v44 = v53;
          float v41 = *((float *)&v83 + 1);
          if (v47 < 0.06)
          {
            *(_DWORD *)(a1 + 238_Block_object_dispose(va, 8) = 1011052224;
            float v54 = 0.011928;
          }
        }

        else
        {
          float v54 = 1.0 - expf(v47 * (float)(v47 * -0.2));
          *(float *)(a1 + 238_Block_object_dispose(va, 8) = v54;
          float v44 = v53;
          float v41 = *((float *)&v83 + 1);
        }
      }

      float v55 = *(float *)&v88;
      double v56 = v52;
      double v57 = v44;
      float v58 = (float)(*(float *)&v88 * v52) + (1.0 - v52) * v44;
      float v59 = (float)(v54 * v58) + (float)((float)(1.0 - v54) * v42);
      *(float *)(a1 + 2384) = v59;
      float v60 = sub_1007443E0(0, v59);
      *(float *)(a1 + 2384) = v60;
      double v24 = -57.2957795;
      if (*(_BYTE *)(a1 + 12))
      {
        if (qword_101934580 != -1)
        {
          float v76 = v60;
          dispatch_once(&qword_101934580, &stru_10184DB38);
          float v60 = v76;
          float v55 = *(float *)&v88;
        }

        float v61 = v60 - v42;
        int v62 = (os_log_s *)qword_101934588;
        if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
        {
          float v63 = *(float *)(a1 + 2388);
          double v64 = *(float *)(a1 + 2384);
          *(_DWORD *)uint64_t buf = 134220800;
          double v118 = v20;
          __int16 v119 = 2048;
          double v120 = v41;
          __int16 v121 = 2048;
          double v122 = *((float *)&v86 + 1);
          __int16 v123 = 2048;
          double v124 = *(float *)&v86;
          __int16 v125 = 2048;
          double v126 = v57;
          __int16 v127 = 2048;
          double v128 = v55;
          __int16 v129 = 2048;
          double v130 = v64;
          __int16 v131 = 2048;
          double v132 = v63;
          __int16 v133 = 2048;
          double v134 = v56;
          __int16 v135 = 2048;
          double v136 = *((float *)&v85 + 1);
          __int16 v137 = 2048;
          double v138 = v84;
          __int16 v139 = 2048;
          double v140 = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEBUG,  "rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f",  buf,  0x7Au);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934580 != -1) {
            dispatch_once(&qword_101934580, &stru_10184DB38);
          }
          double v77 = *(float *)(a1 + 2384);
          double v78 = *(float *)(a1 + 2388);
          int v93 = 134220800;
          double v94 = v20;
          __int16 v95 = 2048;
          double v96 = v41;
          __int16 v97 = 2048;
          double v98 = *((float *)&v86 + 1);
          __int16 v99 = 2048;
          double v100 = *(float *)&v86;
          __int16 v101 = 2048;
          double v102 = v57;
          __int16 v103 = 2048;
          double v104 = *(float *)&v88;
          __int16 v105 = 2048;
          double v106 = v77;
          __int16 v107 = 2048;
          double v108 = v78;
          __int16 v109 = 2048;
          double v110 = v56;
          __int16 v111 = 2048;
          double v112 = *((float *)&v85 + 1);
          __int16 v113 = 2048;
          double v114 = v84;
          __int16 v115 = 2048;
          double v116 = v61;
          LODWORD(v82) = 122;
          int v79 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroH eadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, de ltaFiltered, %.3f",  COERCE_DOUBLE(&v93),  v82,  v83,  v84,  v85,  v86,  -57.2957795,  v88,  *(double *)&v89,  v90,  v91,  v92);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)",  "%s\n",  v79);
          double v24 = v87;
        }
      }

      float v43 = *(float *)(a1 + 2384);
    }

    else
    {
      sub_10074DAA8(a1 + 624, (float *)&v92 + 1);
      float v43 = *(float *)(a1 + 632);
      *(float *)(a1 + 2384) = v43;
    }

    if ((v43 >= 360.0 || v43 < 0.0) && *(_BYTE *)(a1 + 12))
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184DB38);
      }
      unint64_t v65 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
      {
        double v66 = *(float *)(a1 + 2384);
        *(_DWORD *)uint64_t buf = 134217984;
        double v118 = v66;
        _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_INFO,  "#Warning Heading  %.2f, is not in bound [0 360]",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184DB38);
        }
        double v80 = *(float *)(a1 + 2384);
        int v93 = 134217984;
        double v94 = v80;
        int v81 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "#Warning Heading  %.2f, is not in bound [0 360]",  COERCE_DOUBLE(&v93));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)",  "%s\n",  v81);
      }
    }

    if (sub_10074DC0C(a1)
      && (((*(uint64_t (**)(void))(**(void **)(a1 + 104) + 72LL))(*(void *)(a1 + 104)) & 1) != 0
       || *(_BYTE *)(a1 + 15)))
    {
      float v67 = sub_10074E070((float *)(a1 + 1280), (float *)(a1 + 72)) * v24 + 90.0;
      float v68 = sqrtf( (float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))
      float v69 = v67 * 3.14159265 / 180.0;
      float v70 = cosf(v69);
      sub_100788228(a1 + 112, v67, v68 * v70);
    }

    float v71 = *(float *)(a1 + 2384);
    *(float *)(a2 + sub_10000AE14(v9 + 24) = v71;
    else {
      float v72 = sub_100292B94(v71, *(double *)(a1 + 1408));
    }
    *(float *)(a2 + 2_Block_object_dispose(va, 8) = v72;
    int v73 = *(_DWORD *)(a1 + 1364);
    if (v73 || !*(_BYTE *)(a1 + 15))
    {
      float v74 = 20.0;
      if (*(_BYTE *)(a1 + 14))
      {
LABEL_57:
        *(float *)(a2 + 32) = v74;
        if (*(_BYTE *)(a1 + 13) && *(_BYTE *)(*(void *)(a1 + 104) + 184LL)) {
          *(float *)(a2 + 32) = v74 + 1.0;
        }
        return v22;
      }
    }

    else
    {
      int v73 = 1;
    }

    float v74 = sub_1007883FC(a1 + 112, v73);
    goto LABEL_57;
  }

  return v22;
}

void sub_10074DAA8(uint64_t a1, float *a2)
{
  float v3 = *a2 * 0.0174532925;
  __float2 v12 = __sincosf_stret(v3);
  sub_100476A68(a1 + 16, &v12.__cosval);
  sub_100476A68(a1 + 104, (float *)&v12);
  sub_10074DE7C((void *)(a1 + 16), 2, &v12.__cosval);
  sub_10074DE7C((void *)(a1 + 104), 2, &v12);
  float v4 = atan2f(v12.__sinval, v12.__cosval) * 57.2957795;
  *(float *)(a1 + _Block_object_dispose(va, 8) = v4;
  float v5 = sub_1007443E0(0, v4);
  *(float *)(a1 + _Block_object_dispose(va, 8) = v5;
  float v6 = *(float *)(a1 + 12);
  if (v6 != -1.0)
  {
    float v7 = sub_100292B54(v5, v6);
    double v8 = v7;
    float v9 = (cos(v7 * 0.0174532925) + 1.0) * *(float *)(a1 + 4);
    float v10 = (1.2 - v9) * 0.75 * v8;
    else {
      float v11 = -v10;
    }
    float v5 = sub_100292B94(*(float *)(a1 + 12), (float)(v11 + 0.0));
    *(float *)(a1 + _Block_object_dispose(va, 8) = v5;
  }

  *(float *)(a1 + 12) = v5;
}

BOOL sub_10074DC0C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 13)) {
    return sub_10074DD54(a1);
  }
  else {
    return sub_10074DCE4(a1);
  }
}

uint64_t sub_10074DC1C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 1352);
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(result + 1360);
  *(void *)a2 = v2;
  return result;
}

uint64_t sub_10074DC30(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 120LL))(*(void *)(a1 + 104));
}

float sub_10074DC40(uint64_t a1, float *a2)
{
  uint64_t v4 = a1 + 24;
  sub_10047109C((void *)(a1 + 24), a2);
  unint64_t v5 = *(void *)(a1 + 64);
  if (v5 > *(void *)(a1 + 8))
  {
    unint64_t v6 = *(void *)(a1 + 56);
    float v7 = *(float *)(*(void *)(*(void *)(a1 + 32) + ((v6 >> 7) & 0x1FFFFFFFFFFFFF8LL)) + 4 * (v6 & 0x3FF));
    float v8 = *(float *)(a1 + 16) - v7;
    float v9 = *(float *)(a1 + 20) - (float)(v7 * v7);
    *(float *)(a1 + sub_100708348(v2 - 16) = v8;
    *(float *)(a1 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v9;
    *(void *)(a1 + 56) = v6 + 1;
    *(void *)(a1 + 64) = v5 - 1;
    sub_10074E0DC(v4, 1);
  }

  float v10 = *(float *)(a1 + 20);
  *(float *)(a1 + sub_100708348(v2 - 16) = *a2 + *(float *)(a1 + 16);
  float result = v10 + (float)(*a2 * *a2);
  *(float *)(a1 + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = result;
  return result;
}

BOOL sub_10074DCE4(uint64_t a1)
{
  BOOL result = 0LL;
  float v3 = sqrtf( (float)((float)(*(float *)(a1 + 84) * *(float *)(a1 + 84)) + (float)(*(float *)(a1 + 80) * *(float *)(a1 + 80)))
       + (float)(*(float *)(a1 + 88) * *(float *)(a1 + 88)));
  if (v3 < 1.2 && v3 > 0.8)
  {
    unint64_t v4 = *(void *)(a1 + 1568);
    return !v4 || (float)(*(float *)(a1 + 1520) / (float)v4) < 0.09;
  }

  return result;
}

BOOL sub_10074DD54(uint64_t a1)
{
  if (sqrtf( (float)((float)(*(float *)(a1 + 60) * *(float *)(a1 + 60)) + (float)(*(float *)(a1 + 56) * *(float *)(a1 + 56))) {
  unint64_t v1 = *(void *)(a1 + 1640);
  }
  if (!v1) {
    return 1LL;
  }
  float v2 = *(float *)(a1 + 1592);
  else {
    return 1LL;
  }
}

void sub_10074DDF4(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

uint64_t sub_10074DE20(uint64_t a1)
{
  *(void *)(a1 + 104) = off_10183B0F0;
  sub_100008390(a1 + 168, *(void **)(a1 + 176));
  sub_100210578((void *)(a1 + 120));
  *(void *)(a1 + sub_100708348(v2 - 16) = off_10183B0F0;
  sub_100008390(a1 + 80, *(void **)(a1 + 88));
  sub_100210578((void *)(a1 + 32));
  return a1;
}

uint64_t sub_10074DE7C(void *a1, int a2, _DWORD *a3)
{
  unint64_t v3 = a1[10];
  if (!v3) {
    return 0LL;
  }
  if (a2 == 2)
  {
    float v10 = (double)v3 * 0.5;
    int v11 = vcvtms_s32_f32(v10);
    __float2 v12 = (void *)a1[8];
    if (v11 < 1)
    {
      float v7 = (void *)a1[8];
    }

    else
    {
      for (int i = 0; i != v11; ++i)
      {
        float v14 = (void *)v12[1];
        if (v14)
        {
          do
          {
            float v7 = v14;
            float v14 = (void *)*v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            float v7 = (void *)v12[2];
            BOOL v8 = *v7 == (void)v12;
            __float2 v12 = v7;
          }

          while (!v8);
        }

        __float2 v12 = v7;
      }
    }

    goto LABEL_22;
  }

  if (a2 != 1)
  {
    if (!a2)
    {
      unint64_t v6 = (void *)a1[9];
      float v4 = a1 + 9;
      unint64_t v5 = v6;
      if (v6)
      {
        do
        {
          float v7 = v5;
          unint64_t v5 = (void *)v5[1];
        }

        while (v5);
      }

      else
      {
        do
        {
          float v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          float v4 = v7;
        }

        while (v8);
      }

      goto LABEL_22;
    }

    return 0LL;
  }

  float v7 = (void *)a1[8];
LABEL_22:
  *a3 = *((_DWORD *)v7 + 7);
  return 1LL;
}

void sub_10074DF50(void *a1)
{
  unint64_t v1 = sub_10074DF98(a1);
  operator delete(v1);
}

void sub_10074DF64(void *a1)
{
  *a1 = off_10184DB98;
  sub_10046E180(a1 + 3);
  operator delete(a1);
}

void *sub_10074DF98(void *a1)
{
  *a1 = off_10184DB68;
  a1[20] = off_10184DB98;
  sub_10046E180(a1 + 23);
  a1[11] = off_10184DB98;
  sub_10046E180(a1 + 14);
  a1[2] = off_10184DB98;
  sub_10046E180(a1 + 5);
  return a1;
}

void sub_10074DFF8(void *a1)
{
  float v2 = (void **)a1[4];
  uint64_t v3 = a1[5];
  a1[8] = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[5];
      float v2 = (void **)(a1[4] + 8LL);
      a1[4] = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 512LL;
    goto LABEL_7;
  }

  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 1024LL;
LABEL_7:
    a1[7] = v6;
  }

  a1[2] = 0LL;
}

float sub_10074E070(float *a1, float *a2)
{
  float v2 = a1[2];
  float v3 = a1[3];
  float v4 = a1[4];
  float v5 = sqrtf((float)((float)(v3 * v3) + (float)(v2 * v2)) + (float)(v4 * v4));
  if (v5 > 0.0
    && (float v6 = a2[2],
        float v7 = a2[3],
        float v8 = a2[4],
        float v9 = sqrtf((float)((float)(v7 * v7) + (float)(v6 * v6)) + (float)(v8 * v8)),
        v9 > 0.0)
    && (float v10 = (float)((float)((float)((float)(v3 * v7) + (float)(v6 * v2)) + (float)(v8 * v4)) / v5) / v9, v10 <= 1.0))
  {
    return acosf(v10);
  }

  else
  {
    return 0.0;
  }

uint64_t sub_10074E0DC(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x400) {
    a2 = 1;
  }
  if (v2 < 0x800) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 1024LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_10074E138(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  float v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *float v7 = off_10184DBC8;
  _OWORD v7[6] = 0LL;
  sub_100CB8234((uint64_t)sub_10074E1F4, a1, a3, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = v12;
    uint64_t v12 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a1;
}

void sub_10074E1C8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_10074E1F4(uint64_t a1, _DWORD *a2, double *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10184DC18);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLProxPDPAndALSPhoneSubscription::onProxPDPData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10184DC18);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      float v15 = "";
      __int16 v16 = 2082;
      float v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLProxPDPAndALSPhoneSubscription::onProxPDPData, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10074F18C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10074E3AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074E3D0(void *a1)
{
  *a1 = off_10184DBC8;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return sub_100C6AB50((uint64_t)a1);
}

void sub_10074E414(void *a1)
{
  *a1 = off_10184DBC8;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = (void *)sub_100C6AB50((uint64_t)a1);
  operator delete(v3);
}

void *sub_10074E45C@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_10184DC68;
  v11[1] = sub_10074E6C4;
  _DWORD v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageProxPDPUpdate");
  sub_10074F57C((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_10184DC68;
  v9[1] = sub_10074EC28;
  _DWORD v9[2] = 0LL;
  uint64_t v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageALSPhoneUpdate");
  sub_10074F57C((uint64_t)v16, (uint64_t)v9);
  sub_10074F96C(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      uint64_t v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  float v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    float v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  BOOL result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    BOOL result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_10074E5F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  float v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    float v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  BOOL v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    BOOL v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_10074E6C4(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if ((sub_10029D234() & 1) != 0)
  {
    sub_1010DDBC0(buf, "com.apple.locationd.cmproxpdpandalsphonemanager");
    char v5 = sub_100C6AC9C(a1);
    char v6 = v5;
    if (v22 < 0)
    {
      operator delete(*(void **)buf);
      if ((v6 & 1) != 0)
      {
LABEL_4:
        sub_100C6AC8C(a1);
        if (a2)
        {
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_10184DC38);
          }
          uint64_t v7 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Requesting Prox PDP subscription", buf, 2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_10184DC38);
            }
            v16[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Requesting Prox PDP subscription",  v16,  2);
            int v13 = (uint8_t *)v12;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestProxPDP(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
            if (v13 != buf) {
              free(v13);
            }
          }

          [*(id *)(*(void *)(a1 + 48) + 16) register:*(void *)(*(void *)(a1 + 48) + 8) forNotification:0 registrationInfo:0];
        }

        else
        {
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_10184DC38);
          }
          uint64_t v9 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Requesting Prox PDP unsubscription",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_10184DC38);
            }
            v16[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Requesting Prox PDP unsubscription",  v16,  2);
            float v15 = (uint8_t *)v14;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestProxPDP(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
            if (v15 != buf) {
              free(v15);
            }
          }

          [*(id *)(*(void *)(a1 + 48) + 16) unregister:*(void *)(*(void *)(a1 + 48) + 8) forNotification:0];
        }

        goto LABEL_25;
      }
    }

    else if ((v5 & 1) != 0)
    {
      goto LABEL_4;
    }

    uint64_t v17 = CMErrorMessage;
    __int16 v18 = &off_1018D3908;
    *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_10074F410(a1, buf);
    goto LABEL_25;
  }

  if (qword_1019344A0 != -1) {
    dispatch_once(&qword_1019344A0, &stru_10184DC38);
  }
  uint64_t v8 = (os_log_s *)qword_1019344A8;
  if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Subscription to Prox PDP is not available",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344A0 != -1) {
      dispatch_once(&qword_1019344A0, &stru_10184DC38);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  16LL,  "Subscription to Prox PDP is not available",  v16,  2);
    char v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestProxPDP(BOOL, const CLNameValuePair &)",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  uint64_t v19 = CMErrorMessage;
  float v20 = &off_1018D38F0;
  *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
  sub_10074F410(a1, buf);
LABEL_25:
}

void sub_10074EBC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  _Unwind_Resume(a1);
}

void sub_10074EC28(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if ((sub_10029D234() & 1) != 0)
  {
    sub_1010DDBC0(buf, "com.apple.locationd.cmproxpdpandalsphonemanager");
    char v5 = sub_100C6AC9C(a1);
    char v6 = v5;
    if (v22 < 0)
    {
      operator delete(*(void **)buf);
      if ((v6 & 1) != 0)
      {
LABEL_4:
        sub_100C6AC8C(a1);
        if (a2)
        {
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_10184DC38);
          }
          uint64_t v7 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Requesting ALS Phone subscription",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_10184DC38);
            }
            v16[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Requesting ALS Phone subscription",  v16,  2);
            int v13 = (uint8_t *)v12;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestALSPhone(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
            if (v13 != buf) {
              free(v13);
            }
          }

          [*(id *)(*(void *)(a1 + 48) + 16) register:*(void *)(*(void *)(a1 + 48) + 8) forNotification:1 registrationInfo:0];
        }

        else
        {
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_10184DC38);
          }
          uint64_t v9 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Requesting ALS Phone unsubscription",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_10184DC38);
            }
            v16[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Requesting ALS Phone unsubscription",  v16,  2);
            float v15 = (uint8_t *)v14;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestALSPhone(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
            if (v15 != buf) {
              free(v15);
            }
          }

          [*(id *)(*(void *)(a1 + 48) + 16) unregister:*(void *)(*(void *)(a1 + 48) + 8) forNotification:1];
        }

        goto LABEL_25;
      }
    }

    else if ((v5 & 1) != 0)
    {
      goto LABEL_4;
    }

    uint64_t v17 = CMErrorMessage;
    __int16 v18 = &off_1018D3908;
    *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_10074F4B0(a1, buf);
    goto LABEL_25;
  }

  if (qword_1019344A0 != -1) {
    dispatch_once(&qword_1019344A0, &stru_10184DC38);
  }
  uint64_t v8 = (os_log_s *)qword_1019344A8;
  if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Subscription to ALS is not available", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344A0 != -1) {
      dispatch_once(&qword_1019344A0, &stru_10184DC38);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  16LL,  "Subscription to ALS is not available",  v16,  2);
    char v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLProxPDPAndALSPhoneSubscription::handleRequestALSPhone(BOOL, const CLNameValuePair &)",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  uint64_t v19 = CMErrorMessage;
  float v20 = &off_1018D38F0;
  *(void *)uint64_t buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);
  sub_10074F4B0(a1, buf);
LABEL_25:
}

void sub_10074F12C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  _Unwind_Resume(a1);
}

void sub_10074F18C(uint64_t a1, uint64_t a2, _DWORD *a3, double *a4)
{
  if (*a3 == 1)
  {
    id v15 = objc_alloc(&OBJC_CLASS___CMALSPhone);
    LODWORD(vsub_100708348(v2 - 16) = *((_DWORD *)a4 + 2);
    id v17 = [v15 initWithTimestamp:*a4 illumination:v16];
    uint64_t v19 = CMALSPhoneObject;
    id v20 = v17;
    __int16 v18 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL);

    sub_10074F368(a1, &v18);
  }

  else if (!*a3)
  {
    id v6 = objc_alloc(&OBJC_CLASS___CMProxPDP);
    LODWORD(v7) = *((_DWORD *)a4 + 2);
    LODWORD(v_Block_object_dispose(va, 8) = *((_DWORD *)a4 + 3);
    LODWORD(v9) = *((_DWORD *)a4 + 4);
    LODWORD(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *((_DWORD *)a4 + 5);
    LODWORD(v11) = *((_DWORD *)a4 + 6);
    LODWORD(v12) = *((_DWORD *)a4 + 7);
    LODWORD(v13) = *((_DWORD *)a4 + 8);
    id v14 = [v6 initWithTimestamp:*((unsigned __int8 *)a4 + 36) intensity:*((unsigned __int8 *)a4 + 37) intensityCalDelta:*a4 intensityBaselineDelta:v7 ambient:v8 pocketProbability:v9 baselineConfi dence:v10 rxNtcC:v11 scanFlags:v12 pocketFlag:v13];
    uint64_t v21 = CMProxPDPObject;
    id v22 = v14;
    __int16 v18 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v22,  &v21,  1LL);

    sub_10074F2C0(a1, &v18);
  }

void sub_10074F2C0(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10074F354(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10074F368(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10074F3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10074F410(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(off_10184DD08, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10074F49C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10074F4B0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(off_10184DD10, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10074F53C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10074F550(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_10074F57C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + sub_10000AE14(v9 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + sub_10000AE14(v9 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  void *v3 = 0LL;
  return a1;
}

void sub_10074F5E0(id a1)
{
  qword_1019344A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Eclipse");
}

__n128 sub_10074F60C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10184DC68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_10074F648(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10184DC68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_10074F66C(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_10074F674(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10074F6B0()
{
}

void sub_10074F6BC(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_10074F740(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10074F728( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074F740(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    double v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    double v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      double v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10184DCD8);
    }
    double v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10184DCD8);
      }
    }

    double v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_10074F924( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10074F940(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

uint64_t sub_10074F96C(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_10074F9E4(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_10074F9D0(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10074F9E4(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  double v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    double v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_10074FC64(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  id v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *id v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + sub_100708348(v2 - 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_10074FC4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_10074FC64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_10074FCD8(v8 + 2, a3);
  *(_BYTE *)(a4 + sub_100708348(v2 - 16) = 1;
  return result;
}

void sub_10074FCC0(_Unwind_Exception *a1)
{
}

void *sub_10074FCD8(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_10074FD30(_Unwind_Exception *exception_object)
{
}

_DWORD *sub_10074FD4C(_DWORD *result, int a2)
{
  *__n128 result = a2;
  return result;
}

void *sub_10074FD54@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10184DD18[*a1]);
}

uint64_t sub_10074FEB8(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 2)
    {
      String = (void *)PBReaderReadString(a2);

      *(void *)(a1 + sub_100708348(v2 - 16) = String;
    }

    else if ((v6 >> 3) == 1)
    {
      char v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = 0LL;
      while (1)
      {
        unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v15 == -1LL || v15 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v16 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 1;
        v14 |= (unint64_t)(v16 & 0x7F) << v12;
        if ((v16 & 0x80) == 0) {
          goto LABEL_30;
        }
        v12 += 7;
        BOOL v9 = v13++ >= 9;
        if (v9)
        {
          LODWORD(v14) = 0;
          goto LABEL_32;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_30:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v14) = 0;
      }
LABEL_32:
      *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v14;
    }

    else
    {
      uint64_t result = PBReaderSkipValueWithTag(a2);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_10075030C(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + sub_10000AE14(v9 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(_BYTE *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 57) = 65793;
  if (byte_1019A15F7 < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 64), (void *)xmmword_1019A15E0, *((unint64_t *)&xmmword_1019A15E0 + 1));
  }

  else
  {
    *(_OWORD *)(a1 + 64) = xmmword_1019A15E0;
    *(void *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = unk_1019A15F0;
  }

  if (byte_1019A160F < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 88), (void *)xmmword_1019A15F8, *((unint64_t *)&xmmword_1019A15F8 + 1));
  }

  else
  {
    *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = xmmword_1019A15F8;
    *(void *)(a1 + 104) = unk_1019A1608;
  }

  if (byte_1019A1627 < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 112), (void *)xmmword_1019A1610, *((unint64_t *)&xmmword_1019A1610 + 1));
  }

  else
  {
    *(_OWORD *)(a1 + sub_10000AE14(v2 - 112) = xmmword_1019A1610;
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = unk_1019A1620;
  }

  *(_OWORD *)(a1 + 136) = xmmword_101329190;
  *(_OWORD *)(a1 + 16sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *(void *)(a1 + 152) = 0x4024000000000000LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 20sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a1 + 192) = 1065353216;
  *(_WORD *)(a1 + 2sub_10000AE14(v9 + 24) = 257;
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 2sub_100708348(v2 - 16) = 0LL;
  *(void *)(a1 + 22_Block_object_dispose(va, 8) = 0x32000000018LL;
  *(_WORD *)(a1 + 236) = 0;
  *(_BYTE *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
  *(_DWORD *)(a1 + 244) = -115;
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0x4000000000000000LL;
  *(void *)(a1 + 256) = 0x3E800000005LL;
  *(_WORD *)(a1 + 264) = 0;
  *(void *)(a1 + 26_Block_object_dispose(va, 8) = -1LL;
  *(_WORD *)(a1 + 276) = 257;
  *(_BYTE *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
  *(_WORD *)(a1 + 284) = 257;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0x32000000018LL;
  *(_WORD *)(a1 + 296) = 0;
  *(_WORD *)(a1 + 30sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *(void *)(a1 + 304) = 0x6400000005LL;
  *(_WORD *)(a1 + 312) = 256;
  *(_WORD *)(a1 + 3sub_100708348(v2 - 16) = 0;
  *(void *)(a1 + 32sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = -1LL;
  *(_WORD *)(a1 + 32_Block_object_dispose(va, 8) = 257;
  *(_BYTE *)(a1 + 332) = 1;
  *(_WORD *)(a1 + 336) = 0;
  *(void *)(a1 + 34sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = -1LL;
  *(_WORD *)(a1 + 34_Block_object_dispose(va, 8) = 257;
  *(_WORD *)(a1 + 352) = 0;
  *(void *)(a1 + 356) = -1LL;
  *(_WORD *)(a1 + 364) = 257;
  *(_WORD *)(a1 + 36_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 372) = -1LL;
  *(_WORD *)(a1 + 38sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 257;
  *(void *)(a1 + 384) = 0x6400000002LL;
  *(_DWORD *)(a1 + 392) = 100;
  *(_WORD *)(a1 + 396) = 256;
  *(_OWORD *)(a1 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = xmmword_1013291A0;
  *(void *)(a1 + 4sub_100708348(v2 - 16) = 0x93A80018B8200LL;
  sub_1007505D8(a1);
  return a1;
}

void sub_10075054C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1007505D8(uint64_t a1)
{
  if (byte_1019987AF >= 0) {
    uint64_t v2 = (const char *)&qword_101998798;
  }
  else {
    uint64_t v2 = (const char *)qword_101998798;
  }
  BOOL v3 = sub_1002A8F8C(*(uint64_t *)buf, v2, v69);
  char v4 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unsigned int v5 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  if (v3)
  {
    sub_1007538D0((int *)a1, (uint64_t)v69);
  }

  else
  {
    memset(buf, 0, sizeof(buf));
    int v78 = 1065353216;
    sub_100754218((int *)a1, buf);
    unint64_t v7 = *(uint64_t **)&buf[16];
    if (*(void *)&buf[16])
    {
      do
      {
        sub_1010DDBC0(&__p, "");
        sub_100751750((int *)a1, (std::string *)(v7 + 2), (std::string *)(v7 + 5), 0, &__p);
        unint64_t v7 = (uint64_t *)*v7;
      }

      while (v7);
    }

    sub_1007825DC((uint64_t)buf);
  }

  memset(&__p, 0, sizeof(__p));
  sub_1002F0B04(buf);
  BOOL v8 = sub_1002A8560(*(uint64_t *)buf, "EEDIntermediateCert", &__p);
  BOOL v9 = v8;
  int v10 = *(std::__shared_weak_count **)&buf[8];
  if (!*(void *)&buf[8]) {
    goto LABEL_20;
  }
  uint8x8_t v11 = (unint64_t *)(*(void *)&buf[8] + 8LL);
  do
    unint64_t v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v9) {
      goto LABEL_28;
    }
  }

  else
  {
LABEL_20:
    if (!v8) {
      goto LABEL_28;
    }
  }

  unsigned int v13 = (void *)(a1 + 200);
  std::string::operator=((std::string *)(a1 + 200), &__p);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v14 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)a1;
    char v16 = (void *)(a1 + 200);
    *(_DWORD *)uint64_t buf = 67240451;
    *(_DWORD *)&uint8_t buf[4] = v15;
    *(_WORD *)&uint8_t buf[8] = 2081;
    *(void *)&buf[10] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2Cfg,inst,%{public}d,overriding intermediate cert to %{private}s",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v52 = *(_DWORD *)a1;
    LODWORD(__str.__r_.__value_.__l.__data_) = 67240451;
    HIDWORD(__str.__r_.__value_.__r.__words[0]) = v52;
    LOWORD(__str.__r_.__value_.__r.__words[1]) = 2081;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2Cfg,inst,%{public}d,overriding intermediate cert to %{private}s",  &__str,  18);
    float v54 = (uint8_t *)v53;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::SimConfig::loadSettingsFromDefaults()", "%s\n", v53);
    if (v54 != buf) {
      free(v54);
    }
  }

void sub_100751164( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43, uint64_t a44, char a45)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_1002A5590(&a18);
  _Unwind_Resume(a1);
}

BOOL sub_100751290(uint64_t a1, unsigned __int8 *a2, std::string *__str, const std::string *a4)
{
  if (__PAIR64__(*(unsigned __int8 *)(a1 + 57), *(unsigned __int8 *)(a1 + 56)) != __PAIR64__(a2[1], *a2)
    || *(unsigned __int8 *)(a1 + 58) != a2[128])
  {
    goto LABEL_19;
  }

  signed __int8 v8 = a2[31];
  int v9 = *(char *)(a1 + 87);
  if (v9 < 0)
  {
    int v10 = *(const void **)(a1 + 64);
    unint64_t v11 = *(void *)(a1 + 72);
  }

  else
  {
    int v10 = (const void *)(a1 + 64);
    unint64_t v11 = v9;
  }

  unint64_t v12 = v8 >= 0 ? a2[31] : *((void *)a2 + 2);
  unsigned int v13 = v8 >= 0 ? a2 + 8 : (unsigned __int8 *)*((void *)a2 + 1);
  size_t v14 = v12 >= v11 ? v11 : v12;
  if (!memcmp(v10, v13, v14) && v12 == v11)
  {
    signed __int8 v47 = a2[55];
    if (*(char *)(a1 + 111) < 0)
    {
      unint64_t v48 = *(const void **)(a1 + 88);
      size_t v49 = *(void *)(a1 + 96);
    }

    else
    {
      unint64_t v48 = (const void *)(a1 + 88);
      size_t v49 = *(unsigned __int8 *)(a1 + 111);
    }

    if (v47 >= 0) {
      size_t v50 = a2[55];
    }
    else {
      size_t v50 = *((void *)a2 + 5);
    }
    if (v47 >= 0) {
      float v51 = a2 + 32;
    }
    else {
      float v51 = (const void *)*((void *)a2 + 4);
    }
    if (v50 >= v49) {
      size_t v52 = v49;
    }
    else {
      size_t v52 = v50;
    }
    BOOL v16 = 1LL;
    if (!memcmp(v48, v51, v52)
      && v50 == v49
      && *(double *)(a1 + 136) == *((double *)a2 + 10)
      && *(double *)(a1 + 144) == *((double *)a2 + 11)
      && *(double *)(a1 + 152) == *((double *)a2 + 12)
      && *(unsigned __int8 *)(a1 + 60) == a2[129]
      && !sub_1007516E4((const void **)(a1 + 112), a2 + 56))
    {
      BOOL v16 = *(unsigned __int8 *)(a1 + 59) != a2[2];
    }
  }

  else
  {
LABEL_19:
    BOOL v16 = 1LL;
  }

  std::string::operator=((std::string *)(a1 + 8), __str);
  std::string::operator=((std::string *)(a1 + 32), a4);
  *(_WORD *)(a1 + 56) = *(_WORD *)a2;
  *(_BYTE *)(a1 + 5_Block_object_dispose(va, 8) = a2[128];
  *(_BYTE *)(a1 + 59) = a2[2];
  BOOL v17 = (void *)(a1 + 64);
  std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 8));
  BOOL v18 = (void *)(a1 + 88);
  std::string::operator=((std::string *)(a1 + 88), (const std::string *)(a2 + 32));
  unint64_t v19 = (void *)(a1 + 112);
  std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 56));
  *(_OWORD *)(a1 + 136) = *((_OWORD *)a2 + 5);
  *(void *)(a1 + 152) = *((void *)a2 + 12);
  unint64_t v20 = (void *)(a1 + 200);
  std::string::operator=((std::string *)(a1 + 200), (const std::string *)(a2 + 104));
  *(_BYTE *)(a1 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a2[129];
  __int128 v21 = *((_OWORD *)a2 + 16);
  __int128 v22 = *((_OWORD *)a2 + 17);
  __int128 v23 = *((_OWORD *)a2 + 19);
  *(_OWORD *)(a1 + 352) = *((_OWORD *)a2 + 18);
  *(_OWORD *)(a1 + 36_Block_object_dispose(va, 8) = v23;
  *(_OWORD *)(a1 + 32sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v21;
  *(_OWORD *)(a1 + 336) = v22;
  __int128 v24 = *((_OWORD *)a2 + 12);
  __int128 v25 = *((_OWORD *)a2 + 13);
  __int128 v26 = *((_OWORD *)a2 + 15);
  *(_OWORD *)(a1 + 28_Block_object_dispose(va, 8) = *((_OWORD *)a2 + 14);
  *(_OWORD *)(a1 + 304) = v26;
  *(_OWORD *)(a1 + 256) = v24;
  *(_OWORD *)(a1 + 272) = v25;
  __int128 v27 = *((_OWORD *)a2 + 11);
  *(_OWORD *)(a1 + 2sub_10000AE14(v9 + 24) = *((_OWORD *)a2 + 10);
  *(_OWORD *)(a1 + 24sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v27;
  int v28 = *((_DWORD *)a2 + 82);
  *(void *)(a1 + 384) = *((void *)a2 + 40);
  *(_DWORD *)(a1 + 392) = v28;
  sub_100782588(a1 + 160);
  uint64_t v29 = *((void *)a2 + 17);
  unint64_t v30 = (const std::string *)*((void *)a2 + 18);
  if ((const std::string *)v29 != v30)
  {
    uint64_t v31 = (const std::string *)(v29 + 56);
    do
    {
      sub_100751750( (int *)a1,  (std::string *)&v31[-3].__r_.__value_.__r.__words[2],  (std::string *)&v31[-2].__r_.__value_.__r.__words[2],  v31[-1].__r_.__value_.__s.__data_[16],  v31);
      uint64_t v32 = v31 + 1;
      uint64_t v31 = (const std::string *)((char *)v31 + 80);
    }

    while (v32 != v30);
  }

  sub_1007505D8(a1);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v33 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    if ((__str->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v34 = __str;
    }
    else {
      double v34 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    if ((a4->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      BOOL v35 = a4;
    }
    else {
      BOOL v35 = (const std::string *)a4->__r_.__value_.__r.__words[0];
    }
    int v36 = *(_DWORD *)a1;
    int v37 = *(unsigned __int8 *)(a1 + 56);
    int v38 = *(unsigned __int8 *)(a1 + 57);
    int v39 = *(unsigned __int8 *)(a1 + 58);
    uint64_t v41 = *(void *)(a1 + 136);
    uint64_t v40 = *(void *)(a1 + 144);
    uint64_t v42 = *(void *)(a1 + 152);
    int v43 = *(_DWORD *)(a1 + 184);
    int v44 = *(unsigned __int8 *)(a1 + 60);
    int v45 = *(unsigned __int8 *)(a1 + 59);
    v53[0] = 68293379;
    v53[1] = 0;
    __int16 v54 = 2082;
    int v55 = "";
    __int16 v56 = 1026;
    BOOL v57 = v16;
    __int16 v58 = 1026;
    int v59 = v36;
    __int16 v60 = 2082;
    int v61 = v34;
    __int16 v62 = 2082;
    float v63 = v35;
    __int16 v64 = 1026;
    int v65 = v37;
    __int16 v66 = 1026;
    int v67 = v38;
    __int16 v68 = 1026;
    int v69 = v39;
    __int16 v70 = 2081;
    int v71 = v17;
    __int16 v72 = 2081;
    int v73 = v18;
    __int16 v74 = 2049;
    uint64_t v75 = v41;
    __int16 v76 = 2049;
    uint64_t v77 = v40;
    __int16 v78 = 2049;
    uint64_t v79 = v42;
    __int16 v80 = 1026;
    int v81 = v43;
    __int16 v82 = 2082;
    double v83 = v20;
    __int16 v84 = 1026;
    int v85 = v44;
    __int16 v86 = 2081;
    double v87 = v19;
    __int16 v88 = 1026;
    int v89 = v45;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#EED2Cfg updated CB info, changed:%{public}d, sim:%{public}d, version:%{publi c, location:escape_only}s, id:%{public, location:escape_only}s, enabled:%{public}hhd, adrEnabled:%{pub lic}hhd, dsaEnabled:%{public}hhd, lisUrl:%{private, location:escape_only}s, adrUrl:%{private, location :escape_only}s, firstLisTimeout:%{private}f, periodicLisTimeout:%{private}f, initialAdrTimeout :%{private}f, partnerInfoMapSize:%{public}d, intermediateCert:%{public, location:escape_only}s, unma skCrashDetection:%{public}hhd, controlUrl:%{private, location:escape_only}s, requestsEnabled:%{public}hhd}",  (uint8_t *)v53,  0x9Cu);
  }

  return v16;
}

uint64_t sub_1007516E4(const void **a1, _BYTE *a2)
{
  char v2 = a2[23];
  if (*((char *)a1 + 23) < 0)
  {
    char v4 = a1;
    a1 = (const void **)*a1;
    size_t v3 = (size_t)v4[1];
  }

  else
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }

  if (v2 >= 0) {
    size_t v5 = a2[23];
  }
  else {
    size_t v5 = *((void *)a2 + 1);
  }
  if (v2 < 0) {
    a2 = *(_BYTE **)a2;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  LODWORD(result) = memcmp(a1, a2, v6);
  if (v3 < v5) {
    unsigned int v8 = -1;
  }
  else {
    unsigned int v8 = v5 < v3;
  }
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v8;
  }
}

void sub_100751750(int *a1, std::string *a2, std::string *a3, unsigned __int8 a4, const std::string *a5)
{
  SecCertificateRef v10 = sub_1007536D4((uint64_t *)a3);
  if (v10)
  {
    CFRelease(v10);
    uint64_t v11 = (uint64_t)(a1 + 40);
    if (sub_10023BD04((void *)a1 + 20, (unsigned __int8 *)a2))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unint64_t v12 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        int v13 = *a1;
        if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v14 = (std::string::size_type)a2;
        }
        else {
          std::string::size_type v14 = a2->__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240450;
        HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v13;
        LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s",  (uint8_t *)buf,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v15 = *a1;
        if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v16 = (std::string::size_type)a2;
        }
        else {
          std::string::size_type v16 = a2->__r_.__value_.__r.__words[0];
        }
        LODWORD(v37.__r_.__value_.__l.__data_) = 67240450;
        HIDWORD(v37.__r_.__value_.__r.__words[0]) = v15;
        LOWORD(v37.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v37.__r_.__value_.__r.__words[1] + 2) = v16;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s",  &v37,  18);
        BOOL v18 = (std::stringbuf::string_type *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::addPartnerInfo(const std::string &, const std::string &, BOOL, const std::string &)",  "%s\n",  v17);
        goto LABEL_31;
      }
    }

    else
    {
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      __int128 v25 = sub_1007829CC((uint64_t)(a1 + 40), (unsigned __int8 *)a2, (uint64_t)&unk_1012CF090, (__int128 **)buf);
      std::string::operator=((std::string *)(v25 + 40), a2);
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      __int128 v26 = sub_1007829CC((uint64_t)(a1 + 40), (unsigned __int8 *)a2, (uint64_t)&unk_1012CF090, (__int128 **)buf);
      std::string::operator=((std::string *)(v26 + 64), a3);
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      sub_1007829CC((uint64_t)(a1 + 40), (unsigned __int8 *)a2, (uint64_t)&unk_1012CF090, (__int128 **)buf)[88] = a4;
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      __int128 v27 = (std::string *)sub_1007829CC( (uint64_t)(a1 + 40),  (unsigned __int8 *)a2,  (uint64_t)&unk_1012CF090,  (__int128 **)buf);
      std::string::operator=(v27 + 4, a5);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v28 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        int v29 = *a1;
        buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
        unint64_t v30 = sub_1007829CC((uint64_t)(a1 + 40), (unsigned __int8 *)a2, (uint64_t)&unk_1012CF090, (__int128 **)buf);
        sub_100753764((uint64_t)(v30 + 40), buf);
        uint64_t v31 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
            ? buf
            : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
        LODWORD(v37.__r_.__value_.__l.__data_) = 67240450;
        HIDWORD(v37.__r_.__value_.__r.__words[0]) = v29;
        LOWORD(v37.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v37.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v31;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#EED2Cfg,inst,%{public}d,fPartnerInfoMap:%s",  (uint8_t *)&v37,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v32 = qword_101934898;
        int v33 = *a1;
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
        double v34 = sub_1007829CC(v11, (unsigned __int8 *)a2, (uint64_t)&unk_1012CF090, (__int128 **)&v37);
        sub_100753764((uint64_t)(v34 + 40), &v37);
        if ((v37.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          BOOL v35 = &v37;
        }
        else {
          BOOL v35 = (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
        }
        v38[0] = 67240450;
        v38[1] = v33;
        __int16 v39 = 2080;
        uint64_t v40 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v32,  0LL,  "#EED2Cfg,inst,%{public}d,fPartnerInfoMap:%s",  v38,  18);
        BOOL v18 = v36;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::addPartnerInfo(const std::string &, const std::string &, BOOL, const std::string &)",  "%s\n",  (const char *)v18);
        if (v18 != buf) {
          goto LABEL_51;
        }
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unint64_t v19 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v20 = *a1;
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v21 = (std::string::size_type)a2;
      }
      else {
        std::string::size_type v21 = a2->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240451;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v20;
      LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s",  (uint8_t *)buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v22 = *a1;
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v23 = (std::string::size_type)a2;
      }
      else {
        std::string::size_type v23 = a2->__r_.__value_.__r.__words[0];
      }
      LODWORD(v37.__r_.__value_.__l.__data_) = 67240451;
      HIDWORD(v37.__r_.__value_.__r.__words[0]) = v22;
      LOWORD(v37.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&v37.__r_.__value_.__r.__words[1] + 2) = v23;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s",  &v37,  18);
      BOOL v18 = (std::stringbuf::string_type *)v24;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::addPartnerInfo(const std::string &, const std::string &, BOOL, const std::string &)",  "%s\n",  v24);
LABEL_31:
      if (v18 == buf) {
        return;
      }
LABEL_51:
      free(v18);
    }
  }

BOOL sub_100751DA4(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (*(unsigned __int8 *)(a1 + 396) != v3)
  {
    LOBYTE(v4) = a2[1];
LABEL_9:
    BOOL v5 = 1LL;
    goto LABEL_11;
  }

  int v4 = *(unsigned __int8 *)(a1 + 397);
  if (v4 == a2[1])
  {
    if (*(_DWORD *)(a1 + 404) == *((_DWORD *)a2 + 2)
      && *(_DWORD *)(a1 + 408) == *((_DWORD *)a2 + 3)
      && *(_DWORD *)(a1 + 412) == *((_DWORD *)a2 + 4)
      && *(_DWORD *)(a1 + 416) == *((_DWORD *)a2 + 5))
    {
      BOOL v5 = *(_DWORD *)(a1 + 420) != *((_DWORD *)a2 + 6);
      goto LABEL_11;
    }

    goto LABEL_9;
  }

  BOOL v5 = 1LL;
  LOBYTE(v4) = a2[1];
LABEL_11:
  *(_BYTE *)(a1 + 396) = v3;
  *(_BYTE *)(a1 + 397) = v4;
  *(_OWORD *)(a1 + 40sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 4);
  *(void *)(a1 + 4sub_100708348(v2 - 16) = *(void *)(a2 + 20);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  size_t v6 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(unsigned __int8 *)(a1 + 396);
    int v8 = *(unsigned __int8 *)(a1 + 397);
    int v9 = *(_DWORD *)(a1 + 400);
    int v10 = *(_DWORD *)(a1 + 404);
    int v11 = *(_DWORD *)(a1 + 408);
    int v12 = *(_DWORD *)(a1 + 412);
    int v13 = *(_DWORD *)(a1 + 416);
    int v14 = *(_DWORD *)(a1 + 420);
    v16[0] = 68291330;
    v16[1] = 0;
    __int16 v17 = 2082;
    BOOL v18 = "";
    __int16 v19 = 1026;
    BOOL v20 = v5;
    __int16 v21 = 1026;
    int v22 = v7;
    __int16 v23 = 1026;
    int v24 = v8;
    __int16 v25 = 1026;
    int v26 = v9;
    __int16 v27 = 1026;
    int v28 = v10;
    __int16 v29 = 1026;
    int v30 = v11;
    __int16 v31 = 1026;
    int v32 = v12;
    __int16 v33 = 1026;
    int v34 = v13;
    __int16 v35 = 1026;
    int v36 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#EED2Cfg updated BAA settings, changed:%{public}hhd, disabled:%{public}hhd, EED enabled only:%{public}hhd, cert validty period:%{public}d, no cert request window:%{public}d, no cert retry window:%{public}d, cert available request window min:%{public}d, cert available request window max :%{public}d, cert available retry window:%{public}d}",  (uint8_t *)v16,  0x48u);
  }

  return v5;
}

uint64_t sub_100751F94@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1007825DC((uint64_t)v5);
}

void sub_100751FDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100751FF0(int *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  if (*((void *)a1 + 23))
  {
    for (uint64_t i = (uint64_t *)*((void *)a1 + 22); i; uint64_t i = (uint64_t *)*i)
    {
      if (*((char *)i + 39) < 0)
      {
        sub_1010DD48C(__dst, (void *)i[2], i[3]);
      }

      else
      {
        *(_OWORD *)__uuid_t dst = *((_OWORD *)i + 1);
        uint64_t v13 = i[4];
      }

      if (*((char *)i + 63) < 0)
      {
        sub_1010DD48C(buf, (void *)i[5], i[6]);
      }

      else
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)(i + 5);
        uint64_t v15 = i[7];
      }

      else {
        std::string v16 = *(std::string *)(i + 8);
      }
      char v17 = *((_BYTE *)i + 88);
      if (*((char *)i + 119) < 0)
      {
        sub_1010DD48C(&__p, (void *)i[12], i[13]);
      }

      else
      {
        __int128 __p = *((_OWORD *)i + 6);
        uint64_t v19 = i[14];
      }

      int v11 = __dst;
      BOOL v5 = sub_100782650(a2, (unsigned __int8 *)__dst, (uint64_t)&unk_1012CF090, (__int128 **)&v11);
      std::string::operator=((std::string *)(v5 + 40), &v16);
      if (SHIBYTE(v19) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v15) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v13) < 0) {
        operator delete(__dst[0]);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    size_t v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d, empty fPartnerInfoMap early return",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v8 = *a1;
      LODWORD(__dst[0]) = 67240192;
      HIDWORD(__dst[0]) = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d, empty fPartnerInfoMap early return",  __dst,  8);
      int v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getPartnerCertMap() const",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

void sub_100752310( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

void sub_100752384(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + sub_100708348(v2 - 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  SecCertificateRef v6 = sub_1007536D4(a1 + 25);
  if (v6)
  {
    sub_1002F0B04(buf);
    int v7 = sub_1002A6F64(*(uint64_t *)buf, "EEDUseTestCertPolicy", __p);
    if (__p[0]) {
      int v8 = v7;
    }
    else {
      int v8 = 0;
    }
    int v9 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      int v10 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = "Prod";
      int v14 = *(_DWORD *)a1;
      if (v8) {
        uint64_t v13 = "Test";
      }
      *(_DWORD *)uint64_t buf = 67240450;
      *(_DWORD *)&uint8_t buf[4] = v14;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg,inst,%{public}d,configured to use %{public}s ADR cert policy",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v38 = "Prod";
      int v39 = *(_DWORD *)a1;
      if (v8) {
        int v38 = "Test";
      }
      *(_DWORD *)__int128 __p = 67240450;
      *(_DWORD *)&__p[4] = v39;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = v38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg,inst,%{public}d,configured to use %{public}s ADR cert policy",  __p,  18);
      uint64_t v41 = (char *)v40;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const PartnerCertMap &) const",  "%s\n",  v40);
      if (v41 != buf) {
        free(v41);
      }
    }

    if (v8) {
      uint64_t v15 = @"1.2.840.113635.100.15.4";
    }
    else {
      uint64_t v15 = @"1.2.840.113635.100.15.1";
    }
    uint64_t ApplePinned = SecPolicyCreateApplePinned(@"EED", @"1.2.840.113635.100.6.2.3", v15);
    char v17 = (const void *)ApplePinned;
    if (ApplePinned)
    {
      for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
      {
        if (*((char *)i + 39) < 0)
        {
          uint64_t ApplePinned = (uint64_t)sub_1010DD48C(__p, (void *)i[2], i[3]);
        }

        else
        {
          *(_OWORD *)__int128 __p = *((_OWORD *)i + 1);
          *(void *)&__p[16] = i[4];
        }

        else {
          std::string __str = *(std::string *)(i + 5);
        }
        if (sub_100754998(ApplePinned, v17, (uint64_t)v6, (uint64_t *)__p, (uint64_t *)&__str))
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v19 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            if (__p[23] >= 0) {
              BOOL v20 = __p;
            }
            else {
              BOOL v20 = *(_BYTE **)__p;
            }
            p_str = &__str;
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)uint64_t buf = 136446466;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = p_str;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg,partner certificate is valid,partner ID,%{public}s,partner cert,%{public}s",  buf,  0x16u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            if (__p[23] >= 0) {
              int v26 = __p;
            }
            else {
              int v26 = *(_BYTE **)__p;
            }
            __int16 v27 = &__str;
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              __int16 v27 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            int v46 = 136446466;
            signed __int8 v47 = v26;
            __int16 v48 = 2082;
            size_t v49 = v27;
            LODWORD(v44) = 22;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg,partner certificate is valid,partner ID,%{public}s,partner cert,%{public}s",  &v46,  v44);
            __int16 v29 = (char *)v28;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const PartnerCertMap &) const",  "%s\n",  v28);
            if (v29 != buf) {
              free(v29);
            }
          }

          *(void *)uint64_t buf = __p;
          int v22 = sub_100782650(a3, __p, (uint64_t)&unk_1012CF090, (__int128 **)buf);
          uint64_t ApplePinned = (uint64_t)std::string::operator=((std::string *)(v22 + 40), &__str);
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          __int16 v23 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            if (__p[23] >= 0) {
              int v24 = __p;
            }
            else {
              int v24 = *(_BYTE **)__p;
            }
            __int16 v25 = &__str;
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              __int16 v25 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)uint64_t buf = 136446466;
            *(void *)&uint8_t buf[4] = v24;
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,invalid partner certificate found,partner ID,%{public}s,partner cert,%{public}s",  buf,  0x16u);
          }

          uint64_t ApplePinned = sub_1002921D0(115, 0);
          if ((_DWORD)ApplePinned)
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            if (__p[23] >= 0) {
              int v30 = __p;
            }
            else {
              int v30 = *(_BYTE **)__p;
            }
            uint64_t v31 = &__str;
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              uint64_t v31 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            int v46 = 136446466;
            signed __int8 v47 = v30;
            __int16 v48 = 2082;
            size_t v49 = v31;
            LODWORD(v44) = 22;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,invalid partner certificate found,partner ID,%{public}s,partner cert,%{public}s",  &v46,  v44);
            __int16 v33 = (char *)v32;
            uint64_t ApplePinned = sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const P artnerCertMap &) const",  "%s\n",  v32);
            if (v33 != buf) {
              free(v33);
            }
          }
        }

        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      CFRelease(v6);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      std::stringbuf::string_type v37 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,failed to create ADR cert validation policy",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)__int128 __p = 0;
        LODWORD(v44) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,failed to create ADR cert validation policy",  __p,  v44);
        int v43 = (char *)v42;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const PartnerCertMap &) const",  "%s\n",  v42);
        if (v43 != buf) {
          free(v43);
        }
      }

      char v17 = v6;
    }

    CFRelease(v17);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v34 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,unable to convert intermediate cert data to SecCertificateRef",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)__int128 __p = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,unable to convert intermediate cert data to SecCertificateRef",  __p,  2);
      int v36 = (char *)v35;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const PartnerCertMap &) const",  "%s\n",  v35);
      if (v36 != buf) {
        free(v36);
      }
    }
  }

void sub_100752CC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, char a31)
{
}

uint64_t sub_100752D3C@<X0>(int *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  LODWORD(v25) = 1065353216;
  SecCertificateRef v6 = sub_100121918(v26, a2);
  int v7 = v6;
  if (v6)
  {
    *(void *)uint64_t buf = v6 + 16;
    int v8 = sub_100782650((uint64_t)&v23, v6 + 16, (uint64_t)&unk_1012CF090, (__int128 **)buf);
    std::string::operator=((std::string *)(v8 + 40), (const std::string *)(v7 + 40));
    sub_100752384((uint64_t *)a1, (uint64_t)&v23, (uint64_t)v30);
    if (v33)
    {
      *(void *)uint64_t buf = a2;
      int v9 = sub_100782650((uint64_t)v30, a2, (uint64_t)&unk_1012CF090, (__int128 **)buf);
      if ((char)v9[63] < 0)
      {
        sub_1010DD48C((_BYTE *)a3, *((void **)v9 + 5), *((void *)v9 + 6));
      }

      else
      {
        __int128 v10 = *(_OWORD *)(v9 + 40);
        *(void *)(a3 + sub_100708348(v2 - 16) = *((void *)v9 + 7);
        *(_OWORD *)a3 = v10;
      }
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v14 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        int v15 = *a1;
        *(_DWORD *)uint64_t buf = 67240448;
        *(_DWORD *)&uint8_t buf[4] = v15;
        __int16 v35 = 2048;
        int v36 = (unsigned __int8 *)v33;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,getValidatedCertForPartner,validatedCertMap size:%lu,early return",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v20 = *a1;
        v27[0] = 67240448;
        v27[1] = v20;
        __int16 v28 = 2048;
        __int16 v29 = v33;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,getValidatedCertForPartner,validatedCertMap size:%lu,early return",  v27,  18,  v23,  v24,  v25);
        int v22 = (uint8_t *)v21;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::string CLEmergencyEED2::SimConfig::getValidatedCertForPartner(std::string) const",  "%s\n",  v21);
        if (v22 != buf) {
          free(v22);
        }
      }

      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a3 + sub_100708348(v2 - 16) = 0LL;
    }

    sub_1007825DC((uint64_t)v30);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unint64_t v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *a1;
      uint64_t v13 = a2;
      *(_DWORD *)uint64_t buf = 67240450;
      *(_DWORD *)&uint8_t buf[4] = v12;
      __int16 v35 = 2080;
      int v36 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,getValidatedCertForPartner,cert not found for partner: %s,early return",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v17 = *a1;
      v30[0] = 67240450;
      v30[1] = v17;
      __int16 v31 = 2080;
      int v32 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,getValidatedCertForPartner,cert not found for partner: %s,early return",  v30,  18,  v23,  v24,  v25);
      uint64_t v19 = (uint8_t *)v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::string CLEmergencyEED2::SimConfig::getValidatedCertForPartner(std::string) const",  "%s\n",  v18);
      if (v19 != buf) {
        free(v19);
      }
    }

    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + sub_100708348(v2 - 16) = 0LL;
  }

  sub_1007825DC((uint64_t)&v23);
  return sub_1007825DC((uint64_t)v26);
}

void sub_100753190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);
  sub_1007825DC((uint64_t)va2);
  sub_1007825DC((uint64_t)va);
  sub_1007825DC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007531D4(uint64_t a1)
{
  return a1;
}

void sub_100753224(int *a1, unsigned __int8 *a2, std::string *a3, void *a4)
{
  SecCertificateRef v8 = sub_1007536D4((uint64_t *)a3);
  if (v8)
  {
    CFRelease(v8);
    if (sub_10023BD04(a4, a2))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        int v10 = *a1;
        if ((a2[23] & 0x80u) == 0) {
          unint64_t v11 = (uint64_t *)a2;
        }
        else {
          unint64_t v11 = *(uint64_t **)a2;
        }
        *(_DWORD *)uint64_t buf = 67240450;
        *(_DWORD *)&uint8_t buf[4] = v10;
        __int16 v33 = 2080;
        int v34 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v12 = qword_101934898;
        int v13 = *a1;
        if ((a2[23] & 0x80u) == 0) {
          uint64_t v14 = (uint64_t *)a2;
        }
        else {
          uint64_t v14 = *(uint64_t **)a2;
        }
        LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 67240450;
        HIDWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v13;
        LOWORD(v31) = 2080;
        *(void *)((char *)&v31 + 2) = v14;
        uint64_t v15 = "#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s";
LABEL_31:
        uint64_t v21 = 2LL;
LABEL_47:
        _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v12, v21, v15, &v30, 18, v30, v31);
        __int16 v29 = (uint8_t *)v28;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::addPartnerCert(const std::string &, const std::string &, PartnerCertMap &)",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }
    }

    else
    {
      *(void *)uint64_t buf = a2;
      int v22 = sub_100782650((uint64_t)a4, a2, (uint64_t)&unk_1012CF090, (__int128 **)buf);
      std::string::operator=((std::string *)(v22 + 40), a3);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int128 v23 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *a1;
        if ((a2[23] & 0x80u) == 0) {
          uint64_t v25 = (uint64_t *)a2;
        }
        else {
          uint64_t v25 = *(uint64_t **)a2;
        }
        *(_DWORD *)uint64_t buf = 67240451;
        *(_DWORD *)&uint8_t buf[4] = v24;
        __int16 v33 = 2081;
        int v34 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#EED2Cfg,inst,%{public}d,added cert for partner %{private}s",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v12 = qword_101934898;
        int v26 = *a1;
        if ((a2[23] & 0x80u) == 0) {
          __int16 v27 = (uint64_t *)a2;
        }
        else {
          __int16 v27 = *(uint64_t **)a2;
        }
        LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 67240451;
        HIDWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v26;
        LOWORD(v31) = 2081;
        *(void *)((char *)&v31 + 2) = v27;
        uint64_t v15 = "#EED2Cfg,inst,%{public}d,added cert for partner %{private}s";
        uint64_t v21 = 0LL;
        goto LABEL_47;
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v16 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v17 = *a1;
      if ((a2[23] & 0x80u) == 0) {
        uint64_t v18 = (uint64_t *)a2;
      }
      else {
        uint64_t v18 = *(uint64_t **)a2;
      }
      *(_DWORD *)uint64_t buf = 67240451;
      *(_DWORD *)&uint8_t buf[4] = v17;
      __int16 v33 = 2081;
      int v34 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v12 = qword_101934898;
      int v19 = *a1;
      if ((a2[23] & 0x80u) == 0) {
        int v20 = (uint64_t *)a2;
      }
      else {
        int v20 = *(uint64_t **)a2;
      }
      LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 67240451;
      HIDWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v19;
      LOWORD(v31) = 2081;
      *(void *)((char *)&v31 + 2) = v20;
      uint64_t v15 = "#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s";
      goto LABEL_31;
    }
  }

SecCertificateRef sub_1007536D4(uint64_t *a1)
{
  char v2 = objc_alloc(&OBJC_CLASS___NSData);
  else {
    int v3 = (uint64_t *)*a1;
  }
  uint64_t v4 = -[NSData initWithBase64EncodedString:options:]( v2,  "initWithBase64EncodedString:options:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3),  0LL);
  BOOL v5 = (const __CFData *)v4;
  if (v4 && -[NSData length](v4, "length"))
  {
    SecCertificateRef v6 = SecCertificateCreateWithData(0LL, v5);

    return v6;
  }

  else
  {

    return 0LL;
  }

uint64_t sub_100753764@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_10000CF44(&v26, (uint64_t)"partnerID,", 10LL);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  SecCertificateRef v8 = sub_10000CF44(v4, v6, v7);
  uint64_t v9 = sub_10000CF44(v8, (uint64_t)",requestsSupported,", 19LL);
  int v10 = (void *)std::ostream::operator<<(v9, *(unsigned __int8 *)(a1 + 48));
  unint64_t v11 = sub_10000CF44(v10, (uint64_t)",baseURL,", 9LL);
  int v12 = *(char *)(a1 + 79);
  if (v12 >= 0) {
    uint64_t v13 = a1 + 56;
  }
  else {
    uint64_t v13 = *(void *)(a1 + 56);
  }
  if (v12 >= 0) {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 79);
  }
  else {
    uint64_t v14 = *(void *)(a1 + 64);
  }
  uint64_t v15 = sub_10000CF44(v11, v13, v14);
  uint64_t v16 = sub_10000CF44(v15, (uint64_t)",adrCert,", 9LL);
  uint64_t v19 = *(void *)(a1 + 24);
  uint64_t v18 = a1 + 24;
  uint64_t v17 = v19;
  int v20 = *(char *)(v18 + 23);
  if (v20 >= 0) {
    uint64_t v21 = v18;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v20 >= 0) {
    uint64_t v22 = *(unsigned __int8 *)(v18 + 23);
  }
  else {
    uint64_t v22 = *(void *)(v18 + 8);
  }
  sub_10000CF44(v16, v21, v22);
  std::stringbuf::str(a2, &v27);
  *(void *)((char *)v25
  uint64_t v26 = v23;
  std::streambuf::~streambuf(&v27);
  return std::ios::~ios(&v28);
}

void sub_1007538BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1007538D0(int *a1, uint64_t a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2Cfg,readPartnerInfoDefault,partner info default overriding certs and other partner info from other sources",  (uint8_t *)buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v39) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2Cfg,readPartnerInfoDefault,partner info default overriding certs and other partner info from other sources",  &v39,  2);
    uint64_t v30 = (std::string *)v29;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerInfoDefault(CLNameValuePair &)",  "%s\n",  v29);
    if (v30 != buf) {
      free(v30);
    }
  }

  sub_100782588((uint64_t)(a1 + 40));
  int v39 = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  if ((sub_1002A6CEC(a2, (uint64_t *)&v39) & 1) != 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *a1;
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240448;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v6;
      LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = -1431655765
                                                                    * ((unint64_t)((char *)v40 - (char *)v39) >> 3);
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg,inst,%{public}d,readPartnerInfoDefault,reading %{public}d partner certs from default",  (uint8_t *)buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v31 = *a1;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67240448;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v31;
      LOWORD(__p.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = -1431655765
                                                                 * ((unint64_t)((char *)v40 - (char *)v39) >> 3);
      LODWORD(v37) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg,inst,%{public}d,readPartnerInfoDefault,reading %{public}d partner certs from default",  &__p,  v37);
      __int16 v33 = (std::string *)v32;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerInfoDefault(CLNameValuePair &)",  "%s\n",  v32);
      if (v33 != buf) {
        free(v33);
      }
    }

    uint64_t v7 = v39;
    for (uint64_t i = v40; v7 != i; ++v7)
    {
      sub_1002A5370(v38);
      uint64_t v9 = (const char *)v7;
      if (sub_1002A8F8C(a2, v9, v38))
      {
        memset(&__p, 0, sizeof(__p));
        if (byte_1019A263F >= 0) {
          int v10 = (const char *)&qword_1019A2628;
        }
        else {
          int v10 = (const char *)qword_1019A2628;
        }
        if (sub_1002A8560((uint64_t)v38, v10, &__p))
        {
          LOBYTE(v42[0]) = 1;
          if (byte_1019A2657 >= 0) {
            unint64_t v11 = (const char *)&qword_1019A2640;
          }
          else {
            unint64_t v11 = (const char *)qword_1019A2640;
          }
          sub_1002A6F64((uint64_t)v38, v11, (BOOL *)v42);
          sub_1010DDBC0(buf, "");
          if (byte_1019A266F >= 0) {
            int v12 = (const char *)&qword_1019A2658;
          }
          else {
            int v12 = (const char *)qword_1019A2658;
          }
          sub_1002A8560((uint64_t)v38, v12, buf);
          sub_100751750(a1, v7, &__p, v42[0], buf);
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v20 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            std::string::size_type v21 = (std::string::size_type)v7;
            int v22 = *a1;
            LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240451;
            HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v22;
            LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2081;
            *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to read cert data for partner %{private}s",  (uint8_t *)buf,  0x12u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            int v23 = *a1;
            int v24 = v7;
            v42[0] = 67240451;
            v42[1] = v23;
            __int16 v43 = 2081;
            uint64_t v44 = v24;
            LODWORD(v37) = 18;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to read cert data for partner %{private}s",  v42,  v37);
            uint64_t v26 = (std::string *)v25;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerInfoDefault(CLNameValuePair &)",  "%s\n",  v25);
            if (v26 != buf) {
              free(v26);
            }
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v13 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          std::string::size_type v14 = (std::string::size_type)v7;
          int v15 = *a1;
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240451;
          HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v15;
          LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2081;
          *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to readpartner info for partner %{private}s",  (uint8_t *)buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v16 = *a1;
          std::string::size_type v17 = (std::string::size_type)v7;
          LODWORD(__p.__r_.__value_.__l.__data_) = 67240451;
          HIDWORD(__p.__r_.__value_.__r.__words[0]) = v16;
          LOWORD(__p.__r_.__value_.__r.__words[1]) = 2081;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = v17;
          LODWORD(v37) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to readpartner info for partner %{private}s",  &__p,  v37);
          uint64_t v19 = (std::string *)v18;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerInfoDefault(CLNameValuePair &)",  "%s\n",  v18);
          if (v19 != buf) {
            free(v19);
          }
        }
      }

      sub_1002A5590(v38);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    std::stringbuf v27 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v28 = *a1;
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to retrieve partner IDs from default",  (uint8_t *)buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v34 = *a1;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v34;
      LODWORD(v37) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,readPartnerInfoDefault,unable to retrieve partner IDs from default",  &__p,  v37);
      int v36 = (std::string *)v35;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerInfoDefault(CLNameValuePair &)",  "%s\n",  v35);
      if (v36 != buf) {
        free(v36);
      }
    }
  }

  buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
  sub_1000129D4((void ***)buf);
}

void sub_100754198( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, char *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  a30 = &a15;
  sub_1000129D4((void ***)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_100754218(int *a1, void *a2)
{
  BOOL v4 = sub_1002A8F8C(*(uint64_t *)buf, "EEDPartnerCerts", v37);
  BOOL v5 = v4;
  int v6 = (std::__shared_weak_count *)v43[0];
  if (!v43[0]) {
    goto LABEL_5;
  }
  uint64_t v7 = (unint64_t *)(v43[0] + 8LL);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v5) {
      return sub_1002A5590(v37);
    }
  }

  else
  {
LABEL_5:
    if (!v4) {
      return sub_1002A5590(v37);
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v9 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2Cfg,partner certificate default overriding certs from other sources",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v34) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2Cfg,partner certificate default overriding certs from other sources",  &v34,  2);
    uint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerCertDefault(PartnerCertMap &)",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  sub_100782D14((uint64_t)a2);
  uint64_t v34 = 0LL;
  uint64_t v35 = 0LL;
  uint64_t v36 = 0LL;
  if ((sub_1002A6CEC((uint64_t)v37, &v34) & 1) != 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *a1;
      *(_DWORD *)uint64_t buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v11;
      LOWORD(v43[0]) = 1026;
      *(_DWORD *)((char *)v43 + 2) = -1431655765 * ((unint64_t)(v35 - v34) >> 3);
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg,inst,%{public}d,reading %{public}d partner certs from default",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v27 = *a1;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67240448;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v27;
      LOWORD(__p.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = -1431655765 * ((unint64_t)(v35 - v34) >> 3);
      LODWORD(v33) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg,inst,%{public}d,reading %{public}d partner certs from default",  &__p,  v33);
      __int16 v29 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerCertDefault(PartnerCertMap &)",  "%s\n",  v28);
      if (v29 != buf) {
        free(v29);
      }
    }

    uint64_t v12 = v34;
    for (uint64_t i = v35; v12 != i; v12 += 24LL)
    {
      memset(&__p, 0, sizeof(__p));
      std::string::size_type v14 = (const char *)v12;
      if (sub_1002A8560((uint64_t)v37, v14, &__p))
      {
        sub_100753224(a1, (unsigned __int8 *)v12, &__p, a2);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v15 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          int v16 = (const char *)v12;
          int v17 = *a1;
          *(_DWORD *)uint64_t buf = 67240451;
          *(_DWORD *)&uint8_t buf[4] = v17;
          LOWORD(v43[0]) = 2081;
          *(void *)((char *)v43 + 2) = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,unable to read cert data for partner %{private}s",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v18 = *a1;
          uint64_t v19 = (const char *)v12;
          v38[0] = 67240451;
          v38[1] = v18;
          __int16 v39 = 2081;
          uint64_t v40 = v19;
          LODWORD(v33) = 18;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,unable to read cert data for partner %{private}s",  v38,  v33);
          std::string::size_type v21 = (uint8_t *)v20;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerCertDefault(PartnerCertMap &)",  "%s\n",  v20);
          if (v21 != buf) {
            free(v21);
          }
        }
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v22 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v23 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "#Warning #EED2Cfg,inst,%{public}d,unable to retrieve partner IDs from default",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v30 = *a1;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v30;
      LODWORD(v33) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#Warning #EED2Cfg,inst,%{public}d,unable to retrieve partner IDs from default",  &__p,  v33);
      int v32 = (uint8_t *)v31;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::SimConfig::readPartnerCertDefault(PartnerCertMap &)",  "%s\n",  v31);
      if (v32 != buf) {
        free(v32);
      }
    }
  }

  *(void *)uint64_t buf = &v34;
  sub_1000129D4((void ***)buf);
  return sub_1002A5590(v37);
}

void sub_100754928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, char *a30)
{
  a30 = &a13;
  sub_1000129D4((void ***)&a30);
  sub_1002A5590(&a17);
  _Unwind_Resume(a1);
}

BOOL sub_100754998(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  SecCertificateRef v8 = sub_1007536D4(a5);
  if (v8)
  {
    uint64_t v9 = v8;
    id v10 = [(id)SecCertificateCopyCommonNames() objectAtIndexedSubscript:0];
    else {
      int v11 = (uint64_t *)*a4;
    }
    if ((objc_msgSend( v10,  "isEqualToString:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11)) & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v25 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        else {
          uint64_t v26 = (uint64_t *)*a4;
        }
        *(_DWORD *)uint64_t buf = 136446466;
        __int16 v60 = v26;
        __int16 v61 = 2082;
        *(void *)__int16 v62 = [v10 UTF8String];
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,partner ID does not match common name in cert,partner ID,%{public}s,common name,%{public}s",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v38 = qword_101934898;
        int v52 = 136446466;
        float v53 = a4;
        __int16 v54 = 2082;
        *(void *)int v55 = [v10 UTF8String];
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v38,  16LL,  "#EED2Cfg,partner ID does not match common name in cert,partner ID,%{public}s,common name,%{public}s",  &v52,  22);
        uint64_t v40 = (uint8_t *)v39;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::SimConfig::validatePartnerCertificate(SecPolicyRef, SecCertificateRef, const std::string &, const std::string &) const",  "%s\n",  v39);
        if (v40 != buf) {
          free(v40);
        }
      }

      SecTrustRef v27 = v9;
      goto LABEL_55;
    }

    v58[0] = v9;
    v58[1] = a3;
    uint64_t v12 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v58, 2LL);
    CFRelease(v9);
    SecTrustRef trust = 0LL;
    OSStatus v13 = SecTrustCreateWithCertificates(v12, a2, &trust);
    if (v13)
    {
      OSStatus v14 = v13;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v15 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        else {
          int v16 = (uint64_t *)*a4;
        }
        *(_DWORD *)uint64_t buf = 136446466;
        __int16 v60 = v16;
        __int16 v61 = 1026;
        *(_DWORD *)__int16 v62 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,failed to create trust object when validating ADR cert,partner ID,%{public}s,err,%{public}d",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        else {
          int v17 = (uint64_t *)*a4;
        }
        int v52 = 136446466;
        float v53 = v17;
        __int16 v54 = 1026;
        *(_DWORD *)int v55 = v14;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,failed to create trust object when validating ADR cert,partner ID,%{public}s,err,%{public}d",  &v52,  18);
LABEL_80:
        uint64_t v42 = (uint8_t *)v18;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::SimConfig::validatePartnerCertificate(SecPolicyRef, SecCertificateRef, const std::string &, const std::string &) const",  "%s\n",  v18);
        if (v42 != buf) {
          free(v42);
        }
      }
    }

    else
    {
      OSStatus Allowed = SecTrustSetNetworkFetchAllowed(trust, 0);
      if (!Allowed)
      {
        CFErrorRef error = 0LL;
        BOOL v21 = SecTrustEvaluateWithError(trust, &error);
        CFRelease(trust);
        if (!error) {
          return v21;
        }
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v33 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          else {
            uint64_t v34 = (uint64_t *)*a4;
          }
          unsigned int v35 = -[__CFError code](error, "code");
          id v36 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
          id v37 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
          *(_DWORD *)uint64_t buf = 136446978;
          __int16 v60 = v34;
          __int16 v61 = 1026;
          *(_DWORD *)__int16 v62 = v35;
          *(_WORD *)&v62[4] = 2082;
          *(void *)&v62[6] = v36;
          __int16 v63 = 2082;
          id v64 = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,ADR certificate validation failed,partner ID,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s",  buf,  0x26u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v43 = qword_101934898;
          else {
            uint64_t v44 = (uint64_t *)*a4;
          }
          unsigned int v45 = -[__CFError code](error, "code");
          id v46 = objc_msgSend(-[__CFError domain](error, "domain"), "UTF8String");
          id v47 = objc_msgSend(-[__CFError localizedDescription](error, "localizedDescription"), "UTF8String");
          int v52 = 136446978;
          float v53 = v44;
          __int16 v54 = 1026;
          *(_DWORD *)int v55 = v45;
          *(_WORD *)&v55[4] = 2082;
          *(void *)&v55[6] = v46;
          __int16 v56 = 2082;
          id v57 = v47;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v43,  16LL,  "#EED2Cfg,ADR certificate validation failed,partner ID,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s",  &v52,  38);
          size_t v49 = (uint8_t *)v48;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::SimConfig::validatePartnerCertificate(SecPolicyRef, SecCertificateRef, const std::stri ng &, const std::string &) const",  "%s\n",  v48);
          if (v49 != buf) {
            free(v49);
          }
        }

        return 0LL;
      }

      OSStatus v29 = Allowed;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v30 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        else {
          int v31 = (uint64_t *)*a4;
        }
        *(_DWORD *)uint64_t buf = 136446466;
        __int16 v60 = v31;
        __int16 v61 = 1026;
        *(_DWORD *)__int16 v62 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,failed to disable network use for trust eval,partner ID,%{public}s,err,%{public}d",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        else {
          uint64_t v41 = (uint64_t *)*a4;
        }
        int v52 = 136446466;
        float v53 = v41;
        __int16 v54 = 1026;
        *(_DWORD *)int v55 = v29;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,failed to disable network use for trust eval,partner ID,%{public}s,err,%{public}d",  &v52,  18);
        goto LABEL_80;
      }
    }

    SecTrustRef v27 = trust;
    if (!trust) {
      return 0LL;
    }
LABEL_55:
    CFRelease(v27);
    return 0LL;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v19 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    else {
      int v20 = (uint64_t *)*a4;
    }
    *(_DWORD *)uint64_t buf = 136446210;
    __int16 v60 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "#EED2Cfg,unable to convert partner cert data to SecCertificateRef,partner ID,%{public}s",  buf,  0xCu);
  }

  BOOL v21 = 0LL;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    else {
      int v22 = (uint64_t *)*a4;
    }
    int v52 = 136446210;
    float v53 = v22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg,unable to convert partner cert data to SecCertificateRef,partner ID,%{public}s",  &v52,  12);
    int v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::SimConfig::validatePartnerCertificate(SecPolicyRef, SecCertificateRef, const std::string &, const std::string &) const",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
    return 0LL;
  }

  return v21;
}

uint64_t sub_100755298(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 5) = 0u;
  char v2 = (BOOL *)(a1 + 5);
  *(_BYTE *)(a1 + 4) = 1;
  uint64_t v3 = a1 + 8;
  *(_OWORD *)(a1 + 21) = 0u;
  *(void *)(a1 + 36) = 0x3F80000000000000LL;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  uint64_t v4 = a1 + 48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 8sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1065353216;
  int v27 = 0;
  sub_10075030C((uint64_t)v26, 0);
  sub_100781D54((uint64_t)buf, &v27, (uint64_t)v26);
  sub_100782DDC(v3, (int *)buf, (uint64_t)buf);
  sub_100781E94((uint64_t)v29);
  sub_100781E94((uint64_t)v26);
  int v27 = 0;
  sub_10075030C((uint64_t)v26, 0);
  sub_100781D54((uint64_t)buf, &v27, (uint64_t)v26);
  sub_100782DDC(v4, (int *)buf, (uint64_t)buf);
  sub_100781E94((uint64_t)v29);
  sub_100781E94((uint64_t)v26);
  if (sub_1004FAACC())
  {
    int v27 = 1;
    sub_10075030C((uint64_t)v26, 1);
    sub_100781D54((uint64_t)buf, &v27, (uint64_t)v26);
    sub_100782DDC(v3, (int *)buf, (uint64_t)buf);
    sub_100781E94((uint64_t)v29);
    sub_100781E94((uint64_t)v26);
    int v27 = 1;
    sub_10075030C((uint64_t)v26, 1);
    sub_100781D54((uint64_t)buf, &v27, (uint64_t)v26);
    sub_100782DDC(v4, (int *)buf, (uint64_t)buf);
    sub_100781E94((uint64_t)v29);
    sub_100781E94((uint64_t)v26);
  }

  LOBYTE(v27) = 0;
  sub_1002F0B04(buf);
  int v5 = sub_1002A6F64(*(uint64_t *)buf, "GpsSimulatorTestMode", (BOOL *)&v27);
  if ((_BYTE)v27) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  uint64_t v7 = (std::__shared_weak_count *)v29[0];
  if (!v29[0]) {
    goto LABEL_10;
  }
  SecCertificateRef v8 = (unint64_t *)(v29[0] + 8LL);
  do
    unint64_t v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v6) {
      goto LABEL_16;
    }
  }

  else
  {
LABEL_10:
    if (!v6) {
      goto LABEL_16;
    }
  }

  *(_BYTE *)(a1 + 6) = 1;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v10 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2Cfg EED2 is disabled due to simulator mode",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v26[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2Cfg EED2 is disabled due to simulator mode",  v26,  2);
    int v22 = (uint8_t *)v21;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyEED2::Config::Config()", "%s\n", v21);
    if (v22 != buf) {
      free(v22);
    }
  }

void sub_10075580C(_Unwind_Exception *a1)
{
}

uint64_t sub_10075588C(uint64_t a1, int *a2)
{
  int v4 = *a2;
  HIDWORD(v15) = v4;
  *(_DWORD *)uint64_t buf = v4;
  int v5 = (void *)(a1 + 8);
  if (sub_100781F1C((void *)(a1 + 8), (int *)buf)
    && (*(_DWORD *)buf = v4, int v6 = (void *)(a1 + 48), sub_100781F1C(v6, (int *)buf)))
  {
    uint64_t v7 = sub_100781F1C(v6, (int *)&v15 + 1);
    if (!v7
      || (BOOL v8 = sub_100751290( (uint64_t)(v7 + 3),  (unsigned __int8 *)a2 + 608,  (std::string *)(a2 + 266),  (const std::string *)(a2 + 272)),  (v9 = sub_100781F1C(v5, (int *)&v15 + 1)) == 0LL))
    {
      sub_10000C918("unordered_map::at: key not found");
    }

    return v8 | sub_100751290( (uint64_t)(v9 + 3),  (unsigned __int8 *)a2 + 272,  (std::string *)(a2 + 278),  (const std::string *)(a2 + 284));
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v18 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "#EED2Cfg ignoring emergency settings for unexpected inst %{public}d",  buf,  8u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v16[0] = 67240192;
      v16[1] = v4;
      LODWORD(v15) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg ignoring emergency settings for unexpected inst %{public}d",  v16,  v15);
      OSStatus v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::Config::updateEmergencySettings(const CLEmergencyController::LocationSettings &)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100755ADC(int *a1, int a2)
{
  if (a2 == 255 || *a1 == a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v21 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg keeping previous active inst %{public}d",  buf,  8u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v13 = *a1;
    int v18 = 67240192;
    int v19 = v13;
    double v14 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg keeping previous active inst %{public}d",  &v18,  8);
    BOOL v12 = v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v14);
LABEL_27:
    if (v12 != buf) {
      free(v12);
    }
    return 0LL;
  }

  *(_DWORD *)uint64_t buf = a2;
  if (sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    *a1 = a2;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg active inst changed to %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v18 = 67240192;
      int v19 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg active inst changed to %{public}d",  &v18,  8);
      int v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    return 1LL;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    BOOL v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#EED2Cfg ignoring unexpected inst %{public}d",  buf,  8u);
    }

    BOOL v9 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v9)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v18 = 67240192;
      int v19 = a2;
      double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg ignoring unexpected inst %{public}d",  &v18,  8);
      BOOL v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v10);
      goto LABEL_27;
    }
  }

  return result;
}

uint64_t sub_100755F4C(uint64_t a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  HIDWORD(v1_Block_object_dispose(va, 8) = a2;
  *(_DWORD *)uint64_t buf = a2;
  BOOL v8 = (void *)(a1 + 8);
  if (sub_100781F1C((void *)(a1 + 8), (int *)buf)
    && (*(_DWORD *)buf = a2, BOOL v9 = (void *)(a1 + 48), sub_100781F1C(v9, (int *)buf)))
  {
    double v10 = sub_100781F1C(v9, (int *)&v18 + 1);
    return v11 | sub_100751DA4((uint64_t)(v12 + 3), a3);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    double v14 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "#EED2Cfg ignoring BAA settings for unexpected inst %{public}d",  buf,  8u);
    }

    BOOL v15 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v15)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v19[0] = 67240192;
      v19[1] = a2;
      LODWORD(v1_Block_object_dispose(va, 8) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg ignoring BAA settings for unexpected inst %{public}d",  v19,  v18);
      int v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::Config::updateBaaSettings(const SimInstance, const BAASettings &, const BAASettings &)",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100756190(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  *(_DWORD *)uint64_t buf = *(_DWORD *)a1;
  if (sub_100781F1C((void *)(a1 + 8), (int *)buf))
  {
    uint64_t v3 = sub_100781F1C(v2, (int *)a1);
    if (!v3) {
      sub_10000C918("unordered_map::at: key not found");
    }
    if (!*((_BYTE *)v3 + 80) || !*(_BYTE *)(a1 + 4) || *(_BYTE *)(a1 + 6)) {
      return 0LL;
    }
    return *(_BYTE *)(a1 + 7) == 0;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v6 = *(_DWORD *)a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v13 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2Cfg unexpected inst %{public}d is active",  buf,  8u);
    }

    BOOL v7 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v7)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v8 = *(_DWORD *)a1;
      v11[0] = 67240192;
      v11[1] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg unexpected inst %{public}d is active",  v11,  8);
      double v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::Config::isEnabled() const", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1007563B0(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 24);
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  char v4 = 0;
  if (v2)
  {
    int v5 = &qword_101934890;
    int v6 = &stru_10184E040;
    do
    {
      if (*((_BYTE *)v2 + 80)
        && *(_BYTE *)(a1 + 4)
        && !*(_BYTE *)(a1 + 6)
        && !*(_BYTE *)(a1 + 7)
        && *((_BYTE *)v2 + 81)
        && v2[26])
      {
        if (*((char *)v2 + 247) < 0)
        {
          if (v2[29])
          {
LABEL_15:
            if (p_vtable[274] == (void *)-1LL)
            {
              BOOL v7 = v6;
              int v8 = v5;
            }

            else
            {
              int v8 = v5;
              BOOL v7 = v6;
              dispatch_once(v5, v6);
            }

            BOOL v9 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              int v10 = *((_DWORD *)v2 + 4);
              *(_DWORD *)uint64_t buf = 67240192;
              LODWORD(v32) = v10;
              _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2Cfg EED enabled for sim %{public}d operator",  buf,  8u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(v8, v7);
              }
              int v11 = *((_DWORD *)v2 + 4);
              int v29 = 67240192;
              LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v11;
              LODWORD(v2_Block_object_dispose(va, 8) = 8;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2Cfg EED enabled for sim %{public}d operator",  &v29,  v28);
              int v13 = (uint8_t *)v12;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::Config::shouldDisplayEEDUI() const",  "%s\n",  v12);
              if (v13 != buf) {
                free(v13);
              }
            }

            char v4 = 1;
            int v5 = v8;
            int v6 = v7;
            p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          }
        }

        else if (*((_BYTE *)v2 + 247))
        {
          goto LABEL_15;
        }
      }

      uint64_t v2 = (uint64_t *)*v2;
    }

    while (v2);
  }

  double v14 = *(uint64_t **)(a1 + 64);
  if (v14)
  {
    BOOL v15 = &stru_10184E040;
    do
    {
      if (*((_BYTE *)v14 + 80)
        && *(_BYTE *)(a1 + 4)
        && !*(_BYTE *)(a1 + 6)
        && !*(_BYTE *)(a1 + 7)
        && *((_BYTE *)v14 + 81)
        && v14[26])
      {
        if (*((char *)v14 + 247) < 0)
        {
          if (v14[29])
          {
LABEL_40:
            int v16 = v15;
            int v17 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              int v18 = *((_DWORD *)v14 + 4);
              *(_DWORD *)uint64_t buf = 67240192;
              LODWORD(v32) = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#EED2Cfg EED enabled for sim %{public}d carrier",  buf,  8u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              int v19 = *((_DWORD *)v14 + 4);
              int v29 = 67240192;
              LODWORD(v3sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v19;
              LODWORD(v2_Block_object_dispose(va, 8) = 8;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2Cfg EED enabled for sim %{public}d carrier",  &v29,  v28);
              int v21 = (uint8_t *)v20;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::Config::shouldDisplayEEDUI() const",  "%s\n",  v20);
              if (v21 != buf) {
                free(v21);
              }
            }

            char v4 = 1;
            BOOL v15 = v16;
          }
        }

        else if (*((_BYTE *)v14 + 247))
        {
          goto LABEL_40;
        }
      }

      double v14 = (uint64_t *)*v14;
    }

    while (v14);
  }

  int v22 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = "not be displayed";
    if ((v4 & 1) != 0) {
      int v23 = "be displayed";
    }
    *(_DWORD *)uint64_t buf = 136446210;
    int v32 = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#EED2Cfg EED UI should %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    uint64_t v25 = "not be displayed";
    if ((v4 & 1) != 0) {
      uint64_t v25 = "be displayed";
    }
    int v29 = 136446210;
    int v30 = v25;
    LODWORD(v2_Block_object_dispose(va, 8) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2Cfg EED UI should %{public}s",  &v29,  v28);
    int v27 = (uint8_t *)v26;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::Config::shouldDisplayEEDUI() const", "%s\n", v26);
    if (v27 != buf) {
      free(v27);
    }
  }

  return v4 & 1;
}

uint64_t sub_100756950(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 24);
  for (i = 0; v2; uint64_t v2 = (uint64_t *)*v2)
  {
    if (!*((_BYTE *)v2 + 420) && (!*((_BYTE *)v2 + 421) || *((_BYTE *)v2 + 80)))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        int v5 = *((_DWORD *)v2 + 4);
        *(_DWORD *)uint64_t buf = 67240192;
        LODWORD(v25) = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg BAA enabled for sim %{public}d operator",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v6 = *((_DWORD *)v2 + 4);
        int v22 = 67240192;
        LODWORD(v23) = v6;
        LODWORD(v21) = 8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg BAA enabled for sim %{public}d operator",  &v22,  v21);
        int v8 = (uint8_t *)v7;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::Config::shouldRequestBaaCerts() const", "%s\n", v7);
        if (v8 != buf) {
          free(v8);
        }
      }

      char i = 1;
    }
  }

  for (j = *(uint64_t **)(a1 + 64); j; j = (uint64_t *)*j)
  {
    if (!*((_BYTE *)j + 420) && (!*((_BYTE *)j + 421) || *((_BYTE *)j + 80)))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        int v11 = *((_DWORD *)j + 4);
        *(_DWORD *)uint64_t buf = 67240192;
        LODWORD(v25) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg BAA enabled for sim %{public}d carrier",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v12 = *((_DWORD *)j + 4);
        int v22 = 67240192;
        LODWORD(v23) = v12;
        LODWORD(v21) = 8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg BAA enabled for sim %{public}d carrier",  &v22,  v21);
        double v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::Config::shouldRequestBaaCerts() const",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }

      char i = 1;
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  BOOL v15 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    int v16 = "disabled";
    if ((i & 1) != 0) {
      int v16 = "enabled";
    }
    *(_DWORD *)uint64_t buf = 136446210;
    uint64_t v25 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "#EED2Cfg BAA cert requests %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v18 = "disabled";
    if ((i & 1) != 0) {
      int v18 = "enabled";
    }
    int v22 = 136446210;
    int v23 = v18;
    LODWORD(v21) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2Cfg BAA cert requests %{public}s",  &v22,  v21);
    int v20 = (uint8_t *)v19;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::Config::shouldRequestBaaCerts() const", "%s\n", v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  return i & 1;
}

uint64_t *sub_100756E48(int *a1)
{
  uint64_t v2 = a1 + 2;
  *(_DWORD *)uint64_t buf = *a1;
  if (!sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)uint64_t buf = 67240192;
      int v12 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#EED2Cfg EED2 config for inst %{public}d wasn't created on construction",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v7 = *a1;
      v10[0] = 67240192;
      v10[1] = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg EED2 config for inst %{public}d wasn't created on construction",  v10,  8);
      BOOL v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getOperatorSimConfig() const",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  int v5 = sub_100781F1C(v2, a1);
  if (!v5) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return v5 + 3;
}

uint64_t *sub_100757034(uint64_t a1, int a2, uint64_t *a3)
{
  HIDWORD(v15) = a2;
  int v3 = *((char *)a3 + 23);
  if (v3 < 0)
  {
    if (a3[1] != 7)
    {
LABEL_10:
      *(_DWORD *)uint64_t buf = a2;
      int v5 = (void *)(a1 + 8);
      if (!sub_100781F1C((void *)(a1 + 8), (int *)buf))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v6 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 67240192;
          int v19 = HIDWORD(v15);
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#EED2Cfg EED2 operator config for inst %{public}d wasn't created on construction",  buf,  8u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v16 = 67240192;
          int v17 = HIDWORD(v15);
          LODWORD(v15) = 8;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg EED2 operator config for inst %{public}d wasn't created on construction",  &v16,  v15);
          int v12 = (uint8_t *)v11;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getSimConfig(SimInstance, std::string) const",  "%s\n",  v11);
          if (v12 != buf) {
            free(v12);
          }
        }
      }

      int v7 = sub_100781F1C(v5, (int *)&v15 + 1);
      if (!v7) {
        sub_10000C918("unordered_map::at: key not found");
      }
      return v7 + 3;
    }

    a3 = (uint64_t *)*a3;
  }

  else if (v3 != 7)
  {
    goto LABEL_10;
  }

  *(_DWORD *)uint64_t buf = a2;
  BOOL v9 = (void *)(a1 + 48);
  if (!sub_100781F1C((void *)(a1 + 48), (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v19 = HIDWORD(v15);
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#EED2Cfg EED2 carrier config for inst %{public}d wasn't created on construction",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v16 = 67240192;
      int v17 = HIDWORD(v15);
      LODWORD(v15) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg EED2 carrier config for inst %{public}d wasn't created on construction",  &v16,  v15);
      double v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getSimConfig(SimInstance, std::string) const",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  int v7 = sub_100781F1C(v9, (int *)&v15 + 1);
  if (!v7) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return v7 + 3;
}

uint64_t *sub_1007573F4(int *a1)
{
  int v2 = *a1;
  sub_1010DDBC0(__p, "operator");
  int v3 = sub_100757034((uint64_t)a1, v2, (uint64_t *)__p);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  if (!*((_BYTE *)v3 + 396) && (!*((_BYTE *)v3 + 397) || *((_BYTE *)v3 + 56) != 0)) {
    return v3;
  }
  if (*a1 == 1) {
    int v5 = 0;
  }
  else {
    int v5 = 255;
  }
  if (*a1) {
    int v6 = v5;
  }
  else {
    int v6 = 1;
  }
  sub_1010DDBC0(v21, "operator");
  int v7 = sub_100757034((uint64_t)a1, v6, (uint64_t *)v21);
  if (v22 < 0) {
    operator delete(v21[0]);
  }
  if (*((_BYTE *)v7 + 396) || (*((_BYTE *)v7 + 397) ? (BOOL v8 = *((_BYTE *)v7 + 56) == 0) : (BOOL v8 = 0), v8))
  {
LABEL_54:
    int v9 = *a1;
    sub_1010DDBC0(v19, "carrier");
    int v7 = sub_100757034((uint64_t)a1, v9, (uint64_t *)v19);
    if (v20 < 0) {
      operator delete(v19[0]);
    }
    if (*((_BYTE *)v7 + 396) || *((_BYTE *)v7 + 397) && !*((_BYTE *)v7 + 56))
    {
      if (*a1 == 1) {
        int v10 = 0;
      }
      else {
        int v10 = 255;
      }
      if (*a1) {
        int v11 = v10;
      }
      else {
        int v11 = 1;
      }
      sub_1010DDBC0(v17, "carrier");
      int v7 = sub_100757034((uint64_t)a1, v11, (uint64_t *)v17);
      if (v18 < 0) {
        operator delete(v17[0]);
      }
      if (*((_BYTE *)v7 + 396) || *((_BYTE *)v7 + 397) && !*((_BYTE *)v7 + 56))
      {
LABEL_41:
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v12 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#EED2Cfg requested sim config for BAA when not enabled",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          v16[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2Cfg requested sim config for BAA when not enabled",  v16,  2);
          uint64_t v15 = (uint8_t *)v14;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getSimConfigForBaa() const",  "%s\n",  v14);
          if (v15 != buf) {
            free(v15);
          }
        }

        return v3;
      }
    }
  }

  return v7;
}

void sub_10075770C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, char a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, char a31, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t (**sub_100757770( uint64_t (**a1)(), uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, uint64_t a6))()
{
  int v11 = (std::__shared_weak_count *)a5[1];
  uint64_t v42 = *a5;
  uint64_t v43 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  sub_10001A504((uint64_t)v44, a6);
  sub_100F9E19C((uint64_t)a1, a2, 1, a3, (uint64_t)v46, &v42, (uint64_t)v44);
  double v14 = v45;
  if (v45 == v44)
  {
    uint64_t v15 = 4LL;
    double v14 = v44;
    goto LABEL_8;
  }

  if (v45)
  {
    uint64_t v15 = 5LL;
LABEL_8:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }

  int v16 = v43;
  if (v43)
  {
    int v17 = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  int v19 = v47;
  if (v47 == v46)
  {
    uint64_t v20 = 4LL;
    int v19 = v46;
    goto LABEL_18;
  }

  if (v47)
  {
    uint64_t v20 = 5LL;
LABEL_18:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }

  *a1 = (uint64_t (*)())off_10184DD48;
  sub_100755298((uint64_t)(a1 + 181));
  sub_1010DDBC0(__p, "#EED2 state machine");
  int v52 = a1;
  uint64_t v21 = (std::__shared_weak_count *)operator new(0x20uLL);
  v21->__vftable = (std::__shared_weak_count_vtbl *)&off_10184E070;
  v21->__shared_owners_ = 0LL;
  v21->__shared_weak_owners_ = 0LL;
  v21[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  float v53 = v21;
  sub_100783218((uint64_t)(a1 + 192), (const void **)__p, &v52);
  char v22 = v53;
  if (v53)
  {
    int v23 = (unint64_t *)&v53->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  if (v41 < 0) {
    operator delete(__p[0]);
  }
  *((_OWORD *)a1 + sub_10000AE14(v2 - 112) = 0u;
  *((_OWORD *)a1 + 111) = 0u;
  a1[208] = 0LL;
  *(uint64_t (**)())((char *)a1 + 167sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *((_OWORD *)a1 + 105) = 0u;
  *((_OWORD *)a1 + 106) = 0u;
  *((_OWORD *)a1 + 107) = 0u;
  *((_OWORD *)a1 + 10_Block_object_dispose(va, 8) = 0u;
  *((_BYTE *)a1 + 1744) = 0;
  *((_DWORD *)a1 + 442) = 0;
  *(_OWORD *)(a1 + 219) = 0u;
  *((_DWORD *)a1 + 452) = 1065353216;
  a1[231] = 0LL;
  *((_BYTE *)a1 + 1856) = 0;
  a1[245] = 0LL;
  *((_DWORD *)a1 + 454) = 0;
  *((_BYTE *)a1 + 184sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  *((_OWORD *)a1 + 114) = 0u;
  *(_OWORD *)((char *)a1 + 1923) = 0u;
  *(_OWORD *)(a1 + 237) = 0u;
  *(_OWORD *)(a1 + 239) = 0u;
  *(_OWORD *)(a1 + 233) = 0u;
  *(_OWORD *)(a1 + 235) = 0u;
  *(_OWORD *)((char *)a1 + 194sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0u;
  *((_DWORD *)a1 + 492) = -1;
  *((_BYTE *)a1 + 1972) = 0;
  *((_DWORD *)a1 + 494) = 0;
  *((_BYTE *)a1 + 198sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  a1[248] = 0LL;
  *((_OWORD *)a1 + 125) = 0u;
  a1[249] = (uint64_t (*)())(a1 + 250);
  *((_WORD *)a1 + 100_Block_object_dispose(va, 8) = 0;
  a1[253] = 0LL;
  *((_DWORD *)a1 + 50_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 255) = 0u;
  uint64_t v25 = +[NSURLSessionConfiguration defaultSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "defaultSessionConfiguration");
  -[NSURLSessionConfiguration setAllowsCellularAccess:](v25, "setAllowsCellularAccess:", 1LL);
  a1[208] = (uint64_t (*)()) +[NSURLSession sessionWithConfiguration:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:",  v25);
  *((_BYTE *)a1 + 1656) = 0;
  sub_100757EE0((uint64_t)(a1 + 192), 0, (uint64_t *)sub_1007581AC, 0LL);
  sub_100757EE0((uint64_t)(a1 + 192), 1, (uint64_t *)sub_1007598F8, 0LL);
  sub_100757EE0((uint64_t)(a1 + 192), 2, (uint64_t *)sub_10075B024, 0LL);
  sub_100757EE0((uint64_t)(a1 + 192), 3, (uint64_t *)sub_10075C5BC, 0LL);
  sub_100757EE0((uint64_t)(a1 + 192), 4, (uint64_t *)sub_10075E9D4, 0LL);
  a1[202] = (uint64_t (*)())objc_msgSend(objc_msgSend(a1[1], "silo"), "queue");
  *((_DWORD *)a1 + 385) = 0;
  *((_BYTE *)a1 + 1584) = 1;
  sub_1007615DC((uint64_t)(a1 + 192), 0LL);
  sub_1002F0B04(&v52);
  int v26 = sub_1002A6F64((uint64_t)v52, "BAAResetCache", v50);
  if (v50[0]) {
    int v27 = v26;
  }
  else {
    int v27 = 0;
  }
  uint64_t v28 = v53;
  if (!v53) {
    goto LABEL_33;
  }
  int v29 = (unint64_t *)&v53->__shared_owners_;
  do
    unint64_t v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
    if (v27) {
      goto LABEL_34;
    }
  }

  else
  {
LABEL_33:
    if (v27)
    {
LABEL_34:
      sub_10075FC24();
      goto LABEL_37;
    }
  }

  sub_100760180(a1);
LABEL_37:
  sub_100760A68((uint64_t)a1, 0);
  a1[256] = (uint64_t (*)()) objc_msgSend( objc_msgSend(a1[1], "vendor"),  "proxyForService:",  @"CLAnalyticsLogger");
  int v31 = operator new(0xD0uLL);
  int v32 = a1[1];
  int v52 = &off_10184E0F0;
  float v53 = (std::__shared_weak_count *)a1;
  __int16 v54 = (uint64_t *)&v52;
  sub_10001A504((uint64_t)v50, (uint64_t)(a1 + 4));
  v48[0] = &off_10184E180;
  v48[1] = a1;
  size_t v49 = v48;
  sub_100EED300(v31, v32, &v52, v50, v48, a1[256]);
  uint64_t v33 = v49;
  if (v49 == v48)
  {
    uint64_t v34 = 4LL;
    uint64_t v33 = v48;
  }

  else
  {
    if (!v49) {
      goto LABEL_42;
    }
    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_42:
  unsigned int v35 = v51;
  if (v51 == v50)
  {
    uint64_t v36 = 4LL;
    unsigned int v35 = v50;
  }

  else
  {
    if (!v51) {
      goto LABEL_47;
    }
    uint64_t v36 = 5LL;
  }

  (*(void (**)(void))(*(void *)v35 + 8 * v36))();
LABEL_47:
  id v37 = (uint64_t (***)())v54;
  if (v54 == (uint64_t *)&v52)
  {
    uint64_t v38 = 4LL;
    id v37 = &v52;
    goto LABEL_51;
  }

  if (v54)
  {
    uint64_t v38 = 5LL;
LABEL_51:
    (*v37)[v38]();
  }

  sub_1007834EC((uint64_t *)a1 + 219, (uint64_t)v31);
  sub_1007615DC((uint64_t)(a1 + 192), 3LL);
  return a1;
}

void sub_100757CAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, char *a28, char a29, uint64_t a30, uint64_t a31, char *a32)
{
  uint64_t v40 = a28;
  if (a28 == &a25)
  {
    uint64_t v41 = 4LL;
    uint64_t v40 = &a25;
  }

  else
  {
    if (!a28) {
      goto LABEL_6;
    }
    uint64_t v41 = 5LL;
  }

  (*(void (**)(void))(*(void *)v40 + 8 * v41))();
LABEL_6:
  uint64_t v42 = a32;
  if (a32 == &a29)
  {
    uint64_t v43 = 4LL;
    uint64_t v42 = &a29;
  }

  else
  {
    if (!a32) {
      goto LABEL_11;
    }
    uint64_t v43 = 5LL;
  }

  (*(void (**)(void))(*(void *)v42 + 8 * v43))();
LABEL_11:
  uint64_t v44 = *(void **)(v38 - 96);
  if (v44 == (void *)(v38 - 120))
  {
    uint64_t v45 = 4LL;
    uint64_t v44 = (void *)(v38 - 120);
  }

  else
  {
    if (!v44) {
      goto LABEL_16;
    }
    uint64_t v45 = 5LL;
  }

  (*(void (**)(void))(*v44 + 8 * v45))();
LABEL_16:
  operator delete(v35);
  id v46 = *v37;
  *id v37 = 0LL;
  if (v46) {
    operator delete(v46);
  }
  sub_1004C1CC0(v32 + 1992, *v36);
  sub_100783518((uint64_t *)(v32 + 1880), 0LL);
  sub_100019CEC(v32 + 1776);
  sub_1007834EC(v34, 0LL);
  sub_100783408(v33);
  sub_100782D68(v32 + 1496);
  sub_100782D68(v32 + 1456);
  sub_100F9E660(v32);
  _Unwind_Resume(a1);
}

uint64_t **sub_100757EE0(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  int v21 = a2;
  if (a4 & 1 | (unint64_t)a3)
  {
    int v4 = a4;
    int v5 = a3;
    unsigned int v7 = a2;
    uint64_t v6 = a1;
    if (qword_101934880 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101249C14(qword_101934880 == -1);
    __break(1u);
  }

  dispatch_once(&qword_101934880, &stru_10184E0C0);
LABEL_3:
  BOOL v8 = (os_log_s *)qword_101934888;
  os_log_type_t v9 = *(_BYTE *)(v6 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v9))
  {
    int v10 = (void *)(v6 + 96);
    sub_100762504(v7, __p);
    if (SBYTE3(v26) >= 0) {
      int v11 = __p;
    }
    else {
      int v11 = *(_BYTE **)__p;
    }
    *(_DWORD *)uint64_t buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v28 = 1024;
    unsigned int v29 = v7;
    __int16 v30 = 2080;
    int v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, v9, "%sstate,%d,%s", buf, 0x1Cu);
    if (SBYTE3(v26) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    unint64_t v13 = (void *)(v6 + 96);
    uint64_t v14 = qword_101934888;
    uint64_t v15 = *(unsigned __int8 *)(v6 + 120);
    sub_100762504(v7, v19);
    if (v20 >= 0) {
      int v16 = v19;
    }
    else {
      int v16 = (void **)v19[0];
    }
    *(_DWORD *)std::string __p = 136315650;
    *(void *)&__p[4] = v13;
    __int16 v23 = 1024;
    unsigned int v24 = v7;
    __int16 v25 = 2080;
    int v26 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  v15,  "%sstate,%d,%s",  __p,  28,  (const char *)v19[0]);
    unint64_t v18 = v17;
    if (v20 < 0) {
      operator delete(v19[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyEED2>::setStateHandler(State, StateHandler) [T = CLEmergencyEED2]",  "%s\n",  v18);
    if (v18 != buf) {
      free(v18);
    }
  }

  *(void *)uint64_t buf = &v21;
  BOOL result = sub_100783544((uint64_t **)(v6 + 8), &v21, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
  result[5] = v5;
  result[6] = v4;
  return result;
}

uint64_t sub_1007581AC(uint64_t a1, int a2)
{
  uint64_t result = 0LL;
  switch(a2)
  {
    case 0:
      v59[0] = 0;
      *(void *)uint64_t buf = v59;
      *((_BYTE *)sub_1007837B4(a1 + 1776, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      if (sub_1004FAACC())
      {
        v59[0] = 1;
        *(void *)uint64_t buf = v59;
        *((_BYTE *)sub_1007837B4(a1 + 1776, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      }

      *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 1872) = 0LL;
      *(_DWORD *)(a1 + 18sub_100708348(v2 - 16) = 0;
      int v4 = *(void **)(a1 + 1920);
      if (v4)
      {

        *(void *)(a1 + 192sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
      }

      int v5 = *(const void **)(a1 + 1928);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(a1 + 192_Block_object_dispose(va, 8) = 0LL;
      }

      sub_100763A5C(a1 + 1536, 17, 30.0);
      return 0LL;
    case 1:
      sub_10076452C(a1 + 1536, 17);
      sub_10076452C(a1 + 1536, 18);
      sub_1007649BC(a1);
      return 0LL;
    case 2:
      *(_BYTE *)(a1 + 18sub_100708348(v2 - 16) = 1;
      uint64_t result = sub_10076381C((_BYTE *)a1);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t result = sub_100764AF4(a1);
      if ((_DWORD)result != 4) {
        return result;
      }
      sub_100765030(a1);
      sub_100766A44(a1);
      return 4LL;
    case 3:
      *(_BYTE *)(a1 + 1817) = 1;
      *(_BYTE *)(a1 + 1819) = 0;
      goto LABEL_84;
    case 4:
      *(_WORD *)(a1 + 181_Block_object_dispose(va, 8) = 1;
LABEL_84:
      sub_100763A5C(a1 + 1536, 18, 1.0);
      return 0LL;
    case 7:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      os_log_type_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendFixTimeout fired while Initializing",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendFixTimeout fired while Initializing",  v59,  v58);
      BOOL v8 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v10);
      goto LABEL_129;
    case 8:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v11 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendAdrTimeout fired while Initializing",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendAdrTimeout fired while Initializing",  v59,  v58);
      BOOL v8 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v12);
      goto LABEL_129;
    case 11:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unint64_t v13 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SessionAssertReleased fired in Initializing state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SessionAssertReleased fired in Initializing state",  v59,  v58);
        uint64_t v43 = (uint8_t *)v42;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v42);
        if (v43 != buf) {
          free(v43);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      return 0LL;
    case 12:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v28 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CanSendADRTimeout fired while Initializing",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CanSendADRTimeout fired while Initializing",  v59,  v58);
      BOOL v8 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v29);
      goto LABEL_129;
    case 13:
      v59[0] = 0;
      *(void *)uint64_t buf = v59;
      __int16 v30 = sub_1004C2E20((uint64_t **)(a1 + 1992), v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v30[6] == v30[5])
      {
        HIDWORD(v5_Block_object_dispose(va, 8) = 1;
        *(void *)uint64_t buf = (char *)&v58 + 4;
        int v31 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v58 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        if (v31[6] == v31[5])
        {
          sub_100F9F0DC(a1);
          sub_100766D4C(a1);
          sub_10076452C(a1 + 1536, 14);
        }
      }

      return 0LL;
    case 14:
      uint64_t v14 = (uint64_t **)(a1 + 1992);
      v59[0] = 0;
      *(void *)uint64_t buf = v59;
      uint64_t v15 = sub_1004C2E20((uint64_t **)(a1 + 1992), v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v15[6] == v15[5] {
        && (HIDWORD(v5_Block_object_dispose(va, 8) = 1,
      }
            *(void *)uint64_t buf = (char *)&v58 + 4,
            int v16 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v58 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf),
            v16[6] == v16[5]))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v40 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "#EED2 LIS Response timer timedout when no notifications were expected",  buf,  2u);
        }

        uint64_t result = sub_1002921D0(115, 0);
        if ((_DWORD)result)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v59[0]) = 0;
          LODWORD(v5_Block_object_dispose(va, 8) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 LIS Response timer timedout when no notifications were expected",  v59,  v58);
          BOOL v8 = (uint8_t *)v41;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v41);
LABEL_129:
          if (v8 != buf) {
            free(v8);
          }
          return 0LL;
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v17 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#EED2 LIS Response timer timedout. Submit AWD report with failure",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v59[0]) = 0;
          LODWORD(v5_Block_object_dispose(va, 8) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 LIS Response timer timedout. Submit AWD report with failure",  v59,  v58);
          id v57 = (uint8_t *)v56;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v56);
          if (v57 != buf) {
            free(v57);
          }
        }

        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v18 = *(void *)(a1 + 2040);
        if (v18) {
          sub_100767578(a1, (unsigned int *)(v18 + 24), 3u);
        }
        *(void *)(a1 + 352) = -1LL;
        sub_100F9F0DC(a1);
        sub_100766D4C(a1);
        v59[0] = 0;
        *(void *)uint64_t buf = v59;
        int v19 = sub_1004C2E20(v14, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        v19[6] = v19[5];
        v59[0] = 1;
        *(void *)uint64_t buf = v59;
        char v20 = sub_1004C2E20(v14, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        uint64_t result = 0LL;
        v20[6] = v20[5];
      }

      return result;
    case 15:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v21 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSTokenReceived in Initializing state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSTokenReceived in Initializing state",  v59,  v58);
        uint64_t v45 = (uint8_t *)v44;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v44);
        if (v45 != buf) {
          free(v45);
        }
      }

      char v22 = *(void **)(a1 + 1824);
      if (!v22) {
        return 0LL;
      }

      uint64_t result = 0LL;
      *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
      return result;
    case 16:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v23 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSMessageReceived in Initializing state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSMessageReceived in Initializing state",  v59,  v58);
        id v47 = (uint8_t *)v46;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v46);
        if (v47 != buf) {
          free(v47);
        }
      }

      unsigned int v24 = *(void **)(a1 + 1832);
      if (!v24) {
        return 0LL;
      }

      uint64_t result = 0LL;
      *(void *)(a1 + 1832) = 0LL;
      return result;
    case 17:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v25 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "#EED2 InitializationTimeout reached",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 InitializationTimeout reached",  v59,  v58);
        size_t v49 = (uint8_t *)v48;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v48);
        if (v49 != buf) {
          free(v49);
        }
      }

      uint64_t result = sub_100764AF4(a1);
      if ((_DWORD)result == 4) {
        goto LABEL_111;
      }
      return result;
    case 18:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v32 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#EED2 DebounceTimeout reached", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 DebounceTimeout reached",  v59,  v58);
        float v51 = (uint8_t *)v50;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v50);
        if (v51 != buf) {
          free(v51);
        }
      }

      *(_BYTE *)(a1 + 1819) = 1;
      uint64_t result = sub_10076381C((_BYTE *)a1);
      if ((_DWORD)result)
      {
        uint64_t result = sub_100764AF4(a1);
        if ((_DWORD)result == 4) {
          goto LABEL_111;
        }
      }

      return result;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v33 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "#EED2 PhoneNumberChanged in Initializing State",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 PhoneNumberChanged in Initializing State",  v59,  v58);
        float v53 = (uint8_t *)v52;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v52);
        if (v53 != buf) {
          free(v53);
        }
      }

      uint64_t result = sub_10076381C((_BYTE *)a1);
      if ((_DWORD)result)
      {
        uint64_t result = sub_100764AF4(a1);
        if ((_DWORD)result == 4)
        {
LABEL_111:
          sub_100765030(a1);
          sub_100766A44(a1);
          return 4LL;
        }
      }

      return result;
    case 20:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v34 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CallEndpointChanged in Initializing State",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CallEndpointChanged in Initializing State",  v59,  v58);
      BOOL v8 = (uint8_t *)v35;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v35);
      goto LABEL_129;
    case 21:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v36 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#EED2 BAACertDownload in Initializing State, no-op",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 BAACertDownload in Initializing State, no-op",  v59,  v58);
      BOOL v8 = (uint8_t *)v37;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v37);
      goto LABEL_129;
    case 22:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v6 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSReconnected in Initializing state",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSReconnected in Initializing state",  v59,  v58);
      BOOL v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v7);
      goto LABEL_129;
    case 23:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v26 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "#EED2 ControlDataResponseReceived in Initializing State, no-op",  buf,  2u);
      }

      uint64_t result = sub_1002921D0(115, 2);
      if (!(_DWORD)result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 ControlDataResponseReceived in Initializing State, no-op",  v59,  v58);
      BOOL v8 = (uint8_t *)v27;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v27);
      goto LABEL_129;
    case 24:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v38 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CoexMetricUpdated in Initializing state, no-op",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CoexMetricUpdated in Initializing state, no-op",  v59,  v58);
        int v55 = (uint8_t *)v54;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Initializing(CLEmergencyEED2::Event)",  "%s\n",  v54);
        if (v55 != buf) {
          free(v55);
        }
      }

      __int16 v39 = *(void **)(a1 + 1984);
      if (!v39) {
        return 0LL;
      }

      uint64_t result = 0LL;
      *(void *)(a1 + 1984) = 0LL;
      return result;
    default:
      return result;
  }

uint64_t sub_1007598F8(uint64_t a1, int a2)
{
  uint64_t v2 = 1LL;
  switch(a2)
  {
    case 0:
      sub_1007675C4();
      sub_100767780();
      sub_100767A6C();
      sub_100766A44(a1);
      return v2;
    case 3:
      uint64_t v2 = sub_100764AF4(a1);
      if ((v2 - 3) <= 1)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v12 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          sub_100762504(v2, buf);
          unint64_t v13 = v70 >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)int v65 = 136315138;
          *(void *)&v65[4] = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#EED2, unexpected transition from Disabled state to %s state.",  v65,  0xCu);
          if (v70 < 0) {
            operator delete(*(void **)buf);
          }
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v14 = qword_101934898;
          sub_100762504(v2, v65);
          if (v66 >= 0) {
            uint64_t v15 = v65;
          }
          else {
            uint64_t v15 = *(_BYTE **)v65;
          }
          int v67 = 136315138;
          __int16 v68 = v15;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  16LL,  "#EED2, unexpected transition from Disabled state to %s state.",  (const char *)&v67);
          int v17 = v16;
          if (v66 < 0) {
            operator delete(*(void **)v65);
          }
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v17);
        }
      }

      return v2;
    case 7:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v18 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendFixTimeout fired while Disabled",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendFixTimeout fired while Disabled",  v65,  2);
      unsigned int v7 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v19);
      goto LABEL_137;
    case 8:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v20 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendAdrTimeout fired while Disabled",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendAdrTimeout fired while Disabled",  v65,  2);
      unsigned int v7 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v21);
      goto LABEL_137;
    case 11:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SessionAssertReleased fired in Disabled state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v65 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SessionAssertReleased fired in Disabled state",  v65,  2);
        __int16 v56 = (uint8_t *)v55;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v55);
        if (v56 != buf) {
          free(v56);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      return 1LL;
    case 12:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v22 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CanSendADRTimeout fired while Disabled",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CanSendADRTimeout fired while Disabled",  v65,  2);
      unsigned int v7 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v23);
      goto LABEL_137;
    case 13:
      *(_DWORD *)int v65 = 0;
      *(void *)uint64_t buf = v65;
      unsigned int v24 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)v65, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v24[6] == v24[5])
      {
        int v67 = 1;
        *(void *)uint64_t buf = &v67;
        __int16 v25 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v67, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        if (v25[6] == v25[5])
        {
          sub_100F9F0DC(a1);
          sub_100766D4C(a1);
          sub_10076452C(a1 + 1536, 14);
        }
      }

      return 1LL;
    case 14:
      int v26 = (uint64_t **)(a1 + 1992);
      *(_DWORD *)int v65 = 0;
      *(void *)uint64_t buf = v65;
      int v27 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)v65, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v27[6] == v27[5]
        && (int v67 = 1,
            *(void *)uint64_t buf = &v67,
            __int16 v28 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v67, (uint64_t)&unk_1012CF090, (_DWORD **)buf),
            v28[6] == v28[5]))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        float v53 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "#EED2 LIS Response timer timedout when no notifications were expected",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          *(_WORD *)int v65 = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 LIS Response timer timedout when no notifications were expected",  v65,  2);
          unsigned int v7 = (uint8_t *)v54;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v54);
LABEL_137:
          if (v7 != buf) {
            free(v7);
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v29 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "#EED2 LIS Response timer timedout. Submit AWD report with failure",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          *(_WORD *)int v65 = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 LIS Response timer timedout. Submit AWD report with failure",  v65,  2);
          id v64 = (uint8_t *)v63;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v63);
          if (v64 != buf) {
            free(v64);
          }
        }

        uint64_t v30 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v31 = *(void *)(a1 + 2040);
        if (v31)
        {
          unsigned int v33 = *(_DWORD *)(v31 + 24);
          uint64_t v32 = (int *)(v31 + 24);
          unsigned int v34 = sub_100778A88(v30, v33);
          int v35 = *v32;
          if (v34 >= 0xFFFFFFFD) {
            int v35 = 3;
          }
          *uint64_t v32 = v35;
        }

        *(void *)(a1 + 352) = -1LL;
        sub_100F9F0DC(a1);
        sub_100766D4C(a1);
        *(_DWORD *)int v65 = 0;
        *(void *)uint64_t buf = v65;
        uint64_t v36 = sub_1004C2E20(v26, (int *)v65, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        _BYTE v36[6] = v36[5];
        *(_DWORD *)int v65 = 1;
        *(void *)uint64_t buf = v65;
        id v37 = sub_1004C2E20(v26, (int *)v65, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        _BYTE v37[6] = v37[5];
      }

      return 1LL;
    case 15:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v38 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSTokenReceived in Disabled state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v65 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSTokenReceived in Disabled state",  v65,  2);
        uint64_t v58 = (uint8_t *)v57;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v57);
        if (v58 != buf) {
          free(v58);
        }
      }

      __int16 v39 = *(void **)(a1 + 1824);
      if (v39)
      {

        *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
      }

      return 1LL;
    case 16:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v40 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSMessageReceived in Disabled state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v65 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSMessageReceived in Disabled state",  v65,  2);
        __int16 v60 = (uint8_t *)v59;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v59);
        if (v60 != buf) {
          free(v60);
        }
      }

      uint64_t v41 = *(void **)(a1 + 1832);
      if (v41)
      {

        *(void *)(a1 + 1832) = 0LL;
      }

      return 1LL;
    case 17:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected InitializationTimeout in Disabled state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected InitializationTimeout in Disabled state",  v65,  2);
      unsigned int v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v6);
      goto LABEL_137;
    case 18:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v42 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected DebounceTimeout in Disabled state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected DebounceTimeout in Disabled state",  v65,  2);
      unsigned int v7 = (uint8_t *)v43;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v43);
      goto LABEL_137;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      BOOL v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2 PhoneNumberChanged in Disabled State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 PhoneNumberChanged in Disabled State, no-op",  v65,  2);
      unsigned int v7 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v9);
      goto LABEL_137;
    case 20:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CallEndpointChanged in Disabled State",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CallEndpointChanged in Disabled State",  v65,  2);
      unsigned int v7 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v11);
      goto LABEL_137;
    case 21:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v44 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "#EED2 BAACertDownload in Disabled State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 BAACertDownload in Disabled State, no-op",  v65,  2);
      unsigned int v7 = (uint8_t *)v45;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v45);
      goto LABEL_137;
    case 22:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v46 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSReconnected in Disabled state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSReconnected in Disabled state",  v65,  2);
      unsigned int v7 = (uint8_t *)v47;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v47);
      goto LABEL_137;
    case 23:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v48 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "#EED2 ControlDataResponseReceived in Disabled State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v65 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 ControlDataResponseReceived in Disabled State, no-op",  v65,  2);
      unsigned int v7 = (uint8_t *)v49;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v49);
      goto LABEL_137;
    case 24:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      size_t v50 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CoexMetricUpdated in Disabled state, no-op",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v65 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CoexMetricUpdated in Disabled state, no-op",  v65,  2);
        __int16 v62 = (uint8_t *)v61;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)",  "%s\n",  v61);
        if (v62 != buf) {
          free(v62);
        }
      }

      float v51 = *(void **)(a1 + 1984);
      if (v51)
      {

        *(void *)(a1 + 1984) = 0LL;
      }

      return 1LL;
    default:
      return v2;
  }

uint64_t sub_10075B024(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      sub_1007675C4();
      sub_100767780();
      sub_100767A6C();
      sub_100766A44(a1);
      return 2LL;
    case 3:
    case 4:
      return sub_100764AF4(a1);
    case 7:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendFixTimeout fired while Idle",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendFixTimeout fired while Idle",  v59,  v58);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v5);
      goto LABEL_151;
    case 8:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unsigned int v7 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SendAdrTimeout fired while Idle",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SendAdrTimeout fired while Idle",  v59,  v58);
      uint64_t v6 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v8);
      goto LABEL_151;
    case 11:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      os_log_type_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SessionAssertReleased fired in Idle state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SessionAssertReleased fired in Idle state",  v59,  v58);
        __int16 v48 = (uint8_t *)v47;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v47);
        if (v48 != buf) {
          free(v48);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      return 2LL;
    case 12:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v20 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CanSendADRTimeout fired while Idle",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CanSendADRTimeout fired while Idle",  v59,  v58);
      uint64_t v6 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v21);
      goto LABEL_151;
    case 13:
      v59[0] = 0;
      *(void *)uint64_t buf = v59;
      char v22 = sub_1004C2E20((uint64_t **)(a1 + 1992), v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v22[6] == v22[5])
      {
        HIDWORD(v5_Block_object_dispose(va, 8) = 1;
        *(void *)uint64_t buf = (char *)&v58 + 4;
        __int16 v23 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v58 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        if (v23[6] == v23[5])
        {
          sub_100F9F0DC(a1);
          sub_100766D4C(a1);
          sub_10076452C(a1 + 1536, 14);
        }
      }

      return 2LL;
    case 14:
      unsigned int v24 = (uint64_t **)(a1 + 1992);
      v59[0] = 0;
      *(void *)uint64_t buf = v59;
      __int16 v25 = sub_1004C2E20((uint64_t **)(a1 + 1992), v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v25[6] == v25[5] {
        && (HIDWORD(v5_Block_object_dispose(va, 8) = 1,
      }
            *(void *)uint64_t buf = (char *)&v58 + 4,
            int v26 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v58 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf),
            v26[6] == v26[5]))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v45 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "#EED2 LIS response timer timedout when no notifications were expected",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v59[0]) = 0;
          LODWORD(v5_Block_object_dispose(va, 8) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 LIS response timer timedout when no notifications were expected",  v59,  v58);
          uint64_t v6 = (uint8_t *)v46;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v46);
LABEL_151:
          if (v6 != buf) {
            free(v6);
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v27 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#EED2 LIS response timer timedout. Submit AWD report with failure",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v59[0]) = 0;
          LODWORD(v5_Block_object_dispose(va, 8) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 LIS response timer timedout. Submit AWD report with failure",  v59,  v58);
          id v57 = (uint8_t *)v56;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v56);
          if (v57 != buf) {
            free(v57);
          }
        }

        uint64_t v28 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v29 = *(void *)(a1 + 2040);
        if (v29)
        {
          unsigned int v31 = *(_DWORD *)(v29 + 24);
          uint64_t v30 = (int *)(v29 + 24);
          unsigned int v32 = sub_100778A88(v28, v31);
          int v33 = *v30;
          if (v32 >= 0xFFFFFFFD) {
            int v33 = 3;
          }
          *uint64_t v30 = v33;
        }

        *(void *)(a1 + 352) = -1LL;
        sub_100F9F0DC(a1);
        sub_100766D4C(a1);
        v59[0] = 0;
        *(void *)uint64_t buf = v59;
        unsigned int v34 = sub_1004C2E20(v24, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        v34[6] = v34[5];
        v59[0] = 1;
        *(void *)uint64_t buf = v59;
        int v35 = sub_1004C2E20(v24, v59, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        v35[6] = v35[5];
      }

      return 2LL;
    case 15:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v36 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSTokenReceived in Idle state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSTokenReceived in Idle state",  v59,  v58);
        __int16 v54 = (uint8_t *)v53;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v53);
        if (v54 != buf) {
          free(v54);
        }
      }

      id v37 = *(void **)(a1 + 1824);
      if (v37)
      {

        *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
      }

      return 2LL;
    case 16:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSMessageReceived in Idle state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSMessageReceived in Idle state",  v59,  v58);
        size_t v50 = (uint8_t *)v49;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v49);
        if (v50 != buf) {
          free(v50);
        }
      }

      int v11 = *(void **)(a1 + 1832);
      if (v11)
      {

        *(void *)(a1 + 1832) = 0LL;
      }

      return 2LL;
    case 17:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v12 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected InitializationTimeout in Idle state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected InitializationTimeout in Idle state",  v59,  v58);
      uint64_t v6 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v13);
      goto LABEL_151;
    case 18:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v14 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected DebounceTimeout in Idle state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected DebounceTimeout in Idle state",  v59,  v58);
      uint64_t v6 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v15);
      goto LABEL_151;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v16 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#EED2 PhoneNumberChanged in Idle State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 PhoneNumberChanged in Idle State, no-op",  v59,  v58);
      uint64_t v6 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v17);
      goto LABEL_151;
    case 20:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v38 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CallEndpointChanged in Idle State",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CallEndpointChanged in Idle State",  v59,  v58);
      uint64_t v6 = (uint8_t *)v39;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v39);
      goto LABEL_151;
    case 21:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v40 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "#EED2 BAACertDownload in Idle State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 BAACertDownload in Idle State, no-op",  v59,  v58);
      uint64_t v6 = (uint8_t *)v41;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v41);
      goto LABEL_151;
    case 22:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v42 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSReconnected in Idle state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSReconnected in Idle state",  v59,  v58);
      uint64_t v6 = (uint8_t *)v43;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v43);
      goto LABEL_151;
    case 23:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v44 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "#EED2 ControlDataResponseReceived in Idle State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 2LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v59[0]) = 0;
      LODWORD(v5_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 ControlDataResponseReceived in Idle State, no-op",  v59,  v58);
      uint64_t v6 = (uint8_t *)v55;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v55);
      goto LABEL_151;
    case 24:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v18 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CoexMetricUpdated in Idle state, no-op",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v59[0]) = 0;
        LODWORD(v5_Block_object_dispose(va, 8) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CoexMetricUpdated in Idle state, no-op",  v59,  v58);
        int v52 = (uint8_t *)v51;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)",  "%s\n",  v51);
        if (v52 != buf) {
          free(v52);
        }
      }

      int v19 = *(void **)(a1 + 1984);
      if (v19)
      {

        *(void *)(a1 + 1984) = 0LL;
      }

      return 2LL;
    default:
      return 2LL;
  }

uint64_t sub_10075C5BC(uint64_t a1, int a2)
{
  uint64_t v2 = 3LL;
  switch(a2)
  {
    case 0:
      LODWORD(v1sub_10000AE14(v9 + 24) = 0;
      *(void *)uint64_t buf = &v124;
      int v4 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v124, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      if (v4[6] != v4[5] {
        || (LODWORD(v12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1,
      }
            *(void *)uint64_t buf = &v120,
            int v5 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v120, (uint64_t)&unk_1012CF090, (_DWORD **)buf),
            v5[6] != v5[5]))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v6 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EED2 Submitting previous session AWD report before starting new session",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 Submitting previous session AWD report before starting new session",  &v124,  2);
          double v83 = (uint8_t *)v82;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v82);
          if (v83 != buf) {
            free(v83);
          }
        }

        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v7 = *(void *)(a1 + 2040);
        if (v7) {
          sub_100767578(a1, (unsigned int *)(v7 + 24), 3u);
        }
        *(void *)(a1 + 352) = -1LL;
        sub_100F9F0DC(a1);
        sub_100766D4C(a1);
        LODWORD(v1sub_10000AE14(v9 + 24) = 0;
        *(void *)uint64_t buf = &v124;
        BOOL v8 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v124, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        void v8[6] = v8[5];
        LODWORD(v1sub_10000AE14(v9 + 24) = 1;
        *(void *)uint64_t buf = &v124;
        os_log_type_t v9 = sub_1004C2E20((uint64_t **)(a1 + 1992), (int *)&v124, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        v9[6] = v9[5];
        sub_10076452C(a1 + 1536, 14);
      }

      if (!*(void *)(a1 + 2040))
      {
        int v10 = (char *)operator new(0x78uLL);
        *((_OWORD *)v10 + 2) = 0u;
        *((_OWORD *)v10 + 3) = 0u;
        *((_OWORD *)v10 + 4) = 0u;
        *((_OWORD *)v10 + 5) = 0u;
        *((_OWORD *)v10 + 6) = 0u;
        *((void *)v10 + 14) = 0LL;
        *(_OWORD *)int v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        *((_DWORD *)v10 + 6) = 10;
        __asm { FMOV            V1.2S, #-1.0 }

        *(void *)(v10 + 2_Block_object_dispose(va, 8) = _D1;
        *(void *)(v10 + 44) = 0LL;
        *(void *)(v10 + 52) = 0LL;
        *(void *)(v10 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
        *(_OWORD *)(v10 + 72) = 0u;
        *(_OWORD *)(v10 + 8_Block_object_dispose(va, 8) = 0u;
        *((void *)v10 + 13) = -1LL;
        *(void *)(a1 + 204sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v10;
      }

      if (!sub_100765030(a1))
      {
        sub_100767D58(a1);
        sub_100767E24(*(void *)(a1 + 2040));
      }

      sub_100766A44(a1);
      *(_WORD *)(a1 + 1936) = 0;
      *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 0;
      *(_DWORD *)(a1 + 194sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      *(double *)(a1 + 176) = sub_101171D4C();
      int v16 = *(_DWORD *)(a1 + 1764);
      *(_DWORD *)(a1 + 176_Block_object_dispose(va, 8) = v16;
      uint64_t v17 = *(void *)(a1 + 1752);
      if (v17)
      {
        sub_100EEF808(v17, v16);
        sub_100EEFA28(*(void *)(a1 + 1752));
      }

      if (*(void *)(a1 + 1880)) {
        goto LABEL_208;
      }
      uint64_t v18 = operator new(0x90uLL);
      uint64_t v19 = *(void *)(a1 + 8);
      *(void *)uint64_t buf = &off_10184E210;
      uint64_t v114 = a1;
      double v116 = buf;
      sub_10001A504((uint64_t)&v124, a1 + 32);
      double v120 = (void **)&off_10184E290;
      uint64_t v121 = a1;
      __int16 v123 = (uint64_t *)&v120;
      sub_100CC7B28(v18, v19, buf, &v124, &v120);
      char v20 = (void ***)v123;
      if (v123 == (uint64_t *)&v120)
      {
        uint64_t v21 = 4LL;
        char v20 = &v120;
      }

      else
      {
        if (!v123) {
          goto LABEL_197;
        }
        uint64_t v21 = 5LL;
      }

      ((void (*)(void))(*v20)[v21])();
LABEL_197:
      __int16 v60 = (void **)v127;
      if (v127 == (uint64_t *)&v124)
      {
        uint64_t v61 = 4LL;
        __int16 v60 = (void **)&v124;
      }

      else
      {
        if (!v127) {
          goto LABEL_202;
        }
        uint64_t v61 = 5LL;
      }

      (*((void (**)(void))*v60 + v61))();
LABEL_202:
      __int16 v62 = v116;
      if (v116 == buf)
      {
        uint64_t v63 = 4LL;
        __int16 v62 = buf;
      }

      else
      {
        if (!v116)
        {
LABEL_207:
          sub_100783518((uint64_t *)(a1 + 1880), (uint64_t)v18);
LABEL_208:
          sub_100767F50(a1);
          uint64_t v64 = *(void *)(a1 + 1880);
          if (v64)
          {
            sub_100CC7C00(v64, *(_DWORD *)(a1 + 132));
            sub_100CC7E20(*(std::string **)(a1 + 1880), (const std::string *)(a1 + 136));
          }

          *(_DWORD *)(a1 + 1672) = 0;
          *(_WORD *)(a1 + 1761) = 0;
          *(_WORD *)(a1 + 20sub_100708348(v2 - 16) = 0;
          *(_BYTE *)(a1 + 1763) = 0;
          sub_100F9EEE8(a1);
          IOPSGetPercentRemaining(*(void *)(a1 + 2040) + 104LL, 0LL, 0LL);
          *(_DWORD *)(a1 + 2032) = 2;
          int v65 = sub_100496E10((unsigned int *)(a1 + 112));
          *(_DWORD *)uint64_t buf = 141;
          LODWORD(v114) = v65;
          int v66 = *(_DWORD *)(a1 + 2032);
          int v117 = 0;
          v118[0] = 138;
          v118[2] = v66;
          v118[8] = 0;
          __int16 v125 = 0LL;
          double v126 = 0LL;
          double v124 = 0LL;
          double v120 = (void **)&v124;
          LOBYTE(v121) = 0;
          double v124 = (char *)operator new(0x50uLL);
          __int16 v125 = v124;
          double v126 = v124 + 80;
          __int16 v125 = (_BYTE *)sub_100783D5C((uint64_t)&v126, (uint64_t)buf, (uint64_t)&v119, (uint64_t)v124);
          for (uint64_t i = 48LL; i != -32; i -= 40LL)
            sub_10043AFF4((uint64_t)&buf[i]);
          __int16 v68 = *(void **)(a1 + 2048);
          memset(v111, 0, 24);
          sub_10043BC44(v111, (uint64_t)v124, (uint64_t)v125, 0xCCCCCCCCCCCCCCCDLL * ((v125 - v124) >> 3));
          [v68 setMeasurements:sub_100435878(v111)];
          *(void *)uint64_t buf = v111;
          sub_10043B844((void ***)buf);
          uint64_t v69 = sub_10059CEEC();
          char v70 = (void *)sub_10059E244(v69);
          int v71 = v70;
          if (v70)
          {
            __int16 v72 = (char *)[v70 UTF8String];
            *(_DWORD *)uint64_t buf = 127;
            sub_1010DDBC0(&v114, v72);
            int v117 = 6;
            uint64_t v121 = 0LL;
            double v122 = 0LL;
            double v120 = 0LL;
            v111[3] = (uint64_t)&v120;
            char v112 = 0;
            double v120 = (void **)operator new(0x28uLL);
            uint64_t v121 = (uint64_t)v120;
            double v122 = v120 + 5;
            uint64_t v121 = sub_100783D5C((uint64_t)&v122, (uint64_t)buf, (uint64_t)v118, (uint64_t)v120);
            sub_10043AFF4((uint64_t)&v114);
            int v73 = *(void **)(a1 + 2048);
            memset(v110, 0, sizeof(v110));
            sub_10043BC44(v110, (uint64_t)v120, v121, 0xCCCCCCCCCCCCCCCDLL * ((v121 - (uint64_t)v120) >> 3));
            [v73 setMeasurements:sub_100435878(v110)];
            *(void *)uint64_t buf = v110;
            sub_10043B844((void ***)buf);

            *(void *)uint64_t buf = &v120;
            sub_10043B844((void ***)buf);
          }

          sub_100760A68(a1, 2u);
          if (sub_1009830B8(a1 + 112)
            || (*(_DWORD *)(a1 + 1440) - 2) <= 3 && (*(_DWORD *)(a1 + 1768) - 3) > 3)
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            __int16 v74 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "#EED2 allowed to send ADR data immediately",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              LOWORD(v12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
              LODWORD(v109) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 allowed to send ADR data immediately",  &v120,  v109);
              double v98 = (uint8_t *)v97;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v97);
              if (v98 != buf) {
                free(v98);
              }
            }

            *(_BYTE *)(a1 + 1761) = 1;
          }

          else
          {
            sub_100768180(a1);
          }

          uint64_t v75 = (int *)(a1 + 1448);
          if (*((_BYTE *)sub_100756E48((int *)(a1 + 1448)) + 58))
          {
            uint64_t v76 = *(void *)(a1 + 1728);
            if (v76) {
              *(void *)(a1 + 1736) = +[CLEmergencyEnablementAssertion newAssertionForBundle:withReason:]( &OBJC_CLASS___CLEmergencyEnablementAssertion,  "newAssertionForBundle:withReason:",  v76,  @"fetching DSA for EED2");
            }
          }

          sub_100F9E9FC(a1, 1LL);
          uint64_t v77 = a1 + 1536;
          sub_100763A5C(v77, 11, 60.0);
          __int16 v78 = sub_100756E48(v75);
          sub_100763A5C(v77, 7, *((double *)v78 + 17));
          uint64_t v79 = sub_100756E48(v75);
          sub_100763A5C(v77, 8, *((double *)v79 + 19));
          *(void *)uint64_t buf = &v124;
          sub_10043B844((void ***)buf);
          return 3LL;
        }

        uint64_t v63 = 5LL;
      }

      (*(void (**)(void))(*(void *)v62 + 8 * v63))();
      goto LABEL_207;
    case 1:
      sub_100768458(a1);
      uint64_t v37 = *(void *)(a1 + 2040);
      if (v37)
      {
        uint64_t v38 = IOPSGetPercentRemaining(v37 + 108, 0LL, 0LL);
        *(_BYTE *)(*(void *)(a1 + 2040) + 112LL) = IOPSDrawingUnlimitedPower(v38);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        __int16 v39 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v40 = *(void *)(a1 + 2040);
          int v41 = *(_DWORD *)(v40 + 104);
          int v42 = *(_DWORD *)(v40 + 108);
          LODWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(unsigned __int8 *)(v40 + 112);
          *(_DWORD *)uint64_t buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v41;
          LOWORD(v114) = 1024;
          *(_DWORD *)((char *)&v114 + 2) = v42;
          HIWORD(v114) = 1024;
          int v115 = v40;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "#EED2 fBatteryLevelAtSessionStart:%d, fBatteryLevelAtCallEnd:%d, fPowerSourcePlugged:%d",  buf,  0x14u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v90 = *(void *)(a1 + 2040);
          int v91 = *(_DWORD *)(v90 + 104);
          int v92 = *(_DWORD *)(v90 + 108);
          LODWORD(v9sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(unsigned __int8 *)(v90 + 112);
          LODWORD(v1sub_10000AE14(v9 + 24) = 67109632;
          HIDWORD(v1sub_10000AE14(v9 + 24) = v91;
          LOWORD(v125) = 1024;
          *(_DWORD *)((char *)&v125 + 2) = v92;
          HIWORD(v125) = 1024;
          LODWORD(v126) = v90;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 fBatteryLevelAtSessionStart:%d, fBatteryLevelAtCallEnd:%d, fPowerSourcePlugged:%d",  &v124,  20,  LODWORD(v110[0]));
          double v94 = (uint8_t *)v93;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v93);
          if (v94 != buf) {
            free(v94);
          }
        }
      }

      if (sub_100764AF4(a1) != 4)
      {
        sub_100768AAC(a1);
        sub_1007692C8(a1);
        return 3LL;
      }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v43 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "#EED2 Moving from ActiveSession state to ExtendedSession state. No cleanup needed at this point",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      LODWORD(v109) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 Moving from ActiveSession state to ExtendedSession state. No cleanup needed at this point",  &v124,  v109);
      uint64_t v30 = (uint8_t *)v44;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v44);
      goto LABEL_193;
    case 3:
      if (sub_100764AF4(a1) == 1)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        char v22 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 unexpectedly disabled during active emergency call",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 unexpectedly disabled during active emergency call",  &v124,  2);
          double v100 = (uint8_t *)v99;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v99);
          if (v100 != buf) {
            free(v100);
          }
        }

        sub_100F9E9FC(a1, 0LL);
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 14LL);
        uint64_t v23 = *(void *)(a1 + 2040);
        if (v23) {
          sub_100767578(a1, (unsigned int *)(v23 + 24), 5u);
        }
        return sub_100764AF4(a1);
      }

      return v2;
    case 4:
      uint64_t v2 = sub_100764AF4(a1);
      if (v2 <= 2)
      {
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v36 = *(void *)(a1 + 2040);
        if (v36) {
          sub_100767578(a1, (unsigned int *)(v36 + 24), 3u);
        }
      }

      return v2;
    case 5:
      uint64_t v24 = *(unsigned int *)(a1 + 1764);
      if ((_DWORD)v24)
      {
        *(_DWORD *)(a1 + 176_Block_object_dispose(va, 8) = v24;
        *(_DWORD *)(a1 + 1292) = sub_100BF2734(v24);
        uint64_t v25 = *(void *)(a1 + 1752);
        if (v25) {
          sub_100EEF808(v25, *(_DWORD *)(a1 + 1768));
        }
      }

      if (*(_BYTE *)(a1 + 1761) || !*(_BYTE *)(a1 + 1760)) {
        return v2;
      }
      if ((*(_DWORD *)(a1 + 1440) - 2) >= 4)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v81 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "#EED2 EmergencyCallStatusChange,no ongoing call,cancel CanSendADRTimeout",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 EmergencyCallStatusChange,no ongoing call,cancel CanSendADRTimeout",  &v124,  2);
          double v106 = (uint8_t *)v105;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v105);
          if (v106 != buf) {
            free(v106);
          }
        }

        sub_10076A080(a1);
      }

      else
      {
        if (!sub_1009830B8(a1 + 112)
          && ((*(_DWORD *)(a1 + 1440) - 2) > 3 || (*(_DWORD *)(a1 + 1768) - 3) < 4))
        {
          return v2;
        }

        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v26 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "#EED2 EmergencyCallStatusChange,ADR allowed immediately",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 EmergencyCallStatusChange,ADR allowed immediately",  &v124,  2);
          double v108 = (uint8_t *)v107;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v107);
          if (v108 != buf) {
            free(v108);
          }
        }

        sub_10076A080(a1);
        *(_BYTE *)(a1 + 1761) = 1;
        sub_10076A220(a1);
      }

      return 3LL;
    case 6:
      if (*(_BYTE *)(a1 + 1763))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v32 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "#EED2 CachedLocationUpdate,triggering ADR send",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CachedLocationUpdate,triggering ADR send",  &v124,  2);
          int v89 = (uint8_t *)v88;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v88);
          if (v89 != buf) {
            free(v89);
          }
        }

        sub_10076A220(a1);
      }

      if (*(_BYTE *)(a1 + 1840))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v33 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "#EED2 CachedLocationUpdate,triggering Control Data send for APNS token",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          LODWORD(v109) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CachedLocationUpdate,triggering Control Data send for APNS token",  &v124,  v109);
          double v96 = (uint8_t *)v95;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v95);
          if (v96 != buf) {
            free(v96);
          }
        }

        sub_10076ACC0(a1);
        sub_10076BCF8(a1);
      }

      return 3LL;
    case 7:
      sub_100768AAC(a1);
      uint64_t v45 = sub_100756E48((int *)(a1 + 1448));
      sub_100763A5C(a1 + 1536, 7, *((double *)v45 + 18));
      return 3LL;
    case 8:
      *(_BYTE *)(a1 + 1762) = 1;
      goto LABEL_160;
    case 9:
      if (*(_BYTE *)(a1 + 2016) && *(_BYTE *)(a1 + 2017)) {
        goto LABEL_135;
      }
      if (*(_BYTE *)(a1 + 1762)) {
        goto LABEL_160;
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v56 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data",  &v124,  2);
      uint64_t v30 = (uint8_t *)v57;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v57);
      goto LABEL_193;
    case 10:
      if (*(_BYTE *)(a1 + 1762) || !*(_BYTE *)(a1 + 2016) || !*(_BYTE *)(a1 + 2017)) {
        return v2;
      }
LABEL_135:
      *(_BYTE *)(a1 + 1762) = 1;
      sub_10076452C(a1 + 1536, 8);
LABEL_160:
      sub_10076A220(a1);
      return v2;
    case 11:
      sub_100F9E9FC(a1, 0LL);
      return v2;
    case 12:
      *(_BYTE *)(a1 + 176sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      if (*(_BYTE *)(a1 + 1761))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v34 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "#EED2 CanSendADRTimeout,ADR sending already allowed",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 CanSendADRTimeout,ADR sending already allowed",  &v124,  2);
          uint64_t v30 = (uint8_t *)v35;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v35);
          goto LABEL_193;
        }
      }

      else
      {
        if ((*(_DWORD *)(a1 + 1440) - 2) < 4)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v55 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "#EED2 CanSendADRTimeout,ongoing emergency call,allow ADR",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v1sub_10000AE14(v9 + 24) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CanSendADRTimeout,ongoing emergency call,allow ADR",  &v124,  2);
            double v104 = (uint8_t *)v103;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v103);
            if (v104 != buf) {
              free(v104);
            }
          }

          *(_BYTE *)(a1 + 1761) = 1;
          sub_10076A220(a1);
          return 3LL;
        }

        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v58 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_ERROR,  "#EED2 CanSendADRTimeout,no ongoing emergency call",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 CanSendADRTimeout,no ongoing emergency call",  &v124,  2);
          uint64_t v30 = (uint8_t *)v59;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v59);
          goto LABEL_193;
        }
      }

      return 3LL;
    case 14:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v28 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 LIS Timeout while in ActiveSession. Ignoring it",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 LIS Timeout while in ActiveSession. Ignoring it",  &v124,  2);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v29);
      goto LABEL_193;
    case 15:
      sub_10076ACC0(a1);
      sub_10076BCF8(a1);
      return v2;
    case 16:
      sub_10076D204(a1);
      return v2;
    case 17:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v46 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected InitializationTimeout in ActiveSession state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected InitializationTimeout in ActiveSession state",  &v124,  2);
      uint64_t v30 = (uint8_t *)v47;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v47);
      goto LABEL_193;
    case 18:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      size_t v50 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected DebounceTimeout in ActiveSession state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected DebounceTimeout in ActiveSession state",  &v124,  2);
      uint64_t v30 = (uint8_t *)v51;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v51);
      goto LABEL_193;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v48 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "#EED2 PhoneNumberChanged in ActiveSession State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10000AE14(v9 + 24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 PhoneNumberChanged in ActiveSession State, no-op",  &v124,  2);
      uint64_t v30 = (uint8_t *)v49;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v49);
      goto LABEL_193;
    case 20:
      sub_100768AAC(a1);
      if (*(void *)(a1 + 1824)) {
        sub_10076ACC0(a1);
      }
      return v2;
    case 21:
      if (*(void *)(a1 + 1824))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v31 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "#EED2 BAACertDownload in ActiveSession State, sendControlData",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 BAACertDownload in ActiveSession State, sendControlData",  &v124,  2);
          double v87 = (uint8_t *)v86;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v86);
          if (v87 != buf) {
            free(v87);
          }
        }

        sub_10076ACC0(a1);
      }

      if (*(_BYTE *)(a1 + 1762) && *(_BYTE *)(a1 + 2016) && *(_BYTE *)(a1 + 2017)) {
        sub_10076A220(a1);
      }
      return 3LL;
    case 22:
      if (*(void *)(a1 + 1824)) {
        return v2;
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v52 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "#EED2 APNSReconnected and nil fAPNSToken. Request APNS token",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v1sub_10000AE14(v9 + 24) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 APNSReconnected and nil fAPNSToken. Request APNS token",  &v124,  2);
        double v102 = (uint8_t *)v101;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v101);
        if (v102 != buf) {
          free(v102);
        }
      }

      sub_100767F50(a1);
      return 3LL;
    case 23:
      sub_10076E7E0(a1);
      return v2;
    case 24:
      if (*(void *)(a1 + 1984))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v27 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#EED2 CoexMetricUpdated in ActiveSession state, cache the metric data",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CoexMetricUpdated in ActiveSession state, cache the metric data",  &v124,  2);
          int v85 = (uint8_t *)v84;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v84);
          if (v85 != buf) {
            free(v85);
          }
        }

        sub_10076ECA8(a1);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        float v53 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "#EED2 CoexMetricUpdated in ActiveSession state, but nil fCoexMetricDict",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v1sub_10000AE14(v9 + 24) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 CoexMetricUpdated in ActiveSession state, but nil fCoexMetricDict",  &v124,  2);
          uint64_t v30 = (uint8_t *)v54;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ActiveSession(CLEmergencyEED2::Event)",  "%s\n",  v54);
LABEL_193:
          if (v30 != buf) {
            free(v30);
          }
        }
      }

      return 3LL;
    default:
      return v2;
  }

void sub_10075E804( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)(v19 - 112);
  sub_10043B844(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_10075E9D4(uint64_t a1, int a2)
{
  uint64_t v2 = 4LL;
  switch(a2)
  {
    case 0:
      sub_10076A080(a1);
      goto LABEL_5;
    case 1:
      sub_1007692C8(a1);
      return v2;
    case 3:
      if (sub_100764AF4(a1) == 1)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v5 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 unexpectedly disabled during extended emergency state (i.e. EEM mode)",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v40[0]) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 unexpectedly disabled during extended emergency state (i.e. EEM mode)",  v40,  2);
          __int16 v39 = (uint8_t *)v38;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v38);
          if (v39 != buf) {
            free(v39);
          }
        }

        sub_100F9E9FC(a1, 0LL);
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 14LL);
        uint64_t v6 = *(void *)(a1 + 2040);
        if (v6) {
          sub_100767578(a1, (unsigned int *)(v6 + 24), 5u);
        }
        return sub_100764AF4(a1);
      }

      return v2;
    case 4:
      uint64_t v2 = sub_100764AF4(a1);
      if ((v2 & 6) != 2) {
        return v2;
      }
      goto LABEL_56;
    case 5:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v7 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#EED2 EmergencyCallStatusChange in ExtendedSession state,no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 EmergencyCallStatusChange in ExtendedSession state,no-op",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 6:
      if (!*(_BYTE *)(a1 + 1763)) {
        return v2;
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2 CachedLocationUpdate,triggering ADR send",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v40[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CachedLocationUpdate,triggering ADR send",  v40,  2);
        uint64_t v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }

      sub_10076A220(a1);
      return 4LL;
    case 7:
LABEL_5:
      sub_100768AAC(a1);
      int v4 = sub_100756E48((int *)(a1 + 1448));
      sub_100763A5C(a1 + 1536, 7, *((double *)v4 + 18));
      return 4LL;
    case 8:
      *(_BYTE *)(a1 + 1762) = 1;
      goto LABEL_49;
    case 9:
      if (*(_BYTE *)(a1 + 2016) && *(_BYTE *)(a1 + 2017)) {
        goto LABEL_48;
      }
      if (*(_BYTE *)(a1 + 1762)) {
        goto LABEL_49;
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v11 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 10:
      if (*(_BYTE *)(a1 + 1762) || !*(_BYTE *)(a1 + 2016) || !*(_BYTE *)(a1 + 2017)) {
        return v2;
      }
LABEL_48:
      *(_BYTE *)(a1 + 1762) = 1;
      sub_10076452C(a1 + 1536, 8);
LABEL_49:
      sub_10076A220(a1);
      return v2;
    case 11:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v12 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 SessionAssertReleased fired in ExtendedSession state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v40[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 SessionAssertReleased fired in ExtendedSession state",  v40,  2);
        unsigned int v31 = (uint8_t *)v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v30);
        if (v31 != buf) {
          free(v31);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      uint64_t v2 = sub_100764AF4(a1);
      if ((_DWORD)v2 != 4)
      {
LABEL_56:
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        uint64_t v13 = *(void *)(a1 + 2040);
        if (v13) {
          sub_100767578(a1, (unsigned int *)(v13 + 24), 3u);
        }
      }

      return v2;
    case 12:
      *(_BYTE *)(a1 + 176sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v14 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "#EED2 CanSendADRTimeout,no ongoing emergency call in ExtendedSession state, ignore Event::CanSendADRTimeout",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v16 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 CanSendADRTimeout,no ongoing emergency call in ExtendedSession state, ignore Event::CanSendADRTimeout",  v40,  2,  v40[0]);
      goto LABEL_136;
    case 14:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v17 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 LISResponseTimeout while in ExtendedSession. Ignoring it",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 LISResponseTimeout while in ExtendedSession. Ignoring it",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 15:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v18 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSTokenReceived in ExtendedSession state. Ignore it",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v40[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSTokenReceived in ExtendedSession state. Ignore it",  v40,  2);
        int v33 = (uint8_t *)v32;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v32);
        if (v33 != buf) {
          free(v33);
        }
      }

      uint64_t v19 = *(void **)(a1 + 1824);
      if (v19)
      {

        *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
      }

      return 4LL;
    case 16:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v20 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSMessageReceived in ExtendedSession state. Add directly to RequestsHandled queue",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v40[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSMessageReceived in ExtendedSession state. Add directly to RequestsHandled queue",  v40,  2);
        int v35 = (uint8_t *)v34;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v34);
        if (v35 != buf) {
          free(v35);
        }
      }

      sub_10076EF58(a1);
      return 4LL;
    case 17:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v21 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected InitializationTimeout in ExtendedSession state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v16 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected InitializationTimeout in ExtendedSession state",  v40,  2,  v40[0]);
      goto LABEL_136;
    case 18:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v26 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "#Warning #EED2 unexpected DebounceTimeout in ExtendedSession state",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v16 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#Warning #EED2 unexpected DebounceTimeout in ExtendedSession state",  v40,  2,  v40[0]);
LABEL_136:
      int v27 = v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v16);
      goto LABEL_160;
    case 19:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v22 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#EED2 PhoneNumberChanged in ExtendedSession State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 PhoneNumberChanged in ExtendedSession State, no-op",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 20:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v23 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#EED2 CallEndpointChanged in ExtendedSession State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 CallEndpointChanged in ExtendedSession State, no-op",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 21:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v24 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#EED2 BAACertDownload in ExtendedSession State, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 BAACertDownload in ExtendedSession State, no-op",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 22:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v28 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 APNSReconnected in ExtendedSession state, Ignore it",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 APNSReconnected in ExtendedSession state, Ignore it",  v40,  2,  v40[0]);
      goto LABEL_159;
    case 23:
      sub_10076E7E0(a1);
      return v2;
    case 24:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v25 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2 CoexMetricUpdated in ExtendedSession state, no-op",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 4LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 CoexMetricUpdated in ExtendedSession state, no-op",  v40,  2,  v40[0]);
LABEL_159:
      int v27 = v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyEED2::State CLEmergencyEED2::handler_ExtendedSession(CLEmergencyEED2::Event)",  "%s\n",  v9);
LABEL_160:
      if (v27 != buf) {
        free(v27);
      }
      return 4LL;
    default:
      return v2;
  }

uint64_t sub_10075FC24()
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v0 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "#EED2,#BAA,deleting cached info", buf, 2u);
  }

  uint64_t v1 = sub_1002921D0(115, 2);
  if ((_DWORD)v1)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v19[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,deleting cached info",  v19,  2);
    int v11 = (uint8_t *)v10;
    uint64_t v1 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::deleteCachedBaaInfo()", "%s\n", v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  uint64_t v2 = sub_100770338(v1, (uint64_t)@"com.apple.locationd.BAA.key");
  if ((v2 & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA private key",  buf,  2u);
    }

    uint64_t v2 = sub_1002921D0(115, 2);
    if ((_DWORD)v2)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v19[0] = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA private key",  v19,  v18);
      uint64_t v13 = (uint8_t *)v12;
      uint64_t v2 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::deleteCachedBaaInfo()", "%s\n", v12);
      if (v13 != buf) {
        free(v13);
      }
    }
  }

  uint64_t v4 = sub_1007709D0(v2, (uint64_t)@"com.apple.locationd.BAA.leafCert");
  if ((v4 & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA leaf cert",  buf,  2u);
    }

    uint64_t v4 = sub_1002921D0(115, 2);
    if ((_DWORD)v4)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v19[0] = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA leaf cert",  v19,  v18);
      uint64_t v15 = (uint8_t *)v14;
      uint64_t v4 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::deleteCachedBaaInfo()", "%s\n", v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

  if (!sub_1007709D0(v4, (uint64_t)@"com.apple.locationd.BAA.intCert"))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA intermediate cert",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v19[0] = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA intermediate cert",  v19,  v18);
      uint64_t v17 = (uint8_t *)v16;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::deleteCachedBaaInfo()", "%s\n", v16);
      if (v17 != buf) {
        free(v17);
      }
    }
  }

  uint64_t v7 = sub_1002F8DDC();
  *(_DWORD *)uint64_t buf = 0;
  sub_1002AC288(v7, @"BaaNextCertRequestTime", buf);
  uint64_t v8 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 944LL))(v8);
}

void sub_100760180(void *a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EED2,#BAA,loading cached info", buf, 2u);
  }

  uint64_t v3 = sub_1002921D0(115, 2);
  if ((_DWORD)v3)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v40[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,loading cached info",  v40,  2);
    char v22 = (uint8_t *)v21;
    uint64_t v3 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v21);
    if (v22 != buf) {
      free(v22);
    }
  }

  CFTypeRef v39 = 0LL;
  BOOL v4 = sub_1007700F8(v3, (uint64_t)@"com.apple.locationd.BAA.key", &v39);
  if (v4)
  {
    uint64_t v5 = a1[210];
    if (v5) {
      CFRelease((CFTypeRef)v5);
    }
    a1[210] = v39;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to retrieve BAA private key from keychain",  buf,  2u);
    }

    uint64_t v5 = sub_1002921D0(115, 2);
    if ((_DWORD)v5)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to retrieve BAA private key from keychain",  v40,  v36);
      uint64_t v29 = (uint8_t *)v28;
      uint64_t v5 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v28);
      if (v29 != buf) {
        free(v29);
      }
    }
  }

  CFTypeRef v38 = 0LL;
  if (sub_1007707A4(v5, (uint64_t)@"com.apple.locationd.BAA.leafCert", &v38))
  {
    uint64_t v7 = a1[211];
    if (v7) {
      CFRelease((CFTypeRef)v7);
    }
    a1[211] = v38;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to retrieve BAA leaf cert from keychain",  buf,  2u);
    }

    uint64_t v7 = sub_1002921D0(115, 2);
    if ((_DWORD)v7)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to retrieve BAA leaf cert from keychain",  v40,  v36);
      unsigned int v31 = (uint8_t *)v30;
      uint64_t v7 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v30);
      if (v31 != buf) {
        free(v31);
      }
    }

    BOOL v4 = 0;
  }

  CFTypeRef v37 = 0LL;
  if (!sub_1007707A4(v7, (uint64_t)@"com.apple.locationd.BAA.intCert", &v37))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to retrieve BAA intermediate cert from keychain",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to retrieve BAA intermediate cert from keychain",  v40,  v36);
      int v33 = (uint8_t *)v32;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v32);
      if (v33 != buf) {
        free(v33);
      }
    }

    goto LABEL_35;
  }

  double v9 = (const void *)a1[212];
  if (v9) {
    CFRelease(v9);
  }
  a1[212] = v37;
  if (!v4)
  {
LABEL_35:
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v12 = a1[210] == 0LL;
      BOOL v13 = a1[211] == 0LL;
      BOOL v14 = a1[212] == 0LL;
      *(_DWORD *)uint64_t buf = 67240704;
      BOOL v46 = v12;
      __int16 v47 = 1026;
      BOOL v48 = v13;
      __int16 v49 = 1026;
      BOOL v50 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,following info missing in keychain,private key,%{public}d,leaf cert,%{public}d,intermediate cert,%{public}d",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      BOOL v23 = a1[210] == 0LL;
      BOOL v24 = a1[211] == 0LL;
      BOOL v25 = a1[212] == 0LL;
      v40[0] = 67240704;
      v40[1] = v23;
      __int16 v41 = 1026;
      BOOL v42 = v24;
      __int16 v43 = 1026;
      BOOL v44 = v25;
      LODWORD(v36) = 20;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,following info missing in keychain,private key,%{public}d,leaf cert,%{public}d,intermediate cert,%{public}d",  v40,  v36);
      int v27 = (uint8_t *)v26;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v26);
      if (v27 != buf) {
        free(v27);
      }
    }

    uint64_t v15 = (const void *)a1[210];
    if (v15)
    {
      CFRelease(v15);
      a1[210] = 0LL;
    }

    double v16 = (const void *)a1[211];
    if (v16)
    {
      CFRelease(v16);
      a1[211] = 0LL;
    }

    uint64_t v17 = (const void *)a1[212];
    if (v17)
    {
      CFRelease(v17);
      a1[212] = 0LL;
    }
  }

  uint64_t v18 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v18 + 936LL))(v18);
  uint64_t v19 = sub_1002F8DDC();
  if ((sub_1002A832C(v19, (uint64_t)@"BaaNextCertRequestTime", a1 + 213) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    char v20 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,cache did not contain next BAA cert request time",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v40[0]) = 0;
      LODWORD(v36) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,cache did not contain next BAA cert request time",  v40,  v36);
      int v35 = (uint8_t *)v34;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::loadCachedBaaInfo()", "%s\n", v34);
      if (v35 != buf) {
        free(v35);
      }
    }
  }

  sub_100770E24(a1);
}

void sub_100760A68(uint64_t a1, unsigned int a2)
{
  int v4 = sub_1007718B4((void *)a1);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    sub_100771920(a2, __p);
    uint64_t v6 = v31 >= 0 ? __p : (void **)__p[0];
    uint64_t v7 = *(void *)(a1 + 1704);
    *(_DWORD *)uint64_t buf = 68289794;
    int v33 = 0;
    __int16 v34 = 2082;
    int v35 = "";
    __int16 v36 = 2082;
    CFTypeRef v37 = v6;
    __int16 v38 = 1026;
    int v39 = v4;
    __int16 v40 = 2050;
    uint64_t v41 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,#BAA,checking cert request status, reason:%{public, location:escape_only}s, v alid cart available:%{public}hhd, next scheduled request:%{public}.1f}",  buf,  0x2Cu);
    if (v31 < 0) {
      operator delete(__p[0]);
    }
  }

  if (*(_BYTE *)(a1 + 1677))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,there is a cert request outstanding already,no need to do anything until we get a response",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,there is a cert request outstanding already,no need to do anything until we get a response",  __p,  2);
    BOOL v13 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v18);
LABEL_72:
    if (v13 != buf) {
      free(v13);
    }
    return;
  }

  if (!*(_BYTE *)(a1 + 1676))
  {
    if ((sub_100756950(a1 + 1448) & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v11 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,no need to start XPC activity",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(__p[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,no need to start XPC activity",  __p,  2);
        BOOL v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v12);
        goto LABEL_72;
      }

      return;
    }

    if (!*(_BYTE *)(a1 + 1676))
    {
LABEL_18:
      switch(a2)
      {
        case 0u:
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          BOOL v14 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,need to start XPC activity",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(__p[0]) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,need to start XPC activity",  __p,  2);
            BOOL v24 = (uint8_t *)v23;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v23);
            if (v24 != buf) {
              free(v24);
            }
          }

          sub_100771AF8(a1, 0);
          sub_1007720E8(a1);
          break;
        case 1u:
          if (sub_100771AF8(a1, 1))
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            uint64_t v15 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,next cert request time changed so (re)starting XPC activity",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              LOWORD(__p[0]) = 0;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,next cert request time changed so (re)starting XPC activity",  __p,  2);
              int v26 = (uint8_t *)v25;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v25);
              if (v26 != buf) {
                free(v26);
              }
            }

            sub_10077194C(a1);
            sub_1007720E8(a1);
          }

          else if (!*(_BYTE *)(a1 + 1676))
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            uint64_t v17 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,need to start XPC activity",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              LOWORD(__p[0]) = 0;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,need to start XPC activity",  __p,  2);
              uint64_t v29 = (uint8_t *)v28;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v28);
              if (v29 != buf) {
                free(v29);
              }
            }

            sub_1007720E8(a1);
          }

          break;
        case 2u:
          if ((v4 & 1) == 0)
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            double v16 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,need to request cert immediately for ongoing session",  buf,  2u);
            }

            if (!sub_1002921D0(115, 2)) {
              goto LABEL_33;
            }
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(__p[0]) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,need to request cert immediately for ongoing session",  __p,  2);
            char v20 = (uint8_t *)v27;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v27);
            if (v20 == buf) {
              goto LABEL_33;
            }
            goto LABEL_77;
          }

          break;
        case 3u:
        case 4u:
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          double v9 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,scheduling next cert request",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(__p[0]) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,scheduling next cert request",  __p,  2);
            char v22 = (uint8_t *)v21;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v21);
            if (v22 != buf) {
              free(v22);
            }
          }

          sub_100771AF8(a1, a2);
          sub_1007720E8(a1);
          break;
        default:
          return;
      }

      return;
    }
  }

  if ((sub_100756950(a1 + 1448) & 1) != 0) {
    goto LABEL_18;
  }
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v10 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,need to stop XPC activity due to device settings",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,need to stop XPC activity due to device settings",  __p,  2);
    char v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::checkBaaCertRequestStatus(CertRequestStatusCheckReason)",  "%s\n",  v19);
    if (v20 != buf) {
LABEL_77:
    }
      free(v20);
  }

uint64_t sub_1007615DC(uint64_t a1, uint64_t a2)
{
  unsigned int v100 = *(_DWORD *)(a1 + 4);
  if (!*(void *)(a1 + 32))
  {
    sub_101249D88();
    goto LABEL_157;
  }

  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (!*(_BYTE *)(a1 + 48))
  {
    sub_101249EF8(qword_101934880 == -1);
    goto LABEL_157;
  }

  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10184E0C0);
  }
  uint64_t v5 = (os_log_s *)qword_101934888;
  os_log_type_t v6 = *(_BYTE *)(a1 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v6))
  {
    uint64_t v7 = (void *)(a1 + 96);
    sub_100762504(*(_DWORD *)(a1 + 4), __p);
    int v8 = SHIBYTE(v104);
    double v9 = *(_BYTE **)__p;
    sub_1007624D8(a2, v111);
    int v10 = __p;
    if (v8 < 0) {
      int v10 = v9;
    }
    if (v114 >= 0) {
      int v11 = v111;
    }
    else {
      int v11 = *(_BYTE **)v111;
    }
    *(_DWORD *)uint64_t buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v107 = 2080;
    double v108 = v10;
    __int16 v109 = 2080;
    double v110 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%scurrent_state,%s,event,%s", buf, 0x20u);
    if (v114 < 0) {
      operator delete(*(void **)v111);
    }
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (SHIBYTE(v104) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    uint64_t v58 = (void *)(a1 + 96);
    uint64_t v59 = qword_101934888;
    uint64_t v60 = *(unsigned __int8 *)(a1 + 120);
    sub_100762504(*(_DWORD *)(a1 + 4), v111);
    int v61 = v114;
    __int16 v62 = *(_BYTE **)v111;
    sub_1007624D8(a2, v98);
    uint64_t v63 = v111;
    if (v61 < 0) {
      uint64_t v63 = v62;
    }
    if (v99 >= 0) {
      uint64_t v64 = v98;
    }
    else {
      uint64_t v64 = (void **)v98[0];
    }
    *(_DWORD *)std::string __p = 136315650;
    *(void *)&__p[4] = v58;
    __int16 v102 = 2080;
    __int16 v103 = v63;
    __int16 v104 = 2080;
    __int16 v105 = v64;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v59,  v60,  "%scurrent_state,%s,event,%s",  __p,  32,  v96);
    int v66 = v65;
    if (v99 < 0) {
      operator delete(v98[0]);
    }
    p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
    if (v114 < 0) {
      operator delete(*(void **)v111);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyEED2>::handleEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v66);
    if (v66 != buf) {
      free(v66);
    }
  }

  uint64_t v12 = *(void *)(a1 + 16);
  if (!v12) {
    goto LABEL_28;
  }
  BOOL v13 = (uint64_t **)(a1 + 8);
  int v14 = *(_DWORD *)(a1 + 4);
  uint64_t v15 = a1 + 16;
  do
  {
    int v16 = *(_DWORD *)(v12 + 32);
    BOOL v17 = v16 < v14;
    if (v16 >= v14) {
      uint64_t v18 = (uint64_t *)v12;
    }
    else {
      uint64_t v18 = (uint64_t *)(v12 + 8);
    }
    if (!v17) {
      uint64_t v15 = v12;
    }
    uint64_t v12 = *v18;
  }

  while (*v18);
  if (v15 == a1 + 16 || v14 < *(_DWORD *)(v15 + 32))
  {
LABEL_28:
    sub_10124A06C();
    goto LABEL_157;
  }

  char v20 = *(uint64_t (**)(void *, uint64_t))(v15 + 40);
  uint64_t v19 = *(void *)(v15 + 48);
  uint64_t v21 = (void *)(*(void *)(a1 + 32) + (v19 >> 1));
  if ((v19 & 1) != 0) {
    char v20 = *(uint64_t (**)(void *, uint64_t))(*v21 + v20);
  }
  uint64_t v22 = v20(v21, a2);
  uint64_t v23 = v22;
  int v97 = v22;
  if (a2 <= 1 && (_DWORD)v22 != v100)
  {
    sub_10124A4BC();
    goto LABEL_157;
  }

  if (*(_DWORD *)(a1 + 88) >= 2u)
  {
    BOOL v24 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      BOOL v25 = (void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "%sNested invocation of state machine",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      int v73 = (void *)(a1 + 96);
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v73;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "%sNested invocation of state machine",  __p);
      uint64_t v75 = (char *)v74;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "State CLStateMachine<CLEmergencyEED2>::handleEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v74);
      if (v75 != buf) {
        free(v75);
      }
    }
  }

  int v26 = (os_log_s *)qword_101934888;
  os_log_type_t v27 = *(_BYTE *)(a1 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v27))
  {
    uint64_t v28 = (void *)(a1 + 96);
    sub_100762504(v23, buf);
    if (v109 >= 0) {
      uint64_t v29 = buf;
    }
    else {
      uint64_t v29 = *(_BYTE **)buf;
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v28;
    __int16 v102 = 2080;
    __int16 v103 = v29;
    _os_log_impl((void *)&_mh_execute_header, v26, v27, "%snewState,%s", __p, 0x16u);
    if (SHIBYTE(v109) < 0) {
      operator delete(*(void **)buf);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v67 = (void *)(a1 + 96);
    uint64_t v68 = qword_101934888;
    uint64_t v69 = *(unsigned __int8 *)(a1 + 120);
    sub_100762504(v23, __p);
    if (v104 >= 0) {
      char v70 = __p;
    }
    else {
      char v70 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int16 v111 = 136315394;
    *(void *)&uint64_t v111[4] = v67;
    __int16 v112 = 2080;
    __int16 v113 = v70;
    LODWORD(v95) = 22;
    _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v68, v69, "%snewState,%s", v111, v95);
    __int16 v72 = v71;
    if (SHIBYTE(v104) < 0) {
      operator delete(*(void **)__p);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyEED2>::handleEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v72);
    if (v72 != buf) {
      free(v72);
    }
  }

  if ((_DWORD)v23 != v100)
  {
    uint64_t v30 = (os_log_s *)qword_101934888;
    os_log_type_t v31 = *(_BYTE *)(a1 + 120);
    if (os_log_type_enabled((os_log_t)qword_101934888, v31))
    {
      unsigned int v32 = (void *)(a1 + 96);
      sub_100762504(v100, __p);
      int v33 = p_vtable;
      int v34 = SHIBYTE(v104);
      int v35 = *(_BYTE **)__p;
      sub_1010DDBC0(v111, "Exit");
      __int16 v36 = __p;
      if (v34 < 0) {
        __int16 v36 = v35;
      }
      if (v114 >= 0) {
        CFTypeRef v37 = v111;
      }
      else {
        CFTypeRef v37 = *(_BYTE **)v111;
      }
      *(_DWORD *)uint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = v32;
      __int16 v107 = 2080;
      double v108 = v36;
      __int16 v109 = 2080;
      double v110 = v37;
      _os_log_impl((void *)&_mh_execute_header, v30, v31, "%soldState,%s,event,%s", buf, 0x20u);
      if (v114 < 0) {
        operator delete(*(void **)v111);
      }
      p_vtable = v33;
      if (SHIBYTE(v104) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      uint64_t v76 = (void *)(a1 + 96);
      uint64_t v77 = qword_101934888;
      uint64_t v78 = *(unsigned __int8 *)(a1 + 120);
      sub_100762504(v100, v111);
      uint64_t v79 = p_vtable;
      int v80 = v114;
      int v81 = *(_BYTE **)v111;
      sub_1010DDBC0(v98, "Exit");
      __int16 v82 = v111;
      if (v80 < 0) {
        __int16 v82 = v81;
      }
      if (v99 >= 0) {
        double v83 = v98;
      }
      else {
        double v83 = (void **)v98[0];
      }
      *(_DWORD *)std::string __p = 136315650;
      *(void *)&__p[4] = v76;
      __int16 v102 = 2080;
      __int16 v103 = v82;
      __int16 v104 = 2080;
      __int16 v105 = v83;
      LODWORD(v95) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v77,  v78,  "%soldState,%s,event,%s",  __p,  v95,  (const char *)(a1 + 8));
      int v85 = v84;
      if (v99 < 0) {
        operator delete(v98[0]);
      }
      p_vtable = v79;
      BOOL v13 = (uint64_t **)v96;
      if (v114 < 0) {
        operator delete(*(void **)v111);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyEED2>::handleEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v85);
      if (v85 != buf) {
        free(v85);
      }
    }

    uint64_t v38 = *(void *)(a1 + 32);
    *(void *)uint64_t buf = &v100;
    int v39 = sub_100783544(v13, (int *)&v100, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
    __int16 v40 = v39[5];
    uint64_t v41 = (uint64_t)v39[6];
    BOOL v42 = (void *)(v38 + (v41 >> 1));
    if ((v41 & 1) != 0) {
      __int16 v40 = *(uint64_t **)(*v42 + v40);
    }
    int v43 = ((uint64_t (*)(void *, uint64_t))v40)(v42, 1LL);
    if (v43 == v100)
    {
      *(_DWORD *)(a1 + 4) = v23;
      BOOL v44 = (os_log_s *)qword_101934888;
      os_log_type_t v45 = *(_BYTE *)(a1 + 120);
      if (os_log_type_enabled((os_log_t)qword_101934888, v45))
      {
        BOOL v46 = (void *)(a1 + 96);
        sub_100762504(v23, __p);
        __int16 v47 = p_vtable;
        int v48 = SHIBYTE(v104);
        __int16 v49 = *(_BYTE **)__p;
        sub_1010DDBC0(v111, "Enter");
        BOOL v50 = __p;
        if (v48 < 0) {
          BOOL v50 = v49;
        }
        if (v114 >= 0) {
          float v51 = v111;
        }
        else {
          float v51 = *(_BYTE **)v111;
        }
        *(_DWORD *)uint64_t buf = 136315650;
        *(void *)&uint8_t buf[4] = v46;
        __int16 v107 = 2080;
        double v108 = v50;
        __int16 v109 = 2080;
        double v110 = v51;
        _os_log_impl((void *)&_mh_execute_header, v44, v45, "%snewState,%s,event,%s", buf, 0x20u);
        if (v114 < 0) {
          operator delete(*(void **)v111);
        }
        p_vtable = v47;
        if (SHIBYTE(v104) < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        __int16 v86 = (void *)(a1 + 96);
        uint64_t v87 = qword_101934888;
        uint64_t v88 = *(unsigned __int8 *)(a1 + 120);
        sub_100762504(v23, v111);
        int v89 = v114;
        uint64_t v90 = *(_BYTE **)v111;
        sub_1010DDBC0(v98, "Enter");
        int v91 = v111;
        if (v89 < 0) {
          int v91 = v90;
        }
        if (v99 >= 0) {
          int v92 = v98;
        }
        else {
          int v92 = (void **)v98[0];
        }
        *(_DWORD *)std::string __p = 136315650;
        *(void *)&__p[4] = v86;
        __int16 v102 = 2080;
        __int16 v103 = v91;
        __int16 v104 = 2080;
        __int16 v105 = v92;
        LODWORD(v95) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v87,  v88,  "%snewState,%s,event,%s",  __p,  v95,  v96);
        double v94 = v93;
        if (v99 < 0) {
          operator delete(v98[0]);
        }
        if (v114 < 0) {
          operator delete(*(void **)v111);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyEED2>::handleEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v94);
        if (v94 != buf) {
          free(v94);
        }
      }

      uint64_t v52 = *(void *)(a1 + 32);
      *(void *)uint64_t buf = &v97;
      float v53 = sub_100783544(v13, &v97, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      __int16 v54 = v53[5];
      uint64_t v55 = (uint64_t)v53[6];
      __int16 v56 = (void *)(v52 + (v55 >> 1));
      if ((v55 & 1) != 0) {
        __int16 v54 = *(uint64_t **)(*v56 + v54);
      }
      uint64_t v23 = ((uint64_t (*)(void *, void))v54)(v56, 0LL);
      if ((_DWORD)v23 == v97) {
        goto LABEL_89;
      }
      sub_10124A1DC();
    }

    else
    {
      sub_10124A34C();
    }

void sub_1007622C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
}

uint64_t sub_100762328(uint64_t a1)
{
  *(void *)a1 = off_10184DD48;

  *(void *)(a1 + 1664) = 0LL;
  uint64_t v2 = *(const void **)(a1 + 1680);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 168sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  uint64_t v3 = *(const void **)(a1 + 1688);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 168_Block_object_dispose(va, 8) = 0LL;
  }

  int v4 = *(const void **)(a1 + 1696);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 1696) = 0LL;
  }

  *(void *)(a1 + 1712) = 0LL;
  *(void *)(a1 + 172sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;

  *(void *)(a1 + 172_Block_object_dispose(va, 8) = 0LL;
  [*(id *)(a1 + 1736) invalidate];

  *(void *)(a1 + 1736) = 0LL;
  [*(id *)(a1 + 2024) invalidate];

  *(void *)(a1 + 20sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 204_Block_object_dispose(va, 8) = 0LL;

  *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
  *(void *)(a1 + 1832) = 0LL;

  *(void *)(a1 + 184_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 1944) = 0LL;

  *(void *)(a1 + 1864) = 0LL;
  *(void *)(a1 + 188_Block_object_dispose(va, 8) = 0LL;

  *(void *)(a1 + 1896) = 0LL;
  *(void *)(a1 + 1904) = 0LL;

  *(void *)(a1 + 1912) = 0LL;
  *(void *)(a1 + 1984) = 0LL;
  uint64_t v5 = *(void **)(a1 + 2040);
  *(void *)(a1 + 204sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  if (v5) {
    operator delete(v5);
  }
  sub_1004C1CC0(a1 + 1992, *(void **)(a1 + 2000));
  sub_100783518((uint64_t *)(a1 + 1880), 0LL);
  sub_100019CEC(a1 + 1776);
  sub_1007834EC((uint64_t *)(a1 + 1752), 0LL);
  sub_100783408(a1 + 1536);
  sub_100782D68(a1 + 1496);
  sub_100782D68(a1 + 1456);
  return sub_100F9E660(a1);
}

void sub_1007624BC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100762328(a1);
  operator delete(v1);
}

uint64_t sub_1007624D0(uint64_t a1)
{
  return sub_1007563B0(a1 + 1448);
}

void *sub_1007624D8@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 0x18) {
    uint64_t v2 = "EventUnknown";
  }
  else {
    uint64_t v2 = off_10184E440[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

void *sub_100762504@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 4) {
    uint64_t v2 = "StateUnknown";
  }
  else {
    uint64_t v2 = off_10184E508[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

void *sub_100762530@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1) {
    uint64_t v2 = "Companion";
  }
  else {
    uint64_t v2 = "Native";
  }
  return sub_1010DDBC0(a2, v2);
}

void sub_100762550(uint64_t a1)
{
  uint64_t v2 = a1 + 1448;
  uint64_t v3 = sub_100756E48((int *)(a1 + 1448));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v5 = sub_100756190(v2);
    int v6 = *(unsigned __int8 *)(a1 + 1452);
    int v7 = *(_DWORD *)v3;
    if (*((char *)v3 + 55) < 0)
    {
      sub_1010DD48C(__dst, (void *)v3[4], v3[5]);
    }

    else
    {
      *(_OWORD *)__uuid_t dst = *((_OWORD *)v3 + 2);
      uint64_t v22 = v3[6];
    }

    if (v22 >= 0) {
      int v8 = __dst;
    }
    else {
      int v8 = (void **)__dst[0];
    }
    if (*((char *)v3 + 31) < 0)
    {
      sub_1010DD48C(v19, (void *)v3[1], v3[2]);
    }

    else
    {
      *(_OWORD *)uint64_t v19 = *(_OWORD *)(v3 + 1);
      uint64_t v20 = v3[3];
    }

    if (v20 >= 0) {
      double v9 = v19;
    }
    else {
      double v9 = (void **)v19[0];
    }
    if (*((char *)v3 + 87) < 0)
    {
      sub_1010DD48C(v17, (void *)v3[8], v3[9]);
    }

    else
    {
      *(_OWORD *)BOOL v17 = *((_OWORD *)v3 + 4);
      uint64_t v18 = v3[10];
    }

    if (v18 >= 0) {
      int v10 = v17;
    }
    else {
      int v10 = (void **)v17[0];
    }
    if (*((char *)v3 + 111) < 0)
    {
      sub_1010DD48C(v15, (void *)v3[11], v3[12]);
    }

    else
    {
      *(_OWORD *)uint64_t v15 = *(_OWORD *)(v3 + 11);
      uint64_t v16 = v3[13];
    }

    if (v16 >= 0) {
      int v11 = v15;
    }
    else {
      int v11 = (void **)v15[0];
    }
    if (*((char *)v3 + 135) < 0)
    {
      sub_1010DD48C(__p, (void *)v3[14], v3[15]);
    }

    else
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v3 + 7);
      uint64_t v14 = v3[16];
    }

    uint64_t v12 = __p;
    if (v14 < 0) {
      uint64_t v12 = (void **)__p[0];
    }
    *(_DWORD *)uint64_t buf = 68291075;
    int v24 = 0;
    __int16 v25 = 2082;
    int v26 = "";
    __int16 v27 = 1026;
    BOOL v28 = v5;
    __int16 v29 = 1026;
    int v30 = v6;
    __int16 v31 = 1026;
    int v32 = v7;
    __int16 v33 = 2082;
    int v34 = v8;
    __int16 v35 = 2082;
    __int16 v36 = v9;
    __int16 v37 = 2081;
    uint64_t v38 = v10;
    __int16 v39 = 2081;
    __int16 v40 = v11;
    __int16 v41 = 2081;
    BOOL v42 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2 logging current settings, enabled:%{public}d, switch state:%{public}d, in st:%{public}d, bundle ID:%{public, location:escape_only}s, bundle version:%{public, location:escape_only }s, LIS URL:%{private, location:escape_only}s, ADR URL:%{private, location:escape_only}s, Control URL: %{private, location:escape_only}s}",  buf,  0x56u);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v16) < 0) {
      operator delete(v15[0]);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete(__dst[0]);
    }
  }

void sub_100762848( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007628B4(uint64_t a1, uint64_t a2)
{
  int v4 = (unsigned int *)(a1 + 112);
  if (!sub_1009830C8(a1 + 112) && sub_1009830C8(a2))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    BOOL v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = (void *)(a1 + 136);
      int v7 = *(unsigned __int8 *)(a1 + 1452);
      *(_DWORD *)uint64_t buf = 68289539;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2081;
      uint64_t v22 = v6;
      __int16 v23 = 1026;
      int v24 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EmgContext #EED2, CompanionNum:%{private, location:escape_only}s, UserToggle:%{public}d}",  buf,  0x22u);
    }
  }

  __int128 v8 = *(_OWORD *)a2;
  v4[4] = *(_DWORD *)(a2 + 16);
  *(_OWORD *)int v4 = v8;
  sub_100F9EF4C(a1);
  uint64_t v9 = *(void *)(a1 + 1752);
  if (v9) {
    sub_100EEF5E8(v9, *(_DWORD *)(a1 + 132));
  }
  uint64_t v10 = *(void *)(a1 + 1880);
  if (v10) {
    sub_100CC7C00(v10, *(_DWORD *)(a1 + 132));
  }
  int v11 = sub_100496E10(v4);
  if (sub_100755ADC((int *)(a1 + 1448), v11))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v18 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#EED2 active inst changed to %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v16[0] = 67240192;
      v16[1] = v11;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 active inst changed to %{public}d",  v16,  8);
      uint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyEED2::handleEmergencyStateChange(CLEmergencyState)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
    sub_1007615DC(a1 + 1536, 3LL);
    sub_100760A68(a1, 1u);
  }

  return sub_1007615DC(a1 + 1536, 4LL);
}

id sub_100762BB8(uint64_t a1, void *a2, int a3, int a4, unsigned int a5)
{
  id result = a2;
  *(void *)(a1 + 1864) = result;
  int v11 = *(_DWORD *)(a1 + 1764);
  int v12 = *(_DWORD *)(a1 + 1440);
  if (v11 != a3 || v12 != a4)
  {
    sub_100F9F12C(a1, v12, a4);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v14 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BF2720(*(_DWORD *)(a1 + 1764), v43);
      if (v46 >= 0) {
        uint64_t v15 = v43;
      }
      else {
        uint64_t v15 = *(_BYTE **)v43;
      }
      sub_100BF2720(a3, v31);
      int v16 = a5;
      if (v32 >= 0) {
        BOOL v17 = v31;
      }
      else {
        BOOL v17 = (void **)v31[0];
      }
      sub_100BF270C(*(_DWORD *)(a1 + 1440), v29);
      int v18 = v30;
      __int16 v19 = (void **)v29[0];
      sub_100BF270C(a4, __p);
      uint64_t v20 = v29;
      if (v18 < 0) {
        uint64_t v20 = v19;
      }
      __int16 v21 = __p;
      if (v28 < 0) {
        __int16 v21 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 68290306;
      *(_DWORD *)int v34 = 0;
      *(_WORD *)&v34[4] = 2082;
      *(void *)&v34[6] = "";
      *(_WORD *)&v34[14] = 2082;
      *(void *)&v34[16] = v15;
      __int16 v35 = 2082;
      __int16 v36 = v17;
      __int16 v37 = 2082;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = v21;
      __int16 v41 = 1026;
      a5 = v16;
      int v42 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2 emergency call status change, old trigger:%{public, location:escape_only}s,  new trigger:%{public, location:escape_only}s, old call status:%{public, location:escape_only}s, new call status:%{public, location:escape_only}s, endpointOnCurrentDevice:%{public}hhd}",  buf,  0x40u);
      if (v28 < 0) {
        operator delete(__p[0]);
      }
      if (v30 < 0) {
        operator delete(v29[0]);
      }
      if (v32 < 0) {
        operator delete(v31[0]);
      }
      if (v46 < 0) {
        operator delete(*(void **)v43);
      }
    }

    *(_DWORD *)(a1 + 1764) = a3;
    *(_DWORD *)(a1 + 144sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a4;
    id result = (id)sub_1007615DC(a1 + 1536, 5LL);
    if (*(unsigned __int8 *)(a1 + 1856) != a5)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v22 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = *(unsigned __int8 *)(a1 + 1856);
        *(_DWORD *)uint64_t buf = 134349312;
        *(void *)int v34 = v23;
        *(_WORD *)&_WORD v34[8] = 2050;
        *(void *)&v34[10] = a5;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#EED2 callEndpointOnCurrentDevice changed from %{public}ld to %{public}ld",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v24 = *(unsigned __int8 *)(a1 + 1856);
        *(_DWORD *)int v43 = 134349312;
        *(void *)&v43[4] = v24;
        __int16 v44 = 2050;
        uint64_t v45 = a5;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 callEndpointOnCurrentDevice changed from %{public}ld to %{public}ld",  v43,  22);
        int v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyEED2::handleEmergencyCallStatusChange(NSString *, EmergencyTriggerType, CallStatus, BOOL)",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      *(_BYTE *)(a1 + 1856) = a5;
      id result = (id)sub_1007615DC(a1 + 1536, 20LL);
    }

    if (v11 != a3 && (*(_DWORD *)(a1 + 1440) - 2) <= 3)
    {
      if (*(_BYTE *)(a1 + 1453)) {
        return (id)sub_1007615DC(a1 + 1536, 9LL);
      }
    }
  }

  return result;
}

void sub_100762FB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10076300C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1448;
  uint64_t v5 = sub_10075588C(a1 + 1448, (int *)a2);
  int v6 = sub_100755F4C(v4, *(_DWORD *)a2, (unsigned __int8 *)(a2 + 1008), (unsigned __int8 *)(a2 + 1036));
  if ((_DWORD)v5)
  {
    sub_1007615DC(a1 + 1536, 3LL);
LABEL_4:
    sub_100760A68(a1, 1u);
    return v5;
  }

  if (v6) {
    goto LABEL_4;
  }
  return v5;
}

uint64_t sub_100763080(uint64_t a1)
{
  return sub_1007615DC(a1 + 1536, 6LL);
}

uint64_t sub_10076308C(uint64_t a1, int a2)
{
  int v5 = a2;
  int v6 = &v5;
  *((_BYTE *)sub_1007837B4(a1 + 1776, &v5, (uint64_t)&unk_1012CF090, &v6) + 2sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
  uint64_t v3 = *(void *)(a1 + 1752);
  if (v3) {
    sub_100EEF028(v3, v5);
  }
  return sub_1007615DC(a1 + 1536, 19LL);
}

std::string *sub_1007630FC(uint64_t a1, const std::string *a2)
{
  uint64_t v4 = *(void *)(a1 + 1752);
  if (v4) {
    sub_100EEF1D0(v4, a2);
  }
  id result = *(std::string **)(a1 + 1880);
  if (result) {
    return sub_100CC7E20(result, a2);
  }
  return result;
}

uint64_t sub_100763148(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 1752);
  if (result)
  {
    uint64_t result = sub_100EEF3A8(result, a2);
    if ((_DWORD)result)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2 handleBatteryStatusChange,change in battery bin",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v7[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 handleBatteryStatusChange,change in battery bin",  v7,  2);
        int v6 = (uint8_t *)v5;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyEED2::handleBatteryStatusChange(const Battery &)",  "%s\n",  v5);
        if (v6 != buf) {
          free(v6);
        }
      }

      return sub_1007615DC(a1 + 1536, 9LL);
    }
  }

  return result;
}

void sub_1007632F4(uint64_t a1, unsigned int a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 134349056;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2 handleReachability,%{public}ld",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v7 = 134349056;
    uint64_t v8 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 handleReachability,%{public}ld",  &v7,  12);
    int v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyEED2::handleReachability(const CLDaemonStatus_Type::Reachability)",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  *(_DWORD *)(a1 + 1976) = a2;
  if (!*(_BYTE *)(a1 + 1980)) {
    *(_BYTE *)(a1 + 198sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
  }
}

void sub_1007634BC(uint64_t a1, void *a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2[3];
    *(_DWORD *)uint64_t buf = 134349056;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2 handleVlqmForActiveCall,%{public}ld",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v7 = a2[3];
    int v13 = 134349056;
    uint64_t v14 = v7;
    LODWORD(v12) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 handleVlqmForActiveCall,%{public}ld",  &v13,  v12);
    uint64_t v9 = (char *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyEED2::handleVlqmForActiveCall(std::unordered_map<SimInstance, int32_t> &)",  "%s\n",  v8);
  }

  if (!*(_BYTE *)(a1 + 1972)) {
    *(_BYTE *)(a1 + 1972) = 1;
  }
  HIDWORD(v12) = *(_DWORD *)(a1 + 1448);
  if (sub_100781F1C(a2, (int *)&v12 + 1))
  {
    *(void *)uint64_t buf = (char *)&v12 + 4;
    *(_DWORD *)(a1 + 196_Block_object_dispose(va, 8) = *((_DWORD *)sub_1007839D4( (uint64_t)a2,  (int *)&v12 + 1,  (uint64_t)&unk_1012CF090,  (_DWORD **)buf)
                             + 5);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      *(void *)&uint8_t buf[4] = SHIDWORD(v12);
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#EED2 handleVlqmForActiveCall, No vLqm data for simInstance:%{public}ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v13 = 134349056;
      uint64_t v14 = SHIDWORD(v12);
      LODWORD(v12) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 handleVlqmForActiveCall, No vLqm data for simInstance:%{public}ld",  &v13,  v12);
      int v11 = (char *)v10;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLEmergencyEED2::handleVlqmForActiveCall(std::unordered_map<SimInstance, int32_t> &)",  "%s\n",  v10);
    }
  }

BOOL sub_10076381C(_BYTE *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 1776);
  int v13 = 0;
  *(void *)uint64_t buf = &v13;
  BOOL v3 = *((_BYTE *)sub_1007837B4((uint64_t)(a1 + 1776), &v13, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 20)
    && a1[1816]
    && a1[1817]
    && a1[1818]
    && a1[1819] != 0;
  if (sub_1004FAACC() && v3)
  {
    int v13 = 1;
    *(void *)uint64_t buf = &v13;
    BOOL v3 = *((_BYTE *)sub_1007837B4(v2, &v13, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 20) != 0;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 0;
    *(void *)uint64_t buf = &v13;
    int v5 = *((unsigned __int8 *)sub_1007837B4(v2, &v13, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 20);
    int v12 = 1;
    *(void *)uint64_t buf = &v12;
    int v6 = *((unsigned __int8 *)sub_1007837B4(v2, &v12, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 20);
    int v7 = a1[1816];
    int v8 = a1[1817];
    int v9 = a1[1818];
    int v10 = a1[1819];
    *(_DWORD *)uint64_t buf = 68290818;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v15 = 2082;
    int v16 = "";
    __int16 v17 = 1026;
    BOOL v18 = v3;
    __int16 v19 = 1026;
    int v20 = v5;
    __int16 v21 = 1026;
    int v22 = v6;
    __int16 v23 = 1026;
    int v24 = v7;
    __int16 v25 = 1026;
    int v26 = v8;
    __int16 v27 = 1026;
    int v28 = v9;
    __int16 v29 = 1026;
    int v30 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,requiredInitializationDataReceived, initialized:%{public}hhd, fPhoneNumbersRe ceived[SimInstance::kSim1]:%{public}hhd, fPhoneNumbersReceived[SimInstance::kSim2]:%{public}hhd, fSosToggl eStateReceived:%{public}hhd, fConfigChangeReceived:%{public}hhd, fEmergencyStateChangeReceived:%{public} hhd, fDebounceTimerTimedout:%{public}hhd}",  buf,  0x3Cu);
  }

  return v3;
}

void sub_100763A5C(uint64_t a1, signed int a2, double a3)
{
  unsigned int v50 = a2;
  uint64_t v4 = *(dispatch_queue_s **)(a1 + 80);
  if (!v4)
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    __int16 v39 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      __int16 v40 = (void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "%sInvoking timers without callback queue set",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
      __int16 v44 = (void *)(a1 + 96);
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v44;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "%sInvoking timers without callback queue set",  __p);
      char v46 = (char *)v45;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLStateMachine<CLEmergencyEED2>::setTimeoutEvent(Event, double) [T = CLEmergencyEED2]",  "%s\n",  v45);
      if (v46 != buf) {
        free(v46);
      }
    }

    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    __int16 v41 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
    }

    int v42 = (os_log_s *)qword_101934888;
    if (os_signpost_enabled((os_log_t)qword_101934888))
    {
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v42,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion failed",  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
    }

    int v43 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/GPS/CLStateMachine.h",  173,  "setTimeoutEvent");
    __break(1u);
  }

  if (a3 < 0.0)
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    int v7 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
    {
      int v8 = (void *)(a1 + 96);
      sub_1007624D8(a2, __p);
      if (v58 >= 0) {
        int v9 = __p;
      }
      else {
        int v9 = *(_BYTE **)__p;
      }
      *(_DWORD *)uint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v9;
      *(_WORD *)&_BYTE buf[22] = 2050;
      *(double *)&buf[24] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f",  buf,  0x20u);
      if (SHIBYTE(v58) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
      int v10 = (void *)(a1 + 96);
      uint64_t v11 = qword_101934888;
      sub_1007624D8(a2, v51);
      if (v54 >= 0) {
        int v12 = v51;
      }
      else {
        int v12 = *(_BYTE **)v51;
      }
      *(_DWORD *)std::string __p = 136315650;
      *(void *)&__p[4] = v10;
      __int16 v56 = 2082;
      id v57 = v12;
      __int16 v58 = 2050;
      double v59 = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  17LL,  "%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f",  __p,  32);
      uint64_t v14 = v13;
      if (v54 < 0) {
        operator delete(*(void **)v51);
      }
LABEL_79:
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLStateMachine<CLEmergencyEED2>::setTimeoutEvent(Event, double) [T = CLEmergencyEED2]",  "%s\n",  v14);
LABEL_80:
      if (v14 != buf) {
        free(v14);
      }
      return;
    }

    return;
  }

  uint64_t v15 = *(void *)(a1 + 64);
  if (v15)
  {
    uint64_t v16 = a1 + 64;
    do
    {
      signed int v17 = *(_DWORD *)(v15 + 32);
      BOOL v18 = v17 < a2;
      if (v17 >= a2) {
        __int16 v19 = (uint64_t *)v15;
      }
      else {
        __int16 v19 = (uint64_t *)(v15 + 8);
      }
      if (!v18) {
        uint64_t v16 = v15;
      }
      uint64_t v15 = *v19;
    }

    while (*v19);
    if (v16 != a1 + 64 && *(_DWORD *)(v16 + 32) <= a2)
    {
      int v20 = *(dispatch_source_s **)(v16 + 40);
      if (v20)
      {
LABEL_37:
        dispatch_time_t v22 = dispatch_time(0LL, (uint64_t)(a3 * 1000000000.0));
        dispatch_source_set_timer(v20, v22, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
        if (qword_101934880 != -1) {
          dispatch_once(&qword_101934880, &stru_10184E0C0);
        }
        __int16 v23 = (os_log_s *)qword_101934888;
        os_log_type_t v24 = *(_BYTE *)(a1 + 120);
        if (os_log_type_enabled((os_log_t)qword_101934888, v24))
        {
          __int16 v25 = (void *)(a1 + 96);
          sub_1007624D8(v50, __p);
          if (v58 >= 0) {
            int v26 = __p;
          }
          else {
            int v26 = *(_BYTE **)__p;
          }
          *(_DWORD *)uint64_t buf = 136315650;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v26;
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(double *)&buf[24] = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, v24, "%sevent,%s,timeout,%.2f", buf, 0x20u);
          if (SHIBYTE(v58) < 0) {
            operator delete(*(void **)__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934880 != -1) {
            dispatch_once(&qword_101934880, &stru_10184E0C0);
          }
          __int16 v27 = (void *)(a1 + 96);
          uint64_t v28 = qword_101934888;
          uint64_t v29 = *(unsigned __int8 *)(a1 + 120);
          sub_1007624D8(v50, v51);
          if (v54 >= 0) {
            int v30 = v51;
          }
          else {
            int v30 = *(_BYTE **)v51;
          }
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = v27;
          __int16 v56 = 2080;
          id v57 = v30;
          __int16 v58 = 2048;
          double v59 = a3;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  v29,  "%sevent,%s,timeout,%.2f",  __p,  32,  v47);
          uint64_t v14 = v31;
          if (v54 < 0) {
            operator delete(*(void **)v51);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyEED2>::setTimeoutEvent(Event, double) [T = CLEmergencyEED2]",  "%s\n",  v14);
          goto LABEL_80;
        }

        return;
      }
    }
  }

  __int16 v21 = (uint64_t *)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v4);
  if (v21)
  {
    int v20 = (dispatch_source_s *)v21;
    *(void *)uint64_t buf = &v50;
    sub_10000C858((uint64_t **)(a1 + 56), (int *)&v50, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[5] = v21;
    dispatch_source_set_timer(v20, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100783BF0;
    handler[3] = &unk_10182B540;
    handler[4] = a1;
    unsigned int v49 = v50;
    dispatch_source_set_event_handler(v20, handler);
    dispatch_resume(v20);
    goto LABEL_37;
  }

  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10184E0C0);
  }
  char v32 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
  {
    __int16 v33 = (void *)(a1 + 96);
    sub_1007624D8(a2, buf);
    if (buf[23] >= 0) {
      int v34 = buf;
    }
    else {
      int v34 = *(_BYTE **)buf;
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v33;
    __int16 v56 = 2082;
    id v57 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "%scannot create timer, event, %{public}s",  __p,  0x16u);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    __int16 v35 = (void *)(a1 + 96);
    uint64_t v36 = qword_101934888;
    sub_1007624D8(a2, __p);
    if (v58 >= 0) {
      __int16 v37 = __p;
    }
    else {
      __int16 v37 = *(_BYTE **)__p;
    }
    *(_DWORD *)float v51 = 136315394;
    *(void *)&v51[4] = v35;
    __int16 v52 = 2082;
    float v53 = v37;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  17LL,  "%scannot create timer, event, %{public}s",  v51,  22);
    uint64_t v14 = v38;
    if (SHIBYTE(v58) < 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_79;
  }

void sub_10076452C(uint64_t a1, signed int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4) {
    goto LABEL_33;
  }
  uint64_t v5 = a1 + 64;
  do
  {
    signed int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      int v8 = (uint64_t *)v4;
    }
    else {
      int v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 != a1 + 64 && *(_DWORD *)(v5 + 32) <= a2 && (int v9 = *(dispatch_source_s **)(v5 + 40)) != 0LL)
  {
    dispatch_source_set_timer(v9, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    int v10 = (os_log_s *)qword_101934888;
    os_log_type_t v11 = *(_BYTE *)(a1 + 120);
    if (os_log_type_enabled((os_log_t)qword_101934888, v11))
    {
      int v12 = (void *)(a1 + 96);
      sub_1007624D8(a2, __p);
      if (v36 >= 0) {
        int v13 = __p;
      }
      else {
        int v13 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v28 = 2080;
      uint64_t v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, v11, "%scancel timer,event,%s", buf, 0x16u);
      if (v36 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
      uint64_t v14 = (void *)(a1 + 96);
      uint64_t v15 = qword_101934888;
      uint64_t v16 = *(unsigned __int8 *)(a1 + 120);
      sub_1007624D8(a2, buf);
      if (v30 >= 0) {
        signed int v17 = buf;
      }
      else {
        signed int v17 = *(_BYTE **)buf;
      }
      int v31 = 136315394;
      char v32 = v14;
      __int16 v33 = 2080;
      int v34 = v17;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  v16,  "%scancel timer,event,%s",  (const char *)&v31,  22);
      __int16 v19 = v18;
      if (v30 < 0) {
        operator delete(*(void **)buf);
      }
LABEL_54:
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyEED2>::cancelTimeoutEvent(Event) [T = CLEmergencyEED2]",  "%s\n",  v19);
    }
  }

  else
  {
LABEL_33:
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10184E0C0);
    }
    int v20 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v21 = (void *)(a1 + 96);
      sub_1007624D8(a2, __p);
      if (v36 >= 0) {
        dispatch_time_t v22 = __p;
      }
      else {
        dispatch_time_t v22 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      __int16 v28 = 2080;
      uint64_t v29 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#Warning,%s,cancel timer,notFound, event,%s",  buf,  0x16u);
      if (v36 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10184E0C0);
      }
      __int16 v23 = (void *)(a1 + 96);
      uint64_t v24 = qword_101934888;
      sub_1007624D8(a2, buf);
      if (v30 >= 0) {
        __int16 v25 = buf;
      }
      else {
        __int16 v25 = *(_BYTE **)buf;
      }
      int v31 = 136315394;
      char v32 = v23;
      __int16 v33 = 2080;
      int v34 = v25;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning,%s,cancel timer,notFound, event,%s",  (const char *)&v31,  22);
      __int16 v19 = v26;
      if (v30 < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_54;
    }
  }

CLEEDHelperService *sub_1007649BC(uint64_t a1)
{
  _DWORD v8[4] = a1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  _DWORD v9[2] = sub_10077D278;
  void v9[3] = &unk_10184DEB8;
  v9[4] = a1;
  unsigned __int8 v7[4] = a1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_10077D594;
  unsigned __int8 v8[3] = &unk_10184DED8;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_10077D75C;
  void v7[3] = &unk_10184DEF8;
  _OWORD v5[4] = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_10077D924;
  void v6[3] = &unk_10184DF18;
  v6[4] = a1;
  v4[4] = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10077DC94;
  v5[3] = &unk_10184DF38;
  unsigned __int8 v3[4] = a1;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_10077ED3C;
  v4[3] = &unk_10184DF58;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10077FBEC;
  unsigned __int8 v3[3] = &unk_10184DF78;
  uint64_t result = -[CLEEDHelperService initWithUniverse:pendingRequestsCB:streamingRequestCB:uploadRequestCB:streamingEndCB:uploadListCB:handleResponseCB:mitigationsCB:]( objc_alloc(&OBJC_CLASS___CLEEDHelperService),  "initWithUniverse:pendingRequestsCB:streamingRequestCB:uploadRequestCB:streamingEndCB:uploadListCB:handleRes ponseCB:mitigationsCB:",  *(void *)(a1 + 8),  v9,  v8,  v7,  v6,  v5,  v4,  v3);
  *(void *)(a1 + 184_Block_object_dispose(va, 8) = result;
  return result;
}

uint64_t sub_100764AF4(uint64_t a1)
{
  if (!sub_100756190(a1 + 1448)) {
    return 1LL;
  }
  if (!sub_100983098(a1 + 112) && (sub_1009830D8(a1 + 112) || *(_BYTE *)(a1 + 160) && sub_1009830C8(a1 + 112)))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,expectedState,State::ActiveSession",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v14[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,expectedState,State::ActiveSession",  v14,  2);
      os_log_type_t v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyEED2::State CLEmergencyEED2::expectedState()", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    return 3LL;
  }

  if (!sub_100983098(a1 + 112) && sub_1009830E8(a1 + 112) && !sub_1009830D8(a1 + 112))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    BOOL v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#EED2,expectedState,State::ExtendedSession due to fEmergencyState in EEM",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 4LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v14[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,expectedState,State::ExtendedSession due to fEmergencyState in EEM",  v14,  2,  v14[0]);
    goto LABEL_40;
  }

  if (*(_BYTE *)(a1 + 184))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,expectedState,State::ExtendedSession due to fAssertingSession",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 4LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v14[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,expectedState,State::ExtendedSession due to fAssertingSession",  v14,  2,  v14[0]);
LABEL_40:
    int v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyEED2::State CLEmergencyEED2::expectedState()", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
    return 4LL;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#EED2,expectedState, State::Idle", buf, 2u);
  }

  uint64_t v3 = 2LL;
  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v14[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,expectedState, State::Idle",  v14,  2);
    int v13 = (uint8_t *)v12;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyEED2::State CLEmergencyEED2::expectedState()", "%s\n", v12);
    if (v13 != buf) {
      free(v13);
    }
    return 2LL;
  }

  return v3;
}

BOOL sub_100765030(uint64_t a1)
{
  if (!*(void *)(a1 + 2040))
  {
    uint64_t v2 = (char *)operator new(0x78uLL);
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((void *)v2 + 14) = 0LL;
    *((_DWORD *)v2 + 6) = 10;
    __asm { FMOV            V1.2S, #-1.0 }

    *(void *)(v2 + 2_Block_object_dispose(va, 8) = _D1;
    *(void *)(v2 + 44) = 0LL;
    *(void *)(v2 + 52) = 0LL;
    *(void *)(v2 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    *(_OWORD *)(v2 + 72) = 0u;
    *(_OWORD *)(v2 + 8_Block_object_dispose(va, 8) = 0u;
    *((void *)v2 + 13) = -1LL;
    *(void *)(a1 + 204sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v2;
  }

  uint64_t v8 = sub_1002F8DDC();
  if ((sub_1002A6F20(v8, (uint64_t)@"EEDCacheData", (CFTypeRef *)&v134) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v15 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,EED data not cached. Early Return",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v137) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,EED data not cached. Early Return",  &v137,  2);
      uint64_t v14 = (uint8_t *)v16;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v16);
      goto LABEL_209;
    }

    return result;
  }

  double v9 = sub_100767E24(*(void *)(a1 + 2040));
  *(_BYTE *)(*(void *)(a1 + 2040) + 41LL) = 1;
  double v124 = v134;
  if (byte_10199847F >= 0) {
    int v10 = &qword_101998468;
  }
  else {
    int v10 = (uint64_t *)qword_101998468;
  }
  if (objc_msgSend( objc_msgSend( v134,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10, v9)),  "intValue") == 4 && sub_100764AF4(a1) == 3)
  {
    sub_1007675C4();
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    os_log_type_t v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,ignore cached data and clear it as new session has started in the interim. Early Return",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v137) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,ignore cached data and clear it as new session has started in the interim. Early Return",  &v137,  2);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v13);
LABEL_209:
      if (v14 != buf) {
        free(v14);
      }
      return 0LL;
    }

    return result;
  }

  if (byte_10199844F >= 0) {
    signed int v17 = &qword_101998438;
  }
  else {
    signed int v17 = (uint64_t *)qword_101998438;
  }
  objc_msgSend( objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17)),  "doubleValue");
  *(double *)(a1 + 16_Block_object_dispose(va, 8) = v18;
  if (v18 <= 0.0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int16 v28 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fSessionStartTime unavailable, Early Return",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v137) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,fSessionStartTime unavailable, Early Return",  &v137,  2);
      uint64_t v14 = (uint8_t *)v29;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v29);
      goto LABEL_209;
    }

    return result;
  }

  if (byte_101998467 >= 0) {
    __int16 v19 = &qword_101998450;
  }
  else {
    __int16 v19 = (uint64_t *)qword_101998450;
  }
  objc_msgSend( objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19)),  "doubleValue");
  *(void *)(a1 + 1872) = v20;
  __int16 v21 = *(void **)(a1 + 1920);
  if (v21) {

  }
  if (byte_101998497 >= 0) {
    dispatch_time_t v22 = &qword_101998480;
  }
  else {
    dispatch_time_t v22 = (uint64_t *)qword_101998480;
  }
  id v23 =  objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22));
  *(void *)(a1 + 192sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v23;
  if (!v23)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    char v30 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fRootSecret unavailable, Early Return",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v137) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,fRootSecret unavailable, Early Return",  &v137,  2);
      uint64_t v14 = (uint8_t *)v31;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v31);
      goto LABEL_209;
    }

    return result;
  }

  uint64_t v24 = *(const void **)(a1 + 1928);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 192_Block_object_dispose(va, 8) = 0LL;
  }

  if (byte_1019984AF >= 0) {
    __int16 v25 = &qword_101998498;
  }
  else {
    __int16 v25 = (uint64_t *)qword_101998498;
  }
  id v26 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v25));
  if (v26)
  {
    id v27 = +[CLEEDCryptoUtilities createKeyFromExternalRepresentationString:keyClass:]( &OBJC_CLASS___CLEEDCryptoUtilities,  "createKeyFromExternalRepresentationString:keyClass:",  v26,  kSecAttrKeyClassPrivate);
    *(void *)(a1 + 192_Block_object_dispose(va, 8) = v27;
  }

  else
  {
    id v27 = *(id *)(a1 + 1928);
  }

  if (v27)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    char v32 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v33 = *(void **)(a1 + 168);
      int v34 = *(void **)(a1 + 1872);
      uint64_t v35 = *(void *)(a1 + 1920);
      uint64_t v36 = *(void *)(a1 + 1928);
      *(_DWORD *)uint64_t buf = 134349827;
      id v146 = v33;
      __int16 v147 = 2050;
      id v148 = v34;
      __int16 v149 = 2113;
      uint64_t v150 = v35;
      __int16 v151 = 2113;
      uint64_t v152 = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched fSessionStartTime:%{public}f, fCallEndTime:%{public}f, fRootSecret:%{private} @, fDeviceSessionPrivateKey:%{private}@",  buf,  0x2Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v95 = *(void **)(a1 + 168);
      double v96 = *(void **)(a1 + 1872);
      uint64_t v97 = *(void *)(a1 + 1920);
      uint64_t v98 = *(void *)(a1 + 1928);
      int v137 = 134349827;
      id v138 = v95;
      __int16 v139 = 2050;
      id v140 = v96;
      __int16 v141 = 2113;
      uint64_t v142 = v97;
      __int16 v143 = 2113;
      uint64_t v144 = v98;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,fetched fSessionStartTime:%{public}f, fCallEndTime:%{public}f, fRootSecret:%{private} @, fDeviceSessionPrivateKey:%{private}@",  &v137,  42);
      unsigned int v100 = (uint8_t *)v99;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v99);
      if (v100 != buf) {
        free(v100);
      }
    }

    __int16 v37 = *(void **)(a1 + 1904);
    if (v37)
    {

      *(void *)(a1 + 1904) = 0LL;
    }

    if (byte_1019984C7 >= 0) {
      uint64_t v38 = &qword_1019984B0;
    }
    else {
      uint64_t v38 = (uint64_t *)qword_1019984B0;
    }
    id v39 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v38));
    if (v39)
    {
      *(void *)(a1 + 1904) = +[CLEEDRequest createRequestFromCachedDict:error:]( &OBJC_CLASS___CLEEDRequest,  "createRequestFromCachedDict:error:",  v39,  &v133);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v40 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        id v41 = [*(id *)(a1 + 1904) ID];
        int v42 = *(void **)(a1 + 1904);
        *(_DWORD *)uint64_t buf = 138543875;
        id v146 = v41;
        __int16 v147 = 2113;
        id v148 = v42;
        __int16 v149 = 2050;
        uint64_t v150 = v133;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, fCurrentStreamingRequest from cache:%{private}@, error:%{public}ld",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v109 = qword_101934898;
        id v110 = [*(id *)(a1 + 1904) ID];
        __int16 v111 = *(void **)(a1 + 1904);
        int v137 = 138543875;
        id v138 = v110;
        __int16 v139 = 2113;
        id v140 = v111;
        __int16 v141 = 2050;
        uint64_t v142 = v133;
        LODWORD(v123) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v109,  0LL,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, fCurrentStreamingRequest from cache:%{private}@, error:%{public}ld",  &v137,  v123);
        __int16 v113 = (uint8_t *)v112;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v112);
        if (v113 != buf) {
          free(v113);
        }
      }
    }

    int v43 = *(void **)(a1 + 1912);
    if (v43)
    {

      *(void *)(a1 + 1912) = 0LL;
    }

    if (byte_1019984DF >= 0) {
      __int16 v44 = &qword_1019984C8;
    }
    else {
      __int16 v44 = (uint64_t *)qword_1019984C8;
    }
    id v45 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v44));
    if (v45)
    {
      *(void *)(a1 + 1912) = +[CLEEDRequest createRequestFromCachedDict:error:]( &OBJC_CLASS___CLEEDRequest,  "createRequestFromCachedDict:error:",  v45,  &v133);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      char v46 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        id v47 = [*(id *)(a1 + 1912) ID];
        int v48 = *(void **)(a1 + 1912);
        *(_DWORD *)uint64_t buf = 138543875;
        id v146 = v47;
        __int16 v147 = 2113;
        id v148 = v48;
        __int16 v149 = 2050;
        uint64_t v150 = v133;
        _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, fCurrentUploadRequest from cache:%{private}@, error:%{public}ld",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v114 = qword_101934898;
        id v115 = [*(id *)(a1 + 1912) ID];
        double v116 = *(void **)(a1 + 1912);
        int v137 = 138543875;
        id v138 = v115;
        __int16 v139 = 2113;
        id v140 = v116;
        __int16 v141 = 2050;
        uint64_t v142 = v133;
        LODWORD(v123) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v114,  0LL,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, fCurrentUploadRequest from cache:%{private}@, error:%{public}ld",  &v137,  v123);
        double v118 = (uint8_t *)v117;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v117);
        if (v118 != buf) {
          free(v118);
        }
      }
    }

    unsigned int v49 = *(void **)(a1 + 1888);
    if (v49) {

    }
    *(void *)(a1 + 188_Block_object_dispose(va, 8) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (byte_10199850F >= 0) {
      unsigned int v50 = &qword_1019984F8;
    }
    else {
      unsigned int v50 = (uint64_t *)qword_1019984F8;
    }
    id v51 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v50));
    __int128 v131 = 0u;
    __int128 v132 = 0u;
    __int128 v129 = 0u;
    __int128 v130 = 0u;
    id v52 = [v51 countByEnumeratingWithState:&v129 objects:v136 count:16];
    if (v52)
    {
      uint64_t v53 = *(void *)v130;
      do
      {
        char v54 = 0LL;
        do
        {
          if (*(void *)v130 != v53) {
            objc_enumerationMutation(v51);
          }
          id v55 =  +[CLEEDRequest createRequestFromCachedDict:error:]( &OBJC_CLASS___CLEEDRequest,  "createRequestFromCachedDict:error:",  *(void *)(*((void *)&v129 + 1) + 8LL * (void)v54),  &v133);
          if (v55)
          {
            [*(id *)(a1 + 1888) addObject:v55];
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            __int16 v56 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              id v57 = [v55 ID];
              id v58 = [v55 type];
              *(_DWORD *)uint64_t buf = 138543618;
              id v146 = v57;
              __int16 v147 = 2050;
              id v148 = v58;
              _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, pending request with requestType:%{public}ld, from cache",  buf,  0x16u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              uint64_t v59 = qword_101934898;
              id v60 = [v55 ID];
              id v61 = [v55 type];
              int v137 = 138543618;
              id v138 = v60;
              __int16 v139 = 2050;
              id v140 = v61;
              LODWORD(v123) = 22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v59,  0LL,  "#EED2,readEEDDataFromCache,fetched requestID:%{public}@, pending request with requestType:%{public}ld, from cache",  &v137,  v123);
              uint64_t v63 = (uint8_t *)v62;
              sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v62);
LABEL_119:
              if (v63 != buf) {
                free(v63);
              }
            }
          }

          else
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            uint64_t v64 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_ERROR,  "#EED2,readEEDDataFromCache,requestsPendingArray, prendingRequest creation failed. This should not happen",  buf,  2u);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              LOWORD(v137) = 0;
              LODWORD(v123) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,readEEDDataFromCache,requestsPendingArray, prendingRequest creation failed. This should not happen",  &v137,  v123);
              uint64_t v63 = (uint8_t *)v65;
              sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v65);
              goto LABEL_119;
            }
          }

          char v54 = (char *)v54 + 1;
        }

        while (v52 != v54);
        id v66 = [v51 countByEnumeratingWithState:&v129 objects:v136 count:16];
        id v52 = v66;
      }

      while (v66);
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v67 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v68 = [*(id *)(a1 + 1888) count];
      *(_DWORD *)uint64_t buf = 134349056;
      id v146 = v68;
      _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched %{public}lu pending requests from cache",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v101 = qword_101934898;
      id v102 = [*(id *)(a1 + 1888) count];
      int v137 = 134349056;
      id v138 = v102;
      LODWORD(v123) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v101,  0LL,  "#EED2,readEEDDataFromCache,fetched %{public}lu pending requests from cache",  &v137,  v123);
      __int16 v104 = (uint8_t *)v103;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v103);
      if (v104 != buf) {
        free(v104);
      }
    }

    uint64_t v69 = *(void **)(a1 + 1896);
    if (v69) {

    }
    *(void *)(a1 + 1896) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (byte_101998527 >= 0) {
      char v70 = &qword_101998510;
    }
    else {
      char v70 = (uint64_t *)qword_101998510;
    }
    id v71 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v70));
    __int128 v127 = 0u;
    __int128 v128 = 0u;
    __int128 v125 = 0u;
    __int128 v126 = 0u;
    id v72 = [v71 countByEnumeratingWithState:&v125 objects:v135 count:16];
    if (!v72)
    {
LABEL_159:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v87 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        id v88 = [*(id *)(a1 + 1896) count];
        *(_DWORD *)uint64_t buf = 134349056;
        id v146 = v88;
        _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched %{public}lu handled requests from cache",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v105 = qword_101934898;
        id v106 = [*(id *)(a1 + 1896) count];
        int v137 = 134349056;
        id v138 = v106;
        LODWORD(v123) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v105,  0LL,  "#EED2,readEEDDataFromCache,fetched %{public}lu handled requests from cache",  &v137,  v123);
        double v108 = (uint8_t *)v107;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v107);
        if (v108 != buf) {
          free(v108);
        }
      }

      int v89 = *(void **)(a1 + 1960);
      if (v89)
      {

        *(void *)(a1 + 196sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
      }

      if (byte_1019984F7 >= 0) {
        uint64_t v90 = &qword_1019984E0;
      }
      else {
        uint64_t v90 = (uint64_t *)qword_1019984E0;
      }
      id v91 = objc_msgSend( v124,  "valueForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v90));
      if (v91)
      {
        *(void *)(a1 + 196sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = +[CLEEDMitigation newMitigationFromDict:]( &OBJC_CLASS___CLEEDMitigation,  "newMitigationFromDict:",  v91);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v92 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          int v93 = *(void **)(a1 + 1960);
          *(_DWORD *)uint64_t buf = 138543362;
          id v146 = v93;
          _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fetched Mitigation:%{public}@",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v119 = *(void **)(a1 + 1960);
          int v137 = 138543362;
          id v138 = v119;
          LODWORD(v123) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,fetched Mitigation:%{public}@",  &v137,  v123);
          uint64_t v121 = (uint8_t *)v120;
          sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v120);
          if (v121 != buf) {
            free(v121);
          }
        }
      }

      sub_100781234(a1);
      return 1LL;
    }

    uint64_t v73 = *(void *)v126;
LABEL_134:
    uint64_t v74 = 0LL;
    while (1)
    {
      if (*(void *)v126 != v73) {
        objc_enumerationMutation(v71);
      }
      id v75 =  +[CLEEDRequest createRequestFromCachedDict:error:]( &OBJC_CLASS___CLEEDRequest,  "createRequestFromCachedDict:error:",  *(void *)(*((void *)&v125 + 1) + 8 * v74),  &v133);
      if (v75)
      {
        [*(id *)(a1 + 1896) addObject:v75];
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v76 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          id v77 = [v75 ID];
          id v78 = [v75 type];
          *(_DWORD *)uint64_t buf = 138543618;
          id v146 = v77;
          __int16 v147 = 2050;
          id v148 = v78;
          _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_DEFAULT,  "#EED2,readDataFromCache,fetched requestID:%{public}@, handled request with requestType:%{public}ld, from cache",  buf,  0x16u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_151;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v79 = qword_101934898;
        id v80 = [v75 ID];
        id v81 = [v75 type];
        int v137 = 138543618;
        id v138 = v80;
        __int16 v139 = 2050;
        id v140 = v81;
        LODWORD(v123) = 22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v79,  0LL,  "#EED2,readDataFromCache,fetched requestID:%{public}@, handled request with requestType:%{public}ld, from cache",  &v137,  v123);
        double v83 = (uint8_t *)v82;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v82);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        __int16 v84 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_ERROR,  "#EED2,readEEDDataFromCache,requestsHandledArray, handledRequest creation failed. This should not happen",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          goto LABEL_151;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v137) = 0;
        LODWORD(v123) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,readEEDDataFromCache,requestsHandledArray, handledRequest creation failed. This should not happen",  &v137,  v123);
        double v83 = (uint8_t *)v85;
        sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v85);
      }

      if (v83 != buf) {
        free(v83);
      }
LABEL_151:
      if (v72 == (id)++v74)
      {
        id v86 = [v71 countByEnumeratingWithState:&v125 objects:v135 count:16];
        id v72 = v86;
        if (!v86) {
          goto LABEL_159;
        }
        goto LABEL_134;
      }
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  double v94 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEFAULT,  "#EED2,readEEDDataFromCache,fDeviceSessionPrivateKey unavailable, Early Return",  buf,  2u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v137) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,readEEDDataFromCache,fDeviceSessionPrivateKey unavailable, Early Return",  &v137,  2);
    uint64_t v14 = (uint8_t *)v122;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::readEEDDataFromCache()", "%s\n", v122);
    goto LABEL_209;
  }

  return result;
}

void sub_100766A44(uint64_t a1)
{
  if (*(int *)(a1 + 1952) < 5)
  {
    if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  @"/private/var/mobile/Library/CLEEDMediaService/CLEEDMSCache"))
    {
      ++*(_DWORD *)(a1 + 1952);
      sub_100780010(a1);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,checkAndRestoreEEDMediaService, initialized media service",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v11[0]) = 0;
        double v9 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,checkAndRestoreEEDMediaService, initialized media service",  v11,  2);
        BOOL v7 = v10;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::checkAndRestoreEEDMediaService()", "%s\n", v9);
        goto LABEL_20;
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v3 = *(_DWORD *)(a1 + 1952);
      *(_DWORD *)uint64_t buf = 67240192;
      int v13 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "#EED2,checkAndRestoreEEDMediaService,LaunchCount exceeded limit:%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v4 = *(_DWORD *)(a1 + 1952);
      v11[0] = 67240192;
      v11[1] = v4;
      double v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,checkAndRestoreEEDMediaService,LaunchCount exceeded limit:%{public}d",  v11,  8);
      BOOL v7 = v6;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::checkAndRestoreEEDMediaService()", "%s\n", v5);
LABEL_20:
      if (v7 != buf) {
        free(v7);
      }
    }
  }

void sub_100766D4C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 1984);
  if (v2)
  {
    unsigned int v3 = objc_msgSend(objc_msgSend(v2, "valueForKey:", @"thermalLevelAtStartOfCall"), "intValue");
    unsigned int v4 = objc_msgSend( objc_msgSend(*(id *)(a1 + 1984), "valueForKey:", @"maxThermalLevelInCall"),  "intValue");
    unsigned int v5 = objc_msgSend( objc_msgSend(*(id *)(a1 + 1984), "valueForKey:", @"thermalLevelAtEndOfCall"),  "intValue");
    unsigned int v6 = objc_msgSend( objc_msgSend(*(id *)(a1 + 1984), "valueForKey:", @"peakPowerAtStartOfCall"),  "intValue");
    unsigned int v7 = objc_msgSend( objc_msgSend(*(id *)(a1 + 1984), "valueForKey:", @"maxPeakPowerInCall"),  "intValue");
    unsigned int v8 = objc_msgSend( objc_msgSend(*(id *)(a1 + 1984), "valueForKey:", @"peakPowerAtEndOfCall"),  "intValue");
  }

  else
  {
    unsigned int v8 = -1;
    unsigned int v7 = -1;
    unsigned int v6 = -1;
    unsigned int v5 = -1;
    unsigned int v4 = -1;
    unsigned int v3 = -1;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  double v9 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 67110400;
    *(_DWORD *)&uint8_t buf[4] = v3;
    *(_WORD *)id v52 = 1024;
    *(_DWORD *)&v52[2] = v4;
    __int16 v53 = 1024;
    unsigned int v54 = v5;
    __int16 v55 = 1024;
    unsigned int v56 = v6;
    __int16 v57 = 1024;
    unsigned int v58 = v7;
    LOWORD(v59[0]) = 1024;
    *(_DWORD *)((char *)v59 + 2) = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2,submitEED2SessionDatatoCA,thermalLevelAtStartOfCall:%d, maxThermalLevelInCall:%d, thermalLevelAtEndOfCall:%d , peakPowerAtStartOfCall:%d, maxPeakPowerInCall:%d, peakPowerAtEndOfCall:%d",  buf,  0x26u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LODWORD(v44) = 67110400;
    HIDWORD(v44) = v3;
    LOWORD(v45) = 1024;
    *(_DWORD *)((char *)&v45 + 2) = v4;
    HIWORD(v45) = 1024;
    *(_DWORD *)char v46 = v5;
    *(_WORD *)&unsigned __int8 v46[4] = 1024;
    *(_DWORD *)&v46[6] = v6;
    __int16 v47 = 1024;
    unsigned int v48 = v7;
    __int16 v49 = 1024;
    unsigned int v50 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,submitEED2SessionDatatoCA,thermalLevelAtStartOfCall:%d, maxThermalLevelInCall:%d, thermalLevelAtEndOfCall:%d , peakPowerAtStartOfCall:%d, maxPeakPowerInCall:%d, peakPowerAtEndOfCall:%d",  &v44,  38,  LODWORD(__p[0]),  LODWORD(__p[1]),  v40,  LODWORD(v41[0]));
    uint64_t v35 = (uint8_t *)v34;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::submitEED2SessionDatatoCA()", "%s\n", v34);
    if (v35 != buf) {
      free(v35);
    }
  }

  int v10 = *(int **)(a1 + 2040);
  if (v10)
  {
    int v11 = v10[2];
    *(_DWORD *)uint64_t buf = 108;
    *(_DWORD *)id v52 = v11;
    v59[0] = 0;
    int v12 = *v10;
    v59[2] = 110;
    v59[4] = v12;
    v59[10] = 0;
    int v13 = v10[1];
    v59[12] = 111;
    v59[14] = v13;
    v59[20] = 0;
    int v14 = v10[3];
    v59[22] = 109;
    v59[24] = v14;
    v59[30] = 0;
    int v15 = v10[4];
    v59[32] = 113;
    v59[34] = v15;
    v59[40] = 0;
    int v16 = v10[5];
    v59[42] = 114;
    v59[44] = v16;
    v59[50] = 0;
    int v17 = v10[6];
    v59[52] = 107;
    v59[54] = v17;
    v59[60] = 0;
    int v18 = v10[9];
    v59[62] = 112;
    v59[64] = v18;
    v59[70] = 0;
    LOBYTE(v1_Block_object_dispose(va, 8) = *((_BYTE *)v10 + 40);
    v59[72] = 190;
    char v60 = v18;
    int v61 = 7;
    int v19 = v10[11];
    int v62 = 191;
    int v63 = v19;
    int v64 = 0;
    int v20 = v10[12];
    int v65 = 192;
    int v66 = v20;
    int v67 = 0;
    int v21 = v10[13];
    int v68 = 193;
    int v69 = v21;
    int v70 = 0;
    int v22 = v10[14];
    int v71 = 194;
    int v72 = v22;
    int v73 = 0;
    int v23 = v10[15];
    int v74 = 195;
    int v75 = v23;
    int v76 = 0;
    int v24 = v10[16];
    int v77 = 196;
    int v78 = v24;
    int v79 = 0;
    LOBYTE(vsub_10000AE14(v9 + 24) = *((_BYTE *)v10 + 41);
    int v80 = 197;
    char v81 = v24;
    int v82 = 7;
    uint64_t v25 = *((void *)v10 + 9);
    int v83 = 198;
    int v84 = v25;
    int v85 = 0;
    LODWORD(v25) = v10[20];
    int v86 = 199;
    int v87 = v25;
    int v88 = 0;
    LODWORD(v25) = v10[21];
    int v89 = 200;
    int v90 = v25;
    int v91 = 0;
    LODWORD(v25) = v10[22];
    int v92 = 201;
    int v93 = v25;
    int v94 = 0;
    LODWORD(v25) = v10[23];
    int v95 = 202;
    int v96 = v25;
    int v97 = 0;
    LODWORD(v25) = v10[24];
    int v98 = 203;
    int v99 = v25;
    int v100 = 0;
    LODWORD(v25) = v10[25];
    int v101 = 204;
    int v102 = v25;
    int v103 = 0;
    int v26 = v10[27] - v10[26];
    if (v26 < 0) {
      int v26 = v10[26] - v10[27];
    }
    int v104 = 205;
    int v105 = v26;
    int v106 = 0;
    char v27 = *((_BYTE *)v10 + 112);
    int v107 = 206;
    char v108 = v27;
    int v109 = 7;
    int v28 = v10[26];
    int v110 = 207;
    int v111 = v28;
    int v112 = 0;
    int v29 = v10[27];
    int v113 = 208;
    int v114 = v29;
    int v115 = 0;
    int v116 = 220;
    unsigned int v117 = v3;
    int v118 = 0;
    int v119 = 221;
    unsigned int v120 = v4;
    int v121 = 0;
    int v122 = 222;
    unsigned int v123 = v5;
    int v124 = 0;
    int v125 = 223;
    unsigned int v126 = v6;
    int v127 = 0;
    int v128 = 224;
    unsigned int v129 = v7;
    int v130 = 0;
    int v131 = 225;
    unsigned int v132 = v8;
    int v133 = 0;
    __int16 v44 = 0LL;
    id v45 = 0LL;
    *(void *)char v46 = 0LL;
    int v42 = (void **)&v44;
    char v43 = 0;
    __int16 v44 = (char *)operator new(0x528uLL);
    id v45 = v44;
    *(void *)char v46 = v44 + 1320;
    id v45 = (_BYTE *)sub_100783D5C((uint64_t)v46, (uint64_t)buf, (uint64_t)&v134, (uint64_t)v44);
    for (uint64_t i = 1288LL; i != -32; i -= 40LL)
      sub_10043AFF4((uint64_t)&buf[i]);
    int v31 = *(void **)(a1 + 2048);
    memset(v41, 0, sizeof(v41));
    sub_10043BC44(v41, (uint64_t)v44, (uint64_t)v45, 0xCCCCCCCCCCCCCCCDLL * ((v45 - v44) >> 3));
    [v31 setMeasurements:sub_100435878(v41)];
    *(void *)uint64_t buf = v41;
    sub_10043B844((void ***)buf);
    char v32 = *(void **)(a1 + 2048);
    if (byte_1019A16CF < 0)
    {
      sub_1010DD48C(__p, (void *)xmmword_1019A16B8, *((unint64_t *)&xmmword_1019A16B8 + 1));
    }

    else
    {
      *(_OWORD *)std::string __p = xmmword_1019A16B8;
      uint64_t v40 = unk_1019A16C8;
    }

    [v32 submitEvent:sub_1007793B4((__int128 *)__p)];
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[0]);
    }
    sub_100767E24(*(void *)(a1 + 2040));
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int16 v33 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "#EED2,submitEED2SessionDatatoCA,metric submitted",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v42) = 0;
      LODWORD(v3_Block_object_dispose(va, 8) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,submitEED2SessionDatatoCA,metric submitted",  &v42,  v38);
      __int16 v37 = (uint8_t *)v36;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::submitEED2SessionDatatoCA()", "%s\n", v36);
      if (v37 != buf) {
        free(v37);
      }
    }

    *(void *)uint64_t buf = &v44;
    sub_10043B844((void ***)buf);
  }

void sub_1007674EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char *a28)
{
  a28 = &a22;
  sub_10043B844((void ***)&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100767578(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v5 = sub_100778A88(a1, *a2);
  unsigned int v6 = v5;
  uint64_t result = sub_100778A88(v5, a3);
  unsigned int v8 = *a2;
  *a2 = v8;
  return result;
}

void sub_1007675C4()
{
  uint64_t v0 = sub_1002F8DDC();
  if (sub_1002A6E6C(v0))
  {
    uint64_t v1 = sub_1002F8DDC();
    sub_1002A66DC(v1);
    uint64_t v2 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v2 + 944LL))(v2);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unsigned int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EED2,clearEEDDataFromCache,complete",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v6[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,clearEEDDataFromCache,complete",  v6,  2);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::clearEEDDataFromCache()", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

void sub_100767780()
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v0 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#EED2,clearEEDMetricDataFromCache,entered",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v10[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,clearEEDMetricDataFromCache,entered",  v10,  2);
    unsigned int v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::clearEEDMetricDataFromCache()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v1 = sub_1002F8DDC();
  if (sub_1002A6E6C(v1))
  {
    uint64_t v2 = sub_1002F8DDC();
    sub_1002A66DC(v2);
    uint64_t v3 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v3 + 944LL))(v3);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unsigned int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,clearEEDMetricDataFromCache,complete",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v10[0] = 0;
      LODWORD(v9) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,clearEEDMetricDataFromCache,complete",  v10,  v9);
      unsigned int v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::clearEEDMetricDataFromCache()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

void sub_100767A6C()
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v0 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#EED2,clearCoexMetricDataFromCache,entered",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v10[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,clearCoexMetricDataFromCache,entered",  v10,  2);
    unsigned int v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::clearCoexMetricDataFromCache()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v1 = sub_1002F8DDC();
  if (sub_1002A6E6C(v1))
  {
    uint64_t v2 = sub_1002F8DDC();
    sub_1002A66DC(v2);
    uint64_t v3 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v3 + 944LL))(v3);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unsigned int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,clearCoexMetricDataFromCache,complete",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v10[0] = 0;
      LODWORD(v9) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,clearCoexMetricDataFromCache,complete",  v10,  v9);
      unsigned int v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::clearCoexMetricDataFromCache()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

void sub_100767D58(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 16_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
  *(void *)(a1 + 1872) = 0LL;
  uint64_t v2 = *(void **)(a1 + 1920);
  if (v2) {

  }
  *(void *)(a1 + 192sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) =  +[CLEEDCryptoUtilities getRandomBytes:]( &OBJC_CLASS___CLEEDCryptoUtilities,  "getRandomBytes:",  32LL);
  uint64_t v3 = *(const void **)(a1 + 1928);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 192_Block_object_dispose(va, 8) = +[CLEEDCryptoUtilities createRandomP256PrivateKey]( &OBJC_CLASS___CLEEDCryptoUtilities,  "createRandomP256PrivateKey");
  unsigned int v4 = *(void **)(a1 + 1888);
  if (v4) {

  }
  *(void *)(a1 + 188_Block_object_dispose(va, 8) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v5 = *(void **)(a1 + 1896);
  if (v5) {

  }
  *(void *)(a1 + 1896) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  unsigned int v6 = *(void **)(a1 + 1904);
  if (v6)
  {

    *(void *)(a1 + 1904) = 0LL;
  }

  unsigned int v7 = *(void **)(a1 + 1912);
  if (v7)
  {

    *(void *)(a1 + 1912) = 0LL;
  }

  unsigned int v8 = *(void **)(a1 + 1960);
  if (v8)
  {

    *(void *)(a1 + 196sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  sub_10076BCF8(a1);
}

double sub_100767E24(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#ca AnalyticsReport::reset}",  buf,  0x12u);
  }

  memset(buf, 0, 32);
  __asm { FMOV            V0.2S, #-1.0 }

  *(void *)(a1 + 2_Block_object_dispose(va, 8) = _D0;
  *(_OWORD *)(a1 + 44) = 0uLL;
  __int128 v8 = *(_OWORD *)buf;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = *(_OWORD *)&buf[16];
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + sub_100708348(v2 - 16) = 0LL;
  *(void *)a1 = 0LL;
  *(_DWORD *)(a1 + sub_10000AE14(v9 + 24) = 10;
  *(void *)(a1 + 36) = 0LL;
  *(void *)(a1 + 6sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  *(_DWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 72) = v8;
  double result = NAN;
  *(void *)(a1 + 104) = -1LL;
  *(_BYTE *)(a1 + sub_10000AE14(v2 - 112) = 0;
  return result;
}

void sub_100767F50(uint64_t a1)
{
  if (!*((_BYTE *)sub_100756E48((int *)(a1 + 1448)) + 59))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v1 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#EED2,requestAPNSToken,feature not enabled or requests not supported,early return",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v4[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,requestAPNSToken,feature not enabled or requests not supported,early return",  v4,  2);
      uint64_t v3 = (uint8_t *)v2;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::requestAPNSToken()", "%s\n", v2);
      if (v3 != buf) {
        free(v3);
      }
    }
  }

void *sub_1007680E4(void *a1, uint64_t a2, unint64_t a3)
{
  a1[2] = 0LL;
  uint64_t v4 = (uint64_t)(a1 + 2);
  *a1 = 0LL;
  a1[1] = 0LL;
  if (a3)
  {
    sub_10031C270(a1, a3);
    a1[1] = sub_100783D5C(v4, a2, a2 + 40 * a3, a1[1]);
  }

  return a1;
}

void sub_100768160( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose(va, 8) = v10;
  sub_10043B844(&a9);
  _Unwind_Resume(a1);
}

void sub_100768180(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1760))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v1 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_ERROR,  "#EED2 startCanSendADRTimeout called when timeout is already running, ignoring",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 startCanSendADRTimeout called when timeout is already running, ignoring",  v8,  2);
      uint64_t v3 = (uint8_t *)v2;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::startCanSendADRTimeout()", "%s\n", v2);
      if (v3 != buf) {
        free(v3);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#EED2 startCanSendADRTimeout", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v8[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 startCanSendADRTimeout",  v8,  2);
      unsigned int v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::startCanSendADRTimeout()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    *(_BYTE *)(a1 + 176sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
    sub_100763A5C(a1 + 1536, 12, 12.0);
  }

void sub_100768458(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 1872) = CFAbsoluteTimeGetCurrent();
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void **)(a1 + 1872);
    *(_DWORD *)uint64_t buf = 134283521;
    id v35 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupOnEmergencyCallEnd,set fCallEndTime to %{private}f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v15 = *(void **)(a1 + 1872);
    int v32 = 134283521;
    id v33 = v15;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 cleanupOnEmergencyCallEnd,set fCallEndTime to %{private}f",  &v32,  12);
    int v17 = (uint8_t *)v16;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupOnEmergencyCallEnd()", "%s\n", v16);
    if (v17 != buf) {
      free(v17);
    }
  }

  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  uint64_t v4 = *(void **)(a1 + 1888);
  id v5 = [v4 countByEnumeratingWithState:&v27 objects:v31 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v28;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v28 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v27 + 1) + 8LL * (void)i);
        [v9 setState:2];
        [*(id *)(a1 + 1896) addObject:v9];
      }

      id v6 = [v4 countByEnumeratingWithState:&v27 objects:v31 count:16];
    }

    while (v6);
  }

  if (*(void *)(a1 + 1888))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [*(id *)(a1 + 1888) count];
      *(_DWORD *)uint64_t buf = 134349056;
      id v35 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupOnEmergencyCallEnd,moved %{public}ld requests from fRequestsPending to fRequestsHandled queue",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v20 = qword_101934898;
      id v21 = [*(id *)(a1 + 1888) count];
      int v32 = 134349056;
      id v33 = v21;
      LODWORD(v26) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  0LL,  "#EED2 cleanupOnEmergencyCallEnd,moved %{public}ld requests from fRequestsPending to fRequestsHandled queue",  &v32,  v26);
      int v23 = (uint8_t *)v22;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupOnEmergencyCallEnd()", "%s\n", v22);
      if (v23 != buf) {
        free(v23);
      }
    }

    *(void *)(a1 + 188_Block_object_dispose(va, 8) = 0LL;
  }

  sub_10076F240(a1, (id *)(a1 + 1904));
  sub_10076F240(a1, (id *)(a1 + 1912));
  sub_10076BCF8(a1);
  int v12 = *(void **)(a1 + 1824);
  if (v12)
  {

    *(void *)(a1 + 18sub_10000AE14(v9 + 24) = 0LL;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v13 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupOnEmergencyCallEnd,fAPNSToken cleared",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v32) = 0;
      LODWORD(v26) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 cleanupOnEmergencyCallEnd,fAPNSToken cleared",  &v32,  v26);
      uint64_t v25 = (uint8_t *)v24;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupOnEmergencyCallEnd()", "%s\n", v24);
      if (v25 != buf) {
        free(v25);
      }
    }
  }

  sub_10076ACC0(a1);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v14 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupOnEmergencyCallEnd,completed",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v32) = 0;
    LODWORD(v26) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 cleanupOnEmergencyCallEnd,completed",  &v32,  v26);
    int v19 = (uint8_t *)v18;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupOnEmergencyCallEnd()", "%s\n", v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void sub_100768AAC(uint64_t a1)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1) & 1) != 0)
  {
    ++*(_DWORD *)(a1 + 1672);
    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 1448);
    uint64_t v2 = *(void *)(a1 + 56);
    if (!v2) {
      sub_100008BDC();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v2 + 48LL))(v2, buf);
    if (*(char *)(v3 + 159) < 0)
    {
      sub_1010DD48C(__p, *(void **)(v3 + 136), *(void *)(v3 + 144));
    }

    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v3 + 136);
      uint64_t v38 = *(void *)(v3 + 152);
    }

    sub_100F9F038(a1, (uint64_t)__p, a1 + 136);
    sub_100772904(a1, (uint64_t)__p, a1 + 136);
    if (v38 >= 0) {
      id v11 = (void *)HIBYTE(v38);
    }
    else {
      id v11 = __p[1];
    }
    if (v11)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v12 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#EED2 sending message for native number",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v36[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 sending message for native number",  v36,  2);
        __int128 v28 = (uint8_t *)v27;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendLocation()", "%s\n", v27);
        if (v28 != buf) {
          free(v28);
        }
      }

      sub_100772ACC(a1, 0, (uint64_t *)__p);
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v13 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#EED2 native number is empty, not sending message",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v36[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 native number is empty, not sending message",  v36,  2);
        int v34 = (uint8_t *)v33;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendLocation()", "%s\n", v33);
        if (v34 != buf) {
          free(v34);
        }
      }

      uint64_t v14 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 30LL);
      uint64_t v15 = *(void *)(a1 + 2040);
      if (v15)
      {
        unsigned int v16 = sub_100778A88(v14, *(_DWORD *)(v15 + 24));
        int v17 = *(_DWORD *)(v15 + 24);
        if (v16 >= 6) {
          int v17 = 8;
        }
        *(_DWORD *)(v15 + sub_10000AE14(v9 + 24) = v17;
      }
    }

    else {
      uint64_t v18 = *(unsigned __int8 *)(a1 + 159);
    }
    if (!v18 || byte_1019A4098)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v20 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#EED2 companion number is empty or device supports alternate account, not sending message",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v36[0] = 0;
        LODWORD(v35) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 companion number is empty or device supports alternate account, not sending message",  v36,  v35);
        int v32 = (uint8_t *)v31;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendLocation()", "%s\n", v31);
        if (v32 != buf) {
          free(v32);
        }
      }

      if (!byte_1019A4098)
      {
        uint64_t v21 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 30LL);
        uint64_t v22 = *(void *)(a1 + 2040);
        if (v22)
        {
          unsigned int v23 = sub_100778A88(v21, *(_DWORD *)(v22 + 24));
          int v24 = *(_DWORD *)(v22 + 24);
          if (v23 >= 6) {
            int v24 = 8;
          }
          *(_DWORD *)(v22 + sub_10000AE14(v9 + 24) = v24;
        }
      }
    }

    else
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v19 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#EED2 sending message for companion number",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v36[0] = 0;
        LODWORD(v35) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 sending message for companion number",  v36,  v35);
        __int128 v30 = (uint8_t *)v29;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendLocation()", "%s\n", v29);
        if (v30 != buf) {
          free(v30);
        }
      }

      sub_100772ACC(a1, 1, (uint64_t *)(a1 + 136));
    }

    if (SHIBYTE(v38) < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "#EED2 attempted to send location when not enabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(__p[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#EED2 attempted to send location when not enabled",  __p,  2);
      uint64_t v26 = (uint8_t *)v25;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendLocation()", "%s\n", v25);
      if (v26 != buf) {
        free(v26);
      }
    }

    uint64_t v5 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 12LL);
    uint64_t v6 = *(void *)(a1 + 2040);
    if (v6)
    {
      unsigned int v8 = *(_DWORD *)(v6 + 24);
      uint64_t v7 = (int *)(v6 + 24);
      unsigned int v9 = sub_100778A88(v5, v8);
      int v10 = *v7;
      if (v9 >= 2) {
        int v10 = 4;
      }
      *uint64_t v7 = v10;
    }
  }

void sub_100769294( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007692C8(uint64_t a1)
{
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#EED2 cleanupSession entered", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v85) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2 cleanupSession entered",  &v85,  2);
    int v61 = (char *)v60;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v60);
    if (v61 != buf) {
      free(v61);
    }
  }

  sub_10076F470(a1);
  sub_10076F608(a1);
  uint64_t v4 = sub_10076FD98((void *)a1);
  uint64_t v5 = v4;
  id v6 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
  if (*(void *)(a1 + 2040))
  {
    uint64_t v7 = v6;
    __int128 v83 = 0u;
    __int128 v84 = 0u;
    __int128 v81 = 0u;
    __int128 v82 = 0u;
    id v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v81,  v89,  16LL);
    if (v8)
    {
      id v10 = v8;
      uint64_t v79 = *(void *)v82;
      *(void *)&__int128 v9 = 67109632LL;
      __int128 v78 = v9;
      do
      {
        id v11 = 0LL;
        do
        {
          if (*(void *)v82 != v79) {
            objc_enumerationMutation(v4);
          }
          int v12 = *(void **)(*((void *)&v81 + 1) + 8LL * (void)v11);
          if ([v12 state] == (id)1) {
            ++*(_DWORD *)(*(void *)(a1 + 2040) + 48LL);
          }
          if ([v12 type] == (id)2)
          {
            int v13 = v4;
            uint64_t v14 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              int v15 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
              id v16 = [v12 numDuplicateMediaSelections];
              id v17 = objc_msgSend(objc_msgSend(v12, "mediaList"), "count");
              id v18 = [v7 count];
              *(_DWORD *)uint64_t buf = 67109888;
              *(_DWORD *)&uint8_t buf[4] = v15;
              *(_WORD *)&uint8_t buf[8] = 2048;
              *(void *)&buf[10] = v16;
              p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
              *(_WORD *)&_BYTE buf[18] = 2048;
              *(void *)&buf[20] = v17;
              *(_WORD *)&_BYTE buf[28] = 2048;
              *(void *)&buf[30] = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupSession,looping,before update,fEED2Report->fNumDuplicateMediaSelections:%d, eedRequest.numD uplicateMediaSelections:%ld, eedRequest.mediaList.count:%ld, mediaItemsAcrossRequests.count:%ld",  buf,  0x26u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              uint64_t v26 = qword_101934898;
              int v27 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
              id v28 = [v12 numDuplicateMediaSelections];
              id v29 = objc_msgSend(objc_msgSend(v12, "mediaList"), "count");
              id v30 = [v7 count];
              int v85 = 67109888;
              *(_DWORD *)int v86 = v27;
              *(_WORD *)&v86[4] = 2048;
              *(void *)&v86[6] = v28;
              *(_WORD *)&void v86[14] = 2048;
              *(void *)&v86[16] = v29;
              *(_WORD *)&v86[24] = 2048;
              *(void *)&v86[26] = v30;
              LODWORD(v77) = 38;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#EED2 cleanupSession,looping,before update,fEED2Report->fNumDuplicateMediaSelections:%d, eedRequest.numD uplicateMediaSelections:%ld, eedRequest.mediaList.count:%ld, mediaItemsAcrossRequests.count:%ld",  &v85,  v77,  (void)v78,  *((void *)&v78 + 1));
              int v32 = (char *)v31;
              sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v31);
              if (v32 != buf) {
                free(v32);
              }
              p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
            }

            int v19 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
            *(_DWORD *)(*(void *)(a1 + 2040) + 88LL) = v19
                                                       + [v12 numDuplicateMediaSelections];
            id v20 = [v7 count];
            objc_msgSend(v7, "unionSet:", objc_msgSend(v12, "mediaList"));
            int v21 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
            unsigned int v22 = objc_msgSend(objc_msgSend(v12, "mediaList"), "count") + (_DWORD)v20;
            *(_DWORD *)(*(void *)(a1 + 2040) + 88) = v21 + v22 - [v7 count];
            uint64_t v4 = v13;
            unsigned int v23 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              int v24 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
              id v25 = [v7 count];
              *(_DWORD *)uint64_t buf = v78;
              *(_DWORD *)&uint8_t buf[4] = v24;
              *(_WORD *)&uint8_t buf[8] = 2048;
              *(void *)&buf[10] = v20;
              *(_WORD *)&_BYTE buf[18] = 2048;
              *(void *)&buf[20] = v25;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupSession,looping,after update,fNumDuplicateMediaSelections:%d, itemListCountBeforeUpdate:%ld , mediaItemsAcrossRequests.count:%ld",  buf,  0x1Cu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              uint64_t v33 = qword_101934898;
              int v34 = *(_DWORD *)(*(void *)(a1 + 2040) + 88LL);
              id v35 = [v7 count];
              int v85 = v78;
              *(_DWORD *)int v86 = v34;
              *(_WORD *)&v86[4] = 2048;
              *(void *)&v86[6] = v20;
              *(_WORD *)&void v86[14] = 2048;
              *(void *)&v86[16] = v35;
              LODWORD(v77) = 28;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  0LL,  "#EED2 cleanupSession,looping,after update,fNumDuplicateMediaSelections:%d, itemListCountBeforeUpdate:%ld , mediaItemsAcrossRequests.count:%ld",  &v85,  v77,  (void)v78);
              __int16 v37 = (char *)v36;
              sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v36);
              if (v37 != buf) {
                free(v37);
              }
              uint64_t v4 = v13;
            }
          }

          id v11 = (char *)v11 + 1;
        }

        while (v10 != v11);
        id v38 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v81,  v89,  16LL);
        id v10 = v38;
      }

      while (v38);
    }

    *(_DWORD *)(*(void *)(a1 + 2040) + 92) = [v7 count];
    id v39 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = *(void *)(a1 + 2040);
      int v41 = *(_DWORD *)(v40 + 88);
      LODWORD(v4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_DWORD *)(v40 + 92);
      *(_DWORD *)uint64_t buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v41;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "#EED2 cleanupSession,fNumDuplicateMediaSelections:%d, fTotalItems:%d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      uint64_t v71 = *(void *)(a1 + 2040);
      int v72 = *(_DWORD *)(v71 + 88);
      LODWORD(v71) = *(_DWORD *)(v71 + 92);
      int v85 = 67109376;
      *(_DWORD *)int v86 = v72;
      *(_WORD *)&v86[4] = 1024;
      *(_DWORD *)&v86[6] = v71;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 cleanupSession,fNumDuplicateMediaSelections:%d, fTotalItems:%d",  &v85,  14);
      int v74 = (char *)v73;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v73);
      if (v74 != buf) {
        free(v74);
      }
    }
  }

  int v42 = *(void **)(a1 + 1888);
  if (v42)
  {

    *(void *)(a1 + 188_Block_object_dispose(va, 8) = 0LL;
  }

  char v43 = *(void **)(a1 + 1896);
  if (v43)
  {

    *(void *)(a1 + 1896) = 0LL;
  }

  __int16 v44 = *(void **)(a1 + 1904);
  if (v44)
  {

    *(void *)(a1 + 1904) = 0LL;
  }

  id v45 = *(void **)(a1 + 1912);
  if (v45)
  {

    *(void *)(a1 + 1912) = 0LL;
  }

  char v46 = *(void **)(a1 + 1920);
  if (v46)
  {

    *(void *)(a1 + 192sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
  }

  __int16 v47 = *(const void **)(a1 + 1928);
  if (v47)
  {
    CFRelease(v47);
    *(void *)(a1 + 192_Block_object_dispose(va, 8) = 0LL;
  }

  sub_1007675C4();
  sub_100767780();
  sub_100767A6C();
  unsigned int v48 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v49 = *(void *)(a1 + 1888);
    uint64_t v50 = *(void *)(a1 + 1896);
    uint64_t v51 = *(void *)(a1 + 1904);
    uint64_t v52 = *(void *)(a1 + 1912);
    uint64_t v53 = *(void *)(a1 + 1944);
    *(_DWORD *)uint64_t buf = 138544386;
    *(void *)&uint8_t buf[4] = v49;
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v50;
    *(_WORD *)&_BYTE buf[22] = 2114;
    *(void *)&buf[24] = v51;
    *(_WORD *)&uint8_t buf[32] = 2114;
    *(void *)&buf[34] = v52;
    __int16 v91 = 2114;
    uint64_t v92 = v53;
    _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "#EED2,cleanupSession,all queues and requests are cleaned up. fRequestsPending:%{public}@, fRequestsHandled:%{publi c}@, fCurrentStreamingRequest:%{public}@, fCurrentUploadRequest:%{public}@, fMediaService:%{public}@",  buf,  0x34u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    uint64_t v62 = *(void *)(a1 + 1888);
    uint64_t v63 = *(void *)(a1 + 1896);
    uint64_t v64 = *(void *)(a1 + 1904);
    uint64_t v65 = *(void *)(a1 + 1912);
    uint64_t v66 = *(void *)(a1 + 1944);
    int v85 = 138544386;
    *(void *)int v86 = v62;
    *(_WORD *)&v86[8] = 2114;
    *(void *)&v86[10] = v63;
    *(_WORD *)&v86[18] = 2114;
    *(void *)&v86[20] = v64;
    *(_WORD *)&v86[28] = 2114;
    *(void *)&v86[30] = v65;
    __int16 v87 = 2114;
    uint64_t v88 = v66;
    LODWORD(v77) = 52;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,cleanupSession,all queues and requests are cleaned up. fRequestsPending:%{public}@, fRequestsHandled:%{publi c}@, fCurrentStreamingRequest:%{public}@, fCurrentUploadRequest:%{public}@, fMediaService:%{public}@",  &v85,  v77);
    int v68 = (char *)v67;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v67);
    if (v68 != buf) {
      free(v68);
    }
  }

  sub_10076452C(a1 + 1536, 7);
  sub_10076452C(a1 + 1536, 8);
  sub_10076452C(a1 + 1536, 11);
  sub_10076A080(a1);
  *(_DWORD *)(a1 + 176_Block_object_dispose(va, 8) = 0;
  uint64_t v54 = *(void *)(a1 + 1752);
  if (v54) {
    sub_100EEF808(v54, 0);
  }
  [*(id *)(a1 + 1736) invalidate];

  *(void *)(a1 + 1736) = 0LL;
  if (*(_BYTE *)(a1 + 184))
  {
    __int16 v55 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_ERROR,  "#EED2 session assertion active during Session Exit,clearing",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      LOWORD(v85) = 0;
      LODWORD(v77) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 session assertion active during Session Exit,clearing",  &v85,  v77);
      int v76 = (char *)v75;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v75);
      if (v76 != buf) {
        free(v76);
      }
    }

    sub_100F9E9FC(a1, 0LL);
  }

  int v85 = 0;
  *(void *)uint64_t buf = &v85;
  unsigned int v56 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v85, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
  if (v56[6] == v56[5]
    && (int v80 = 1,
        *(void *)uint64_t buf = &v80,
        __int16 v57 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v80, (uint64_t)&unk_1012CF090, (_DWORD **)buf),
        v57[6] == v57[5]))
  {
    sub_100F9F0DC(a1);
    sub_100766D4C(a1);
  }

  else
  {
    sub_100763A5C(a1 + 1536, 14, 60.0);
  }

  unsigned int v58 = *(void **)(a1 + 1984);
  if (v58)
  {

    *(void *)(a1 + 1984) = 0LL;
  }

  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(a1 + 1936) = 0;
  *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(a1 + 194sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  uint64_t v59 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEBUG, "#EED2 cleanupSession completed", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    LOWORD(v85) = 0;
    LODWORD(v77) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2 cleanupSession completed",  &v85,  v77);
    int v70 = (char *)v69;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupSession()", "%s\n", v69);
    if (v70 != buf) {
      free(v70);
    }
  }

void sub_10076A080(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EED2 cancelCanSendADRTimeout", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 cancelCanSendADRTimeout",  v5,  2);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cancelCanSendADRTimeout()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  *(_BYTE *)(a1 + 176sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
  sub_10076452C(a1 + 1536, 12);
}

void sub_10076A220(uint64_t a1)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "#EED2,sendAdr,attempted to send ADR when not enabled",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(__p[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#EED2,sendAdr,attempted to send ADR when not enabled",  __p,  2);
      id v39 = (char *)v38;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v38);
    }

    uint64_t v8 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 12LL);
    uint64_t v9 = *(void *)(a1 + 2040);
    if (v9)
    {
      unsigned int v11 = *(_DWORD *)(v9 + 24);
      id v10 = (int *)(v9 + 24);
      unsigned int v12 = sub_100778A88(v8, v11);
      int v13 = *v10;
      if (v12 >= 2) {
        int v13 = 4;
      }
      int *v10 = v13;
    }

    return;
  }

  if (!*(_BYTE *)(a1 + 1761))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v14 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendAdr,ignoring ADR send request,not allowed to send ADR data at this time",  (uint8_t *)&buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendAdr,ignoring ADR send request,not allowed to send ADR data at this time",  __p,  2);
    id v16 = (char *)v15;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v15);
LABEL_43:
    return;
  }

  if (!*(_BYTE *)(a1 + 1762))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v18 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendAdr,ignoring ADR send request,not finished gathering ADR data",  (uint8_t *)&buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendAdr,ignoring ADR send request,not finished gathering ADR data",  __p,  2);
    id v16 = (char *)v19;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v19);
    goto LABEL_43;
  }

  uint64_t v2 = sub_100756E48((int *)(a1 + 1448));
  if (*((_BYTE *)v2 + 57)) {
    BOOL v3 = v2[23] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = *((unsigned __int8 *)v2 + 223);
    if ((v4 & 0x80u) != 0LL) {
      uint64_t v4 = v2[26];
    }
    if (v4)
    {
      LODWORD(buf) = *(_DWORD *)(a1 + 1448);
      uint64_t v5 = *(void *)(a1 + 56);
      if (!v5) {
        sub_100008BDC();
      }
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v5 + 48LL))(v5, &buf);
      if (*(char *)(v6 + 159) < 0)
      {
        sub_1010DD48C(__p, *(void **)(v6 + 136), *(void *)(v6 + 144));
      }

      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(v6 + 136);
        uint64_t v46 = *(void *)(v6 + 152);
      }

      id v20 = (void *)HIBYTE(v46);
      if (v46 < 0) {
        id v20 = __p[1];
      }
      if (!v20 && !(*(char *)(a1 + 159) < 0 ? *(void *)(a1 + 144) : *(unsigned __int8 *)(a1 + 159)))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v33 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "#EED2,sendAdr,neither native nor companion number available so not sending ADR",  (uint8_t *)&buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          v44[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,sendAdr,neither native nor companion number available so not sending ADR",  v44,  2);
          id v35 = (char *)v34;
          sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v34);
        }

        goto LABEL_90;
      }

      uint64_t v22 = *(void *)(a1 + 104);
      if (!v22) {
        sub_100008BDC();
      }
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v22 + 48LL))(&buf);
      unsigned int v23 = sub_1007732CC((uint64_t)&buf);
      int v24 = v52;
      if (v52)
      {
        p_shared_owners = (unint64_t *)&v52->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(p_shared_owners);
        while (__stlxr(v26 - 1, p_shared_owners));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      int v27 = v23;
      if (!v23)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v32 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendAdr,no location available so not sending ADR",  (uint8_t *)&buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          v44[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendAdr,no location available so not sending ADR",  v44,  2);
          char v43 = (char *)v42;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v42);
        }

        *(_BYTE *)(a1 + 1763) = 1;
        goto LABEL_90;
      }

      *(_BYTE *)(a1 + 1763) = 0;
      uint64_t v28 = *(void *)(a1 + 1752);
      if (!v28) {
        goto LABEL_84;
      }
      v47[0] = &off_10184E310;
      v47[1] = a1;
      unsigned int v48 = v47;
      char v29 = sub_100EEFA54(v28, v23, a1 + 192, (uint64_t)v47);
      id v30 = v48;
      if (v48 == v47)
      {
        uint64_t v31 = 4LL;
        id v30 = v47;
      }

      else
      {
        if (!v48) {
          goto LABEL_81;
        }
        uint64_t v31 = 5LL;
      }

      (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_81:
      if ((v29 & 1) != 0)
      {
        uint64_t v36 = *(void *)(a1 + 2040);
        if (v36) {
          ++*(_DWORD *)(v36 + 16);
        }
LABEL_89:
        sub_1007745E0(a1);
LABEL_90:
        if (SHIBYTE(v46) < 0) {
          operator delete(__p[0]);
        }
        return;
      }

void sub_10076AC40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10076ACC0(uint64_t a1)
{
  if (sub_1001B9A1C())
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,not enabled for watches",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v72) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendControlData,not enabled for watches",  &v72,  2);
      uint64_t v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v3);
LABEL_10:
      if (v4 != buf) {
        free(v4);
      }
      return;
    }

    return;
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "#EED2,sendControlData,attempted to send Control data when not enabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v72) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#EED2,sendControlData,attempted to send Control data when not enabled",  &v72,  2);
      uint64_t v54 = (uint8_t *)v53;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v53);
      if (v54 != buf) {
        free(v54);
      }
    }

    uint64_t v10 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 12LL);
    uint64_t v11 = *(void *)(a1 + 2040);
    if (v11)
    {
      unsigned int v13 = *(_DWORD *)(v11 + 24);
      unsigned int v12 = (int *)(v11 + 24);
      unsigned int v14 = sub_100778A88(v10, v13);
      int v15 = *v12;
      if (v14 >= 2) {
        int v15 = 4;
      }
      *unsigned int v12 = v15;
    }

    return;
  }

  if (!*((_BYTE *)sub_100756E48((int *)(a1 + 1448)) + 59))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v16 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,feature not enabled or requests not supported,early return",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v72) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendControlData,feature not enabled or requests not supported,early return",  &v72,  2);
      uint64_t v4 = (uint8_t *)v17;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v17);
      goto LABEL_10;
    }

    return;
  }

  if (*(void *)(a1 + 1880))
  {
    uint64_t v5 = sub_100756E48((int *)(a1 + 1448));
    if (!*((_BYTE *)v5 + 59) || !v5[23]) {
      goto LABEL_40;
    }
    uint64_t v6 = *((unsigned __int8 *)v5 + 223);
    if ((v6 & 0x80u) != 0LL) {
      uint64_t v6 = v5[26];
    }
    if (!v6)
    {
LABEL_40:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v18 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)__int128 v83 = 0;
        *(_WORD *)&v83[4] = 2082;
        *(void *)&v83[6] = "";
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,sendControlData,not configured for Control Data encryption}",  buf,  0x12u);
      }

      return;
    }

    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 1448);
    uint64_t v7 = *(void *)(a1 + 56);
    if (!v7) {
      sub_100008BDC();
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v7 + 48LL))(v7, buf);
    if (*(char *)(v8 + 159) < 0)
    {
      sub_1010DD48C(__p, *(void **)(v8 + 136), *(void *)(v8 + 144));
    }

    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v8 + 136);
      uint64_t v69 = *(void *)(v8 + 152);
    }

    int v21 = (void *)HIBYTE(v69);
    if (v69 < 0) {
      int v21 = __p[1];
    }
    if (!v21 && !(*(char *)(a1 + 159) < 0 ? *(void *)(a1 + 144) : *(unsigned __int8 *)(a1 + 159)))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v44 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_ERROR,  "#EED2,sendControlData,neither native nor companion number available so not sending Control Data",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v72) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,sendControlData,neither native nor companion number available so not sending Control Data",  &v72,  2,  __p[0]);
        uint64_t v46 = (uint8_t *)v45;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v45);
        if (v46 != buf) {
          free(v46);
        }
      }

      goto LABEL_112;
    }

    if (*(_BYTE *)(a1 + 1936))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unsigned int v23 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,waiting for response for previous sendControlData. set fControlDataSendPending",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v72) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendControlData,waiting for response for previous sendControlData. set fControlDataSendPending",  &v72,  2,  __p[0]);
        unsigned int v56 = (uint8_t *)v55;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v55);
        if (v56 != buf) {
          free(v56);
        }
      }

      *(_BYTE *)(a1 + 1937) = 1;
      goto LABEL_112;
    }

    int v24 = sub_10076FD98((void *)a1);
    id v25 = v24;
    uint64_t v26 = *(void *)(a1 + 104);
    if (!v26) {
      sub_100008BDC();
    }
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v26 + 48LL))(buf);
    int v27 = sub_1007732CC((uint64_t)buf);
    sub_10000AE14((uint64_t)&v90);
    uint64_t v28 = v27;
    if (!v27)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v47 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,no location available not sending Control data right now",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v72) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendControlData,no location available not sending Control data right now",  &v72,  2,  __p[0]);
        uint64_t v66 = (uint8_t *)v65;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v65);
        if (v66 != buf) {
          free(v66);
        }
      }

      *(_BYTE *)(a1 + 184sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 1;
      goto LABEL_112;
    }

    *(_BYTE *)(a1 + 184sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    char v29 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v30 = -[NSMutableArray count](v24, "count");
      uint64_t v31 = *(void *)(a1 + 1824);
      uint64_t v32 = *(void *)(a1 + 168);
      uint64_t v33 = *(void *)(a1 + 1872);
      *(_DWORD *)uint64_t buf = 134219010;
      *(void *)__int128 v83 = v30;
      *(_WORD *)&v83[8] = 2112;
      *(void *)&_BYTE v83[10] = v31;
      __int16 v84 = 2048;
      uint64_t v85 = v32;
      __int16 v86 = 2048;
      uint64_t v87 = v33;
      __int16 v88 = 2112;
      int v89 = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,eedRequests Count:%ld,fAPNSToken:%@,fSessionStartTime:%f,fCallEndTime:%f, locationDict:%@",  buf,  0x34u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v57 = qword_101934898;
      id v58 = -[NSMutableArray count](v24, "count");
      uint64_t v59 = *(void *)(a1 + 1824);
      uint64_t v60 = *(void *)(a1 + 168);
      uint64_t v61 = *(void *)(a1 + 1872);
      int v72 = 134219010;
      id v73 = v58;
      __int16 v74 = 2112;
      uint64_t v75 = v59;
      __int16 v76 = 2048;
      uint64_t v77 = v60;
      __int16 v78 = 2048;
      uint64_t v79 = v61;
      __int16 v80 = 2112;
      __int128 v81 = v27;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v57,  0LL,  "#EED2,sendControlData,eedRequests Count:%ld,fAPNSToken:%@,fSessionStartTime:%f,fCallEndTime:%f, locationDict:%@",  &v72,  52);
      uint64_t v63 = (uint8_t *)v62;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v62);
      if (v63 != buf) {
        free(v63);
      }
    }

    uint64_t v34 = *(void *)(a1 + 1880);
    if (!v34) {
      goto LABEL_106;
    }
    id v35 = *(void **)(a1 + 1824);
    double v36 = *(double *)(a1 + 168);
    double v37 = *(double *)(a1 + 1872);
    id v38 = *(uint64_t **)(a1 + 1920);
    uint64_t v39 = *(void *)(a1 + 1928);
    uint64_t v40 = sub_10077516C(a1);
    v70[0] = &off_10184E3D0;
    v70[1] = a1;
    uint64_t v71 = v70;
    char v41 = sub_100CC7FF8(v34, v35, (uint64_t)v27, v24, v38, v39, (uint64_t)v40, (uint64_t)v70, v36, v37);
    int v42 = v71;
    if (v71 == v70)
    {
      uint64_t v43 = 4LL;
      int v42 = v70;
    }

    else
    {
      if (!v71) {
        goto LABEL_95;
      }
      uint64_t v43 = 5LL;
    }

    (*(void (**)(void))(*v42 + 8 * v43))();
LABEL_95:
    if ((v41 & 1) != 0)
    {
      *(_BYTE *)(a1 + 1936) = 1;
      uint64_t v48 = *(void *)(a1 + 2040);
      if (v48) {
        ++*(_DWORD *)(v48 + 52);
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v49 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "#EED2,sendControlData,control send Successful",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_111;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v72) = 0;
      LODWORD(v67) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,sendControlData,control send Successful",  &v72,  v67,  __p[0]);
      uint64_t v51 = (uint8_t *)v50;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::sendControlData()", "%s\n", v50);
LABEL_130:
      if (v51 != buf) {
        free(v51);
      }
LABEL_111:
      sub_1007745E0(a1);
LABEL_112:
      if (SHIBYTE(v69) < 0) {
        operator delete(__p[0]);
      }
      return;
    }

void sub_10076BC60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10076BCF8(uint64_t a1)
{
  if (*(void *)(a1 + 1920) && *(void *)(a1 + 1928))
  {
    id v2 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    BOOL v3 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 168));
    if (byte_10199844F >= 0) {
      uint64_t v4 = &qword_101998438;
    }
    else {
      uint64_t v4 = (uint64_t *)qword_101998438;
    }
    objc_msgSend( v2,  "setValue:forKey:",  v3,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4));
    uint64_t v5 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 1872));
    if (byte_101998467 >= 0) {
      uint64_t v6 = &qword_101998450;
    }
    else {
      uint64_t v6 = (uint64_t *)qword_101998450;
    }
    objc_msgSend( v2,  "setValue:forKey:",  v5,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6));
    if (byte_101998497 >= 0) {
      uint64_t v7 = &qword_101998480;
    }
    else {
      uint64_t v7 = (uint64_t *)qword_101998480;
    }
    objc_msgSend( v2,  "setValue:forKey:",  *(void *)(a1 + 1920),  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
    uint64_t v8 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_100764AF4(a1));
    if (byte_10199847F >= 0) {
      uint64_t v9 = &qword_101998468;
    }
    else {
      uint64_t v9 = (uint64_t *)qword_101998468;
    }
    objc_msgSend( v2,  "setValue:forKey:",  v8,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9));
    id v10 = +[CLEEDCryptoUtilities getKeyExternalRepresentation:]( &OBJC_CLASS___CLEEDCryptoUtilities,  "getKeyExternalRepresentation:",  *(void *)(a1 + 1928));
    if (v10)
    {
      if (byte_1019984AF >= 0) {
        uint64_t v11 = &qword_101998498;
      }
      else {
        uint64_t v11 = (uint64_t *)qword_101998498;
      }
      objc_msgSend( v2,  "setValue:forKey:",  v10,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11));
      unsigned int v12 = *(void **)(a1 + 1904);
      if (v12)
      {
        id v13 = [v12 getRequestDict];
        if (v13)
        {
          if (byte_1019984C7 >= 0) {
            unsigned int v14 = &qword_1019984B0;
          }
          else {
            unsigned int v14 = (uint64_t *)qword_1019984B0;
          }
          objc_msgSend( v2,  "setValue:forKey:",  v13,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v15 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,Added fCurrentStreamingRequest to cacheDataDict",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v79) = 0;
            double v17 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,Added fCurrentStreamingRequest to cacheDataDict",  &v79,  2);
LABEL_58:
            unsigned int v23 = v16;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v17);
LABEL_176:
            if (v23 != buf) {
              free(v23);
            }
          }
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          int v24 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDDataToCache,fCurrentStreamingRequest,nil dict",  buf,  2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v79) = 0;
            double v70 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDDataToCache,fCurrentStreamingRequest,nil dict",  &v79,  2);
            unsigned int v23 = v71;
            sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v70);
            goto LABEL_176;
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v22 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,fCurrentStreamingRequest is empty",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v79) = 0;
          double v17 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,fCurrentStreamingRequest is empty",  &v79,  2);
          goto LABEL_58;
        }
      }

      id v25 = *(void **)(a1 + 1912);
      if (v25)
      {
        id v26 = [v25 getRequestDict];
        if (v26)
        {
          if (byte_1019984DF >= 0) {
            int v27 = &qword_1019984C8;
          }
          else {
            int v27 = (uint64_t *)qword_1019984C8;
          }
          objc_msgSend( v2,  "setValue:forKey:",  v26,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v27));
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v28 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,Added fCurrentUploadRequest to cacheDataDict",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v79) = 0;
            LODWORD(v76) = 2;
            double v30 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,Added fCurrentUploadRequest to cacheDataDict",  &v79,  v76);
LABEL_85:
            uint64_t v32 = v29;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v30);
LABEL_181:
            if (v32 != buf) {
              free(v32);
            }
          }
        }

        else
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v33 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDDataToCache,fCurrentUploadRequest,nil dict",  buf,  2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v79) = 0;
            LODWORD(v76) = 2;
            double v72 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDDataToCache,fCurrentUploadRequest,nil dict",  &v79,  v76);
            uint64_t v32 = v73;
            sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v72);
            goto LABEL_181;
          }
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v31 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,fCurrentUploadRequest is empty",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          LOWORD(v79) = 0;
          LODWORD(v76) = 2;
          double v30 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,fCurrentUploadRequest is empty",  &v79,  v76);
          goto LABEL_85;
        }
      }

      id v34 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      id v35 = *(void **)(a1 + 1888);
      v78[0] = _NSConcreteStackBlock;
      v78[1] = 3221225472LL;
      v78[2] = sub_100780BF4;
      v78[3] = &unk_10184E008;
      v78[4] = v34;
      [v35 enumerateObjectsUsingBlock:v78];
      if ([v34 count])
      {
        if (byte_10199850F >= 0) {
          double v36 = &qword_1019984F8;
        }
        else {
          double v36 = (uint64_t *)qword_1019984F8;
        }
        objc_msgSend( v2,  "setValue:forKey:",  v34,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v36));
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        double v37 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          id v38 = [v34 count];
          *(_DWORD *)uint64_t buf = 134349056;
          id v82 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,Added %{public}lu requests from fRequestsPending to cacheDataDict",  buf,  0xCu);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_109;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v39 = qword_101934898;
        id v40 = [v34 count];
        int v79 = 134349056;
        id v80 = v40;
        LODWORD(v76) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v39,  0LL,  "#EED2,storeEEDDataToCache,Added %{public}lu requests from fRequestsPending to cacheDataDict",  &v79,  v76);
        int v42 = (uint8_t *)v41;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v41);
        if (v42 == buf) {
          goto LABEL_109;
        }
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v43 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,fRequestsPending is empty",  buf,  2u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_109;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v79) = 0;
        LODWORD(v76) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,fRequestsPending is empty",  &v79,  v76);
        int v42 = (uint8_t *)v68;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v68);
        if (v42 == buf)
        {
LABEL_109:
          id v44 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          id v45 = *(void **)(a1 + 1896);
          v77[0] = _NSConcreteStackBlock;
          v77[1] = 3221225472LL;
          v77[2] = sub_100780F14;
          v77[3] = &unk_10184E008;
          v77[4] = v44;
          [v45 enumerateObjectsUsingBlock:v77];
          if ([v44 count])
          {
            if (byte_101998527 >= 0) {
              uint64_t v46 = &qword_101998510;
            }
            else {
              uint64_t v46 = (uint64_t *)qword_101998510;
            }
            objc_msgSend( v2,  "setValue:forKey:",  v44,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v46));
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            __int16 v47 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              id v48 = [v44 count];
              *(_DWORD *)uint64_t buf = 134349056;
              id v82 = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,Added %{public}lu requests from fRequestsHandled to cacheDataDict",  buf,  0xCu);
            }

            if (!sub_1002921D0(115, 2)) {
              goto LABEL_127;
            }
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            uint64_t v49 = qword_101934898;
            id v50 = [v44 count];
            int v79 = 134349056;
            id v80 = v50;
            LODWORD(v76) = 12;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  0LL,  "#EED2,storeEEDDataToCache,Added %{public}lu requests from fRequestsHandled to cacheDataDict",  &v79,  v76);
            uint64_t v52 = (uint8_t *)v51;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v51);
            if (v52 == buf) {
              goto LABEL_127;
            }
          }

          else
          {
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            uint64_t v53 = (os_log_s *)qword_101934898;
            if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,fRequestsHandled is empty",  buf,  2u);
            }

            if (!sub_1002921D0(115, 2)) {
              goto LABEL_127;
            }
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_10184E040);
            }
            LOWORD(v79) = 0;
            LODWORD(v76) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,fRequestsHandled is empty",  &v79,  v76);
            uint64_t v52 = (uint8_t *)v69;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v69);
            if (v52 == buf)
            {
LABEL_127:
              uint64_t v54 = *(void **)(a1 + 1960);
              if (v54)
              {
                id v55 = [v54 newMitigationDict];
                if (!v55)
                {
                  if (qword_101934890 != -1) {
                    dispatch_once(&qword_101934890, &stru_10184E040);
                  }
                  uint64_t v62 = (os_log_s *)qword_101934898;
                  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)uint64_t buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDDataToCache,fEEDCoexMitigation,nil dict",  buf,  2u);
                  }

                  if (!sub_1002921D0(115, 0)) {
                    goto LABEL_154;
                  }
                  bzero(buf, 0x65CuLL);
                  if (qword_101934890 != -1) {
                    dispatch_once(&qword_101934890, &stru_10184E040);
                  }
                  LOWORD(v79) = 0;
                  LODWORD(v76) = 2;
                  double v74 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDDataToCache,fEEDCoexMitigation,nil dict",  &v79,  v76);
                  uint64_t v61 = v75;
                  sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v74);
                  goto LABEL_186;
                }

                if (byte_1019984F7 >= 0) {
                  unsigned int v56 = &qword_1019984E0;
                }
                else {
                  unsigned int v56 = (uint64_t *)qword_1019984E0;
                }
                objc_msgSend( v2,  "setValue:forKey:",  v55,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v56));
                if (qword_101934890 != -1) {
                  dispatch_once(&qword_101934890, &stru_10184E040);
                }
                uint64_t v57 = (os_log_s *)qword_101934898;
                if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,Added fEEDCoexMitigation to cacheDataDict",  buf,  2u);
                }

                if (!sub_1002921D0(115, 2)) {
                  goto LABEL_154;
                }
                bzero(buf, 0x65CuLL);
                if (qword_101934890 != -1) {
                  dispatch_once(&qword_101934890, &stru_10184E040);
                }
                LOWORD(v79) = 0;
                LODWORD(v76) = 2;
                double v59 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,Added fEEDCoexMitigation to cacheDataDict",  &v79,  v76);
              }

              else
              {
                if (qword_101934890 != -1) {
                  dispatch_once(&qword_101934890, &stru_10184E040);
                }
                uint64_t v60 = (os_log_s *)qword_101934898;
                if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,fEEDCoexMitigation is empty",  buf,  2u);
                }

                if (!sub_1002921D0(115, 2)) {
                  goto LABEL_154;
                }
                bzero(buf, 0x65CuLL);
                if (qword_101934890 != -1) {
                  dispatch_once(&qword_101934890, &stru_10184E040);
                }
                LOWORD(v79) = 0;
                LODWORD(v76) = 2;
                double v59 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,fEEDCoexMitigation is empty",  &v79,  v76);
              }

              uint64_t v61 = v58;
              sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v59);
LABEL_186:
              if (v61 != buf) {
                free(v61);
              }
LABEL_154:
              if (qword_101934890 != -1) {
                dispatch_once(&qword_101934890, &stru_10184E040);
              }
              uint64_t v63 = (os_log_s *)qword_101934898;
              if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t buf = 138412290;
                id v82 = v2;
                _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDDataToCache,storing the dictionary to cache:%@",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934890 != -1) {
                  dispatch_once(&qword_101934890, &stru_10184E040);
                }
                int v79 = 138412290;
                id v80 = v2;
                LODWORD(v76) = 12;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDDataToCache,storing the dictionary to cache:%@",  &v79,  v76);
                uint64_t v67 = (uint8_t *)v66;
                sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v66);
                if (v67 != buf) {
                  free(v67);
                }
              }

              uint64_t v64 = sub_1002F8DDC();
              sub_1002AB3DC(v64);
              uint64_t v65 = sub_1002F8DDC();
              (*(void (**)(uint64_t))(*(void *)v65 + 944LL))(v65);
              return;
            }
          }

          free(v52);
          goto LABEL_127;
        }
      }

      free(v42);
      goto LABEL_109;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v21 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDDataToCache,nil deviceSessionPrivateKeyRep,cannot store data,early return",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v79) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDDataToCache,nil deviceSessionPrivateKeyRep,cannot store data,early return",  &v79,  2);
LABEL_40:
      id v20 = (uint8_t *)v19;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::storeEEDDataToCache()", "%s\n", v19);
      if (v20 != buf) {
        free(v20);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v18 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDDataToCache,nil fRootSecret or fDeviceSessionPrivateKey,cannot store data,early return",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v79) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDDataToCache,nil fRootSecret or fDeviceSessionPrivateKey,cannot store data,early return",  &v79,  2);
      goto LABEL_40;
    }
  }

void sub_10076D204(uint64_t a1)
{
  if (sub_100779E5C(a1))
  {
    id v2 = +[CLEEDRequest getPartnerIDFromDict:]( &OBJC_CLASS___CLEEDRequest,  "getPartnerIDFromDict:",  *(void *)(a1 + 1832));
    BOOL v3 = sub_100756E48((int *)(a1 + 1448));
    sub_1010DDBC0(__p, (char *)[v2 UTF8String]);
    sub_100752D3C((int *)v3, (unsigned __int8 *)__p, (uint64_t)&__str);
    if (v85 < 0) {
      operator delete(__p[0]);
    }
    std::string::size_type size = __str.__r_.__value_.__s.__size_;
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (!size)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v11 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        id v12 = [v2 UTF8String];
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,valid cert not found for receviedPartnerID: %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v53 = qword_101934898;
        id v54 = [v2 UTF8String];
        int v91 = 136315138;
        id v92 = v54;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v53,  16LL,  "#EED2,handleAPNSMessage,valid cert not found for receviedPartnerID: %s",  (const char *)&v91);
        unsigned int v56 = (char *)v55;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v55);
        if (v56 != buf) {
          free(v56);
        }
      }

      sub_10077A6A0(a1, 8LL);

      *(void *)(a1 + 1832) = 0LL;
      goto LABEL_74;
    }

    memset(&v83, 0, sizeof(v83));
    memset(&v82, 0, sizeof(v82));
    uint64_t v5 = sub_100756E48((int *)(a1 + 1448));
    sub_100781FD0((uint64_t)&v91, (uint64_t)(v5 + 20));
    id v6 = +[CLEEDRequest getCallIDFromDict:](&OBJC_CLASS___CLEEDRequest, "getCallIDFromDict:", *(void *)(a1 + 1832));
    sub_1010DDBC0(buf, (char *)[v2 UTF8String]);
    uint64_t v7 = sub_10023BD04(&v91, buf);
    uint64_t v8 = (const std::string *)v7;
    if (SHIBYTE(v96) < 0)
    {
      operator delete(*(void **)buf);
      if (!v8) {
        goto LABEL_63;
      }
    }

    else if (!v7)
    {
LABEL_63:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v35 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,nil deviceSessionSecretForPartner due to phone number mismatch,early return",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_68;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v89 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessage,nil deviceSessionSecretForPartner due to phone number mismatch,early return",  v89,  2);
      uint64_t v52 = (char *)v51;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v51);
      if (v52 == buf) {
        goto LABEL_68;
      }
      goto LABEL_126;
    }

    std::string::operator=(&v83, v8 + 4);
    int v13 = v8[3].__r_.__value_.__s.__data_[16];
    std::string::operator=(&v82, &__str);
    uint64_t v14 = *(void *)(a1 + 1880);
    sub_1010DDBC0(buf, (char *)[v6 UTF8String]);
    int v15 = sub_100CCADC4(v14, (uint64_t *)&v8[1].__r_.__value_.__l.__cap_, (uint64_t *)buf, *(uint64_t **)(a1 + 1920));
    id v16 = v15;
    if (SHIBYTE(v96) < 0)
    {
      operator delete(*(void **)buf);
      if (!v16) {
        goto LABEL_63;
      }
    }

    else if (!v15)
    {
      goto LABEL_63;
    }

    if (!v13)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      double v36 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,requestsSupportedByPartner is false,early return",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v89 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessage,requestsSupportedByPartner is false,early return",  v89,  2);
        uint64_t v61 = (char *)v60;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v60);
        if (v61 != buf) {
          free(v61);
        }
      }

      sub_10077A6A0(a1, 12LL);

      goto LABEL_69;
    }

    if ((v82.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v17 = &v82;
    }
    else {
      double v17 = (std::string *)v82.__r_.__value_.__r.__words[0];
    }
    id v18 = +[CLEEDCryptoUtilities copyAdrPublicKeyData:]( &OBJC_CLASS___CLEEDCryptoUtilities,  "copyAdrPublicKeyData:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v17));
    id v19 = v18;
    if (!v18)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      double v37 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,nil partnerAdrPublicKeyData,early return",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_68;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)int v89 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessage,nil partnerAdrPublicKeyData,early return",  v89,  2);
      uint64_t v52 = (char *)v62;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v62);
      if (v52 == buf) {
        goto LABEL_68;
      }
LABEL_126:
      free(v52);
LABEL_68:
      sub_10077A6A0(a1, 7LL);

LABEL_69:
      *(void *)(a1 + 1832) = 0LL;
LABEL_70:
      sub_100782514((uint64_t)&v91);
LABEL_74:
      return;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v20 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = &v83;
      if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v21 = (std::string *)v83.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 138412802;
      *(void *)&uint8_t buf[4] = v2;
      __int16 v94 = 2080;
      int v95 = v21;
      __int16 v96 = 2048;
      uint64_t v97 = 1LL;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessage,receviedPartnerID:%@,baseURL:%s,requestsSupportedByPartner:%ld",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v57 = &v83;
      if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v57 = (std::string *)v83.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v89 = 138412802;
      *(void *)&v89[4] = v2;
      *(_WORD *)&v89[12] = 2080;
      *(void *)&v89[14] = v57;
      *(_WORD *)&v89[22] = 2048;
      uint64_t v90 = 1LL;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,handleAPNSMessage,receviedPartnerID:%@,baseURL:%s,requestsSupportedByPartner:%ld",  v89,  32);
      double v59 = (char *)v58;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v58);
      if (v59 != buf) {
        free(v59);
      }
    }

    id v22 = +[CLEEDCryptoUtilities getSessionIDWithPhoneNumber:sessionStartTime:]( &OBJC_CLASS___CLEEDCryptoUtilities,  "getSessionIDWithPhoneNumber:sessionStartTime:",  v6,  +[CLEEDRequest getSessionStartTimeFromDict:]( &OBJC_CLASS___CLEEDRequest,  "getSessionStartTimeFromDict:",  *(void *)(a1 + 1832)));
    uint64_t v81 = 0LL;
    if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v23 = &v83;
    }
    else {
      unsigned int v23 = (std::string *)v83.__r_.__value_.__r.__words[0];
    }
    id v24 = +[CLEEDRequest createRequestFromDict:baseURL:sessionID:partnerAdrPublicKeyData:deviceSessionPrivateKey:deviceSessionSecret:error:]( &OBJC_CLASS___CLEEDRequest,  "createRequestFromDict:baseURL:sessionID:partnerAdrPublicKeyData:deviceSessionPrivateKey:deviceSessionSecret:error:",  *(void *)(a1 + 1832),  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v23),  v22,  v18,  *(void *)(a1 + 1928),  v16,  &v81);
    id v25 = v24;
    if (!v24 || v81)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v38 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,decryption failed",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v89 = 0;
        LODWORD(v79) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessage,decryption failed",  v89,  v79);
        uint64_t v64 = (char *)v63;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v63);
        if (v64 != buf) {
          free(v64);
        }
      }

      sub_10077A6A0(a1, 8LL);

      goto LABEL_69;
    }

    *(void *)(a1 + 1832) = 0LL;
    uint64_t v26 = *(void *)(a1 + 2040);
    if (v26)
    {
      if (!*(void *)(v26 + 72))
      {
        id v27 = [v24 type];
        uint64_t v26 = *(void *)(a1 + 2040);
        *(void *)(v26 + 72) = v27;
      }

      sub_100778C28(v26, v24);
    }

    [v24 setRequestReceivedTime:CFAbsoluteTimeGetCurrent()];
    objc_msgSend(objc_msgSend(v24, "requestDate"), "timeIntervalSinceNow");
    [v24 setRequestTransmissionTime:(int)vcvtpd_s64_f64(fabs(v28) * 1000.0)];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    char v29 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v30 = [v24 requestDate];
      uint64_t v31 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
      id v32 = [v24 requestTransmissionTime];
      *(_DWORD *)uint64_t buf = 138412802;
      *(void *)&uint8_t buf[4] = v30;
      __int16 v94 = 2112;
      int v95 = v31;
      __int16 v96 = 2048;
      uint64_t v97 = (uint64_t)v32;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessage,request sent date:%@, request received date: %@, requestTransmissionTime:%ld milliseconds",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v65 = qword_101934898;
      id v66 = [v24 requestDate];
      uint64_t v67 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
      id v68 = [v24 requestTransmissionTime];
      *(_DWORD *)int v89 = 138412802;
      *(void *)&v89[4] = v66;
      *(_WORD *)&v89[12] = 2112;
      *(void *)&v89[14] = v67;
      *(_WORD *)&v89[22] = 2048;
      uint64_t v90 = (uint64_t)v68;
      LODWORD(v79) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v65,  0LL,  "#EED2,handleAPNSMessage,request sent date:%@, request received date: %@, requestTransmissionTime:%ld milliseconds",  v89,  v79);
      double v70 = (char *)v69;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v69);
      if (v70 != buf) {
        free(v70);
      }
    }

    if (sub_10077AAFC(a1, v24))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v33 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessage,duplicate request, add to fRequestsHandled queue and early return",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)int v89 = 0;
        LODWORD(v79) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,handleAPNSMessage,duplicate request, add to fRequestsHandled queue and early return",  v89,  v79);
        double v72 = (char *)v71;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v71);
        if (v72 != buf) {
          free(v72);
        }
      }

      if ([v24 type] == (id)1) {
        uint64_t v34 = 13LL;
      }
      else {
        uint64_t v34 = 9LL;
      }
      [v24 setState:v34];
      [*(id *)(a1 + 1896) addObject:v24];
      sub_10076ACC0(a1);
      sub_10076BCF8(a1);
      sub_1007745E0(a1);
      goto LABEL_70;
    }

    uint64_t v39 = sub_10077516C(a1);
    *(void *)int v89 = 0LL;
    *(void *)&v89[8] = v89;
    *(void *)&v89[16] = 0x2020000000LL;
    LOBYTE(v9sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    v80[0] = _NSConcreteStackBlock;
    v80[1] = 3221225472LL;
    v80[2] = sub_10077BC98;
    v80[3] = &unk_10184DE70;
    v80[4] = v24;
    v80[5] = v89;
    -[NSArray enumerateObjectsUsingBlock:](v39, "enumerateObjectsUsingBlock:", v80);
    if (*(_BYTE *)(*(void *)&v89[8] + 24LL))
    {
      if (!v81)
      {
        [*(id *)(a1 + 1888) addObject:v24];
        [*(id *)(a1 + 1848) notifyNewRequestAvailable];
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        id v40 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          id v41 = [*(id *)(a1 + 1888) count];
          *(_DWORD *)uint64_t buf = 134217984;
          *(void *)&uint8_t buf[4] = v41;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessage,CLEEDRequestTypeStreaming added to pending queue and client is notified. Queue size:%ld",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v42 = qword_101934898;
          id v43 = [*(id *)(a1 + 1888) count];
          int v87 = 134217984;
          uint64_t v88 = (uint64_t)v43;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v42,  0LL,  "#EED2,handleAPNSMessage,CLEEDRequestTypeStreaming added to pending queue and client is notified. Queue size:%ld",  &v87);
          id v45 = (char *)v44;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessage()", "%s\n", v44);
          if (v45 != buf) {
            free(v45);
          }
        }

void sub_10076E6CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, char a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

void sub_10076E7E0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1937))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,processControlDataResponseEvent,fControlDataSendPending,sendControlData",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v15) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,processControlDataResponseEvent,fControlDataSendPending,sendControlData",  &v15,  2);
      uint64_t v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleControlDataResponseEvent()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    sub_10076ACC0(a1);
    *(_WORD *)(a1 + 1937) = 0;
    goto LABEL_8;
  }

  if (!*(_BYTE *)(a1 + 1938))
  {
LABEL_8:
    *(_DWORD *)(a1 + 194sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    return;
  }

  if (*(int *)(a1 + 1940) > 2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v6 = *(_DWORD *)(a1 + 1940) + 1;
      *(_DWORD *)uint64_t buf = 67109376;
      int v20 = v6;
      __int16 v21 = 1024;
      int v22 = 3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2,processControlDataResponseEvent,fControlDataSendFailed,fControlDataSendRetryCount:%d,kEEDControlDataSendMa xRetry:%d. Not reattempting.",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v12 = *(_DWORD *)(a1 + 1940) + 1;
      int v15 = 67109376;
      int v16 = v12;
      __int16 v17 = 1024;
      int v18 = 3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,processControlDataResponseEvent,fControlDataSendFailed,fControlDataSendRetryCount:%d,kEEDControlDataSendMa xRetry:%d. Not reattempting.",  &v15,  14);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleControlDataResponseEvent()", "%s\n", v13);
      if (v14 != buf) {
        free(v14);
      }
    }

    *(_DWORD *)(a1 + 194sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
    *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 0;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    BOOL v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *(_DWORD *)(a1 + 1940);
      *(_DWORD *)uint64_t buf = 67109376;
      int v20 = v4;
      __int16 v21 = 1024;
      int v22 = 3;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#EED2,processControlDataResponseEvent,fControlDataSendFailed,fControlDataSendRetryCount:%d,kEEDControlDataSendMa xRetry:%d,attempt sendControlData",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v9 = *(_DWORD *)(a1 + 1940);
      int v15 = 67109376;
      int v16 = v9;
      __int16 v17 = 1024;
      int v18 = 3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,processControlDataResponseEvent,fControlDataSendFailed,fControlDataSendRetryCount:%d,kEEDControlDataSendMa xRetry:%d,attempt sendControlData",  &v15,  14);
      uint64_t v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleControlDataResponseEvent()", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    ++*(_DWORD *)(a1 + 1940);
    sub_10076ACC0(a1);
    *(_BYTE *)(a1 + 1937) = 0;
  }

void sub_10076ECA8(uint64_t a1)
{
  if (*(void *)(a1 + 1984))
  {
    uint64_t v2 = sub_1002F8DDC();
    sub_1002AB3DC(v2);
    uint64_t v3 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v3 + 944LL))(v3);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 1984);
      *(_DWORD *)uint64_t buf = 138412290;
      uint64_t v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeCoexMetricDataToCache,stored the Co-ex metric dictionary to cache:%@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v6 = *(void *)(a1 + 1984);
      LODWORD(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 138412290;
      *(void *)((char *)&v10 + 4) = v6;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeCoexMetricDataToCache,stored the Co-ex metric dictionary to cache:%@",  &v10,  12,  v10);
LABEL_19:
      int v9 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeCoexMetricDataToCache()", "%s\n", v7);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeCoexMetricDataToCache, coexMetricDict nil",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeCoexMetricDataToCache, coexMetricDict nil",  &v10,  2,  v10);
      goto LABEL_19;
    }
  }

void sub_10076EF58(uint64_t a1)
{
  if (sub_100779E5C(a1))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessageInExtendedSession,Received request when not in emergency call. reject the request and inform partner",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,handleAPNSMessageInExtendedSession,Received request when not in emergency call. reject the request and inform partner",  v10,  2);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessageInExtendedSession()", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    sub_10077A6A0(a1, 14LL);
    uint64_t v3 = (void *)(a1 + 1832);
    int v4 = *(void **)(a1 + 1832);
    goto LABEL_15;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessageInExtendedSession,canHandleAPNSMessage retuns false, reject  APNS message and early return",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v10[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessageInExtendedSession,canHandleAPNSMessage retuns false, reject  APNS message and early return",  v10,  2);
    int v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::handleAPNSMessageInExtendedSession()", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  int v4 = *(void **)(a1 + 1832);
  if (v4)
  {
    uint64_t v3 = (void *)(a1 + 1832);
LABEL_15:

    void *v3 = 0LL;
  }

void sub_10076F240(uint64_t a1, id *a2)
{
  if (*a2)
  {
    if ([*a2 state] == (id)4) {
      [*a2 setState:2];
    }
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*a2 type];
      id v6 = [*a2 state];
      *(_DWORD *)uint64_t buf = 134349312;
      id v17 = v5;
      __int16 v18 = 2050;
      id v19 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,moveCurrentRequestToHandledQueueOnCallEnd,requestType:%{public}ld,requestState:%{public}ld",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v7 = qword_101934898;
      id v8 = [*a2 type];
      id v9 = [*a2 state];
      int v12 = 134349312;
      id v13 = v8;
      __int16 v14 = 2050;
      id v15 = v9;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  0LL,  "#EED2,moveCurrentRequestToHandledQueueOnCallEnd,requestType:%{public}ld,requestState:%{public}ld",  &v12,  22);
      uint64_t v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::moveCurrentRequestToHandledQueueOnCallEnd(CLEEDRequest **)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    [*(id *)(a1 + 1896) addObject:*a2];

    *a2 = 0LL;
  }

void sub_10076F470(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 1960);
  if (v1)
  {

    *(void *)(a1 + 196sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0LL;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#EED2CX cleanupOnEmergencyCallEnd,fEEDCoexMitigation cleared",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v6[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2CX cleanupOnEmergencyCallEnd,fEEDCoexMitigation cleared",  v6,  2);
      id v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::cleanupCoexMonitor()", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

id sub_10076F608(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,submitEED2RequestDataToCA,entered",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v37) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,submitEED2RequestDataToCA,entered",  &v37,  2);
    id v30 = (char *)v29;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::submitEED2RequestDataToCA()", "%s\n", v29);
    if (v30 != buf) {
      free(v30);
    }
  }

  id obj = sub_10076FD98((void *)a1);
  uint64_t v3 = obj;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  id result = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
  id v5 = result;
  if (result)
  {
    uint64_t v33 = *(void *)v41;
    do
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v41 != v33) {
          objc_enumerationMutation(obj);
        }
        uint64_t v7 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)v6);
        id v8 = (char *)objc_msgSend(objc_msgSend(v7, "partnerID"), "UTF8String");
        *(_DWORD *)uint64_t buf = 209;
        sub_1010DDBC0(&buf[8], v8);
        int v46 = 6;
        id v9 = (char *)objc_msgSend(objc_msgSend(v7, "psapID"), "UTF8String");
        int v47 = 210;
        sub_1010DDBC0(v48, v9);
        int v49 = 6;
        __int128 v10 = (char *)objc_msgSend(objc_msgSend(v7, "geofenceID"), "UTF8String");
        int v50 = 211;
        sub_1010DDBC0(v51, v10);
        int v52 = 6;
        unsigned int v11 = [v7 type];
        int v53 = 212;
        unsigned int v54 = v11;
        int v55 = 0;
        unsigned int v12 = [v7 requestStatusAtFirstUserResponse];
        int v56 = 213;
        unsigned int v57 = v12;
        int v58 = 0;
        unsigned int v13 = [v7 state];
        int v59 = 214;
        unsigned int v60 = v13;
        int v61 = 0;
        [v7 requestReceivedTime];
        unsigned int v15 = vcvtpd_s64_f64(v14 - *(double *)(a1 + 168));
        int v62 = 215;
        unsigned int v63 = v15;
        int v64 = 0;
        [v7 receivedTimeToFirstUserResponse];
        int v65 = 216;
        unsigned int v66 = vcvtpd_s64_f64(v16);
        int v67 = 0;
        [v7 receivedTimeToAcceptTime];
        int v68 = 217;
        unsigned int v69 = vcvtpd_s64_f64(v17);
        int v70 = 0;
        unsigned int v18 = [v7 numMediaSelectIterations];
        int v71 = 218;
        unsigned int v72 = v18;
        int v73 = 0;
        unsigned int v19 = [v7 requestTransmissionTime];
        int v74 = 219;
        unsigned int v75 = v19;
        int v76 = 0;
        id v38 = 0LL;
        uint64_t v39 = 0LL;
        double v37 = 0LL;
        *(void *)__int16 v78 = &v37;
        v78[8] = 0;
        double v37 = (char *)operator new(0x1B8uLL);
        id v38 = v37;
        uint64_t v39 = v37 + 440;
        id v38 = (_BYTE *)sub_100783D5C((uint64_t)&v39, (uint64_t)buf, (uint64_t)&v77, (uint64_t)v37);
        for (uint64_t i = 408LL; i != -32; i -= 40LL)
          sub_10043AFF4((uint64_t)&buf[i]);
        __int16 v21 = *(void **)(a1 + 2048);
        memset(v36, 0, sizeof(v36));
        sub_10043BC44(v36, (uint64_t)v37, (uint64_t)v38, 0xCCCCCCCCCCCCCCCDLL * ((v38 - v37) >> 3));
        [v21 setMeasurements:sub_100435878(v36)];
        *(void *)uint64_t buf = v36;
        sub_10043B844((void ***)buf);
        int v22 = *(void **)(a1 + 2048);
        if (byte_1019A175F < 0)
        {
          sub_1010DD48C(__p, (void *)xmmword_1019A1748, *((unint64_t *)&xmmword_1019A1748 + 1));
        }

        else
        {
          *(_OWORD *)std::string __p = xmmword_1019A1748;
          uint64_t v35 = unk_1019A1758;
        }

        [v22 submitEvent:sub_1007793B4((__int128 *)__p)];
        if (SHIBYTE(v35) < 0) {
          operator delete(__p[0]);
        }
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v23 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          id v24 = [v7 ID];
          *(_DWORD *)uint64_t buf = 138412290;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#EED2,submitEED2RequestDataToCA,metric submitted for request:%@",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v25 = qword_101934898;
          id v26 = [v7 ID];
          *(_DWORD *)__int16 v78 = 138412290;
          *(void *)&v78[4] = v26;
          LODWORD(v31) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  0LL,  "#EED2,submitEED2RequestDataToCA,metric submitted for request:%@",  v78,  v31);
          double v28 = (char *)v27;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::submitEED2RequestDataToCA()", "%s\n", v27);
          if (v28 != buf) {
            free(v28);
          }
        }

        *(void *)uint64_t buf = &v37;
        sub_10043B844((void ***)buf);
        id v6 = (char *)v6 + 1;
      }

      while (v6 != v5);
      id result = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
      id v5 = result;
    }

    while (result);
  }

  return result;
}

void sub_10076FC6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a63 = (uint64_t)&a35;
  sub_10043B844((void ***)&a63);
  _Unwind_Resume(a1);
}

NSMutableArray *sub_10076FD98(void *a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v3 = v2;
  if (a1[238]) {
    -[NSMutableArray addObject:](v2, "addObject:");
  }
  if (a1[239]) {
    -[NSMutableArray addObject:](v3, "addObject:");
  }
  int v4 = (void *)a1[236];
  if (v4 && [v4 count]) {
    -[NSMutableArray addObjectsFromArray:](v3, "addObjectsFromArray:", a1[236]);
  }
  id v5 = (void *)a1[237];
  if (v5 && [v5 count]) {
    -[NSMutableArray addObjectsFromArray:](v3, "addObjectsFromArray:", a1[237]);
  }
  if (-[NSMutableArray count](v3, "count"))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134349056;
      id v17 = -[NSMutableArray count](v3, "count");
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EED2,createEEDRequestsList,created list with %{public}ld requests",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v7 = qword_101934898;
      int v14 = 134349056;
      id v15 = -[NSMutableArray count](v3, "count");
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  0LL,  "#EED2,createEEDRequestsList,created list with %{public}ld requests",  &v14,  12);
      id v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSArray<CLEEDRequest *> *CLEmergencyEED2::createEEDRequestsList()",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int128 v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2,createEEDRequestsList,no eed Requests",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v14) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,createEEDRequestsList,no eed Requests",  &v14,  2);
      unsigned int v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSArray<CLEEDRequest *> *CLEmergencyEED2::createEEDRequestsList()",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    return 0LL;
  }

  return v3;
}

BOOL sub_1007700F8(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v11[0] = kSecAttrLabel;
  v11[1] = kSecClass;
  v12[0] = a2;
  v12[1] = kSecClassKey;
  _DWORD v11[2] = kSecUseSystemKeychain;
  void v11[3] = kSecAttrIsPermanent;
  _DWORD v12[2] = &__kCFBooleanTrue;
  void v12[3] = &__kCFBooleanTrue;
  _DWORD v11[4] = kSecReturnRef;
  _DWORD v12[4] = &__kCFBooleanTrue;
  OSStatus v3 = SecItemCopyMatching( (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  5LL),  a3);
  if (v3)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EED2,#Sec,failed to copy key from keychain,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v8[0] = 67240192;
      v8[1] = v3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,#Sec,failed to copy key from keychain,response,%{public}d",  v8,  8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::copyCachedKey(NSString *, SecKeyRef *)", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  return v3 == 0;
}

BOOL sub_100770338(uint64_t a1, uint64_t a2)
{
  v10[0] = kSecAttrLabel;
  v10[1] = kSecClass;
  v11[0] = a2;
  v11[1] = kSecClassKey;
  v10[2] = kSecUseSystemKeychain;
  v10[3] = kSecAttrIsPermanent;
  _DWORD v11[2] = &__kCFBooleanTrue;
  void v11[3] = &__kCFBooleanTrue;
  OSStatus v2 = SecItemDelete((CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v11,  v10,  4LL));
  if (v2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    OSStatus v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v9 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "#EED2,#Sec,failed to delete key from keychain,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v7[0] = 67240192;
      v7[1] = v2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,#Sec,failed to delete key from keychain,response,%{public}d",  v7,  8);
      id v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::deleteCachedKey(NSString *)", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  return v2 == 0;
}

BOOL sub_10077055C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = kSecAttrLabel;
  v12[1] = kSecClass;
  v13[0] = a2;
  v13[1] = kSecClassKey;
  _DWORD v12[2] = kSecUseSystemKeychain;
  void v12[3] = kSecAttrIsPermanent;
  _OWORD v13[2] = &__kCFBooleanTrue;
  void v13[3] = &__kCFBooleanTrue;
  _DWORD v12[4] = kSecValueRef;
  void v12[5] = kSecAttrAccessible;
  v13[4] = a4;
  void v13[5] = a3;
  OSStatus v4 = SecItemAdd( (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v13,  v12,  6LL),  0LL);
  if (v4)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v11 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2,#Sec,failed to add key to keychain,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v9[0] = 67240192;
      v9[1] = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#Sec,failed to add key to keychain,response,%{public}d",  v9,  8);
      id v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::cacheKey(NSString *, NSString *, SecKeyRef)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  return v4 == 0;
}

BOOL sub_1007707A4(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v11[0] = kSecAttrLabel;
  v11[1] = kSecClass;
  v12[0] = a2;
  v12[1] = kSecClassCertificate;
  _DWORD v11[2] = kSecUseSystemKeychain;
  void v11[3] = kSecReturnRef;
  _DWORD v12[2] = &__kCFBooleanTrue;
  void v12[3] = &__kCFBooleanTrue;
  OSStatus v3 = SecItemCopyMatching( (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  4LL),  a3);
  if (v3)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    OSStatus v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#EED2,#Sec,failed to copy cert from keychain,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v8[0] = 67240192;
      v8[1] = v3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,#Sec,failed to copy cert from keychain,response,%{public}d",  v8,  8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::copyCachedCert(NSString *, SecCertificateRef *)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  return v3 == 0;
}

BOOL sub_1007709D0(uint64_t a1, uint64_t a2)
{
  v10[0] = kSecAttrLabel;
  v10[1] = kSecClass;
  v11[0] = a2;
  v11[1] = kSecClassCertificate;
  v10[2] = kSecUseSystemKeychain;
  _DWORD v11[2] = &__kCFBooleanTrue;
  OSStatus v2 = SecItemDelete((CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v11,  v10,  3LL));
  if (v2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    OSStatus v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v9 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "#EED2,#Sec,failed to delete cert,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v7[0] = 67240192;
      v7[1] = v2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,#Sec,failed to delete cert,response,%{public}d",  v7,  8);
      id v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::deleteCachedCert(NSString *)", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  return v2 == 0;
}

BOOL sub_100770BE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = kSecAttrLabel;
  v12[1] = kSecClass;
  v13[0] = a2;
  v13[1] = kSecClassCertificate;
  _DWORD v12[2] = kSecUseSystemKeychain;
  void v12[3] = kSecValueRef;
  _OWORD v13[2] = &__kCFBooleanTrue;
  void v13[3] = a4;
  void v12[4] = kSecAttrAccessible;
  v13[4] = a3;
  OSStatus v4 = SecItemAdd( (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v13,  v12,  5LL),  0LL);
  if (v4)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      OSStatus v11 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2,#Sec,failed to add cert to keychain,response,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v9[0] = 67240192;
      v9[1] = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#Sec,failed to add cert to keychain,response,%{public}d",  v9,  8);
      id v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::cacheCert(NSString *, NSString *, SecCertificateRef)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  return v4 == 0;
}

void sub_100770E24(void *a1)
{
  int v2 = sub_1007718B4(a1);
  double v3 = 0.0;
  double v4 = 0.0;
  if (v2)
  {
    double v4 = SecCertificateNotValidBefore(a1[211]);
    double v3 = SecCertificateNotValidAfter(a1[211]);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1[213];
    v7[0] = 68290050;
    __int16 v8 = 2082;
    v7[1] = 0;
    OSStatus v9 = "";
    __int16 v10 = 1026;
    int v11 = v2;
    __int16 v12 = 2050;
    double v13 = v4;
    __int16 v14 = 2050;
    double v15 = v3;
    __int16 v16 = 2050;
    uint64_t v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,#BAA,current BAA info, cert valid:%{public}hhd, cert validity begins:%{pu blic}.1f, cert validity ends:%{public}.1f, next cert request:%{public}.1f}",  (uint8_t *)v7,  0x36u);
  }

void sub_100770F64(void *a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#EED2,#BAA,writing info to disk", buf, 2u);
  }

  uint64_t v3 = sub_1002921D0(115, 2);
  if ((_DWORD)v3)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v33[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,writing info to disk",  v33,  2);
    unsigned int v19 = (uint8_t *)v18;
    uint64_t v3 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v18);
    if (v19 != buf) {
      free(v19);
    }
  }

  if (a1[210] && a1[211] && a1[212])
  {
    uint64_t v4 = sub_100770338(v3, (uint64_t)@"com.apple.locationd.BAA.key");
    if ((v4 & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA private key",  buf,  2u);
      }

      uint64_t v4 = sub_1002921D0(115, 2);
      if ((_DWORD)v4)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA private key",  v33,  v32);
        __int16 v21 = (uint8_t *)v20;
        uint64_t v4 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v20);
        if (v21 != buf) {
          free(v21);
        }
      }
    }

    uint64_t v6 = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    uint64_t v7 = sub_10077055C( v4,  (uint64_t)@"com.apple.locationd.BAA.key",  kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate,  a1[210]);
    if ((v7 & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#EED2,#BAA,failed to add BAA private key to keychain",  buf,  2u);
      }

      uint64_t v7 = sub_1002921D0(115, 0);
      if ((_DWORD)v7)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#BAA,failed to add BAA private key to keychain",  v33,  v32);
        unsigned int v23 = (uint8_t *)v22;
        uint64_t v7 = sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v22);
        if (v23 != buf) {
          free(v23);
        }
      }
    }

    uint64_t v9 = sub_1007709D0(v7, (uint64_t)@"com.apple.locationd.BAA.leafCert");
    if ((v9 & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA leaf cert",  buf,  2u);
      }

      uint64_t v9 = sub_1002921D0(115, 2);
      if ((_DWORD)v9)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA leaf cert",  v33,  v32);
        uint64_t v25 = (uint8_t *)v24;
        uint64_t v9 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v24);
        if (v25 != buf) {
          free(v25);
        }
      }
    }

    uint64_t v11 = sub_100770BE8(v9, (uint64_t)@"com.apple.locationd.BAA.leafCert", v6, a1[211]);
    if ((v11 & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v12 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#EED2,#BAA,failed to add BAA leaf cert to keychain",  buf,  2u);
      }

      uint64_t v11 = sub_1002921D0(115, 0);
      if ((_DWORD)v11)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#BAA,failed to add BAA leaf cert to keychain",  v33,  v32);
        id v27 = (uint8_t *)v26;
        uint64_t v11 = sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v26);
        if (v27 != buf) {
          free(v27);
        }
      }
    }

    uint64_t v13 = sub_1007709D0(v11, (uint64_t)@"com.apple.locationd.BAA.intCert");
    if ((v13 & 1) == 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v14 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unable to delete existing BAA intermediate cert",  buf,  2u);
      }

      uint64_t v13 = sub_1002921D0(115, 2);
      if ((_DWORD)v13)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unable to delete existing BAA intermediate cert",  v33,  v32);
        char v29 = (uint8_t *)v28;
        uint64_t v13 = sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v28);
        if (v29 != buf) {
          free(v29);
        }
      }
    }

    if (!sub_100770BE8(v13, (uint64_t)@"com.apple.locationd.BAA.intCert", v6, a1[212]))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      double v15 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#EED2,#BAA,failed to add BAA intermediate cert to keychain",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v33[0] = 0;
        LODWORD(v32) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#BAA,failed to add BAA intermediate cert to keychain",  v33,  v32);
        uint64_t v31 = (uint8_t *)v30;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::writeCachedBaaInfo()", "%s\n", v30);
        if (v31 != buf) {
          free(v31);
        }
      }
    }
  }

  uint64_t v16 = sub_1002F8DDC();
  sub_1002AC820(v16, @"BaaNextCertRequestTime", a1 + 213);
  uint64_t v17 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v17 + 944LL))(v17);
  sub_100770E24(a1);
}

uint64_t sub_1007718B4(void *a1)
{
  else {
    return 0LL;
  }
}

void *sub_100771920@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 4) {
    int v2 = "ReasonUnknown";
  }
  else {
    int v2 = off_10184E530[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

void sub_10077194C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1676))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v2 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,unregistering BAA cert request activity",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v5[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,unregistering BAA cert request activity",  v5,  2);
      uint64_t v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::unregisterBaaCertRequestActivity()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }

    xpc_activity_unregister((const char *)[@"com.apple.locationd.BAA" UTF8String]);
    *(_BYTE *)(a1 + 1676) = 0;
  }

BOOL sub_100771AF8(uint64_t a1, int a2)
{
  double v4 = *(double *)(a1 + 1704);
  double Current = CFAbsoluteTimeGetCurrent();
  int v6 = sub_1007718B4((void *)a1);
  char v7 = v6;
  double v8 = 0.0;
  double v9 = 0.0;
  if (v6)
  {
    double v9 = SecCertificateNotValidBefore(*(void *)(a1 + 1688));
    double v8 = SecCertificateNotValidAfter(*(void *)(a1 + 1688));
  }

  __int16 v10 = (int *)sub_1007573F4((int *)(a1 + 1448));
  int v11 = v10[102];
  int v12 = v10[103];
  int v13 = v10[104];
  switch(a2)
  {
    case 0:
    case 1:
      double v14 = *(double *)(a1 + 1704);
      if ((v7 & 1) != 0)
      {
        double v15 = v9 + (double)v12;
        if (v14 < v15 || v14 > v9 + (double)v13)
        {
          double v17 = v15 + (double)(v13 - v12) * ((double)arc4random() / 4294967300.0);
          goto LABEL_24;
        }

        double v17 = Current;
        if (Current > v14) {
          goto LABEL_24;
        }
        goto LABEL_25;
      }

      double v24 = (double)v10[101];
      if (v14 == 0.0 || v14 > Current + v24) {
        goto LABEL_37;
      }
      if (Current > v14) {
        goto LABEL_39;
      }
      goto LABEL_40;
    case 2:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unsigned int v18 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "#EED2,#BAA,shouldn't be checking next cert request time during SessionStart",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v32[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#BAA,shouldn't be checking next cert request time during SessionStart",  v32,  2);
        int v20 = (uint8_t *)v19;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyEED2::checkNextCertRequestTime(CertRequestStatusCheckReason)",  "%s\n",  v19);
        if (v20 != buf) {
          free(v20);
        }
      }

      goto LABEL_20;
    case 3:
      *(double *)(a1 + 1704) = v9 + (double)v12 + (double)(v13 - v12) * ((double)arc4random() / 4294967300.0);
      goto LABEL_20;
    case 4:
      int v21 = v10[105];
      double v22 = (double)arc4random() / 4294967300.0;
      if ((v7 & 1) == 0)
      {
        double Current = Current + (double)v11 * v22;
        goto LABEL_39;
      }

      double v17 = Current + (double)v21 * v22;
LABEL_24:
      *(double *)(a1 + 1704) = v17;
      double v14 = v17;
LABEL_25:
      if (v14 > v8)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        unsigned int v23 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2,#BAA,next cert request time places us beyond expiration of current cert so modifying",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          v32[0] = 0;
          LODWORD(v31) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2,#BAA,next cert request time places us beyond expiration of current cert so modifying",  v32,  v31);
          id v30 = (uint8_t *)v29;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::checkNextCertRequestTime(CertRequestStatusCheckReason)",  "%s\n",  v29);
          if (v30 != buf) {
            free(v30);
          }
        }

        double v14 = (Current + v8) * 0.5;
        *(double *)(a1 + 1704) = v14;
        double v24 = (double)v11;
        if (v14 - Current < (double)v11)
        {
LABEL_37:
          double Current = Current + v24 * ((double)arc4random() / 4294967300.0);
LABEL_39:
          *(double *)(a1 + 1704) = Current;
          double v14 = Current;
        }
      }

void sub_1007720E8(uint64_t a1)
{
  if ((sub_100756950(a1 + 1448) & 1) != 0)
  {
    double v2 = *(double *)(a1 + 1704);
    double Current = CFAbsoluteTimeGetCurrent();
    sub_1002F0B04(buf);
    else {
      int64_t v4 = 600LL;
    }
    id v5 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      int v6 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    xpc_object_t v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REPEATING, 0);
    xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_ALLOW_BATTERY, 1);
    xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY, 1);
    xpc_dictionary_set_string( v8,  XPC_ACTIVITY_NETWORK_TRANSFER_DIRECTION,  XPC_ACTIVITY_NETWORK_TRANSFER_DIRECTION_DOWNLOAD);
    xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REQUIRE_INEXPENSIVE_NETWORK_CONNECTIVITY, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_DELAY, (uint64_t)(v2 - Current) & ~((uint64_t)(v2 - Current) >> 63));
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_GRACE_PERIOD, v4);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    double v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134349312;
      *(void *)&uint8_t buf[4] = (uint64_t)(v2 - Current) & ~((uint64_t)(v2 - Current) >> 63);
      *(_WORD *)&_BYTE buf[12] = 2050;
      *(void *)&buf[14] = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,registering BAA cert request activity,delay,%{public}lld,gracePeriod,%{public}lld",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_DWORD *)uint64_t v16 = 134349312;
      *(void *)&_DWORD v16[4] = (uint64_t)(v2 - Current) & ~((uint64_t)(v2 - Current) >> 63);
      __int16 v17 = 2050;
      int64_t v18 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,registering BAA cert request activity,delay,%{public}lld,gracePeriod,%{public}lld",  v16,  22);
      int v12 = (char *)v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::registerBaaCertRequestActivity()", "%s\n", v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    *(_BYTE *)(a1 + 1676) = 1;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1007725CC;
    handler[3] = &unk_10184DDE0;
    handler[4] = a1;
    xpc_activity_register((const char *)[@"com.apple.locationd.BAA" UTF8String], v8, handler);
    xpc_release(v8);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int16 v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#EED2,#BAA,requesting of BAA certs not allowed by config,not starting XPC activity",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)uint64_t v16 = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,#BAA,requesting of BAA certs not allowed by config,not starting XPC activity",  v16,  2);
      double v14 = (char *)v13;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::registerBaaCertRequestActivity()", "%s\n", v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

void sub_1007725B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1007725CC(uint64_t a1, xpc_activity_t activity)
{
  uint64_t v2 = *(void *)(a1 + 32);
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state == 2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,cert request activity handler triggered",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v13[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,cert request activity handler triggered",  v13,  2);
      double v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::registerBaaCertRequestActivity()_block_invoke",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    id v5 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(v2 + 8), "silo"), "queue");
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1007728F8;
    block[3] = &unk_10181D3D0;
    void block[4] = v2;
    dispatch_async(v5, block);
  }

  else
  {
    int v6 = state;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67240192;
      int v15 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#EED2,#BAA,cert request activity handler triggered with unexpected state %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      v13[0] = 67240192;
      v13[1] = v6;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,#BAA,cert request activity handler triggered with unexpected state %{public}d",  v13,  8);
      int v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::registerBaaCertRequestActivity()_block_invoke",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

uint64_t sub_1007728F8(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 1676LL) = 0;
  return result;
}

void sub_100772904(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0LL) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0LL) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  BOOL v6 = v5 == 0;
  if (v5) {
    int v7 = 3;
  }
  else {
    int v7 = 1;
  }
  if (v6 || v4 == 0) {
    int v9 = 2;
  }
  else {
    int v9 = 4;
  }
  if (v4) {
    int v10 = v9;
  }
  else {
    int v10 = v7;
  }
  LODWORD(v17) = 31;
  v18[0] = v10;
  v18[6] = 0;
  double v14 = 0LL;
  v15[0] = 0LL;
  int v13 = 0LL;
  v15[1] = &v13;
  char v16 = 0;
  int v13 = (char *)operator new(0x28uLL);
  double v14 = v13;
  v15[0] = v13 + 40;
  double v14 = (_BYTE *)sub_100783D5C((uint64_t)v15, (uint64_t)&v17, (uint64_t)&v19, (uint64_t)v13);
  sub_10043AFF4((uint64_t)v18);
  int v11 = *(void **)(a1 + 2048);
  memset(v12, 0, sizeof(v12));
  sub_10043BC44(v12, (uint64_t)v13, (uint64_t)v14, 0xCCCCCCCCCCCCCCCDLL * ((v14 - v13) >> 3));
  [v11 setMeasurements:sub_100435878(v12)];
  __int16 v17 = (void **)v12;
  sub_10043B844(&v17);
  __int16 v17 = (void **)&v13;
  sub_10043B844(&v17);
}

void sub_100772A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a12;
  sub_10043B844(&a17);
  _Unwind_Resume(a1);
}

void sub_100772ACC(uint64_t a1, int a2, uint64_t *a3)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1) & 1) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 104);
    if (!v6) {
      sub_100008BDC();
    }
    (*(void (**)(void *__return_ptr))(*(void *)v6 + 48LL))(v47);
    sub_100F9EFB4(a1, (uint64_t)v47);
    if (sub_100869780((uint64_t)v47))
    {
      ++*(_DWORD *)(a1 + 412);
      uint64_t v7 = *(void *)(a1 + 2040);
      if (v7) {
        ++*(_DWORD *)(v7 + 8);
      }
      xpc_object_t v8 = sub_1007732CC((uint64_t)v47);
      int v9 = sub_1007736F8(a1, a3);
      -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v8, @"location");

      int v10 = sub_1007739B4(a1);
      -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v10, @"internal");

      if (*(void *)(a1 + 1664))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v11 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = a2 ? "Companion" : "Native";
          sub_1010DDBC0(__p, v12);
          int v13 = v58 >= 0 ? __p : (void **)__p[0];
          int v14 = *(_DWORD *)(a1 + 1672);
          *(_DWORD *)uint64_t buf = 136446466;
          *(void *)&uint8_t buf[4] = v13;
          __int16 v50 = 1026;
          int v51 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#EED2 POSTing LIS data for %{public}s number message %{public}d",  buf,  0x12u);
          if (v58 < 0) {
            operator delete(__p[0]);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v39 = qword_101934898;
          if (a2) {
            __int128 v40 = "Companion";
          }
          else {
            __int128 v40 = "Native";
          }
          sub_1010DDBC0(buf, v40);
          if (v52 >= 0) {
            __int128 v41 = buf;
          }
          else {
            __int128 v41 = *(_BYTE **)buf;
          }
          int v42 = *(_DWORD *)(a1 + 1672);
          int v53 = 136446466;
          unsigned int v54 = v41;
          __int16 v55 = 1026;
          int v56 = v42;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v39,  0LL,  "#EED2 POSTing LIS data for %{public}s number message %{public}d",  &v53,  18);
          id v44 = v43;
          if (v52 < 0) {
            operator delete(*(void **)buf);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::sendLocation(NumberType, const std::string &)",  "%s\n",  v44);
        }

        sub_100773F2C(a1, a2, (uint64_t)v9, (uint64_t)v47);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        char v29 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "#EED2 can't POST message due to invalid URL session",  (uint8_t *)__p,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          *(_WORD *)uint64_t buf = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 can't POST message due to invalid URL session",  buf,  2);
          int v46 = (void **)v45;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::sendLocation(NumberType, const std::string &)",  "%s\n",  v45);
          if (v46 != __p) {
            free(v46);
          }
        }

        uint64_t v30 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 3LL);
        uint64_t v31 = *(void *)(a1 + 2040);
        if (v31)
        {
          unsigned int v32 = sub_100778A88(v30, *(_DWORD *)(v31 + 24));
          int v33 = *(_DWORD *)(v31 + 24);
          if (v32 >= 2) {
            int v33 = 2;
          }
          *(_DWORD *)(v31 + sub_10000AE14(v9 + 24) = v33;
        }
      }

      sub_1007745E0(a1);
    }

    else
    {
      ++*(_DWORD *)(a1 + 416);
      uint64_t v22 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 2LL);
      uint64_t v23 = *(void *)(a1 + 2040);
      if (v23)
      {
        ++*(_DWORD *)(v23 + 12);
        unsigned int v24 = sub_100778A88(v22, *(_DWORD *)(v23 + 24));
        int v25 = *(_DWORD *)(v23 + 24);
        if (v24 >= 5) {
          int v25 = 1;
        }
        *(_DWORD *)(v23 + sub_10000AE14(v9 + 24) = v25;
      }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v26 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "#EED2 no fix available to send in LIS payload, not sending",  (uint8_t *)__p,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        *(_WORD *)uint64_t buf = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 no fix available to send in LIS payload, not sending",  buf,  2);
        double v28 = (void **)v27;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::sendLocation(NumberType, const std::string &)",  "%s\n",  v27);
        if (v28 != __p) {
          free(v28);
        }
      }
    }

    uint64_t v34 = v48;
    if (v48)
    {
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v36 = __ldaxr(p_shared_owners);
      while (__stlxr(v36 - 1, p_shared_owners));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v15 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "#EED2 attempted to send location when not enabled",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v47[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#EED2 attempted to send location when not enabled",  v47,  2);
      id v38 = (void **)v37;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::sendLocation(NumberType, const std::string &)",  "%s\n",  v37);
      if (v38 != __p) {
        free(v38);
      }
    }

    uint64_t v16 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 12LL);
    uint64_t v17 = *(void *)(a1 + 2040);
    if (v17)
    {
      unsigned int v19 = *(_DWORD *)(v17 + 24);
      int64_t v18 = (int *)(v17 + 24);
      unsigned int v20 = sub_100778A88(v16, v19);
      int v21 = *v18;
      if (v20 >= 2) {
        int v21 = 4;
      }
      int *v18 = v21;
    }
  }

void sub_100773290(_Unwind_Exception *a1)
{
}

NSMutableDictionary *sub_1007732CC(uint64_t a1)
{
  if ((sub_100869780(a1) & 1) != 0)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    double v3 = *(double *)(a1 + 184);
    uint64_t v4 = (double *)sub_100869D50();
    uint64_t v5 = (double *)(a1 + 76);
    if (v3 != v4[3]) {
      uint64_t v5 = (double *)(a1 + 184);
    }
    -[NSDate timeIntervalSince1970]( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *v5),  "timeIntervalSince1970");
    unint64_t v7 = llround(v6);
    -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v7),  @"timestamp");
    double v8 = round(*(double *)(a1 + 4) * 100000.0) / 100000.0;
    double v9 = round(*(double *)(a1 + 12) * 100000.0) / 100000.0;
    -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v8),  @"latitude");
    -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v9),  @"longitude");
    sub_100F993A0(a1, v17, &v16);
    v17[0] = round(v17[0] * 10.0) / 10.0;
    -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"),  @"hunc");
    double v10 = 0.0;
    if (sub_100F99260(a1))
    {
      double v10 = round((*(double *)(a1 + 28) + *(float *)(a1 + 476)) * 10.0) / 10.0;
      double v16 = round(v16 * 10.0) / 10.0;
      -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v10),  @"altitude");
      -[NSMutableDictionary setValue:forKey:]( v2,  "setValue:forKey:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v16),  @"vunc");
    }

    -[NSMutableDictionary setValue:forKey:](v2, "setValue:forKey:", &off_1018D3920, @"confidence");
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v11 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68290563;
      int v19 = 0;
      __int16 v20 = 2082;
      int v21 = "";
      __int16 v22 = 2050;
      unint64_t v23 = v7;
      __int16 v24 = 2049;
      double v25 = v8;
      __int16 v26 = 2049;
      double v27 = v9;
      __int16 v28 = 2049;
      double v29 = v10;
      __int16 v30 = 2050;
      double v31 = v17[0];
      __int16 v32 = 2050;
      double v33 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2 created location dict, timestamp:%{public}lld, latitude:%{private}f, longitude:%{private}f, altitude (HAE):%{private}f, hunc:%{public}f, vunc:%{public}f}",  buf,  0x4Eu);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#EED2,location is not valid so not creating location dict",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v17[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,location is not valid so not creating location dict",  v17,  2);
      int v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static NSDictionary *CLEmergencyEED2::createLocationDict(const GNSS::DaemonLocation &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    return 0LL;
  }

  return v2;
}

NSMutableDictionary *sub_1007736F8(uint64_t a1, uint64_t *a2)
{
  double v5 = v4;
  sub_1010DDBC0(__p, off_10184E558[*(int *)(a1 + 132)]);
  double v6 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  else {
    unint64_t v7 = (uint64_t *)*a2;
  }
  -[NSMutableDictionary setValue:forKey:]( v6,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7),  @"call_ID");
  unint64_t v8 = llround(v5);
  -[NSMutableDictionary setValue:forKey:]( v6,  "setValue:forKey:",  +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v8),  @"session_start_time");
  if (v18 >= 0) {
    double v9 = __p;
  }
  else {
    double v9 = (void **)__p[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v6,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9),  @"medium");
  if (*(double *)(a1 + 1872) > 0.0)
  {
    -[NSDate timeIntervalSince1970]( +[NSDate dateWithTimeIntervalSinceReferenceDate:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceReferenceDate:"),  "timeIntervalSince1970");
    -[NSMutableDictionary setValue:forKey:]( v6,  "setValue:forKey:",  +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", llround(v10)),  @"session_end_time");
  }

  int v11 = sub_10077516C(a1);
  if (v11) {
    -[NSMutableDictionary setValue:forKey:](v6, "setValue:forKey:", v11, @"capabilities");
  }
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v12 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    else {
      int v13 = (uint64_t *)*a2;
    }
    int v14 = __p;
    if (v18 < 0) {
      int v14 = (void **)__p[0];
    }
    uint64_t v15 = *(void *)(a1 + 1872);
    *(_DWORD *)uint64_t buf = 68290307;
    int v20 = 0;
    __int16 v21 = 2082;
    __int16 v22 = "";
    __int16 v23 = 2081;
    __int16 v24 = v13;
    __int16 v25 = 2050;
    unint64_t v26 = v8;
    __int16 v27 = 2082;
    __int16 v28 = v14;
    __int16 v29 = 2050;
    uint64_t v30 = v15;
    __int16 v31 = 2114;
    __int16 v32 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2 created LIS dict, phone number:%{private, location:escape_only}s, session sta rt time:%{public}lld, medium:%{public, location:escape_only}s, Call End time Absolute:%{public}.1f, request capabilitites:%{public, location:escape_only}@}",  buf,  0x44u);
  }

  if (v18 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_100773988( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

NSMutableDictionary *sub_1007739B4(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 1448);
  *(_DWORD *)uint64_t buf = v2;
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    sub_100008BDC();
  }
  double v4 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v3 + 48LL))(v3, buf);
  double v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 1672)),  @"message_ID");
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 1448)),  @"sim");
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v4),  @"rat");
  sub_1010DDBC0(__p, "carrier");
  double v6 = sub_100757034(a1 + 1448, v2, (uint64_t *)__p);
  else {
    __uuid_t dst = *(std::string *)(v6 + 4);
  }
  if (v34 < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type size = __dst.__r_.__value_.__s.__size_;
  signed __int8 v8 = __dst.__r_.__value_.__s.__size_;
  if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    std::string::assign(&__dst, "Unavailable");
    signed __int8 v8 = __dst.__r_.__value_.__s.__size_;
  }

  if (v8 >= 0) {
    p_uuid_t dst = &__dst;
  }
  else {
    p_uuid_t dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_dst),  @"sim_bundle_id");
  sub_1010DDBC0(v30, "operator");
  double v10 = sub_100757034(a1 + 1448, v2, (uint64_t *)v30);
  else {
    std::string v32 = *(std::string *)(v10 + 4);
  }
  if (v31 < 0) {
    operator delete(v30[0]);
  }
  std::string::size_type v11 = v32.__r_.__value_.__s.__size_;
  signed __int8 v12 = v32.__r_.__value_.__s.__size_;
  if ((v32.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type v11 = v32.__r_.__value_.__l.__size_;
  }
  if (!v11)
  {
    std::string::assign(&v32, "Unavailable");
    signed __int8 v12 = v32.__r_.__value_.__s.__size_;
  }

  if (v12 >= 0) {
    int v13 = &v32;
  }
  else {
    int v13 = (std::string *)v32.__r_.__value_.__r.__words[0];
  }
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13),  @"operator_bundle_id");
  int v14 = (__CFString *)sub_100BF5BD8();
  -[NSMutableDictionary setValue:forKey:](v5, "setValue:forKey:", v14, @"sim_country");
  uint64_t v15 = (__CFString *)sub_100BF5BD8();
  -[NSMutableDictionary setValue:forKey:](v5, "setValue:forKey:", v15, @"operator_country");
  sub_1004F2598();
  sub_1004F6370((uint64_t)buf);
  if (v40 >= 0) {
    double v16 = buf;
  }
  else {
    double v16 = *(uint8_t **)buf;
  }
  uint64_t v17 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v16);
  if (SHIBYTE(v40) < 0) {
    operator delete(*(void **)buf);
  }
  -[NSMutableDictionary setValue:forKey:](v5, "setValue:forKey:", v17, @"product_type");
  sub_1004F2598();
  uint64_t v18 = sub_1004F5C4C();
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v18),  @"release_type");
  -[NSMutableDictionary setValue:forKey:]( v5,  "setValue:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_100BF294C(*(unsigned int *)(a1 + 1768))),  @"trigger_type");
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  int v19 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = *(_DWORD *)(a1 + 1672);
    LODWORD(v2_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 1448);
    HIDWORD(v2_Block_object_dispose(va, 8) = *v4;
    if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v21 = &__dst;
    }
    else {
      __int16 v21 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    id v22 = -[__CFString UTF8String](v14, "UTF8String", v28);
    if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v23 = &v32;
    }
    else {
      __int16 v23 = (std::string *)v32.__r_.__value_.__r.__words[0];
    }
    id v24 = -[__CFString UTF8String](v15, "UTF8String");
    __int16 v25 = -[NSString UTF8String](v17, "UTF8String");
    int v26 = *(_DWORD *)(a1 + 1768);
    *(_DWORD *)uint64_t buf = 68291587;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v37 = 2082;
    id v38 = "";
    __int16 v39 = 1026;
    int v40 = v20;
    __int16 v41 = 1026;
    int v42 = v29;
    __int16 v43 = 1026;
    int v44 = HIDWORD(v29);
    __int16 v45 = 2082;
    int v46 = v21;
    __int16 v47 = 2082;
    id v48 = v22;
    __int16 v49 = 2082;
    __int16 v50 = v23;
    __int16 v51 = 2082;
    id v52 = v24;
    __int16 v53 = 2081;
    unsigned int v54 = v25;
    __int16 v55 = 1026;
    int v56 = v18;
    __int16 v57 = 1026;
    int v58 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2 created internal dict, message_ID:%{public}d, sim:%{public}d, rat:%{pub lic}d, sim_bundle_id:%{public, location:escape_only}s, sim_country:%{public, location:escape_only}s, ope rator_bundle_id:%{public, location:escape_only}s, operator_country:%{public, location:escape_only}s, produ ct_type:%{private, location:escape_only}s, release_type:%{public}d, trigger_type:%{public}d}",  buf,  0x62u);
  }

  return v5;
}

void sub_100773E8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void sub_100773F2C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v85 = a2;
  double v6 = sub_100775488(a3);
  if (v6)
  {
    unint64_t v7 = v6;
    signed __int8 v8 = sub_100756E48((int *)(a1 + 1448));
    if (*((char *)v8 + 87) < 0)
    {
      sub_1010DD48C(&__p, (void *)v8[8], v8[9]);
    }

    else
    {
      __int128 __p = *((_OWORD *)v8 + 4);
      uint64_t v84 = v8[10];
    }

    if (v84 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = (__int128 *)__p;
    }
    std::string v82 = +[NSMutableURLRequest requestWithURL:]( &OBJC_CLASS___NSMutableURLRequest,  "requestWithURL:",  +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p)));
    -[NSMutableURLRequest setHTTPMethod:](v82, "setHTTPMethod:", @"POST");
    sub_1007757C8((__SecKey **)a1, v7, (id *)&v82);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v17 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = SHIBYTE(v84);
      int v19 = (__int128 *)__p;
      NSUInteger v20 = -[NSData length](v7, "length");
      __int16 v21 = &__p;
      *(_DWORD *)uint64_t buf = 68289539;
      if (v18 < 0) {
        __int16 v21 = v19;
      }
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v21;
      *(_WORD *)&_BYTE buf[28] = 2049;
      *(void *)&buf[30] = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,sending LIS POST, URL:%{private, location:escape_only}s, length:%{private}lld}",  buf,  0x26u);
    }

    *(void *)uint64_t buf = &v85;
    id v22 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v85, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
    __int16 v23 = v22;
    id v24 = (char *)v22[6];
    uint64_t v25 = (uint64_t)(v22 + 7);
    int v26 = v22[7];
    if (v24 >= (char *)v26)
    {
      uint64_t v28 = v22[5];
      uint64_t v29 = (v24 - (char *)v28) >> 2;
      unint64_t v30 = (char *)v26 - (char *)v28;
      unint64_t v31 = ((char *)v26 - (char *)v28) >> 1;
      if (v31 <= v29 + 1) {
        unint64_t v31 = v29 + 1;
      }
      if (v30 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v31;
      }
      if (v32)
      {
        double v33 = (char *)sub_10000956C(v25, v32);
        uint64_t v28 = v23[5];
        id v24 = (char *)v23[6];
      }

      else
      {
        double v33 = 0LL;
      }

      char v34 = &v33[4 * v29];
      uint64_t v35 = (uint64_t *)&v33[4 * v32];
      *(_DWORD *)char v34 = *(_DWORD *)(a1 + 1672);
      __int16 v27 = (uint64_t *)(v34 + 4);
      while (v24 != (char *)v28)
      {
        int v36 = *((_DWORD *)v24 - 1);
        v24 -= 4;
        *((_DWORD *)v34 - 1) = v36;
        v34 -= 4;
      }

      void v23[5] = (uint64_t *)v34;
      void v23[6] = v27;
      v23[7] = v35;
      if (v28) {
        operator delete(v28);
      }
    }

    else
    {
      *(_DWORD *)id v24 = *(_DWORD *)(a1 + 1672);
      __int16 v27 = (uint64_t *)(v24 + 4);
    }

    void v23[6] = v27;
    int v37 = *(_DWORD *)(a1 + 1672);
    __int128 v38 = *(_OWORD *)(a4 + 112);
    __int128 v90 = *(_OWORD *)(a4 + 96);
    __int128 v91 = v38;
    v92[0] = *(_OWORD *)(a4 + 128);
    *(_OWORD *)((char *)v92 + 12) = *(_OWORD *)(a4 + 140);
    __int128 v39 = *(_OWORD *)(a4 + 48);
    *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)(a4 + 32);
    __int128 v87 = v39;
    __int128 v40 = *(_OWORD *)(a4 + 80);
    __int128 v88 = *(_OWORD *)(a4 + 64);
    __int128 v89 = v40;
    __int128 v41 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)uint64_t buf = *(_OWORD *)a4;
    *(_OWORD *)&uint8_t buf[16] = v41;
    memcpy(v93, (const void *)(a4 + 160), sizeof(v93));
    uint64_t v42 = *(void *)(a4 + 680);
    uint64_t v94 = v42;
    __int16 v43 = *(std::__shared_weak_count **)(a4 + 688);
    int v95 = v43;
    if (v43)
    {
      p_shared_owners = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v45 = __ldxr(p_shared_owners);
      while (__stxr(v45 + 1, p_shared_owners));
    }

    __int128 v46 = *(_OWORD *)(a4 + 776);
    __int128 v100 = *(_OWORD *)(a4 + 760);
    v101[0] = v46;
    __int128 v47 = *(_OWORD *)(a4 + 712);
    __int128 v96 = *(_OWORD *)(a4 + 696);
    __int128 v97 = v47;
    __int128 v48 = *(_OWORD *)(a4 + 744);
    __int128 v98 = *(_OWORD *)(a4 + 728);
    __int128 v99 = v48;
    v61[1] = 3321888768LL;
    __int128 v62 = *(_OWORD *)buf;
    __int128 v63 = *(_OWORD *)&buf[16];
    __int128 v66 = v88;
    __int128 v67 = v89;
    __int128 v64 = *(_OWORD *)&buf[32];
    __int128 v65 = v87;
    *(_OWORD *)((char *)v70 + 12) = *(_OWORD *)((char *)v92 + 12);
    v70[0] = v92[0];
    __int128 v69 = v91;
    *(void *)((char *)v101 + 13) = *(void *)(a4 + 789);
    __int16 v49 = *(void **)(a1 + 1664);
    __int16 v50 = v82;
    v61[0] = _NSConcreteStackBlock;
    v61[2] = sub_10077684C;
    v61[3] = &unk_10184DE38;
    v61[4] = a1;
    int v80 = v85;
    int v81 = v37;
    __int128 v68 = v90;
    memcpy(v71, v93, sizeof(v71));
    uint64_t v72 = v42;
    int v73 = v43;
    if (v43)
    {
      __int16 v51 = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }

    *(void *)&v79[13] = *(void *)((char *)v101 + 13);
    __int128 v78 = v100;
    *(_OWORD *)uint64_t v79 = v101[0];
    __int128 v74 = v96;
    __int128 v75 = v97;
    __int128 v77 = v99;
    __int128 v76 = v98;
    objc_msgSend(objc_msgSend(v49, "uploadTaskWithRequest:fromData:completionHandler:", v50, v7, v61), "resume");
    __int16 v53 = v73;
    if (v73)
    {
      unsigned int v54 = (unint64_t *)&v73->__shared_owners_;
      do
        unint64_t v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }

    int v56 = v95;
    if (v95)
    {
      __int16 v57 = (unint64_t *)&v95->__shared_owners_;
      do
        unint64_t v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }

    if (SHIBYTE(v84) < 0) {
      operator delete((void *)__p);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    double v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "#EED2 failed to serialize LIS dict into JSON",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(__p) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2 failed to serialize LIS dict into JSON",  &__p,  2);
      unsigned int v60 = (char *)v59;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::postMessage(NumberType, NSDictionary *, const GNSS::DaemonLocation &)",  "%s\n",  v59);
      if (v60 != buf) {
        free(v60);
      }
    }

    uint64_t v10 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 21LL);
    uint64_t v11 = *(void *)(a1 + 2040);
    if (v11)
    {
      unsigned int v13 = *(_DWORD *)(v11 + 24);
      signed __int8 v12 = (int *)(v11 + 24);
      unsigned int v14 = sub_100778A88(v10, v13);
      int v15 = *v12;
      if (v14 >= 2) {
        int v15 = 7;
      }
      *signed __int8 v12 = v15;
    }
  }

void sub_100774590(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x387]) < 0) {
    operator delete((void *)STACK[0x370]);
  }
  _Unwind_Resume(a1);
}

void sub_1007745E0(uint64_t a1)
{
  if (*(void *)(a1 + 2040))
  {
    unsigned int v2 = sub_100764AF4(a1);
    if (v2 > 2)
    {
      id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
      double v9 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_100764AF4(a1));
      if (byte_10199847F >= 0) {
        uint64_t v10 = &qword_101998468;
      }
      else {
        uint64_t v10 = (uint64_t *)qword_101998468;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v9,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10));
      uint64_t v11 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", **(unsigned int **)(a1 + 2040));
      if (byte_10199853F >= 0) {
        signed __int8 v12 = &qword_101998528;
      }
      else {
        signed __int8 v12 = (uint64_t *)qword_101998528;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v11,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
      unsigned int v13 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 4LL));
      if (byte_101998557 >= 0) {
        unsigned int v14 = &qword_101998540;
      }
      else {
        unsigned int v14 = (uint64_t *)qword_101998540;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v13,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
      int v15 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 8LL));
      if (byte_10199856F >= 0) {
        double v16 = &qword_101998558;
      }
      else {
        double v16 = (uint64_t *)qword_101998558;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v15,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16));
      uint64_t v17 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 12LL));
      if (byte_101998587 >= 0) {
        int v18 = &qword_101998570;
      }
      else {
        int v18 = (uint64_t *)qword_101998570;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v17,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v18));
      int v19 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 16LL));
      if (byte_10199859F >= 0) {
        NSUInteger v20 = &qword_101998588;
      }
      else {
        NSUInteger v20 = (uint64_t *)qword_101998588;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v19,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v20));
      __int16 v21 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 20LL));
      if (byte_1019985B7 >= 0) {
        id v22 = &qword_1019985A0;
      }
      else {
        id v22 = (uint64_t *)qword_1019985A0;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v21,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22));
      __int16 v23 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 24LL));
      if (byte_1019985CF >= 0) {
        id v24 = &qword_1019985B8;
      }
      else {
        id v24 = (uint64_t *)qword_1019985B8;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v23,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v24));
      LODWORD(v25) = *(_DWORD *)(*(void *)(a1 + 2040) + 28LL);
      int v26 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v25);
      if (byte_1019985E7 >= 0) {
        __int16 v27 = &qword_1019985D0;
      }
      else {
        __int16 v27 = (uint64_t *)qword_1019985D0;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v26,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v27));
      LODWORD(v2_Block_object_dispose(va, 8) = *(_DWORD *)(*(void *)(a1 + 2040) + 32LL);
      uint64_t v29 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v28);
      if (byte_1019985FF >= 0) {
        unint64_t v30 = &qword_1019985E8;
      }
      else {
        unint64_t v30 = (uint64_t *)qword_1019985E8;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v29,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v30));
      unint64_t v31 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 36LL));
      if (byte_101998617 >= 0) {
        unint64_t v32 = &qword_101998600;
      }
      else {
        unint64_t v32 = (uint64_t *)qword_101998600;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v31,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v32));
      double v33 = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 2040) + 40LL));
      if (byte_10199862F >= 0) {
        char v34 = &qword_101998618;
      }
      else {
        char v34 = (uint64_t *)qword_101998618;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v33,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v34));
      uint64_t v35 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 44LL));
      if (byte_101998647 >= 0) {
        int v36 = &qword_101998630;
      }
      else {
        int v36 = (uint64_t *)qword_101998630;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v35,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v36));
      int v37 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 52LL));
      if (byte_10199865F >= 0) {
        __int128 v38 = &qword_101998648;
      }
      else {
        __int128 v38 = (uint64_t *)qword_101998648;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v37,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v38));
      __int128 v39 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 56LL));
      if (byte_101998677 >= 0) {
        __int128 v40 = &qword_101998660;
      }
      else {
        __int128 v40 = (uint64_t *)qword_101998660;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v39,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v40));
      __int128 v41 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 60LL));
      if (byte_10199868F >= 0) {
        uint64_t v42 = &qword_101998678;
      }
      else {
        uint64_t v42 = (uint64_t *)qword_101998678;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v41,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v42));
      __int16 v43 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 64LL));
      if (byte_1019986A7 >= 0) {
        int v44 = &qword_101998690;
      }
      else {
        int v44 = (uint64_t *)qword_101998690;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v43,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v44));
      unint64_t v45 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 72LL));
      if (byte_1019986BF >= 0) {
        __int128 v46 = &qword_1019986A8;
      }
      else {
        __int128 v46 = (uint64_t *)qword_1019986A8;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v45,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v46));
      __int128 v47 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 80LL));
      if (byte_1019986D7 >= 0) {
        __int128 v48 = &qword_1019986C0;
      }
      else {
        __int128 v48 = (uint64_t *)qword_1019986C0;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v47,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v48));
      __int16 v49 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 84LL));
      if (byte_1019986EF >= 0) {
        __int16 v50 = &qword_1019986D8;
      }
      else {
        __int16 v50 = (uint64_t *)qword_1019986D8;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v49,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v50));
      __int16 v51 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 88LL));
      if (byte_101998707 >= 0) {
        unint64_t v52 = &qword_1019986F0;
      }
      else {
        unint64_t v52 = (uint64_t *)qword_1019986F0;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v51,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v52));
      __int16 v53 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 92LL));
      if (byte_10199871F >= 0) {
        unsigned int v54 = &qword_101998708;
      }
      else {
        unsigned int v54 = (uint64_t *)qword_101998708;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v53,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v54));
      unint64_t v55 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 96LL));
      if (byte_101998737 >= 0) {
        int v56 = &qword_101998720;
      }
      else {
        int v56 = (uint64_t *)qword_101998720;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v55,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v56));
      __int16 v57 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 100LL));
      if (byte_10199874F >= 0) {
        unint64_t v58 = &qword_101998738;
      }
      else {
        unint64_t v58 = (uint64_t *)qword_101998738;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v57,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v58));
      int v59 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 104LL));
      if (byte_101998767 >= 0) {
        unsigned int v60 = &qword_101998750;
      }
      else {
        unsigned int v60 = (uint64_t *)qword_101998750;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v59,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v60));
      int v61 = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 2040) + 108LL));
      if (byte_10199877F >= 0) {
        __int128 v62 = &qword_101998768;
      }
      else {
        __int128 v62 = (uint64_t *)qword_101998768;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v61,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v62));
      __int128 v63 = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 2040) + 112LL));
      if (byte_101998797 >= 0) {
        __int128 v64 = &qword_101998780;
      }
      else {
        __int128 v64 = (uint64_t *)qword_101998780;
      }
      objc_msgSend( v8,  "setValue:forKey:",  v63,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v64));
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int128 v65 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 138412290;
        unint64_t v73 = (unint64_t)v8;
        _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "#EED2,storeEEDMetricDataToCache,storing the dictionary to cache:%@",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v70 = 138412290;
        id v71 = v8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,storeEEDMetricDataToCache,storing the dictionary to cache:%@",  &v70,  12);
        __int128 v69 = (uint8_t *)v68;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::storeEEDMetricDataToCache()", "%s\n", v68);
        if (v69 != buf) {
          free(v69);
        }
      }

      uint64_t v66 = sub_1002F8DDC();
      sub_1002AB3DC(v66);
      uint64_t v67 = sub_1002F8DDC();
      (*(void (**)(uint64_t))(*(void *)v67 + 944LL))(v67);
    }

    else
    {
      unsigned int v3 = v2;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      double v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        unint64_t v73 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDMetricDataToCache,trying to cache metric data in state:%ld,early return",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDMetricDataToCache,trying to cache metric data in state:%ld,early return",  &v70);
LABEL_19:
        unint64_t v7 = (uint8_t *)v5;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::storeEEDMetricDataToCache()", "%s\n", v5);
        if (v7 != buf) {
          free(v7);
        }
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    double v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "#EED2,storeEEDMetricDataToCache,nil fEED2Report,early return",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,storeEEDMetricDataToCache,nil fEED2Report,early return");
      goto LABEL_19;
    }
  }

unint64_t sub_100775134()
{
  return llround(v0);
}

void *sub_100775158@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10184E558[a1]);
}

NSArray *sub_10077516C(uint64_t a1)
{
  if (sub_1004F9834()
    && *(_DWORD *)(a1 + 132) == 1
    && *(_BYTE *)(a1 + 1856)
    && *((_BYTE *)sub_100756E48((int *)(a1 + 1448)) + 59)
    && (unsigned int v2 = *(void **)(a1 + 1960)) != 0LL)
  {
    v17[0] = @"capability";
    v17[1] = @"status";
    v18[0] = kRequestTypeVideoStreaming;
    else {
      unsigned int v3 = @"not_supported";
    }
    v18[1] = v3;
    v19[0] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v18,  v17,  2LL);
    v15[1] = @"status";
    v16[0] = kRequestTypeMediaUpload;
    v15[0] = @"capability";
    else {
      double v4 = @"not_supported";
    }
    v16[1] = v4;
    v19[1] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v16,  v15,  2LL);
    double v5 = v19;
  }

  else
  {
    v22[0] = @"capability";
    v22[1] = @"status";
    v23[0] = kRequestTypeVideoStreaming;
    v23[1] = @"not_supported";
    v24[0] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v23,  v22,  2LL);
    v20[0] = @"capability";
    v20[1] = @"status";
    v21[0] = kRequestTypeMediaUpload;
    v21[1] = @"not_supported";
    v24[1] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v21,  v20,  2LL);
    double v5 = v24;
  }

  double v6 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v5, 2LL);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  unint64_t v7 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 138412290;
    unsigned int v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#EED2 getRequestCapabilities,%@", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v11 = 138412290;
    signed __int8 v12 = v6;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2 getRequestCapabilities,%@",  &v11,  12);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C("Generic", 1LL, 0, 2LL, "NSArray *CLEmergencyEED2::getRequestCapabilities()", "%s\n", v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  return v6;
}

NSData *sub_100775488(uint64_t a1)
{
  if (!a1)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unsigned int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#EED2,getSerializedJsonData,dict is nil",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v13) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,getSerializedJsonData,dict is nil",  &v13,  2);
    goto LABEL_21;
  }

  id v12 = 0LL;
  uint64_t v1 = +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  a1,  0LL,  &v12);
  if (v1) {
    return -[NSString dataUsingEncoding:]( -[NSString stringByReplacingOccurrencesOfString:withString:](  -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v1,  4LL),  "stringByReplacingOccurrencesOfString:withString:",  @"\\/",  @"/"),  "dataUsingEncoding:",  4LL);
  }
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  double v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    id v6 = objc_msgSend(objc_msgSend(v12, "domain"), "UTF8String");
    unsigned int v7 = [v12 code];
    *(_DWORD *)uint64_t buf = 136446466;
    id v18 = v6;
    __int16 v19 = 1026;
    unsigned int v20 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "#EED2,getSerializedJsonData,failed to serialize dict into JSON,domain,%{public}s,code,%{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v8 = qword_101934898;
    id v9 = objc_msgSend(objc_msgSend(v12, "domain"), "UTF8String");
    unsigned int v10 = [v12 code];
    int v13 = 136446466;
    id v14 = v9;
    __int16 v15 = 1026;
    unsigned int v16 = v10;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  16LL,  "#EED2,getSerializedJsonData,failed to serialize dict into JSON,domain,%{public}s,code,%{public}d",  &v13,  18);
LABEL_21:
    int v11 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static NSData *CLEmergencyEED2::getSerializedJsonData(NSDictionary *)",  "%s\n",  v4);
    if (v11 != buf) {
      free(v11);
    }
  }

  return 0LL;
}

void sub_1007757C8(__SecKey **a1, void *a2, id *a3)
{
  if (objc_opt_class(&OBJC_CLASS___AADeviceInfo)) {
    id v6 = (const __CFString *)+[AADeviceInfo clientInfoHeader](&OBJC_CLASS___AADeviceInfo, "clientInfoHeader");
  }
  else {
    id v6 = &stru_1018A4B00;
  }
  [*a3 setValue:v6 forHTTPHeaderField:@"x-mme-client-info"];
  unsigned int v7 = a1[210];
  if (v7 && a1[211] && a1[212])
  {
    error.__r_.__value_.__r.__words[0] = 0LL;
    CFDataRef Signature = SecKeyCreateSignature( v7,  kSecKeyAlgorithmECDSASignatureMessageX962SHA256,  (CFDataRef)a2,  (CFErrorRef *)&error);
    id v9 = -[__CFData base64EncodedStringWithOptions:](Signature, "base64EncodedStringWithOptions:", 0LL);

    [*a3 setValue:v9 forHTTPHeaderField:@"x-eed-baa-signature"];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unsigned int v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      id v11 = [v9 UTF8String];
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#EED2,#BAA,added header x-eed-baa-signature : %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v66 = qword_101934898;
      id v67 = [v9 UTF8String];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v66,  2LL,  "#EED2,#BAA,added header x-eed-baa-signature : %{public}s",  &__p,  12);
      __int128 v69 = (char *)v68;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const",  "%s\n",  v68);
    }

    CFDataRef v12 = SecCertificateCopyData(a1[211]);
    id v13 = -[__CFData base64EncodedStringWithOptions:](v12, "base64EncodedStringWithOptions:", 0LL);

    [*a3 setValue:v13 forHTTPHeaderField:@"x-eed-baa-leaf-cert"];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v14 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      id v15 = [v13 UTF8String];
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "#EED2,#BAA,added header x-eed-baa-leaf-cert : %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v70 = qword_101934898;
      id v71 = [v13 UTF8String];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v71;
      LODWORD(v7_Block_object_dispose(va, 8) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v70,  2LL,  "#EED2,#BAA,added header x-eed-baa-leaf-cert : %{public}s",  &__p,  v78);
      unint64_t v73 = (char *)v72;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const",  "%s\n",  v72);
    }

    CFDataRef v16 = SecCertificateCopyData(a1[212]);
    id v17 = -[__CFData base64EncodedStringWithOptions:](v16, "base64EncodedStringWithOptions:", 0LL);

    [*a3 setValue:v17 forHTTPHeaderField:@"x-eed-baa-int-cert-1"];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v18 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      id v19 = [v17 UTF8String];
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "#EED2,#BAA,added header x-eed-baa-int-cert-1 : %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v74 = qword_101934898;
      id v75 = [v17 UTF8String];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v75;
      LODWORD(v7_Block_object_dispose(va, 8) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v74,  2LL,  "#EED2,#BAA,added header x-eed-baa-int-cert-1 : %{public}s",  &__p,  v78);
      __int128 v77 = (char *)v76;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const",  "%s\n",  v76);
    }

    unsigned int v20 = -[NSString initWithData:encoding:](objc_alloc(&OBJC_CLASS___NSString), "initWithData:encoding:", a2, 4LL);
    sub_1010DDBC0(&buf, "#EED2,#BAA,POST body");
    sub_1010DDBC0(&__p, (char *)-[NSString UTF8String](v20, "UTF8String"));
    sub_100F98768((std::string::size_type)&buf, &__p);
    if (v84 < 0) {
      operator delete((void *)buf);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int16 v21 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "#EED2,#BAA,addHeadersToUrlRequest,cert not available",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,#BAA,addHeadersToUrlRequest,cert not available",  &__p,  2);
      unint64_t v55 = (char *)v54;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const",  "%s\n",  v54);
    }
  }

  memset(&__p, 0, sizeof(__p));
  sub_1002F0B04(&buf);
  if (sub_1002A8560(buf, "EED2EnvHeader", &__p))
  {
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    __int16 v23 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (!*((void *)&buf + 1)) {
      goto LABEL_39;
    }
    id v24 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
      if (!size) {
        goto LABEL_57;
      }
    }

    else
    {
LABEL_39:
      if (!size) {
        goto LABEL_57;
      }
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v26 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf) = 136380675;
      *(void *)((char *)&buf + 4) = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "#Warning #EED2,sending environment override header for %{private}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      unsigned int v60 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        unsigned int v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(error.__r_.__value_.__l.__data_) = 136380675;
      *(std::string::size_type *)((char *)error.__r_.__value_.__r.__words + 4) = (std::string::size_type)v60;
      LODWORD(v7_Block_object_dispose(va, 8) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2,sending environment override header for %{private}s",  &error,  v78);
      __int128 v62 = (char *)v61;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const",  "%s\n",  v61);
    }

    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v28 = &__p;
    }
    else {
      double v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    objc_msgSend( *a3,  "setValue:forHTTPHeaderField:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v28),  @"x-eed-environment");
  }

  else
  {
    uint64_t v29 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (*((void *)&buf + 1))
    {
      unint64_t v30 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
  }

void sub_10077679C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_10077684C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(v7 + 8), "silo"), "queue");
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3321888768LL;
  void v18[2] = sub_1007769D8;
  void v18[3] = &unk_10184DE08;
  v18[6] = v7;
  uint64_t v37 = *(void *)(a1 + 840);
  __int128 v25 = *(_OWORD *)(a1 + 136);
  __int128 v26 = *(_OWORD *)(a1 + 152);
  v27[0] = *(_OWORD *)(a1 + 168);
  *(_OWORD *)((char *)v27 + 12) = *(_OWORD *)(a1 + 180);
  __int128 v21 = *(_OWORD *)(a1 + 72);
  __int128 v22 = *(_OWORD *)(a1 + 88);
  __int128 v23 = *(_OWORD *)(a1 + 104);
  __int128 v24 = *(_OWORD *)(a1 + 120);
  __int128 v19 = *(_OWORD *)(a1 + 40);
  __int128 v20 = *(_OWORD *)(a1 + 56);
  memcpy(v28, (const void *)(a1 + 200), sizeof(v28));
  uint64_t v29 = *(void *)(a1 + 720);
  id v9 = *(std::__shared_weak_count **)(a1 + 728);
  unint64_t v30 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  *(void *)&v36[13] = *(void *)(a1 + 829);
  __int128 v12 = *(_OWORD *)(a1 + 816);
  __int128 v35 = *(_OWORD *)(a1 + 800);
  *(_OWORD *)int v36 = v12;
  __int128 v13 = *(_OWORD *)(a1 + 752);
  __int128 v31 = *(_OWORD *)(a1 + 736);
  __int128 v32 = v13;
  __int128 v14 = *(_OWORD *)(a1 + 784);
  __int128 v33 = *(_OWORD *)(a1 + 768);
  __int128 v34 = v14;
  v18[4] = a3;
  v18[5] = a4;
  dispatch_async(v8, v18);
  id v15 = v30;
  if (v30)
  {
    CFDataRef v16 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_1007769D8(uint64_t a1)
{
}

void sub_1007769F4(uint64_t a1, int a2, __int32 a3, uint64_t a4, void *a5, void *a6)
{
  int v116 = a2;
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  unint64_t v11 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      __int128 v12 = "Companion";
    }
    else {
      __int128 v12 = "Native";
    }
    __int128 v13 = __p;
    sub_1010DDBC0(__p, v12);
    if (SHIBYTE(__p[2]) < 0) {
      __int128 v13 = (void **)__p[0];
    }
    id v14 = objc_msgSend(objc_msgSend(a5, "valueForHTTPHeaderField:", @"X-Responding-Instance"), "UTF8String");
    id v15 = objc_msgSend(objc_msgSend(a5, "valueForHTTPHeaderField:", @"X-Apple-Request-UUID"), "UTF8String");
    id v16 = objc_msgSend( objc_msgSend(a5, "valueForHTTPHeaderField:", @"X-Apple-Jingle-Correlation-Key"),  "UTF8String");
    id v17 = objc_msgSend(objc_msgSend(a5, "valueForHTTPHeaderField:", @"Via"), "UTF8String");
    *(_DWORD *)__int128 buf = 68290563;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v123 = 2082;
    *(void *)&__int128 v124 = v13;
    WORD4(v1sub_10000AE14(v9 + 24) = 1026;
    *(_DWORD *)((char *)&v124 + 1sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = a3;
    HIWORD(v1sub_10000AE14(v9 + 24) = 2081;
    id v125 = v14;
    __int16 v126 = 2081;
    id v127 = v15;
    __int16 v128 = 2081;
    id v129 = v16;
    __int16 v130 = 2081;
    *(void *)int v131 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,#LIS,handleHttpsResponse,response headers, numberType:%{public, location:escape _only}s, message:%{public}d, responding instance:%{private, location:escape_only}s, UUID:%{private, lo cation:escape_only}s, jingle corr key:%{private, location:escape_only}s, via:%{private, location:escape_only}s}",  buf,  0x4Au);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }

  *(void *)__int128 buf = &v116;
  id v18 = (const __int32 *)sub_1004C2E20((uint64_t **)(a1 + 1992), &v116, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[5];
  *(void *)__int128 buf = &v116;
  __int128 v19 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v116, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[6];
  __int128 v20 = wmemchr(v18, a3, ((char *)v19 - (char *)v18) >> 2);
  if (v20) {
    __int128 v19 = (uint64_t *)v20;
  }
  *(void *)__int128 buf = &v116;
  if (v19 != sub_1004C2E20((uint64_t **)(a1 + 1992), &v116, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[6])
  {
    *(void *)__int128 buf = &v116;
    __int128 v21 = sub_1004C2E20((uint64_t **)(a1 + 1992), &v116, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
    __int128 v22 = v21[6];
    int64_t v23 = (char *)v22 - ((char *)v19 + 4);
    v21[6] = (uint64_t *)((char *)v19 + v23);
    int v24 = sub_100869780(a4);
    if (!a5)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v49 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v50 = v116 ? "Companion" : "Native";
        sub_1010DDBC0(__p, v50);
        __int16 v51 = SHIBYTE(__p[2]) >= 0 ? __p : (void **)__p[0];
        unsigned int v52 = [a6 code];
        id v53 = [a6 domain];
        id v54 = [a6 localizedDescription];
        *(_DWORD *)__int128 buf = 136447234;
        *(void *)&uint8_t buf[4] = v51;
        *(_WORD *)&_BYTE buf[12] = 1026;
        *(_DWORD *)&buf[14] = a3;
        __int16 v123 = 1026;
        LODWORD(v1sub_10000AE14(v9 + 24) = v52;
        WORD2(v1sub_10000AE14(v9 + 24) = 2114;
        *(void *)((char *)&v124 + 6) = v53;
        HIWORD(v1sub_10000AE14(v9 + 24) = 2114;
        id v125 = v54;
        _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "#EED2 POST for %{public}s number message %{public}d failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  buf,  0x2Cu);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v81 = qword_101934898;
        if (v116) {
          std::string v82 = "Companion";
        }
        else {
          std::string v82 = "Native";
        }
        sub_1010DDBC0(&v113, v82);
        if (v115 >= 0) {
          std::string v83 = &v113;
        }
        else {
          std::string v83 = v113;
        }
        unsigned int v84 = [a6 code];
        id v85 = [a6 domain];
        id v86 = [a6 localizedDescription];
        LODWORD(__p[0]) = 136447234;
        *(void **)((char *)__p + 4) = v83;
        WORD2(__p[1]) = 1026;
        *(_DWORD *)((char *)&__p[1] + 6) = a3;
        WORD1(__p[2]) = 1026;
        HIDWORD(__p[2]) = v84;
        __int16 v118 = 2114;
        id v119 = v85;
        __int16 v120 = 2114;
        id v121 = v86;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v81,  0LL,  "#EED2 POST for %{public}s number message %{public}d failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  __p,  44);
        __int128 v88 = v87;
        if (v115 < 0) {
          operator delete(v113);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleHttpsResponse(NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)",  "%s\n",  v88);
        if (v88 != buf) {
          free(v88);
        }
      }

      *(_DWORD *)(a1 + 42_Block_object_dispose(va, 8) = [a6 code];
      if (*(void *)(a1 + 2040)) {
        *(_DWORD *)(*(void *)(a1 + 2040) + 36) = [0 statusCode];
      }
      if (v24)
      {
        uint64_t v55 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 16LL);
        ++*(_DWORD *)(a1 + 424);
        uint64_t v56 = *(void *)(a1 + 2040);
        if (v56)
        {
          unsigned int v58 = *(_DWORD *)(v56 + 24);
          __int16 v57 = (int *)(v56 + 24);
          unsigned int v59 = sub_100778A88(v55, v58);
          int v60 = *v57;
          if (v59 >= 4) {
            int v60 = 6;
          }
          *__int16 v57 = v60;
          ++*(_DWORD *)(*(void *)(a1 + 2040) + 4LL);
        }
      }

      goto LABEL_104;
    }

    if ([a5 statusCode] == (id)200)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int128 v25 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        if (v116) {
          __int128 v26 = "Companion";
        }
        else {
          __int128 v26 = "Native";
        }
        sub_1010DDBC0(__p, v26);
        int v27 = SHIBYTE(__p[2]);
        double v28 = (void **)__p[0];
        unsigned int v29 = [a5 statusCode];
        unint64_t v30 = __p;
        *(_DWORD *)__int128 buf = 136446722;
        if (v27 < 0) {
          unint64_t v30 = v28;
        }
        *(void *)&uint8_t buf[4] = v30;
        *(_WORD *)&_BYTE buf[12] = 1026;
        *(_DWORD *)&buf[14] = a3;
        __int16 v123 = 1026;
        LODWORD(v1sub_10000AE14(v9 + 24) = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "#EED2 POST for %{public}s number message %{public}d succeeded with response code %{public}d",  buf,  0x18u);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v89 = qword_101934898;
        if (v116) {
          __int128 v90 = "Companion";
        }
        else {
          __int128 v90 = "Native";
        }
        sub_1010DDBC0(&v113, v90);
        int v91 = v115;
        id v92 = (void **)v113;
        unsigned int v93 = [a5 statusCode];
        uint64_t v94 = &v113;
        LODWORD(__p[0]) = 136446722;
        if (v91 < 0) {
          uint64_t v94 = v92;
        }
        *(void **)((char *)__p + 4) = v94;
        WORD2(__p[1]) = 1026;
        *(_DWORD *)((char *)&__p[1] + 6) = a3;
        WORD1(__p[2]) = 1026;
        HIDWORD(__p[2]) = v93;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v89,  0LL,  "#EED2 POST for %{public}s number message %{public}d succeeded with response code %{public}d",  __p,  24);
        __int128 v96 = v95;
        if (v115 < 0) {
          operator delete(v113);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleHttpsResponse(NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)",  "%s\n",  v96);
        if (v96 != buf) {
          free(v96);
        }
      }

      if (!v24) {
        goto LABEL_104;
      }
      double v31 = sub_101171D4C();
      uint64_t v32 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 0LL);
      ++*(_DWORD *)(a1 + 420);
      uint64_t v33 = *(void *)(a1 + 2040);
      if (v33)
      {
        unsigned int v35 = *(_DWORD *)(v33 + 24);
        __int128 v34 = (int *)(v33 + 24);
        int v36 = sub_100778A88(v32, v35);
        int v37 = *v34;
        if (v36) {
          int v37 = 0;
        }
        *__int128 v34 = v37;
        ++**(_DWORD **)(a1 + 2040);
      }

      sub_100F993A0(a4, &v112, &v111);
      double v38 = *(double *)(a1 + 248);
      if (v38 < 0.0 || v38 >= v112)
      {
        *(double *)(a1 + 24_Block_object_dispose(va, 8) = v112;
        sub_1011BA104(a1 + 192, a4);
        if (sub_100F99260(a4)) {
          *(double *)(a1 + 256) = v111;
        }
      }

      uint64_t v39 = *(void *)(a1 + 2040);
      if (!v39) {
        goto LABEL_104;
      }
      float v40 = *(float *)(v39 + 28);
      if (v40 < 0.0)
      {
        double v41 = v31 - *(double *)(a1 + 176);
        *(_DWORD *)__int128 buf = 101;
        *(_DWORD *)&uint8_t buf[8] = (int)v41;
        int v42 = *(_DWORD *)(a4 + 96);
        HIDWORD(v1sub_10000AE14(v9 + 24) = 0;
        HIDWORD(v125) = 102;
        *(_DWORD *)((char *)&v127 + 2) = v42;
        *(_DWORD *)&v131[6] = 0;
        sub_1007680E4(__p, (uint64_t)buf, 2uLL);
        for (uint64_t i = 48LL; i != -32; i -= 40LL)
          sub_10043AFF4((uint64_t)&buf[i]);
        int v44 = *(void **)(a1 + 2048);
        memset(v110, 0, sizeof(v110));
        sub_10043BC44( v110,  (uint64_t)__p[0],  (uint64_t)__p[1],  0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 3));
        [v44 setMeasurements:sub_100435878(v110)];
        *(void *)__int128 buf = v110;
        sub_10043B844((void ***)buf);
        *(void *)__int128 buf = __p;
        sub_10043B844((void ***)buf);
        double v45 = v112;
        uint64_t v39 = *(void *)(a1 + 2040);
LABEL_98:
        float v73 = v45;
        *(float *)(v39 + 2_Block_object_dispose(va, 8) = v73;
        BOOL v74 = sub_100F99260(a4);
        uint64_t v75 = *(void *)(a1 + 2040);
        if (v74)
        {
          float v76 = v111;
          *(float *)(v75 + 32) = v76;
        }

        else
        {
          float v76 = *(float *)(v75 + 32);
        }

        double v77 = v31 - *(double *)(a1 + 176);
        *(_DWORD *)__int128 buf = 103;
        *(_DWORD *)&uint8_t buf[8] = (int)v77;
        int v78 = *(_DWORD *)(a4 + 96);
        HIDWORD(v1sub_10000AE14(v9 + 24) = 0;
        HIDWORD(v125) = 104;
        *(_DWORD *)((char *)&v127 + 2) = v78;
        *(_DWORD *)&v131[6] = 0;
        LODWORD(v77) = *(_DWORD *)(v75 + 28);
        int v132 = 105;
        int v133 = LODWORD(v77);
        int v134 = 4;
        int v135 = 106;
        float v136 = v76;
        int v137 = 4;
        memset(__p, 0, sizeof(__p));
        int v113 = __p;
        char v114 = 0;
        __p[0] = operator new(0xA0uLL);
        __p[1] = __p[0];
        __p[2] = (char *)__p[0] + 160;
        __p[1] = (void *)sub_100783D5C((uint64_t)&__p[2], (uint64_t)buf, (uint64_t)&v138, (uint64_t)__p[0]);
        for (uint64_t j = 128LL; j != -32; j -= 40LL)
          sub_10043AFF4((uint64_t)&buf[j]);
        int v80 = *(void **)(a1 + 2048);
        memset(v109, 0, sizeof(v109));
        sub_10043BC44( v109,  (uint64_t)__p[0],  (uint64_t)__p[1],  0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 3));
        [v80 setMeasurements:sub_100435878(v109)];
        *(void *)__int128 buf = v109;
        sub_10043B844((void ***)buf);
        *(void *)__int128 buf = __p;
        sub_10043B844((void ***)buf);
        goto LABEL_104;
      }

      double v72 = v40;
      double v45 = v112;
      if (v112 < v72) {
        goto LABEL_98;
      }
LABEL_104:
      sub_1007745E0(a1);
      sub_1007615DC(a1 + 1536, 13LL);
      return;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v61 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      if (v116) {
        __int128 v62 = "Companion";
      }
      else {
        __int128 v62 = "Native";
      }
      sub_1010DDBC0(__p, v62);
      int v63 = SHIBYTE(__p[2]);
      __int128 v64 = (void **)__p[0];
      unsigned int v65 = [a5 statusCode];
      uint64_t v66 = __p;
      *(_DWORD *)__int128 buf = 136446722;
      if (v63 < 0) {
        uint64_t v66 = v64;
      }
      *(void *)&uint8_t buf[4] = v66;
      *(_WORD *)&_BYTE buf[12] = 1026;
      *(_DWORD *)&buf[14] = a3;
      __int16 v123 = 1026;
      LODWORD(v1sub_10000AE14(v9 + 24) = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "#EED2 POST for %{public}s number message %{public}d failed with response code %{public}d",  buf,  0x18u);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v97 = qword_101934898;
      if (v116) {
        __int128 v98 = "Companion";
      }
      else {
        __int128 v98 = "Native";
      }
      sub_1010DDBC0(&v113, v98);
      int v99 = v115;
      __int128 v100 = (void **)v113;
      unsigned int v101 = [a5 statusCode];
      int v102 = &v113;
      LODWORD(__p[0]) = 136446722;
      if (v99 < 0) {
        int v102 = v100;
      }
      *(void **)((char *)__p + 4) = v102;
      WORD2(__p[1]) = 1026;
      *(_DWORD *)((char *)&__p[1] + 6) = a3;
      WORD1(__p[2]) = 1026;
      HIDWORD(__p[2]) = v101;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v97,  0LL,  "#EED2 POST for %{public}s number message %{public}d failed with response code %{public}d",  __p,  24);
      int v104 = v103;
      if (v115 < 0) {
        operator delete(v113);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleHttpsResponse(NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)",  "%s\n",  v104);
      if (v104 != buf) {
        free(v104);
      }
    }

    *(_DWORD *)(a1 + 42_Block_object_dispose(va, 8) = [a5 statusCode];
    if (*(void *)(a1 + 2040))
    {
      unsigned int v67 = [a5 statusCode];
      uint64_t v68 = *(void *)(a1 + 2040);
      *(_DWORD *)(v68 + 36) = v67;
      if ((v24 & 1) == 0) {
        goto LABEL_104;
      }
      ++*(_DWORD *)(a1 + 424);
      ++*(_DWORD *)(v68 + 4);
    }

    else
    {
      if (!v24) {
        goto LABEL_104;
      }
      ++*(_DWORD *)(a1 + 424);
    }

    if ([a5 statusCode] == (id)416)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int128 v69 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "#EED2 POST was determined to be outside coverage area",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(__p[0]) = 0;
        LODWORD(v107) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2 POST was determined to be outside coverage area",  __p,  v107);
        int v106 = (char *)v105;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleHttpsResponse(NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)",  "%s\n",  v105);
        if (v106 != buf) {
          free(v106);
        }
      }

      sub_100F9F078(a1, (unsigned int *)(a1 + 340), 31LL);
      uint64_t v70 = *(void *)(a1 + 2040);
      if (v70) {
        sub_100767578(a1, (unsigned int *)(v70 + 24), 9u);
      }
    }

    else
    {
      sub_100F9F078(a1, (unsigned int *)(a1 + 340), 16LL);
      uint64_t v71 = *(void *)(a1 + 2040);
      if (v71) {
        sub_100767578(a1, (unsigned int *)(v71 + 24), 6u);
      }
    }

    goto LABEL_104;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  unint64_t v46 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "#EED2, messageID is not part of pending messageID!",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2, messageID is not part of pending messageID!",  __p,  2);
    int v48 = (char *)v47;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::handleHttpsResponse(NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)",  "%s\n",  v47);
    if (v48 != buf) {
      free(v48);
    }
  }

void sub_100777A18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100777AF0(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v4;
  __int128 v5 = *(_OWORD *)(a2 + 88);
  __int128 v6 = *(_OWORD *)(a2 + 104);
  __int128 v7 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v7;
  *(_OWORD *)(a1 + 104) = v6;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = v5;
  __int128 v8 = *(_OWORD *)(a2 + 152);
  __int128 v9 = *(_OWORD *)(a2 + 168);
  __int128 v10 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 196) = *(_OWORD *)(a2 + 196);
  *(_OWORD *)(a1 + 184) = v10;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = v9;
  *(_OWORD *)(a1 + 152) = v8;
  memcpy((void *)(a1 + 216), (const void *)(a2 + 216), 0x201uLL);
  *(void *)(a1 + 736) = *(void *)(a2 + 736);
  uint64_t v11 = *(void *)(a2 + 744);
  *(void *)(a1 + 744) = v11;
  if (v11)
  {
    __int128 v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  __int128 v14 = *(_OWORD *)(a2 + 752);
  __int128 v15 = *(_OWORD *)(a2 + 784);
  *(_OWORD *)(a1 + 76_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 768);
  *(_OWORD *)(a1 + 784) = v15;
  *(_OWORD *)(a1 + 752) = v14;
  __n128 result = *(__n128 *)(a2 + 800);
  __int128 v17 = *(_OWORD *)(a2 + 816);
  __int128 v18 = *(_OWORD *)(a2 + 832);
  *(void *)(a1 + 845) = *(void *)(a2 + 845);
  *(_OWORD *)(a1 + 8sub_100708348(v2 - 16) = v17;
  *(_OWORD *)(a1 + 832) = v18;
  *(__n128 *)(a1 + 80sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = result;
  return result;
}

uint64_t sub_100777BC8(uint64_t a1)
{
  return sub_10000AE14(a1 + 736);
}

__n128 sub_100777BD0(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v4;
  __int128 v5 = *(_OWORD *)(a2 + 72);
  __int128 v6 = *(_OWORD *)(a2 + 88);
  __int128 v7 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 12sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v7;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = v6;
  *(_OWORD *)(a1 + 72) = v5;
  __int128 v8 = *(_OWORD *)(a2 + 136);
  __int128 v9 = *(_OWORD *)(a2 + 152);
  __int128 v10 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 18sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(_OWORD *)(a2 + 180);
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = v10;
  *(_OWORD *)(a1 + 152) = v9;
  *(_OWORD *)(a1 + 136) = v8;
  memcpy((void *)(a1 + 200), (const void *)(a2 + 200), 0x201uLL);
  *(void *)(a1 + 72sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = *(void *)(a2 + 720);
  uint64_t v11 = *(void *)(a2 + 728);
  *(void *)(a1 + 72_Block_object_dispose(va, 8) = v11;
  if (v11)
  {
    __int128 v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  __int128 v14 = *(_OWORD *)(a2 + 736);
  __int128 v15 = *(_OWORD *)(a2 + 768);
  *(_OWORD *)(a1 + 752) = *(_OWORD *)(a2 + 752);
  *(_OWORD *)(a1 + 76_Block_object_dispose(va, 8) = v15;
  *(_OWORD *)(a1 + 736) = v14;
  __n128 result = *(__n128 *)(a2 + 784);
  __int128 v17 = *(_OWORD *)(a2 + 800);
  __int128 v18 = *(_OWORD *)(a2 + 816);
  *(void *)(a1 + 829) = *(void *)(a2 + 829);
  *(_OWORD *)(a1 + 80sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = v17;
  *(_OWORD *)(a1 + 8sub_100708348(v2 - 16) = v18;
  *(__n128 *)(a1 + 784) = result;
  return result;
}

uint64_t sub_100777CA8(uint64_t a1)
{
  return sub_10000AE14(a1 + 720);
}

void sub_100777CB0(uint64_t a1, int a2, void *a3, void *a4)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  __int128 v8 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v9 = a2 ? "Companion" : "Native";
    sub_1010DDBC0(__p, v9);
    __int128 v10 = SBYTE3(v68) >= 0 ? __p : *(_BYTE **)__p;
    id v11 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Responding-Instance"), "UTF8String");
    id v12 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Apple-Request-UUID"), "UTF8String");
    id v13 = objc_msgSend( objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Apple-Jingle-Correlation-Key"),  "UTF8String");
    id v14 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"Via"), "UTF8String");
    *(_DWORD *)__int128 buf = 68290307;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v72 = 2082;
    float v73 = v10;
    __int16 v74 = 2081;
    id v75 = v11;
    __int16 v76 = 2081;
    id v77 = v12;
    __int16 v78 = 2081;
    id v79 = v13;
    __int16 v80 = 2081;
    id v81 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,#ADR,handleAdrResponse,response headers, numberType:%{public, location:escape_o nly}s, responding instance:%{private, location:escape_only}s, UUID:%{private, location:escape_only}s, ji ngle corr key:%{private, location:escape_only}s, via:%{private, location:escape_only}s}",  buf,  0x44u);
    if (SBYTE3(v68) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (a3)
  {
    if ([a3 statusCode] != (id)200)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v43 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          int v44 = "Companion";
        }
        else {
          int v44 = "Native";
        }
        sub_1010DDBC0(buf, v44);
        int v45 = SBYTE3(v73);
        unint64_t v46 = *(_BYTE **)buf;
        unsigned int v47 = [a3 statusCode];
        int v48 = buf;
        if (v45 < 0) {
          int v48 = v46;
        }
        *(_DWORD *)std::string __p = 136446466;
        *(void *)&__p[4] = v48;
        __int16 v65 = 1026;
        unsigned int v66 = v47;
        _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "#EED2,ADR POST for %{public}s number failed with response code %{public}d",  __p,  0x12u);
        if (SBYTE3(v73) < 0) {
          operator delete(*(void **)buf);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v50 = qword_101934898;
        if (a2) {
          __int16 v51 = "Companion";
        }
        else {
          __int16 v51 = "Native";
        }
        sub_1010DDBC0(__p, v51);
        int v52 = SBYTE3(v68);
        id v53 = *(_BYTE **)__p;
        unsigned int v54 = [a3 statusCode];
        uint64_t v55 = __p;
        if (v52 < 0) {
          uint64_t v55 = v53;
        }
        *(_DWORD *)int v60 = 136446466;
        *(void *)&v60[4] = v55;
        __int16 v61 = 1026;
        unsigned int v62 = v54;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v50,  0LL,  "#EED2,ADR POST for %{public}s number failed with response code %{public}d",  v60,  18);
        __int16 v57 = v56;
        if (SBYTE3(v68) < 0) {
          operator delete(*(void **)__p);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleAdrResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v57);
        if (v57 != buf) {
          free(v57);
        }
      }

      if ([a3 statusCode] == (id)416)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v49 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "#EED2,ADR POST was determined to be outside coverage area",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          *(_WORD *)std::string __p = 0;
          LODWORD(v59) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,ADR POST was determined to be outside coverage area",  __p,  v59);
          unsigned int v29 = (char *)v58;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleAdrResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v58);
          if (v29 != buf) {
            goto LABEL_60;
          }
        }
      }

      goto LABEL_78;
    }

    ++*(_DWORD *)(a1 + 1288);
    uint64_t v15 = *(void *)(a1 + 2040);
    if (v15) {
      ++*(_DWORD *)(v15 + 20);
    }
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v16 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        __int128 v17 = "Companion";
      }
      else {
        __int128 v17 = "Native";
      }
      sub_1010DDBC0(buf, v17);
      int v18 = SBYTE3(v73);
      __int128 v19 = *(_BYTE **)buf;
      unsigned int v20 = [a3 statusCode];
      __int128 v21 = buf;
      if (v18 < 0) {
        __int128 v21 = v19;
      }
      *(_DWORD *)std::string __p = 136446466;
      *(void *)&__p[4] = v21;
      __int16 v65 = 1026;
      unsigned int v66 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#EED2,ADR POST for %{public}s number succeeded with response code %{public}d",  __p,  0x12u);
      if (SBYTE3(v73) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_78;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v22 = qword_101934898;
    if (a2) {
      int64_t v23 = "Companion";
    }
    else {
      int64_t v23 = "Native";
    }
    sub_1010DDBC0(__p, v23);
    int v24 = SBYTE3(v68);
    __int128 v25 = *(_BYTE **)__p;
    unsigned int v26 = [a3 statusCode];
    int v27 = __p;
    if (v24 < 0) {
      int v27 = v25;
    }
    *(_DWORD *)int v60 = 136446466;
    *(void *)&v60[4] = v27;
    __int16 v61 = 1026;
    unsigned int v62 = v26;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  0LL,  "#EED2,ADR POST for %{public}s number succeeded with response code %{public}d",  v60,  18);
    unsigned int v29 = v28;
    if (SBYTE3(v68) < 0) {
      operator delete(*(void **)__p);
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    unint64_t v30 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      double v31 = a2 ? "Companion" : "Native";
      sub_1010DDBC0(__p, v31);
      uint64_t v32 = SBYTE3(v68) >= 0 ? __p : *(_BYTE **)__p;
      unsigned int v33 = [a4 code];
      __int128 v34 = [a4 domain];
      id v35 = [a4 localizedDescription];
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&_BYTE buf[12] = 1026;
      *(_DWORD *)&buf[14] = v33;
      __int16 v72 = 2114;
      float v73 = v34;
      __int16 v74 = 2114;
      id v75 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "#EED2,ADR POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  buf,  0x26u);
      if (SBYTE3(v68) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_78;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v36 = qword_101934898;
    if (a2) {
      int v37 = "Companion";
    }
    else {
      int v37 = "Native";
    }
    sub_1010DDBC0(v60, v37);
    if (v63 >= 0) {
      double v38 = v60;
    }
    else {
      double v38 = *(_BYTE **)v60;
    }
    unsigned int v39 = [a4 code];
    id v40 = [a4 domain];
    id v41 = [a4 localizedDescription];
    *(_DWORD *)std::string __p = 136446978;
    *(void *)&__p[4] = v38;
    __int16 v65 = 1026;
    unsigned int v66 = v39;
    __int16 v67 = 2114;
    id v68 = v40;
    __int16 v69 = 2114;
    id v70 = v41;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  0LL,  "#EED2,ADR POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  __p,  38);
    unsigned int v29 = v42;
    if (v63 < 0) {
      operator delete(*(void **)v60);
    }
  }

  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleAdrResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v29);
  if (v29 != buf) {
LABEL_60:
  }
    free(v29);
LABEL_78:
  sub_1007745E0(a1);
}

void sub_100778614( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100778670(uint64_t a1)
{
  uint64_t v2 = a1 + 1448;
  sub_1010DDBC0(__p, "carrier");
  unsigned int v3 = sub_100757034(v2, 0, (uint64_t *)__p);
  if (*((char *)v3 + 31) < 0)
  {
    sub_1010DD48C(&__dst, (void *)v3[1], v3[2]);
  }

  else
  {
    __uuid_t dst = *(_OWORD *)(v3 + 1);
    uint64_t v15 = v3[3];
  }

  __int128 v4 = (void **)(a1 + 1152);
  *(_OWORD *)__int128 v4 = __dst;
  *(void *)(a1 + 116_Block_object_dispose(va, 8) = v15;
  HIBYTE(v15) = 0;
  LOBYTE(__dst) = 0;
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v10, "carrier");
  __int128 v5 = sub_100757034(v2, 0, (uint64_t *)v10);
  if (*((char *)v5 + 55) < 0)
  {
    sub_1010DD48C(&__dst, (void *)v5[4], v5[5]);
  }

  else
  {
    __uuid_t dst = *((_OWORD *)v5 + 2);
    uint64_t v15 = v5[6];
  }

  __int128 v6 = (void **)(a1 + 1176);
  *(_OWORD *)__int128 v6 = __dst;
  *(void *)(a1 + 1192) = v15;
  HIBYTE(v15) = 0;
  LOBYTE(__dst) = 0;
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  *(_DWORD *)(a1 + 1292) = sub_100BF2734(*(unsigned int *)(a1 + 1768));
  *(void *)(a1 + 28sub_10023AE2C(v3, "NumberOfDaysToRetainCyclingPowerHistoryInDB", &dword_10130F560, 0) = 0x800000009LL;
  *(_DWORD *)(a1 + 276) = 3;
  *(_DWORD *)(a1 + 32_Block_object_dispose(va, 8) = 2;
  uint64_t v7 = sub_10059CEEC();
  __int128 v8 = (void *)sub_10059E244(v7);
  if (v8)
  {
    __int128 v9 = v8;
    std::string::assign((std::string *)(a1 + 1368), (const std::string::value_type *)[v8 UTF8String]);
  }

void sub_1007787FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10077882C(uint64_t a1, int a2)
{
  if (a2 > 20)
  {
    if (a2 > 29)
    {
      if (a2 == 30) {
        return 6LL;
      }
      if (a2 == 31) {
        return 3LL;
      }
    }

    else
    {
      if (a2 == 21) {
        return 2LL;
      }
      if (a2 == 26) {
        return 4294967294LL;
      }
    }

uint64_t sub_100778A88(uint64_t a1, unsigned int a2)
{
  if (a2 < 0xB) {
    return dword_101329D44[a2];
  }
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  unsigned int v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning #EED2 unexpected error code", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #EED2 unexpected error code",  v6,  2);
    __int128 v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "uint32_t CLEmergencyEED2::getEED2ErrorCodePriority(EED2SessionErrorCode)",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return 0xFFFFFFFFLL;
}

void sub_100778C28(uint64_t a1, void *a2)
{
  if (a2)
  {
    if ([a2 type] == (id)1)
    {
      ++*(_DWORD *)(a1 + 80);
    }

    else if ([a2 type] == (id)2)
    {
      ++*(_DWORD *)(a1 + 84);
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int128 v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [a2 type];
      int v10 = *(_DWORD *)(a1 + 80);
      int v11 = *(_DWORD *)(a1 + 84);
      *(_DWORD *)__int128 buf = 134218496;
      id v25 = v9;
      __int16 v26 = 1024;
      int v27 = v10;
      __int16 v28 = 1024;
      int v29 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,updateRequestTypeCountForCA,eedRequest.type:%ld, fNumStreamingRequests:%d,fNumUploadRequests:%d",  buf,  0x18u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v12 = qword_101934898;
    id v13 = [a2 type];
    int v14 = *(_DWORD *)(a1 + 80);
    int v15 = *(_DWORD *)(a1 + 84);
    int v18 = 134218496;
    id v19 = v13;
    __int16 v20 = 1024;
    int v21 = v14;
    __int16 v22 = 1024;
    int v23 = v15;
    double v16 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  0LL,  "#EED2,updateRequestTypeCountForCA,eedRequest.type:%ld, fNumStreamingRequests:%d,fNumUploadRequests:%d",  &v18,  24);
    uint64_t v7 = v17;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::AnalyticsReport::updateRequestTypeCountForCA(CLEEDRequest *)",  "%s\n",  v16);
LABEL_23:
    if (v7 != buf) {
      free(v7);
    }
    return;
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  __int128 v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#EED2,updateRequestTypeCountForCA,nil eedRequest,early return",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    LOWORD(v1_Block_object_dispose(va, 8) = 0;
    double v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,updateRequestTypeCountForCA,nil eedRequest,early return",  &v18,  2);
    uint64_t v7 = v6;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::AnalyticsReport::updateRequestTypeCountForCA(CLEEDRequest *)",  "%s\n",  v5);
    goto LABEL_23;
  }

void sub_100778F74(uint64_t a1, void *a2)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  __int128 v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [a2 count];
    int v6 = *(_DWORD *)(a1 + 96);
    int v7 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)__int128 buf = 134218496;
    id v41 = v5;
    __int16 v42 = 1024;
    int v43 = v6;
    __int16 v44 = 1024;
    int v45 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,updateMediaItemTypeCountForCA,before update, mediaItemList.count:%ld, fNumImages:%d, fNumVideos:%d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v17 = qword_101934898;
    id v18 = [a2 count];
    int v19 = *(_DWORD *)(a1 + 96);
    int v20 = *(_DWORD *)(a1 + 100);
    int v34 = 134218496;
    id v35 = v18;
    __int16 v36 = 1024;
    int v37 = v19;
    __int16 v38 = 1024;
    int v39 = v20;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  0LL,  "#EED2,updateMediaItemTypeCountForCA,before update, mediaItemList.count:%ld, fNumImages:%d, fNumVideos:%d",  &v34,  24,  (_DWORD)v29);
    __int16 v22 = (uint8_t *)v21;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::AnalyticsReport::updateMediaItemTypeCountForCA(NSSet<CLEEDMediaItem *> *)",  "%s\n",  v21);
    if (v22 != buf) {
      free(v22);
    }
  }

  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  id v8 = [a2 countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v30;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v30 != v10) {
          objc_enumerationMutation(a2);
        }
        uint64_t v12 = *(void **)(*((void *)&v29 + 1) + 8LL * (void)i);
        if ([v12 type] == (id)1)
        {
          ++*(_DWORD *)(a1 + 96);
        }

        else if ([v12 type] == (id)2)
        {
          ++*(_DWORD *)(a1 + 100);
        }
      }

      id v9 = [a2 countByEnumeratingWithState:&v29 objects:v33 count:16];
    }

    while (v9);
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v13 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    id v14 = [a2 count];
    int v15 = *(_DWORD *)(a1 + 96);
    int v16 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)__int128 buf = 134218496;
    id v41 = v14;
    __int16 v42 = 1024;
    int v43 = v15;
    __int16 v44 = 1024;
    int v45 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#EED2,updateMediaItemTypeCountForCA,after update, mediaItemList.count:%ld, fNumImages:%d, fNumVideos:%d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v23 = qword_101934898;
    id v24 = [a2 count];
    int v25 = *(_DWORD *)(a1 + 96);
    int v26 = *(_DWORD *)(a1 + 100);
    int v34 = 134218496;
    id v35 = v24;
    __int16 v36 = 1024;
    int v37 = v25;
    __int16 v38 = 1024;
    int v39 = v26;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  0LL,  "#EED2,updateMediaItemTypeCountForCA,after update, mediaItemList.count:%ld, fNumImages:%d, fNumVideos:%d",  &v34,  24,  (_DWORD)v29);
    __int16 v28 = (uint8_t *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::AnalyticsReport::updateMediaItemTypeCountForCA(NSSet<CLEEDMediaItem *> *)",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

id sub_1007793B4(__int128 *a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768LL;
  _DWORD v3[2] = sub_100783E98;
  unsigned __int8 v3[3] = &unk_10184E390;
  if (*((char *)a1 + 23) < 0)
  {
    sub_1010DD48C(&__p, *(void **)a1, *((void *)a1 + 1));
  }

  else
  {
    __int128 __p = *a1;
    uint64_t v5 = *((void *)a1 + 2);
  }

  id v1 = [v3 copy];
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
  return v1;
}

void sub_100779454( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100779470(uint64_t a1, int a2, void *a3, void *a4)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v8 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = a2 ? "Companion" : "Native";
    sub_1010DDBC0(__p, v9);
    uint64_t v10 = SBYTE3(v70) >= 0 ? __p : *(_BYTE **)__p;
    id v11 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Responding-Instance"), "UTF8String");
    id v12 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Apple-Request-UUID"), "UTF8String");
    id v13 = objc_msgSend( objc_msgSend(a3, "valueForHTTPHeaderField:", @"X-Apple-Jingle-Correlation-Key"),  "UTF8String");
    id v14 = objc_msgSend(objc_msgSend(a3, "valueForHTTPHeaderField:", @"Via"), "UTF8String");
    *(_DWORD *)__int128 buf = 68290307;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v74 = 2082;
    id v75 = v10;
    __int16 v76 = 2081;
    id v77 = v11;
    __int16 v78 = 2081;
    id v79 = v12;
    __int16 v80 = 2081;
    id v81 = v13;
    __int16 v82 = 2081;
    id v83 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,#ControlData,handleControlDataResponse,response headers, numberType:%{public, l ocation:escape_only}s, responding instance:%{private, location:escape_only}s, UUID:%{private, location:esc ape_only}s, jingle corr key:%{private, location:escape_only}s, via:%{private, location:escape_only}s}",  buf,  0x44u);
    if (SBYTE3(v70) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (a3)
  {
    if ([a3 statusCode] == (id)200)
    {
      uint64_t v15 = *(void *)(a1 + 2040);
      if (v15) {
        ++*(_DWORD *)(v15 + 56);
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v16 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          uint64_t v17 = "Companion";
        }
        else {
          uint64_t v17 = "Native";
        }
        sub_1010DDBC0(buf, v17);
        int v18 = SBYTE3(v75);
        int v19 = *(_BYTE **)buf;
        unsigned int v20 = [a3 statusCode];
        int v21 = buf;
        if (v18 < 0) {
          int v21 = v19;
        }
        *(_DWORD *)__int128 __p = 136446466;
        *(void *)&__p[4] = v21;
        __int16 v67 = 1026;
        unsigned int v68 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#EED2,ControlData POST for %{public}s number succeeded with response code %{public}d",  __p,  0x12u);
        if (SBYTE3(v75) < 0) {
          operator delete(*(void **)buf);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_68;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v22 = qword_101934898;
      if (a2) {
        uint64_t v23 = "Companion";
      }
      else {
        uint64_t v23 = "Native";
      }
      sub_1010DDBC0(__p, v23);
      int v24 = SBYTE3(v70);
      int v25 = *(_BYTE **)__p;
      unsigned int v26 = [a3 statusCode];
      int v27 = __p;
      if (v24 < 0) {
        int v27 = v25;
      }
      *(_DWORD *)unsigned int v62 = 136446466;
      *(void *)&v62[4] = v27;
      __int16 v63 = 1026;
      unsigned int v64 = v26;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  0LL,  "#EED2,ControlData POST for %{public}s number succeeded with response code %{public}d",  v62,  18);
      __int128 v29 = v28;
      if (SBYTE3(v70) < 0) {
        operator delete(*(void **)__p);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleControlDataResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v29);
      if (v29 == buf) {
        goto LABEL_68;
      }
      goto LABEL_96;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int16 v36 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        int v37 = "Companion";
      }
      else {
        int v37 = "Native";
      }
      sub_1010DDBC0(buf, v37);
      int v38 = SBYTE3(v75);
      int v39 = *(_BYTE **)buf;
      unsigned int v40 = [a3 statusCode];
      id v41 = buf;
      if (v38 < 0) {
        id v41 = v39;
      }
      *(_DWORD *)__int128 __p = 136446466;
      *(void *)&__p[4] = v41;
      __int16 v67 = 1026;
      unsigned int v68 = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#EED2,ControlData POST for %{public}s number failed with response code %{public}d",  __p,  0x12u);
      if (SBYTE3(v75) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v52 = qword_101934898;
      if (a2) {
        id v53 = "Companion";
      }
      else {
        id v53 = "Native";
      }
      sub_1010DDBC0(__p, v53);
      int v54 = SBYTE3(v70);
      uint64_t v55 = *(_BYTE **)__p;
      unsigned int v56 = [a3 statusCode];
      __int16 v57 = __p;
      if (v54 < 0) {
        __int16 v57 = v55;
      }
      *(_DWORD *)unsigned int v62 = 136446466;
      *(void *)&v62[4] = v57;
      __int16 v63 = 1026;
      unsigned int v64 = v56;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v52,  0LL,  "#EED2,ControlData POST for %{public}s number failed with response code %{public}d",  v62,  18);
      uint64_t v59 = v58;
      if (SBYTE3(v70) < 0) {
        operator delete(*(void **)__p);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleControlDataResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v59);
      if (v59 != buf) {
        free(v59);
      }
    }

    *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 1;
    if ([a3 statusCode] == (id)416)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      __int16 v42 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "#EED2,ControlData POST was determined to be outside coverage area",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_68;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      *(_WORD *)__int128 __p = 0;
      LODWORD(v61) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#EED2,ControlData POST was determined to be outside coverage area",  __p,  v61);
      __int128 v29 = (char *)v60;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleControlDataResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v60);
      if (v29 == buf) {
        goto LABEL_68;
      }
LABEL_96:
      free(v29);
LABEL_68:
      *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 0;
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    __int128 v30 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v31 = a2 ? "Companion" : "Native";
      sub_1010DDBC0(__p, v31);
      __int128 v32 = SBYTE3(v70) >= 0 ? __p : *(_BYTE **)__p;
      unsigned int v33 = [a4 code];
      int v34 = [a4 domain];
      id v35 = [a4 localizedDescription];
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&_BYTE buf[12] = 1026;
      *(_DWORD *)&buf[14] = v33;
      __int16 v74 = 2114;
      id v75 = v34;
      __int16 v76 = 2114;
      id v77 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "#EED2,ControlData POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  buf,  0x26u);
      if (SBYTE3(v70) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v44 = qword_101934898;
      if (a2) {
        int v45 = "Companion";
      }
      else {
        int v45 = "Native";
      }
      sub_1010DDBC0(v62, v45);
      if (v65 >= 0) {
        unint64_t v46 = v62;
      }
      else {
        unint64_t v46 = *(_BYTE **)v62;
      }
      unsigned int v47 = [a4 code];
      id v48 = [a4 domain];
      id v49 = [a4 localizedDescription];
      *(_DWORD *)__int128 __p = 136446978;
      *(void *)&__p[4] = v46;
      __int16 v67 = 1026;
      unsigned int v68 = v47;
      __int16 v69 = 2114;
      id v70 = v48;
      __int16 v71 = 2114;
      id v72 = v49;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v44,  0LL,  "#EED2,ControlData POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@",  __p,  38);
      __int16 v51 = v50;
      if (v65 < 0) {
        operator delete(*(void **)v62);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleControlDataResponse(NumberType, NSURLResponse *, NSError *)",  "%s\n",  v51);
      if (v51 != buf) {
        free(v51);
      }
    }

    *(_BYTE *)(a1 + 193_Block_object_dispose(va, 8) = 1;
  }

  sub_1007745E0(a1);
  return sub_1007615DC(a1 + 1536, 23LL);
}

void sub_100779E00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100779E5C(uint64_t a1)
{
  if (*(void *)(a1 + 1832))
  {
    if (!*(void *)(a1 + 1888) || !*(void *)(a1 + 1896))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#EED2,handleAPNSMessage,nil fRequestsPending or fRequestsHandled queue,early return",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v29[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleAPNSMessage,nil fRequestsPending or fRequestsHandled queue,early return",  v29,  2);
        unsigned int v20 = (uint8_t *)v19;
        sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::canHandleAPNSMessage()", "%s\n", v19);
        if (v20 != buf) {
          free(v20);
        }
      }

      if (*(void *)(a1 + 1896)) {
        sub_10077A6A0(a1, 7LL);
      }

      goto LABEL_19;
    }

    if (!*(void *)(a1 + 1848))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v13 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "#EED2,canHandleAPNSMessage,nil fHelperService,early return",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v29[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,canHandleAPNSMessage,nil fHelperService,early return",  v29,  2);
        int v24 = (uint8_t *)v23;
        sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::canHandleAPNSMessage()", "%s\n", v23);
        if (v24 != buf) {
          free(v24);
        }
      }

      sub_10077A6A0(a1, 7LL);

      goto LABEL_19;
    }

    id v2 = +[CLEEDRequest getSessionStartTimeFromDict:](&OBJC_CLASS___CLEEDRequest, "getSessionStartTimeFromDict:");
    -[NSDate timeIntervalSince1970]( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *(double *)(a1 + 168)),  "timeIntervalSince1970");
    if (v2 != (id)llround(v3))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v14 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "#EED2,canHandleAPNSMessage,receivedSessionStartTime and device session start time mismatch, early return",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v29[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,canHandleAPNSMessage,receivedSessionStartTime and device session start time mismatch, early return",  v29,  2);
        unsigned int v26 = (uint8_t *)v25;
        sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyEED2::canHandleAPNSMessage()", "%s\n", v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      sub_10077A6A0(a1, 10LL);

      goto LABEL_19;
    }

    id v4 = +[CLEEDRequest getCallIDFromDict:](&OBJC_CLASS___CLEEDRequest, "getCallIDFromDict:", *(void *)(a1 + 1832));
    *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
    uint64_t v5 = *(void *)(a1 + 56);
    if (!v5) {
      sub_100008BDC();
    }
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v5 + 48LL))(v5, buf);
    int v7 = (const char *)[v4 UTF8String];
    id v8 = (void *)(v6 + 136);
    size_t v9 = strlen(v7);
    if (*(char *)(v6 + 159) < 0)
    {
      if (v9 != *(void *)(v6 + 144)) {
        goto LABEL_42;
      }
      if (v9 == -1LL) {
        goto LABEL_79;
      }
      id v8 = (void *)*v8;
    }

    else
    {
      if (v9 == -1LL) {
LABEL_79:
      }
        sub_1001040F8();
    }

    if (!memcmp(v8, v7, v9)) {
      return 1LL;
    }
LABEL_42:
    uint64_t v15 = (const char *)[v4 UTF8String];
    int v16 = (void *)(a1 + 136);
    size_t v17 = strlen(v15);
    if (*(char *)(a1 + 159) < 0)
    {
      if (v17 == *(void *)(a1 + 144))
      {
        if (v17 == -1LL) {
          goto LABEL_80;
        }
        int v16 = (void *)*v16;
        goto LABEL_49;
      }
    }

    else if (v17 == *(unsigned __int8 *)(a1 + 159))
    {
      if (v17 == -1LL) {
LABEL_80:
      }
        sub_1001040F8();
LABEL_49:
      if (memcmp(v16, v15, v17)) {
        goto LABEL_50;
      }
      return 1LL;
    }

void sub_10077A68C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10077A6A0(uint64_t a1, uint64_t a2)
{
  id v4 = +[CLEEDRequest createRequestFromDict:baseURL:sessionID:partnerAdrPublicKeyData:deviceSessionPrivateKey:deviceSessionSecret:error:]( CLEEDRequest,  "createRequestFromDict:baseURL:sessionID:partnerAdrPublicKeyData:deviceSessionPrivateKey:deviceSessionSecret:error:",  *(void *)(a1 + 1832),  @"https://dummyURL",  [@"dummySessionID" dataUsingEncoding:4],  objc_msgSend(@"dummyPartnerAdrPublicKeyData", "dataUsingEncoding:", 4),  *(void *)(a1 + 1928),  objc_msgSend(@"dummyDeviceSessionSecretForPartner", "dataUsingEncoding:", 4),  v21);
  if (v4)
  {
    uint64_t v5 = v4;
    id v6 = v4;
    [v5 setState:a2];
    [v5 setRequestReceivedTime:CFAbsoluteTimeGetCurrent()];
    objc_msgSend( objc_msgSend(v5, "requestDate"),  "timeIntervalSinceDate:",  +[NSDate date](NSDate, "date"));
    [v5 setRequestTransmissionTime:(int)vcvtpd_s64_f64(fabs(v7) * 1000.0)];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [v5 requestDate];
      uint64_t v10 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
      id v11 = [v5 requestTransmissionTime];
      *(_DWORD *)__int128 buf = 138412802;
      id v29 = v9;
      __int16 v30 = 2112;
      __int128 v31 = v10;
      __int16 v32 = 2048;
      id v33 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleRequestRejection,request sent date:%@, request received date: %@, requestTransmissionTime:%ld milliseconds",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v13 = qword_101934898;
      id v14 = [v5 requestDate];
      uint64_t v15 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
      id v16 = [v5 requestTransmissionTime];
      int v22 = 138412802;
      id v23 = v14;
      __int16 v24 = 2112;
      int v25 = v15;
      __int16 v26 = 2048;
      id v27 = v16;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  0LL,  "#EED2,handleRequestRejection,request sent date:%@, request received date: %@, requestTransmissionTime:%ld milliseconds",  &v22,  32);
      int v18 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEmergencyEED2::handleRequestRejection(CLEEDRequestState)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }

    [*(id *)(a1 + 1896) addObject:v5];
    sub_10076ACC0(a1);
    sub_10076BCF8(a1);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#EED2,handleRequestRejection,CLEEDRequest could not be created. This should not happen",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v22) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,handleRequestRejection,CLEEDRequest could not be created. This should not happen",  &v22,  2);
      unsigned int v20 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEmergencyEED2::handleRequestRejection(CLEEDRequestState)",  "%s\n",  v19);
      if (v20 != buf) {
        free(v20);
      }
    }
  }

uint64_t sub_10077AAFC(uint64_t a1, void *a2)
{
  uint64_t v90 = 0LL;
  int v91 = &v90;
  uint64_t v92 = 0x2020000000LL;
  int v93 = -1;
  id v4 = *(void **)(a1 + 1888);
  v89[0] = _NSConcreteStackBlock;
  v89[1] = 3221225472LL;
  v89[2] = sub_10077BEE8;
  v89[3] = &unk_10184DE98;
  v89[4] = a2;
  v89[5] = &v90;
  [v4 enumerateObjectsUsingBlock:v89];
  if ((v91[3] & 0x80000000) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1888), "objectAtIndexedSubscript:", *((int *)v91 + 6)), "ID");
      *(_DWORD *)__int128 buf = 138543362;
      id v103 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#EED2,isDuplicateRequest,pending request:%{public}@ moved from fRequestsPending queue to fRequestsHandled queue",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v49 = qword_101934898;
      id v50 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1888), "objectAtIndexedSubscript:", *((int *)v91 + 6)), "ID");
      int v94 = 138543362;
      id v95 = v50;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  0LL,  "#EED2,isDuplicateRequest,pending request:%{public}@ moved from fRequestsPending queue to fRequestsHandled queue",  &v94,  12);
      uint64_t v52 = (uint8_t *)v51;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::isDuplicateRequest(CLEEDRequest *)", "%s\n", v51);
      if (v52 != buf) {
        free(v52);
      }
    }

    objc_msgSend(objc_msgSend(*(id *)(a1 + 1888), "objectAtIndexedSubscript:", *((int *)v91 + 6)), "setState:", 15);
    objc_msgSend( *(id *)(a1 + 1896),  "addObject:",  objc_msgSend(*(id *)(a1 + 1888), "objectAtIndex:", *((int *)v91 + 6)));
    [*(id *)(a1 + 1888) removeObjectAtIndex:*((int *)v91 + 6)];
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    double v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = [a2 ID];
      *(_DWORD *)__int128 buf = 138543362;
      id v103 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#EED2,isDuplicateRequest, Allow the new request:%{public}@ to be added to pending queue",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v53 = qword_101934898;
      id v54 = [a2 ID];
      int v94 = 138543362;
      id v95 = v54;
      LODWORD(v8_Block_object_dispose(va, 8) = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v53,  0LL,  "#EED2,isDuplicateRequest, Allow the new request:%{public}@ to be added to pending queue",  &v94,  v88);
      unsigned int v56 = (uint8_t *)v55;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyEED2::isDuplicateRequest(CLEEDRequest *)", "%s\n", v55);
      if (v56 != buf) {
        free(v56);
      }
    }

    uint64_t v9 = *(void *)(a1 + 2040);
    if (v9)
    {
      uint64_t v10 = 0LL;
      ++*(_DWORD *)(v9 + 64);
      goto LABEL_73;
    }

void sub_10077BC08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10077BC98(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7 = +[CLEEDRequest toCLEEDRequestType:]( CLEEDRequest,  "toCLEEDRequestType:",  [a2 valueForKey:@"capability"]);
  if (v7 == [*(id *)(a1 + 32) type])
  {
    if ((objc_msgSend( objc_msgSend(a2, "valueForKey:", @"status"),  "isEqualToString:",  @"supported") & 1) != 0 || objc_msgSend( objc_msgSend(a2, "valueForKey:", @"status"),  "isEqualToString:",  @"supported_nearby_device"))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = [*(id *)(a1 + 32) type];
        *(_DWORD *)__int128 buf = 134349056;
        id v17 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,handleAPNSMessage,requestType:%{public}ld is supported by device",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v10 = qword_101934898;
        id v11 = [*(id *)(a1 + 32) type];
        int v14 = 134349056;
        id v15 = v11;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  0LL,  "#EED2,handleAPNSMessage,requestType:%{public}ld is supported by device",  &v14,  12);
        uint64_t v13 = (uint8_t *)v12;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::handleAPNSMessage()_block_invoke", "%s\n", v12);
        if (v13 != buf) {
          free(v13);
        }
      }
    }

    *a4 = 1;
  }

void sub_10077BEE8(uint64_t a1, void *a2, int a3, _BYTE *a4)
{
  id v8 = [*(id *)(a1 + 32) type];
  if (v8 == [a2 type])
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [a2 ID];
      int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      id v12 = [*(id *)(a1 + 32) ID];
      id v13 = [*(id *)(a1 + 32) type];
      *(_DWORD *)__int128 buf = 138544130;
      id v30 = v10;
      __int16 v31 = 1026;
      int v32 = v11;
      __int16 v33 = 2114;
      id v34 = v12;
      __int16 v35 = 2050;
      id v36 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2,isDuplicateRequest,found pending request:%{public}@ at index:%{public}d that matches received request:%{pu blic}@ for request type:%{public}ld",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v14 = qword_101934898;
      id v15 = [a2 ID];
      int v16 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      id v17 = [*(id *)(a1 + 32) ID];
      id v18 = [*(id *)(a1 + 32) type];
      int v21 = 138544130;
      id v22 = v15;
      __int16 v23 = 1026;
      int v24 = v16;
      __int16 v25 = 2114;
      id v26 = v17;
      __int16 v27 = 2050;
      id v28 = v18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  0LL,  "#EED2,isDuplicateRequest,found pending request:%{public}@ at index:%{public}d that matches received request:%{pu blic}@ for request type:%{public}ld",  &v21,  38);
      uint64_t v20 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyEED2::isDuplicateRequest(CLEEDRequest *)_block_invoke",  "%s\n",  v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    *a4 = 1;
  }

id sub_10077C178(id *a1, int a2, void *a3, NSError **a4)
{
  uint64_t v29 = 0LL;
  id v30 = &v29;
  uint64_t v31 = 0x2020000000LL;
  int v32 = -1;
  id v8 = a1[237];
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472LL;
  _DWORD v28[2] = sub_10077C6BC;
  uint64_t v28[3] = &unk_10184DE98;
  v28[4] = a3;
  v28[5] = &v29;
  [v8 enumerateObjectsUsingBlock:v28];
  if ((v30[3] & 0x80000000) != 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v13 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      id v43 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#EED2,checkHandledQueueForDuplicateRequest,matching handled request not found for request:%{public}@, early return",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LODWORD(v37) = 138543362;
      *(void *)((char *)&v37 + 4) = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,checkHandledQueueForDuplicateRequest,matching handled request not found for request:%{public}@, early return",  &v37,  12);
      id v22 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::checkHandledQueueForDuplicateRequest(BOOL, NSUUID *, NSError **)",  "%s\n",  v21);
      if (v22 != buf) {
        free(v22);
      }
    }

    uint64_t v14 = objc_alloc(&OBJC_CLASS___NSError);
    NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
    id v41 = @"Request not found";
    id v15 =  -[NSError initWithDomain:code:userInfo:]( v14,  "initWithDomain:code:userInfo:",  @"com.apple.CoreLocation.CLEEDHelperService",  4LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL));
    id v12 = 0LL;
    *a4 = v15;
  }

  else
  {
    id v9 = objc_msgSend(a1[237], "objectAtIndex:");
    *(void *)&__int128 v37 = 0LL;
    *((void *)&v37 + 1) = &v37;
    uint64_t v38 = 0x2020000000LL;
    int v39 = -1;
    id v10 = a1[236];
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    _OWORD v27[2] = sub_10077C8CC;
    v27[3] = &unk_10184DE98;
    v27[4] = v9;
    v27[5] = &v37;
    [v10 enumerateObjectsUsingBlock:v27];
    if ((*(_DWORD *)(*((void *)&v37 + 1) + 24LL) & 0x80000000) != 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v16 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        id v17 = [v9 type];
        *(_DWORD *)__int128 buf = 134349056;
        id v43 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "#EED2,checkHandledQueueForDuplicateRequest,request of type:%{public}ld not found in fRequestsPending queue, early return",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v23 = qword_101934898;
        id v24 = [v9 type];
        int v35 = 134349056;
        id v36 = v24;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  16LL,  "#EED2,checkHandledQueueForDuplicateRequest,request of type:%{public}ld not found in fRequestsPending queue, early return",  &v35,  12);
        id v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEEDRequest *CLEmergencyEED2::checkHandledQueueForDuplicateRequest(BOOL, NSUUID *, NSError **)",  "%s\n",  v25);
        if (v26 != buf) {
          free(v26);
        }
      }

      id v18 = objc_alloc(&OBJC_CLASS___NSError);
      NSErrorUserInfoKey v33 = NSLocalizedDescriptionKey;
      id v34 = @"Request not found";
      id v19 =  -[NSError initWithDomain:code:userInfo:]( v18,  "initWithDomain:code:userInfo:",  @"com.apple.CoreLocation.CLEEDHelperService",  4LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v34,  &v33,  1LL));
      id v12 = 0LL;
      *a4 = v19;
    }

    else
    {
      id v11 = objc_msgSend(a1[236], "objectAtIndex:");
      if (v11)
      {
        id v12 = sub_10077CAFC(a1, v11, a2, a4);
        [a1[236] removeObjectAtIndex:*(int *)(*((void *)&v37 + 1) + 24)];
      }

      else
      {
        id v12 = 0LL;
      }
    }

    _Block_object_dispose(&v37, 8);
  }

  _Block_object_dispose(&v29, 8);
  return v12;
}

void sub_10077C678( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_10077C6BC(uint64_t a1, void *a2, int a3, _BYTE *a4)
{
  if (objc_msgSend(*(id *)(a1 + 32), "isEqual:", objc_msgSend(a2, "ID")))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(_DWORD *)__int128 buf = 138543618;
      uint64_t v19 = v8;
      __int16 v20 = 1026;
      int v21 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#EED2,checkHandledQueueForDuplicateRequest,found matching handled request for request ID:%{public}@ at index:%{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v10 = *(void *)(a1 + 32);
      int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      int v14 = 138543618;
      uint64_t v15 = v10;
      __int16 v16 = 1026;
      int v17 = v11;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,checkHandledQueueForDuplicateRequest,found matching handled request for request ID:%{public}@ at index:%{public}d",  &v14,  18);
      id v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::checkHandledQueueForDuplicateRequest(BOOL, NSUUID *, NSError **)_block_invoke",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    *a4 = 1;
  }

void sub_10077C8CC(uint64_t a1, void *a2, int a3, _BYTE *a4)
{
  id v8 = [*(id *)(a1 + 32) type];
  if (v8 == [a2 type])
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    int v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [a2 ID];
      int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(_DWORD *)__int128 buf = 138543618;
      id v22 = v10;
      __int16 v23 = 1026;
      int v24 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#EED2,checkHandledQueueForDuplicateRequest,found matching pending request with request ID:%{public}@ at index:%{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      uint64_t v12 = qword_101934898;
      id v13 = [a2 ID];
      int v14 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      int v17 = 138543618;
      id v18 = v13;
      __int16 v19 = 1026;
      int v20 = v14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  0LL,  "#EED2,checkHandledQueueForDuplicateRequest,found matching pending request with request ID:%{public}@ at index:%{public}d",  &v17,  18);
      __int16 v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::checkHandledQueueForDuplicateRequest(BOOL, NSUUID *, NSError **)_block_invoke",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    *a4 = 1;
  }

id sub_10077CAFC(id *a1, void *a2, int a3, void *a4)
{
  id v6 = a2;
  objc_msgSend(a2, "updateDurationInformationForCA:");
  switch((unint64_t)[v6 type])
  {
    case 0uLL:
    case 3uLL:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      id v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#EED2,updatePendingRequestForResponse,unknown Request Type. This is unexpected",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        LOWORD(v36) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,updatePendingRequestForResponse,unknown Request Type. This is unexpected",  &v36,  2);
        __int16 v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEEDRequest *CLEmergencyEED2::updatePendingRequestForResponse(CLEEDRequest *, BOOL, NSError **)",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }

      [a1[237] addObject:v6];
      NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
      int v35 = @"Unknown Request Type";
      id v6 = 0LL;
      *a4 =  -[NSError initWithDomain:code:userInfo:]( objc_alloc(&OBJC_CLASS___NSError),  "initWithDomain:code:userInfo:",  @"com.apple.CoreLocation.CLEEDHelperService",  4LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v35,  &v34,  1LL));
      return v6;
    case 1uLL:
      id v9 = a1[245];
      if (v9 && [v9 dropStreaming] && (a3 & 1) != 0)
      {
        uint64_t v10 = 17LL;
      }

      else
      {
        if ([v6 state] == (id)17) {
          goto LABEL_29;
        }
        if (a3) {
          uint64_t v10 = 1LL;
        }
        else {
          uint64_t v10 = 4LL;
        }
      }

      [v6 setState:v10];
LABEL_29:
      if (![v6 requestStatusAtFirstUserResponse]) {
        objc_msgSend(v6, "setRequestStatusAtFirstUserResponse:", objc_msgSend(v6, "state"));
      }
      if ([v6 state] == (id)17)
      {
        [a1[237] addObject:v6];
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        int v14 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          id v39 = [v6 ID];
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to requestsHandled queue",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v15 = qword_101934898;
          int v36 = 138543362;
          id v37 = [v6 ID];
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  0LL,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to requestsHandled queue",  &v36,  12);
          int v17 = (uint8_t *)v16;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::updatePendingRequestForResponse(CLEEDRequest *, BOOL, NSError **)",  "%s\n",  v16);
          if (v17 != buf) {
            free(v17);
          }
        }
      }

      else
      {
        a1[238] = v6;
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        id v18 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          id v19 = [a1[238] ID];
          *(_DWORD *)__int128 buf = 138543362;
          id v39 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to fCurrentStreamingRequest",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_10184E040);
          }
          uint64_t v30 = qword_101934898;
          id v31 = [a1[238] ID];
          int v36 = 138543362;
          id v37 = v31;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v30,  0LL,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to fCurrentStreamingRequest",  &v36,  12);
          NSErrorUserInfoKey v33 = (uint8_t *)v32;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::updatePendingRequestForResponse(CLEEDRequest *, BOOL, NSError **)",  "%s\n",  v32);
          if (v33 != buf) {
            free(v33);
          }
        }

        return a1[238];
      }

      return v6;
    case 2uLL:
      id v11 = v6;
      a1[239] = v11;
      if (!a1[245]
        || ((id v12 = [a1[245] uploadMigitation], v11 = a1[239], v12 == (id)1) ? (v13 = a3 == 0) : (v13 = 1),
            v13))
      {
        if ([v11 state] == (id)18) {
          goto LABEL_48;
        }
        if (a3) {
          uint64_t v20 = 1LL;
        }
        else {
          uint64_t v20 = 4LL;
        }
        id v11 = a1[239];
      }

      else
      {
        uint64_t v20 = 18LL;
      }

      [v11 setState:v20];
LABEL_48:
      if (![a1[239] requestStatusAtFirstUserResponse]) {
        objc_msgSend(a1[239], "setRequestStatusAtFirstUserResponse:", objc_msgSend(a1[239], "state"));
      }
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v21 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        id v22 = [a1[239] ID];
        *(_DWORD *)__int128 buf = 138543362;
        id v39 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to fCurrentUploadRequest",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        uint64_t v26 = qword_101934898;
        id v27 = [a1[239] ID];
        int v36 = 138543362;
        id v37 = v27;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#EED2,updatePendingRequestForResponse,request:%{public}@ found and moved from pending queue to fCurrentUploadRequest",  &v36,  12);
        uint64_t v29 = (uint8_t *)v28;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEEDRequest *CLEmergencyEED2::updatePendingRequestForResponse(CLEEDRequest *, BOOL, NSError **)",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }

      return a1[239];
    default:
      return 0LL;
  }

uint64_t sub_10077D278(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ([*(id *)(v3 + 1888) count])
  {
    id v4 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", *(void *)(v3 + 1888));
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v5 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138477827;
      uint64_t v15 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#EED2,pendingRequestCB,pending requests: %{private}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v12 = 138477827;
      BOOL v13 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,pendingRequestCB,pending requests: %{private}@",  &v12,  12);
      id v7 = (uint8_t *)v6;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#EED2,pendingRequestCB,No pending requests available",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(v12) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,pendingRequestCB,No pending requests available",  &v12,  2);
      id v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    id v4 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, NSSet *, void))(a2 + 16))(a2, v4, 0LL);
}

uint64_t sub_10077D594(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v3 + 1904);
    *(_DWORD *)__int128 buf = 138477827;
    uint64_t v13 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,streamingRequestCB,current streaming request:%{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v7 = *(void *)(v3 + 1904);
    int v10 = 138477827;
    uint64_t v11 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,streamingRequestCB,current streaming request:%{private}@",  &v10,  12);
    id v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  return (*(uint64_t (**)(uint64_t, void, void))(a2 + 16))(a2, *(void *)(v3 + 1904), 0LL);
}

uint64_t sub_10077D75C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  id v4 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v3 + 1912);
    *(_DWORD *)__int128 buf = 138477827;
    uint64_t v13 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#EED2,uploadRequestCB,current upload request:%{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    uint64_t v7 = *(void *)(v3 + 1912);
    int v10 = 138477827;
    uint64_t v11 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,uploadRequestCB,current upload request:%{private}@",  &v10,  12);
    id v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  return (*(uint64_t (**)(uint64_t, void, void))(a2 + 16))(a2, *(void *)(v3 + 1912), 0LL);
}

uint64_t sub_10077D924(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 1904LL);
  if (v5 && objc_msgSend(a2, "isEqual:", objc_msgSend(v5, "ID")))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#EED2,streamingEndCB,fCurrentStreamingRequest has ended",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      LOWORD(vsub_100708348(v2 - 16) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#EED2,streamingEndCB,fCurrentStreamingRequest has ended",  &v16,  2);
      uint64_t v13 = (uint8_t *)v12;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v12);
      if (v13 != buf) {
        free(v13);
      }
    }

    uint64_t v7 = 0LL;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_10184E040);
    }
    id v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138543362;
      id v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#EED2,streamingEndCB,request:%{public}@ does not match fCurrentStreamingRequest.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v16 = 138543362;
      int v17 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,streamingEndCB,request:%{public}@ does not match fCurrentStreamingRequest.",  &v16,  12);
      uint64_t v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::initializeHelperService()_block_invoke", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    uint64_t v15 = @"Streaming End for unavailable request Id";
    uint64_t v7 =  -[NSError initWithDomain:code:userInfo:]( objc_alloc(&OBJC_CLASS___NSError),  "initWithDomain:code:userInfo:",  @"com.apple.CoreLocation.CLEEDHelperService",  6LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL));
  }

  return (*(uint64_t (**)(uint64_t, NSError *))(a3 + 16))(a3, v7);
}