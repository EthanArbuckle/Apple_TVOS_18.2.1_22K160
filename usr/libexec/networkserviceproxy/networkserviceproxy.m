}

LABEL_37:
      LOBYTE(v43) = 0;
      goto LABEL_46;
    }
  }

  v41 = nplog_obj(v34, v35, v36);
  v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
  v31 = v42;
  if (v4)
  {
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      v119 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v19, "waldoInfo"));
      v120 = (void *)objc_claimAutoreleasedReturnValue([v119 locationToleranceDistance]);
      *(_DWORD *)buf = 134218242;
      v132 = v28;
      v133 = 2112;
      v134 = v120;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "Check Only: Location change (%f meters) exceeded tolerance (%@ meters)",  buf,  0x16u);
    }

    LOBYTE(v43) = 1;
  }

  else
  {
    v44 = v19;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v45 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v19, "waldoInfo"));
      v46 = (void *)objc_claimAutoreleasedReturnValue([v45 locationToleranceDistance]);
      *(_DWORD *)buf = 134218242;
      v132 = v28;
      v133 = 2112;
      v134 = v46;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Location change (%f meters) exceeded tolerance (%@ meters), sorting edges by distance",  buf,  0x16u);
    }

    v47 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v44, "waldoInfo"));
    v48 = (void *)objc_claimAutoreleasedReturnValue([v47 edges]);
    v125 = [v48 copy];

    v128 = 0u;
    v129 = 0u;
    v126 = 0u;
    v127 = 0u;
    v123 = v44;
    v49 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v44, "waldoInfo"));
    v50 = (void *)objc_claimAutoreleasedReturnValue([v49 edges]);

    v51 = [v50 countByEnumeratingWithState:&v126 objects:v130 count:16];
    if (v51)
    {
      v52 = v51;
      v53 = *(void *)v127;
      do
      {
        for (i = 0LL; i != v52; i = (char *)i + 1)
        {
          if (*(void *)v127 != v53) {
            objc_enumerationMutation(v50);
          }
          v55 = *(void **)(*((void *)&v126 + 1) + 8LL * (void)i);
          v56 = objc_alloc(&OBJC_CLASS___CLLocation);
          v57 = (void *)objc_claimAutoreleasedReturnValue([v55 location]);
          [v57 latitude];
          v59 = v58;
          v60 = (void *)objc_claimAutoreleasedReturnValue([v55 location]);
          [v60 longtitude];
          v62 = -[CLLocation initWithLatitude:longitude:](v56, "initWithLatitude:longitude:", v59, v61);

          [v6 distanceFromLocation:v62];
          objc_msgSend(v55, "setDistance:");
        }

        v52 = [v50 countByEnumeratingWithState:&v126 objects:v130 count:16];
      }

      while (v52);
    }

    v63 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    v64 = (void *)objc_claimAutoreleasedReturnValue([v63 edges]);
    v65 = (void *)objc_claimAutoreleasedReturnValue([v64 sortedArrayUsingSelector:"compareByDistance:"]);
    v66 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    [v66 setEdges:v65];

    v67 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    v68 = (void *)objc_claimAutoreleasedReturnValue([v67 edges]);
    v69 = [v68 count];

    if (v69)
    {
      v70 = 0LL;
      do
      {
        v71 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
        v72 = (void *)objc_claimAutoreleasedReturnValue([v71 edges]);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v72 objectAtIndexedSubscript:v70]);
        [v73 setIndex:v70];

        ++v70;
        v74 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
        v75 = (void *)objc_claimAutoreleasedReturnValue([v74 edges]);
        v76 = [v75 count];
      }

      while (v70 < (unint64_t)v76);
    }

    v77 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    v78 = [v77 probeSize];

    if (v78)
    {
      v79 = 0LL;
      do
      {
        v80 = (void *)objc_claimAutoreleasedReturnValue([v125 objectAtIndexedSubscript:v79]);
        v81 = (void *)objc_claimAutoreleasedReturnValue([v80 label]);
        v82 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
        v83 = (void *)objc_claimAutoreleasedReturnValue([v82 edges]);
        v84 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:v79]);
        v85 = (void *)objc_claimAutoreleasedReturnValue([v84 label]);
        v86 = [v81 isEqualToString:v85];

        if ((v86 & 1) == 0) {
          break;
        }
        ++v79;
        v87 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
        v88 = [v87 probeSize];
      }

      while (v79 < (unint64_t)v88);
      v43 = v86 ^ 1;
    }

    else
    {
      v43 = 0;
    }

    v97 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    v98 = (void *)objc_claimAutoreleasedReturnValue([v97 edges]);
    v99 = (void *)objc_claimAutoreleasedReturnValue([v98 objectAtIndexedSubscript:0]);

    v100 = objc_alloc(&OBJC_CLASS___NPLocation);
    v101 = (void *)objc_claimAutoreleasedReturnValue([v99 location]);
    [v101 latitude];
    v103 = v102;
    v104 = (void *)objc_claimAutoreleasedReturnValue([v99 location]);
    [v104 longtitude];
    v106 = v105;
    v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    v108 = [v100 initWithLatitude:v107 longtitude:v103 timestamp:v106];
    v109 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
    [v109 setCachedLocation:v108];

    v113 = nplog_obj(v110, v111, v112);
    v114 = (os_log_s *)objc_claimAutoreleasedReturnValue(v113);
    v115 = os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT);
    if (v43)
    {
      if (v115)
      {
        v116 = (void *)objc_claimAutoreleasedReturnValue([v99 label]);
        *(_DWORD *)buf = 138412290;
        v132 = *(double *)&v116;
        _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_DEFAULT,  "Location change resulted in new view, closet edge is %@",  buf,  0xCu);
      }

      v114 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](v123, "waldoInfo"));
      -[os_log_s linkLatenciesAllSignatures:](v114, "linkLatenciesAllSignatures:", 0LL);
    }

    else if (v115)
    {
      v117 = (void *)objc_claimAutoreleasedReturnValue([v99 label]);
      *(_DWORD *)buf = 138412290;
      v132 = *(double *)&v117;
      _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_DEFAULT,  "Location change resulted in same view, closet edge is %@",  buf,  0xCu);
    }

    v31 = (os_log_s *)v125;
  }
    }

LABEL_46:
  return v43;
}
}

LABEL_47:
          a1 = 0LL;
          goto LABEL_48;
        }
      }
    }

    else
    {
      v72 = nplog_obj(0LL, v38, v39);
      v73 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
      {
        v74 = *v6;
        v75 = (void *)objc_claimAutoreleasedReturnValue([v74 agentUUID]);
        *(_DWORD *)v114 = 138412546;
        v115 = a1;
        v116 = 2112;
        v117 = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_INFO,  "%@ registering bootstrap DNS network agent [%@]",  v114,  0x16u);
      }

      v76 = *(id *)(a1 + 56);
      v77 = *(id *)(a1 + 48);
      v78 = [v76 registerNetworkAgent:v77];

      if ((v78 & 1) == 0)
      {
        v99 = nplog_obj(v79, v80, v81);
        v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v99);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          v108 = *v6;
          v109 = (void *)objc_claimAutoreleasedReturnValue([v108 agentUUID]);
          *(_DWORD *)v114 = 138412546;
          v115 = a1;
          v116 = 2112;
          v117 = v109;
          _os_log_error_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "%@: failed to register bootstrap DNS network agent [%@]",  v114,  0x16u);
        }

        goto LABEL_46;
      }

      v82 = *(id *)(a1 + 56);
      v83 = [v82 isRegistered];

      if (v83)
      {
        v84 = objc_alloc(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
        v85 = *(id *)(a1 + 56);
        v86 = *(id *)(a1 + 48);
        v87 = (void *)objc_claimAutoreleasedReturnValue([v86 agentUUID]);
        v88 = *v6;
        v89 = (void *)objc_claimAutoreleasedReturnValue([v88 agentUUID]);
        v90 = [v84 initWithNetworkAgentRegistration:v85 sessionType:&off_1001033F8 configurationIdentifier:v87 agentUUID:v89];
        v91 = *(void **)(*(void *)&buf[8] + 40LL);
        *(void *)(*(void *)&buf[8] + 40LL) = v90;

        v92 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        v93 = *(void *)(*(void *)&buf[8] + 40LL);
        v112[0] = _NSConcreteStackBlock;
        v112[1] = 3221225472LL;
        v112[2] = sub_10004F0A0;
        v112[3] = &unk_1000F9370;
        v112[4] = a1;
        [v92 setFileHandle:v93 matchingPredicate:v112];

        v94 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        [v94 commit];
      }
    }

    a1 = 1LL;
LABEL_48:
    _Block_object_dispose(buf, 8);

    goto LABEL_49;
  }

  v22 = nplog_obj(v19, v20, v21);
  v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    v24 = *(id *)(a1 + 48);
    v25 = (void *)objc_claimAutoreleasedReturnValue([v24 agentUUID]);
    *(_DWORD *)buf = 138412546;
    *(void *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "%@ updating bootstrap DNS network agent with UUID %@",  buf,  0x16u);
  }

  v26 = *(void *)(a1 + 48);
  v27 = *(id *)(a1 + 56);
  LOBYTE(v26) = [v27 updateNetworkAgent:v26];

  if ((v26 & 1) != 0) {
    goto LABEL_17;
  }
  v31 = nplog_obj(v28, v29, v30);
  v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    v101 = *(id *)(a1 + 48);
    v102 = (void *)objc_claimAutoreleasedReturnValue([v101 agentUUID]);
    *(_DWORD *)buf = 138412546;
    *(void *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v102;
    _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "%@: failed to update the registered bootstrap DNS network agent [%@]",  buf,  0x16u);
  }

  a1 = 0LL;
LABEL_49:

  return a1;
}

        goto LABEL_47;
      }
    }

    goto LABEL_26;
  }

  if (v15 == 80)
  {
    v16 = *(void *)(v6 + 96) + 1LL;
    *(void *)(v6 + 96) = v16;
    if (v16 >= 3)
    {
      sub_100050418(v6, *(void **)(a1 + 32), 80, 4LL);
      *(void *)(v6 + 96) = 0LL;
    }

    v17 = (os_log_s *)*(id *)(v6 + 152);
    -[os_log_s setOdohAuthFailureCount:]( v17,  "setOdohAuthFailureCount:",  (char *)-[os_log_s odohAuthFailureCount](v17, "odohAuthFailureCount") + 1);
    goto LABEL_38;
  }

  v70 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.news.embedded-content",  0,  0);
  v71 = (void *)objc_claimAutoreleasedReturnValue(v70);
  if (v71) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v71);
  }

  if ((v21 & 0x800) == 0)
  {
LABEL_29:
    if ((v21 & 0x1000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_52;
  }

  -[NSPConfigurationStats setSafariMetricsEnabled:](v15, "setSafariMetricsEnabled:", 1LL);
  v13 = v15;
  if ((v12 & 0x20) == 0)
  {
LABEL_21:
    if ((v12 & 0x40) == 0) {
      goto LABEL_22;
    }
    goto LABEL_48;
  }

LABEL_19:
      LOBYTE(v4) = 0;
LABEL_20:

      return (char)v4;
    }

    v24 = (void *)objc_claimAutoreleasedReturnValue([v7 cachedLocation]);
    if ([v24 isValid])
    {
      v25 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
      v26 = (void *)objc_claimAutoreleasedReturnValue([v25 cachedLocation]);
      v27 = (void *)objc_claimAutoreleasedReturnValue([v26 timestamp]);
      [v27 timeIntervalSinceNow];
      v29 = fabs(v28);
      v30 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
      v31 = (void *)objc_claimAutoreleasedReturnValue([v30 locationTTL]);
      [v31 doubleValue];
      v33 = v32;

      if (v29 > v33)
      {
        v37 = nplog_obj(v34, v35, v36);
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          v39 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
          v40 = (void *)objc_claimAutoreleasedReturnValue([v39 cachedLocation]);
          v41 = (void *)objc_claimAutoreleasedReturnValue([v40 timestamp]);
          [v41 timeIntervalSinceNow];
          v43 = fabs(v42);
          v44 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
          v45 = (void *)objc_claimAutoreleasedReturnValue([v44 locationTTL]);
          v68 = 134218242;
          v69 = v43;
          v70 = 2112;
          v71 = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "Last valid location was timestamped %f seconds ago (threshold %@), exceeded TTL",  (uint8_t *)&v68,  0x16u);
        }

        v46 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
        v47 = (void *)objc_claimAutoreleasedReturnValue([v46 locationTTL]);
        v48 = (uint64_t)[v47 integerValue] / 10;

        v49 = -[NSDate initWithTimeIntervalSinceNow:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSinceNow:",  (double)v48);
        v50 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
        [v50 setLocationExpiration:v49];

        v54 = nplog_obj(v51, v52, v53);
        v9 = (void *)objc_claimAutoreleasedReturnValue(v54);
        if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT))
        {
          v55 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
          v56 = (void *)objc_claimAutoreleasedReturnValue([v55 locationExpiration]);
          v68 = 134218242;
          v69 = *(double *)&v48;
          v70 = 2112;
          v71 = v56;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v9,  OS_LOG_TYPE_DEFAULT,  "Expiring cached location in %ld seconds at (%@)",  (uint8_t *)&v68,  0x16u);
        }

        goto LABEL_19;
      }
    }

    else
    {
    }

    v57 = nplog_obj(v34, v35, v36);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v57);
    if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEBUG))
    {
      v61 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
      v62 = (void *)objc_claimAutoreleasedReturnValue([v61 cachedLocation]);
      v63 = (void *)objc_claimAutoreleasedReturnValue([v62 timestamp]);
      [v63 timeIntervalSinceNow];
      v65 = fabs(v64);
      v66 = (void *)objc_claimAutoreleasedReturnValue(-[NPWaldoLocationManager waldoInfo](self, "waldoInfo"));
      v67 = (void *)objc_claimAutoreleasedReturnValue([v66 locationTTL]);
      v68 = 134218242;
      v69 = v65;
      v70 = 2112;
      v71 = v67;
      _os_log_debug_impl( (void *)&_mh_execute_header,  (os_log_t)v9,  OS_LOG_TYPE_DEBUG,  "Last valid location was timestamped %f seconds ago (threshold %@), within TTL",  (uint8_t *)&v68,  0x16u);
    }

    goto LABEL_19;
  }

  return (char)v4;
}

    goto LABEL_15;
  }

  v46.receiver = a1;
  v46.super_class = (Class)&OBJC_CLASS___NSPPrivacyProxyTokenRegistration;
  v13 = (id *)objc_msgSendSuper2(&v46, "init");
  a1 = v13;
  if (v13)
  {
    objc_storeWeak(v13 + 1, v12);
    v14 = sub_100043720((id *)objc_alloc(&OBJC_CLASS___NSPPrivacyProxyTokenAgent), a1, v7, v8);
    v15 = a1[2];
    a1[2] = v14;

    v16 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyTokenAgent));
    v17 = a1[3];
    a1[3] = v16;

    if (a1[2])
    {
      v21 = a1[3] == 0LL;
      v22 = nplog_obj(v18, v19, v20);
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      v24 = v23;
      if (!v21)
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "Looking for existing proxy agent registration for %@",  (uint8_t *)&buf,  0xCu);
        }

        *(void *)&buf = 0LL;
        *((void *)&buf + 1) = &buf;
        v50 = 0x3032000000LL;
        v51 = sub_100005D20;
        v52 = sub_100005D30;
        v53 = 0LL;
        v25 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        v40 = _NSConcreteStackBlock;
        v41 = 3221225472LL;
        v42 = sub_100005D38;
        v43 = &unk_1000F92F8;
        v44 = v7;
        p_buf = &buf;
        [v25 iterateFileHandlesWithBlock:&v40];

        if (!*(void *)(*((void *)&buf + 1) + 40LL)) {
          goto LABEL_13;
        }
        v29 = nplog_obj(v26, v27, v28);
        v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v47 = 138412290;
          v48 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "Found existing proxy registration for %@",  v47,  0xCu);
        }

        v31 = (unint64_t)objc_msgSend(*(id *)(*((void *)&buf + 1) + 40), "agentFlags", v40, v41, v42, v43);
        v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&buf + 1) + 40) agentUUID]);
        [a1[2] setAgentUUID:v32];

        [a1[2] setActive:v31 & 1];
        [a1[2] setVoluntary:(v31 >> 1) & 1];
        [a1[2] setUserActivated:(v31 >> 2) & 1];
        [a1[2] setKernelActivated:(v31 >> 3) & 1];
        v33 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&buf + 1) + 40) handle]);
        v34 = dup((int)[v33 fileDescriptor]);

        if ([a1[3] setRegisteredNetworkAgent:a1[2] fileDescriptor:v34])
        {
LABEL_13:

          _Block_object_dispose(&buf, 8);
          goto LABEL_16;
        }

        close(v34);

        _Block_object_dispose(&buf, 8);
LABEL_15:
        a1 = 0LL;
        goto LABEL_16;
      }

      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%s called with null _tokenAgentRegistration",  (uint8_t *)&buf,  0xCu);
      }
    }

    else
    {
      v39 = nplog_obj(v18, v19, v20);
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v39);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%s called with null _tokenAgent",  (uint8_t *)&buf,  0xCu);
      }
    }

    goto LABEL_15;
  }
}

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

    [v16 removeObjectAtIndex:0];
    if (a4) {
      *a4 = [v16 count];
    }
    sub_10003F488((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v16, v14);
    v36 = nplog_obj(v33, v34, v35);
    v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      v41 = 138412290;
      v42 = (const char *)v14;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEBUG,  "Received cached token from keychain for %@",  (uint8_t *)&v41,  0xCu);
    }

    v23 = v23;
    v20 = v23;
    goto LABEL_28;
  }

  v40 = nplog_obj(v9, v10, v11);
  v14 = (void *)objc_claimAutoreleasedReturnValue(v40);
  if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_FAULT))
  {
    v41 = 136315138;
    v42 = "+[NSPPrivateAccessTokenCache copyTokenFromCacheForChallenge:tokenKey:tokensRemaining:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v14,  OS_LOG_TYPE_FAULT,  "%s called with null challenge",  (uint8_t *)&v41,  0xCu);
  }

  v20 = 0LL;
LABEL_31:

  return v20;
}

      return;
    }

    if (v9)
    {
      v10 = nplog_obj(v9, v6, v7, v8);
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v12 = "DNS proxy already running, not starting again";
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
        goto LABEL_19;
      }

      goto LABEL_19;
    }

    v19 = mrc_dns_proxy_parameters_create(&v44);
    v11 = (os_log_s *)v19;
    if (v44 || !v19)
    {
      v34 = nplog_obj(v19, v20, v21, v22);
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v46 = v44;
        v32 = "Unable to create DNS proxy parameters - %d";
        goto LABEL_24;
      }
    }

    else
    {
      v23 = if_nametoindex("lo0");
      mrc_dns_proxy_parameters_add_input_interface(v11, v23);
      v24 = mrc_dns_proxy_create(v11, &v44);
      v25 = *(void **)(a1 + 8);
      *(void *)(a1 + 8) = v24;

      if (!v44)
      {
        v35 = mrc_dns_proxy_set_event_handler(*(void *)(a1 + 8), &stru_1000F9DB8);
        v36 = *(void *)(a1 + 8);
        v37 = NPGetInternalQueue(v35);
        v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
        mrc_dns_proxy_set_queue(v36, v38);

        v39 = mrc_dns_proxy_activate(*(void *)(a1 + 8));
        v43 = nplog_obj(v39, v40, v41, v42);
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v46 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "DNS proxy request to start on lo0 (index %d)",  buf,  8u);
        }

        goto LABEL_18;
      }

      v30 = nplog_obj(v26, v27, v28, v29);
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v46 = v44;
        v32 = "Unable to create DNS proxy - %d";
LABEL_24:
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v32, buf, 8u);
      }
    }

    goto LABEL_15;
  }

  v50.receiver = a1;
  v50.super_class = (Class)&OBJC_CLASS___NSPPrivacyProxyNetworkRegistration;
  v16 = (id *)objc_msgSendSuper2(&v50, "init");
  a1 = v16;
  if (v16)
  {
    objc_storeWeak(v16 + 1, v15);
    v17 = sub_1000432E4((id *)objc_alloc(&OBJC_CLASS___NSPPrivacyProxyConfigAgent), a1, v9, v11);
    v18 = a1[2];
    a1[2] = v17;

    v19 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyConfigAgent));
    v20 = a1[3];
    a1[3] = v19;

    if (a1[2])
    {
      v24 = a1[3] == 0LL;
      v25 = nplog_obj(v21, v22, v23);
      v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
      v27 = v26;
      if (!v24)
      {
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v11;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "Looking for existing proxy agent registration for %@",  (uint8_t *)&buf,  0xCu);
        }

        *(void *)&buf = 0LL;
        *((void *)&buf + 1) = &buf;
        v56 = 0x3032000000LL;
        v57 = sub_100044CA8;
        v58 = sub_100044CB8;
        v59 = 0LL;
        v28 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        v44 = _NSConcreteStackBlock;
        v45 = 3221225472LL;
        v46 = sub_100044CC0;
        v47 = &unk_1000F92F8;
        v29 = v9;
        v48 = v29;
        p_buf = &buf;
        [v28 iterateFileHandlesWithBlock:&v44];

        if (!*(void *)(*((void *)&buf + 1) + 40LL)) {
          goto LABEL_13;
        }
        v33 = nplog_obj(v30, v31, v32);
        v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v51 = 138412546;
          v52 = v11;
          v53 = 2112;
          v54 = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_INFO,  "Found existing proxy registration for %@ (%@)",  v51,  0x16u);
        }

        v35 = (unint64_t)objc_msgSend(*(id *)(*((void *)&buf + 1) + 40), "agentFlags", v44, v45, v46, v47);
        v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&buf + 1) + 40) agentUUID]);
        [a1[2] setAgentUUID:v36];

        [a1[2] setActive:v35 & 1];
        [a1[2] setVoluntary:(v35 >> 1) & 1];
        [a1[2] setUserActivated:(v35 >> 2) & 1];
        [a1[2] setKernelActivated:(v35 >> 3) & 1];
        v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&buf + 1) + 40) handle]);
        v38 = dup((int)[v37 fileDescriptor]);

        if ([a1[3] setRegisteredNetworkAgent:a1[2] fileDescriptor:v38])
        {
LABEL_13:

          _Block_object_dispose(&buf, 8);
          goto LABEL_16;
        }

        close(v38);

        _Block_object_dispose(&buf, 8);
LABEL_15:
        a1 = 0LL;
        goto LABEL_16;
      }

      if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "%s called with null _proxyConfigAgentRegistration",  (uint8_t *)&buf,  0xCu);
      }
    }

    else
    {
      v43 = nplog_obj(v21, v22, v23);
      v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "%s called with null _proxyConfigAgent",  (uint8_t *)&buf,  0xCu);
      }
    }

    goto LABEL_15;
  }

        if (v5)
        {
          v22 = (os_log_s *)objc_claimAutoreleasedReturnValue([v5 domain]);
          if ((-[os_log_s isEqualToString:](v22, "isEqualToString:", NSURLErrorDomain) & 1) != 0)
          {
            if ([v5 code] == (id)-1009) {
              goto LABEL_27;
            }
            v30 = [v5 code];

            if (v30 == (id)-1005LL) {
              goto LABEL_34;
            }
          }

          else
          {
          }
        }

        v32 = *(void *)(a1 + 48);
        if (v32 && (*(_BYTE *)(v32 + 13) = 1, (v33 = *(void *)(a1 + 48)) != 0))
        {
          objc_storeStrong((id *)(v33 + 296), *(id *)(a1 + 64));
          v34 = *(void **)(a1 + 48);
          if (v34)
          {
            v35 = v34[7];
LABEL_33:
            [v34 policiesUpdated:v35 policy:0 resolverInfoChanged:0];
            sub_1000679B4(*(void *)(a1 + 48));
            goto LABEL_34;
          }
        }

        else
        {
          v34 = 0LL;
        }

        v35 = 0LL;
        goto LABEL_33;
      }

      [v12[10] removeObject:*(void *)(a1 + 32)];
    }

    if ((a2 & 1) != 0)
    {
      v16 = v12[5];
      v17 = (void *)objc_claimAutoreleasedReturnValue([v16 etag]);
      v18 = [v17 isEqualToString:*(void *)(a1 + 40)];

      if (v18)
      {
        switch(*(void *)(a1 + 96))
        {
          case 1LL:
            v22 = objc_alloc_init(&OBJC_CLASS___NSPPrivateRelayIncompatibleNetworkStats);
            v23 = *(void *)(a1 + 48);
            if (v23) {
              v24 = *(void **)(v23 + 40);
            }
            else {
              v24 = 0LL;
            }
            v25 = (void *)objc_claimAutoreleasedReturnValue([v24 userTier]);
            v26 = [v25 intValue];
            if (v26 >= 3) {
              v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v26));
            }
            else {
              v27 = *(&off_1000FA520 + (int)v26);
            }
            -[os_log_s setTierType:](v22, "setTierType:", v27);

            if ([*(id *)(a1 + 56) type] == (id)1)
            {
              v39 = v12[9];
              v40 = sub_10006DBCC((uint64_t)v12);
              v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
              [v39 reportBlockedOnWiFiName:v41];

              v42 = @"WiFi";
            }

            else if ([*(id *)(a1 + 56) type] == (id)2)
            {
              v42 = @"Cell";
            }

            else
            {
              sub_10006DC38((uint64_t)v12, *(void **)(a1 + 56));
              v42 = @"Wired";
            }

            -[os_log_s setInterfaceType:](v22, "setInterfaceType:", v42);
            -[os_log_s sendAnalytics](v22, "sendAnalytics");
            goto LABEL_27;
          case 2LL:
            [v12 proxyConnectivityOutage];
            break;
          case 4LL:
            sub_10006DCB0((uint64_t)v12, 0LL, v21);
            break;
          case 5LL:
            sub_10006DEFC((uint64_t)v12, 0LL, v21);
            break;
          default:
            goto LABEL_34;
        }

        goto LABEL_34;
      }

      v31 = nplog_obj(v19, v20, v21);
      v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        v29 = "Proxy configuration changed, ignore reporting any errors";
        goto LABEL_26;
      }

      goto LABEL_27;
    }

    goto LABEL_19;
  }

  if (v12)
  {
LABEL_20:
    v29 = nplog_obj(v20, v21, v22);
    v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = *(void *)(a1 + 40);
      v64 = 138412546;
      v65 = v12;
      v66 = 2112;
      v67 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Received error %@ for %@",  (uint8_t *)&v64,  0x16u);
    }

    v32 = (void *)objc_claimAutoreleasedReturnValue([v12 domain]);
    if ([v32 isEqualToString:NSURLErrorDomain])
    {
      v33 = [v12 code];

      if (v33 == (id)-999LL)
      {
        v34 = *(void (**)(void))(*(void *)(a1 + 48) + 16LL);
LABEL_30:
        v34();
        v36 = objc_alloc_init(&OBJC_CLASS___NSPConfigurationFetchAnalytics);
        v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) absoluteString]);
        -[NSPConfigurationFetchAnalytics setConfigFetchURL:](v36, "setConfigFetchURL:", v41);

        -[NSPConfigurationFetchAnalytics setRequestedServerUUID:](v36, "setRequestedServerUUID:", 0LL);
        -[NSPConfigurationFetchAnalytics setHttpCode:](v36, "setHttpCode:", 0LL);
        v42 = (void *)objc_claimAutoreleasedReturnValue([v12 domain]);
        v43 = [v42 isEqualToString:NSURLErrorDomain];

        if (v43) {
          -[NSPConfigurationFetchAnalytics setNsurlErrorCode:](v36, "setNsurlErrorCode:", [v12 code]);
        }
        v44 = sub_100090A64((uint64_t)&OBJC_CLASS___NSPConfigurationManager, *(void *)(a1 + 56));
        v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
        -[NSPConfigurationFetchAnalytics setReason:](v36, "setReason:", v45);

        -[NSPProxyAnalytics sendAnalytics](v36, "sendAnalytics");
LABEL_46:

        goto LABEL_47;
      }
    }

    else
    {
    }

    v34 = *(void (**)(void))(*(void *)(a1 + 48) + 16LL);
    goto LABEL_30;
  }

  v35 = objc_opt_class(v13[105]);
  if ((objc_opt_isKindOfClass(v11, v35) & 1) != 0)
  {
    v36 = (NSPConfigurationFetchAnalytics *)v11;
    has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.networkserviceproxy");
    if ((_DWORD)has_internal_diagnostics)
    {
      has_internal_diagnostics = objc_claimAutoreleasedReturnValue( -[NSPConfigurationFetchAnalytics valueForHTTPHeaderField:]( v36,  "valueForHTTPHeaderField:",  @"x-apple-request-uuid"));
      v40 = (void *)has_internal_diagnostics;
    }

    else
    {
      v40 = 0LL;
    }

    v46 = nplog_obj(has_internal_diagnostics, v38, v39);
    v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v48 = -[NSPConfigurationFetchAnalytics statusCode](v36, "statusCode");
      v49 = *(void *)(a1 + 40);
      v64 = 134218498;
      v65 = v48;
      v66 = 2112;
      v67 = v49;
      v68 = 2112;
      v69 = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Received HTTP response code %ld for %@ with request UUID %@",  (uint8_t *)&v64,  0x20u);
    }

    if (-[NSPConfigurationFetchAnalytics statusCode](v36, "statusCode") == (id)200)
    {
      v50 = (void *)objc_claimAutoreleasedReturnValue( -[NSPConfigurationFetchAnalytics valueForHTTPHeaderField:]( v36,  "valueForHTTPHeaderField:",  @"Etag"));
      v51 = (void *)objc_claimAutoreleasedReturnValue( -[NSPConfigurationFetchAnalytics valueForHTTPHeaderField:]( v36,  "valueForHTTPHeaderField:",  @"proxy-config-epoch"));
      v52 = v51;
      else {
        v54 = &off_100103908;
      }
      v55 = v9;
      (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    }

    else
    {
      v55 = v9;
      (*(void (**)(void, BOOL, void, void, void, void))(*(void *)(a1 + 48) + 16LL))( *(void *)(a1 + 48),  -[NSPConfigurationFetchAnalytics statusCode](v36, "statusCode") == (id)304,  0LL,  0LL,  0LL,  0LL);
    }

    v56 = mach_absolute_time();
    v57 = objc_alloc_init(&OBJC_CLASS___NSPConfigurationFetchAnalytics);
    v58 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) absoluteString]);
    -[NSPConfigurationFetchAnalytics setConfigFetchURL:](v57, "setConfigFetchURL:", v58);

    v59 = (void *)objc_claimAutoreleasedReturnValue( -[NSPConfigurationFetchAnalytics valueForHTTPHeaderField:]( v36,  "valueForHTTPHeaderField:",  @"x-apple-request-uuid"));
    -[NSPConfigurationFetchAnalytics setRequestedServerUUID:](v57, "setRequestedServerUUID:", v59);

    -[NSPConfigurationFetchAnalytics setHttpCode:]( v57,  "setHttpCode:",  -[NSPConfigurationFetchAnalytics statusCode](v36, "statusCode"));
    v60 = (void *)objc_claimAutoreleasedReturnValue([0 domain]);
    v61 = [v60 isEqualToString:NSURLErrorDomain];

    if (v61) {
      -[NSPConfigurationFetchAnalytics setNsurlErrorCode:](v57, "setNsurlErrorCode:", [0 code]);
    }
    -[NSPConfigurationFetchAnalytics setLatency:]( v57,  "setLatency:",  *(double *)&qword_1001171E8 * (double)(v56 - *(void *)(a1 + 64)));
    v62 = sub_100090A64((uint64_t)&OBJC_CLASS___NSPConfigurationManager, *(void *)(a1 + 56));
    v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
    -[NSPConfigurationFetchAnalytics setReason:](v57, "setReason:", v63);

    -[NSPProxyAnalytics sendAnalytics](v57, "sendAnalytics");
    v9 = v55;
    goto LABEL_46;
  }

id *sub_100005814(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  v12 = v9;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v7)
  {
    uint64_t v36 = nplog_obj(v9, v10, v11);
    v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "%s called with null agentUUID",  (uint8_t *)&buf,  0xCu);
    }

    goto LABEL_19;
  }

  if (!v8)
  {
    uint64_t v38 = nplog_obj(v9, v10, v11);
    v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "%s called with null agentDescription",  (uint8_t *)&buf,  0xCu);
    }

LABEL_16:
  return a1;
}

  uint64_t v20 = *(void *)(a1 + 56);
  BOOL v21 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
  isKindOfClass = objc_opt_isKindOfClass(v20, v21);
  if ((isKindOfClass & 1) != 0)
  {
    v25 = nplog_obj(isKindOfClass, v23, v24);
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    uint64_t v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);

    if (v27)
    {
      unint64_t v31 = nplog_obj(v28, v29, v30);
      v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        id v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) allHeaderFields]);
        *(_DWORD *)__int128 buf = 138412290;
        objc_super v46 = v44;
        _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "Got response headers: %@", buf, 0xCu);
      }
    }

    if (!*(void *)(a1 + 32))
    {
      v33 = *(void **)(a1 + 48);
      if (v33)
      {
        if (objc_getProperty(v33, v29, 48LL, 1))
        {
          v35 = *(id *)(a1 + 48);
          if (v35) {
            v35 = objc_getProperty(v35, v34, 48LL, 1);
          }
          uint64_t v36 = *(void *)(a1 + 40);
          v37 = *(void **)(a1 + 56);
          uint64_t v38 = v35;
          [v38 appendFormat:@"SUCCESS %@ %ld\n", v36, objc_msgSend(v37, "statusCode")];
        }
      }
    }
  }

  uint64_t v39 = *(void *)(*(void *)(a1 + 88) + 8LL);
  v40 = *(void **)(v39 + 40);
  *(void *)(v39 + 40) = 0LL;

  (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
  return (*(uint64_t (**)(void))(*(void *)(a1 + 80) + 16LL))();
}

  if (v23 && xpc_get_type(v23) == (xpc_type_t)&_xpc_type_string && (string_ptr = xpc_string_get_string_ptr(v23)) != 0LL) {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", string_ptr));
  }
  else {
    uint64_t v22 = 0LL;
  }

  if (v22)
  {
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
    [v26 reportActivityForApp:v22 path:0];
  }

  id v8 = v20;
  v12 = v59;
LABEL_22:
  if ((v6 & 0xFFFF0000) != 0xFF0000)
  {
    v33 = nplog_obj(v9, v10, v11);
    uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      if (!v21) {
        BOOL v21 = "none";
      }
      v35 = sub_100044D90(v8);
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
      v37 = (void *)objc_claimAutoreleasedReturnValue([v60 interfaceName]);
      *(_DWORD *)__int128 buf = 67110146;
      *(_DWORD *)&buf[4] = v6;
      *(_WORD *)v62 = 2080;
      *(void *)&v62[2] = v21;
      v63 = 2112;
      v64 = v22;
      v65 = 2112;
      v66 = v36;
      v67 = 2112;
      v68 = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received error (%d) from %s (%@) for %@ agent on interface %@",  buf,  0x30u);
    }

    uint64_t v38 = (id *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath multiHopRegistration](self, "multiHopRegistration"));
    if (v38 == v8)
    {
      v40 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](self, "networkMultiHopAgentStatistics"));
    }

    else
    {
      uint64_t v39 = (id *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath singleHopRegistration](self, "singleHopRegistration"));

      if (v39 != v8)
      {
        unint64_t v31 = 0LL;
        goto LABEL_39;
      }

      v40 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](self, "networkSingleHopAgentStatistics"));
    }

    unint64_t v31 = v40;
LABEL_39:
    uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "interface", v59));
    v42 = [v41 type];

    if (v42 == (id)1)
    {
      v43 = v8;
      id v44 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v13);
      v45 = (void *)objc_claimAutoreleasedReturnValue([v44 objectForKeyedSubscript:@"Signature"]);
      if (v31) {
        objc_super v46 = *(void **)(v31 + 8);
      }
      else {
        objc_super v46 = 0LL;
      }
      v47 = objc_claimAutoreleasedReturnValue([v46 objectForKeyedSubscript:@"Signature"]);
      id v48 = (void *)v47;
      if (v45)
      {
        if (v47)
        {
          v49 = [v45 isEqual:v47];
          if ((v49 & 1) == 0)
          {
            v57 = nplog_obj(v49, v50, v51);
            v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "ignore error, network signature does not match",  buf,  2u);
            }

            id v8 = v43;
            goto LABEL_28;
          }
        }
      }

      id v8 = v43;
    }

    if ((int)v6 <= 1099)
    {
      if ((int)v6 > 0)
      {
        switch((int)v6)
        {
          case '<':
            if (v31) {
              ++*(void *)(v31 + 24);
            }
            id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
            v54 = v53;
            v55 = 60LL;
            goto LABEL_63;
          case '=':
            if (v31) {
              ++*(void *)(v31 + 32);
            }
            id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
            v54 = v53;
            v55 = 61LL;
            goto LABEL_63;
          case '>':
          case '?':
            goto LABEL_94;
          case '@':
            if (v31) {
              ++*(void *)(v31 + 40);
            }
            goto LABEL_28;
          case 'A':
            if (v31) {
              ++*(void *)(v31 + 48);
            }
            goto LABEL_28;
          default:
            if ((_DWORD)v6 != 1) {
              goto LABEL_94;
            }
            goto LABEL_28;
        }
      }

      if ((v6 + 65568) <= 0x1E)
      {
        if (((1 << (v6 + 32)) & 0x4004C000) != 0)
        {
          if (v31) {
            ++*(void *)(v31 + 72);
          }
          goto LABEL_62;
        }

        if ((_DWORD)v6 == -65568)
        {
          if (v31) {
            ++*(void *)(v31 + 64);
          }
          id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
          v54 = v53;
          v55 = 4294901728LL;
          goto LABEL_63;
        }
      }

      if (!(_DWORD)v6)
      {
        if (v31)
        {
          *(void *)(v31 + 120) = 0LL;
          *(_OWORD *)(v31 + 104) = 0u;
          *(_OWORD *)(v31 + 88) = 0u;
          *(_OWORD *)(v31 + 72) = 0u;
          *(_OWORD *)(v31 + 56) = 0u;
          *(_OWORD *)(v31 + 40) = 0u;
          *(_OWORD *)(v31 + 24) = 0u;
          *(void *)(v31 + 16) = 1LL;
        }

        v54 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
        v32 = v60;
        [v54 reportProxySuccessOnInterface:v60 proxyPath:self];
        goto LABEL_64;
      }

      goto LABEL_94;
    }

    if ((int)v6 > 1199)
    {
      if ((v6 - 1200) > 7)
      {
LABEL_75:
        if ((_DWORD)v6 == 1301)
        {
          if (v31) {
            ++*(void *)(v31 + 112);
          }
          id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
          v54 = v53;
          v55 = 1301LL;
          goto LABEL_63;
        }

        if ((_DWORD)v6 == 1302)
        {
          if (v31) {
            ++*(void *)(v31 + 120);
          }
          id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
          v54 = v53;
          v55 = 1302LL;
          goto LABEL_63;
        }

        goto LABEL_94;
      }

      v52 = 1 << (v6 + 80);
      if ((v52 & 0x51) == 0)
      {
        if ((v52 & 0xA2) != 0)
        {
          if (v31) {
            ++*(void *)(v31 + 96);
          }
LABEL_62:
          id v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
          v54 = v53;
          v55 = v6;
LABEL_63:
          v32 = v60;
          [v53 reportProxyError:v55 interface:v60 proxyPath:self];
LABEL_64:

          goto LABEL_65;
        }

        goto LABEL_75;
      }

  return a1;
}

      if (!self)
      {
        v23 = [0 containsObject:v10];
        interfacesBeingChecked = 0LL;
        goto LABEL_23;
      }

      v23 = -[NSMutableSet containsObject:](self->_interfacesBeingChecked, "containsObject:", v10);
      if (!(_DWORD)v23)
      {
        interfacesBeingChecked = self->_interfacesBeingChecked;
LABEL_23:
        -[NSMutableSet addObject:](interfacesBeingChecked, "addObject:", v10);
        goto LABEL_24;
      }

  return v4;
}

      -[NSMutableArray addObject:](v10, "addObject:", v18);
      id v17 = (char *)v17 + 1;
    }

    while (v14 != v17);
    v14 = [v11 countByEnumeratingWithState:&v38 objects:v42 count:16];
  }

  while (v14);

  self = v33;
  v13 = &AnalyticsSendEventLazy_ptr;
  if ((v16 & 1) != 0)
  {
LABEL_22:
    uint64_t v28 = objc_alloc(&OBJC_CLASS___PrivacyProxyAppStatus);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v13[96] now]);
    v30 = [v28 initWithStatus:v9 bundleID:v8 path:v35 activeDate:v29];

    -[NSMutableArray addObject:](v10, "addObject:", v30);
    goto LABEL_23;
  }

  if ((v34 & 1) == 0)
  {
    uint64_t v27 = 0;
    goto LABEL_26;
  }

    v16 = 0LL;
    goto LABEL_6;
  }

  v16 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  v25 = __rev16([v7 tokenType]);
  -[NSMutableData appendBytes:length:](v16, "appendBytes:length:", &v25, 2LL);
  -[NSMutableData appendData:](v16, "appendData:", v8);
  *(_OWORD *)md = 0u;
  uint64_t v29 = 0u;
  id v17 = (void *)objc_claimAutoreleasedReturnValue([v7 challengeData]);
  CC_SHA256([v17 bytes], (CC_LONG)objc_msgSend(v17, "length"), md);
  -[NSMutableData appendBytes:length:](v16, "appendBytes:length:", md, 32LL);
  *(_OWORD *)uint64_t v26 = 0u;
  uint64_t v27 = 0u;
  CC_SHA256([v9 bytes], (CC_LONG)objc_msgSend(v9, "length"), v26);
  -[NSMutableData appendBytes:length:](v16, "appendBytes:length:", v26, 32LL);

LABEL_6:
  return v16;
}

        uint64_t v18 = v13;
        goto LABEL_17;
      }

void sub_100005CF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100005D20(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100005D30(uint64_t a1)
{
}

uint64_t sub_100005D38(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_6;
  }
  v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
  unsigned int v6 = [v5 isEqual:&off_1001032F0];
  if (v6)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
    unsigned int v8 = [v7 isEqual:*(void *)(a1 + 32)];

    if (v8)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v10 = v3;
      v5 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v10;
      goto LABEL_5;
    }

LABEL_6:
    uint64_t v11 = 1LL;
    goto LABEL_7;
  }

    v12 = 1LL;
    goto LABEL_7;
  }

    uint64_t v11 = 1LL;
    goto LABEL_7;
  }

    v6[2](v6, 0LL);
    goto LABEL_7;
  }

  v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSPDeviceIdentityCertificate sharedDeviceIdentity]( &OBJC_CLASS___NSPDeviceIdentityCertificate,  "sharedDeviceIdentity"));
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_1000A7D94;
  v17[3] = &unk_1000FAED0;
  uint64_t v18 = v6;
  [v13 signData:v5 andFetchDeviceIdentityCertificate:v17];

LABEL_7:
}

  v25 = 0LL;
LABEL_7:

  return v25;
}

LABEL_5:
  uint64_t v11 = v6 ^ 1;
LABEL_7:

  return v11;
}

  v12 = v6 ^ 1;

LABEL_7:
  return v12;
}

  self->_geohashSharingEnabled = v4;
  -[NSPPrivacyProxyAgentManager setGeohashOverride:](self, "setGeohashOverride:", v6);
  -[NSPProxyPath updateGeohashSharing:](self->_fallbackProxyPath, "updateGeohashSharing:", v4);
  -[NSPProxyPath updateGeohashSharing:](self->_quicProxyPath, "updateGeohashSharing:", v4);
  uint64_t v20 = 0u;
  BOOL v21 = 0u;
  uint64_t v18 = 0u;
  uint64_t v19 = 0u;
  preferredQUICProxyPaths = self->_preferredQUICProxyPaths;
LABEL_6:
  id v10 = preferredQUICProxyPaths;
  uint64_t v11 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v18,  v22,  16LL);
  if (v11)
  {
    v12 = v11;
    v13 = *(void *)v19;
    do
    {
      v14 = 0LL;
      do
      {
        if (*(void *)v19 != v13) {
          objc_enumerationMutation(v10);
        }
        if (self) {
          id v15 = self->_preferredQUICProxyPaths;
        }
        else {
          id v15 = 0LL;
        }
        v16 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v15,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v18 + 1) + 8LL * (void)v14),  (void)v18));
        [v16 updateGeohashSharing:v4];

        v14 = (char *)v14 + 1;
      }

      while (v12 != v14);
      id v17 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v18,  v22,  16LL);
      v12 = v17;
    }

    while (v17);
  }

  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
LABEL_18:
}

  uint64_t v11 = v6 ^ 1;

LABEL_7:
  return v11;
}

      (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
      goto LABEL_10;
    }

    uint64_t v9 = nplog_obj(WeakRetained, v3, v4);
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = [*(id *)(a1 + 40) canUse];
      uint64_t v18 = 67109120;
      LODWORD(v19) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Received access token, can use %u",  (uint8_t *)&v18,  8u);
    }

    v12 = *(void *)(a1 + 48);
    v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) accessToken]);
    (*(void (**)(uint64_t, uint64_t, void *))(v12 + 16))(v12, 1LL, v13);
  }

    v13 = 0LL;
    goto LABEL_18;
  }

  v12 = (os_log_s *)objc_claimAutoreleasedReturnValue([v6 valueForKeyPath:@"@sum.self"]);
  -[os_log_s doubleValue](v12, "doubleValue");
  v14 = (double)v10;
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v15 / (double)v10));
  uint64_t v34 = 0u;
  v35 = 0u;
  uint64_t v36 = 0u;
  v37 = 0u;
  id v17 = v6;
  uint64_t v18 = [v17 countByEnumeratingWithState:&v34 objects:v40 count:16];
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(void *)v35;
    BOOL v21 = 0.0;
    do
    {
      for (i = 0LL; i != v19; i = (char *)i + 1)
      {
        if (*(void *)v35 != v20) {
          objc_enumerationMutation(v17);
        }
        objc_msgSend(*(id *)(*((void *)&v34 + 1) + 8 * (void)i), "doubleValue", (void)v34);
        v24 = v23;
        [v16 doubleValue];
        BOOL v21 = v21 + (v24 - v25) * (v24 - v25);
      }

      uint64_t v19 = [v17 countByEnumeratingWithState:&v34 objects:v40 count:16];
    }

    while (v19);
  }

  else
  {
    BOOL v21 = 0.0;
  }

  [v16 doubleValue];
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", sqrt(v21 / v14)));
  v38[0] = @"mean";
  v38[1] = @"stdDev";
  v39[0] = v26;
  v39[1] = v27;
  v13 = (char *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v39,  v38,  2LL));
  v30 = nplog_obj(v13, v28, v29);
  unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    v42 = v13;
    _os_log_debug_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "Data stats dict:%@", buf, 0xCu);
  }

LABEL_18:
  return v13;
}

  objc_sync_exit(obj);
}

  objc_sync_exit(obj);
}

void sub_100005E08(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v6 = v3;
  if (a1)
  {
    if (v3)
    {
    }

    else
    {
      uint64_t v7 = nplog_obj(0LL, v4, v5);
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        int v9 = 136315138;
        id v10 = "-[NSPPrivacyProxyTokenRegistration addToken:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "%s called with null token",  (uint8_t *)&v9,  0xCu);
      }
    }
  }
}

void sub_100005FC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100005FE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) agentDescription]);
    int v11 = 138412290;
    v12 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Token low water mark hit for %@ agent",  (uint8_t *)&v11,  0xCu);
  }

  uint64_t v7 = *(void *)(a1 + 40);
  if (v7) {
    id WeakRetained = objc_loadWeakRetained((id *)(v7 + 8));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained tokenLowWaterMarkReached];

  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = 0LL;
}

void sub_1000061EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100006204(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = *(_DWORD *)(a1 + 64);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) agentDescription]);
    v13[0] = 67109378;
    v13[1] = v6;
    __int16 v14 = 2112;
    id v15 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Received error %d for %@ agent",  (uint8_t *)v13,  0x12u);
  }

  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v8 + 8));
    uint64_t v10 = *(void *)(a1 + 40);
  }

  else
  {
    uint64_t v10 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained reportErrorForTokenRegistration:v10 error:*(unsigned int *)(a1 + 64) withOptions:*(void *)(a1 + 48)];

  uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8LL);
  v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = 0LL;
}

uint64_t sub_10000631C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_8;
  }
  id v5 = v3;
  int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sessionType]);
  if (([v6 isEqual:&off_1001032F0] & 1) == 0)
  {

LABEL_8:
    uint64_t v12 = 0LL;
    goto LABEL_9;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 agentUUID]);
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    uint64_t v9 = *(void **)(v8 + 16);
  }
  else {
    uint64_t v9 = 0LL;
  }
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 agentUUID]);
  unsigned __int8 v11 = [v7 isEqual:v10];

  if ((v11 & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v12 = 1LL;
LABEL_9:

  return v12;
}

void sub_100006400(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return;
  }
  if (!*(void *)(a1 + 24))
  {
    uint64_t v69 = nplog_obj(a1, a2, a3);
    v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
    if (!os_log_type_enabled((os_log_t)v70, OS_LOG_TYPE_FAULT))
    {
LABEL_42:

      return;
    }

    *(_DWORD *)v73 = 136315138;
    *(void *)&v73[4] = "-[NSPPrivacyProxyTokenRegistration registerTokenAgentWithLowWaterMark:]";
    v71 = "%s called with null self.tokenAgentRegistration";
LABEL_44:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v70, OS_LOG_TYPE_FAULT, v71, v73, 0xCu);
    goto LABEL_42;
  }

  uint64_t v4 = *(void **)(a1 + 16);
  if (!v4)
  {
    uint64_t v72 = nplog_obj(0LL, a2, a3);
    v70 = (void *)objc_claimAutoreleasedReturnValue(v72);
    if (!os_log_type_enabled((os_log_t)v70, OS_LOG_TYPE_FAULT)) {
      goto LABEL_42;
    }
    *(_DWORD *)v73 = 136315138;
    *(void *)&v73[4] = "-[NSPPrivacyProxyTokenRegistration registerTokenAgentWithLowWaterMark:]";
    v71 = "%s called with null self.tokenAgent";
    goto LABEL_44;
  }

  [v4 setActive:1];
  [*(id *)(a1 + 16) setVoluntary:0];
  [*(id *)(a1 + 16) setUserActivated:0];
  [*(id *)(a1 + 16) setKernelActivated:0];
  id v6 = [*(id *)(a1 + 24) isRegistered];
  int v7 = (int)v6;
  uint64_t v10 = nplog_obj(v6, v8, v9);
  unsigned __int8 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (!v7)
  {
    if (v12)
    {
      id v29 = *(id *)(a1 + 16);
      v30 = (void *)objc_claimAutoreleasedReturnValue([v29 agentDescription]);
      id v31 = *(id *)(a1 + 16);
      v32 = (void *)objc_claimAutoreleasedReturnValue([v31 agentUUID]);
      *(_DWORD *)v73 = 138412546;
      *(void *)&v73[4] = v30;
      *(_WORD *)&v73[12] = 2112;
      *(void *)&v73[14] = v32;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Registering %@ token agent (%@)", v73, 0x16u);
    }

    uint64_t v33 = *(void *)(a1 + 16);
    id v34 = *(id *)(a1 + 24);
    LOBYTE(v33) = [v34 registerNetworkAgent:v33];

    if ((v33 & 1) == 0)
    {
      uint64_t v38 = nplog_obj(v35, v36, v37);
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        id v61 = *(id *)(a1 + 16);
        v62 = (void *)objc_claimAutoreleasedReturnValue([v61 agentDescription]);
        id v63 = *(id *)(a1 + 16);
        v64 = (void *)objc_claimAutoreleasedReturnValue([v63 agentUUID]);
        *(_DWORD *)v73 = 138412546;
        *(void *)&v73[4] = v62;
        *(_WORD *)&v73[12] = 2112;
        *(void *)&v73[14] = v64;
        _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "Failed to register %@ token agent (%@)",  v73,  0x16u);
      }
    }

    id v40 = [*(id *)(a1 + 24) setLowWaterMark:a2];
    uint64_t v43 = nplog_obj(v40, v41, v42);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_38;
  }

  if (v12)
  {
    id v13 = *(id *)(a1 + 16);
    __int16 v14 = (void *)objc_claimAutoreleasedReturnValue([v13 agentDescription]);
    id v15 = *(id *)(a1 + 16);
    v16 = (void *)objc_claimAutoreleasedReturnValue([v15 agentUUID]);
    *(_DWORD *)v73 = 138412546;
    *(void *)&v73[4] = v14;
    *(_WORD *)&v73[12] = 2112;
    *(void *)&v73[14] = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Updating %@ token agent (%@)", v73, 0x16u);
  }

  uint64_t v17 = *(void *)(a1 + 16);
  id v18 = *(id *)(a1 + 24);
  LOBYTE(v17) = [v18 updateNetworkAgent:v17];

  if ((v17 & 1) == 0)
  {
    uint64_t v22 = nplog_obj(v19, v20, v21);
    v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      id v57 = *(id *)(a1 + 16);
      v58 = (void *)objc_claimAutoreleasedReturnValue([v57 agentDescription]);
      id v59 = *(id *)(a1 + 16);
      v60 = (void *)objc_claimAutoreleasedReturnValue([v59 agentUUID]);
      *(_DWORD *)v73 = 138412546;
      *(void *)&v73[4] = v58;
      *(_WORD *)&v73[12] = 2112;
      *(void *)&v73[14] = v60;
      _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Failed to update %@ token agent (%@)",  v73,  0x16u);
    }
  }

  id v24 = [*(id *)(a1 + 24) setLowWaterMark:a2];
  uint64_t v27 = nplog_obj(v24, v25, v26);
  uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
LABEL_38:
    id v65 = *(id *)(a1 + 16);
    v66 = (void *)objc_claimAutoreleasedReturnValue([v65 agentDescription]);
    id v67 = *(id *)(a1 + 16);
    v68 = (void *)objc_claimAutoreleasedReturnValue([v67 agentUUID]);
    *(_DWORD *)v73 = 134218498;
    *(void *)&v73[4] = a2;
    *(_WORD *)&v73[12] = 2112;
    *(void *)&v73[14] = v66;
    *(_WORD *)&v73[22] = 2112;
    v74 = v68;
    _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Failed to set low water mark(%lu) on %@ token agent (%@)",  v73,  0x20u);
  }

LABEL_22:
LABEL_23:
  *(void *)v73 = _NSConcreteStackBlock;
  *(void *)&v73[8] = 3221225472LL;
  *(void *)&v73[16] = sub_10000631C;
  v74 = &unk_1000F9370;
  uint64_t v75 = a1;
  id v44 = objc_retainBlock(v73);
  if ([*(id *)(a1 + 24) isRegistered])
  {
    id v45 = objc_alloc(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
    objc_super v46 = *(void **)(a1 + 24);
    id v47 = *(id *)(a1 + 16);
    id v48 = v46;
    v49 = (void *)objc_claimAutoreleasedReturnValue([v47 agentUUID]);
    id v50 = *(id *)(a1 + 16);
    v51 = (void *)objc_claimAutoreleasedReturnValue([v50 agentUUID]);
    id v52 = [v45 initWithNetworkAgentRegistration:v48 sessionType:&off_1001032F0 configurationIdentifier:v49 agentUUID:v51 name:0];

    if (v52)
    {
      uint64_t v53 = [*(id *)(a1 + 16) isActive];
      else {
        uint64_t v54 = v53;
      }
      [v52 setAgentFlags:v54];
      v55 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v55 setFileHandle:v52 matchingPredicate:v44];
    }

    else
    {
      v55 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v55 removeFileHandleMatchingPredicate:v44];
    }
  }

  else
  {
    id v52 = (id)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    [v52 removeFileHandleMatchingPredicate:v44];
  }

  v56 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v56 commit];
}
}
}
}

  return 1LL;
}

      uint64_t v38 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v12 lowercaseString]);
      id v40 = (void *)objc_claimAutoreleasedReturnValue([v13 lowercaseString]);
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v14 lowercaseString]);
      uint64_t v42 = -[NSString initWithFormat:](v38, "initWithFormat:", @"%@^%@^%@", v39, v40, v41);

      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v42]);
      if (v43)
      {
        id v44 = (id)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v42]);

        if (v44 != v15)
        {
          id v48 = nplog_obj(v45, v46, v47);
          v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          {
            id v61 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v42]);
            v62 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 identifier]);
            *(_DWORD *)__int128 buf = 138412802;
            id v65 = v61;
            v66 = 2112;
            id v67 = (os_log_s *)v15;
            v68 = 2112;
            uint64_t v69 = v62;
            _os_log_error_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_ERROR,  "Content map %@ and %@ have conflicts, skipping %@",  buf,  0x20u);
          }

          uint64_t v33 = 0LL;
LABEL_42:

          goto LABEL_18;
        }
      }

      else
      {
        [v11 setObject:v15 forKeyedSubscript:v42];
      }

      if (v12) {
        id v50 = 630;
      }
      else {
        id v50 = 660;
      }
      if (v20)
      {
        v51 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s path](v20, "path"));
        id v52 = (void *)objc_claimAutoreleasedReturnValue([v51 componentsSeparatedByString:@"/"]);
        id v63 = v42;
        uint64_t v53 = v50;
        uint64_t v54 = (char *)[v52 count] - 1;

        v55 = 5;
        v56 = v53 - 2 * v55;
        uint64_t v42 = v63;
        uint64_t v33 = (v56 + 10);
      }

      else if (v14)
      {
        v58 = (void *)objc_claimAutoreleasedReturnValue([v14 componentsSeparatedByString:@"."]);
        id v59 = [v58 count];

        v60 = 5;
        uint64_t v33 = (v50 - 2 * v60 + 20);
      }

      else
      {
        uint64_t v33 = (v50 + 20);
      }

      goto LABEL_42;
    }

    if (!v14 || (uint64_t v35 = sub_100084BD4(v14), (v35 & 1) != 0))
    {
      uint64_t v20 = 0LL;
      goto LABEL_22;
    }

    id v57 = nplog_obj(v35, v36, v37);
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 identifier]);
    *(_DWORD *)__int128 buf = 138412546;
    id v65 = v14;
    v66 = 2112;
    id v67 = v21;
    uint64_t v22 = "Skipping unsupported hostname %@ for map %@";
LABEL_14:
    v23 = v20;
    id v24 = 22;
    goto LABEL_15;
  }

  uint64_t v19 = nplog_obj(v16, v17, v18);
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 identifier]);
    *(_DWORD *)__int128 buf = 138412802;
    id v65 = v13;
    v66 = 2112;
    id v67 = (os_log_s *)v14;
    v68 = 2112;
    uint64_t v69 = v21;
    uint64_t v22 = "Unspported content map with URL %@ and hostname %@ for map %@";
    v23 = v20;
    id v24 = 32;
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
LABEL_16:
  }
}
      }
    }
  }
}

void sub_100006AF0(uint64_t a1)
{
  if (a1)
  {
    id v2 = [*(id *)(a1 + 24) isRegistered];
    if ((_DWORD)v2)
    {
      uint64_t v5 = nplog_obj(v2, v3, v4);
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        id v7 = *(id *)(a1 + 16);
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 agentUUID]);
        *(_DWORD *)__int128 buf = 138412290;
        id v13 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Un-registering token agent with UUID %@",  buf,  0xCu);
      }

      [*(id *)(a1 + 24) unregisterNetworkAgent];
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = sub_100006C38;
      v11[3] = &unk_1000F9370;
      v11[4] = a1;
      [v9 removeFileHandleMatchingPredicate:v11];

      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v10 commit];
    }
  }

id sub_100006C38(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_1001032F0])
    {
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 16);
      }
      else {
        uint64_t v8 = 0LL;
      }
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

void sub_100006D8C(id a1)
{
  if (objc_opt_class(&OBJC_CLASS___CLLocation))
  {
    v1 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyLocationMonitor);
    id v2 = (void *)qword_1001170A8;
    qword_1001170A8 = (uint64_t)v1;
  }

void sub_100006F58(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 48), a2);
  }
}

void sub_100007194(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v9 = v6;
  if (v6)
  {
    uint64_t v10 = nplog_obj(v6, v7, v8);
    unsigned __int8 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v28 = v24;
      __int16 v29 = 2112;
      v30 = v9;
      _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "%@: Error in looking up geocode: %@",  buf,  0x16u);
    }
  }

  memset(v25, 0, sizeof(v25));
  if ([v5 countByEnumeratingWithState:v25 objects:v26 count:16])
  {
    BOOL v12 = (void *)**((void **)&v25[0] + 1);
    id v13 = (void *)objc_claimAutoreleasedReturnValue([**((id **)&v25[0] + 1) ISOcountryCode]);
    __int16 v14 = (void *)objc_claimAutoreleasedReturnValue([v12 timeZone]);
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 abbreviation]);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@-%@", v13, v15));
    id v18 = *(void **)(a1 + 32);
    if (v18) {
      objc_setProperty_atomic(v18, v16, v17, 40LL);
    }

    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    if (v19)
    {
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
      uint64_t v22 = *(void **)(a1 + 32);
      if (v22) {
        id Property = objc_getProperty(v22, v20, 40LL, 1);
      }
      else {
        id Property = 0LL;
      }
      [v21 didUpdateCountryPlusTimezone:Property];
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

id sub_10000750C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v10 = 138412290;
    uint64_t v11 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "%@: location monitor timer fired, requesting location ...",  (uint8_t *)&v10,  0xCu);
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = *(void **)(v7 + 24);
  }
  else {
    uint64_t v8 = 0LL;
  }
  [v8 requestLocation];
  return [*(id *)(a1 + 32) setUserEventAgentTimer];
}

void sub_1000079C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000079E0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000079F0(uint64_t a1)
{
}

void sub_1000079F8(uint64_t a1)
{
  id v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_double(v4, "LocationMonitorTimeInterval", *(double *)(*(void *)(a1 + 32) + 56LL));
  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", v4);
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;
}

void sub_100007D58(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);

  if (v2)
  {
    id v3 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    [v3 didUpdateSignificantLocation];
  }

void sub_100008114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100008134(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) lastObject]);
  id v5 = [v2 copy];

  [*(id *)(a1 + 40) handleLocationUpdate:v5];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

void sub_100008308(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = "active";
    if (a2) {
      uint64_t v6 = "idle";
    }
    int v16 = 136315138;
    uint64_t v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "network context is %s", (uint8_t *)&v16, 0xCu);
  }

  *(_BYTE *)(*(void *)(a1 + 32) + 9LL) = a2;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void **)(v7 + 72);
  if ((a2 & 1) != 0)
  {
    if (!v8) {
      return;
    }
    *(void *)(v7 + 72) = 0LL;

    uint64_t v9 = nplog_obj();
    int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
      goto LABEL_13;
    }
    LOWORD(v16) = 0;
    uint64_t v11 = "shared network transaction released";
    goto LABEL_12;
  }

  if (v8) {
    return;
  }
  uint64_t v12 = os_transaction_create("com.apple.networkserviceproxy.shared-network-transaction");
  uint64_t v13 = *(void *)(a1 + 32);
  __int16 v14 = *(void **)(v13 + 72);
  *(void *)(v13 + 72) = v12;

  uint64_t v15 = nplog_obj();
  int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    LOWORD(v16) = 0;
    uint64_t v11 = "shared network transaction acquired";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, v11, (uint8_t *)&v16, 2u);
  }

LABEL_13:
}

    int v16 = nplog_obj(v4, v5, v6);
    id WeakRetained = (id)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled((os_log_t)WeakRetained, OS_LOG_TYPE_ERROR))
    {
      if (self)
      {
        uint64_t v25 = self->_probingReason;
        uint64_t v26 = @"Unknown";
        if (v25 == 2) {
          uint64_t v26 = @"DNS";
        }
        if (v25 == 1) {
          uint64_t v27 = @"Proxy";
        }
        else {
          uint64_t v27 = (__CFString *)v26;
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      uint64_t v28 = v27;
      __int16 v29 = 138412290;
      v30 = (const char *)v28;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)WeakRetained,  OS_LOG_TYPE_ERROR,  "Invalid probing reason: %@",  (uint8_t *)&v29,  0xCu);
    }

    goto LABEL_14;
  }

  directPathProber = self->_directPathProber;
  id v18 = nplog_obj(v4, v5, v6);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (directPathProber == v7)
  {
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = self->_probingReason;
      uint64_t v22 = @"Unknown";
      if (v21 == 2) {
        uint64_t v22 = @"DNS";
      }
      if (v21 == 1) {
        v23 = @"Proxy";
      }
      else {
        v23 = (__CFString *)v22;
      }
      uint64_t v24 = v23;
      __int16 v29 = 138412290;
      v30 = (const char *)v24;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Probing(%@): Direct path probe redirected",  (uint8_t *)&v29,  0xCu);
    }

    sub_100027BE8((uint64_t)self);
    goto LABEL_24;
  }

  if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
  {
    __int16 v29 = 136315138;
    v30 = "-[NSPPrivacyProxyAgentManager probeRedirected:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "%s called with null (prober == self.directPathProber)",  (uint8_t *)&v29,  0xCu);
  }

LABEL_25:
}
}

  return (unint64_t)v4;
}
}

    uint64_t v26 = (void *)sub_10003D9A0(@"RECOVERED_TITLE", @"RECOVERED_TITLE");
    uint64_t v27 = (void *)sub_10003D9A0(@"RECOVERED_SAFARI", @"RECOVERED_SAFARI");
    sub_100099F9C(self, (id)1, v26, v27, 0LL);
  }
}

void sub_100008498(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "network context idleness check timer fired",  buf,  2u);
  }

  if (*(_BYTE *)(*(void *)(a1 + 32) + 9LL))
  {
    uint64_t v4 = nplog_obj();
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "network context is idle, releasing shared network transaction",  v8,  2u);
    }

    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 72);
    *(void *)(v6 + 72) = 0LL;
  }

void sub_100008570(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 72))
  {
    *(_BYTE *)(v1 + 9) = 1;
    uint64_t v3 = os_transaction_create("com.apple.networkserviceproxy.shared-network-transaction");
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 72);
    *(void *)(v4 + 72) = v3;

    uint64_t v9 = *(void *)(a1 + 32);
    if (v9)
    {
      uint64_t v10 = NPGetInternalQueue(v6);
      uint64_t v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
      dispatch_source_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v11);
      uint64_t v13 = *(void **)(v9 + 80);
      *(void *)(v9 + 80) = v12;

      __int16 v14 = *(void **)(v9 + 80);
      if (v14)
      {
        uint64_t v15 = v14;
        dispatch_time_t v16 = dispatch_time(0LL, 30000000000LL);
        dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0LL);

        uint64_t v17 = *(dispatch_source_s **)(v9 + 80);
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 3221225472LL;
        v20[2] = sub_100008498;
        v20[3] = &unk_1000F9450;
        v20[4] = v9;
        dispatch_source_set_event_handler(v17, v20);
        dispatch_resume(*(dispatch_object_t *)(v9 + 80));
      }
    }

    uint64_t v18 = nplog_obj(v6, v7, v8);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      LOWORD(v20[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "shared network transaction acquired",  (uint8_t *)v20,  2u);
    }
  }

void sub_1000086F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = NPGetInternalQueue(v3);
  id v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_1000087AC;
  v7[3] = &unk_1000F9478;
  id v8 = v3;
  id v6 = v3;
  objc_copyWeak(&v9, (id *)(a1 + 32));
  dispatch_async(v5, v7);

  objc_destroyWeak(&v9);
}

void sub_1000087AC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) invalidate];
  uint64_t v5 = nplog_obj(v2, v3, v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Resurrection timer fired", v10, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v9 = WeakRetained;
  if (WeakRetained)
  {
    objc_setProperty_atomic(WeakRetained, v8, 0LL, 40LL);
    sub_100008850(v9, 0LL);
  }
}

void sub_100008850(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = sub_10005725C();
    uint64_t v5 = objc_claimAutoreleasedReturnValue(v4);
    id v6 = (void *)v5;
    if (v5) {
      uint64_t v7 = *(void **)(v5 + 40);
    }
    else {
      uint64_t v7 = 0LL;
    }
    id v8 = v7;

    if (v8)
    {
      if ((*(_BYTE *)(a1 + 8) & 1) == 0)
      {
        [v8 setResurrectionDate:0];
        *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
        dispatch_source_t v12 = (void *)objc_claimAutoreleasedReturnValue([v8 configServerEnabled]);
        unsigned __int8 v13 = [v12 BOOLValue];

        uint64_t v17 = nplog_obj(v14, v15, v16);
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
        BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
        if ((v13 & 1) != 0)
        {
          if (v19)
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Fetching Waldo", buf, 2u);
          }

          *(void *)__int128 buf = 0LL;
          id v31 = buf;
          uint64_t v32 = 0x3032000000LL;
          uint64_t v33 = sub_100009748;
          id v34 = sub_100009758;
          uint64_t v35 = os_transaction_create("com.apple.networkserviceproxy.refreshWaldo");
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v8 timestamp]);
          v25[0] = _NSConcreteStackBlock;
          v25[1] = 3221225472LL;
          v25[2] = sub_10000B11C;
          v25[3] = &unk_1000F96F8;
          id v26 = v8;
          uint64_t v27 = a1;
          id v28 = v3;
          __int16 v29 = buf;
          sub_10000A0A4(a1, 0LL, v20, v25);

          _Block_object_dispose(buf, 8);
          uint64_t v21 = (void *)v35;
        }

        else
        {
          if (v19)
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Waldo is disabled, re-establishing trust",  buf,  2u);
          }

          v36[0] = _NSConcreteStackBlock;
          v36[1] = 3221225472LL;
          v36[2] = sub_10000B09C;
          v36[3] = &unk_1000F96A8;
          v36[4] = a1;
          id v37 = v3;
          sub_10000AC98(a1, v36);
          uint64_t v21 = v37;
        }

LABEL_20:
        goto LABEL_21;
      }

      uint64_t v24 = nplog_obj(v9, v10, v11);
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Waldo refresh is already pending", buf, 2u);
      }
    }

    else
    {
      uint64_t v22 = nplog_obj(v9, v10, v11);
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "No configuration, cannot refresh Waldo",  buf,  2u);
      }
    }

    if (v3) {
      (*((void (**)(id, void, void))v3 + 2))(v3, 0LL, 0LL);
    }
    goto LABEL_20;
  }

LABEL_21:
}
  }

  else
  {
LABEL_19:
    uint64_t v10 = 0LL;
  }

  return v10;
}
}
}

  uint64_t v32 = *(void *)(a1 + 64);
  if (v32)
  {
    ++*(void *)(v32 + 112);
    uint64_t v33 = *(void *)(a1 + 64);
  }

  else
  {
    uint64_t v33 = 0LL;
  }

  sub_100087A2C(v33, 0LL, v31);
  id v34 = *(void *)(a1 + 88);
  if (v34) {
    (*(void (**)(uint64_t, void, void))(v34 + 16))(v34, 0LL, *(void *)(a1 + 80));
  }
}

    uint64_t v11 = 0LL;
    goto LABEL_22;
  }

  uint64_t v11 = 5LL;
LABEL_22:

  return v11;
}

      BOOL v19 = (void *)sub_10003D9A0(@"CAPTIVE_WARNING_TITLE", @"CAPTIVE_WARNING_TITLE");
      uint64_t v20 = self;
      uint64_t v21 = 7LL;
      uint64_t v22 = v19;
      v23 = v10;
    }

    else
    {
      uint64_t v10 = (void *)sub_10003D9A0(@"OUTAGE_WARNING_TITLE", @"OUTAGE_WARNING_TITLE");
      BOOL v19 = (void *)sub_10003D9A0(@"OUTAGE_WARNING", @"OUTAGE_WARNING");
      uint64_t v20 = self;
      uint64_t v21 = 2LL;
      uint64_t v22 = v10;
      v23 = v19;
    }

    sub_100099F9C(v20, (id)v21, v22, v23, 0LL);
  }
}

void sub_100008B38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100008D28(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v6, @"MessageResult");

  if (v7) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v7, @"RequestLog");
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100008DD4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = nplog_obj();
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)a2)
  {
    if (!v6) {
      goto LABEL_7;
    }
    __int16 v16 = 0;
    id v7 = "Tuscany refresh succeeded";
    id v8 = (uint8_t *)&v16;
  }

  else
  {
    if (!v6) {
      goto LABEL_7;
    }
    __int16 v15 = 0;
    id v7 = "Tuscany refresh failed";
    id v8 = (uint8_t *)&v15;
  }

  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
LABEL_7:

  uint64_t v10 = *(void **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  if (v10) {
    id Property = objc_getProperty(v10, v9, 48LL, 1);
  }
  else {
    id Property = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t, id))(v11 + 16))(v11, a2, Property);
  uint64_t v14 = *(void **)(a1 + 32);
  if (v14) {
    objc_setProperty_atomic(v14, v13, 0LL, 48LL);
  }
}

void sub_100009230(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 32))
  {
    id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  a2,  200LL,  0LL,  0LL));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

void sub_100009488(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  if (a1)
  {
    __int16 v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    uint64_t v17 = NPGetInternalQueue(v16);
    uint64_t v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v17);
    dispatch_assert_queue_V2(v18);

    if (v11 && (!v12 || (id v19 = [v12 compare:v16], v19 == (id)-1)))
    {
      uint64_t v24 = nplog_obj(v19, v20, v21);
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Sending request for %@",  (uint8_t *)&buf,  0xCu);
      }

      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v34 = 0x3032000000LL;
      uint64_t v35 = sub_100009748;
      uint64_t v36 = sub_100009758;
      id v37 = 0LL;
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472LL;
      v27[2] = sub_100009760;
      v27[3] = &unk_1000F9540;
      id v28 = v11;
      uint64_t v29 = a1;
      p___int128 buf = &buf;
      id v30 = v14;
      id v31 = v15;
      id v26 = (void *)objc_claimAutoreleasedReturnValue([v13 dataTaskWithURL:v28 completionHandler:v27]);
      objc_storeStrong((id *)(*((void *)&buf + 1) + 40LL), v26);
      [*(id *)(*((void *)&buf + 1) + 40) resume];

      _Block_object_dispose(&buf, 8);
    }

    else
    {
      uint64_t v22 = nplog_obj(v19, v20, v21);
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Current results for %@ have not yet expired",  (uint8_t *)&buf,  0xCu);
      }

      (*((void (**)(id, void, void))v15 + 2))(v15, 0LL, 0LL);
    }
  }
}

void sub_100009728( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100009748(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100009758(uint64_t a1)
{
}

void sub_100009760(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue(v9);
  id v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  v19[2] = sub_100009884;
  v19[3] = &unk_1000F9518;
  id v20 = v9;
  id v12 = *(id *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  id v14 = *(void **)(a1 + 48);
  id v21 = v12;
  uint64_t v22 = v13;
  uint64_t v15 = *(void *)(a1 + 64);
  id v23 = v8;
  uint64_t v27 = v15;
  id v24 = v7;
  id v25 = v14;
  id v26 = *(id *)(a1 + 56);
  id v16 = v7;
  id v17 = v8;
  id v18 = v9;
  dispatch_async(v11, v19);
}

uint64_t sub_100009884(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 domain]);
    if ([v3 isEqualToString:NSURLErrorDomain])
    {
      id v4 = [*(id *)(a1 + 32) code];

      if (v4 == (id)-999LL)
      {
        uint64_t v8 = nplog_obj(v5, v6, v7);
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void **)(a1 + 40);
          *(_DWORD *)__int128 buf = 138412290;
          objc_super v46 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Request for %@ was cancelled", buf, 0xCu);
        }

LABEL_15:
        goto LABEL_16;
      }
    }

    else
    {
    }

    uint64_t v11 = nplog_obj(v5, v6, v7);
    id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v43 = *(void *)(a1 + 32);
      uint64_t v42 = *(void **)(a1 + 40);
      *(_DWORD *)__int128 buf = 138412546;
      objc_super v46 = v42;
      __int16 v47 = 2112;
      uint64_t v48 = v43;
      _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Request for %@ resulted in error: %@",  buf,  0x16u);
    }

    id v14 = *(void **)(a1 + 48);
    if (v14 && objc_getProperty(v14, v13, 48LL, 1))
    {
      id Property = *(id *)(a1 + 48);
      if (Property) {
        id Property = objc_getProperty(Property, v15, 48LL, 1);
      }
      id v17 = *(void **)(a1 + 32);
      uint64_t v18 = *(void *)(a1 + 40);
      id v19 = Property;
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 localizedDescription]);
      [v19 appendFormat:@"FAIL %@ %@\n", v18, v9];

      goto LABEL_15;
    }
  }

  return v28;
}
}
  }
}
  }
}

  a1 = 0LL;
LABEL_16:

LABEL_17:
  return a1;
}

  a1 = 0LL;
LABEL_16:

LABEL_17:
  return a1;
}

      goto LABEL_25;
    }
}
}

  objc_sync_exit(v5);
}

      (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
LABEL_84:

      goto LABEL_85;
    }

    if (!v135)
    {
      v114 = nplog_obj(0LL, v30, v31);
      uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v114);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        v163 = "-[NSPPrivacyTokenManager fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssuancePublicK"
               "ey:tokenChallenge:tokenCount:accessToken:retryAttempt:completionHandler:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_FAULT,  "%s called with null tokenBlinder",  buf,  0xCu);
      }

      goto LABEL_15;
    }

    uint64_t v34 = &AnalyticsSendEventLazy_ptr;
    if (v24)
    {
      v136 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v134 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      id v35 = a9;
      do
      {
        uint64_t v36 = sub_1000ACA74((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenRequest);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v36);
        if (!v39)
        {
          v105 = nplog_obj(0LL, v37, v38);
          v106 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
          if (os_log_type_enabled(v106, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            v163 = "-[NSPPrivacyTokenManager fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssuancePub"
                   "licKey:tokenChallenge:tokenCount:accessToken:retryAttempt:completionHandler:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_FAULT,  "%s called with null clientNonce",  buf,  0xCu);
          }

          (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
          goto LABEL_83;
        }

        id v40 = sub_1000ACB50((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenRequest, v24, v39, v137);
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v40);
        if (!v43)
        {
          v107 = nplog_obj(0LL, v41, v42);
          v108 = (os_log_s *)objc_claimAutoreleasedReturnValue(v107);
          if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            v163 = "-[NSPPrivacyTokenManager fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssuancePub"
                   "licKey:tokenChallenge:tokenCount:accessToken:retryAttempt:completionHandler:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_FAULT,  "%s called with null messageToBlind",  buf,  0xCu);
          }

          (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
          goto LABEL_83;
        }

        -[NSMutableArray addObject:](v136, "addObject:", v43);
        -[NSMutableArray addObject:](v134, "addObject:", v39);

        --v35;
      }

      while (v35);
      id v44 = v135;
      id v45 = v136;
      if (!self)
      {
        v136 = v45;
        v125 = 0LL;

        goto LABEL_45;
      }

      if (!v45)
      {
        v136 = 0LL;
        v49 = 1;
        goto LABEL_29;
      }

      v136 = v45;
      objc_super v46 = -[NSMutableArray count](v45, "count");
      if (v46 == (id)a9)
      {
        v49 = 0;
        goto LABEL_29;
      }

      v119 = nplog_obj(v46, v47, v48);
      v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v119);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        v163 = "-[NSPPrivacyTokenManager generateTokensUsingTokenBlinder:contentArray:tokenCount:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_FAULT,  "%s called with null (contentArray.count == tokenCount)",  buf,  0xCu);
      }
    }

    else
    {
      id v50 = v135;
      v134 = 0LL;
      if (!self)
      {
        v136 = 0LL;
        v125 = 0LL;

        goto LABEL_45;
      }

      v49 = 1;
      v136 = 0LL;
LABEL_29:
      v51 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      id v52 = 0LL;
      while (1)
      {
        if ((v49 & 1) != 0)
        {
          uint64_t v53 = 0LL;
        }

        else
        {
          uint64_t v34 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v136, "objectAtIndexedSubscript:", v52));
          uint64_t v53 = v34;
        }

        v159 = 0LL;
        uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue([v135 tokenWaitingActivationWithContent:v53 error:&v159]);
        v55 = (char *)v159;
        v58 = v55;
        if ((v49 & 1) == 0) {

        }
        if (v58) {
          break;
        }
        if (!v54)
        {
          v109 = nplog_obj(v55, v56, v57);
          uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v109);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            v163 = "-[NSPPrivacyTokenManager generateTokensUsingTokenBlinder:contentArray:tokenCount:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_FAULT,  "%s called with null waitingActivation",  buf,  0xCu);
          }

          goto LABEL_42;
        }

        -[os_log_s addObject:](v51, "addObject:", v54);

        if (a9 == ++v52)
        {
          v51 = v51;
          v125 = v51;
          goto LABEL_44;
        }
      }

      id v59 = nplog_obj(v55, v56, v57);
      v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        v163 = v58;
        _os_log_error_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_ERROR,  "tokenWaitingActivationWithContent failed with error %@",  buf,  0xCu);
      }

LABEL_42:
    }

    v125 = 0LL;
LABEL_44:

LABEL_45:
    if (-[os_log_s count](v125, "count"))
    {
      id v63 = -[os_log_s count](v125, "count");
      if (self) {
        self->_totalUnactivatedTokenCount += (unint64_t)v63;
      }
      v66 = nplog_obj(v63, v64, v65);
      id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        v68 = (const char *)-[os_log_s count](v125, "count");
        *(_DWORD *)__int128 buf = 134218242;
        v163 = v68;
        v164 = 2112;
        v165 = v128;
        _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "generated %lu unactivated tokens for %@",  buf,  0x16u);
      }

      if (v24)
      {
        v152 = 0uLL;
        v153 = 0uLL;
        v150 = 0uLL;
        v151 = 0uLL;
        uint64_t v69 = v125;
        v70 = -[os_log_s countByEnumeratingWithState:objects:count:]( v69,  "countByEnumeratingWithState:objects:count:",  &v150,  v160,  16LL);
        if (v70)
        {
          v71 = *(void *)v151;
          while (2)
          {
            for (i = 0LL; i != v70; i = (char *)i + 1)
            {
              if (*(void *)v151 != v71) {
                objc_enumerationMutation(v69);
              }
              v73 = *(void **)(*((void *)&v150 + 1) + 8LL * (void)i);
              v74 = objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenRequest);
              uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v73 blindedMessage]);
              v76 = sub_1000ACEB0((uint64_t)v74, v24, v137, 0LL, 0LL, v75);

              if (!v76 || (v77 = objc_getProperty(v76, v78, 24LL, 1)) == 0LL)
              {
                v117 = nplog_obj(v77, v78, v79);
                v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);
                if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)__int128 buf = 136315138;
                  v163 = "-[NSPPrivacyTokenManager fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssua"
                         "ncePublicKey:tokenChallenge:tokenCount:accessToken:retryAttempt:completionHandler:]";
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_FAULT,  "%s called with null requestData",  buf,  0xCu);
                }

                (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
                goto LABEL_82;
              }

              v80 = v77;
              [v28 addTokenRequestList:v77];
            }

            v70 = -[os_log_s countByEnumeratingWithState:objects:count:]( v69,  "countByEnumeratingWithState:objects:count:",  &v150,  v160,  16LL);
            if (v70) {
              continue;
            }
            break;
          }
        }
      }

      else
      {
        v156 = 0uLL;
        v157 = 0uLL;
        v154 = 0uLL;
        v155 = 0uLL;
        v81 = v125;
        v82 = -[os_log_s countByEnumeratingWithState:objects:count:]( v81,  "countByEnumeratingWithState:objects:count:",  &v154,  v161,  16LL);
        if (v82)
        {
          v83 = *(void *)v155;
          do
          {
            for (j = 0LL; j != v82; j = (char *)j + 1)
            {
              if (*(void *)v155 != v83) {
                objc_enumerationMutation(v81);
              }
              [v28 addUnactivatedTokenList:v85];
            }

            v82 = -[os_log_s countByEnumeratingWithState:objects:count:]( v81,  "countByEnumeratingWithState:objects:count:",  &v154,  v161,  16LL);
          }

          while (v82);
        }
      }

      v86 = (void *)objc_claimAutoreleasedReturnValue([v135 keyId]);
      [v28 setTokenKeyID:v86];

      [v28 setProxyURL:v132];
      [v28 setVendor:v128];
      v87 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenActivationQuery);
      [v87 setTokenInfo:v28];
      v120 = (void *)mach_absolute_time();
      v88 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyTokenManager tokenFetchURL](self, "tokenFetchURL"));
      v89 = sub_10009E990((uint64_t)self, v88, v126, 0, 0, a11 != 0);
      v90 = (void *)objc_claimAutoreleasedReturnValue(v89);

      if (v129) {
        [v90 setValue:v129 forHTTPHeaderField:@"X-Mask-User-Tier"];
      }
      if (v127) {
        [v90 setValue:v127 forHTTPHeaderField:@"X-Mask-Subscription-Token"];
      }
      v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%lu", a11));
      if (v91) {
        [v90 setValue:v91 forHTTPHeaderField:@"Retry-Attempt"];
      }
      v123 = objc_alloc_init(&OBJC_CLASS___NSURLSessionDelegate);
      v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
      v93 = (void *)objc_claimAutoreleasedReturnValue([v92 _socketStreamProperties]);
      if (v93)
      {
        v94 = (void *)objc_claimAutoreleasedReturnValue([v92 _socketStreamProperties]);
        v122 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v94));
      }

      else
      {
        v122 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      }

      [v122 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
      objc_msgSend(v92, "set_socketStreamProperties:", v122);
      [v92 setTimeoutIntervalForRequest:60.0];
      objc_msgSend(v92, "set_loggingPrivacyLevel:", 1);
      v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyTokenManager tokenFetchURL](self, "tokenFetchURL"));
      v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v95));

      v96 = (void *)objc_claimAutoreleasedReturnValue([v121 host]);
      [v123 setValidationHostname:v96];

      if (self)
      {
        v97 = self;
        ignoreInvalidCerts = self->_ignoreInvalidCerts;
      }

      else
      {
        ignoreInvalidCerts = 0LL;
        v97 = 0LL;
      }

      v99 = v97 == 0LL;
      [v123 setIgnoreInvalidCerts:ignoreInvalidCerts];
      v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSOperationQueue mainQueue](&OBJC_CLASS___NSOperationQueue, "mainQueue"));
      v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v92,  v123,  v100));

      [v101 setSessionDescription:@"PrivacyProxyTokenFetch"];
      objc_initWeak((id *)buf, self);
      if (v99) {
        authenticationClass = 0LL;
      }
      else {
        authenticationClass = self->_authenticationClass;
      }
      v138[0] = _NSConcreteStackBlock;
      v138[1] = 3221225472LL;
      v138[2] = sub_10009FD04;
      v138[3] = &unk_1000FAB98;
      objc_copyWeak(v149, (id *)buf);
      v103 = v101;
      v139 = v103;
      v104 = v90;
      v140 = v104;
      v148 = v131;
      v141 = v125;
      v142 = v24;
      v143 = v137;
      v144 = v134;
      v145 = v128;
      v146 = v132;
      v147 = v129;
      v149[1] = (id)a9;
      v149[2] = v120;
      -[objc_class sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:]( authenticationClass,  "sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:",  v104,  v103,  v87,  v138);

      objc_destroyWeak(v149);
      objc_destroyWeak((id *)buf);
    }

    else
    {
      v115 = nplog_obj(0LL, v61, v62);
      v116 = (os_log_s *)objc_claimAutoreleasedReturnValue(v115);
      if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        v163 = "-[NSPPrivacyTokenManager fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssuancePublicK"
               "ey:tokenChallenge:tokenCount:accessToken:retryAttempt:completionHandler:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_FAULT,  "%s called with null (tokenWaitingActivationList.count > 0)",  buf,  0xCu);
      }

      (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
    }

      goto LABEL_16;
    }

    if (!v7
      || (id v19 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse),
          id WeakRetained = objc_opt_isKindOfClass(v8, v19),
          (WeakRetained & 1) == 0))
    {
      id v26 = nplog_obj(WeakRetained, v11, v12);
      id v16 = (void *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR))
      {
        v49 = *(void **)(a1 + 32);
        id v50 = 138412290;
        v51 = v49;
        _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v16,  OS_LOG_TYPE_ERROR,  "%@ failed to receive expected response from the captive probe server",  (uint8_t *)&v50,  0xCu);
      }

      goto LABEL_15;
    }

    uint64_t v20 = v8;
    if ((char *)[v20 statusCode] - 200 <= (char *)0x63)
    {
      uint64_t v21 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v7,  134217984LL);
      uint64_t v22 = -[NSString isEqualToString:]( v21,  "isEqualToString:",  @"<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>");
      if (v22)
      {
        uint64_t v25 = v13;
      }

      else
      {
        objc_super v46 = nplog_obj(v22, v23, v24);
        __int16 v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
        {
          uint64_t v48 = *(void **)(a1 + 32);
          id v50 = 138412290;
          v51 = v48;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_INFO,  "%@ received HTTP redirect from the network",  (uint8_t *)&v50,  0xCu);
        }

        uint64_t v25 = v13;
      }

      sub_1000B1A6C(v25);
      goto LABEL_35;
    }

    uint64_t v21 = (NSString *)v20;
    uint64_t v29 = nplog_obj(v21, v27, v28);
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      id v50 = 138412546;
      v51 = v13;
      id v52 = 2048;
      uint64_t v53 = -[NSString statusCode](v21, "statusCode");
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "%@ HTTP response has status code: [%ld]",  (uint8_t *)&v50,  0x16u);
    }

    uint64_t v31 = (char *)-[NSString statusCode](v21, "statusCode");
    if ((unint64_t)(v31 - 300) >= 4 && v31 != (char *)307)
    {
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSString allHeaderFields](v21, "allHeaderFields"));
      if ((char *)-[NSString statusCode](v21, "statusCode") - 200 > (char *)0x63
        || (uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKey:@"Location"]),
            v33,
            !v33))
      {

LABEL_35:
LABEL_36:

        goto LABEL_18;
      }

      id v37 = nplog_obj(v34, v35, v36);
      id v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
      {
        id v50 = 138412290;
        v51 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_INFO,  "%@ HTTP response has 'Location' header",  (uint8_t *)&v50,  0xCu);
      }
    }

    uint64_t v42 = nplog_obj(v39, v40, v41);
    uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      id v44 = *(void **)(a1 + 32);
      id v50 = 138412290;
      v51 = v44;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_INFO,  "%@ received HTTP redirect from the network",  (uint8_t *)&v50,  0xCu);
    }

    sub_1000B1A6C(v13);
    goto LABEL_36;
  }

void sub_10000A0A4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    id v10 = sub_10005725C();
    uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
    id v12 = (void *)v11;
    if (v11) {
      uint64_t v13 = *(void **)(v11 + 40);
    }
    else {
      uint64_t v13 = 0LL;
    }
    id v14 = v13;

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 createConfigFetchURLWithPath:v7 timestamp:v8]);
    v32[0] = 0LL;
    v32[1] = v32;
    v32[2] = 0x3032000000LL;
    v32[3] = sub_100009748;
    v32[4] = sub_100009758;
    id v33 = 0LL;
    v30[0] = 0LL;
    v30[1] = v30;
    v30[2] = 0x3032000000LL;
    v30[3] = sub_100009748;
    v30[4] = sub_100009758;
    id v31 = 0LL;
    v28[0] = 0LL;
    v28[1] = v28;
    v28[2] = 0x3032000000LL;
    v28[3] = sub_100009748;
    v28[4] = sub_100009758;
    id v29 = 0LL;
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v14 privacyProxyURLSession]);
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472LL;
    v23[2] = sub_10000A2E0;
    v23[3] = &unk_1000F9568;
    uint64_t v25 = v30;
    id v26 = v32;
    BOOL v27 = v28;
    id v17 = v15;
    id v24 = v17;
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_10000A64C;
    v18[3] = &unk_1000F9590;
    id v19 = v9;
    uint64_t v20 = v28;
    uint64_t v21 = v30;
    uint64_t v22 = v32;
    sub_100009488(a1, v17, 0LL, v16, v23, v18);

    _Block_object_dispose(v28, 8);
    _Block_object_dispose(v30, 8);

    _Block_object_dispose(v32, 8);
  }
}

void sub_10000A2B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
}

void sub_10000A2E0(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
    if ((objc_opt_isKindOfClass(v5, v7) & 1) != 0)
    {
      id v8 = v5;
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 allHeaderFields]);
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"X-Modified"]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NPUtilities stripWhitespace:](&OBJC_CLASS___NPUtilities, "stripWhitespace:", v10));

      id v12 = (void *)objc_claimAutoreleasedReturnValue([v8 allHeaderFields]);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"X-POI"]);
      id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NPUtilities stripWhitespace:](&OBJC_CLASS___NPUtilities, "stripWhitespace:", v13));

      if (v11)
      {
        uint64_t v15 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [v11 integerValue]));
        uint64_t v16 = *(void *)(a1[5] + 8LL);
        id v17 = *(void **)(v16 + 40);
        *(void *)(v16 + 40) = v15;
      }

      id v18 = [v14 length];
      if (v18)
      {
        uint64_t v21 = nplog_obj(v18, v19, v20);
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 138412290;
          v49 = (os_log_s *)v14;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "Got geohash %@ from the X-POI header",  buf,  0xCu);
        }

        objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), v14);
      }

      id v23 = [v8 statusCode];
      if (v23 != (id)200)
      {
        uint64_t v43 = nplog_obj(v23, v24, v25);
        BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          id v44 = (os_log_s *)[v8 statusCode];
          uint64_t v45 = a1[4];
          *(_DWORD *)__int128 buf = 134218242;
          v49 = v44;
          __int16 v50 = 2112;
          uint64_t v51 = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Received HTTP response code %ld for %@, not parsing JSON",  buf,  0x16u);
        }

        goto LABEL_18;
      }

      id v47 = 0LL;
      uint64_t v26 = objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v6,  0LL,  &v47));
      BOOL v27 = (os_log_s *)v47;
      uint64_t v28 = *(void *)(a1[7] + 8LL);
      id v29 = *(void **)(v28 + 40);
      *(void *)(v28 + 40) = v26;

      uint64_t v33 = *(void *)(*(void *)(a1[7] + 8LL) + 40LL);
      if (v33)
      {
        uint64_t v34 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v33, v34);
        if ((isKindOfClass & 1) != 0)
        {
LABEL_18:

          goto LABEL_19;
        }

        uint64_t v38 = nplog_obj(isKindOfClass, v36, v37);
        uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          id v40 = "Parsed JSON object is not a dictionary";
          uint64_t v41 = v39;
          uint32_t v42 = 2;
LABEL_21:
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
        }
      }

      else
      {
        uint64_t v46 = nplog_obj(v30, v31, v32);
        uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          v49 = v27;
          id v40 = "Failed to parse JSON data into a JSON object: %@";
          uint64_t v41 = v39;
          uint32_t v42 = 12;
          goto LABEL_21;
        }
      }

      goto LABEL_18;
    }
  }

uint64_t sub_10000A64C(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, BOOL, void, void, void))(a1[4] + 16LL))( a1[4],  a2 == 0,  *(void *)(*(void *)(a1[5] + 8LL) + 40LL),  *(void *)(*(void *)(a1[6] + 8LL) + 40LL),  *(void *)(*(void *)(a1[7] + 8LL) + 40LL));
}

id sub_10000A680(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_10000A6A8(uint64_t a1)
{
}

void sub_10000A6B0(uint64_t a1, unint64_t a2)
{
  if ((unint64_t)[*(id *)(a1 + 32) count] <= a2)
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
    uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8LL);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = 0LL;

    uint64_t v13 = *(void *)(*(void *)(a1 + 72) + 8LL);
    id v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = 0LL;
  }

  else
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:a2]);
    if (v4)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgeSets]);
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v4]);

      uint64_t v7 = *(void *)(a1 + 48);
      id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 timestamp]);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      v16[2] = sub_10000A870;
      v16[3] = &unk_1000F95E0;
      id v17 = v4;
      id v18 = v6;
      int8x16_t v15 = *(int8x16_t *)(a1 + 40);
      id v9 = (id)v15.i64[0];
      int8x16_t v19 = vextq_s8(v15, v15, 8uLL);
      uint64_t v20 = *(void *)(a1 + 72);
      unint64_t v21 = a2;
      id v10 = v6;
      sub_10000A0A4(v7, v17, v8, v16);
    }

    else
    {
      (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL) + 16LL))();
    }
  }

void sub_10000A870(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (!a2)
  {
    unint64_t v21 = *(void **)(a1 + 40);
    if (v21)
    {
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 currentNetworkInfo]);
      [v22 setLastFallbackReason:16];

      [*(id *)(a1 + 40) setShouldSave:1];
    }

    goto LABEL_9;
  }

  if (!v9)
  {
LABEL_9:
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL) + 16LL))();
    goto LABEL_10;
  }

  id v12 = -[NPWaldo initWithIdentifier:timestamp:fromDictionary:source:]( objc_alloc(&OBJC_CLASS___NPWaldo),  "initWithIdentifier:timestamp:fromDictionary:source:",  *(void *)(a1 + 32),  v10,  v9,  1LL);
  uint64_t v13 = v12;
  if (!v12 || !-[NPWaldo hasEdges](v12, "hasEdges"))
  {

    goto LABEL_9;
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = sub_10000AA00;
  v23[3] = &unk_1000F95B8;
  uint64_t v24 = v13;
  id v25 = *(id *)(a1 + 40);
  id v14 = v11;
  uint64_t v15 = *(void *)(a1 + 48);
  uint64_t v16 = *(void **)(a1 + 56);
  id v26 = v14;
  uint64_t v27 = v15;
  id v28 = v16;
  id v17 = *(id *)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 64);
  uint64_t v19 = *(void *)(a1 + 72);
  id v29 = v17;
  uint64_t v30 = v18;
  uint64_t v31 = v19;
  uint64_t v20 = v13;
  -[NPWaldo resolveWithCompletionHandler:](v20, "resolveWithCompletionHandler:", v23);

LABEL_10:
}

uint64_t sub_10000AA00(uint64_t a1, char a2)
{
  uint64_t v4 = NPGetInternalQueue(a1);
  id v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  dispatch_assert_queue_V2(v5);

  if ((a2 & 1) == 0)
  {
    uint64_t v9 = nplog_obj(v6, v7, v8);
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) identifier]);
      int v25 = 138412290;
      id v26 = v24;
      _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "%@: Failed to resolve downloaded Waldo",  (uint8_t *)&v25,  0xCu);
    }
  }

  id v11 = *(void **)(a1 + 40);
  if (v11)
  {
    [v11 merge:*(void *)(a1 + 32) missingSettingsOnly:0];
    [*(id *)(a1 + 40) link];
    id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) locationManager]);
    [v12 setCurrentGeohash:*(void *)(a1 + 48)];

    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgesGeneration]);
    if (!v13)
    {
      [*(id *)(a1 + 40) setEdgesGeneration:&off_100103320];
      [*(id *)(a1 + 40) setUsedEdgesGeneration:&off_100103320];
    }

    id v14 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgesGeneration]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v14 unsignedIntValue] + 1));
    [*(id *)(a1 + 40) setEdgesGeneration:v15];
  }

  else
  {
    uint64_t v16 = *(void **)(a1 + 56);
    id v17 = *(id *)(a1 + 32);
    uint64_t v18 = v17;
    if (v16)
    {
      [v17 setDelegate:v16];
      uint64_t v19 = -[NPWaldoLocationManager initWithWaldo:]( objc_alloc(&OBJC_CLASS___NPWaldoLocationManager),  "initWithWaldo:",  v18);
      [v18 setLocationManager:v19];

      if (objc_getProperty(v16, v20, 32LL, 1)) {
        objc_msgSend(v18, "setCurrentNetworkCharacteristics:", objc_getProperty(v16, v21, 32, 1));
      }
    }

    [*(id *)(a1 + 32) link];
    [*(id *)(a1 + 32) setEdgesGeneration:&off_100103320];
    [*(id *)(a1 + 32) setUsedEdgesGeneration:&off_100103308];
    [*(id *)(a1 + 32) setShouldSave:1];
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) edgeSets]);
    id v14 = [v22 mutableCopy];

    [v14 setObject:*(void *)(a1 + 32) forKeyedSubscript:*(void *)(a1 + 72)];
    [*(id *)(a1 + 64) setEdgeSets:v14];
  }

  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL) + 16LL))();
}

void sub_10000AC98(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    id v7 = sub_10005725C();
    uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
    uint64_t v9 = (void *)v8;
    if (v8) {
      id v10 = *(void **)(v8 + 40);
    }
    else {
      id v10 = 0LL;
    }
    id v11 = v10;

    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 edgeSets]);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 allValues]);

    v17[0] = 0LL;
    v17[1] = v17;
    v17[2] = 0x3032000000LL;
    v17[3] = sub_100009748;
    v17[4] = sub_100009758;
    id v18 = (id)os_transaction_create("com.apple.networkserviceproxy.establishTrust");
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_10000B064;
    v14[3] = &unk_1000F9680;
    id v15 = v4;
    uint64_t v16 = v17;
    sub_10000AE04(a1, v13, 0LL, 1, 0, v14);

    _Block_object_dispose(v17, 8);
  }
}

void sub_10000ADEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000AE04(uint64_t a1, void *a2, uint64_t a3, char a4, char a5, void *a6)
{
  id v11 = a2;
  id v12 = a6;
  uint64_t v13 = v12;
  if (a1)
  {
    uint64_t v14 = NPGetInternalQueue(v12);
    id v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10000AEE0;
    block[3] = &unk_1000F9658;
    uint64_t v20 = a3;
    id v17 = v11;
    uint64_t v18 = a1;
    char v21 = a4;
    char v22 = a5;
    id v19 = v13;
    dispatch_async(v15, block);
  }
}

void sub_10000AEE0(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 56);
  if (v2 >= (unint64_t)[*(id *)(a1 + 32) count])
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

  else
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 56)]);
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5) {
      id Property = objc_getProperty(v5, v3, 32LL, 1);
    }
    else {
      id Property = 0LL;
    }
    [v4 setCurrentNetworkCharacteristics:Property];
    if ([v4 hasEdges])
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472LL;
      v10[2] = sub_10000B020;
      v10[3] = &unk_1000F9630;
      __int16 v14 = *(_WORD *)(a1 + 64);
      int8x16_t v9 = *(int8x16_t *)(a1 + 32);
      id v7 = (id)v9.i64[0];
      int8x16_t v11 = vextq_s8(v9, v9, 8uLL);
      uint64_t v8 = *(void **)(a1 + 48);
      uint64_t v13 = *(void *)(a1 + 56);
      id v12 = v8;
      [v4 establishTrustWithCompletionHandler:v10];
    }

    else
    {
      sub_10000AE04( *(void *)(a1 + 40),  *(void *)(a1 + 32),  *(void *)(a1 + 56) + 1LL,  *(unsigned __int8 *)(a1 + 64),  *(unsigned __int8 *)(a1 + 65),  *(void *)(a1 + 48));
    }
  }

uint64_t sub_10000B020(uint64_t a1, int a2, char a3)
{
  if (!a2)
  {
    BOOL v3 = 0LL;
    if ((a3 & 1) == 0) {
      goto LABEL_3;
    }
LABEL_5:
    BOOL v4 = 1LL;
    return sub_10000AE04( *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(void *)(a1 + 56) + 1LL,  v3,  v4,  *(void *)(a1 + 48));
  }

  BOOL v3 = *(_BYTE *)(a1 + 64) != 0;
  if ((a3 & 1) != 0) {
    goto LABEL_5;
  }
LABEL_3:
  BOOL v4 = *(_BYTE *)(a1 + 65) != 0;
  return sub_10000AE04( *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(void *)(a1 + 56) + 1LL,  v3,  v4,  *(void *)(a1 + 48));
}

void sub_10000B064(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  BOOL v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;
}

uint64_t sub_10000B09C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = sub_10005725C();
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  sub_100067790((uint64_t)v7);

  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = 0;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3);
  }
  return result;
}

void sub_10000B11C(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v73 = a4;
  id v71 = a5;
  uint64_t v72 = v9;
  if (a2)
  {
    if (v9)
    {
      id v10 = -[NSPConfiguration initWithTimestamp:fromDictionary:waldoSource:]( objc_alloc(&OBJC_CLASS___NSPConfiguration),  "initWithTimestamp:fromDictionary:waldoSource:",  v73,  v9,  1LL);
      if (v10)
      {
        -[NSPConfiguration setIgnoreInvalidCerts:]( v10,  "setIgnoreInvalidCerts:",  [*(id *)(a1 + 32) ignoreInvalidCerts]);
        [*(id *)(a1 + 32) merge:v10];
        [*(id *)(a1 + 32) evaluateEnableRatios];
        id v11 = sub_10005725C();
        id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        sub_100066738((uint64_t)v12);
      }
    }

    uint64_t v13 = *(void **)(a1 + 40);
    if (v13)
    {
      id v14 = sub_10005725C();
      uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = (void *)v15;
      if (v15) {
        id v17 = *(void **)(v15 + 40);
      }
      else {
        id v17 = 0LL;
      }
      id v18 = v17;

      id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 resurrectionDate]);
      if (v19)
      {
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v18 resurrectionDate]);
        [v20 timeIntervalSinceNow];
        double v22 = v21;

        if (v22 > 0.0)
        {
          id v23 = (void *)objc_claimAutoreleasedReturnValue([v18 resurrectionDate]);
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v23,  1LL,  2LL));

          uint64_t v27 = nplog_obj(v24, v25, v26);
          id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v69;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Resurrection date is %@, starting timer",  (uint8_t *)&buf,  0xCu);
          }

          objc_initWeak((id *)&buf, v13);
          id v29 = objc_alloc(&OBJC_CLASS___NSTimer);
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v18 resurrectionDate]);
          v97[0] = _NSConcreteStackBlock;
          v97[1] = 3221225472LL;
          v97[2] = sub_1000086F8;
          v97[3] = &unk_1000F94A0;
          objc_copyWeak(v98, (id *)&buf);
          uint64_t v31 = -[NSTimer initWithFireDate:interval:repeats:block:]( v29,  "initWithFireDate:interval:repeats:block:",  v30,  0LL,  v97,  0.0);
          objc_setProperty_atomic(v13, v32, v31, 40LL);

          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
          id v35 = objc_getProperty(v13, v34, 40LL, 1);
          [v33 addTimer:v35 forMode:NSDefaultRunLoopMode];

          id v36 = sub_10005725C();
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
          sub_100066738((uint64_t)v37);

          objc_destroyWeak(v98);
          objc_destroyWeak((id *)&buf);

          uint64_t v38 = *(void *)(a1 + 40);
          if (v38) {
            *(_BYTE *)(v38 + _Block_object_dispose(va, 8) = 0;
          }
          id v39 = sub_10005725C();
          id v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
          sub_100067790((uint64_t)v40);

          uint64_t v41 = *(void *)(a1 + 48);
          if (v41)
          {
            uint32_t v42 = *(void (**)(void))(v41 + 16);
LABEL_21:
            v42();
            goto LABEL_38;
          }

          goto LABEL_38;
        }
      }

      uint64_t v45 = *(void *)(a1 + 40);
    }

    else
    {
      uint64_t v45 = 0LL;
    }

    v74[0] = _NSConcreteStackBlock;
    v74[1] = 3221225472LL;
    v74[2] = sub_10000B818;
    v74[3] = &unk_1000F96D0;
    v74[4] = v45;
    id v75 = *(id *)(a1 + 48);
    uint64_t v67 = v45;
    v68 = v74;
    if (v45)
    {
      uint64_t v46 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      id v47 = sub_10005725C();
      uint64_t v48 = objc_claimAutoreleasedReturnValue(v47);
      v49 = (void *)v48;
      if (v48) {
        __int16 v50 = *(void **)(v48 + 40);
      }
      else {
        __int16 v50 = 0LL;
      }
      id v70 = v50;

      __int128 v86 = 0u;
      __int128 v87 = 0u;
      __int128 v84 = 0u;
      __int128 v85 = 0u;
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v70 appRules]);
      id v52 = [v51 countByEnumeratingWithState:&v84 objects:v97 count:16];
      if (v52)
      {
        uint64_t v53 = *(void *)v85;
        do
        {
          for (i = 0LL; i != v52; i = (char *)i + 1)
          {
            if (*(void *)v85 != v53) {
              objc_enumerationMutation(v51);
            }
            v55 = *(void **)(*((void *)&v84 + 1) + 8LL * (void)i);
            v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "edgeSetIdentifier", v67, v68));
            if (v56)
            {
              id v57 = (void *)objc_claimAutoreleasedReturnValue([v55 edgeSetIdentifier]);
              unsigned __int8 v58 = -[NSMutableArray containsObject:](v46, "containsObject:", v57);

              if ((v58 & 1) == 0)
              {
                id v59 = (void *)objc_claimAutoreleasedReturnValue([v55 edgeSetIdentifier]);
                -[NSMutableArray addObject:](v46, "addObject:", v59);
              }
            }
          }

          id v52 = [v51 countByEnumeratingWithState:&v84 objects:v97 count:16];
        }

        while (v52);
      }

      v82[0] = 0LL;
      v82[1] = v82;
      v82[2] = 0x3032000000LL;
      v82[3] = sub_100009748;
      v82[4] = sub_100009758;
      id v83 = (id)os_transaction_create("com.apple.networkserviceproxy.fetchHostsFiles");
      uint64_t v76 = 0LL;
      v77 = &v76;
      uint64_t v78 = 0x3032000000LL;
      v79 = sub_10000A680;
      v80 = sub_10000A6A8;
      id v81 = 0LL;
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      v89 = sub_10000A6B0;
      v90 = &unk_1000F9608;
      v60 = v46;
      v91 = v60;
      v94 = v68;
      v95 = v82;
      v96 = &v76;
      id v61 = v70;
      id v92 = v61;
      uint64_t v93 = v67;
      v62 = objc_retainBlock(&buf);
      id v63 = objc_retainBlock(v62);
      v64 = (void *)v77[5];
      v77[5] = (uint64_t)v63;

      (*(void (**)(void))(v77[5] + 16))();
      _Block_object_dispose(&v76, 8);

      _Block_object_dispose(v82, 8);
    }

    goto LABEL_38;
  }

  uint64_t v43 = *(void *)(a1 + 40);
  if (v43) {
    *(_BYTE *)(v43 + _Block_object_dispose(va, 8) = 0;
  }
  uint64_t v44 = *(void *)(a1 + 48);
  if (v44)
  {
    uint32_t v42 = *(void (**)(void))(v44 + 16);
    goto LABEL_21;
  }

LABEL_38:
  objc_msgSend(*(id *)(a1 + 32), "saveToKeychain", v67);
  uint64_t v65 = *(void *)(*(void *)(a1 + 56) + 8LL);
  v66 = *(void **)(v65 + 40);
  *(void *)(v65 + 40) = 0LL;
}

          id v71 = 0u;
          uint64_t v72 = 0u;
          uint64_t v69 = 0u;
          id v70 = 0u;
          uint64_t v26 = a1[43];
          uint64_t v31 = [v26 countByEnumeratingWithState:&v69 objects:v92 count:16];
          if (v31)
          {
            SEL v32 = v31;
            uint64_t v33 = *(void *)v70;
LABEL_40:
            SEL v34 = 0LL;
            while (1)
            {
              if (*(void *)v70 != v33) {
                objc_enumerationMutation(v26);
              }
              if (v32 == (id)++v34)
              {
                SEL v32 = [v26 countByEnumeratingWithState:&v69 objects:v92 count:16];
                if (v32) {
                  goto LABEL_40;
                }
                break;
              }
            }
          }

          -[NSMutableArray addObject:](v54, "addObject:", v7);
          uint64_t v2 = v56;
        }

        if (v7) {
          id v35 = *(void **)(v7 + 24);
        }
        else {
          id v35 = 0LL;
        }
        if ([v35 proxyHop] == 2)
        {
          id v9 = a1[26];
          id v10 = a1[27];
          id v11 = a1[28];
          if ([v11 matchEgress:v7])
          {
LABEL_53:

LABEL_54:
LABEL_55:

            goto LABEL_56;
          }

          id v36 = [a1[29] matchEgress:v7];

          if ((v36 & 1) == 0)
          {
            uint64_t v67 = 0u;
            v68 = 0u;
            uint64_t v65 = 0u;
            v66 = 0u;
            uint64_t v13 = a1[38];
            uint64_t v37 = [v13 countByEnumeratingWithState:&v65 objects:v91 count:16];
            if (v37)
            {
              uint64_t v38 = v37;
              id v39 = *(void *)v66;
LABEL_61:
              id v40 = 0LL;
              while (1)
              {
                if (*(void *)v66 != v39) {
                  objc_enumerationMutation(v13);
                }
                uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( [a1[38] objectForKeyedSubscript:*(void *)(*((void *)&v65 + 1) + 8 * v40)]);
                uint32_t v42 = [v41 matchEgress:v7];

                if ((v42 & 1) != 0) {
                  goto LABEL_84;
                }
                if (v38 == (id)++v40)
                {
                  uint64_t v38 = [v13 countByEnumeratingWithState:&v65 objects:v91 count:16];
                  if (v38) {
                    goto LABEL_61;
                  }
                  break;
                }
              }
            }

            id v63 = 0u;
            v64 = 0u;
            id v61 = 0u;
            v62 = 0u;
            uint64_t v13 = a1[39];
            uint64_t v43 = [v13 countByEnumeratingWithState:&v61 objects:v90 count:16];
            if (v43)
            {
              uint64_t v44 = v43;
              uint64_t v45 = *(void *)v62;
LABEL_69:
              uint64_t v46 = 0LL;
              while (1)
              {
                if (*(void *)v62 != v45) {
                  objc_enumerationMutation(v13);
                }
                id v47 = (void *)objc_claimAutoreleasedReturnValue( [a1[39] objectForKeyedSubscript:*(void *)(*((void *)&v61 + 1) + 8 * v46)]);
                uint64_t v48 = [v47 matchEgress:v7];

                if ((v48 & 1) != 0) {
                  break;
                }
                if (v44 == (id)++v46)
                {
                  uint64_t v44 = [v13 countByEnumeratingWithState:&v61 objects:v90 count:16];
                  if (v44) {
                    goto LABEL_69;
                  }
                  goto LABEL_75;
                }
              }

  -[NSPProxyAnalytics sendAnalytics](v13, "sendAnalytics");
}
    }

      (*((void (**)(id, void, uint64_t, void))v22 + 2))(v22, 0LL, 1008LL, 0LL);
      goto LABEL_83;
    }
  }

  if (a14)
  {
LABEL_49:
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    v133 = 0x3032000000LL;
    v134 = sub_1000A47BC;
    v135 = sub_1000A47CC;
    v136 = (id)os_transaction_create("com.apple.networkserviceproxy.privateaccesstoken");
    uint64_t v67 = sub_1000AB4CC(v21, a14);
    if (v67)
    {
      v127 = 0;
      v68 = (void *)objc_claimAutoreleasedReturnValue([v107 key]);
      uint64_t v69 = sub_10003FAE8((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21, v68, &v127);

      id v70 = v69 == 0LL;
      if (v69)
      {
        (*((void (**)(id, id, void, void))v22 + 2))(v22, v69, 0LL, 0LL);
        id v71 = v127 >= 2;
      }

      else
      {
        id v71 = 0;
      }

      uint64_t v72 = !v71;

      id v73 = dispatch_group_create();
      v74 = v73;
      if (!v72)
      {
        v90 = 0LL;
LABEL_82:
        v94 = NPGetInternalQueue(v73);
        v95 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v94);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_1000A4BA4;
        block[3] = &unk_1000F9428;
        v115 = v90;
        p___int128 buf = &buf;
        v96 = v90;
        dispatch_group_notify(v74, v95, block);

        _Block_object_dispose(&buf, 8);
        goto LABEL_83;
      }

      id v75 = 5;
    }

    else
    {
      id v70 = 1;
      v74 = dispatch_group_create();
      id v75 = 0;
    }

    __int128 v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
    __int128 v85 = (void *)objc_claimAutoreleasedReturnValue([v84 _socketStreamProperties]);
    if (v85)
    {
      __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v84 _socketStreamProperties]);
      __int128 v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v86));
    }

    else
    {
      __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    }

    [v87 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
    objc_msgSend(v84, "set_socketStreamProperties:", v87);
    [v84 setTimeoutIntervalForRequest:60.0];
    objc_msgSend(v84, "set_sourceApplicationAuditTokenData:", v103);
    objc_msgSend(v84, "set_sourceApplicationBundleIdentifier:", v108);
    objc_msgSend(v84, "set_usesNWLoader:", 1);
    v90 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:",  v84));
    [v90 setSessionDescription:@"PrivateAccessTokenFetch"];

    if (v70)
    {
      dispatch_group_enter(v74);
      if (v111) {
        v91 = v75 + 1;
      }
      else {
        v91 = 1;
      }
      v123[0] = _NSConcreteStackBlock;
      v123[1] = 3221225472LL;
      v123[2] = sub_1000A47D4;
      v123[3] = &unk_1000FAC60;
      v126 = v22;
      v124 = v21;
      v125 = v74;
      sub_1000A1138( (uint64_t)self,  v124,  (void *)v111,  v110,  v104,  v107,  v91,  v105,  v109,  v106,  v108,  v113,  0LL,  v90,  v123);
    }

    if (v111)
    {
      if (v67 && !v70)
      {
        dispatch_group_enter(v74);
        v117[0] = _NSConcreteStackBlock;
        v117[1] = 3221225472LL;
        v117[2] = sub_1000A4A88;
        v117[3] = &unk_1000FAC88;
        v118 = v21;
        v74 = v74;
        v119 = v74;
        sub_1000A1138( (uint64_t)self,  v118,  (void *)v111,  v110,  v104,  v107,  v75,  v105,  v109,  v106,  v108,  v113,  0LL,  v90,  v117);
      }
    }

    else if (v67)
    {
      do
      {
        dispatch_group_enter(v74);
        v120[0] = _NSConcreteStackBlock;
        v120[1] = 3221225472LL;
        v120[2] = sub_1000A496C;
        v120[3] = &unk_1000FAC88;
        id v92 = v21;
        v121 = v92;
        uint64_t v93 = v74;
        v122 = v93;
        sub_1000A1138((uint64_t)self, v92, 0LL, v110, v104, v107, 1u, v105, v109, v106, v108, v113, 0LL, v90, v120);

        --v75;
      }

      while (v75);
      v74 = v93;
    }

    goto LABEL_82;
  }

  uint64_t v76 = sub_1000A3830((uint64_t)self, v103, v21, v109, a13);
  if ((v76 & 1) != 0)
  {
    v79 = sub_1000428D8((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21, v109);
    if ((v79 & 1) != 0) {
      goto LABEL_49;
    }
    v82 = nplog_obj(v79, v80, v81);
    id v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_INFO,  "Not allowed to fetch private access token, rate limited",  (uint8_t *)&buf,  2u);
    }

    (*((void (**)(id, void, uint64_t, void))v22 + 2))(v22, 0LL, 1009LL, 0LL);
  }

  else
  {
    v88 = nplog_obj(v76, v77, v78);
    v89 = (os_log_s *)objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_INFO,  "Not allowed to fetch private access token for origin",  (uint8_t *)&buf,  2u);
    }

    (*((void (**)(id, void, uint64_t, void))v22 + 2))(v22, 0LL, 1001LL, 0LL);
  }

void sub_10000B7BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, id location)
{
}

void sub_10000B818(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_10000B888;
  v2[3] = &unk_1000F96A8;
  uint64_t v1 = *(void **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = v1;
  sub_10000AC98(v3, v2);
}

uint64_t sub_10000B888(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = sub_10005725C();
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  sub_100067790((uint64_t)v7);

  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = 0;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3);
  }
  return result;
}

LABEL_53:
  if (selfa) {
    objc_getProperty(selfa, v53, 56LL, 1);
  }
  __int128 v86 = nw_path_evaluator_copy_path();
  __int128 v87 = (void *)v86;
  if (v86)
  {
    v88 = (nw_interface *)nw_path_copy_interface(v86);
    if (v88)
    {
      v89 = +[NPUtilities interfaceTypeOfInterface:](&OBJC_CLASS___NPUtilities, "interfaceTypeOfInterface:", v88);
      v90 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_interface_get_name(v88));
      v91 = objc_claimAutoreleasedReturnValue(v90);
      id v92 = (void *)v91;
      if (v89 == (id)1 && v91)
      {
        uint64_t v93 = WiFiManagerClientCreate(kCFAllocatorDefault, 0LL);
        if (v93)
        {
          v96 = (const void *)v93;
          if (WiFiManagerClientGetDevice(v93, v92))
          {
            v99 = WiFiDeviceClientCopyCurrentNetwork();
            if (v99)
            {
              v102 = (const void *)v99;
              id Property = WiFiNetworkGetProperty(v99, kWiFiScaledRSSIKey);
              v104 = (void *)objc_claimAutoreleasedReturnValue(Property);
              v105 = objc_opt_class(&OBJC_CLASS___NSNumber);
              if ((objc_opt_isKindOfClass(v104, v105) & 1) != 0)
              {
                [v104 doubleValue];
                v107 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)(int)(v106 * 1000.0) / 1000.0));
                -[NSMutableDictionary setObject:forKeyedSubscript:]( v122,  "setObject:forKeyedSubscript:",  v107,  @"signal_wifi");
              }

              CFRelease(v102);
              id v17 = v121;
              goto LABEL_75;
            }

            v113 = nplog_obj(0LL, v100, v101);
            v104 = (void *)objc_claimAutoreleasedReturnValue(v113);
            if (os_log_type_enabled((os_log_t)v104, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              v111 = "Failed to copy the current WiFi network";
              goto LABEL_74;
            }
          }

          else
          {
            v110 = nplog_obj(0LL, v97, v98);
            v104 = (void *)objc_claimAutoreleasedReturnValue(v110);
            if (os_log_type_enabled((os_log_t)v104, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              v111 = "Failed to get the WiFi device";
LABEL_74:
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)v104, OS_LOG_TYPE_DEFAULT, v111, buf, 2u);
            }
          }

  -[NSPConfigurationStats setNewsEmbeddedContentEnabled:](v15, "setNewsEmbeddedContentEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x800) == 0)
  {
LABEL_28:
    if ((v12 & 0x1000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_55;
  }

  double v22 = self;
  objc_msgSend(objc_getProperty(self, v46, 64, 1), "removeObjectsInArray:", v29);
  uint64_t v72 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v47, 64, 1), "count") >= 0xB)
  {
    v49 = (char *)objc_msgSend(objc_getProperty(self, v48, 64, 1), "count");
    v80 = 0u;
    id v81 = 0u;
    v82 = 0u;
    id v83 = 0u;
    uint64_t v51 = objc_getProperty(self, v50, 64LL, 1);
    id v52 = [v51 countByEnumeratingWithState:&v80 objects:v89 count:16];
    if (v52)
    {
      uint64_t v53 = v52;
      uint64_t v54 = v49 - 10;
      v55 = *(void *)v81;
LABEL_56:
      v56 = 0LL;
      while (1)
      {
        if (*(void *)v81 != v55) {
          objc_enumerationMutation(v51);
        }
        if (!v54) {
          break;
        }
        id v57 = *(void *)(*((void *)&v80 + 1) + 8 * v56);
        if (v57) {
          unsigned __int8 v58 = *(void **)(v57 + 8);
        }
        else {
          unsigned __int8 v58 = 0LL;
        }
        id v59 = v58;
        v60 = [v59 networkType];
        if (v60 == -[PrivacyProxyNetworkStatus networkType](v27, "networkType") && v57)
        {
          id v61 = *(void *)(v57 + 24);

          if (v61)
          {
            -[NSMutableArray addObject:](v72, "addObject:", v57);
            --v54;
          }
        }

        else
        {
        }

        if (v53 == (id)++v56)
        {
          v62 = [v51 countByEnumeratingWithState:&v80 objects:v89 count:16];
          uint64_t v53 = v62;
          if (v62) {
            goto LABEL_56;
          }
          break;
        }
      }
    }

    double v22 = self;
  }

  objc_msgSend(objc_getProperty(v22, v48, 64, 1), "removeObjectsInArray:", v72);
  id v63 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyNetworkStatusTime);
  sub_100011668((uint64_t)v63, v27);
  sub_10003ED60((uint64_t)v63, v28);
  objc_msgSend(objc_getProperty(v22, v64, 64, 1), "addObject:", v63);
  sub_100099658(v22);

  id v7 = v73;
  uint64_t v13 = v68;
  id v12 = v69;
LABEL_73:

  ++v22[6];
  +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-service-status-changed");
LABEL_74:
  v79 = (v22[10] == 2LL) & v12;

  uint64_t v65 = v79;
LABEL_75:

  return v65;
}

LABEL_75:
          CFRelease(v96);
          goto LABEL_76;
        }

        v108 = nplog_obj(0LL, v94, v95);
        v109 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v109,  OS_LOG_TYPE_DEFAULT,  "Failed to create a WiFi manager",  buf,  2u);
        }
      }
    }

    else
    {
      id v92 = 0LL;
    }
  }

  else
  {
    id v92 = 0LL;
    v88 = 0LL;
  }

            id v59 = 0u;
            v60 = 0u;
            id v57 = 0u;
            unsigned __int8 v58 = 0u;
            uint64_t v26 = a1[40];
            v49 = [v26 countByEnumeratingWithState:&v57 objects:v89 count:16];
            uint64_t v5 = v55;
            if (v49)
            {
              __int16 v50 = v49;
              uint64_t v51 = *(void *)v58;
LABEL_77:
              id v52 = 0LL;
              while (1)
              {
                if (*(void *)v58 != v51) {
                  objc_enumerationMutation(v26);
                }
                if (v50 == (id)++v52)
                {
                  __int16 v50 = [v26 countByEnumeratingWithState:&v57 objects:v89 count:16];
                  if (v50) {
                    goto LABEL_77;
                  }
                  break;
                }
              }
            }

            -[NSMutableArray addObject:](v54, "addObject:", v7);
            goto LABEL_86;
          }
        }

LABEL_76:
  -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v122, @"connection");
  return v17;
}

BOOL sub_10000C67C(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) tokenKeyInfo]);
  BOOL v2 = [v1 length] != 0;

  return v2;
}

void sub_10000C6C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = *(id *)(a1 + 24);
      id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 vendor]);
      int v14 = 138412290;
      uint64_t v15 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "reset token fetch timer for %@",  (uint8_t *)&v14,  0xCu);
    }

    uint64_t v8 = *(dispatch_source_s **)(a1 + 64);
    if (v8)
    {
      dispatch_source_cancel(v8);
      id v9 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0LL;
    }

    id v10 = *(void **)(a1 + 80);
    *(void *)(a1 + 72) = 0LL;
    *(void *)(a1 + 80) = 0LL;
    *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 0;

    id v11 = (id *)(a1 + 16);
    id WeakRetained = objc_loadWeakRetained(v11);
    [WeakRetained updateUserEventAgentData];

    id v13 = objc_loadWeakRetained(v11);
    [v13 setUserEventAgentTokenFetchParameters];
  }

void sub_10000C7E4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 64), a2);
  }
}

void sub_10000C7F4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 80), a2);
  }
}

void sub_10000C93C(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) vendor]);

    if (v2)
    {
      uint64_t v6 = nplog_obj(v3, v4, v5);
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        id v8 = *(id *)(a1 + 24);
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 vendor]);
        int v11 = 138412290;
        id v12 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Removing proxy tokens for %@ from keychain",  (uint8_t *)&v11,  0xCu);
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) vendor]);
      +[NPUtilities removeDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.ProxyToken",  v10);
    }
  }

void sub_10000CAB4(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = *(void **)(a1 + 80);
    if (v2)
    {
      [v2 timeIntervalSinceNow];
      if (v4 <= 0.0)
      {
        v10[0] = 0LL;
        v10[1] = v10;
        v10[2] = 0x3032000000LL;
        v10[3] = sub_10000CED4;
        void v10[4] = sub_10000CEE4;
        id v11 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenManagerRetry");
        uint64_t v5 = NPGetInternalQueue(v11);
        uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472LL;
        v9[2] = sub_10000CEEC;
        v9[3] = &unk_1000F9428;
        v9[4] = a1;
        v9[5] = v10;
        dispatch_async(v6, v9);

        _Block_object_dispose(v10, 8);
      }

      else
      {
        sub_10000CBD4(a1, (unint64_t)v4, v3);
      }
    }

    id v7 = sub_10000D2EC(a1);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

    if (v8) {
      sub_10000D5C4(a1);
    }
  }

void sub_10000CBBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000CBD4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2;
  uint64_t v5 = *(dispatch_source_s **)(a1 + 64);
  if (v5)
  {
    dispatch_source_cancel(v5);
    uint64_t v6 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = 0LL;
  }

  if (!v3)
  {
    unint64_t v7 = *(void *)(a1 + 72);
    if (v7 < 8)
    {
      int v10 = dword_1000C3734[v7];
      uint64_t v5 = (dispatch_source_s *)arc4random_uniform(6u);
      unint64_t v3 = ((_DWORD)v5 + v10);
    }

    else
    {
      uint64_t v8 = nplog_obj(v5, a2, a3);
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        id v29 = *(id *)(a1 + 24);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 vendor]);
        *(_DWORD *)__int128 buf = 138412546;
        SEL v34 = v30;
        __int16 v35 = 1024;
        LODWORD(v36) = 8;
        _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Failed to fetch tokens for %@ after %u attempts",  buf,  0x12u);
      }

      uint64_t v5 = (dispatch_source_s *)arc4random_uniform(6u);
      unint64_t v3 = ((_DWORD)v5 + 1800);
    }
  }

  uint64_t v11 = nplog_obj(v5, a2, a3);
  id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = *(id *)(a1 + 24);
    int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 vendor]);
    *(_DWORD *)__int128 buf = 138412546;
    SEL v34 = v14;
    __int16 v35 = 2048;
    unint64_t v36 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Retry: fetching token for %@ after %lu seconds",  buf,  0x16u);
  }

  uint64_t v16 = NPGetInternalQueue(v15);
  id v17 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v16);
  dispatch_source_t v18 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v17);
  id v19 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v18;

  if (*(void *)(a1 + 64))
  {
    uint64_t v20 = (dispatch_source_s *)*(id *)(a1 + 64);
    dispatch_time_t v21 = dispatch_time(0x8000000000000000LL, 1000000000 * v3);
    dispatch_source_set_timer(v20, v21, 0xFFFFFFFFFFFFFFFFLL, 0LL);

    objc_initWeak((id *)buf, (id)a1);
    double v22 = *(void **)(a1 + 64);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10000F930;
    handler[3] = &unk_1000F97C0;
    id v23 = v22;
    objc_copyWeak(&v32, (id *)buf);
    dispatch_source_set_event_handler(v23, handler);

    dispatch_resume(*(dispatch_object_t *)(a1 + 64));
    objc_destroyWeak(&v32);
    objc_destroyWeak((id *)buf);
  }

  uint64_t v24 = objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceNow:", (double)v3));
  uint64_t v25 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v24;

  uint64_t v26 = (id *)(a1 + 16);
  id WeakRetained = objc_loadWeakRetained(v26);
  [WeakRetained updateUserEventAgentData];

  id v28 = objc_loadWeakRetained(v26);
  [v28 setUserEventAgentTokenFetchParameters];
}

uint64_t sub_10000CED4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10000CEE4(uint64_t a1)
{
}

void sub_10000CEEC(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_10000CF44;
  v2[3] = &unk_1000F9748;
  uint64_t v1 = *(void *)(a1 + 32);
  void v2[4] = *(void *)(a1 + 40);
  sub_10000CF58(v1, v2);
}

void sub_10000CF44(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  BOOL v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_10000CF58(uint64_t a1, void *a2)
{
  unint64_t v3 = a2;
  if (!a1) {
    goto LABEL_8;
  }
  BOOL v4 = sub_10000C67C(a1);
  if (!v4) {
    goto LABEL_6;
  }
  unint64_t v7 = 30LL;
  if (!*(_BYTE *)(a1 + 11)) {
    unint64_t v7 = 10LL;
  }
  if (*(void *)(a1 + 32) > v7)
  {
LABEL_6:
    if (v3) {
      v3[2](v3, 1LL);
    }
    goto LABEL_8;
  }

  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v8 = nplog_obj(v4, v5, v6);
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = *(id *)(a1 + 24);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 vendor]);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "token fetch request for %@ is already pending",  (uint8_t *)&buf,  0xCu);
    }

    if (v3) {
      goto LABEL_24;
    }
  }

  else if (*(void *)(a1 + 64))
  {
    uint64_t v12 = nplog_obj(v4, v5, v6);
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      id v14 = *(id *)(a1 + 24);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 vendor]);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "token fetch request for %@ has a pending timer",  (uint8_t *)&buf,  0xCu);
    }

    if (v3) {
      goto LABEL_24;
    }
  }

  else
  {
    id v16 = [*(id *)(a1 + 56) status];
    if (v16 == (id)1)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v31 = 0x3032000000LL;
      id v32 = sub_10000CED4;
      uint64_t v33 = sub_10000CEE4;
      id v34 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenManagerRefreshPool");
      objc_initWeak(&location, (id)a1);
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472LL;
      v25[2] = sub_10000EB24;
      v25[3] = &unk_1000F9798;
      objc_copyWeak(&v28, &location);
      uint64_t v26 = v3;
      p___int128 buf = &buf;
      [WeakRetained requestAccessTokenWithCompletionHandler:v25];

      objc_destroyWeak(&v28);
      objc_destroyWeak(&location);
      _Block_object_dispose(&buf, 8);

      goto LABEL_8;
    }

    uint64_t v20 = nplog_obj(v16, v17, v18);
    dispatch_time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      id v22 = *(id *)(a1 + 24);
      id v23 = (void *)objc_claimAutoreleasedReturnValue([v22 vendor]);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "deferring token fetch for %@, path is not satisfied",  (uint8_t *)&buf,  0xCu);
    }

    *(_BYTE *)(a1 + 9) = 1;
    id v24 = objc_loadWeakRetained((id *)(a1 + 16));
    [v24 setUserEventAgentTokenFetchParameters];

    if (v3) {
LABEL_24:
    }
      v3[2](v3, 0LL);
  }

LABEL_8:
}

    uint64_t v6 = 60LL;
    goto LABEL_12;
  }

  if (v5 == 10) {
    goto LABEL_8;
  }
LABEL_9:
  unint64_t v7 = nplog_obj(a1, a2, a3, a4);
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    id v9 = *(_DWORD *)(a1 + 12);
    v10[0] = 67109120;
    v10[1] = v9;
    _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "unknown link quality value %d",  (uint8_t *)v10,  8u);
  }

  uint64_t v6 = 30LL;
LABEL_12:
  *(void *)(a1 + 72) = v6;
}

LABEL_9:
}

    id v14 = 1LL;
    goto LABEL_9;
  }

    id v14 = 1LL;
    goto LABEL_9;
  }

  if ([v4 type] == (id)1)
  {
    if (self)
    {
      uint64_t v51 = 0u;
      id v52 = 0u;
      v49 = 0u;
      __int16 v50 = 0u;
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[NSPServiceStatusManager serviceStatus](self->_serviceStatusManager, "serviceStatus"));
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 networkStatuses]);

      id v13 = [v12 countByEnumeratingWithState:&v49 objects:buf count:16];
      if (v13)
      {
        id v14 = v13;
        uint64_t v15 = v5;
        id v16 = 0LL;
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)v50;
        do
        {
          for (i = 0LL; i != v14; i = (char *)i + 1)
          {
            if (*(void *)v50 != v18) {
              objc_enumerationMutation(v12);
            }
            uint64_t v20 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)i);
            if ([v20 networkType] == 1)
            {
              if (![v20 networkStatus]) {
                goto LABEL_38;
              }
              if ([v20 networkStatus] == (id)2)
              {
                dispatch_time_t v21 = objc_claimAutoreleasedReturnValue([v20 networkName]);

                uint64_t v17 = 1;
                id v16 = (void *)v21;
              }
            }
          }

          id v14 = [v12 countByEnumeratingWithState:&v49 objects:buf count:16];
        }

        while (v14);

        if ((v17 & 1) != 0)
        {
          -[NSPServiceStatusManager reportActiveOnWiFiName:]( self->_serviceStatusManager,  "reportActiveOnWiFiName:",  v16);
          uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
          [v12 wifiDisabled:0];
LABEL_38:
          uint64_t v5 = v15;
LABEL_40:

LABEL_41:
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      goto LABEL_39;
    }

    goto LABEL_60;
  }

  if ([v4 type] != (id)2)
  {
    uint64_t v30 = v4;
    if (self)
    {
      uint64_t v31 = v30;
      if ([v30 type] == (id)3)
      {
        id v47 = v5;
        uint64_t v48 = v4;
        id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 interfaceName]);
        uint64_t v46 = sub_100074C28(v32);
        v49 = 0u;
        __int16 v50 = 0u;
        uint64_t v51 = 0u;
        id v52 = 0u;
        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(-[NSPServiceStatusManager serviceStatus](self->_serviceStatusManager, "serviceStatus"));
        id v34 = (void *)objc_claimAutoreleasedReturnValue([v33 networkStatuses]);

        __int16 v35 = [v34 countByEnumeratingWithState:&v49 objects:buf count:16];
        if (v35)
        {
          unint64_t v36 = v35;
          uint64_t v37 = 0;
          uint64_t v38 = *(void *)v50;
          do
          {
            for (j = 0LL; j != v36; j = (char *)j + 1)
            {
              if (*(void *)v50 != v38) {
                objc_enumerationMutation(v34);
              }
              id v40 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)j);
              if ([v40 networkType] == 3)
              {
                uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v40 networkName]);
                uint32_t v42 = [v41 isEqualToString:v32];

                if (v42)
                {
                  if (![v40 networkStatus]) {
                    goto LABEL_57;
                  }
                  v37 |= [v40 networkStatus] == (id)2;
                }
              }
            }

            unint64_t v36 = [v34 countByEnumeratingWithState:&v49 objects:buf count:16];
          }

          while (v36);

          uint64_t v43 = (void *)v46;
          if ((v37 & 1) != 0)
          {
            -[NSPServiceStatusManager reportActiveOnInterfaceName:displayName:type:]( self->_serviceStatusManager,  "reportActiveOnInterfaceName:displayName:type:",  v32,  v46,  3LL);
            sub_10006A2F8((uint64_t)self);
          }
        }

        else
        {
LABEL_57:

          uint64_t v43 = (void *)v46;
        }

        uint64_t v5 = v47;
        BOOL v4 = v48;
      }
    }

    goto LABEL_59;
  }

  if (self)
  {
    uint64_t v51 = 0u;
    id v52 = 0u;
    v49 = 0u;
    __int16 v50 = 0u;
    id v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSPServiceStatusManager serviceStatus](self->_serviceStatusManager, "serviceStatus"));
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v22 networkStatuses]);

    id v23 = [v12 countByEnumeratingWithState:&v49 objects:buf count:16];
    if (v23)
    {
      id v24 = v23;
      uint64_t v15 = v5;
      id v16 = 0LL;
      uint64_t v25 = 0;
      uint64_t v26 = *(void *)v50;
      do
      {
        for (k = 0LL; k != v24; k = (char *)k + 1)
        {
          if (*(void *)v50 != v26) {
            objc_enumerationMutation(v12);
          }
          id v28 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)k);
          if ([v28 networkType] == 2)
          {
            if (![v28 networkStatus]) {
              goto LABEL_38;
            }
            if ([v28 networkStatus] == (id)2)
            {
              id v29 = objc_claimAutoreleasedReturnValue([v28 networkName]);

              uint64_t v25 = 1;
              id v16 = (void *)v29;
            }
          }
        }

        id v24 = [v12 countByEnumeratingWithState:&v49 objects:buf count:16];
      }

      while (v24);

      if ((v25 & 1) != 0)
      {
        -[NSPServiceStatusManager reportActiveOnCellularName:]( self->_serviceStatusManager,  "reportActiveOnCellularName:",  v16);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
        [v12 cellularDisabled:0];
        goto LABEL_38;
      }

    id v10 = 0LL;
    goto LABEL_9;
  }

  [(id)qword_100117178 setParentContext:v5];
  id v10 = (id)qword_100117178;
LABEL_9:

  return v10;
}

      id v23 = v19;
      goto LABEL_21;
    }
  }

  else if (v10)
  {
    uint64_t v15 = +[NEProcessInfo copyUUIDsForExecutable:](&OBJC_CLASS___NEProcessInfo, "copyUUIDsForExecutable:", v10);
    if (!v15)
    {
      id v22 = nplog_obj(0LL, v20, v21);
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        __int16 v50 = v12;
        uint64_t v51 = 2112;
        id v52 = v10;
        goto LABEL_23;
      }

      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  id v39 = v10;
  id v40 = v9;
  uint64_t v45 = 0u;
  uint64_t v46 = 0u;
  uint64_t v43 = 0u;
  uint64_t v44 = 0u;
  id v23 = (os_log_s *)v15;
  uint32_t v42 = -[os_log_s countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v43,  v48,  16LL);
  if (v42)
  {
    id v24 = *(void *)v44;
    uint64_t v25 = &AnalyticsSendEventLazy_ptr;
    uint64_t v41 = a4;
    do
    {
      for (i = 0LL; i != v42; i = (char *)i + 1)
      {
        if (*(void *)v44 != v24) {
          objc_enumerationMutation(v23);
        }
        uint64_t v27 = *(void **)(*((void *)&v43 + 1) + 8LL * (void)i);
        id v28 = (uint64_t)(p_superclass + 459);
        id v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25[81], "skipWithOrder:", 600, v39, v40));
        if ((a4 & 1) != 0)
        {
          uint64_t v30 = v23;
          uint64_t v31 = v11;
          id v32 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
          id v47 = v32;
          uint64_t v33 = v25;
          id v34 = v24;
          __int16 v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v47,  1LL));
          unint64_t v36 = sub_10008026C(v28, 400LL, v29, v27, 0LL, 0LL, v35, 0);
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);

          id v24 = v34;
          uint64_t v25 = v33;

          uint64_t v11 = v31;
          id v23 = v30;
          a4 = v41;
          p_superclass = (__objc2_class **)(&OBJC_CLASS___NSPAuxiliaryAuthInfo + 8);
        }

        else
        {
          uint64_t v38 = sub_10008026C((uint64_t)(p_superclass + 459), 400LL, v29, v27, 0LL, 0LL, 0LL, 0);
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v38);
        }

        [v11 addObject:v37];
      }

      uint32_t v42 = -[os_log_s countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v43,  v48,  16LL);
    }

    while (v42);
  }

  id v10 = v39;
  id v9 = v40;
LABEL_21:
}
}

void sub_10000D2BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

id sub_10000D2EC(uint64_t a1)
{
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) vendor]);
  id v3 = +[NPUtilities copyDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "copyDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.ProxyToken",  v2);

  if (v3)
  {
    uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSArray);
    uint64_t v5 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v4,  objc_opt_class(&OBJC_CLASS___NSPToken),  0LL);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    id v35 = 0LL;
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v6,  v3,  &v35));
    id v8 = v35;

    if (v7) {
      BOOL v12 = v8 == 0LL;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v7));
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      id v16 = [v15 countByEnumeratingWithState:&v31 objects:v40 count:16];
      if (v16)
      {
        id v19 = v16;
        uint64_t v20 = 0LL;
        uint64_t v21 = *(void *)v32;
        do
        {
          for (i = 0LL; i != v19; i = (char *)i + 1)
          {
            if (*(void *)v32 != v21) {
              objc_enumerationMutation(v15);
            }
            id v23 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)i);
            if (v23) {
              id v23 = (void *)v23[1];
            }
            id v24 = v23;
            v20 += (uint64_t)[v24 count];
          }

          id v19 = [v15 countByEnumeratingWithState:&v31 objects:v40 count:16];
        }

        while (v19);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      *(void *)(a1 + 32) = v20;
      uint64_t v25 = nplog_obj(0LL, v17, v18);
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        id v28 = *(void **)(a1 + 32);
        id v29 = *(id *)(a1 + 24);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 vendor]);
        *(_DWORD *)__int128 buf = 134218242;
        id v37 = v28;
        __int16 v38 = 2112;
        id v39 = v30;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "Received %lu tokens from keychain for %@",  buf,  0x16u);
      }
    }

    else
    {
      uint64_t v13 = nplog_obj(v9, v10, v11);
      id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v37 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "unarchivedObjectOfClass for token info list failed with error: %@",  buf,  0xCu);
      }

      uint64_t v15 = 0LL;
      *(void *)(a1 + 32) = 0LL;
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  return v15;
}

void sub_10000D5C4(uint64_t a1)
{
  if (a1 && sub_10000C67C(a1))
  {
    BOOL v2 = (uint64_t *)(a1 + 40);
    if (!*(void *)(a1 + 40))
    {
      id v3 = objc_alloc(&OBJC_CLASS___NSPPrivacyProxyTokenRegistration);
      uint64_t v4 = *(void **)(a1 + 48);
      id v5 = *(id *)(a1 + 24);
      id v6 = v4;
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 vendor]);
      id v8 = sub_100005814((id *)&v3->super.isa, v6, v7, (void *)a1);
      objc_storeStrong((id *)(a1 + 40), v8);

      id v10 = *(id *)(a1 + 40);
      if (*(_BYTE *)(a1 + 11))
      {
        else {
          uint64_t v11 = 5LL;
        }
      }

      else
      {
        uint64_t v11 = 5LL;
      }

      sub_100006400((uint64_t)v10, v11, v9);
    }

    sub_10000E04C(a1);
    uint64_t v15 = *(void *)(a1 + 40);
    if (v15)
    {
      id v12 = [*(id *)(v15 + 24) tokenCount];
      unint64_t v16 = v12;
    }

    else
    {
      unint64_t v16 = 0LL;
    }

    if (*(void *)(a1 + 32))
    {
      if (*(_BYTE *)(a1 + 11))
      {
        id v12 = [*(id *)(a1 + 24) proxyHop];
        unint64_t v17 = 10LL;
        if ((_DWORD)v12 == 1) {
          unint64_t v17 = 30LL;
        }
      }

      else
      {
        unint64_t v17 = 10LL;
      }

      if (v16 < v17)
      {
        unint64_t v18 = *(void *)(a1 + 32);
        if (*(_BYTE *)(a1 + 11))
        {
          id v12 = [*(id *)(a1 + 24) proxyHop];
          uint64_t v19 = 10LL;
          if ((_DWORD)v12 == 1) {
            uint64_t v19 = 30LL;
          }
        }

        else
        {
          uint64_t v19 = 10LL;
        }

        if (v18 <= v19 - v16)
        {
          unint64_t v21 = *(void *)(a1 + 32);
        }

        else
        {
          if (*(_BYTE *)(a1 + 11))
          {
            id v12 = [*(id *)(a1 + 24) proxyHop];
            uint64_t v20 = 10LL;
            if ((_DWORD)v12 == 1) {
              uint64_t v20 = 30LL;
            }
          }

          else
          {
            uint64_t v20 = 10LL;
          }

          unint64_t v21 = v20 - v16;
        }

        uint64_t v22 = nplog_obj(v12, v13, v14);
        id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          id v24 = *(id *)(a1 + 24);
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 vendor]);
          *(_DWORD *)__int128 buf = 134218242;
          unint64_t v55 = v21;
          __int16 v56 = 2112;
          id v57 = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "adding %lu tokens to token agent[%@]",  buf,  0x16u);
        }

        *(void *)(a1 + 96) += v21;
        if (v21)
        {
          uint64_t v26 = objc_alloc_init(&OBJC_CLASS___NSPProxyAgentStats);
          uint64_t v27 = sub_10000F274(a1);
          id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
          -[NSPProxyAgentStats setTierType:](v26, "setTierType:", v28);

          else {
            -[NSPProxyAgentStats setEgressProxyTokensAdded:](v26, "setEgressProxyTokensAdded:", v21);
          }
          uint64_t v51 = v26;
          -[NSPProxyAnalytics sendAnalytics](v26, "sendAnalytics");
          id v29 = sub_10000D2EC(a1);
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
          id v52 = [v30 count];
          if (v52)
          {
            uint64_t v31 = 0LL;
            while (1)
            {
              uint64_t v32 = objc_claimAutoreleasedReturnValue([v30 firstObject]);
              __int128 v33 = (void *)v32;
              if (v32) {
                __int128 v34 = *(void **)(v32 + 8);
              }
              else {
                __int128 v34 = 0LL;
              }
              id v35 = v34;
              if ((unint64_t)[v35 count] <= v21)
              {
                if (v33) {
                  id v37 = (void *)v33[1];
                }
                else {
                  id v37 = 0LL;
                }
                id v38 = v37;
                unint64_t v36 = (unint64_t)[v38 count];

                if (!v36) {
                  goto LABEL_56;
                }
              }

              else
              {

                unint64_t v36 = v21;
              }

              unint64_t v39 = v36;
              do
              {
                if (v33) {
                  id v40 = (void *)v33[1];
                }
                else {
                  id v40 = 0LL;
                }
                id v41 = v40;
                uint32_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 firstObject]);

                sub_100005E08(*v2, v42);
                if (v33) {
                  uint64_t v43 = (void *)v33[1];
                }
                else {
                  uint64_t v43 = 0LL;
                }
                id v44 = v43;
                [v44 removeObject:v42];

                --v39;
              }

              while (v39);
LABEL_56:
              *(void *)(a1 + 32) -= v36;
              if (v33) {
                uint64_t v45 = (void *)v33[1];
              }
              else {
                uint64_t v45 = 0LL;
              }
              id v46 = v45;
              id v47 = [v46 count];

              if (!v47) {
                [v30 removeObject:v33];
              }
              v21 -= v36;

              if (v21)
              {
                if ((id)++v31 != v52) {
                  continue;
                }
              }

              break;
            }
          }

          sub_10000E4E4(a1, (uint64_t)v30);
        }

        if (*v2)
        {
          id v48 = [*(id *)(*v2 + 24) tokenCount];
          if ((_DWORD)v48)
          {
            uint64_t v49 = NPGetInternalQueue(v48);
            __int16 v50 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v49);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_10000F324;
            block[3] = &unk_1000F9450;
            void block[4] = a1;
            dispatch_async(v50, block);
          }
        }
      }
    }
  }

void sub_10000E01C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 24), a2);
  }
}

void sub_10000E02C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 40), a2);
  }
}

void sub_10000E03C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 56), a2);
  }
}

void sub_10000E04C(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 32))
    {
      BOOL v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      id v3 = sub_10000D2EC(a1);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      uint64_t v5 = *(void *)(a1 + 32);
      id v6 = (char *)[v4 count];
      if (v6)
      {
        uint64_t v9 = v6;
        for (i = 0LL; i != v9; ++i)
        {
          uint64_t v11 = objc_claimAutoreleasedReturnValue([v4 objectAtIndexedSubscript:i]);
          id v12 = (id *)v11;
          if (v11) {
            uint64_t v13 = *(void **)(v11 + 24);
          }
          else {
            uint64_t v13 = 0LL;
          }
          id v14 = v13;
          [v14 timeIntervalSinceNow];
          BOOL v16 = v15 > 0.0;

          if (!v16)
          {
            if (v12) {
              id v17 = v12[1];
            }
            else {
              id v17 = 0LL;
            }
            unint64_t v18 = *(void *)(a1 + 32);
            id v19 = v17;
            LODWORD(v1_Block_object_dispose(va, 8) = v18 < (unint64_t)[v19 count];

            if ((_DWORD)v18)
            {
              uint64_t v26 = nplog_obj(v20, v21, v22);
              uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
              if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
              {
                id v28 = *(id *)(a1 + 24);
                uint64_t v29 = objc_claimAutoreleasedReturnValue([v28 vendor]);
                *(_DWORD *)__int128 buf = 138412290;
                *(void *)&uint8_t buf[4] = v29;
                uint64_t v49 = (void *)v29;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "self.tokenCount < tokenInfo.tokens.count for %@",  buf,  0xCu);
              }
            }

            if (v12)
            {
              id v23 = v12[1];
              *(void *)(a1 + 104) += [v23 count];

              id v24 = v12[1];
            }

            else
            {
              *(void *)(a1 + 104) += [0 count];
              id v24 = 0LL;
            }

            id v25 = v24;
            *(void *)(a1 + 32) -= [v25 count];

            -[NSMutableArray addObject:](v2, "addObject:", v12);
          }
        }
      }

      uint64_t v30 = nplog_obj(v6, v7, v8);
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = *(void *)(a1 + 32);
        id v33 = *(id *)(a1 + 24);
        __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v33 vendor]);
        *(_DWORD *)__int128 buf = 134218242;
        *(void *)&uint8_t buf[4] = v5 - v32;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v34;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Cleaned up %lu expired tokens for %@",  buf,  0x16u);
      }

      [v4 removeObjectsInArray:v2];
      if (v5 != *(void *)(a1 + 32))
      {
        sub_10000E4E4(a1, (uint64_t)v4);
        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
        id v46 = *(id *)(a1 + 24);
        id v47 = (void *)objc_claimAutoreleasedReturnValue([v46 vendor]);
        uint64_t v48 = sub_10000E688(a1);

        +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v45,  5LL,  v47,  v48);
      }
    }

    BOOL v35 = sub_10000C67C(a1);
    if (v35)
    {
      unint64_t v38 = 30LL;
      if (!*(_BYTE *)(a1 + 11)) {
        unint64_t v38 = 10LL;
      }
      if (*(void *)(a1 + 32) <= v38)
      {
        uint64_t v39 = nplog_obj(v35, v36, v37);
        id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue(v39);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          id v41 = *(id *)(a1 + 24);
          uint32_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 vendor]);
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v42;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Proxy %@, hit cached low water mark",  buf,  0xCu);
        }

        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000LL;
        id v52 = sub_10000CED4;
        uint64_t v53 = sub_10000CEE4;
        id v54 = (id)os_transaction_create("com.apple.networkserviceproxy.removeExpiredTokens");
        uint64_t v43 = NPGetInternalQueue(v54);
        id v44 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v43);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10000E6BC;
        block[3] = &unk_1000F9428;
        void block[4] = a1;
        void block[5] = buf;
        dispatch_async(v44, block);

        _Block_object_dispose(buf, 8);
      }
    }
  }

void sub_10000E4C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10000E4E4(uint64_t a1, uint64_t a2)
{
  id v14 = 0LL;
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  a2,  1LL,  &v14));
  id v4 = v14;
  uint64_t v7 = nplog_obj(v4, v5, v6);
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = v8;
  if (v3) {
    BOOL v10 = v4 == 0LL;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void **)(a1 + 32);
      id v12 = *(id *)(a1 + 24);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 vendor]);
      *(_DWORD *)__int128 buf = 134218242;
      id v16 = v11;
      __int16 v17 = 2112;
      unint64_t v18 = v13;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Saving %lu proxy tokens for %@ in the keychain",  buf,  0x16u);
    }

    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) vendor]);
    +[NPUtilities saveDataToKeychain:withIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "saveDataToKeychain:withIdentifier:accountName:",  v3,  @"com.apple.NetworkServiceProxy.ProxyToken",  v9);
  }

  else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v16 = v4;
    _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for token info list failed with error: %@",  buf,  0xCu);
  }
}

uint64_t sub_10000E688(uint64_t result)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 32);
    uint64_t v1 = *(void *)(result + 40);
    if (v1) {
      uint64_t v1 = [*(id *)(v1 + 24) tokenCount];
    }
    return v1 + v2;
  }

  return result;
}

void sub_10000E6BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10000E718(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = *(id *)(a1 + 24);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 vendor]);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Flushing tokens for %@",  (uint8_t *)&buf,  0xCu);
    }

    *(void *)(a1 + 32) = 0LL;
    sub_10000C93C(a1);
    sub_10000E8B4(a1);
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v12 = 0x3032000000LL;
    uint64_t v13 = sub_10000CED4;
    id v14 = sub_10000CEE4;
    id v15 = (id)os_transaction_create("com.apple.networkserviceproxy.flushProxyTokensLowWaterMark");
    uint64_t v8 = NPGetInternalQueue(v15);
    uint64_t v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v8);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_10000EAC8;
    v10[3] = &unk_1000F9428;
    void v10[4] = a1;
    void v10[5] = &buf;
    dispatch_async(v9, v10);

    _Block_object_dispose(&buf, 8);
  }

void sub_10000E894( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000E8B4(uint64_t a1)
{
  if (a1 && sub_10000C67C(a1))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      uint64_t v2 = [*(id *)(v2 + 24) tokenCount];
    }
    if (!(v2 + v3))
    {
      v17[0] = 0LL;
      v17[1] = v17;
      v17[2] = 0x3032000000LL;
      v17[3] = sub_10000CED4;
      v17[4] = sub_10000CEE4;
      id v18 = (id)os_transaction_create("com.apple.networkserviceproxy.emptyProxyTokens");
      uint64_t v6 = nplog_obj(v18, v4, v5);
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = *(id *)(a1 + 24);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 vendor]);
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v20 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "no tokens available for proxy[%@]", buf, 0xCu);
      }

      BOOL v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
      id v11 = *(id *)(a1 + 24);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 vendor]);
      +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v10,  1LL,  v12,  0LL);

      uint64_t v14 = NPGetInternalQueue(v13);
      id v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      v16[2] = sub_10000F7A0;
      v16[3] = &unk_1000F9428;
      void v16[4] = a1;
      v16[5] = v17;
      dispatch_async(v15, v16);

      _Block_object_dispose(v17, 8);
    }
  }

void sub_10000EAA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000EAC8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10000EB24(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v71[0] = _NSConcreteStackBlock;
    v71[1] = 3221225472LL;
    uint64_t v72 = sub_10000F238;
    id v73 = &unk_1000F9770;
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    id v74 = v6;
    uint64_t v75 = v7;
    id v8 = v4;
    uint64_t v9 = v71;
    uint64_t v12 = v9;
    if (WeakRetained[3])
    {
      BOOL v13 = sub_10000C67C((uint64_t)WeakRetained);
      if (!v13)
      {
        uint64_t v22 = nplog_obj(v13, v14, v15);
        id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          id v24 = WeakRetained[3];
          id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 vendor]);
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "proxy for %@ does not require any token",  buf,  0xCu);
        }

        ((void (*)(void *, uint64_t))v72)(v12, 1LL);
        goto LABEL_12;
      }

      if (*((_BYTE *)WeakRetained + 8))
      {
        uint64_t v16 = nplog_obj(v13, v14, v15);
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          id v18 = WeakRetained[3];
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 vendor]);
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "token fetch request for %@ is already pending",  buf,  0xCu);
        }
      }

      else if (WeakRetained[8])
      {
        uint64_t v26 = nplog_obj(v13, v14, v15);
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          id v27 = WeakRetained[3];
          id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 vendor]);
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v28;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "token fetch request for %@ has a pending timer",  buf,  0xCu);
        }
      }

      else
      {
        id v29 = [WeakRetained[7] status];
        if (v29 != (id)1)
        {
          uint64_t v37 = nplog_obj(v29, v30, v31);
          unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            id v39 = WeakRetained[3];
            id v40 = (void *)objc_claimAutoreleasedReturnValue([v39 vendor]);
            *(_DWORD *)__int128 buf = 138412290;
            *(void *)&uint8_t buf[4] = v40;
            _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_INFO,  "deferring token fetch for %@, path is not satisfied",  buf,  0xCu);
          }

          *((_BYTE *)WeakRetained + 9) = 1;
          id v41 = objc_loadWeakRetained(WeakRetained + 2);
          [v41 setUserEventAgentTokenFetchParameters];

          ((void (*)(void *, void))v72)(v12, 0LL);
          goto LABEL_12;
        }

        unint64_t v32 = 30LL;
        if (!*((_BYTE *)WeakRetained + 11)) {
          unint64_t v32 = 10LL;
        }
        if ((unint64_t)WeakRetained[4] <= v32)
        {
          *((_BYTE *)WeakRetained + _Block_object_dispose(va, 8) = 1;
          id v42 = sub_10000F7F4((uint64_t)WeakRetained);
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(v42);
          uint64_t v45 = nplog_obj(v65, v43, v44);
          id v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            id v47 = WeakRetained[3];
            uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v47 vendor]);
            *(_DWORD *)__int128 buf = 138412546;
            *(void *)&uint8_t buf[4] = v48;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v65;
            _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "Fetch tokens for %@ on %@",  buf,  0x16u);
          }

          objc_initWeak(&location, WeakRetained);
          uint64_t v49 = 60LL;
          if (!*((_BYTE *)WeakRetained + 11)) {
            uint64_t v49 = 30LL;
          }
          uint64_t v64 = v49;
          id v50 = WeakRetained[3];
          id v63 = (void *)objc_claimAutoreleasedReturnValue([v50 tokenKeyInfo]);

          id v51 = WeakRetained[3];
          uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v51 tokenChallenge]);

          id v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));
          id v52 = sub_10000F7F4((uint64_t)WeakRetained);
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(v52);
          uint64_t v53 = sub_10000F274((uint64_t)WeakRetained);
          v68 = (void *)objc_claimAutoreleasedReturnValue(v53);
          id v62 = WeakRetained[3];
          id v54 = (void *)objc_claimAutoreleasedReturnValue([v62 proxyURL]);
          id v55 = WeakRetained[3];
          __int16 v56 = (void *)objc_claimAutoreleasedReturnValue([v55 vendor]);
          id v57 = WeakRetained[4];
          id v58 = WeakRetained[9];
          *(void *)__int128 buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3221225472LL;
          *(void *)&uint8_t buf[16] = sub_10000FA98;
          uint64_t v78 = &unk_1000F9810;
          objc_copyWeak(v83, &location);
          uint64_t v59 = v64 - (void)v57;
          v79 = WeakRetained;
          id v60 = v63;
          id v80 = v60;
          id v66 = v65;
          id v81 = v66;
          id v82 = v12;
          [v70 fetchPrivacyTokensOnInterface:v69 tierType:v68 proxyURL:v54 tokenVendor:v56 tokenIssuancePublicKey:v60 tokenChallenge:v67 tokenCount :v59 accessToken:v8 retryAttempt:v58 completionHandler:buf];

          objc_destroyWeak(v83);
          objc_destroyWeak(&location);

          goto LABEL_12;
        }

        uint64_t v33 = nplog_obj(1LL, v30, v31);
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          id v34 = WeakRetained[3];
          BOOL v35 = (void *)objc_claimAutoreleasedReturnValue([v34 vendor]);
          id v36 = WeakRetained[4];
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v35;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "ignoring token fetch for %@, token count %lu",  buf,  0x16u);
        }
      }
    }

    else
    {
      uint64_t v61 = nplog_obj(v9, v10, v11);
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPProxyTokenInfo requestTokensWithAccessToken:completionHandler:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "%s called with null self.proxyInfo",  buf,  0xCu);
      }
    }

    ((void (*)(void *, void))v72)(v12, 0LL);
LABEL_12:

    goto LABEL_13;
  }

  uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v21 = *(void **)(v20 + 40);
  *(void *)(v20 + 40) = 0LL;

LABEL_13:
}

void sub_10000F208( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, id a28)
{
}

void sub_10000F238(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

__CFString *sub_10000F274(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained tierString]);

  if (v3)
  {
    id v4 = v3;
  }

  else if (*(_BYTE *)(a1 + 11))
  {
    id v4 = @"SUBSCRIBER";
  }

  else
  {
    id v4 = @"FREE";
  }

  return v4;
}

uint64_t sub_10000F2E8(uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 11))
    {
      else {
        return 5LL;
      }
    }

    else
    {
      return 5LL;
    }
  }

  return result;
}

void sub_10000F324(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = *(void **)(a1 + 32);
    if (v6) {
      id v6 = (void *)v6[3];
    }
    uint64_t v7 = v6;
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 vendor]);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ tokens added", (uint8_t *)&buf, 0xCu);
  }

  uint64_t v9 = *(void *)(a1 + 32);
  if (v9) {
    id WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained tokenAdded];

  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    unint64_t v12 = *(_BYTE *)(v11 + 11) ? 30LL : 10LL;
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v11 + 24) vendor]);
    unsigned int v14 = +[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]( &OBJC_CLASS___NSPCoreData,  "triggerProactiveTokenFetch:lowerTokenCountThreshold:",  v13,  v12 + (v12 >> 1));

    if (v14)
    {
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
      id v16 = *(id *)(v11 + 24);
      __int16 v17 = (void *)objc_claimAutoreleasedReturnValue([v16 vendor]);
      uint64_t v19 = *(void *)(v11 + 32);
      uint64_t v18 = *(void *)(v11 + 40);
      if (v18) {
        uint64_t v20 = [*(id *)(v18 + 24) tokenCount];
      }
      else {
        uint64_t v20 = 0LL;
      }

      +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v15,  4LL,  v17,  v20 + v19);
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v25 = 0x3032000000LL;
      uint64_t v26 = sub_10000CED4;
      id v27 = sub_10000CEE4;
      id v28 = (id)os_transaction_create("com.apple.networkserviceproxy.proactiveTokenFetch");
      uint64_t v21 = NPGetInternalQueue(v28);
      uint64_t v22 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v21);
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472LL;
      v23[2] = sub_100010960;
      v23[3] = &unk_1000F9428;
      void v23[4] = v11;
      v23[5] = &buf;
      dispatch_async(v22, v23);

      _Block_object_dispose(&buf, 8);
    }
  }

void sub_10000F588( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000F5A8(uint64_t a1)
{
  if (a1 && sub_10000C67C(a1))
  {
    unint64_t v2 = 30LL;
    if (!*(_BYTE *)(a1 + 11)) {
      unint64_t v2 = 10LL;
    }
    if (*(void *)(a1 + 32) <= v2)
    {
      v10[0] = 0LL;
      v10[1] = v10;
      v10[2] = 0x3032000000LL;
      v10[3] = sub_10000CED4;
      void v10[4] = sub_10000CEE4;
      id v11 = (id)os_transaction_create("com.apple.networkserviceproxy.checkCachedTokenCount");
      uint64_t v3 = NPGetInternalQueue(v11);
      uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v3);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472LL;
      v9[2] = sub_10000F744;
      v9[3] = &unk_1000F9428;
      v9[4] = a1;
      v9[5] = v10;
      dispatch_async(v4, v9);

      ++*(void *)(a1 + 128);
      uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSPProxyAgentStats);
      id v6 = sub_10000F274(a1);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      -[NSPProxyAgentStats setTierType:](v5, "setTierType:", v7);

      id v8 = *(id *)(a1 + 24);
      LODWORD(v7) = [v8 proxyHop];

      if ((_DWORD)v7 == 1) {
        -[NSPProxyAgentStats setIngressProxyLowWaterMarkHitCount:]( v5,  "setIngressProxyLowWaterMarkHitCount:",  (char *)-[NSPProxyAgentStats ingressProxyLowWaterMarkHitCount](v5, "ingressProxyLowWaterMarkHitCount") + 1);
      }
      else {
        -[NSPProxyAgentStats setEgressProxyLowWaterMarkHitCount:]( v5,  "setEgressProxyLowWaterMarkHitCount:",  (char *)-[NSPProxyAgentStats egressProxyLowWaterMarkHitCount](v5, "egressProxyLowWaterMarkHitCount") + 1);
      }
      -[NSPProxyAnalytics sendAnalytics](v5, "sendAnalytics");

      _Block_object_dispose(v10, 8);
    }
  }

void sub_10000F728( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000F744(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10000F7A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained tokensEmpty];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

id sub_10000F7F4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 10))
  {
    uint64_t v1 = 0LL;
  }

  else
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) interface]);
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([v2 interfaceName]);
  }

  return v1;
}

void sub_10000F840(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && *(_BYTE *)(a1 + 9))
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = *(id *)(a1 + 24);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 vendor]);
      int v11 = 138412290;
      unint64_t v12 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Retry fetching tokens for %@ on network or key change",  (uint8_t *)&v11,  0xCu);
    }

    uint64_t v8 = *(void *)(a1 + 72);
    sub_10000C6C4(a1, v9, v10);
    *(void *)(a1 + 72) = v8;
    sub_10000CF58(a1, 0LL);
  }

void sub_10000F930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Token fetch retry timer fired", v9, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 8));
    uint64_t v8 = (void *)v7[8];
    v7[8] = 0LL;

    sub_10000CF58(v7, 0LL);
  }
}

double sub_10000F9CC(void *a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([a1 allHeaderFields]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"Retry-After"]);

  if (v2)
  {
    uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSNumberFormatter);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(-[NSNumberFormatter numberFromString:](v3, "numberFromString:", v2));
    [v4 doubleValue];
    double v6 = v5;
  }

  else
  {
    double v6 = 0.0;
  }

  return v6;
}

void sub_10000FA5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v3 = WeakRetained;
  [WeakRetained tokenFetched];
}

void sub_10000FA98(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6, int a7)
{
  id v13 = a3;
  v122 = a4;
  id v121 = a5;
  id v120 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v15 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[8] = 0;
    if (a2)
    {
      if ([v13 statusCode] == (id)200)
      {
        id v16 = [v121 count];
        if (v16)
        {
          uint64_t v19 = nplog_obj(v16, v17, v18);
          uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            id v21 = *(id *)(v15 + 24);
            uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 vendor]);
            *(_DWORD *)__int128 buf = 138412290;
            *(void *)&uint8_t buf[4] = v22;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Token fetch successful for %@",  buf,  0xCu);
          }

          ++*(void *)(v15 + 88);
          id v23 = v121;
          id v24 = (NSDate *)v120;
          v119 = v23;
          if ([v23 count])
          {
            if (!v24 || (-[NSDate timeIntervalSinceNow](v24, "timeIntervalSinceNow"), v27 < 0.0))
            {
              id v28 = -[NSDate initWithTimeIntervalSinceNow:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSinceNow:",  86400.0);

              id v24 = v28;
            }

            id v29 = sub_10003EA30((id *)objc_alloc(&OBJC_CLASS___NSPToken), v24);
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v119));
            sub_100011668((uint64_t)v29, v30);

            id v31 = sub_10000D2EC(v15);
            unint64_t v32 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v31);
            if (!v32) {
              unint64_t v32 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            }
            -[NSMutableArray addObject:](v32, "addObject:", v29);
            *(void *)(v15 + 32) += [v119 count];
            sub_10000E4E4(v15, (uint64_t)v32);
            uint64_t v36 = nplog_obj(v33, v34, v35);
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              id v38 = [v119 count];
              id v39 = *(id *)(v15 + 24);
              id v40 = (void *)objc_claimAutoreleasedReturnValue([v39 vendor]);
              *(_DWORD *)__int128 buf = 134218498;
              *(void *)&uint8_t buf[4] = v38;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v40;
              *(_WORD *)&buf[22] = 2112;
              v137 = (uint64_t (*)(uint64_t, uint64_t))v24;
              _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Cache %lu tokens for proxy %@, expiration %@",  buf,  0x20u);
            }
          }

          else
          {
            uint64_t v118 = nplog_obj(0LL, v25, v26);
            id v29 = (id *)objc_claimAutoreleasedReturnValue(v118);
            if (os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              *(void *)&uint8_t buf[4] = "-[NSPProxyTokenInfo cacheTokens:expirationTime:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v29,  OS_LOG_TYPE_FAULT,  "%s called with null (tokens.count > 0)",  buf,  0xCu);
            }
          }

          sub_10000C6C4(v15, v41, v42);
          sub_10000D5C4(v15);
          sub_10000F5A8(v15);
          uint64_t v44 = NPGetInternalQueue(v43);
          uint64_t v45 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v44);
          *(void *)__int128 buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3221225472LL;
          *(void *)&uint8_t buf[16] = sub_10000FA5C;
          v137 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9450;
          v138 = (void (*)(uint64_t))v15;
          dispatch_async(v45, buf);

          id v46 = (id)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          id v47 = *(void **)(a1 + 32);
          if (v47) {
            id v47 = (void *)v47[3];
          }
          uint64_t v48 = v47;
          uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v48 vendor]);
          uint64_t v50 = sub_10000E688(*(void *)(a1 + 32));

          +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v46,  2LL,  v49,  v50);
          goto LABEL_65;
        }
      }
    }

    if ([v13 statusCode] == (id)429)
    {
      uint64_t v53 = nplog_obj(429LL, v51, v52);
      id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        id v114 = *(id *)(v15 + 24);
        v115 = (void *)objc_claimAutoreleasedReturnValue([v114 vendor]);
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v115;
        _os_log_error_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "Token fetch failed for %@ with too many requests",  buf,  0xCu);
      }

      ++*(void *)(v15 + 112);
      id v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
      __int16 v56 = *(void **)(a1 + 32);
      if (v56) {
        __int16 v56 = (void *)v56[3];
      }
      id v57 = v56;
      id v58 = (void *)objc_claimAutoreleasedReturnValue([v57 vendor]);
      uint64_t v59 = sub_10000E688(*(void *)(a1 + 32));

      +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v55,  3LL,  v58,  v59);
      double v61 = sub_10000F9CC(v13);
      if (v61 <= 0.0) {
        double v62 = 86400.0;
      }
      else {
        double v62 = v61;
      }
      *(_BYTE *)(v15 + 9) = 0;
      sub_10000CBD4(v15, (unint64_t)v62, v60);
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000LL;
      v137 = sub_10000CED4;
      v138 = sub_10000CEE4;
      id v139 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenRateLimited");
      uint64_t v63 = NPGetInternalQueue(v139);
      uint64_t v64 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v63);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100010724;
      block[3] = &unk_1000F97E8;
      double v135 = v62;
      id v133 = (id)v15;
      v134 = buf;
      dispatch_async(v64, block);

      _Block_object_dispose(buf, 8);
      goto LABEL_64;
    }

    id v65 = *(id *)(v15 + 24);
    id v66 = (void *)objc_claimAutoreleasedReturnValue([v65 tokenKeyInfo]);
    uint64_t v67 = *(void **)(a1 + 40);
    unint64_t v68 = v66;
    unint64_t v69 = v67;
    id v70 = (void *)v69;
    if (v68 | v69 && (!v68 || !v69 || ![(id)v68 isEqual:v69]))
    {
      id v71 = (id)v68;
LABEL_48:

      uint64_t v103 = nplog_obj(v100, v101, v102);
      v104 = (os_log_s *)objc_claimAutoreleasedReturnValue(v103);
      if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEFAULT,  "Token fetch failed, retrying immediately",  buf,  2u);
      }

      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000LL;
      v137 = sub_10000CED4;
      v138 = sub_10000CEE4;
      id v139 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenRefreshPoolKeyChanged");
      uint64_t v105 = NPGetInternalQueue(v139);
      v106 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v105);
      v129[0] = _NSConcreteStackBlock;
      v129[1] = 3221225472LL;
      v129[2] = sub_100010784;
      v129[3] = &unk_1000F9428;
      id v130 = (id)v15;
      v131 = buf;
      dispatch_async(v106, v129);

      _Block_object_dispose(buf, 8);
      goto LABEL_64;
    }

    id v71 = *(id *)(v15 + 56);
    if ([v71 status] == (id)1)
    {
      id v72 = sub_10000F7F4(v15);
      id v70 = (void *)objc_claimAutoreleasedReturnValue(v72);
      if (v70)
      {
        id v73 = sub_10000F7F4(v15);
        id v74 = (void *)objc_claimAutoreleasedReturnValue(v73);
        uint64_t v75 = *(void **)(a1 + 48);
        unint64_t v76 = v74;
        unint64_t v77 = v75;
        uint64_t v78 = (void *)v77;
        if (v76 | v77 && (!v76 || !v77 || ![(id)v76 isEqual:v77]))
        {

          goto LABEL_48;
        }
      }
    }

    uint64_t v82 = nplog_obj(v79, v80, v81);
    id v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      id v116 = *(id *)(v15 + 24);
      v117 = (void *)objc_claimAutoreleasedReturnValue([v116 vendor]);
      *(_DWORD *)__int128 buf = 138412802;
      *(void *)&uint8_t buf[4] = v117;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = [v13 statusCode];
      *(_WORD *)&buf[22] = 2112;
      v137 = v122;
      _os_log_error_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_ERROR,  "Token fetch failed for %@ with %lu, error %@",  buf,  0x20u);
    }

    ++*(void *)(v15 + 112);
    __int128 v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    __int128 v85 = *(void **)(a1 + 32);
    if (v85) {
      __int128 v85 = (void *)v85[3];
    }
    __int128 v86 = v85;
    __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v86 vendor]);
    uint64_t v88 = sub_10000E688(*(void *)(a1 + 32));

    +[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]( &OBJC_CLASS___NSPCoreData,  "saveTokenEvent:eventType:vendor:tokenCount:",  v84,  3LL,  v87,  v88);
    if ([v13 statusCode] == (id)404 || a7)
    {
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000LL;
      v137 = sub_10000CED4;
      v138 = sub_10000CEE4;
      id v139 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenInfoInvalid");
      uint64_t v107 = NPGetInternalQueue(v139);
      v108 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v107);
      v126[0] = _NSConcreteStackBlock;
      v126[1] = 3221225472LL;
      v126[2] = sub_1000107F0;
      v126[3] = &unk_1000F9428;
      id v127 = (id)v15;
      v128 = buf;
      dispatch_async(v108, v126);

      _Block_object_dispose(buf, 8);
    }

    else
    {
      v89 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
      v90 = (void *)objc_claimAutoreleasedReturnValue([v89 objectForKeyedSubscript:@"X-Apple-Client-Action"]);

      id v91 = [v90 isEqualToString:@"Switch-Proxy"];
      if ((_DWORD)v91)
      {
        uint64_t v94 = nplog_obj(v91, v92, v93);
        v95 = (os_log_s *)objc_claimAutoreleasedReturnValue(v94);
        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
        {
          id v96 = *(id *)(v15 + 24);
          v97 = (void *)objc_claimAutoreleasedReturnValue([v96 vendor]);
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v97;
          _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "Received switch proxy from server for %@",  buf,  0xCu);
        }

        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000LL;
        v137 = sub_10000CED4;
        v138 = sub_10000CEE4;
        id v139 = (id)os_transaction_create("com.apple.networkserviceproxy.switchProxy");
        uint64_t v98 = NPGetInternalQueue(v139);
        v99 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v98);
        v123[0] = _NSConcreteStackBlock;
        v123[1] = 3221225472LL;
        v123[2] = sub_10001084C;
        v123[3] = &unk_1000F9428;
        id v124 = (id)v15;
        v125 = buf;
        dispatch_async(v99, v123);

        _Block_object_dispose(buf, 8);
      }
    }

    unint64_t v109 = (unint64_t)sub_10000F9CC(v13);
    *(_BYTE *)(v15 + 9) = v109 == 0;
    sub_10000CBD4(v15, v109, v110);
    ++*(void *)(v15 + 72);
    if (v122)
    {
      v111 = (void *)objc_claimAutoreleasedReturnValue([v122 domain]);
      if ([v111 isEqualToString:NSURLErrorDomain])
      {
        if ([v122 code] == (id)-1009)
        {

LABEL_62:
          --*(void *)(v15 + 72);
          goto LABEL_63;
        }

        BOOL v112 = [v122 code] == (id)-1005;

        if (v112) {
          goto LABEL_62;
        }
      }

      else
      {
      }
    }

LABEL_63:
    id v113 = objc_loadWeakRetained((id *)(v15 + 16));
    [v113 updateUserEventAgentData];

LABEL_64:
    id v46 = objc_loadWeakRetained((id *)(v15 + 16));
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v15 + 24) proxyURL]);
    objc_msgSend(v46, "reportTokenFetchFailure:statusCode:", v49, objc_msgSend(v13, "statusCode"));
LABEL_65:
  }

  (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
}

void sub_1000106F8(_Unwind_Exception *a1)
{
}

void sub_100010724(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained tokenRateLimited:v4 untilDate:*(double *)(a1 + 48)];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

uint64_t sub_100010784(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_1000107DC;
  v3[3] = &unk_1000F9748;
  uint64_t v1 = *(void *)(a1 + 32);
  v3[4] = *(void *)(a1 + 40);
  return sub_10000CF58(v1, v3);
}

void sub_1000107DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000107F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained tokenInfoInvalid:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10001084C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained switchProxy:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100010960(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472LL;
  v1[2] = sub_1000109B8;
  v1[3] = &unk_1000F9838;
  sub_10000CF58(*(void *)(a1 + 32), v1);
}

void sub_1000109B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  double v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    uint64_t v10 = (void *)v9;
    int v11 = @"failed";
    if (v3) {
      int v11 = @"succeeded";
    }
    int v14 = 138412546;
    uint64_t v15 = v9;
    __int16 v16 = 2112;
    uint64_t v17 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "proactive Token fetch for vendor %@ %@",  (uint8_t *)&v14,  0x16u);
  }

  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = 0LL;
}

void sub_100011668(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 8), a2);
  }
}

LABEL_24:
        (*((void (**)(id, void))v4 + 2))(v4, 0LL);
        id v39 = 1;
LABEL_25:

        goto LABEL_26;
      }

      uint64_t v45 = nplog_obj(v15, v16, v17);
      uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v44 = "Failed to match key configuration in transparency blob for oblivious config, blocking";
    }

    else
    {
      uint64_t v42 = nplog_obj(v9, v10, v11);
      uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v44 = "Failed to parse transparency blob for oblivious config, blocking";
    }

      uint64_t v7 = (char *)v7 + 1;
    }

    while (v6 != v7);
    id v24 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v30,  v34,  16LL);
    double v6 = v24;
  }

  while (v24);
LABEL_31:

  return v26;
}

        uint64_t v22 = (char *)v22 + 1;
      }

      while (v20 != v22);
      unint64_t v32 = [v18 countByEnumeratingWithState:&v45 objects:v50 count:16];
      uint64_t v20 = v32;
      if (!v32)
      {

        a7 = v41;
        uint64_t v12 = v40;
        if ((v42 & 1) != 0) {
          goto LABEL_41;
        }
        goto LABEL_31;
      }
    }
  }

LABEL_31:
  if (!objc_msgSend(v18, "count", v40))
  {
    uint64_t v33 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));

    uint64_t v18 = (id)v33;
  }

  uint64_t v34 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
  -[NSPPrivacyProxyAuxiliaryAuthInfo setAuthType:](v34, "setAuthType:", a3);
  -[NSPPrivacyProxyAuxiliaryAuthInfo setLabel:](v34, "setLabel:", v13);
  -[NSPPrivacyProxyAuxiliaryAuthInfo addContentList:](v34, "addContentList:", v43);
  if (v14)
  {
    uint64_t v35 = objc_alloc(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
    uint64_t v36 = v14;
    if (v35
      && (v49.receiver = v35,
          v49.super_class = (Class)&OBJC_CLASS___NSPAuxiliaryAuthInfo,
          (uint64_t v37 = (id *)objc_msgSendSuper2(&v49, "init")) != 0))
    {
      id v38 = v37;
      objc_storeStrong(v37 + 2, a6);

      objc_setProperty_atomic(v38, v39, v34, 8LL);
    }

    else
    {

      id v38 = 0LL;
    }

    [v18 addObject:v38];
  }

  else
  {
    [v18 addObject:v34];
  }

LABEL_41:
  sub_10004091C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v18, v12, a7);
  sub_100040BF0((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, a7);
}

    sub_1000883F4((uint64_t)v679);
LABEL_128:
    v232 = nplog_large_obj();
    v233 = (os_log_s *)objc_claimAutoreleasedReturnValue(v232);
    if (os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
    {
      v244 = v679;
      if (v679) {
        v244 = v679->_configuration;
      }
      v245 = v244;
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v245;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v233,  OS_LOG_TYPE_DEBUG,  "Configuration state: %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679) {
      v234 = v679->_configuration;
    }
    else {
      v234 = 0LL;
    }
    v235 = v234;
    v236 = -[NSPConfiguration saveToPreferences](v235, "saveToPreferences");

    if ((v236 & 1) != 0)
    {
      if (v679)
      {
        ++v679->_generation;
        +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-configuration-changed");
        *(void *)&__int128 buf = 0LL;
        *((void *)&buf + 1) = &buf;
        v832 = 0x3032000000LL;
        v833 = sub_100086D74;
        v834 = sub_100086D84;
        v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.configurationUpdated");
        v240 = NPGetInternalQueue(v835);
        v241 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v240);
        block = _NSConcreteStackBlock;
        p_block = 3221225472LL;
        v809 = (uint64_t)sub_100088C70;
        v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
        v811 = (void (*)(uint64_t))v679;
        p___int128 buf = &buf;
        dispatch_async(v241, &block);

        _Block_object_dispose(&buf, 8);
      }

      else
      {
        +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-configuration-changed",  0LL);
      }
    }

    else
    {
      v242 = nplog_obj(v237, v238, v239);
      v243 = (os_log_s *)objc_claimAutoreleasedReturnValue(v242);
      if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v243,  OS_LOG_TYPE_ERROR,  "Failed to write configuration to file",  (uint8_t *)&buf,  2u);
      }
    }

    goto LABEL_137;
  }

  uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration cloudSubscriptionCheckEnabled](v678, "cloudSubscriptionCheckEnabled"));
  unint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v677 cloudSubscriptionCheckEnabled]);
  unint64_t v77 = v75;
  uint64_t v78 = v76;
  uint64_t v79 = (void *)v78;
  if (!(v77 | v78) || v77 && v78 && [(id)v77 isEqual:v78])
  {
  }

  else
  {

    id v83 = nplog_obj(v80, v81, v82);
    __int128 v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v85 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration cloudSubscriptionCheckEnabled](v678, "cloudSubscriptionCheckEnabled"));
      __int128 v86 = [v85 BOOLValue];
      __int128 v87 = "no";
      if (v86) {
        __int128 v87 = "yes";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v87;
      _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "cloud subscription check changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue( -[NSPConfiguration cloudSubscriptionCheckEnabled]( v679->_configuration,  "cloudSubscriptionCheckEnabled"));
      v89 = [v88 BOOLValue];

      if ((v89 & 1) == 0)
      {
        -[NSPConfiguration setProxyAccountType:](v679->_configuration, "setProxyAccountType:", 0LL);
        -[NSPConfiguration setProxyAccountUnlimited:](v679->_configuration, "setProxyAccountUnlimited:", 0LL);
      }

      v90 = (void *)objc_claimAutoreleasedReturnValue( -[NSPConfiguration cloudSubscriptionCheckEnabled]( v679->_configuration,  "cloudSubscriptionCheckEnabled"));
      id v91 = [v90 BOOLValue];

      block = 0LL;
      p_block = (uint64_t)&block;
      v809 = 0x3032000000LL;
      v810 = sub_100086D74;
      v811 = sub_100086D84;
      p___int128 buf = (__int128 *)os_transaction_create("com.apple.networkserviceproxy.cloudSubscriptionCheckChanged");
      uint64_t v92 = NPGetInternalQueue(p_buf);
      uint64_t v93 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v92);
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      v832 = (uint64_t)sub_100088B58;
      v833 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9B90;
      v836 = v91;
      v834 = (void (*)(uint64_t))v679;
      v835 = &block;
      dispatch_async(v93, &buf);

      _Block_object_dispose(&block, 8);
    }

    id v21 = 1;
  }

  uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration trialConfigVersion](v678, "trialConfigVersion"));
  v95 = (void *)objc_claimAutoreleasedReturnValue([v677 trialConfigVersion]);
  id v96 = v94;
  v97 = v95;
  uint64_t v98 = (void *)v97;
  if (!(v96 | v97) || v96 && v97 && [(id)v96 isEqual:v97])
  {
  }

  else
  {

    uint64_t v102 = nplog_obj(v99, v100, v101);
    uint64_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
    if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
    {
      v104 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration trialConfigVersion](v678, "trialConfigVersion"));
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v104;
      _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEFAULT,  "Trial configuration version changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.trialConfigurationVersionChanged");
      block = _NSConcreteStackBlock;
      p_block = 3221225472LL;
      v809 = (uint64_t)sub_1000897AC;
      v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000FA170;
      v811 = (void (*)(uint64_t))&buf;
      -[NSPConfigurationManager refreshConfigurationWithReason:completionHandler:]( v679,  "refreshConfigurationWithReason:completionHandler:",  2LL,  &block);
      _Block_object_dispose(&buf, 8);
    }

    id v21 = 1;
  }

  uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration resurrectionDate](v678, "resurrectionDate"));
  v106 = (void *)objc_claimAutoreleasedReturnValue([v677 resurrectionDate]);
  uint64_t v107 = v105;
  v108 = v106;
  unint64_t v109 = (void *)v108;
  if (v107 | v108 && (!v107 || !v108 || ![(id)v107 isEqual:v108]))
  {

    id v121 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration resurrectionDate](v678, "resurrectionDate"));
    v122 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v121,  1LL,  2LL));

    v126 = nplog_obj(v123, v124, v125);
    id v127 = (os_log_s *)objc_claimAutoreleasedReturnValue(v126);
    if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v122;
      _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_DEFAULT,  "resurrection date changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.resurrectionDateUpdated");
      v128 = v679->_configuration;
      v129 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration resurrectionDate](v128, "resurrectionDate"));
      id v130 = v129 == 0LL;

      v131 = v679->_configuration;
      v132 = v131;
      if (v130)
      {
        -[NSPConfiguration setConfigServerEnabled:](v131, "setConfigServerEnabled:", &__kCFBooleanTrue);

        sub_100086A34((uint64_t)v679);
        sub_100087CDC((id *)&v679->super.isa, v144, v145);
        v147 = NPGetInternalQueue(v146);
        id v133 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v147);
        block = _NSConcreteStackBlock;
        p_block = 3221225472LL;
        v809 = (uint64_t)sub_100088C14;
        v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
        v811 = (void (*)(uint64_t))v679;
        p___int128 buf = &buf;
        dispatch_async(v133, &block);
      }

      else
      {
        id v133 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration resurrectionDate](v131, "resurrectionDate"));

        sub_100087984((uint64_t)v679, v134, v135);
        sub_1000876FC((uint64_t)v679, v136, v137);
        sub_100088028((uint64_t)v679, v138, v139);
        v140 = v679->_configuration;
        -[NSPConfiguration setResurrectionDate:](v140, "setResurrectionDate:", v133);

        sub_100087170((id *)&v679->super.isa);
        v142 = NPGetInternalQueue(v141);
        v143 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v142);
        block = _NSConcreteStackBlock;
        p_block = 3221225472LL;
        v809 = (uint64_t)sub_100088BB8;
        v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
        v811 = (void (*)(uint64_t))v679;
        p___int128 buf = &buf;
        dispatch_async(v143, &block);
      }

      _Block_object_dispose(&buf, 8);
    }

    goto LABEL_128;
  }

  uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration userTier](v678, "userTier"));
  v111 = [v110 unsignedIntValue];
  BOOL v112 = (void *)objc_claimAutoreleasedReturnValue([v677 userTier]);
  LOBYTE(v111) = v111 == [v112 unsignedIntValue];

  if ((v111 & 1) == 0)
  {
    id v116 = nplog_obj(v113, v114, v115);
    v117 = (os_log_s *)objc_claimAutoreleasedReturnValue(v116);
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration userTier](v678, "userTier"));
      v119 = [v118 unsignedIntValue];
      if (v119 >= 3) {
        id v120 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v119));
      }
      else {
        id v120 = *(&off_1000FA9C0 + (int)v119);
      }
      v148 = v120;
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v148;
      _os_log_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_DEFAULT,  "user tier changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.userTierChanged");
      v149 = NPGetInternalQueue(v835);
      v150 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v149);
      block = _NSConcreteStackBlock;
      p_block = 3221225472LL;
      v809 = (uint64_t)sub_100088FF4;
      v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
      v811 = (void (*)(uint64_t))v679;
      p___int128 buf = &buf;
      dispatch_async(v150, &block);

      _Block_object_dispose(&buf, 8);
    }

    id v21 = 1;
  }

  v151 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration userPreferredTier](v678, "userPreferredTier"));
  v152 = [v151 unsignedIntValue];
  v153 = (void *)objc_claimAutoreleasedReturnValue([v677 userPreferredTier]);
  LOBYTE(v152) = v152 == [v153 unsignedIntValue];

  if ((v152 & 1) == 0)
  {
    v157 = nplog_obj(v154, v155, v156);
    v158 = (os_log_s *)objc_claimAutoreleasedReturnValue(v157);
    if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
    {
      v159 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration userTier](v678, "userTier"));
      v160 = [v159 unsignedIntValue];
      if (v160 >= 3) {
        v161 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v160));
      }
      else {
        v161 = *(&off_1000FA9C0 + (int)v160);
      }
      v162 = v161;
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v162;
      _os_log_impl( (void *)&_mh_execute_header,  v158,  OS_LOG_TYPE_DEFAULT,  "user preferred tier changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.userPreferredTierChanged");
      v163 = NPGetInternalQueue(v835);
      v164 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v163);
      block = _NSConcreteStackBlock;
      p_block = 3221225472LL;
      v809 = (uint64_t)sub_100089050;
      v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
      v811 = (void (*)(uint64_t))v679;
      p___int128 buf = &buf;
      dispatch_async(v164, &block);

      _Block_object_dispose(&buf, 8);
    }

    id v21 = 1;
  }

  v165 = -[NSPConfigurationManager effectiveUserTier](v679, "effectiveUserTier");
  if ((id)v6 != v165)
  {
    v168 = nplog_obj(v165, v166, v167);
    v169 = (os_log_s *)objc_claimAutoreleasedReturnValue(v168);
    if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
    {
      v170 = -[NSPConfigurationManager effectiveUserTier](v679, "effectiveUserTier");
      if (v170 >= 3) {
        v171 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v170));
      }
      else {
        v171 = *(&off_1000FA9C0 + (int)v170);
      }
      v172 = v171;
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v172;
      _os_log_impl( (void *)&_mh_execute_header,  v169,  OS_LOG_TYPE_DEFAULT,  "effective user tier changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.effectiveUserTierChanged");
      v173 = NPGetInternalQueue(v835);
      v174 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v173);
      block = _NSConcreteStackBlock;
      p_block = 3221225472LL;
      v809 = (uint64_t)sub_1000890F8;
      v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
      v811 = (void (*)(uint64_t))v679;
      p___int128 buf = &buf;
      dispatch_async(v174, &block);

      _Block_object_dispose(&buf, 8);
    }

    id v21 = 1;
  }

  v175 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration willResetSubscriberTierTomorrow](v678, "willResetSubscriberTierTomorrow"));
  v176 = (void *)objc_claimAutoreleasedReturnValue([v677 willResetSubscriberTierTomorrow]);
  if (v175 == v176)
  {
    v178 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration resetTomorrowDate](v678, "resetTomorrowDate"));
    v179 = (void *)objc_claimAutoreleasedReturnValue([v677 resetTomorrowDate]);
    v177 = v178 != v179;
  }

  else
  {
    v177 = 1;
  }

  v180 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v181 = [v180 enabled];
  v182 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v183 = [v182 enabled];

  if (v181 != v183)
  {
    v187 = nplog_obj(v184, v185, v186);
    v188 = (os_log_s *)objc_claimAutoreleasedReturnValue(v187);
    if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
    {
      v189 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
      v190 = [v189 enabled];
      v191 = "disabled";
      if (v190) {
        v191 = "enabled";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v191;
      _os_log_impl( (void *)&_mh_execute_header,  v188,  OS_LOG_TYPE_DEFAULT,  "proxy token fetch state changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    if (v679)
    {
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      v832 = 0x3032000000LL;
      v833 = sub_100086D74;
      v834 = sub_100086D84;
      v835 = (void ***)os_transaction_create("com.apple.networkserviceproxy.proxyTokenFetchStateUpdated");
      v192 = v679->_configuration;
      v193 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v192, "proxyConfiguration"));
      v194 = [v193 enabled];

      v196 = NPGetInternalQueue(v195);
      v197 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v196);
      v198 = v197;
      block = _NSConcreteStackBlock;
      if (v194) {
        v199 = sub_100088E04;
      }
      else {
        v199 = sub_100088E60;
      }
      p_block = 3221225472LL;
      v809 = (uint64_t)v199;
      v810 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F9428;
      v811 = (void (*)(uint64_t))v679;
      p___int128 buf = &buf;
      dispatch_async(v197, &block);

      _Block_object_dispose(&buf, 8);
    }

    goto LABEL_128;
  }

  v200 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v201 = [v200 enabled];

  v21 |= v177;
  if (!v201)
  {
LABEL_127:
    if (!v21) {
      goto LABEL_137;
    }
    goto LABEL_128;
  }

  v663 = v21;
  v202 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyAccountType](v678, "proxyAccountType"));
  v203 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyAccountType]);
  v204 = sub_10008EE68(v202, v203);

  if (v204)
  {
    v208 = nplog_obj(v205, v206, v207);
    v209 = (os_log_s *)objc_claimAutoreleasedReturnValue(v208);
    if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
    {
      v210 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyAccountType](v678, "proxyAccountType"));
      v211 = (id)objc_claimAutoreleasedReturnValue( +[NSPConfiguration proxyAccountTypeToString:]( &OBJC_CLASS___NSPConfiguration,  "proxyAccountTypeToString:",  v210));
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v211;
      _os_log_impl( (void *)&_mh_execute_header,  v209,  OS_LOG_TYPE_DEFAULT,  "proxy account type changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    v663 = 1;
  }

  v212 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyAccountUnlimited](v678, "proxyAccountUnlimited"));
  v213 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyAccountUnlimited]);
  v214 = sub_10008EE68(v212, v213);

  if (v214)
  {
    v218 = nplog_obj(v215, v216, v217);
    v219 = (os_log_s *)objc_claimAutoreleasedReturnValue(v218);
    if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
    {
      v220 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyAccountUnlimited](v678, "proxyAccountUnlimited"));
      v221 = [v220 BOOLValue];
      v222 = "false";
      if (v221) {
        v222 = "true";
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v222;
      _os_log_impl( (void *)&_mh_execute_header,  v219,  OS_LOG_TYPE_DEFAULT,  "proxy account unlimited changed to %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    v663 = 1;
  }

  v223 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v224 = (void *)objc_claimAutoreleasedReturnValue([v223 authInfo]);
  v225 = (void *)objc_claimAutoreleasedReturnValue([v224 authURL]);
  v226 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v227 = (void *)objc_claimAutoreleasedReturnValue([v226 authInfo]);
  v228 = (void *)objc_claimAutoreleasedReturnValue([v227 authURL]);
  if ((sub_10008EE68(v225, v228) & 1) != 0)
  {
  }

  else
  {
    obj = (id)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
    v716 = (id)objc_claimAutoreleasedReturnValue([obj authInfo]);
    v697 = (void *)objc_claimAutoreleasedReturnValue([v716 accessTokenURL]);
    v708 = (id)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
    v702 = (id)objc_claimAutoreleasedReturnValue([v708 authInfo]);
    v692 = (void *)objc_claimAutoreleasedReturnValue([v702 accessTokenURL]);
    if ((sub_10008EE68(v697, v692) & 1) != 0)
    {
      v246 = 1;
    }

    else
    {
      v687 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
      v680 = (void *)objc_claimAutoreleasedReturnValue([v687 authInfo]);
      v682 = (id)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
      v247 = (void *)objc_claimAutoreleasedReturnValue([v682 authInfo]);
      if (sub_10008A5B0((uint64_t)v679, v680, v247))
      {
        v675 = (id)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
        v672 = (void *)objc_claimAutoreleasedReturnValue([v675 authInfo]);
        v668 = (void *)objc_claimAutoreleasedReturnValue([v672 accessTokenKnownOrigins]);
        v670 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
        v666 = (void *)objc_claimAutoreleasedReturnValue([v670 authInfo]);
        v248 = (void *)objc_claimAutoreleasedReturnValue([v666 accessTokenKnownOrigins]);
        if ((sub_10008EE68(v668, v248) & 1) != 0)
        {
          v246 = 1;
        }

        else
        {
          v661 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
          v664 = (void *)objc_claimAutoreleasedReturnValue([v661 authInfo]);
          v659 = (void *)objc_claimAutoreleasedReturnValue([v664 accessTokenBlockedIssuers]);
          v657 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
          v653 = (void *)objc_claimAutoreleasedReturnValue([v657 authInfo]);
          v655 = (void *)objc_claimAutoreleasedReturnValue([v653 accessTokenBlockedIssuers]);
          if ((sub_10008EE68(v659, v655) & 1) != 0)
          {
            v246 = 1;
          }

          else
          {
            v651 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
            v649 = (void *)objc_claimAutoreleasedReturnValue([v651 authInfo]);
            v249 = [v649 authType];
            v647 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
            v645 = (id)objc_claimAutoreleasedReturnValue([v647 authInfo]);
            if (v249 == [v645 authType])
            {
              v644 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
              v643 = (void *)objc_claimAutoreleasedReturnValue([v644 authInfo]);
              v642 = (void *)objc_claimAutoreleasedReturnValue([v643 nonDefaultAttesters]);
              v641 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
              v640 = (void *)objc_claimAutoreleasedReturnValue([v641 authInfo]);
              v250 = (void *)objc_claimAutoreleasedReturnValue([v640 nonDefaultAttesters]);
              v246 = sub_10008EE68(v642, v250);
            }

            else
            {
              v246 = 1;
            }
          }
        }
      }

      else
      {
        v246 = 1;
      }
    }

    if ((v246 & 1) == 0) {
      goto LABEL_162;
    }
  }

  v251 = nplog_obj(v229, v230, v231);
  v252 = (os_log_s *)objc_claimAutoreleasedReturnValue(v251);
  if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT))
  {
    v253 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
    v254 = (void *)objc_claimAutoreleasedReturnValue([v253 authInfo]);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v254;
    _os_log_impl( (void *)&_mh_execute_header,  v252,  OS_LOG_TYPE_DEFAULT,  "authentication info updated to %@",  (uint8_t *)&buf,  0xCu);
  }

  sub_100088EBC((uint64_t)v679);
  v663 = 1;
LABEL_162:
  v255 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v667 = (void *)objc_claimAutoreleasedReturnValue([v255 proxies]);

  v256 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v665 = (void *)objc_claimAutoreleasedReturnValue([v256 proxies]);

  v257 = [v667 count];
  v258 = [v665 count];
  if (v257 != v258)
  {
    v345 = nplog_obj(v258, v259, v260);
    v346 = (os_log_s *)objc_claimAutoreleasedReturnValue(v345);
    if (os_log_type_enabled(v346, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v667;
      _os_log_impl( (void *)&_mh_execute_header,  v346,  OS_LOG_TYPE_DEFAULT,  "proxy info updated to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089154((uint64_t)v679);
    goto LABEL_288;
  }

  if (![v667 count]) {
    goto LABEL_226;
  }
  v806 = 0u;
  v805 = 0u;
  v804 = 0u;
  v803 = 0u;
  obja = v667;
  v717 = (char *)[obja countByEnumeratingWithState:&v803 objects:v830 count:16];
  if (!v717) {
    goto LABEL_225;
  }
  v261 = *(id *)v804;
  v703 = *(id *)v804;
  do
  {
    v262 = 0LL;
    do
    {
      if (*(id *)v804 != v261)
      {
        v263 = v262;
        objc_enumerationMutation(obja);
        v262 = v263;
      }

      v709 = v262;
      v264 = *(void **)(*((void *)&v803 + 1) + 8LL * (void)v262);
      v799 = 0u;
      v800 = 0u;
      v801 = 0u;
      v802 = 0u;
      v265 = v665;
      v266 = [v265 countByEnumeratingWithState:&v799 objects:v829 count:16];
      if (!v266)
      {
LABEL_279:

        v350 = nplog_obj(v347, v348, v349);
        v351 = (os_log_s *)objc_claimAutoreleasedReturnValue(v350);
        if (os_log_type_enabled(v351, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = obja;
          _os_log_impl( (void *)&_mh_execute_header,  v351,  OS_LOG_TYPE_DEFAULT,  "proxy info updated to %@",  (uint8_t *)&buf,  0xCu);
        }

        sub_100089154((uint64_t)v679);
        goto LABEL_288;
      }

      v267 = *(void *)v800;
LABEL_171:
      v268 = 0LL;
      while (1)
      {
        if (*(void *)v800 != v267) {
          objc_enumerationMutation(v265);
        }
        v269 = *(void **)(*((void *)&v799 + 1) + 8 * v268);
        v270 = [v264 proxyHop];
        v271 = (void *)objc_claimAutoreleasedReturnValue([v264 proxyURL]);
        v272 = (void *)objc_claimAutoreleasedReturnValue([v269 proxyURL]);
        v273 = v271;
        v274 = v272;
        v275 = (void *)v274;
        if (!(v273 | v274) || v273 && v274 && [(id)v273 isEqual:v274])
        {

          v276 = (void *)objc_claimAutoreleasedReturnValue([v264 tcpProxyFqdn]);
          v277 = (void *)objc_claimAutoreleasedReturnValue([v269 tcpProxyFqdn]);
          v273 = v276;
          v278 = v277;
          v275 = (void *)v278;
          if (!(v273 | v278) || v273 && v278 && [(id)v273 isEqual:v278])
          {

            v279 = (void *)objc_claimAutoreleasedReturnValue([v264 proxyKeyInfos]);
            v280 = (void *)objc_claimAutoreleasedReturnValue([v269 proxyKeyInfos]);
            v273 = v279;
            v281 = v280;
            v275 = (void *)v281;
            if (!(v273 | v281) || v273 && v281 && [(id)v273 isEqual:v281])
            {

              v282 = (void *)objc_claimAutoreleasedReturnValue([v264 tokenKeyInfo]);
              v283 = (void *)objc_claimAutoreleasedReturnValue([v269 tokenKeyInfo]);
              v273 = v282;
              v284 = v283;
              v275 = (void *)v284;
              if (!(v273 | v284) || v273 && v284 && [(id)v273 isEqual:v284])
              {

                v285 = (void *)objc_claimAutoreleasedReturnValue([v264 preferredPathConfigUri]);
                v286 = (void *)objc_claimAutoreleasedReturnValue([v269 preferredPathConfigUri]);
                v273 = v285;
                v287 = v286;
                v275 = (void *)v287;
                if (!(v273 | v287) || v273 && v287 && [(id)v273 isEqual:v287])
                {

                  v288 = (void *)objc_claimAutoreleasedReturnValue([v264 tokenChallenge]);
                  v289 = (void *)objc_claimAutoreleasedReturnValue([v269 tokenChallenge]);
                  v273 = v288;
                  v290 = v289;
                  v275 = (void *)v290;
                  if (!(v273 | v290) || v273 && v290 && [(id)v273 isEqual:v290])
                  {

                    v291 = (void *)objc_claimAutoreleasedReturnValue([v264 bootstrapAddresses]);
                    v292 = (void *)objc_claimAutoreleasedReturnValue([v269 bootstrapAddresses]);
                    v273 = v291;
                    v293 = v292;
                    v275 = (void *)v293;
                    if (!(v273 | v293) || v273 && v293 && [(id)v273 isEqual:v293])
                    {

                      v294 = (void *)objc_claimAutoreleasedReturnValue([v264 allowedNextHops]);
                      v295 = (void *)objc_claimAutoreleasedReturnValue([v269 allowedNextHops]);
                      v273 = v294;
                      v296 = v295;
                      v275 = (void *)v296;
                    }
                  }
                }
              }
            }
          }
        }

LABEL_220:
        if (v266 == (id)++v268)
        {
          v266 = [v265 countByEnumeratingWithState:&v799 objects:v829 count:16];
          if (!v266) {
            goto LABEL_279;
          }
          goto LABEL_171;
        }
      }

      v297 = (void *)objc_claimAutoreleasedReturnValue([v264 preferredPathPatterns]);
      v298 = (void *)objc_claimAutoreleasedReturnValue([v269 preferredPathPatterns]);
      v299 = sub_10008EE68(v297, v298);

      if ((v299 & 1) != 0) {
        goto LABEL_220;
      }
      v300 = (void *)objc_claimAutoreleasedReturnValue([v264 proxyVersion]);
      v301 = (void *)objc_claimAutoreleasedReturnValue([v269 proxyVersion]);
      v302 = sub_10008EE68(v300, v301);

      if ((v302 & 1) != 0) {
        goto LABEL_220;
      }
      v303 = [v264 fallbackSupportsUDPProxying];
      v304 = [v264 algorithm];

      v262 = v709 + 1;
      v261 = v703;
    }

    while (v709 + 1 != v717);
    v717 = (char *)[obja countByEnumeratingWithState:&v803 objects:v830 count:16];
    v261 = v703;
  }

  while (v717);
LABEL_225:

LABEL_226:
  v305 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v688 = (void *)objc_claimAutoreleasedReturnValue([v305 pathWeights]);

  v306 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v704 = (id)objc_claimAutoreleasedReturnValue([v306 pathWeights]);

  v307 = [v688 count];
  v308 = [v704 count];
  if (v307 != v308)
  {
    v352 = nplog_obj(v308, v309, v310);
    v353 = (os_log_s *)objc_claimAutoreleasedReturnValue(v352);
    if (os_log_type_enabled(v353, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v688;
      _os_log_impl( (void *)&_mh_execute_header,  v353,  OS_LOG_TYPE_DEFAULT,  "proxy path list updated to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089154((uint64_t)v679);
LABEL_288:
    v663 = 1;
    goto LABEL_289;
  }

  if (![v688 count]) {
    goto LABEL_251;
  }
  v798 = 0u;
  v797 = 0u;
  v796 = 0u;
  v795 = 0u;
  v683 = v688;
  v698 = (char *)[v683 countByEnumeratingWithState:&v795 objects:v828 count:16];
  if (!v698) {
    goto LABEL_250;
  }
  v693 = *(void *)v796;
  while (2)
  {
    v311 = 0LL;
    while (2)
    {
      if (*(void *)v796 != v693)
      {
        v312 = v311;
        objc_enumerationMutation(v683);
        v311 = v312;
      }

      v710 = v311;
      v313 = *(void **)(*((void *)&v795 + 1) + 8LL * (void)v311);
      v791 = 0u;
      v792 = 0u;
      v793 = 0u;
      v794 = 0u;
      v718 = v704;
      v314 = [v718 countByEnumeratingWithState:&v791 objects:v827 count:16];
      if (!v314)
      {
LABEL_285:

        v357 = nplog_obj(v354, v355, v356);
        v358 = (os_log_s *)objc_claimAutoreleasedReturnValue(v357);
        if (os_log_type_enabled(v358, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v683;
          _os_log_impl( (void *)&_mh_execute_header,  v358,  OS_LOG_TYPE_DEFAULT,  "proxy path updated to %@",  (uint8_t *)&buf,  0xCu);
        }

        sub_100089154((uint64_t)v679);
        goto LABEL_288;
      }

      objb = *(id *)v792;
      while (2)
      {
        v315 = 0LL;
LABEL_236:
        if (*(id *)v792 != objb) {
          objc_enumerationMutation(v718);
        }
        v316 = *(void **)(*((void *)&v791 + 1) + 8 * v315);
        v317 = [v313 weight];
        if (v317 != [v316 weight]
          || (v318 = [v313 proxiesCount], v318 != objc_msgSend(v316, "proxiesCount")))
        {
LABEL_245:
          if ((id)++v315 == v314)
          {
            v314 = [v718 countByEnumeratingWithState:&v791 objects:v827 count:16];
            if (!v314) {
              goto LABEL_285;
            }
            continue;
          }

          goto LABEL_236;
        }

        break;
      }

      if ([v313 proxiesCount])
      {
        v319 = 0LL;
        do
        {
          v322 = (void *)objc_claimAutoreleasedReturnValue([v320 proxyURL]);
          v323 = (void *)objc_claimAutoreleasedReturnValue([v321 proxyURL]);
          v324 = [v322 isEqualToString:v323];

          if ((v324 & 1) == 0) {
            goto LABEL_245;
          }
        }

        while (++v319 < (unint64_t)[v313 proxiesCount]);
      }

      v311 = v710 + 1;
      if (v710 + 1 != v698) {
        continue;
      }
      break;
    }

    v698 = (char *)[v683 countByEnumeratingWithState:&v795 objects:v828 count:16];
    if (v698) {
      continue;
    }
    break;
  }

  id v23 = 0LL;
  id v13 = 0LL;
  id v24 = 0LL;
LABEL_25:
  uint64_t v25 = v1;
LABEL_26:
  uint64_t v26 = mach_absolute_time();
  double v27 = objc_alloc_init(&OBJC_CLASS___NSPTokenFetchAnalytics);
  -[NSPTokenFetchAnalytics setProxyURL:](v27, "setProxyURL:", *(void *)(v25 + 120));
  id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v25 + 80) issuerName]);
  -[NSPTokenFetchAnalytics setProxyVendor:](v27, "setProxyVendor:", v28);

  id v29 = *(int *)(v25 + 164);
  if (v29 >= 5) {
    uint64_t v30 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  *(int *)(v25 + 164)));
  }
  else {
    uint64_t v30 = off_1000FAE28[v29];
  }
  -[NSPTokenFetchAnalytics setAuthenticationType:](v27, "setAuthenticationType:", v30);

  -[NSPTokenFetchAnalytics setRequestedServerUUID:](v27, "setRequestedServerUUID:", v24);
  -[NSPTokenFetchAnalytics setRequestedTokenCount:](v27, "setRequestedTokenCount:", *(unsigned int *)(v96 + 160));
  -[NSPTokenFetchAnalytics setActivatedCount:](v27, "setActivatedCount:", v23);
  -[NSPTokenFetchAnalytics setHttpCode:](v27, "setHttpCode:", [v13 statusCode]);
  id v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v96 + 32) domain]);
  unint64_t v32 = [v31 isEqualToString:NSURLErrorDomain];

  if (v32) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v27, "setNsurlErrorCode:", [*(id *)(v96 + 32) code]);
  }
  uint64_t v33 = (double)(v26 - *(void *)(v96 + 152));
  if (qword_100117210 != -1) {
    dispatch_once(&qword_100117210, &stru_1000FADE8);
  }
  -[NSPTokenFetchAnalytics setLatency:](v27, "setLatency:", *(double *)&qword_100117218 * v33);
  -[NSPProxyAnalytics sendAnalytics](v27, "sendAnalytics");

LABEL_34:
}

LABEL_23:
    _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, v44, buf, 2u);
    goto LABEL_24;
  }

  id v39 = 1;
  (*((void (**)(id, uint64_t))v4 + 2))(v4, 1LL);
LABEL_26:

  return v39;
}

LABEL_24:
  }
}

  id v31 = (void *)objc_claimAutoreleasedReturnValue([v13[96] now]);
  sub_10009C5A0(self, v10, v31);

  if (self)
  {
    ++self->_generation;
    +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-service-status-changed");
  }

  double v27 = 1;
LABEL_26:

  return v27;
}

    uint64_t v41 = nplog_obj(v34, v35, v36);
    uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_INFO,  "No eligible account found, cannot request token",  (uint8_t *)&buf,  2u);
    }

    (*((void (**)(id, void, uint64_t, void))v22 + 2))(v22, 0LL, 1003LL, 0LL);
    goto LABEL_83;
  }

  if (!v113 && !a14) {
    goto LABEL_23;
  }
LABEL_26:
  uint64_t v43 = self;
  if (self)
  {
    accessTokenTypes = self->_accessTokenTypes;
    if (accessTokenTypes)
    {
      id v130 = 0u;
      v131 = 0u;
      v128 = 0u;
      v129 = 0u;
      uint64_t v45 = accessTokenTypes;
      id v46 = -[NSArray countByEnumeratingWithState:objects:count:]( v45,  "countByEnumeratingWithState:objects:count:",  &v128,  v137,  16LL);
      if (v46)
      {
        id v47 = *(void *)v129;
        while (2)
        {
          for (i = 0LL; i != v46; i = (char *)i + 1)
          {
            if (*(void *)v129 != v47) {
              objc_enumerationMutation(v45);
            }
            uint64_t v49 = [*(id *)(*((void *)&v128 + 1) + 8 * (void)i) unsignedShortValue];
            if (v49 == [v21 tokenType])
            {

              uint64_t v43 = self;
              goto LABEL_40;
            }
          }

          id v46 = -[NSArray countByEnumeratingWithState:objects:count:]( v45,  "countByEnumeratingWithState:objects:count:",  &v128,  v137,  16LL);
          if (v46) {
            continue;
          }
          break;
        }
      }

      uint64_t v53 = nplog_obj(v50, v51, v52);
      id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        id v55 = [v21 tokenType];
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v55;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Cannot fetch token type %u, not in allowed type list",  (uint8_t *)&buf,  8u);
      }

      goto LABEL_38;
    }

  uint64_t v30 = 0LL;
LABEL_10:

LABEL_11:
  return v30;
}

LABEL_24:
  uint64_t v51 = 0LL;
LABEL_46:

LABEL_47:
  return v51;
}

void sub_100012AF4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if (![a2 result])
  {
    uint64_t v16 = nplog_obj(0LL, v6, v7);
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    char v15 = 1;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_INFO)) {
      goto LABEL_12;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v17 = "Oblivious config validated by transparency, allowing";
    uint64_t v18 = v13;
    uint32_t v19 = 2;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, v17, buf, v19);
    goto LABEL_12;
  }

  uint64_t v8 = _os_feature_enabled_impl("NetworkServiceProxy", "TransparencyValidation");
  char v9 = v8;
  uint64_t v12 = nplog_obj(v8, v10, v11);
  id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_INFO);
  if ((v9 & 1) == 0)
  {
    if (!v14)
    {
      char v15 = 1;
      goto LABEL_12;
    }

    *(_DWORD *)__int128 buf = 138412290;
    id v27 = v5;
    uint64_t v17 = "Oblivious config not validated by transparency (error %@), allowing since feature flag is not enabled";
    char v15 = 1;
    uint64_t v18 = v13;
    uint32_t v19 = 12;
    goto LABEL_10;
  }

  if (v14)
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v27 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Oblivious config not validated by transparency (error %@), blocking",  buf,  0xCu);
  }

  char v15 = 0;
LABEL_12:

  uint64_t v21 = NPGetInternalQueue(v20);
  uint64_t v22 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v21);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = sub_100012CC4;
  v23[3] = &unk_1000F9860;
  id v24 = *(id *)(a1 + 32);
  char v25 = v15;
  dispatch_async(v22, v23);
}

uint64_t sub_100012CC4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

LABEL_9:
  uint64_t v22 = nplog_obj(v17, v18, v19);
  id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    id v24 = (void *)objc_claimAutoreleasedReturnValue(-[NSPObliviousPath shortName](self, "shortName"));
    *(_DWORD *)__int128 buf = 134218242;
    *(void *)&uint8_t buf[4] = self;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%p oblivious path [%@] is ready", buf, 0x16u);
  }

  return 1;
}

      uint64_t v6 = 0LL;
    }
  }

  return v6;
}

  return v9;
}

  return a1;
}

    (*((void (**)(id, void, void, void))v9 + 2))(v9, 0LL, 0LL, 0LL);
    goto LABEL_6;
  }

  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v7 URL]);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Sending request for %@", (uint8_t *)&buf, 0xCu);
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v26 = 0x3032000000LL;
  id v27 = sub_1000A8328;
  id v28 = sub_1000A8338;
  id v29 = 0LL;
  uint32_t v19 = _NSConcreteStackBlock;
  uint64_t v20 = 3221225472LL;
  uint64_t v21 = sub_1000A8340;
  uint64_t v22 = &unk_1000FA940;
  p___int128 buf = &buf;
  id v23 = v9;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v8 dataTaskWithRequest:v7 completionHandler:&v19]);
  objc_storeStrong((id *)(*((void *)&buf + 1) + 40LL), v17);
  objc_msgSend(*(id *)(*((void *)&buf + 1) + 40), "resume", v19, v20, v21, v22);

  _Block_object_dispose(&buf, 8);
LABEL_6:
}

  v234.receiver = (id)a1;
  v234.super_class = (Class)&OBJC_CLASS___NSPPrivateAccessTokenRequest;
  uint64_t v26 = objc_msgSendSuper2(&v234, "init");
  if (!v26)
  {
    v207 = nplog_obj(0LL, v27, v28);
    a1 = objc_claimAutoreleasedReturnValue(v207);
    if (os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)md = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)a1, OS_LOG_TYPE_FAULT, "[super init] failed", md, 2u);
    }

    goto LABEL_24;
  }

  a1 = (uint64_t)v26;
  v26[5] = (unsigned __int16)[v11 tokenType];
  id v29 = (void *)objc_claimAutoreleasedReturnValue([v11 originNames]);
  uint64_t v30 = [v29 count];

  if (!v14 || (unint64_t)v30 < 2)
  {
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v11 originName]);
    objc_setProperty_atomic((id)a1, v37, v36, 56LL);

LABEL_15:
    memset(md, 0, sizeof(md));
    CC_SHA256([v12 bytes], (CC_LONG)objc_msgSend(v12, "length"), md);
    v233 = md[31];
    *(_BYTE *)(a1 + 9) = md[31];
    id v38 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
    v232 = __rev16(*(unsigned __int16 *)(a1 + 10));
    -[NSMutableData appendBytes:length:](v38, "appendBytes:length:", &v232, 2LL);
    objc_setProperty_atomic((id)a1, v39, v18, 32LL);
    if (*(_WORD *)(a1 + 10) != 3)
    {
      -[NSMutableData appendBytes:length:](v38, "appendBytes:length:", &v233, 1LL);
      -[NSMutableData appendData:](v38, "appendData:", v18);
LABEL_20:
      objc_setProperty_atomic((id)a1, v50, v38, 24LL);
      uint64_t v51 = (id)a1;
LABEL_45:

      goto LABEL_46;
    }

    v231 = v13;
    id v40 = v13;
    uint64_t v41 = [v40 length];
    uint64_t v42 = (char *)[v40 bytes];
    if ((unint64_t)v41 <= 0x26)
    {
      uint64_t v45 = nplog_obj(v42, v43, v44);
      id v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134217984;
        *(void *)&uint8_t buf[4] = v41;
        id v47 = "Config length is too short: %zu";
        uint64_t v48 = v46;
        uint64_t v49 = 12;
LABEL_42:
        _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, v47, buf, v49);
      }

void sub_100013114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id sub_10001314C(uint64_t a1, int a2)
{
  int v3 = *(void **)(a1 + 32);
  if (a2) {
    uint64_t v4 = 2LL;
  }
  else {
    uint64_t v4 = 3LL;
  }
  id result = [v3 setTransparencyState:v4];
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    id result = [*(id *)(a1 + 32) pathReady];
    if ((_DWORD)result) {
      return [*(id *)(a1 + 32) setupProxyAgentsForceUpdateDelegate:1];
    }
  }

  return result;
}

LABEL_20:
  return (char)v6;
}

        uint64_t v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      char v15 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
      uint64_t v6 = v15;
    }

    while (v15);
  }

  uint64_t v16 = 0LL;
LABEL_26:

  return v16;
}

        sub_1000653B8((uint64_t)WeakRetained);
        goto LABEL_21;
      }
    }

    else
    {
      id v24 = nplog_obj(v14, v15, v16);
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        id v29 = WeakRetained[5];
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 etag]);
        id v31 = 138412290;
        unint64_t v32 = v30;
        _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "Unable to verify configuration signature on disk (etag was %@)",  (uint8_t *)&v31,  0xCu);
      }
    }

    uint64_t v26 = nplog_obj(v19, v20, v21);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v31) = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Starting and not using configuration settings on disk",  (uint8_t *)&v31,  2u);
    }

    [WeakRetained[5] setEtag:0];
    [WeakRetained[5] setEpoch:0];
    [WeakRetained[5] setProxyConfiguration:0];
    [WeakRetained[5] setConfigurationFetchDate:0];
    id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) configServerPath]);
    [WeakRetained[5] setConfigServerPath:v28];

    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) configServerHost]);
    [WeakRetained[5] setConfigServerHost:v23];
    goto LABEL_20;
  }

LABEL_11:
      id v28 = 0;
      goto LABEL_15;
    }
  }

  else
  {
  }

  id v29 = nplog_obj(v23, v24, v25);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
  id v28 = 1;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxiedContentPath shortName](self, "shortName"));
    unint64_t v32 = 138412290;
    uint64_t v33 = (uint64_t)v30;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "proxied content path [%@] is ready",  (uint8_t *)&v32,  0xCu);
  }

  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
}

      uint64_t v44 = -[MLMultiArray initWithShape:dataType:error:]( objc_alloc(&OBJC_CLASS___MLMultiArray),  "initWithShape:dataType:error:",  v18,  65568LL,  0LL);
      if (!v44)
      {
        uint64_t v118 = nplog_obj(0LL, v42, v43);
        id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v118);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          v131 = "+[NSPCoreData normalizeData:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_FAULT,  "%s called with null reshapedInput",  buf,  0xCu);
        }

        uint64_t v102 = 0LL;
        goto LABEL_46;
      }

      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
      id v46 = [v45 count];

      if ((unint64_t)v46 >= 3)
      {
        id v124 = v7;
        v125 = v44;
        v123 = v11;
        id v47 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v47 objectAtIndexedSubscript:1]);
        uint64_t v49 = [v48 unsignedIntValue];

        if (v49)
        {
          uint64_t v50 = 0LL;
          do
          {
            uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
            v129[0] = v51;
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v50));
            v129[1] = v52;
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
            v129[2] = v53;
            id v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v129,  3LL));
            id v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v54));

            __int16 v56 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
            id v57 = (void *)objc_claimAutoreleasedReturnValue([v56 objectAtIndexedSubscript:2]);
            LODWORD(v52) = [v57 unsignedIntValue];

            if ((_DWORD)v52)
            {
              id v58 = 0LL;
              do
              {
                uint64_t v59 = (char *)[v55 count] - 1;
                uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v58));
                [v55 replaceObjectAtIndex:v59 withObject:v60];

                double v61 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v55]);
                -[os_log_s setObject:forKeyedSubscript:](v125, "setObject:forKeyedSubscript:", v61, v55);

                id v58 = (v58 + 1);
                double v62 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
                uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 objectAtIndexedSubscript:2]);
                uint64_t v64 = [v63 unsignedIntValue];
              }

              while (v58 < v64);
            }

            uint64_t v50 = (v50 + 1);
            id v65 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
            id v66 = (void *)objc_claimAutoreleasedReturnValue([v65 objectAtIndexedSubscript:1]);
            uint64_t v67 = [v66 unsignedIntValue];
          }

          while (v50 < v67);
        }

        v126 = 0LL;
        uint64_t v7 = v124;
        uint64_t v44 = v125;
        unint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v124, "predictionFromNormalizer_input:error:", v125, &v126));
        unint64_t v69 = (os_log_s *)v126;
        id v72 = v69;
        if (v68)
        {
          id v121 = v69;
          v122 = v18;
          id v73 = objc_alloc(&OBJC_CLASS___MLMultiArray);
          id v74 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
          uint64_t v75 = -[MLMultiArray initWithShape:dataType:error:](v73, "initWithShape:dataType:error:", v74, 65568LL, 0LL);

          if (v75)
          {
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
            uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:1]);
            uint64_t v81 = [v80 unsignedIntValue];

            if (v81)
            {
              uint64_t v82 = 0LL;
              do
              {
                id v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  0LL));
                v128[0] = v83;
                __int128 v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v82));
                v128[1] = v84;
                __int128 v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  0LL));
                v128[2] = v85;
                __int128 v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v128,  3LL));
                __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v86));

                uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
                v89 = (void *)objc_claimAutoreleasedReturnValue([v88 objectAtIndexedSubscript:2]);
                LODWORD(v85) = [v89 unsignedIntValue];

                if ((_DWORD)v85)
                {
                  v90 = 0LL;
                  do
                  {
                    id v91 = (char *)[v87 count] - 1;
                    uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v90));
                    [v87 replaceObjectAtIndex:v91 withObject:v92];

                    uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v68 Identity]);
                    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([v93 objectForKeyedSubscript:v87]);
                    -[MLMultiArray setObject:forKeyedSubscript:](v75, "setObject:forKeyedSubscript:", v94, v87);

                    v90 = (v90 + 1);
                    v95 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
                    id v96 = (void *)objc_claimAutoreleasedReturnValue([v95 objectAtIndexedSubscript:2]);
                    v97 = [v96 unsignedIntValue];
                  }

                  while (v90 < v97);
                }

                uint64_t v82 = (v82 + 1);
                uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v3 shape]);
                v99 = (void *)objc_claimAutoreleasedReturnValue([v98 objectAtIndexedSubscript:1]);
                uint64_t v100 = [v99 unsignedIntValue];
              }

              while (v82 < v100);
            }

            uint64_t v101 = v75;
            uint64_t v102 = v101;
          }

          else
          {
            v119 = nplog_obj(v76, v77, v78);
            id v120 = (os_log_s *)objc_claimAutoreleasedReturnValue(v119);
            if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              v131 = "+[NSPCoreData normalizeData:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_FAULT,  "%s called with null reshapedOutput",  buf,  0xCu);
            }

            uint64_t v101 = 0LL;
            uint64_t v102 = 0LL;
          }

          uint64_t v11 = v123;
          uint64_t v7 = v124;
          id v72 = v121;
          uint64_t v18 = v122;
          uint64_t v44 = v125;
        }

        else
        {
          v115 = nplog_obj(v69, v70, v71);
          uint64_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue(v115);
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            v131 = (const char *)v72;
            _os_log_error_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_ERROR,  "Failed to normalize the input. error:%@",  buf,  0xCu);
          }

          uint64_t v102 = 0LL;
          uint64_t v11 = v123;
        }

LABEL_46:
        goto LABEL_40;
      }
    }

    else
    {
      uint64_t v107 = nplog_obj(v26, v27, v28);
      uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue(v107);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
LABEL_38:
        v111 = (char *)objc_claimAutoreleasedReturnValue([v3 shape]);
        *(_DWORD *)__int128 buf = 138412546;
        v131 = v111;
        v132 = 2112;
        id v133 = v18;
        _os_log_error_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_ERROR,  "Incompatiable shape (%@ vs %@)",  buf,  0x16u);
      }
    }

  uint64_t v22 = v15;

  _Block_object_dispose(&v29, 8);
  return v22;
}

  objc_sync_exit(v5);
}

  return (char)v3;
}

    v15[2](v15, 1LL, 0LL, 0LL, 0LL);
    goto LABEL_5;
  }

  if (!v10)
  {
    uint64_t v21 = nplog_obj(v12, v13, v14);
    uint32_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v29 = "+[NSPBAA sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:]";
      uint64_t v20 = "%s called with null tokenFetchURLSession";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v11)
  {
    uint64_t v22 = nplog_obj(v12, v13, v14);
    uint32_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v29 = "+[NSPBAA sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:]";
    uint64_t v20 = "%s called with null tokenActivationQuery";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v20, buf, 0xCu);
    goto LABEL_11;
  }

  [v11 setAuthType:1];
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v11 tokenInfo]);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 data]);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = sub_1000A8630;
  v23[3] = &unk_1000FAEF8;
  id v24 = v11;
  char v25 = v9;
  uint64_t v26 = v10;
  id v27 = v15;
  sub_1000A7BF0((uint64_t)&OBJC_CLASS___NSPBAA, v17, v23);

LABEL_5:
}

    v15[2](v15, 1LL, 0LL, 0LL, 0LL);
    goto LABEL_5;
  }

  if (!v10)
  {
    uint32_t v19 = nplog_obj(v12, v13, v14);
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v27 = "+[NSPBAA sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:]";
      uint64_t v18 = "%s called with null tokenFetchURLSession";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v11)
  {
    uint64_t v20 = nplog_obj(v12, v13, v14);
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v27 = "+[NSPBAA sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:]";
    uint64_t v18 = "%s called with null messageBody";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v18, buf, 0xCu);
    goto LABEL_11;
  }

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  v21[2] = sub_1000A8EBC;
  v21[3] = &unk_1000FAF48;
  uint64_t v22 = v9;
  id v23 = v11;
  id v24 = v10;
  char v25 = v15;
  sub_1000A8860((uint64_t)&OBJC_CLASS___NSPBAA, v23, v22, v21);

LABEL_5:
}

    v15[2](v15, 1LL, 0LL, 0LL, 0LL);
    goto LABEL_5;
  }

  if (!v10)
  {
    id v29 = nplog_obj(v12, v13, v14);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA_Anisette sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:c"
                                      "ompletionHandler:]";
      id v28 = "%s called with null tokenFetchURLSession";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v11)
  {
    uint64_t v30 = nplog_obj(v12, v13, v14);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "+[NSPBAA_Anisette sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:com"
                                    "pletionHandler:]";
    id v28 = "%s called with null tokenActivationQuery";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, v28, (uint8_t *)&buf, 0xCu);
    goto LABEL_11;
  }

  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_1000A9418;
  v34[3] = &unk_1000FAF70;
  uint64_t v33 = v9;
  uint64_t v35 = v9;
  unint64_t v32 = v10;
  uint64_t v36 = v10;
  id v31 = v11;
  uint64_t v37 = v11;
  id v38 = v15;
  uint64_t v16 = v35;
  uint64_t v17 = v36;
  uint64_t v18 = v37;
  uint32_t v19 = v34;
  objc_opt_self(&OBJC_CLASS___NSPBAA);
  [v18 setAuthType:1];
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v18 tokenInfo]);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 data]);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  id v40 = sub_1000A8744;
  uint64_t v41 = &unk_1000FAEF8;
  uint64_t v22 = v18;
  uint64_t v42 = v22;
  id v23 = v16;
  uint64_t v43 = v23;
  id v24 = v17;
  uint64_t v44 = v24;
  char v25 = v19;
  uint64_t v45 = v25;
  sub_1000A7BF0((uint64_t)&OBJC_CLASS___NSPBAA, v21, &buf);

  uint64_t v11 = v31;
  char v9 = v33;

  uint64_t v10 = v32;
LABEL_5:
}

    v15[2](v15, 1LL, 0LL, 0LL, 0LL);
    goto LABEL_5;
  }

  if (!v10)
  {
    unint64_t v32 = nplog_obj(v12, v13, v14);
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA_Anisette sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:]";
      id v31 = "%s called with null tokenFetchURLSession";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v11)
  {
    uint64_t v33 = nplog_obj(v12, v13, v14);
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "+[NSPBAA_Anisette sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:]";
    id v31 = "%s called with null messageBody";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, v31, (uint8_t *)&buf, 0xCu);
    goto LABEL_11;
  }

  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_1000A97E8;
  v34[3] = &unk_1000FAF70;
  uint64_t v35 = v9;
  uint64_t v36 = v10;
  uint64_t v37 = v11;
  id v38 = v15;
  uint64_t v16 = v35;
  uint64_t v17 = v36;
  uint64_t v18 = v37;
  uint32_t v19 = v11;
  uint64_t v20 = v10;
  uint64_t v21 = v9;
  uint64_t v22 = v15;
  id v23 = v34;
  objc_opt_self(&OBJC_CLASS___NSPBAA);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  id v40 = sub_1000A8FAC;
  uint64_t v41 = &unk_1000FAF48;
  id v24 = v16;
  uint64_t v42 = v24;
  char v25 = v18;
  uint64_t v43 = v25;
  uint64_t v26 = v17;
  uint64_t v44 = v26;
  id v27 = v23;
  char v15 = v22;
  char v9 = v21;
  uint64_t v10 = v20;
  uint64_t v11 = v19;
  id v28 = v27;
  uint64_t v45 = v27;
  sub_1000A8860((uint64_t)&OBJC_CLASS___NSPBAA, v25, v24, &buf);

LABEL_5:
}

    uint64_t v16 = 0LL;
    goto LABEL_5;
  }

  if (!v9)
  {
    uint64_t v21 = nplog_obj(v10, v11, v12);
    uint32_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      id v23 = 136315138;
      id v24 = "-[NSPPrivateAccessTokenChallenge initRateLimitedRSABlindSignatureChallengeWithIssuerName:redemptionNonce:originNames:]";
      uint64_t v20 = "%s called with null redemptionNonce";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (![v10 count])
  {
    uint64_t v22 = nplog_obj(0LL, v14, v15);
    uint32_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    id v23 = 136315138;
    id v24 = "-[NSPPrivateAccessTokenChallenge initRateLimitedRSABlindSignatureChallengeWithIssuerName:redemptionNonce:originNames:]";
    uint64_t v20 = "%s called with null originNames.count";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v23, 0xCu);
    goto LABEL_11;
  }

  self = (NSPPrivateAccessTokenChallenge *)sub_1000AAE68(self, 3u, v8, v9, v13);
  uint64_t v16 = self;
LABEL_5:

  return v16;
}

    goto LABEL_5;
  }

  if (!v10)
  {
    uint64_t v20 = nplog_obj(v11, v12, v13);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    {
      uint64_t v22 = 136315138;
      id v23 = "+[NSPPrivateAccessTokenFetcher saveAuxiliaryAuthenticationDataToCache:type:forLabel:cacheKey:]";
      uint32_t v19 = "%s called with null label";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v11)
  {
    uint64_t v21 = nplog_obj(0LL, v12, v13);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    uint64_t v22 = 136315138;
    id v23 = "+[NSPPrivateAccessTokenFetcher saveAuxiliaryAuthenticationDataToCache:type:forLabel:cacheKey:]";
    uint32_t v19 = "%s called with null cacheKey";
LABEL_13:
    _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v22, 0xCu);
    goto LABEL_11;
  }

  ServerConnection = getServerConnection();
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(ServerConnection);
  [v16 addAuxiliaryAuthenticationData:v9 type:a4 label:v10 cacheKey:v14];

LABEL_5:
}

void sub_100015F64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23)
{
}

void sub_100015FA0(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  switch(a2)
  {
    case 1:
    case 4:
      uint64_t v6 = *(nw_connection **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
      if (v6) {
        nw_connection_cancel(v6);
      }
      break;
    case 3:
      dispatch_time_t v7 = dispatch_time(0LL, 5000000000LL);
      uint64_t v8 = NPGetInternalQueue(v7);
      char v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v8);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10001609C;
      block[3] = &unk_1000F98B0;
      void block[4] = *(void *)(a1 + 32);
      dispatch_after(v7, v9, block);

      break;
    case 5:
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8LL);
      uint64_t v11 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = 0LL;

      break;
    default:
      break;
  }
}

void sub_10001609C(uint64_t a1)
{
  uint64_t v1 = *(nw_connection **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (v1) {
    nw_connection_cancel(v1);
  }
}

void sub_1000160B4(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v4 = WeakRetained;
  if (WeakRetained) {
    id v5 = [WeakRetained copyAddressesFromDoHAnswer:v6];
  }
  else {
    id v5 = 0LL;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  nw_connection_cancel(*(nw_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
}

int64_t sub_1000161E4(id a1, NSString *a2, NSString *a3)
{
  uint64_t v4 = a3;
  unsigned int v5 = -[NSString containsString:](a2, "containsString:", @":");
  unsigned int v6 = -[NSString containsString:](v4, "containsString:", @":");

  if (v5 == v6) {
    unsigned int v5 = arc4random_uniform(2u) == 0;
  }
  if (v5) {
    return -1LL;
  }
  else {
    return 1LL;
  }
}

void sub_1000168F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,id location,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

void sub_100016950(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (nw_protocol_options_is_http3())
  {
    v9[0] = 0LL;
    v9[1] = 0LL;
    nw_http3_set_resumable_session_agent(v3, v9);
    uint64_t v4 = nw_http3_set_idle_timeout(v3, 0LL);
    uint64_t v5 = NPGetInternalQueue(v4);
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_100016A60;
    v7[3] = &unk_1000F9968;
    objc_copyWeak(&v8, (id *)(a1 + 32));
    nw_http3_set_resumable_session_handler(v3, 20LL, v6, v7);

    objc_destroyWeak(&v8);
  }
}

void sub_100016A44(_Unwind_Exception *a1)
{
}

void sub_100016A60(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained quicRegistration]);

    if (v6)
    {
      uint64_t v10 = nplog_obj(v7, v8, v9);
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v5 shortName]);
        int v14 = 138412290;
        char v15 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "proxied content path [%@] received session ticket",  (uint8_t *)&v14,  0xCu);
      }

      id v13 = (void *)objc_claimAutoreleasedReturnValue([v5 quicRegistration]);
      sub_100044DB0((uint64_t)v13, v3);
    }
  }
}

void sub_100016B70(uint64_t a1, void *a2)
{
  id v4 = a2;
  if ([v4 count]) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100016BC8(uint64_t a1, void *a2)
{
  id v4 = a2;
  if ([v4 count]) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100016C20(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = [WeakRetained setFetchingSessionTickets:0];
    uint64_t v9 = nplog_obj(v6, v7, v8);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 shortName]);
      *(_DWORD *)uint64_t v26 = 138412290;
      *(void *)&v26[4] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "proxied content path [%@] done fetching session tickets",  v26,  0xCu);
    }

    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v5 delegate]);
    unsigned int v13 = [v12 disableDoHBootstrapResults];

    int v14 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) arrayByAddingObjectsFromArray:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)]);
    uint64_t v17 = nplog_obj(v14, v15, v16);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint32_t v19 = (void *)objc_claimAutoreleasedReturnValue([v5 shortName]);
      uint64_t v20 = "";
      *(_DWORD *)uint64_t v26 = 138412802;
      *(void *)&v26[4] = v19;
      if (v13) {
        uint64_t v20 = " (ignoring)";
      }
      *(_WORD *)&v26[12] = 2082;
      *(void *)&v26[14] = v20;
      __int16 v27 = 2112;
      id v28 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "proxied content path [%@] received resolved addresses%{public}s: %@",  v26,  0x20u);
    }

    if (v13)
    {
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v5 resolvedAddresses]);

      if (!v21)
      {
LABEL_14:
        char v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "delegate", v22, *(void *)v26, *(void *)&v26[8]));
        [v25 updateUserEventAgentData];

        goto LABEL_15;
      }

      uint64_t v22 = 0LL;
    }

    else
    {
      if (![v14 count]) {
        goto LABEL_14;
      }
      id v23 = (void *)objc_claimAutoreleasedReturnValue([v5 resolvedAddresses]);
      unsigned __int8 v24 = [v14 isEqualToArray:v23];

      uint64_t v22 = v14;
      if ((v24 & 1) != 0) {
        goto LABEL_14;
      }
    }

    objc_msgSend(v5, "setResolvedAddresses:", v22, *(_OWORD *)v26);
    [v5 resetQUICProxyAgentForceUpdateDelegate:0];
    [v5 resetResolverAgentForceUpdateDelegate:0];
    goto LABEL_14;
  }

LABEL_51:
        v108 = -[NSPProxiedContentPath proxiedContentAgentRegistered](self, "proxiedContentAgentRegistered");
        if (v98)
        {
        }

        if ((v108 & 1) != 0) {
          goto LABEL_57;
        }
        goto LABEL_55;
      }
    }

  -[NSPConfigurationStats setAppTrackersEnabled:](v15, "setAppTrackersEnabled:", 1LL);
  unsigned int v13 = v15;
  if ((v12 & 0x400) == 0)
  {
LABEL_26:
    if ((v12 & 0x10000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_53;
  }

LABEL_56:
LABEL_57:
    _Block_object_dispose(buf, 8);

LABEL_58:
LABEL_59:
  }

        id v6 = (char *)v6 + 1;
      }

      while (v6 != v4);
      uint64_t v53 = [v2 countByEnumeratingWithState:&v85 objects:v96 count:16];
      id v4 = v53;
      if (!v53)
      {
LABEL_90:

        [a1[44] removeObjectsInArray:v54];
        return;
      }
    }
  }

  -[NSPConfigurationStats setNetworkToolsEnabled:](v15, "setNetworkToolsEnabled:", 1LL);
  unsigned int v13 = v15;
  if ((v12 & 0x4000) == 0)
  {
LABEL_31:
    if ((v12 & 0x8000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_58;
  }

void sub_100018798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t sub_1000187FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_6;
  }
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
  unsigned int v6 = [v5 isEqual:&off_100103338];
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resolverAgentUUID]);
    unsigned int v9 = [v7 isEqual:v8];

    if (v9)
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v11 = v3;
      uint64_t v5 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v11;
      goto LABEL_5;
    }

id sub_1000188EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_100103338])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resolverAgentUUID]);
      id v8 = [v6 isEqual:v7];
    }

    else
    {
      id v8 = 0LL;
    }
  }

  else
  {
    id v8 = 0LL;
  }

  return v8;
}

id sub_100018BAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_100103338])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resolverAgentUUID]);
      id v8 = [v6 isEqual:v7];
    }

    else
    {
      id v8 = 0LL;
    }
  }

  else
  {
    id v8 = 0LL;
  }

  return v8;
}

LABEL_60:
      if (v31) {
        ++*(void *)(v31 + 88);
      }
      goto LABEL_62;
    }

    if ((v6 - 1100) <= 7)
    {
      if (((1 << (v6 - 76)) & 0x33) != 0) {
        goto LABEL_60;
      }
      if ((_DWORD)v6 == 1106)
      {
        if (v31) {
          ++*(void *)(v31 + 80);
        }
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
        id v54 = v53;
        id v55 = 1106LL;
        goto LABEL_63;
      }

      if ((_DWORD)v6 == 1107)
      {
        if (v31) {
          ++*(void *)(v31 + 104);
        }
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
        id v54 = v53;
        id v55 = 1107LL;
        goto LABEL_63;
      }
    }
}

  -[NSPConfigurationStats setPromotedContentEnabled:](v15, "setPromotedContentEnabled:", 1LL);
  unsigned int v13 = v15;
  if ((v12 & 0x800000) == 0)
  {
LABEL_35:
    if ((v12 & 0x1000000) == 0) {
      goto LABEL_36;
    }
LABEL_62:
    -[NSPConfigurationStats setPasswordManagerIconFetchEnabled:](v15, "setPasswordManagerIconFetchEnabled:", 1LL);
    unsigned int v13 = v15;
    if ((v12 & 0x2000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

LABEL_94:
    if (v31) {
      ++*(void *)(v31 + 56);
    }
    goto LABEL_62;
  }

  __int16 v27 = nplog_obj(v9, v10, v11);
  id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    if (!v21) {
      uint64_t v21 = "none";
    }
    id v29 = sub_100044D90(v8);
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    *(_DWORD *)__int128 buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = (unsigned __int16)v6;
    *(_WORD *)double v62 = 2080;
    *(void *)&v62[2] = v21;
    uint64_t v63 = 2112;
    uint64_t v64 = v22;
    id v65 = 2112;
    id v66 = v30;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Received epoch (%u) from %s (%@) for %@ agent",  buf,  0x26u);
  }

  id v31 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
  [(id)v31 reportEpoch:(unsigned __int16)v6];
LABEL_28:
  unint64_t v32 = v60;
LABEL_65:
}

LABEL_73:
    goto LABEL_65;
  }

  id v23 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));

  if (!v23)
  {
    __int128 v87 = nplog_obj(v24, v25, v26);
    __int128 v85 = (os_log_s *)objc_claimAutoreleasedReturnValue(v87);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v146 = "-[NSPQuicProxyPath setupNetworkSpecificMultiHopProxyRegistrations:]";
      __int128 v86 = "%s called with null self.egressProxy";
      goto LABEL_72;
    }

    goto LABEL_73;
  }

  if (-[NSPProxyPath allowFallback](self, "allowFallback"))
  {
    v144 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopFallbackProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopFallbackProxyAgentUUID"));
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue(-[NSPQuicProxyPath quicProxyPathDelegate](self, "quicProxyPathDelegate"));
    v143 = (void *)objc_claimAutoreleasedReturnValue([v27 multiHopFallbackProxyConfigHash:self]);
  }

  else
  {
    v143 = 0LL;
    v144 = 0LL;
  }

  id v28 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath multiHopRegistration](self, "multiHopRegistration"));
  id v29 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  double v135 = (void *)v29;
  if (v29) {
    uint64_t v30 = *(void **)(v29 + 24);
  }
  else {
    uint64_t v30 = 0LL;
  }
  v134 = v30;
  id v133 = (void *)objc_claimAutoreleasedReturnValue([v134 proxyURL]);
  id v31 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  v132 = (void *)v31;
  if (v31) {
    unint64_t v32 = *(void **)(v31 + 24);
  }
  else {
    unint64_t v32 = 0LL;
  }
  v131 = v32;
  uint64_t v33 = objc_claimAutoreleasedReturnValue([v131 proxyURL]);
  uint64_t v34 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  v129 = (void *)v34;
  if (v34) {
    uint64_t v35 = *(void **)(v34 + 24);
  }
  else {
    uint64_t v35 = 0LL;
  }
  v128 = v35;
  uint64_t v36 = objc_claimAutoreleasedReturnValue([v128 proxyKeyInfos]);
  uint64_t v37 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  v126 = (void *)v37;
  if (v37) {
    id v38 = *(void **)(v37 + 24);
  }
  else {
    id v38 = 0LL;
  }
  v125 = v38;
  v142 = (void *)objc_claimAutoreleasedReturnValue([v125 proxyKeyInfos]);
  id v39 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  id v124 = (void *)v39;
  if (v39) {
    id v40 = *(void **)(v39 + 24);
  }
  else {
    id v40 = 0LL;
  }
  v123 = v40;
  v141 = (void *)objc_claimAutoreleasedReturnValue([v123 proxyVersion]);
  uint64_t v41 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  v122 = (void *)v41;
  if (v41) {
    uint64_t v42 = *(void **)(v41 + 24);
  }
  else {
    uint64_t v42 = 0LL;
  }
  id v121 = v42;
  v140 = (void *)objc_claimAutoreleasedReturnValue([v121 proxyVersion]);
  uint64_t v43 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  id v120 = (void *)v43;
  if (v43) {
    uint64_t v44 = *(void **)(v43 + 24);
  }
  else {
    uint64_t v44 = 0LL;
  }
  v119 = v44;
  id v139 = (void *)objc_claimAutoreleasedReturnValue([v119 allowedNextHops]);
  uint64_t v45 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  uint64_t v118 = (void *)v45;
  if (v45) {
    id v46 = *(void **)(v45 + 24);
  }
  else {
    id v46 = 0LL;
  }
  v117 = v46;
  v138 = (void *)objc_claimAutoreleasedReturnValue([v117 allowedNextHops]);
  id v47 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  id v116 = (void *)v47;
  if (v47) {
    uint64_t v48 = *(void **)(v47 + 24);
  }
  else {
    uint64_t v48 = 0LL;
  }
  v115 = v48;
  uint64_t v107 = [v115 supportsResumption];
  uint64_t v49 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  id v114 = (void *)v49;
  if (v49) {
    uint64_t v50 = *(void **)(v49 + 24);
  }
  else {
    uint64_t v50 = 0LL;
  }
  id v113 = v50;
  uint64_t v105 = [v113 supportsResumption];
  uint64_t v51 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  BOOL v112 = (void *)v51;
  if (v51) {
    uint64_t v52 = *(void **)(v51 + 24);
  }
  else {
    uint64_t v52 = 0LL;
  }
  v111 = v52;
  uint64_t v53 = [v111 algorithm];
  id v54 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  uint64_t v110 = (void *)v54;
  if (v54) {
    id v55 = *(void **)(v54 + 24);
  }
  else {
    id v55 = 0LL;
  }
  unint64_t v109 = v55;
  __int16 v56 = [v109 algorithm];
  v108 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  v106 = sub_10000C67C((uint64_t)v108);
  if (v106)
  {
    id v57 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
    v90 = (void *)v57;
    if (v57) {
      id v58 = *(void **)(v57 + 48);
    }
    else {
      id v58 = 0LL;
    }
    v137 = v58;
  }

  else
  {
    v137 = 0LL;
  }

  v104 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  uint64_t v103 = sub_10000C67C((uint64_t)v104);
  if (v103)
  {
    uint64_t v59 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
    v89 = (void *)v59;
    if (v59) {
      uint64_t v60 = *(void **)(v59 + 48);
    }
    else {
      uint64_t v60 = 0LL;
    }
    uint64_t v102 = v60;
  }

  else
  {
    uint64_t v102 = 0LL;
  }

  double v61 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  uint64_t v101 = (void *)v61;
  if (v61) {
    double v62 = *(void **)(v61 + 24);
  }
  else {
    double v62 = 0LL;
  }
  uint64_t v100 = v62;
  uint64_t v63 = objc_claimAutoreleasedReturnValue([v100 tokenChallenge]);
  uint64_t v64 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self, "egressProxy"));
  v99 = (void *)v64;
  if (v64) {
    id v65 = *(void **)(v64 + 24);
  }
  else {
    id v65 = 0LL;
  }
  uint64_t v98 = v65;
  id v66 = (void *)objc_claimAutoreleasedReturnValue([v98 tokenChallenge]);
  uint64_t v93 = -[NSPProxyPath allowFailOpen](self, "allowFailOpen");
  uint64_t v92 = -[NSPProxyPath geohashSharingEnabled](self, "geohashSharingEnabled");
  v97 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
  id v96 = (void *)objc_claimAutoreleasedReturnValue([v97 geohashOverride]);
  v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
  id v91 = [v95 dnsFilteringHintEnabled];
  uint64_t v67 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](self, "ingressProxy"));
  unint64_t v68 = (void *)v67;
  v136 = (void *)v28;
  id v130 = (void *)v33;
  id v127 = (void *)v36;
  if (v67) {
    unint64_t v69 = *(void **)(v67 + 24);
  }
  else {
    unint64_t v69 = 0LL;
  }
  uint64_t v94 = (void *)v63;
  id v70 = v63 != 0;
  id v71 = v56 == 2;
  id v72 = v53 == 2;
  id v73 = v69;
  id v74 = [v73 fallbackSupportsUDPProxying];
  uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath configEpoch](self, "configEpoch"));
  sub_100045CE0( (uint64_t)v136,  v133,  v130,  v127,  v142,  v141,  v140,  v139,  v138,  v107,  v105,  v72,  v71,  v137,  v102,  v70,  v66 != 0LL,  v144,  v93,  v92,  v96,  v91,  0LL,  0LL,  v143,  v74,  v75);

  if (v103)
  {
  }

  if (v106)
  {
  }

  unint64_t v76 = -[NSPProxyPath multiHopRegistered](self, "multiHopRegistered");
  unint64_t v77 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath multiHopRegistration](self, "multiHopRegistration"));
  if (v77)
  {
    uint64_t v78 = (void *)v77;
    uint64_t v79 = [*(id *)(v77 + 24) isRegistered];

    if (v76 != v79)
    {
LABEL_61:
      uint64_t v80 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath multiHopRegistration](self, "multiHopRegistration"));
      uint64_t v81 = (void *)v80;
      if (v80) {
        uint64_t v82 = [*(id *)(v80 + 24) isRegistered];
      }
      else {
        uint64_t v82 = 0LL;
      }
      -[NSPProxyPath setMultiHopRegistered:](self, "setMultiHopRegistered:", v82);

      id v83 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
      [v83 multiHopAgentRegistered:self];
    }
  }

  else if ((v76 & 1) != 0)
  {
    goto LABEL_61;
  }

LABEL_65:
}

  if (-[NSMutableArray count](v16, "count"))
  {
    v254 = v43;
    v269 = v13;
    v271 = v16;
    v266 = v15;
    v268 = v14;
    uint64_t v88 = v276;
    objc_opt_self(&OBJC_CLASS___NSPPrivacyProxyPolicySerialization);
    obja = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v302 = 0u;
    v303 = 0u;
    v304 = 0u;
    v305 = 0u;
    v277 = v88;
    v89 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v277,  "countByEnumeratingWithState:objects:count:",  &v302,  buf,  16LL);
    if (v89)
    {
      v90 = v89;
      id v91 = *(void *)v303;
      do
      {
        for (j = 0LL; j != v90; j = (char *)j + 1)
        {
          if (*(void *)v303 != v91) {
            objc_enumerationMutation(v277);
          }
          uint64_t v93 = *(void *)(*((void *)&v302 + 1) + 8LL * (void)j);
          uint64_t v94 = objc_alloc(&OBJC_CLASS___NEPolicy);
          v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyBootstrapDNSAgent dnsAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyBootstrapDNSAgent,  "dnsAgentUUID"));
          id v96 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v95));
          v97 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v93));
          *(void *)&v307 = v97;
          uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          *((void *)&v307 + 1) = v98;
          v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v307,  2LL));
          uint64_t v100 = [v94 initWithOrder:420 result:v96 conditions:v99];

          -[NSMutableArray addObject:](obja, "addObject:", v100);
        }

        v90 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v277,  "countByEnumeratingWithState:objects:count:",  &v302,  buf,  16LL);
      }

      while (v90);
    }

    -[NSMutableArray addObjectsFromArray:](v271, "addObjectsFromArray:", obja);
    uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
    uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition localNetworks](&OBJC_CLASS___NEPolicyCondition, "localNetworks"));
    v300[0] = v102;
    uint64_t v103 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v300[1] = v103;
    v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v300, 2LL));
    uint64_t v105 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 410LL, v101, 0LL, 0LL, 0LL, v104, 1);
    v106 = objc_claimAutoreleasedReturnValue(v105);

    v253 = (void *)v106;
    -[NSMutableArray addObject:](v271, "addObject:", v106);
    uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
    v108 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", @"local"));
    v299[0] = v108;
    unint64_t v109 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddressEmpty]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddressEmpty"));
    v299[1] = v109;
    uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v299[2] = v110;
    v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v299, 3LL));
    BOOL v112 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 410LL, v107, 0LL, 0LL, 0LL, v111, 1);
    id v113 = objc_claimAutoreleasedReturnValue(v112);

    v252 = (void *)v113;
    -[NSMutableArray addObject:](v271, "addObject:", v113);
    id v114 = objc_alloc(&OBJC_CLASS___NEPolicy);
    v115 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
    id v116 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v298[0] = v116;
    v117 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"Cellular",  &stru_1001009D0));
    v298[1] = v117;
    uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v298, 2LL));
    v119 = [v114 initWithOrder:411 result:v115 conditions:v118];

    v251 = v119;
    -[NSMutableArray addObject:](v271, "addObject:", v119);
    id v120 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v121 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
    v122 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v297 = v122;
    v123 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v297, 1LL));
    id v124 = [v120 initWithOrder:490 result:v121 conditions:v123];

    v250 = v124;
    -[NSMutableArray addObject:](v271, "addObject:", v124);
    v125 = objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
    v126 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v127 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v125));
    v128 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v296 = v128;
    v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v296, 1LL));
    id v130 = [v126 initWithOrder:550 result:v127 conditions:v129];

    v260 = v130;
    -[NSMutableArray addObject:](v271, "addObject:", v130);
    v131 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  0LL));
    v278 = (id)v125;
    [v131 setNetworkAgentUUID:v125];
    v259 = v131;
    v295[0] = v131;
    v132 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  1LL,  2LL));
    v295[1] = v132;
    id v133 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  1LL,  3LL));
    v295[2] = v133;
    v134 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  1LL,  6LL));
    v295[3] = v134;
    double v135 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  1LL,  4LL));
    v295[4] = v135;
    v136 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v295, 5LL));

    v137 = objc_alloc(&OBJC_CLASS___NEPolicy);
    v258 = (void *)v136;
    v138 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v136));
    id v139 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v294 = v139;
    v140 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v294, 1LL));
    v141 = [v137 initWithOrder:551 result:v138 conditions:v140];

    p_superclass = (__objc2_class **)(&OBJC_CLASS___NSPAuxiliaryAuthInfo + 8);
    -[NSMutableArray addObject:](v271, "addObject:", v141);
    unsigned int v13 = v269;
    v143 = v254 ^ 1;
    if (!v269) {
      v143 = 1;
    }
    if ((v143 & 1) == 0)
    {
      v249 = v141;
      v144 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v293 = v144;
      v145 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v293, 1LL));

      v146 = v278;
      v255 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  7LL,  v278));
      v147 = (void *)objc_claimAutoreleasedReturnValue([v269 controlUnit]);
      v148 = [v147 unsignedIntValue];
      v247 = (void *)v145;
      if (a4)
      {

        [v255 setControlUnit:(1 << ((_BYTE)v148 - 1)) | 0x80000000];
        if ((a2 & 0x20000) != 0)
        {
          v149 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v145);
          v150 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 17LL));
          -[NSMutableArray addObject:](v149, "addObject:", v150);

          v151 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition schemeUsingPort:]( &OBJC_CLASS___NEPolicyCondition,  "schemeUsingPort:",  53LL));
          -[NSMutableArray addObject:](v149, "addObject:", v151);

          v152 = objc_alloc(&OBJC_CLASS___NEPolicy);
          v292 = v255;
          v153 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v292,  1LL));
          v154 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v153));
          v155 = [v152 initWithOrder:530 result:v154 conditions:v149];

          -[NSMutableArray addObject:](v271, "addObject:", v155);
          v156 = objc_alloc(&OBJC_CLASS___NEPolicy);
          v157 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 535LL));
          v158 = [v156 initWithOrder:531 result:v157 conditions:v149];

          v146 = v278;
          -[NSMutableArray addObject:](v271, "addObject:", v158);
        }

        v159 = objc_alloc(&OBJC_CLASS___NEPolicy);
        v291 = v255;
        v160 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v291,  1LL));
        v161 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v160));
        v162 = [v159 initWithOrder:532 result:v161 conditions:v145];

        v163 = v271;
        -[NSMutableArray addObject:](v271, "addObject:", v162);
        v164 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  7LL,  v146));
        [v164 setControlUnit:0xFFFFFFFLL];
        v165 = objc_alloc(&OBJC_CLASS___NEPolicy);
        v290 = v164;
        v166 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v290,  1LL));
        v167 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v166));
        v168 = [v165 initWithOrder:533 result:v167 conditions:v247];

        v145 = (uint64_t)v247;
        v146 = v278;
        -[NSMutableArray addObject:](v271, "addObject:", v168);
      }

      else
      {
        [v255 setControlUnit:v148];

        v175 = objc_alloc(&OBJC_CLASS___NEPolicy);
        v289 = v255;
        v176 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v289,  1LL));
        v177 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v176));
        v162 = [v175 initWithOrder:530 result:v177 conditions:v145];

        v163 = v271;
        -[NSMutableArray addObject:](v271, "addObject:", v162);
      }

      v262 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  6LL,  v146));
      [v262 setNetworkAgentUUID:v146];
      v178 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v288 = v262;
      v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v288, 1LL));
      v180 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v179));
      v256 = [v178 initWithOrder:534 result:v180 conditions:v145];

      -[NSMutableArray addObject:](v163, "addObject:", v256);
      v181 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allowsUnsafeSocketAccess]( &OBJC_CLASS___NEPolicyCondition,  "allowsUnsafeSocketAccess"));
      [v181 setNegative:1];
      v182 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v183 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 540LL));
      v184 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v287[0] = v184;
      v185 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition usesModernNetworkAPI]( &OBJC_CLASS___NEPolicyCondition,  "usesModernNetworkAPI"));
      v287[1] = v185;
      v287[2] = v181;
      v186 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v287, 3LL));
      v187 = [v182 initWithOrder:520 result:v183 conditions:v186];

      -[NSMutableArray addObject:](v163, "addObject:", v187);
      v188 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v189 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 540LL));
      v190 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v286[0] = v190;
      v191 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.networkserviceproxy.flowdivert"));
      v286[1] = v191;
      v192 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v286, 2LL));
      v193 = [v188 initWithOrder:520 result:v189 conditions:v192];

      -[NSMutableArray addObject:](v163, "addObject:", v193);
      p_superclass = &OBJC_CLASS___NSPAuxiliaryAuthInfo.superclass;
      v141 = v249;
      unsigned int v13 = v269;
    }

    v194 = +[NPUtilities machoUUIDFromPID:](&OBJC_CLASS___NPUtilities, "machoUUIDFromPID:", getpid());
    v195 = objc_claimAutoreleasedReturnValue(v194);
    v263 = (void *)v195;
    if (v195)
    {
      v198 = v195;
      v199 = nplog_obj(v195, v196, v197);
      v200 = (os_log_s *)objc_claimAutoreleasedReturnValue(v199);
      if (os_log_type_enabled(v200, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v264;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v198;
        _os_log_impl( (void *)&_mh_execute_header,  v200,  OS_LOG_TYPE_INFO,  "%@ adding self removal policy using uuid: %@",  buf,  0x16u);
      }

      v201 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v202 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
      v203 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v285[0] = v203;
      v204 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v198));
      v285[1] = v204;
      v205 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
      v285[2] = v205;
      v206 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v285, 3LL));
      v207 = [v201 initWithOrder:400 result:v202 conditions:v206];

      if (!v207)
      {
        v240 = nplog_obj(v208, v209, v210);
        v214 = (os_log_s *)objc_claimAutoreleasedReturnValue(v240);
        uint64_t v15 = v266;
        int v14 = v268;
        if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v264;
          _os_log_error_impl( (void *)&_mh_execute_header,  v214,  OS_LOG_TYPE_ERROR,  "%@ failed to create self removal policy",  buf,  0xCu);
        }

        v239 = 0;
LABEL_135:

        uint64_t v16 = v271;
        if (v239) {
          goto LABEL_136;
        }
LABEL_141:
        v241 = 0LL;
        goto LABEL_142;
      }

      -[NSMutableArray addObject:](v271, "addObject:", v207);
    }

    v211 = v273;
    v212 = v272;
    v213 = objc_opt_self(p_superclass + 459);
    if ([v211 count] || objc_msgSend(v212, "count"))
    {
      v214 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v307 = 0u;
      v308 = 0u;
      v309 = 0u;
      v310 = 0u;
      v215 = v211;
      v216 = [v215 countByEnumeratingWithState:&v307 objects:buf count:16];
      if (v216)
      {
        v217 = v216;
        v218 = *(void *)v308;
        do
        {
          for (k = 0LL; k != v217; k = (char *)k + 1)
          {
            if (*(void *)v308 != v218) {
              objc_enumerationMutation(v215);
            }
            sub_100081428(v213, *(void **)(*((void *)&v307 + 1) + 8LL * (void)k), 0LL, 0, v214);
          }

          v217 = [v215 countByEnumeratingWithState:&v307 objects:buf count:16];
        }

        while (v217);
      }

      v283 = 0u;
      v284 = 0u;
      v281 = 0u;
      v282 = 0u;
      v220 = v212;
      v221 = [v220 countByEnumeratingWithState:&v281 objects:&v302 count:16];
      if (v221)
      {
        v222 = v221;
        v223 = *(void *)v282;
        do
        {
          for (m = 0LL; m != v222; m = (char *)m + 1)
          {
            if (*(void *)v282 != v223) {
              objc_enumerationMutation(v220);
            }
            sub_100081428(v213, 0LL, *(void **)(*((void *)&v281 + 1) + 8LL * (void)m), 0, v214);
          }

          v222 = [v220 countByEnumeratingWithState:&v281 objects:&v302 count:16];
        }

        while (v222);
      }

      p_superclass = &OBJC_CLASS___NSPAuxiliaryAuthInfo.superclass;
    }

    else
    {
      v214 = 0LL;
    }

    uint64_t v15 = v266;
    int v14 = v268;
    if (v214) {
      -[NSMutableArray addObjectsFromArray:](v271, "addObjectsFromArray:", v214);
    }
    v225 = objc_opt_self(p_superclass + 459);
    v226 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    sub_100081428(v225, @"com.apple.WebSheet", 0LL, 1, v226);
    sub_100081428(v225, 0LL, @"/usr/libexec/captiveagent", 1, v226);
    sub_100081428(v225, 0LL, @"/usr/libexec/configd", 1, v226);
    if (v226) {
      -[NSMutableArray addObjectsFromArray:](v271, "addObjectsFromArray:", v226);
    }
    if ((a2 & 0x20000) != 0)
    {
      objc_opt_self(p_superclass + 459);
      v275 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v248 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowLocalAddressEmpty]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddressEmpty"));
      [v248 setNegative:1];
      v246 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition clientFlags:](&OBJC_CLASS___NEPolicyCondition, "clientFlags:", 0x800000LL));
      v227 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"0.0.0.0",  @"1024"));
      v228 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"255.255.255.255",  @"65535"));
      v257 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddressStart:end:",  v227,  v228));

      v229 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"::",  @"1024"));
      v230 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF",  @"65535"));
      v245 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddressStart:end:",  v229,  v230));

      v231 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
      *(void *)__int128 buf = v248;
      *(void *)&uint8_t buf[8] = v257;
      *(void *)&uint8_t buf[16] = v246;
      v232 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", buf, 3LL));
      v233 = sub_10008026C((uint64_t)(p_superclass + 459), 410LL, v231, 0LL, 0LL, 17LL, v232, 0);
      v234 = (void *)objc_claimAutoreleasedReturnValue(v233);
      -[NSMutableArray addObject:](v275, "addObject:", v234);

      v235 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
      *(void *)&v302 = v248;
      *((void *)&v302 + 1) = v245;
      *(void *)&v303 = v246;
      v236 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v302, 3LL));
      v237 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  410LL,  v235,  0LL,  0LL,  17LL,  v236,  0);
      v238 = (void *)objc_claimAutoreleasedReturnValue(v237);
      -[NSMutableArray addObject:](v275, "addObject:", v238);

      if (v275) {
        -[NSMutableArray addObjectsFromArray:](v271, "addObjectsFromArray:", v275);
      }
      sub_100081428(v264, @"com.apple.softwareupdated", 0LL, 1, v271);
      sub_100081428(v264, @"com.apple.mobileassetd", 0LL, 1, v271);
      sub_100081428(v264, @"com.apple.apsd", 0LL, 1, v271);

      int v14 = v268;
      unsigned int v13 = v269;
      uint64_t v15 = v266;
    }

    v239 = 1;
    goto LABEL_135;
  }

  if (-[NSPPrivateAccessTokenChallenge typeRequiresOriginName](v16, "typeRequiresOriginName")
    && !objc_getProperty(v16, v99, 56LL, 1))
  {
    BOOL v112 = nplog_obj(0LL, v99, v100);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)__int128 buf = 0;
    uint32_t v19 = "Origin name is required";
    goto LABEL_8;
  }

  objc_setProperty_atomic(v16, v99, v7, 16LL);
  if (os_variant_allows_internal_security_policies("com.apple.networkserviceproxy"))
  {
    uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge issuerName](v16, "issuerName"));
    uint64_t v102 = [v101 containsString:@";"];

    if (v102)
    {
      uint64_t v103 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge issuerName](v16, "issuerName"));
      v104 = (void *)objc_claimAutoreleasedReturnValue([v103 componentsSeparatedByString:@";"]);
      self = (NSPPrivateAccessTokenChallenge *)objc_claimAutoreleasedReturnValue([v104 firstObject]);

      LODWORD(v103) = -[NSPPrivateAccessTokenChallenge tokenType](v16, "tokenType");
      uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge redemptionNonce](v16, "redemptionNonce"));
      id Property = objc_getProperty(v16, v106, 56LL, 1);
      v108 = sub_1000AA3D0(v103, self, v105, Property);
      unint64_t v109 = (void *)objc_claimAutoreleasedReturnValue(v108);
      objc_setProperty_atomic(v16, v110, v109, 16LL);

      goto LABEL_17;
    }
  }

LABEL_39:
    uint64_t v52 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath singleHopRegistration](self, "singleHopRegistration"));
    uint64_t v53 = (void *)v52;
    if (v52) {
      id v54 = [*(id *)(v52 + 24) isRegistered];
    }
    else {
      id v54 = 0LL;
    }
    -[NSPProxyPath setSingleHopRegistered:](self, "setSingleHopRegistered:", v54);

    id v55 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath delegate](self, "delegate"));
    [v55 singleHopAgentRegistered:self];

    goto LABEL_42;
  }

  uint64_t v49 = nplog_obj(v4, v5, v6);
  uint64_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue(v49);
  if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    unint64_t v76 = "-[NSPQuicProxyPath resetSingleHopProxyAgent]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_FAULT,  "%s called with null self.ingressProxy",  buf,  0xCu);
  }
}
}

    uint64_t v16 = 0LL;
    goto LABEL_40;
  }

    uint64_t v102 = 0LL;
LABEL_40:

    goto LABEL_41;
  }

  id v116 = nplog_obj(0LL, v5, v6);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(v116);
  if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    v131 = "+[NSPCoreData normalizeData:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v11,  OS_LOG_TYPE_FAULT,  "%s called with null normalizer",  buf,  0xCu);
  }

  uint64_t v102 = 0LL;
LABEL_41:

  return v102;
}

  uint64_t v49 = sub_10008040C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 0LL, 0LL, 6LL);
  uint64_t v50 = objc_claimAutoreleasedReturnValue(v49);
  if (!v50)
  {
    v173 = nplog_obj(0LL, v51, v52);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v173);
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v264;
    v170 = "%@ failed to create App TCP policies";
    goto LABEL_98;
  }

  uint64_t v53 = (void *)v50;
  -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v50);
  id v54 = sub_10008040C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 0LL, 0LL, 17LL);
  id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v54);

  if (!v55)
  {
    v174 = nplog_obj(v56, v57, v58);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v174);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v264;
      v170 = "%@ failed to create App UDP policies";
      goto LABEL_98;
    }
  }

  sub_1000937C0((id *)&v17->super.isa);
  if (v17)
  {
LABEL_41:
    session = v17->_session;
    goto LABEL_42;
  }

  session = 0LL;
LABEL_42:
  unint64_t v76 = session;
  unint64_t v77 = -[NEPolicySession apply](v76, "apply");

  if (v77)
  {
    uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    [v78 commit];

    uint64_t v82 = nplog_obj(v79, v80, v81);
    id v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 138412290;
      unint64_t v109 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_INFO,  "%@ sucessfully applied all the policies",  buf,  0xCu);
    }
  }

  objc_sync_exit(v17);

  return v77;
}

LABEL_72:
}

        uint64_t v75 = nplog_obj(type, v45, v46);
        unint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue(v75);
        if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_INFO,  "Failed to find a supported challenge",  (uint8_t *)buf,  2u);
        }

        sub_10006FFB4(v4, 1004LL, @"Invalid challenge");
        goto LABEL_81;
      }
    }

    else
    {
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
      if ((_DWORD)v14) {
        goto LABEL_21;
      }
    }

    id v23 = v20;
    goto LABEL_30;
  }

LABEL_26:
      uint64_t v41 = 0;
      goto LABEL_27;
    }
  }

  else
  {
  }

  id v40 = nplog_obj(v33, v34, v35);
  uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
  uint64_t v41 = 1;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    uint64_t v42 = objc_claimAutoreleasedReturnValue(-[NSPCandidateProxyPath ingressProxy](self, "ingressProxy"));
    uint64_t v43 = (void *)v42;
    if (v42) {
      uint64_t v44 = *(void **)(v42 + 24);
    }
    else {
      uint64_t v44 = 0LL;
    }
    uint64_t v45 = v44;
    id v46 = (void *)objc_claimAutoreleasedReturnValue([v45 vendor]);
    id v47 = objc_claimAutoreleasedReturnValue(-[NSPCandidateProxyPath egressProxy](self, "egressProxy"));
    uint64_t v48 = (void *)v47;
    if (v47) {
      uint64_t v49 = *(void **)(v47 + 24);
    }
    else {
      uint64_t v49 = 0LL;
    }
    uint64_t v50 = v49;
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v50 vendor]);
    id v54 = 138412546;
    id v55 = (uint64_t)v46;
    __int16 v56 = 2112;
    id v57 = v51;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "proxy path [%@:%@] is ready",  (uint8_t *)&v54,  0x16u);
  }

  id v29 = 0;
LABEL_27:

  return v29;
}

    uint64_t v15 = 0LL;
LABEL_27:

    goto LABEL_28;
  }

  uint64_t v15 = 0LL;
LABEL_28:

  return v15;
}

            uint32_t v19 = (char *)v19 + 1;
          }

          while (v17 != v19);
          uint64_t v17 = [v15 countByEnumeratingWithState:&v38 objects:v46 count:16];
          if (!v17)
          {
LABEL_28:

            uint64_t v7 = v36;
            uint64_t v5 = v37;
            goto LABEL_29;
          }
        }
      }

      id v11 = (char *)v11 + 1;
    }

    while (v9 != v11);
    unsigned int v9 = [v7 countByEnumeratingWithState:&v42 objects:v47 count:16];
  }

  while (v9);
LABEL_9:

  int v14 = (NSMutableArray *)v7;
LABEL_29:

  return v14;
}

          uint64_t v34 = nplog_obj(v31, v32, v33);
          uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v36 = *(void **)(a1 + 40);
            if (v36) {
              uint64_t v36 = (void *)v36[8];
            }
            uint64_t v37 = v36;
            id v38 = [v37 status];
            id v39 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) interfaceName]);
            id v40 = *(void **)(a1 + 40);
            __int16 v56 = (void *)v39;
            if (v40) {
              id v40 = (void *)v40[8];
            }
            uint64_t v41 = v40;
            uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 interface]);
            uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 interfaceName]);
            uint64_t v44 = *(void **)(a1 + 40);
            id v55 = v41;
            if (v44) {
              uint64_t v44 = (void *)v44[9];
            }
            uint64_t v45 = v44;
            id v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v45,  1LL,  2LL));
            id v47 = *(void **)(a1 + 40);
            uint64_t v48 = v38;
            if (v47) {
              id v47 = (void *)v47[10];
            }
            uint64_t v49 = v47;
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v49,  1LL,  2LL));
            *(_DWORD *)__int128 buf = 134219010;
            uint64_t v59 = v48;
            uint64_t v60 = 2112;
            double v61 = v56;
            double v62 = 2112;
            uint64_t v63 = v43;
            uint64_t v64 = 2112;
            id v65 = v46;
            id v66 = 2112;
            uint64_t v67 = v50;
            _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "ignoring DNS bad message error, path status %ld reporting interface %@ primary interface %@ last path unsa tisfied date %@, last interface change date %@",  buf,  0x34u);
          }

          goto LABEL_37;
        }
}

LABEL_27:
  return v41;
}

          sub_10003F878((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v14);
          uint64_t v20 = 0LL;
LABEL_28:

          goto LABEL_29;
        }
      }

      __int16 v27 = sub_1000ABB98((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v23, v7);
      if (!v27)
      {
        uint64_t v30 = nplog_obj(v27, v28, v29);
        id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = 138412290;
          uint64_t v42 = (const char *)v14;
          unint64_t v32 = "Cached token from keychain for %@ has non-matching challenege, flushing tokens";
LABEL_26:
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&v41, 0xCu);
          goto LABEL_27;
        }

        goto LABEL_27;
      }
    }

          goto LABEL_34;
        }

    id v28 = 0LL;
    goto LABEL_28;
  }

  uint64_t v17 = [v6 count];
  uint64_t v18 = [v10 count];
  if (v17 != v18)
  {
    unsigned __int8 v24 = nplog_obj(v18, v19, v20);
    unsigned int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = 138412546;
      uint64_t v35 = v6;
      uint64_t v36 = 2112;
      uint64_t v37 = v10;
      char v25 = "Incompatible version strings (%@ vs %@)";
      uint64_t v26 = v13;
      __int16 v27 = 22;
LABEL_26:
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v25, (uint8_t *)&v34, v27);
      goto LABEL_27;
    }

    goto LABEL_27;
  }

  if (![v6 count])
  {
LABEL_15:
    uint64_t v15 = objc_alloc(&OBJC_CLASS___NSNumber);
    uint64_t v16 = 0LL;
LABEL_22:
    id v28 = -[NSNumber initWithInt:](v15, "initWithInt:", v16);
    goto LABEL_28;
  }

  uint64_t v21 = 0LL;
  while (1)
  {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndex:v21]);
    id v23 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndex:v21]);

    if (v22 != v23) {
      break;
    }
  }

  id v29 = objc_alloc(&OBJC_CLASS___NSNumber);
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndex:v21]);
  id v31 = [v30 intValue];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndex:v21]);
  id v28 = -[NSNumber initWithInt:](v29, "initWithInt:", v31 - [v32 intValue]);

LABEL_28:
  return v28;
}

    goto LABEL_28;
  }

  uint64_t v51 = nplog_obj(0LL, v2, v3);
  unsigned __int8 v24 = (void *)objc_claimAutoreleasedReturnValue(v51);
  if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int16 v56 = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v24, OS_LOG_TYPE_FAULT, "[super init] failed", v56, 2u);
  }

void sub_10001EC78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, id location, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_10001ECD0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue(v9);
  id v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_10001EE04;
  v17[3] = &unk_1000F9A08;
  uint64_t v23 = *(void *)(a1 + 48);
  objc_copyWeak(&v25, (id *)(a1 + 64));
  id v18 = v9;
  id v19 = v7;
  id v20 = v8;
  id v21 = *(id *)(a1 + 32);
  id v12 = *(id *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 56);
  id v22 = v12;
  uint64_t v24 = v13;
  id v14 = v8;
  id v15 = v7;
  id v16 = v9;
  dispatch_async(v11, v17);

  objc_destroyWeak(&v25);
}

void sub_10001EE04(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 72) + 8LL);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;

  uint64_t WeakRetained = (uint64_t)objc_loadWeakRetained((id *)(a1 + 88));
  id v7 = (void *)WeakRetained;
  if (WeakRetained)
  {
    if (!*(void *)(a1 + 32))
    {
      if (*(void *)(a1 + 40))
      {
        uint64_t v17 = *(void *)(a1 + 48);
        uint64_t v18 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
        uint64_t WeakRetained = objc_opt_isKindOfClass(v17, v18);
        if ((WeakRetained & 1) != 0)
        {
          uint64_t WeakRetained = (uint64_t)[*(id *)(a1 + 48) statusCode];
          if (WeakRetained == 200)
          {
            id v19 = [*(id *)(a1 + 40) copy];
            [v7 setDomainFilter:v19];
          }
        }
      }
    }

    uint64_t v8 = nplog_obj(WeakRetained, v5, v6);
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 domainFilter]);
      id v11 = @"successful";
      uint64_t v12 = *(void *)(a1 + 56);
      if (!v10) {
        id v11 = @"failed";
      }
      int v20 = 138412546;
      id v21 = v11;
      __int16 v22 = 2112;
      uint64_t v23 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Received %@ response for %@",  (uint8_t *)&v20,  0x16u);
    }

    uint64_t v13 = *(void *)(a1 + 64);
    if (v13)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v7 domainFilter]);
      (*(void (**)(uint64_t, BOOL))(v13 + 16))(v13, v14 != 0LL);
    }
  }

  uint64_t v15 = *(void *)(*(void *)(a1 + 80) + 8LL);
  id v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = 0LL;
}

void sub_10001F910(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 32), a2);
  }
}

void sub_10001F920(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_DWORD *)(a1 + 12);
  uint64_t v6 = 30LL;
  if (v5 > 19)
  {
    if (v5 != 20)
    {
      if (v5 == 100) {
        goto LABEL_12;
      }
      if (v5 != 50) {
        goto LABEL_9;
      }
    }

id *sub_10001FA18(id *a1, void *a2, void *a3, int a4, void *a5, char a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)&OBJC_CLASS___NSPProber;
    id v14 = (id *)objc_msgSendSuper2(&v16, "init");
    a1 = v14;
    if (v14)
    {
      objc_storeWeak(v14 + 2, v11);
      objc_storeStrong(a1 + 3, a3);
      *((_DWORD *)a1 + 3) = a4;
      *((_BYTE *)a1 + 11) = a6;
      objc_storeStrong(a1 + 11, a5);
    }
  }

  return a1;
}

void sub_10001FAE0(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
    id v3 = v2;
    if (*(_BYTE *)(a1 + 11))
    {
      objc_msgSend(v2, "set_sourceApplicationSecondaryIdentifier:", @"com.apple.nsp.proxyAgentProbe");
    }

    else
    {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 _socketStreamProperties]);
      if (v4)
      {
        int v5 = (void *)objc_claimAutoreleasedReturnValue([v3 _socketStreamProperties]);
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v5));
      }

      else
      {
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      }

      [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
      objc_msgSend(v3, "set_socketStreamProperties:", v6);
    }

    uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
    uint64_t v8 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v7;

    uint64_t v10 = NPGetInternalQueue(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [*(id *)(a1 + 48) setUnderlyingQueue:v11];

    uint64_t v12 = objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v3,  0LL,  *(void *)(a1 + 48)));
    id v13 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = v12;

    [*(id *)(a1 + 32) setSessionDescription:@"probe"];
    id v14 = *(void **)(a1 + 80);
    if (v14)
    {
      id v15 = [v14 timeIntervalSinceNow];
      if ((unint64_t)v17)
      {
        sub_10001FCA8(a1, (unint64_t)v17, v16);
      }

      else
      {
        uint64_t v18 = NPGetInternalQueue(v15);
        id v19 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v18);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10001FF88;
        block[3] = &unk_1000F9450;
        void block[4] = a1;
        dispatch_async(v19, block);
      }
    }
  }

void sub_10001FCA8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2;
  int v5 = *(dispatch_source_s **)(a1 + 56);
  if (v5)
  {
    dispatch_source_cancel(v5);
    uint64_t v6 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;
  }

  *(_BYTE *)(a1 + 9) = 1;
  if (!v3)
  {
    unint64_t v7 = *(void *)(a1 + 64);
    if (v7 < 8)
    {
      int v11 = dword_1000C3770[v7];
      int v5 = (dispatch_source_s *)arc4random_uniform(6u);
      unsigned int v10 = (_DWORD)v5 + v11;
    }

    else
    {
      uint64_t v8 = nplog_obj(v5, a2, a3);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v27 = *(void *)(a1 + 24);
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v31 = v27;
        __int16 v32 = 1024;
        LODWORD(v33) = 8;
        _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Probe[%@] failed %u attempts",  buf,  0x12u);
      }

      int v5 = (dispatch_source_s *)arc4random_uniform(6u);
      unsigned int v10 = (_DWORD)v5 + 1800;
    }

    unint64_t v3 = v10;
    ++*(void *)(a1 + 64);
  }

  uint64_t v12 = nplog_obj(v5, a2, a3);
  id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v31 = v14;
    __int16 v32 = 2048;
    unint64_t v33 = v3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Retry Probe[%@] after %lu seconds", buf, 0x16u);
  }

  id inited = objc_initWeak((id *)buf, (id)a1);
  uint64_t v16 = NPGetInternalQueue(inited);
  double v17 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v16);
  dispatch_source_t v18 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v17);
  id v19 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v18;

  if (*(void *)(a1 + 56))
  {
    int v20 = (dispatch_source_s *)*(id *)(a1 + 56);
    dispatch_time_t v21 = dispatch_time(0x8000000000000000LL, 1000000000 * v3);
    dispatch_source_set_timer(v20, v21, 0xFFFFFFFFFFFFFFFFLL, 0LL);

    __int16 v22 = *(void **)(a1 + 56);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100020674;
    handler[3] = &unk_1000F97C0;
    uint64_t v23 = v22;
    objc_copyWeak(&v29, (id *)buf);
    dispatch_source_set_event_handler(v23, handler);

    dispatch_resume(*(dispatch_object_t *)(a1 + 56));
    objc_destroyWeak(&v29);
  }

  uint64_t v24 = objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceNow:", (double)v3));
  id v25 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v24;

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
  [WeakRetained setUserEventAgentProberParameters];

  objc_destroyWeak((id *)buf);
}

void sub_10001FF6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10001FF88(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    *(_BYTE *)(v2 + 9) = 0;
  }
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_10000CED4;
  v5[4] = sub_10000CEE4;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.setupProbeTimerFired");
  uint64_t v3 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100020064;
  v4[3] = &unk_1000F98B0;
  v4[4] = v5;
  sub_100020078(v3, v4);
  _Block_object_dispose(v5, 8);
}

void sub_10002004C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100020064(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_100020078(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    id inited = objc_initWeak(&location, (id)a1);
    if (*(_BYTE *)(a1 + 10))
    {
      uint64_t v7 = nplog_obj(inited, v5, v6);
      id WeakRetained = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(WeakRetained, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(void **)(a1 + 24);
        *(_DWORD *)__int128 buf = 138412290;
        id v45 = v9;
        _os_log_error_impl( (void *)&_mh_execute_header,  WeakRetained,  OS_LOG_TYPE_ERROR,  "previous probe[%@] is already pending",  buf,  0xCu);
      }
    }

    else
    {
      id v10 = *(id *)(a1 + 88);
      BOOL v11 = [v10 status] == (id)1;

      if (v11)
      {
        *(_BYTE *)(a1 + 10) = 1;
        id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"http://netcts.cdn-apple.com"));
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableURLRequest requestWithURL:cachePolicy:timeoutInterval:]( &OBJC_CLASS___NSMutableURLRequest,  "requestWithURL:cachePolicy:timeoutInterval:",  v15,  4LL,  (double)*(unint64_t *)(a1 + 72)));
        id v17 = *(id *)(a1 + 88);
        dispatch_source_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 interface]);
        id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 interfaceName]);
        [v16 setBoundInterfaceIdentifier:v19];

        uint64_t v23 = nplog_obj(v20, v21, v22);
        uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          id v39 = v15;
          id v25 = *(id *)(a1 + 24);
          uint64_t v26 = *(void *)(a1 + 64);
          id v27 = *(id *)(a1 + 88);
          id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 interface]);
          id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 interfaceName]);
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities stringFromLinkQualityValue:]( &OBJC_CLASS___NPUtilities,  "stringFromLinkQualityValue:",  *(unsigned int *)(a1 + 12)));
          *(_DWORD *)__int128 buf = 138413058;
          id v45 = v25;
          __int16 v46 = 2048;
          uint64_t v47 = v26 + 1;
          __int16 v48 = 2112;
          uint64_t v49 = v29;
          __int16 v50 = 2112;
          uint64_t v51 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "[%@] send probe[%lu] over %@ with link quality %@",  buf,  0x2Au);

          id v15 = v39;
        }

        id v31 = *(id *)(a1 + 32);
        v40[0] = _NSConcreteStackBlock;
        v40[1] = 3221225472LL;
        v40[2] = sub_100020CC8;
        v40[3] = &unk_1000F9A58;
        objc_copyWeak(&v42, &location);
        v40[4] = a1;
        uint64_t v41 = v3;
        uint64_t v32 = objc_claimAutoreleasedReturnValue([v31 dataTaskWithRequest:v16 completionHandler:v40]);
        unint64_t v33 = *(void **)(a1 + 40);
        *(void *)(a1 + 40) = v32;

        id v34 = *(id *)(a1 + 40);
        [v34 setDelegate:a1];

        id v35 = *(id *)(a1 + 40);
        [v35 resume];

        objc_destroyWeak(&v42);
        goto LABEL_13;
      }

      uint64_t v36 = nplog_obj(v12, v13, v14);
      uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        id v38 = *(void **)(a1 + 24);
        *(_DWORD *)__int128 buf = 138412290;
        id v45 = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "deferring probe[%@], path is not satisfied",  buf,  0xCu);
      }

      *(_BYTE *)(a1 + 9) = 1;
      id WeakRetained = (os_log_s *)objc_loadWeakRetained((id *)(a1 + 16));
      -[os_log_s setUserEventAgentProberParameters](WeakRetained, "setUserEventAgentProberParameters");
    }

    v3[2](v3);
LABEL_13:
    objc_destroyWeak(&location);
  }
}

void sub_10002042C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_100020588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 24);
      int v11 = 138412290;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Reset probe[%@] timer", (uint8_t *)&v11, 0xCu);
    }

    uint64_t v7 = *(dispatch_source_s **)(a1 + 56);
    if (v7)
    {
      dispatch_source_cancel(v7);
      uint64_t v8 = *(void **)(a1 + 56);
      *(void *)(a1 + 56) = 0LL;
    }

    *(_WORD *)(a1 + 9) = 0;
    uint64_t v9 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;

    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
    [WeakRetained setUserEventAgentProberParameters];
  }

void sub_100020674(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Probe retry timer fired", buf, 2u);
  }

  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[7]);
    uint64_t v8 = *(void **)(v7 + 56);
    *(void *)(v7 + 56) = 0LL;

    *(_BYTE *)(v7 + 9) = 0;
    *(void *)__int128 buf = 0LL;
    int v11 = buf;
    uint64_t v12 = 0x3032000000LL;
    uint64_t v13 = sub_10000CED4;
    uint64_t v14 = sub_10000CEE4;
    id v15 = (id)os_transaction_create("com.apple.networkserviceproxy.agentProbeTimerFired");
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_1000207A8;
    v9[3] = &unk_1000F98B0;
    v9[4] = buf;
    sub_100020078(v7, v9);
    _Block_object_dispose(buf, 8);
  }
}

void sub_100020790( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000207A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000207BC(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_10000CED4;
  v5[4] = sub_10000CEE4;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.probeFailedReport");
  uint64_t v2 = NPGetInternalQueue(v6);
  uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000208A0;
  v4[3] = &unk_1000F9428;
  v4[4] = a1;
  void v4[5] = v5;
  dispatch_async(v3, v4);

  _Block_object_dispose(v5, 8);
}

void sub_100020888( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000208A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained probeFailed:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_1000208FC(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_10000CED4;
  v5[4] = sub_10000CEE4;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.probeSuccessReport");
  uint64_t v2 = NPGetInternalQueue(v6);
  uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000209E0;
  v4[3] = &unk_1000F9428;
  v4[4] = a1;
  void v4[5] = v5;
  dispatch_async(v3, v4);

  _Block_object_dispose(v5, 8);
}

void sub_1000209C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000209E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained probeSuccess:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100020A3C(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_10000CED4;
  v5[4] = sub_10000CEE4;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.probeRedirected");
  uint64_t v2 = NPGetInternalQueue(v6);
  uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100020B20;
  v4[3] = &unk_1000F9428;
  v4[4] = a1;
  void v4[5] = v5;
  dispatch_async(v3, v4);

  _Block_object_dispose(v5, 8);
}

void sub_100020B08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100020B20(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained probeRedirected:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100020B7C(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = v7;
  v7[2] = 0x3032000000LL;
  v7[3] = sub_10000CED4;
  void v7[4] = sub_10000CEE4;
  id v8 = (id)os_transaction_create("com.apple.networkserviceproxy.probeServerError");
  uint64_t v4 = NPGetInternalQueue(v8);
  uint64_t v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100020C68;
  block[3] = &unk_1000F97E8;
  void block[5] = v7;
  void block[6] = a2;
  void block[4] = a1;
  dispatch_async(v5, block);

  _Block_object_dispose(v7, 8);
}

void sub_100020C50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100020C68(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = a1[4];
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained probeServerError:v4 httpStatusCode:a1[6]];

  uint64_t v5 = *(void *)(a1[5] + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100020CC8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v11 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[10] = 0;
    uint64_t isKindOfClass = sub_10001FCA8(WeakRetained, 0LL);
    if (v9)
    {
      uint64_t v15 = nplog_obj(isKindOfClass, v13, v14);
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 24);
        }
        int v35 = 138412546;
        uint64_t v36 = v17;
        __int16 v37 = 2112;
        uint64_t v38 = (uint64_t)v9;
        dispatch_source_t v18 = "Probe[%@] failed with error %@";
        id v19 = v16;
        uint32_t v20 = 22;
LABEL_27:
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v18, (uint8_t *)&v35, v20);
        goto LABEL_17;
      }

      goto LABEL_17;
    }

    if (!v7
      || (uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse),
          uint64_t isKindOfClass = objc_opt_isKindOfClass(v8, v21),
          (isKindOfClass & 1) == 0))
    {
      uint64_t v29 = nplog_obj(isKindOfClass, v13, v14);
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v34 = *(void *)(a1 + 32);
        if (v34) {
          uint64_t v34 = *(void *)(v34 + 24);
        }
        int v35 = 138412290;
        uint64_t v36 = v34;
        dispatch_source_t v18 = "Probe[%@] failed to receive expected response";
        id v19 = v16;
        uint32_t v20 = 12;
        goto LABEL_27;
      }

LABEL_17:
LABEL_18:
      sub_1000207BC(v11);
      goto LABEL_19;
    }

    uint64_t v22 = (uint64_t)[v8 statusCode];
    uint64_t v25 = nplog_obj(v22, v23, v24);
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      if (v27) {
        uint64_t v27 = *(void *)(v27 + 24);
      }
      int v35 = 138412546;
      uint64_t v36 = v27;
      __int16 v37 = 2048;
      uint64_t v38 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Probe[%@] received response %ld",  (uint8_t *)&v35,  0x16u);
    }

    if ((unint64_t)(v22 - 200) > 0x63)
    {
      if (v22 >= 400)
      {
        sub_100020B7C(v11, v22);
        uint64_t v30 = objc_alloc_init(&OBJC_CLASS___NSPProbeHTTPErrorCodeStats);
        id v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v11 + 88) interface]);
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities getInterfaceTypeString:]( NPUtilities,  "getInterfaceTypeString:",  [v31 type]));
        -[NSPProbeHTTPErrorCodeStats setInterfaceType:](v30, "setInterfaceType:", v32);

        -[NSPProbeHTTPErrorCodeStats setDirectPath:](v30, "setDirectPath:", *(_BYTE *)(v11 + 11) == 0);
        unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v22));
        -[NSPProbeHTTPErrorCodeStats setHTTPErrorCode:](v30, "setHTTPErrorCode:", v33);

        -[NSPProxyAnalytics sendAnalytics](v30, "sendAnalytics");
        goto LABEL_19;
      }

      goto LABEL_18;
    }

    id v28 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v7,  134217984LL);
    if (-[NSString isEqualToString:]( v28,  "isEqualToString:",  @"<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>"))
    {
      sub_1000208FC(v11);
    }

    else
    {
      sub_100020A3C(v11);
    }
  }
    }

    else
    {
      id v19 = 0;
    }

    uint32_t v20 = v4;
    reply = xpc_dictionary_create_reply(v20);
    remote_connection = xpc_dictionary_get_remote_connection(v20);
    uint64_t v23 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

    if (reply && v23)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerPrivateAccessTokenOriginAllowed", v19);
      xpc_connection_send_message(v23, reply);
    }
  }
}

  unint64_t v33 = 0LL;
LABEL_18:

  return v33;
}
  }

  return v2;
}

LABEL_18:
      id v31 = 0LL;
      goto LABEL_37;
    }

    id v71 = nplog_obj(v3, v4, v5);
    uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v80 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
    id v70 = "%s called with null self.hpkeContext";
LABEL_45:
    _os_log_fault_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, v70, buf, 0xCu);
    goto LABEL_17;
  }

  id v31 = (NSData *)v3;
LABEL_37:

  return v31;
}

void sub_100021004(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 8))
    {
      *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
      sub_10001F920(a1, a2, a3, a4);
      v6[0] = 0LL;
      v6[1] = v6;
      v6[2] = 0x3032000000LL;
      v6[3] = sub_10000CED4;
      v6[4] = sub_10000CEE4;
      id v7 = (id)os_transaction_create("com.apple.networkserviceproxy.sendProbe");
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472LL;
      v5[2] = sub_1000210E4;
      v5[3] = &unk_1000F98B0;
      v5[4] = v6;
      sub_100020078(a1, v5);
      _Block_object_dispose(v6, 8);
    }
  }

void sub_1000210CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000210E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000210F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_10002110C(uint64_t a1, void *a2)
{
  id v11 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 88), a2);
    if ([v11 status] == (id)1)
    {
      if (*(_BYTE *)(a1 + 9))
      {
        uint64_t v6 = nplog_obj(1LL, v4, v5);
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *(void *)(a1 + 24);
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Retry probing[%@] on network change",  (uint8_t *)&buf,  0xCu);
        }

        sub_100020588(a1, v9, v10);
        *(void *)&__int128 buf = 0LL;
        *((void *)&buf + 1) = &buf;
        uint64_t v14 = 0x3032000000LL;
        uint64_t v15 = sub_10000CED4;
        uint64_t v16 = sub_10000CEE4;
        id v17 = (id)os_transaction_create("com.apple.networkserviceproxy.probePathChange");
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472LL;
        v12[2] = sub_1000210F8;
        v12[3] = &unk_1000F98B0;
        v12[4] = &buf;
        sub_100020078(a1, v12);
        _Block_object_dispose(&buf, 8);
      }
    }
  }
}

void sub_10002127C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000213B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  if (!v5)
  {
    uint64_t v56 = nplog_obj(v7, v8, v9);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v56);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy1";
LABEL_41:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v46, OS_LOG_TYPE_FAULT, v57, (uint8_t *)&v64, 0xCu);
    goto LABEL_20;
  }

  unsigned int v10 = [v5 proxyHop];
  if (v10 != [v6 proxyHop])
  {
LABEL_21:
    uint64_t v54 = 0LL;
    goto LABEL_22;
  }

  id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 proxyURL]);

  if (!v11)
  {
    uint64_t v58 = nplog_obj(v12, v13, v14);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v58);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy1.proxyURL";
    goto LABEL_41;
  }

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyURL]);

  if (!v15)
  {
    uint64_t v59 = nplog_obj(v16, v17, v18);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v59);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy2.proxyURL";
    goto LABEL_41;
  }

  id v19 = (void *)objc_claimAutoreleasedReturnValue([v5 proxyURL]);
  uint32_t v20 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyURL]);
  unsigned int v21 = [v19 isEqualToString:v20];

  if (!v21) {
    goto LABEL_21;
  }
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v5 proxyKeyInfos]);

  if (!v22)
  {
    uint64_t v60 = nplog_obj(v23, v24, v25);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v60);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy1.proxyKeyInfos";
    goto LABEL_41;
  }

  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyKeyInfos]);

  if (!v26)
  {
    uint64_t v61 = nplog_obj(v27, v28, v29);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v61);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy2.proxyKeyInfos";
    goto LABEL_41;
  }

  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v5 proxyKeyInfos]);
  id v31 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyKeyInfos]);
  unsigned int v32 = [v30 isEqualToArray:v31];

  if (!v32) {
    goto LABEL_21;
  }
  unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v5 tokenKeyInfo]);

  if (!v33)
  {
    uint64_t v62 = nplog_obj(v34, v35, v36);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v62);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy1.tokenKeyInfo";
    goto LABEL_41;
  }

  __int16 v37 = (void *)objc_claimAutoreleasedReturnValue([v6 tokenKeyInfo]);

  if (!v37)
  {
    uint64_t v63 = nplog_obj(v38, v39, v40);
    uint64_t v46 = objc_claimAutoreleasedReturnValue(v63);
    if (!os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v64 = 136315138;
    id v65 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    id v57 = "%s called with null proxy2.tokenKeyInfo";
    goto LABEL_41;
  }

  uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v5 tokenKeyInfo]);
  id v42 = (void *)objc_claimAutoreleasedReturnValue([v6 tokenKeyInfo]);
  unsigned int v43 = [v41 isEqualToData:v42];

  if (!v43) {
    goto LABEL_21;
  }
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v5 tcpProxyFqdn]);
  id v45 = (void *)objc_claimAutoreleasedReturnValue([v6 tcpProxyFqdn]);
  uint64_t v46 = v44;
  unint64_t v47 = v45;
  __int16 v48 = (void *)v47;
  if (v46 | v47 && (!v46 || !v47 || ![(id)v46 isEqual:v47]))
  {

LABEL_20:
    goto LABEL_21;
  }

  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v5 preferredPathConfigUri]);
  __int16 v50 = (void *)objc_claimAutoreleasedReturnValue([v6 preferredPathConfigUri]);
  unint64_t v51 = v49;
  unint64_t v52 = v50;
  uint64_t v53 = (void *)v52;
  if (!(v51 | v52)) {
    goto LABEL_17;
  }
  uint64_t v54 = 0LL;
  if (!v51 || !v52) {
    goto LABEL_18;
  }
  if ([(id)v51 isEqual:v52]) {
LABEL_17:
  }
    uint64_t v54 = 1LL;
  else {
    uint64_t v54 = 0LL;
  }
LABEL_18:

LABEL_22:
  return v54;
}

void sub_100021BE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    int v11 = 138412290;
    uint64_t v12 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Token challenge changed for %@, flushing tokens",  (uint8_t *)&v11,  0xCu);
  }

  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 40);
    if (v10)
    {
      [*(id *)(v10 + 24) flushTokens];
      uint64_t v9 = *(void *)(a1 + 40);
    }
  }

  sub_10000E718(v9, v7, v8);
}

void sub_100021CC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    int v9 = 138412290;
    uint64_t v10 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Token key changed for %@",  (uint8_t *)&v9,  0xCu);
  }

  sub_10000F840(*(void *)(a1 + 40), v7, v8);
}

void sub_100023D24(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 88), a2);
  }
}

void sub_100023D34(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 96), a2);
  }
}

void sub_100023D44(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 104), a2);
  }
}

void sub_100023D54(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 112), a2);
  }
}

void sub_100023D64(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 120), a2);
  }
}

void sub_100023D74(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 128), a2);
  }
}

void sub_100023D84(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 136), a2);
  }
}

void sub_100023D94(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 144), a2);
  }
}

void sub_100023DA4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 152), a2);
  }
}

void sub_100023DB4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 336), a2);
  }
}

void sub_100023DC4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 72), a2);
  }
}

void sub_100023DD4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 160), a2);
  }
}

void sub_100023DE4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 208), a2);
  }
}

void sub_100023DF4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 216), a2);
  }
}

void sub_100023E04(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 224), a2);
  }
}

void sub_100023E14(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 232), a2);
  }
}

void sub_100023E24(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 288), a2);
  }
}

void sub_100023E34(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 352), a2);
  }
}

void sub_100023E44(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 368), a2);
  }
}

void sub_100023E54(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 376), a2);
  }
}

void sub_100023E64(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 384), a2);
  }
}

void sub_100023E74(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 272), a2);
  }
}

void sub_100023E84(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 392), a2);
  }
}

void sub_100023E94(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 240), a2);
  }
}

void sub_100023EA4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 256), a2);
  }
}

void sub_100023EB4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 512), a2);
  }
}

void sub_100023EC4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 400), a2);
  }
}

void sub_100023ED4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 408), a2);
  }
}

void sub_100024240(uint64_t a1)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 360), 0LL);
  }
}

id sub_100024254(uint64_t a1)
{
  CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"NSPProxyPathRestoreIntervalSeconds", kCFPreferencesCurrentApplication);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  if (v2
    && (uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSNumber),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v2, v3),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected proxy path restore interval in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = [v2 unsignedIntegerValue];
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_100024368()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPPreferredProxy", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected preferred proxy in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_10002445C()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPPreferredObliviousProxy", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected preferred oblivious proxy in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_100024550()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPOverrideIngressProxy", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected override ingress proxy in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_100024644()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPOverrideFallbackIngressProxy", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected override fallback ingress proxy in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_100024738()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPOverrideIngressProxyKey", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSData),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected override ingress proxy key in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_10002482C()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPOverrideEnabledMaps", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSArray),
        uint64_t isKindOfClass = objc_opt_isKindOfClass(v1, v2),
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = nplog_obj(isKindOfClass, v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138543362;
      uint64_t v12 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Detected overridden enabled proxied content maps in preferences file: %{public}@",  (uint8_t *)&v11,  0xCu);
    }

    id v9 = v1;
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_100024920()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPDisableProxiedContentDoHBootstrap", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1 && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
  {
    id v3 = [v1 BOOLValue];
    uint64_t v6 = nplog_obj(v3, v4, v5);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67240192;
      v9[1] = (_DWORD)v3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Detected DoH bootstrap disabled in preferences file: %{public}d",  (uint8_t *)v9,  8u);
    }
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

id sub_100024A20()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPForceFallback", kCFPreferencesCurrentApplication);
  CFPropertyListRef v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1 && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
  {
    id v3 = [v1 BOOLValue];
    uint64_t v6 = nplog_obj(v3, v4, v5);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67240192;
      v9[1] = (_DWORD)v3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Detected force fallback in preferences file: %{public}d",  (uint8_t *)v9,  8u);
    }
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

id sub_100024C98(uint64_t a1)
{
  CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"NSPProxyAgentManagerPreferences", kCFPreferencesCurrentApplication);
  if (v1)
  {
    uint64_t v4 = v1;
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString);
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber);
    uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSArray);
    id v9 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  v6,  v7,  v8,  objc_opt_class(&OBJC_CLASS___NSData),  0LL);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    uint64_t v22 = 0LL;
    int v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v10,  v4,  &v22));

    CFRelease(v4);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:@"Version"]);
    id v13 = [v12 unsignedIntegerValue];
    if (v13 == (id)1)
    {
      id v16 = v11;
    }

    else
    {
      uint64_t v18 = nplog_obj(v13, v14, v15);
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        id v21 = [v12 unsignedIntegerValue];
        *(_DWORD *)__int128 buf = 134218240;
        id v24 = v21;
        __int16 v25 = 1024;
        int v26 = 1;
        _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "saved version %lu does not match current version %u",  buf,  0x12u);
      }

      id v16 = 0LL;
    }
  }

  else
  {
    uint64_t v17 = nplog_obj(0LL, v2, v3);
    int v11 = (void *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v11, OS_LOG_TYPE_INFO, "no saved proxy agent data", buf, 2u);
    }

    id v16 = 0LL;
  }

  return v16;
}

void sub_100025FD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42)
{
}

void sub_100025FF4(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = *(dispatch_source_s **)(a1 + 360);
    if (v4)
    {
      dispatch_source_cancel(v4);
      uint64_t v5 = *(void **)(a1 + 360);
      *(void *)(a1 + 360) = 0LL;
    }

    if (a2)
    {
      uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceNow:", (double)a2));
      uint64_t v7 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v6;

      uint64_t v9 = NPGetInternalQueue(v8);
      uint64_t v10 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v9);
      dispatch_source_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v10);
      uint64_t v12 = *(void **)(a1 + 360);
      *(void *)(a1 + 360) = v11;

      id v13 = *(void **)(a1 + 360);
      if (v13)
      {
        uint64_t v14 = v13;
        dispatch_time_t v15 = dispatch_time(0x8000000000000000LL, 1000000000 * a2);
        dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0LL);

        objc_initWeak(&location, (id)a1);
        id v16 = *(void **)(a1 + 360);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_1000285F4;
        handler[3] = &unk_1000F9AA8;
        uint64_t v17 = v16;
        objc_copyWeak(&v20, &location);
        void handler[4] = a1;
        dispatch_source_set_event_handler(v17, handler);

        dispatch_resume(*(dispatch_object_t *)(a1 + 360));
        objc_destroyWeak(&v20);
        objc_destroyWeak(&location);
      }
    }

    else
    {
      uint64_t v18 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = 0LL;
    }
  }

void sub_100026178(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained tokenIssuanceAllowed];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

void sub_1000261CC(uint64_t a1, void *a2)
{
  id v120 = a2;
  id v3 = *(id *)(a1 + 224);
  id location = (id *)(a1 + 224);
  if (!v3)
  {
    id v23 = *(id *)(a1 + 168);
    if (v23)
    {
      id v24 = v23;
      id v25 = *(id *)(a1 + 168);
      int v26 = (void *)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:@"IngressProxyURL"]);
      if (v26)
      {
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 168) objectForKeyedSubscript:@"EgressProxyURL"]);

        if (v27)
        {
          id v28 = *(id *)(a1 + 168);
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 objectForKeyedSubscript:@"IngressProxyURL"]);
          id v30 = *(id *)(a1 + 168);
          id v31 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"EgressProxyURL"]);
          unsigned int v32 = sub_1000292DC((id *)a1, v29, v31);
          id v33 = (id)objc_claimAutoreleasedReturnValue(v32);

          [*(id *)(a1 + 168) removeObjectForKey:@"IngressProxyURL"];
          [*(id *)(a1 + 168) removeObjectForKey:@"EgressProxyURL"];
          if (v33) {
            goto LABEL_42;
          }
        }
      }

      else
      {
      }
    }

    __int16 v50 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);

    if (v120 && !v50)
    {
      id v33 = v120;
      goto LABEL_42;
    }

    unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);

    if (v51)
    {
      __int128 v128 = 0u;
      __int128 v129 = 0u;
      __int128 v126 = 0u;
      __int128 v127 = 0u;
      id obj = *(id *)(a1 + 104);
      id v117 = [obj countByEnumeratingWithState:&v126 objects:buf count:16];
      if (v117)
      {
        uint64_t v115 = *(void *)v127;
LABEL_30:
        uint64_t v52 = 0LL;
        while (1)
        {
          if (*(void *)v127 != v115) {
            objc_enumerationMutation(obj);
          }
          uint64_t v53 = *(void **)(*((void *)&v126 + 1) + 8 * v52);
          id v54 = *(id *)(a1 + 88);
          id v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectAtIndex:", *(unsigned int *)objc_msgSend(v53, "proxies")));

          id v56 = *(id *)(a1 + 88);
          uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v55 proxyURL]);
          uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);
          uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v57 proxyURL]);
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);
          unsigned __int8 v62 = [v60 isEqualToString:v61];

          if ((v62 & 1) != 0) {
            goto LABEL_39;
          }

          if (v117 == (id)++v52)
          {
            id v117 = [obj countByEnumeratingWithState:&v126 objects:buf count:16];
            if (v117) {
              goto LABEL_30;
            }
            goto LABEL_37;
          }
        }

LABEL_39:
        id v63 = v53;

        if (!v63) {
          goto LABEL_41;
        }
        id v33 = v63;
        goto LABEL_42;
      }

LABEL_41:
    id v64 = sub_100028ED8(*(void **)(a1 + 112));
    id v33 = (id)objc_claimAutoreleasedReturnValue(v64);
    if (!v33)
    {
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000LL;
      v131 = sub_10000CED4;
      v132 = sub_10000CEE4;
      id v133 = (id)os_transaction_create("com.apple.networkserviceproxy.refreshProxyInfo");
      uint64_t v103 = NPGetInternalQueue(v133);
      v104 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v103);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10002A8E4;
      block[3] = &unk_1000F9428;
      void block[4] = a1;
      void block[5] = buf;
      dispatch_async(v104, block);

      _Block_object_dispose(buf, 8);
      goto LABEL_63;
    }

  -[NSPConfigurationStats setSafariAllEnabled:](v15, "setSafariAllEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x10) == 0)
  {
LABEL_16:
    if ((v12 & 0x40000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_43;
  }

LABEL_42:
    id v65 = *(id *)(a1 + 88);
    id v116 = v33;
    id v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "objectAtIndexedSubscript:", *(unsigned int *)objc_msgSend(v33, "proxies")));

    id v67 = *(id *)(a1 + 88);
    uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v67,  "objectAtIndexedSubscript:",  *((unsigned int *)objc_msgSend(v116, "proxies") + 1)));

    if (v66)
    {
      if (v118)
      {
        id v71 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxy]);
        if (v71)
        {
        }

        else
        {
          id v72 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxyKey]);

          if (!v72)
          {
            uint64_t v78 = v66;
            goto LABEL_52;
          }
        }

        id v73 = [v66 copy];

        id v74 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxy]);
        if (v74)
        {
          uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxy]);
          [v73 setProxyURL:v75];
        }

        unint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxyKey]);

        if (v76)
        {
          [v73 clearProxyKeyInfos];
          unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxyKey]);
          [v73 addProxyKeyInfo:v77];
        }

        uint64_t v78 = v73;
LABEL_52:
        BOOL v112 = v78;
        uint64_t v79 = sub_10002991C(a1, v78);
        id obja = (id)objc_claimAutoreleasedReturnValue(v79);
        uint64_t v80 = sub_10002991C(a1, v118);
        uint64_t v81 = objc_claimAutoreleasedReturnValue(v80);
        __int128 v84 = (void *)v81;
        if (obja)
        {
          if (v81)
          {
            __int128 v85 = -[NSPCandidateProxyPath initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:]( [NSPCandidateQuicProxyPath alloc],  "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:",  obja,  v81,  [v116 weight],  0,  0);
            objc_storeStrong(location, v85);

            uint64_t v89 = nplog_obj(v86, v87, v88);
            v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v89);
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
            {
              id v111 = *location;
              uint64_t v91 = objc_claimAutoreleasedReturnValue([v111 ingressProxy]);
              uint64_t v92 = (void *)v91;
              if (v91) {
                uint64_t v93 = *(void **)(v91 + 24);
              }
              else {
                uint64_t v93 = 0LL;
              }
              id v94 = v93;
              v95 = (void *)objc_claimAutoreleasedReturnValue([v94 vendor]);
              id v96 = *location;
              uint64_t v97 = objc_claimAutoreleasedReturnValue([v96 egressProxy]);
              uint64_t v98 = (void *)v97;
              if (v97) {
                v99 = *(void **)(v97 + 24);
              }
              else {
                v99 = 0LL;
              }
              id v100 = v99;
              uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 vendor]);
              *(_DWORD *)__int128 buf = 138412546;
              *(void *)&uint8_t buf[4] = v95;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v101;
              _os_log_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_DEFAULT,  "Setting candidate proxy path ([%@]-[%@])",  buf,  0x16u);
            }

            int v102 = 0;
            goto LABEL_61;
          }

          uint64_t v110 = nplog_obj(0LL, v82, v83);
          v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v110);
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_FAULT))
          {
LABEL_76:
            int v102 = 1;
LABEL_61:

            id v66 = v112;
LABEL_62:

            if (v102) {
              goto LABEL_63;
            }
            id v3 = *location;
            goto LABEL_4;
          }

          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
          unint64_t v109 = "%s called with null egressProxyTokenInfo";
        }

        else
        {
          uint64_t v108 = nplog_obj(v81, v82, v83);
          v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_FAULT)) {
            goto LABEL_76;
          }
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
          unint64_t v109 = "%s called with null ingressProxyTokenInfo";
        }

        _os_log_fault_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_FAULT, v109, buf, 0xCu);
        goto LABEL_76;
      }

      uint64_t v106 = nplog_obj(v68, v69, v70);
      uint64_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);
      if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_FAULT,  "%s called with null egressProxyInfo",  buf,  0xCu);
      }
    }

    else
    {
      uint64_t v105 = nplog_obj(v68, v69, v70);
      id v66 = (void *)objc_claimAutoreleasedReturnValue(v105);
      if (os_log_type_enabled((os_log_t)v66, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v66,  OS_LOG_TYPE_FAULT,  "%s called with null ingressProxyInfo",  buf,  0xCu);
      }
    }

    int v102 = 1;
    goto LABEL_62;
  }
}

  -[NSPConfigurationStats setSafariHTTPEnabled:](v15, "setSafariHTTPEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x40000) == 0)
  {
LABEL_17:
    if ((v12 & 0x80000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_44;
  }

LABEL_4:
  id v4 = [v3 proxyPathReady];
  if ((_DWORD)v4)
  {
    uint64_t v7 = nplog_obj(v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *location;
      uint64_t v10 = objc_claimAutoreleasedReturnValue([v9 ingressProxy]);
      dispatch_source_t v11 = (void *)v10;
      if (v10) {
        uint64_t v12 = *(void **)(v10 + 24);
      }
      else {
        uint64_t v12 = 0LL;
      }
      id v13 = v12;
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 vendor]);
      id v15 = *location;
      uint64_t v16 = objc_claimAutoreleasedReturnValue([v15 egressProxy]);
      uint64_t v17 = (void *)v16;
      if (v16) {
        uint64_t v18 = *(void **)(v16 + 24);
      }
      else {
        uint64_t v18 = 0LL;
      }
      id v19 = v18;
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 vendor]);
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Setting quic proxy path ([%@]-[%@])",  buf,  0x16u);
    }

    sub_10002A4AC(a1, v21, v22);
  }

  else
  {
    id v34 = *location;
    uint64_t v35 = objc_claimAutoreleasedReturnValue([v34 ingressProxy]);
    uint64_t v36 = (void *)v35;
    if (v35) {
      __int16 v37 = *(void **)(v35 + 24);
    }
    else {
      __int16 v37 = 0LL;
    }
    id v38 = v37;

    id v39 = *location;
    uint64_t v40 = objc_claimAutoreleasedReturnValue([v39 egressProxy]);
    uint64_t v41 = (void *)v40;
    if (v40) {
      id v42 = *(void **)(v40 + 24);
    }
    else {
      id v42 = 0LL;
    }
    id v43 = v42;

    id v44 = *location;
    id v45 = (void *)objc_claimAutoreleasedReturnValue([v44 ingressProxy]);
    v123[0] = _NSConcreteStackBlock;
    v123[1] = 3221225472LL;
    v123[2] = sub_10002A93C;
    v123[3] = &unk_1000F9720;

    id v124 = v38;
    id v46 = v38;
    sub_10000CF58((uint64_t)v45, v123);

    id v47 = *location;
    __int16 v48 = (void *)objc_claimAutoreleasedReturnValue([v47 egressProxy]);
    v121[0] = _NSConcreteStackBlock;
    v121[1] = 3221225472LL;
    v121[2] = sub_10002AA20;
    v121[3] = &unk_1000F9720;

    id v122 = v43;
    id v49 = v43;
    sub_10000CF58((uint64_t)v48, v121);
  }

  sub_100029DC4((id *)a1);
  [(id)a1 updateUserEventAgentData];
  sub_10002AB04(a1);
LABEL_63:
}

  uint64_t v58 = v13;
  if (![v12 count]) {
    goto LABEL_24;
  }
  id v23 = 0LL;
  *(void *)&uint64_t v22 = 138412290LL;
  id v54 = v22;
  id v55 = v10;
  id v56 = v11;
  while (1)
  {
    id v24 = objc_msgSend(v9, "count", v54);
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v9 objectAtIndex:v23]);
    id v28 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v23]);
    uint64_t v59 = 0LL;
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 activateTokenWithServerResponse:v28 error:&v59]);
    id v30 = (char *)v59;

    if (v30)
    {
      id v34 = nplog_obj(v31, v32, v33);
      uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = v54;
        unsigned __int8 v62 = v30;
        _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "activateTokenWithServerResponse failed with error %@",  buf,  0xCu);
      }
    }

    else
    {
      if (!v29) {
        goto LABEL_11;
      }
      if (v10)
      {
        uint64_t v36 = objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenResponse);
        __int16 v37 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v23]);
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v29 signature]);
        uint64_t v35 = sub_1000AB5D4(v36, v10, v37, v57, v38);

        if (v35)
        {
          uint64_t v40 = objc_getProperty(v35, v39, 8LL, 1);
          if (v40) {
            -[NSMutableArray addObject:](v58, "addObject:", v40);
          }
        }

        else
        {
          uint64_t v40 = 0LL;
        }

        dispatch_source_t v11 = v56;

        uint64_t v10 = v55;
      }

      else
      {
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[NSMutableData data](&OBJC_CLASS___NSMutableData, "data"));
        -[os_log_s appendBytes:length:](v35, "appendBytes:length:", &v60, 1LL);
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v29 keyId]);
        -[os_log_s appendData:](v35, "appendData:", v41);

        id v42 = (void *)objc_claimAutoreleasedReturnValue([v29 tokenContent]);
        -[os_log_s appendData:](v35, "appendData:", v42);

        id v43 = (void *)objc_claimAutoreleasedReturnValue([v29 signature]);
        -[os_log_s appendData:](v35, "appendData:", v43);

        -[NSMutableArray addObject:](v58, "addObject:", v35);
      }
    }

LABEL_11:
  }

  id v44 = nplog_obj(v24, v25, v26);
  id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
  {
    id v46 = (const char *)[v12 count];
    id v47 = [v9 count];
    *(_DWORD *)__int128 buf = 134218240;
    unsigned __int8 v62 = v46;
    id v63 = 2048;
    id v64 = v47;
    _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "More unactivated tokens than waiting tokens (%lu != %lu)",  buf,  0x16u);
  }

LABEL_24:
  id v13 = v58;
  __int16 v48 = v58;
LABEL_25:

  return v48;
}

    id v24 = 0LL;
    goto LABEL_34;
  }

  if (!v17)
  {
    id v63 = nplog_obj(v19, v20, v21);
    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "%s called with null tokenBlinder",  (uint8_t *)bytes,  0xCu);
    }

    goto LABEL_4;
  }

  id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (a7)
  {
    id v25 = a7;
    while (1)
    {
      if (v14)
      {
        int v26 = v14;
        objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenRequest);
        memset(bytes, 0, sizeof(bytes));
        uint64_t v27 = SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes);
        if ((v27 & 0x80000000) != 0)
        {
          id v38 = nplog_obj(v27, v28, v29);
          id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)md = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "generate tokens: SecRandomCopyBytes failed",  md,  2u);
          }

          id v30 = 0LL;
          unsigned int v32 = 0LL;
        }

        else
        {
          id v30 = (id)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  bytes,  32LL));
          id v31 = (os_log_s *)[v26 mutableCopy];
          -[os_log_s appendBytes:length:](v31, "appendBytes:length:", bytes, 32LL);
          *(_OWORD *)md = 0u;
          id v73 = 0u;
          CC_SHA256(-[os_log_s bytes](v31, "bytes"), (CC_LONG)-[os_log_s length](v31, "length"), md);
          unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", md, 32LL));
        }

        id v34 = v30;
        __int16 v37 = v34;
      }

      else
      {
        id v33 = sub_1000ACA74((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenRequest);
        id v34 = (id)objc_claimAutoreleasedReturnValue(v33);
        unsigned int v32 = v34;
        __int16 v37 = 0LL;
      }

      if (!v32) {
        break;
      }
      id v39 = (void *)objc_claimAutoreleasedReturnValue([v68 key]);
      uint64_t v40 = sub_1000ACB50((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenRequest, v69, v32, v39);
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(v40);

      if (!v41)
      {
        uint64_t v59 = nplog_obj(v42, v43, v44);
        uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
        {
          LODWORD(bytes[0]) = 136315138;
          *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:paire"
                                           "dToken:clientNonces:clientSalts:tokenCount:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_FAULT,  "%s called with null messageToBlind",  (uint8_t *)bytes,  0xCu);
        }

LABEL_41:
        id v24 = 0LL;
        uint64_t v18 = 0LL;
        goto LABEL_34;
      }

      -[os_log_s addObject:](v23, "addObject:", v41);
      [v67 addObject:v32];
      if (v37) {
        [v66 addObject:v37];
      }

      if (!--v25)
      {
        id v45 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        id v46 = 0LL;
        while (1)
        {
          if (v23)
          {
            id v39 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s objectAtIndexedSubscript:](v23, "objectAtIndexedSubscript:", v46));
            id v47 = v39;
          }

          else
          {
            id v47 = 0LL;
          }

          uint64_t v70 = 0LL;
          __int16 v48 = (void *)objc_claimAutoreleasedReturnValue([v17 tokenWaitingActivationWithContent:v47 error:&v70]);
          id v49 = v70;
          uint64_t v52 = v49;
          if (v23) {

          }
          if (!v48) {
            break;
          }
          -[NSMutableArray addObject:](v45, "addObject:", v48);

          if (a7 == ++v46)
          {
            uint64_t v18 = 0LL;
            goto LABEL_31;
          }
        }

        uint64_t v61 = nplog_obj(v49, v50, v51);
        unsigned __int8 v62 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
        {
          LODWORD(bytes[0]) = 136315138;
          *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:paire"
                                           "dToken:clientNonces:clientSalts:tokenCount:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_FAULT,  "%s called with null waitingActivation",  (uint8_t *)bytes,  0xCu);
        }

        id v24 = 0LL;
        uint64_t v18 = 0LL;
        goto LABEL_33;
      }
    }

    id v57 = nplog_obj(v34, v35, v36);
    uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_FAULT,  "%s called with null clientNonce",  (uint8_t *)bytes,  0xCu);
    }

    goto LABEL_41;
  }

  id v45 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
LABEL_31:
  if (-[NSMutableArray count](v45, "count"))
  {
    id v45 = v45;
    id v24 = v45;
  }

  else
  {
    id v64 = nplog_obj(0LL, v53, v54);
    id v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v64);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_FAULT,  "%s called with null (waitingTokens.count > 0)",  (uint8_t *)bytes,  0xCu);
    }

    id v24 = 0LL;
  }

void sub_100026CF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
}

void sub_100026D14(id *a1, void *a2)
{
  id v3 = a2;
  if (!a1) {
    goto LABEL_60;
  }
  uint64_t v5 = a1 + 29;
  id v4 = a1[29];
  if (v4) {
    goto LABEL_3;
  }
  id v27 = a1[21];
  if (v27)
  {
    id v28 = v27;
    id v29 = a1[21];
    uint64_t v30 = objc_claimAutoreleasedReturnValue([v29 objectForKeyedSubscript:@"IngressFallbackProxyURL"]);
    if (v30)
    {
      id v31 = (void *)v30;
      unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue([a1[21] objectForKeyedSubscript:@"EgressFallbackProxyURL"]);

      if (v32)
      {
        id v33 = a1[21];
        id v34 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:@"IngressFallbackProxyURL"]);
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([a1[21] objectForKeyedSubscript:@"EgressFallbackProxyURL"]);
        uint64_t v36 = sub_100029598(a1, v34, v35);
        id v37 = (id)objc_claimAutoreleasedReturnValue(v36);

        [a1[21] removeObjectForKey:@"IngressFallbackProxyURL"];
        [a1[21] removeObjectForKey:@"EgressFallbackProxyURL"];
        if (v37) {
          goto LABEL_31;
        }
      }
    }

    else
    {
    }
  }

  id v54 = (void *)objc_claimAutoreleasedReturnValue([a1 overridePreferredProxy]);

  if (v3 && !v54)
  {
    id v37 = v3;
    goto LABEL_31;
  }

  id v55 = sub_1000290A4(a1);
  id v37 = (id)objc_claimAutoreleasedReturnValue(v55);
  if (v37)
  {
LABEL_31:
    id v58 = a1[11];
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:", *(unsigned int *)objc_msgSend(v37, "proxies")));

    id v60 = a1[11];
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "objectAtIndexedSubscript:", *((unsigned int *)objc_msgSend(v37, "proxies") + 1)));

    if (v59)
    {
      if (v61)
      {
        id v65 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideFallbackIngressProxy]);
        if (v65)
        {
        }

        else
        {
          id v66 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideIngressProxyKey]);

          if (!v66) {
            goto LABEL_41;
          }
        }

        id v67 = [v59 copy];

        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideFallbackIngressProxy]);
        if (v68)
        {
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideFallbackIngressProxy]);
          [v67 setProxyURL:v69];
        }

        uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideIngressProxyKey]);

        if (v70)
        {
          [v67 clearProxyKeyInfos];
          id v71 = (void *)objc_claimAutoreleasedReturnValue([a1 overrideIngressProxyKey]);
          [v67 addProxyKeyInfo:v71];
        }

        uint64_t v59 = v67;
LABEL_41:
        id v72 = sub_10002991C((uint64_t)a1, v59);
        id v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
        id v74 = sub_10002991C((uint64_t)a1, v61);
        uint64_t v75 = objc_claimAutoreleasedReturnValue(v74);
        uint64_t v78 = (void *)v75;
        if (v73)
        {
          if (v75)
          {
            uint64_t v79 = -[NSPCandidateProxyPath initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:]( [NSPCandidateFallbackProxyPath alloc],  "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:",  v73,  v75,  [v37 weight],  0,  0);
            objc_storeStrong(a1 + 29, v79);

            uint64_t v83 = nplog_obj(v80, v81, v82);
            __int128 v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
            {
              id v122 = *v5;
              uint64_t v85 = objc_claimAutoreleasedReturnValue([v122 ingressProxy]);
              id v120 = (void *)v85;
              if (v85) {
                uint64_t v86 = *(void **)(v85 + 24);
              }
              else {
                uint64_t v86 = 0LL;
              }
              id v118 = v86;
              id v116 = (char *)objc_claimAutoreleasedReturnValue([v118 tcpProxyFqdn]);
              id v114 = *v5;
              uint64_t v87 = objc_claimAutoreleasedReturnValue([v114 ingressProxy]);
              id v124 = v59;
              BOOL v112 = (void *)v87;
              if (v87) {
                uint64_t v88 = *(void **)(v87 + 24);
              }
              else {
                uint64_t v88 = 0LL;
              }
              id v111 = v88;
              uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v111 vendor]);
              id v110 = *v5;
              uint64_t v90 = objc_claimAutoreleasedReturnValue([v110 egressProxy]);
              id v131 = v37;
              id v132 = v3;
              __int128 v126 = v78;
              unint64_t v109 = (void *)v90;
              if (v90) {
                uint64_t v91 = *(void **)(v90 + 24);
              }
              else {
                uint64_t v91 = 0LL;
              }
              id v108 = v91;
              uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v108 tcpProxyFqdn]);
              id v93 = *v5;
              uint64_t v94 = objc_claimAutoreleasedReturnValue([v93 egressProxy]);
              v95 = (void *)v94;
              __int128 v129 = v61;
              if (v94) {
                id v96 = *(void **)(v94 + 24);
              }
              else {
                id v96 = 0LL;
              }
              id v97 = v96;
              uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v97 vendor]);
              *(_DWORD *)__int128 buf = 138413058;
              v138 = v116;
              __int16 v139 = 2112;
              v140 = v89;
              __int16 v141 = 2112;
              v142 = v92;
              __int16 v143 = 2112;
              v144 = v98;
              _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "Setting candidate fallback proxy path (%@[%@]-%@[%@])",  buf,  0x2Au);

              int v99 = 0;
              id v37 = v131;
              id v3 = v132;
              uint64_t v61 = v129;
              uint64_t v59 = v124;
              uint64_t v78 = v126;
            }

            else
            {
              int v99 = 0;
            }

            goto LABEL_54;
          }

          uint64_t v107 = nplog_obj(0LL, v76, v77);
          __int128 v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v107);
          if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
          {
LABEL_70:
            int v99 = 1;
LABEL_54:

LABEL_55:
            if (v99) {
              goto LABEL_60;
            }
            id v4 = *v5;
LABEL_3:
            id v6 = [v4 proxyPathReady];
            if ((_DWORD)v6)
            {
              uint64_t v9 = nplog_obj(v6, v7, v8);
              uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                id v130 = *v5;
                uint64_t v11 = objc_claimAutoreleasedReturnValue([v130 ingressProxy]);
                __int128 v128 = (void *)v11;
                if (v11) {
                  uint64_t v12 = *(void **)(v11 + 24);
                }
                else {
                  uint64_t v12 = 0LL;
                }
                id v127 = v12;
                v125 = (char *)objc_claimAutoreleasedReturnValue([v127 tcpProxyFqdn]);
                id v123 = *v5;
                uint64_t v13 = objc_claimAutoreleasedReturnValue([v123 ingressProxy]);
                id v121 = (void *)v13;
                if (v13) {
                  uint64_t v14 = *(void **)(v13 + 24);
                }
                else {
                  uint64_t v14 = 0LL;
                }
                id v119 = v14;
                id v117 = (void *)objc_claimAutoreleasedReturnValue([v119 vendor]);
                id v115 = *v5;
                uint64_t v15 = objc_claimAutoreleasedReturnValue([v115 egressProxy]);
                uint64_t v16 = (void *)v15;
                if (v15) {
                  uint64_t v17 = *(void **)(v15 + 24);
                }
                else {
                  uint64_t v17 = 0LL;
                }
                id v113 = v17;
                uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v113 tcpProxyFqdn]);
                id v19 = *v5;
                uint64_t v20 = objc_claimAutoreleasedReturnValue([v19 egressProxy]);
                uint64_t v21 = (void *)v20;
                if (v20) {
                  uint64_t v22 = *(void **)(v20 + 24);
                }
                else {
                  uint64_t v22 = 0LL;
                }
                id v23 = v22;
                id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 vendor]);
                *(_DWORD *)__int128 buf = 138413058;
                v138 = v125;
                __int16 v139 = 2112;
                v140 = v117;
                __int16 v141 = 2112;
                v142 = v18;
                __int16 v143 = 2112;
                v144 = v24;
                _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Setting fallback proxy path (%@[%@]-%@[%@])",  buf,  0x2Au);
              }

              sub_10002BB90((uint64_t)a1, v25, v26);
            }

            else
            {
              id v38 = *v5;
              uint64_t v39 = objc_claimAutoreleasedReturnValue([v38 ingressProxy]);
              uint64_t v40 = (void *)v39;
              if (v39) {
                uint64_t v41 = *(void **)(v39 + 24);
              }
              else {
                uint64_t v41 = 0LL;
              }
              id v42 = v41;

              id v43 = *v5;
              uint64_t v44 = objc_claimAutoreleasedReturnValue([v43 egressProxy]);
              id v45 = (void *)v44;
              if (v44) {
                id v46 = *(void **)(v44 + 24);
              }
              else {
                id v46 = 0LL;
              }
              id v47 = v46;

              id v48 = *v5;
              id v49 = (void *)objc_claimAutoreleasedReturnValue([v48 ingressProxy]);
              v135[0] = _NSConcreteStackBlock;
              v135[1] = 3221225472LL;
              v135[2] = sub_10002BFBC;
              v135[3] = &unk_1000F9720;

              id v136 = v42;
              id v50 = v42;
              sub_10000CF58((uint64_t)v49, v135);

              id v51 = *v5;
              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 egressProxy]);
              v133[0] = _NSConcreteStackBlock;
              v133[1] = 3221225472LL;
              v133[2] = sub_10002C0A0;
              v133[3] = &unk_1000F9720;

              id v134 = v47;
              id v53 = v47;
              sub_10000CF58((uint64_t)v52, v133);
            }

            sub_100029DC4(a1);
            [a1 updateUserEventAgentData];
            sub_10002AB04((uint64_t)a1);
            goto LABEL_60;
          }

          *(_DWORD *)__int128 buf = 136315138;
          v138 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
          uint64_t v106 = "%s called with null egressFallbackProxyTokenInfo";
        }

        else
        {
          uint64_t v105 = nplog_obj(v75, v76, v77);
          __int128 v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
          if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
            goto LABEL_70;
          }
          *(_DWORD *)__int128 buf = 136315138;
          v138 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
          uint64_t v106 = "%s called with null ingressFallbackProxyTokenInfo";
        }

        _os_log_fault_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_FAULT, v106, buf, 0xCu);
        goto LABEL_70;
      }

      uint64_t v103 = nplog_obj(v62, v63, v64);
      v104 = (os_log_s *)objc_claimAutoreleasedReturnValue(v103);
      if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        v138 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_FAULT,  "%s called with null egressFallbackProxyInfo",  buf,  0xCu);
      }
    }

    else
    {
      uint64_t v102 = nplog_obj(v62, v63, v64);
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(v102);
      if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        v138 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v59,  OS_LOG_TYPE_FAULT,  "%s called with null ingressFallbackProxyInfo",  buf,  0xCu);
      }
    }

    int v99 = 1;
    goto LABEL_55;
  }

  uint64_t v100 = nplog_obj(0LL, v56, v57);
  uint64_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue(v100);
  if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "no available fallback proxy path", buf, 2u);
  }

LABEL_60:
}

void sub_100027BE8(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSPProbeStats);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 tierString]);
  -[NSPProbeStats setTierType:](v2, "setTierType:", v3);

  -[NSPProbeStats setProbeReason:](v2, "setProbeReason:", *(void *)(a1 + 520));
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 368) interface]);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities getInterfaceTypeString:]( NPUtilities,  "getInterfaceTypeString:",  [v4 type]));
  -[NSPProbeStats setProbeInterface:](v2, "setProbeInterface:", v5);

  uint64_t v6 = *(void *)(a1 + 272);
  id v7 = *(id *)(a1 + 280);
  [v7 timeIntervalSinceDate:v6];
  -[NSPProbeStats setProbeDurationSec:](v2, "setProbeDurationSec:", (unint64_t)v8);

  uint64_t v9 = *(void *)(a1 + 240);
  if (v9) {
    uint64_t v10 = *(void *)(v9 + 64);
  }
  else {
    uint64_t v10 = 0LL;
  }
  -[NSPProbeStats setProxyProbeCount:](v2, "setProxyProbeCount:", v10);
  uint64_t v11 = *(void *)(a1 + 240);
  if (v11) {
    uint64_t v12 = *(void *)(v11 + 96);
  }
  else {
    uint64_t v12 = 0LL;
  }
  -[NSPProbeStats setProxyProbeSuccessCount:](v2, "setProxyProbeSuccessCount:", v12);
  uint64_t v13 = *(void *)(a1 + 240);
  if (v13) {
    uint64_t v14 = *(void *)(v13 + 104);
  }
  else {
    uint64_t v14 = 0LL;
  }
  -[NSPProbeStats setProxyProbeFailedCount:](v2, "setProxyProbeFailedCount:", v14);
  uint64_t v15 = *(void *)(a1 + 240);
  if (v15) {
    uint64_t v16 = *(void *)(v15 + 112);
  }
  else {
    uint64_t v16 = 0LL;
  }
  -[NSPProbeStats setProxyProbeRedirectedCount:](v2, "setProxyProbeRedirectedCount:", v16);
  uint64_t v17 = *(void *)(a1 + 240);
  if (v17) {
    uint64_t v18 = *(void *)(v17 + 120);
  }
  else {
    uint64_t v18 = 0LL;
  }
  -[NSPProbeStats setProxyProbeServerErrorCount:](v2, "setProxyProbeServerErrorCount:", v18);
  uint64_t v19 = *(void *)(a1 + 248);
  if (v19) {
    uint64_t v20 = *(void *)(v19 + 64);
  }
  else {
    uint64_t v20 = 0LL;
  }
  -[NSPProbeStats setDirectProbeCount:](v2, "setDirectProbeCount:", v20);
  uint64_t v21 = *(void *)(a1 + 248);
  if (v21) {
    uint64_t v22 = *(void *)(v21 + 96);
  }
  else {
    uint64_t v22 = 0LL;
  }
  -[NSPProbeStats setDirectProbeSuccessCount:](v2, "setDirectProbeSuccessCount:", v22);
  uint64_t v23 = *(void *)(a1 + 248);
  if (v23) {
    uint64_t v24 = *(void *)(v23 + 104);
  }
  else {
    uint64_t v24 = 0LL;
  }
  -[NSPProbeStats setDirectProbeFailedCount:](v2, "setDirectProbeFailedCount:", v24);
  uint64_t v25 = *(void *)(a1 + 248);
  if (v25) {
    uint64_t v26 = *(void *)(v25 + 112);
  }
  else {
    uint64_t v26 = 0LL;
  }
  -[NSPProbeStats setDirectProbeRedirectedCount:](v2, "setDirectProbeRedirectedCount:", v26);
  uint64_t v27 = *(void *)(a1 + 248);
  if (v27) {
    uint64_t v28 = *(void *)(v27 + 120);
  }
  else {
    uint64_t v28 = 0LL;
  }
  -[NSPProbeStats setDirectProbeServerErrorCount:](v2, "setDirectProbeServerErrorCount:", v28);
  -[NSPProxyAnalytics sendAnalytics](v2, "sendAnalytics");

  id v29 = *(void **)(a1 + 248);
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;

  uint64_t v30 = *(void **)(a1 + 240);
  *(void *)(a1 + 240) = 0LL;

  id v31 = *(void **)(a1 + 272);
  *(void *)(a1 + 272) = 0LL;

  unsigned int v32 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = 0LL;

  *(void *)(a1 + 520) = 0LL;
}

void sub_100027E08(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 536), a2);
  }
}

void sub_100027E18(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v4 = *(id *)(a1 + 344);
    id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v12;
      do
      {
        for (i = 0LL; i != v6; i = (char *)i + 1)
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8LL * (void)i);
          objc_msgSend(v9, "resetError", (void)v11);
          if (v3) {
            [v9 handleNetworkCharacteristicsChange:v3];
          }
          else {
            [v9 resetStats];
          }
        }

        id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }

      while (v6);
    }

    uint64_t v10 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = 0LL;

    sub_10002D130(a1);
  }
}

LABEL_10:
    -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
    return;
  }

  if (a3)
  {
    __int128 v14 = 0LL;
    goto LABEL_10;
  }

    ++v9[2];
LABEL_11:

    if (!self)
    {
      id WeakRetained = 0LL;
      goto LABEL_13;
    }
  }

  __int128 v12 = 0LL;
LABEL_11:

  return v12;
}
}

    uint64_t v15 = (void *)v30[5];
    goto LABEL_11;
  }

  __int128 v13 = objc_alloc_init(&OBJC_CLASS___NEPolicySession);
  __int128 v14 = (void *)v30[5];
  void v30[5] = (uint64_t)v13;

  [(id)v30[5] setPriority:a3];
  uint64_t v15 = (void *)v30[5];
  if (v15)
  {
    uint64_t v16 = objc_alloc(&OBJC_CLASS___NEPolicySessionFileHandle);
    __int128 v12 = (os_log_s *)[v16 initWithPolicySession:v30[5] name:v7];
    if (v12)
    {
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      v24[2] = sub_100093740;
      v24[3] = &unk_1000F9370;
      uint64_t v25 = (os_log_s *)v7;
      [v19 setFileHandle:v12 matchingPredicate:v24];

      uint64_t v20 = v25;
    }

    else
    {
      uint64_t v21 = nplog_obj(0LL, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v36 = a1;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "%@ failed to create a policy session",  buf,  0xCu);
      }
    }

    goto LABEL_10;
  }

    goto LABEL_11;
  }

  uint64_t v7 = v11;
  if (!v11) {
    goto LABEL_10;
  }
  id v6 = 0LL;
  captiveNetworkExceptionHostname = 0LL;
LABEL_4:
  uint64_t v9 = captiveNetworkExceptionHostname;
  uint64_t v10 = -[NSString isEqualToString:](v9, "isEqualToString:", v11);

  if ((v10 & 1) == 0)
  {
    if (v5) {
      objc_storeStrong((id *)&v5->_captiveNetworkExceptionHostname, a3);
    }
    sub_100095848(v5);
  }

    uint64_t v10 = 0LL;
    goto LABEL_4;
  }

  uint64_t v10 = v7;
  objc_setProperty_atomic(v7, v8, v6, 56LL);
LABEL_4:

  return v10;
}

void sub_1000285F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Token issuance limit timer fired", buf, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      double v8 = *(dispatch_source_s **)(v7 + 360);
    }
    else {
      double v8 = 0LL;
    }
    dispatch_source_cancel(v8);
    sub_100024240(*(void *)(a1 + 32));
    sub_10001F910(*(void *)(a1 + 32), 0LL);
    *(void *)__int128 buf = 0LL;
    uint64_t v20 = buf;
    uint64_t v21 = 0x3032000000LL;
    uint64_t v22 = sub_10000CED4;
    uint64_t v23 = sub_10000CEE4;
    id v24 = (id)os_transaction_create("com.apple.networkserviceproxy.tokenIssuanceTimerFired");
    id v9 = WeakRetained[11];
    id v10 = WeakRetained[12];
    id v11 = WeakRetained[13];
    id v12 = WeakRetained[15];
    id v13 = WeakRetained[17];
    id v14 = WeakRetained[19];
    [WeakRetained updateProxyInfo:v9 resolverInfo:v10 proxyPathList:v11 fallbackProxyPathList:v12 obliviousConfigs:v13 proxiedContentMaps:v14];

    uint64_t v16 = NPGetInternalQueue(v15);
    uint64_t v17 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v16);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_1000287E8;
    v18[3] = &unk_1000F9428;
    void v18[4] = *(void *)(a1 + 32);
    v18[5] = buf;
    dispatch_async(v17, v18);

    _Block_object_dispose(buf, 8);
  }
}

void sub_1000287D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000287E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained tokenIssuanceAllowed];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

uint64_t sub_10002883C(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5) {
    uint64_t v7 = (void *)v5[3];
  }
  else {
    uint64_t v7 = 0LL;
  }
  id v8 = [v7 proxyHop];
  if ((_DWORD)v8 != 2)
  {
    uint64_t v29 = nplog_obj(v8, v9, v10);
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v38 = "-[NSPPrivacyProxyAgentManager alternateEgressProxyExists:proxyPathEnumerator:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "%s called with null (proxyTokenInfo.proxyInfo.proxyHop == NSPPrivacyProxyProxyInfo_ProxyHop_EGRESS_ONLY)",  buf,  0xCu);
    }

    goto LABEL_26;
  }

  if (v5) {
    id v11 = (void *)v5[3];
  }
  else {
    id v11 = 0LL;
  }
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 proxyURL]);
  id v13 = (void *)objc_claimAutoreleasedReturnValue([a1 overridePreferredProxy]);
  unsigned __int8 v14 = [v12 isEqualToString:v13];

  if ((v14 & 1) == 0)
  {
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    uint64_t v16 = (os_log_s *)v6;
    id v17 = -[os_log_s countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
    if (v17)
    {
      id v18 = v17;
      id v31 = v6;
      uint64_t v19 = *(void *)v33;
LABEL_10:
      uint64_t v20 = 0LL;
      while (1)
      {
        if (*(void *)v33 != v19) {
          objc_enumerationMutation(v16);
        }
        uint64_t v21 = *(void **)(*((void *)&v32 + 1) + 8 * v20);
        if ([v21 weight])
        {
          id v22 = a1[11];

          id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 proxyURL]);
          uint64_t v25 = v5 ? (void *)v5[3] : 0LL;
          uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 proxyURL]);
          unsigned int v27 = [v24 isEqualToString:v26];

          if (!v27) {
            break;
          }
        }

        if (v18 == (id)++v20)
        {
          id v28 = -[os_log_s countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
          id v18 = v28;
          if (!v28)
          {
            uint64_t v15 = 0LL;
            goto LABEL_23;
          }

          goto LABEL_10;
        }
      }

      uint64_t v15 = 1LL;
LABEL_23:
      id v6 = v31;
      goto LABEL_27;
    }

void sub_100028AB8(id *a1, void *a2)
{
  id v3 = a2;
  if (a1 && sub_10002883C(a1, v3, a1[14]))
  {
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id obj = a1[14];
    id v4 = [obj countByEnumeratingWithState:&v22 objects:v28 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v23;
      while (2)
      {
        for (i = 0LL; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v23 != v6) {
            objc_enumerationMutation(obj);
          }
          id v8 = *(void **)(*((void *)&v22 + 1) + 8LL * (void)i);
          id v9 = a1[11];

          id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 proxyURL]);
          id v12 = (void *)objc_claimAutoreleasedReturnValue([v3[3] proxyURL]);
          unsigned int v13 = [v11 isEqualToString:v12];

          if (v13)
          {
            uint64_t v17 = nplog_obj(v14, v15, v16);
            id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              id v19 = v3[3];
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 vendor]);
              *(_DWORD *)__int128 buf = 138412290;
              unsigned int v27 = v20;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "remove %@ from proxy path enumerator",  buf,  0xCu);
            }

            [a1[14] removeObject:v8];
            goto LABEL_15;
          }
        }

        id v5 = [obj countByEnumeratingWithState:&v22 objects:v28 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

void sub_100028CC8(id *a1, void *a2)
{
  id v3 = a2;
  if (a1 && sub_10002883C(a1, v3, a1[16]))
  {
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id obj = a1[16];
    id v4 = [obj countByEnumeratingWithState:&v22 objects:v28 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v23;
      while (2)
      {
        for (i = 0LL; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v23 != v6) {
            objc_enumerationMutation(obj);
          }
          id v8 = *(void **)(*((void *)&v22 + 1) + 8LL * (void)i);
          id v9 = a1[11];

          id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 proxyURL]);
          id v12 = (void *)objc_claimAutoreleasedReturnValue([v3[3] proxyURL]);
          unsigned int v13 = [v11 isEqualToString:v12];

          if (v13)
          {
            uint64_t v17 = nplog_obj(v14, v15, v16);
            id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              id v19 = v3[3];
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 vendor]);
              *(_DWORD *)__int128 buf = 138412290;
              unsigned int v27 = v20;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "remove %@ from proxy path enumerator",  buf,  0xCu);
            }

            [a1[16] removeObject:v8];
            goto LABEL_15;
          }
        }

        id v5 = [obj countByEnumeratingWithState:&v22 objects:v28 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

id sub_100028ED8(void *a1)
{
  id v1 = a1;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  id v2 = [v1 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (!v2) {
    goto LABEL_19;
  }
  id v3 = v2;
  int v4 = 0;
  uint64_t v5 = *(void *)v22;
  do
  {
    for (i = 0LL; i != v3; i = (char *)i + 1)
    {
      if (*(void *)v22 != v5) {
        objc_enumerationMutation(v1);
      }
      v4 += [*(id *)(*((void *)&v21 + 1) + 8 * (void)i) weight];
    }

    id v3 = [v1 countByEnumeratingWithState:&v21 objects:v26 count:16];
  }

  while (v3);
  if (v4)
  {
    do
      uint32_t v7 = arc4random_uniform(v4 + 1);
    while (!v7);
    uint32_t v8 = v7;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v9 = v1;
    id v10 = [v9 countByEnumeratingWithState:&v17 objects:v25 count:16];
    if (v10)
    {
      unint64_t v11 = 0LL;
      uint64_t v12 = *(void *)v18;
      unint64_t v13 = v8;
      while (2)
      {
        for (j = 0LL; j != v10; j = (char *)j + 1)
        {
          if (*(void *)v18 != v12) {
            objc_enumerationMutation(v9);
          }
          uint64_t v15 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)j);
          v11 += objc_msgSend(v15, "weight", (void)v17);
          if (v11 >= v13)
          {
            id v10 = v15;
            goto LABEL_21;
          }
        }

        id v10 = [v9 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

id sub_1000290A4(id *a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = (void *)objc_claimAutoreleasedReturnValue([a1 overridePreferredProxy]);

  if (v2)
  {
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id obj = a1[15];
    id v19 = [obj countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v19)
    {
      uint64_t v18 = *(void *)v21;
LABEL_5:
      uint64_t v3 = 0LL;
      while (1)
      {
        if (*(void *)v21 != v18) {
          objc_enumerationMutation(obj);
        }
        int v4 = *(void **)(*((void *)&v20 + 1) + 8 * v3);
        id v5 = a1[11];
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndex:", *(unsigned int *)objc_msgSend(v4, "proxies")));

        id v7 = a1[11];
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyURL]);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([a1 overridePreferredProxy]);
        unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v8 proxyURL]);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([a1 overridePreferredProxy]);
        unsigned __int8 v13 = [v11 isEqualToString:v12];

        if ((v13 & 1) != 0) {
          goto LABEL_14;
        }

        if (v19 == (id)++v3)
        {
          id v19 = [obj countByEnumeratingWithState:&v20 objects:v24 count:16];
          if (v19) {
            goto LABEL_5;
          }
          goto LABEL_12;
        }
      }

LABEL_14:
      id v14 = v4;

      if (v14) {
        return v14;
      }
    }

    else
    {
LABEL_12:
    }
  }

  id v15 = sub_100028ED8(a1[16]);
  id v14 = (id)objc_claimAutoreleasedReturnValue(v15);
  return v14;
}

id *sub_1000292DC(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v29 = v6;
  if (!a1) {
    goto LABEL_17;
  }
  if (!v5)
  {
    uint64_t v26 = nplog_obj(v6, v7, v8);
    id obj = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (!os_log_type_enabled(obj, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v38 = "-[NSPPrivacyProxyAgentManager proxyPathWithIngressProxyURL:egressProxyURL:]";
    unsigned int v27 = "%s called with null ingressProxyURL";
    goto LABEL_22;
  }

  if (v6)
  {
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    id obj = (os_log_s *)a1[13];
    id v9 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v33;
      do
      {
        for (i = 0LL; i != v10; i = (char *)i + 1)
        {
          if (*(void *)v33 != v11) {
            objc_enumerationMutation(obj);
          }
          unsigned __int8 v13 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)i);
          id v14 = a1[11];
          id v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectAtIndex:", *(unsigned int *)objc_msgSend(v13, "proxies")));

          id v16 = a1[11];
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v15 proxyURL]);
          if ([v18 isEqualToString:v5])
          {
            id v31 = v15;
            id v19 = a1;
            id v20 = v10;
            uint64_t v21 = v11;
            id v22 = v5;
            __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v17 proxyURL]);
            unsigned int v24 = [v23 isEqualToString:v29];

            id v5 = v22;
            uint64_t v11 = v21;
            id v10 = v20;
            a1 = v19;
            id v15 = v31;

            if (v24)
            {
              a1 = v13;

              goto LABEL_16;
            }
          }

          else
          {
          }
        }

        id v10 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
      }

      while (v10);
    }

    goto LABEL_15;
  }

  uint64_t v28 = nplog_obj(0LL, v7, v8);
  id obj = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(obj, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    id v38 = "-[NSPPrivacyProxyAgentManager proxyPathWithIngressProxyURL:egressProxyURL:]";
    unsigned int v27 = "%s called with null egressProxyURL";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, obj, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
  }

id *sub_100029598(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v29 = v6;
  if (!a1) {
    goto LABEL_17;
  }
  if (!v5)
  {
    uint64_t v26 = nplog_obj(v6, v7, v8);
    id obj = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (!os_log_type_enabled(obj, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v38 = "-[NSPPrivacyProxyAgentManager fallbackProxyPathWithIngressProxyURL:egressProxyURL:]";
    unsigned int v27 = "%s called with null ingressProxyURL";
    goto LABEL_22;
  }

  if (v6)
  {
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    id obj = (os_log_s *)a1[15];
    id v9 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v33;
      do
      {
        for (i = 0LL; i != v10; i = (char *)i + 1)
        {
          if (*(void *)v33 != v11) {
            objc_enumerationMutation(obj);
          }
          unsigned __int8 v13 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)i);
          id v14 = a1[11];
          id v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectAtIndex:", *(unsigned int *)objc_msgSend(v13, "proxies")));

          id v16 = a1[11];
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v15 proxyURL]);
          if ([v18 isEqualToString:v5])
          {
            id v31 = v15;
            id v19 = a1;
            id v20 = v10;
            uint64_t v21 = v11;
            id v22 = v5;
            __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v17 proxyURL]);
            unsigned int v24 = [v23 isEqualToString:v29];

            id v5 = v22;
            uint64_t v11 = v21;
            id v10 = v20;
            a1 = v19;
            id v15 = v31;

            if (v24)
            {
              a1 = v13;

              goto LABEL_16;
            }
          }

          else
          {
          }
        }

        id v10 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
      }

      while (v10);
    }

    goto LABEL_15;
  }

  uint64_t v28 = nplog_obj(0LL, v7, v8);
  id obj = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(obj, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    id v38 = "-[NSPPrivacyProxyAgentManager fallbackProxyPathWithIngressProxyURL:egressProxyURL:]";
    unsigned int v27 = "%s called with null egressProxyURL";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, obj, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
  }

void sub_100029854(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Proxy path restore timer fired", v14, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    id v8 = WeakRetained[13];
    id v9 = [v8 mutableCopy];
    id v10 = *(void **)(v7 + 112);
    *(void *)(v7 + 112) = v9;

    id v11 = *(id *)(v7 + 120);
    id v12 = [v11 mutableCopy];
    unsigned __int8 v13 = *(void **)(v7 + 128);
    *(void *)(v7 + 12_Block_object_dispose(va, 8) = v12;

    sub_100027E18(v7, 0LL);
  }
}

NSPProxyTokenInfo *sub_10002991C(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (!v6)
  {
    uint64_t v35 = nplog_obj(0LL, v4, v5);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v45 = "-[NSPPrivacyProxyAgentManager getProxyTokenInfoForProxyInfo:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%s called with null proxyInfo", buf, 0xCu);
    }

    goto LABEL_27;
  }

  id obj = a2;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  uint64_t v7 = (os_log_s *)*(id *)(a1 + 352);
  id v8 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v39,  v43,  16LL);
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v40;
    do
    {
      id v11 = 0LL;
      do
      {
        if (*(void *)v40 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)v11);
        if (v12) {
          unsigned __int8 v13 = (void *)v12[3];
        }
        else {
          unsigned __int8 v13 = 0LL;
        }
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 proxyURL]);
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyURL]);
        unsigned __int8 v16 = [v14 isEqualToString:v15];

        if ((v16 & 1) != 0)
        {
          __int128 v32 = v12;
          goto LABEL_20;
        }

        id v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v17 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v39,  v43,  16LL);
      id v9 = v17;
    }

    while (v17);
  }

  uint64_t v18 = objc_alloc(&OBJC_CLASS___NSPProxyTokenInfo);
  id v19 = *(void **)(a1 + 368);
  char v20 = *(_BYTE *)(a1 + 13);
  char v21 = *(_BYTE *)(a1 + 12);
  id v22 = (id)a1;
  id v23 = v6;
  id v24 = v19;
  if (v18)
  {
    __int128 v25 = -[NSPProxyTokenInfo init](v18, "init");
    uint64_t v18 = v25;
    if (v25)
    {
      objc_storeWeak((id *)&v25->_delegate, v22);
      objc_storeStrong((id *)&v18->_proxyInfo, obj);
      objc_storeStrong((id *)&v18->_tokenPath, v19);
      v18->_subscriber = v20;
      v18->_useDefaultInterface = v21;
      id v26 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v18->_tokenPath);
      uint64_t v27 = objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:@"Signature"]);
      networkSignature = v18->_networkSignature;
      v18->_networkSignature = (NSData *)v27;
    }
  }

  if (!v18)
  {
    uint64_t v36 = nplog_obj(v29, v30, v31);
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v45 = "-[NSPPrivacyProxyAgentManager getProxyTokenInfoForProxyInfo:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "%s called with null proxyTokenInfo",  buf,  0xCu);
    }

    uint64_t v7 = 0LL;
LABEL_27:
    __int128 v33 = 0LL;
    goto LABEL_21;
  }

  [*(id *)(a1 + 352) addObject:v18];
  sub_10000CAB4((uint64_t)v18);
  __int128 v32 = v18;
  uint64_t v7 = (os_log_s *)v32;
LABEL_20:
  __int128 v33 = v32;
LABEL_21:

  return v33;
}

void *sub_100029C28(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v4 = *(id *)(a1 + 352);
  id v5 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v19;
    do
    {
      id v8 = 0LL;
      do
      {
        if (*(void *)v19 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)v8);
        if (v9) {
          uint64_t v10 = (void *)v9[3];
        }
        else {
          uint64_t v10 = 0LL;
        }
        id v11 = v10;
        if (a2)
        {
          id v12 = v9 ? (void *)v9[3] : 0LL;
          id v2 = v12;
          if (([v2 supportsFallback] & 1) == 0)
          {

LABEL_19:
            goto LABEL_20;
          }
        }

        unint64_t v13 = sub_10000E688((uint64_t)v9);
        unint64_t v14 = sub_10000F2E8((uint64_t)v9);
        if (a2) {

        }
        if (v13 >= v14)
        {
          unsigned __int8 v16 = v9;
          goto LABEL_26;
        }

void sub_100029DC4(id *a1)
{
  if (a1)
  {
    id v54 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v85 = 0u;
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    __int128 v88 = 0u;
    id v2 = a1[44];
    id v3 = [v2 countByEnumeratingWithState:&v85 objects:v96 count:16];
    if (!v3) {
      goto LABEL_90;
    }
    id v4 = v3;
    uint64_t v5 = *(void *)v86;
    uint64_t v55 = *(void *)v86;
    id v56 = v2;
    while (1)
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v86 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v85 + 1) + 8LL * (void)v6);
        if (v7) {
          id v8 = *(void **)(v7 + 24);
        }
        else {
          id v8 = 0LL;
        }
        if ([v8 proxyHop] == 1)
        {
          id v9 = a1[26];
          id v10 = a1[27];
          id v11 = a1[28];
          unsigned __int8 v12 = [a1[29] matchIngress:v7];

          if ((v12 & 1) != 0) {
            goto LABEL_56;
          }
          __int128 v83 = 0u;
          __int128 v84 = 0u;
          __int128 v81 = 0u;
          __int128 v82 = 0u;
          id v13 = a1[38];
          id v14 = [v13 countByEnumeratingWithState:&v81 objects:v95 count:16];
          if (v14)
          {
            id v15 = v14;
            uint64_t v16 = *(void *)v82;
LABEL_16:
            uint64_t v17 = 0LL;
            while (1)
            {
              if (*(void *)v82 != v16) {
                objc_enumerationMutation(v13);
              }
              __int128 v18 = (void *)objc_claimAutoreleasedReturnValue( [a1[38] objectForKeyedSubscript:*(void *)(*((void *)&v81 + 1) + 8 * v17)]);
              unsigned __int8 v19 = [v18 matchIngress:v7];

              if ((v19 & 1) != 0) {
                goto LABEL_84;
              }
              if (v15 == (id)++v17)
              {
                id v15 = [v13 countByEnumeratingWithState:&v81 objects:v95 count:16];
                if (v15) {
                  goto LABEL_16;
                }
                break;
              }
            }
          }

          __int128 v79 = 0u;
          __int128 v80 = 0u;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          id v13 = a1[39];
          id v20 = [v13 countByEnumeratingWithState:&v77 objects:v94 count:16];
          if (v20)
          {
            id v21 = v20;
            uint64_t v22 = *(void *)v78;
LABEL_24:
            uint64_t v23 = 0LL;
            while (1)
            {
              if (*(void *)v78 != v22) {
                objc_enumerationMutation(v13);
              }
              id v24 = (void *)objc_claimAutoreleasedReturnValue( [a1[39] objectForKeyedSubscript:*(void *)(*((void *)&v77 + 1) + 8 * v23)]);
              unsigned __int8 v25 = [v24 matchIngress:v7];

              if ((v25 & 1) != 0) {
                goto LABEL_84;
              }
              if (v21 == (id)++v23)
              {
                id v21 = [v13 countByEnumeratingWithState:&v77 objects:v94 count:16];
                if (v21) {
                  goto LABEL_24;
                }
                break;
              }
            }
          }

          __int128 v75 = 0u;
          __int128 v76 = 0u;
          __int128 v73 = 0u;
          __int128 v74 = 0u;
          id v26 = a1[40];
          id v27 = [v26 countByEnumeratingWithState:&v73 objects:v93 count:16];
          uint64_t v5 = v55;
          if (v27)
          {
            id v28 = v27;
            uint64_t v29 = *(void *)v74;
LABEL_32:
            uint64_t v30 = 0LL;
            while (1)
            {
              if (*(void *)v74 != v29) {
                objc_enumerationMutation(v26);
              }
              if (v28 == (id)++v30)
              {
                id v28 = [v26 countByEnumeratingWithState:&v73 objects:v93 count:16];
                if (v28) {
                  goto LABEL_32;
                }
                goto LABEL_38;
              }
            }

LABEL_85:
LABEL_86:
            id v2 = v56;
            goto LABEL_56;
          }

LABEL_84:
              uint64_t v5 = v55;
              id v2 = v56;
              goto LABEL_56;
            }

              v109[11] = 0LL;
              goto LABEL_85;
            }

            v235 = self->_probingReason;
            uint64_t v23 = v605;
            if (v235 == 1) {
              goto LABEL_188;
            }
            if (!v235)
            {
              sub_100036E68((id *)&self->super.isa, @"ProxyPrimaryEgressError");
              sub_1000370F8((uint64_t)self, 1LL, v236);
              v237 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
              if (v237) {
                v237[11] = 0LL;
              }

              v238 = self->_quicProxyPath;
LABEL_218:
              unint64_t v109 = (void *)objc_claimAutoreleasedReturnValue([v238 networkSingleHopAgentStatistics]);
              if (!v109) {
                goto LABEL_85;
              }
              goto LABEL_84;
            }

            v302 = self->_quicProxyPath;
LABEL_314:
            [v302 resetError];
            goto LABEL_188;
          }

          v220 = nplog_obj(v94, v95, v96);
          v221 = (os_log_s *)objc_claimAutoreleasedReturnValue(v220);
          if (os_log_type_enabled(v221, OS_LOG_TYPE_INFO))
          {
            v607 = v23;
            v222 = self->_lastQuicProxySwitchedDate;
            v223 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v222,  1LL,  2LL));
            *(_DWORD *)__int128 buf = 138412290;
            v635 = (NWPathStatus)v223;
            v224 = "ignoring egress quic proxy error, last quic proxy switched date %@";
LABEL_186:
            _os_log_impl((void *)&_mh_execute_header, v221, OS_LOG_TYPE_INFO, v224, buf, 0xCu);

            uint64_t v23 = v607;
          }
}

void sub_10002A4AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = (id *)(a1 + 224);
  if (*(void *)(a1 + 224))
  {
    if (([(id)a1 forceFallback] & 1) == 0)
    {
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 208) egressProxy]);
      uint64_t v5 = *(void **)(a1 + 208);
      id v6 = &AnalyticsSendEventLazy_ptr;
      if (v5)
      {
        id v7 = *v3;
        id v8 = v5;
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v7 ingressProxy]);
        id v10 = *v3;
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 egressProxy]);
        id v12 = *v3;
        objc_msgSend( v8,  "updateIngressProxy:egressProxy:proxyPathWeight:",  v9,  v11,  objc_msgSend(v12, "proxyPathWeight"));
      }

      else
      {
        __int128 v41 = objc_alloc(&OBJC_CLASS___NSPQuicProxyPath);
        id v44 = *(id *)(a1 + 224);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v44 ingressProxy]);
        id v43 = *(id *)(a1 + 224);
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v43 egressProxy]);
        id v42 = *(id *)(a1 + 224);
        id v37 = [v42 proxyPathWeight];
        id v13 = *(void **)(a1 + 216);
        BOOL v14 = v13 != 0LL;
        id v40 = v13;
        unsigned __int8 v15 = [(id)a1 forceFallback];
        BOOL v16 = *(_BYTE *)(a1 + 13) == 0;
        char v17 = *(_BYTE *)(a1 + 15);
        __int128 v18 = *(void **)(a1 + 400);
        id v19 = *(id *)(a1 + 368);
        id v20 = v18;
        id v21 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v19);
        BYTE2(v36) = v17;
        BYTE1(v36) = v16;
        LOBYTE(v36) = v15;
        uint64_t v22 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:]( v41,  "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:all owFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:",  a1,  v39,  v38,  v37,  v14,  0LL,  v36,  v20,  v21);
        objc_storeStrong((id *)(a1 + 208), v22);

        id v6 = &AnalyticsSendEventLazy_ptr;
        [*(id *)(a1 + 208) resetSingleHopProxyAgent];
        [*(id *)(a1 + 208) resetMultiHopProxyAgent];
      }

      if (v45) {
        uint64_t v23 = (void *)v45[3];
      }
      else {
        uint64_t v23 = 0LL;
      }
      id v24 = v23;
      unsigned __int8 v25 = (void *)objc_claimAutoreleasedReturnValue([v24 vendor]);
      id v26 = *(id *)(a1 + 208);
      id v27 = (void *)objc_claimAutoreleasedReturnValue([v26 egressProxy]);
      id v28 = v27;
      if (v27) {
        id v27 = (void *)v27[3];
      }
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 vendor]);
      unint64_t v30 = v25;
      unint64_t v31 = v29;
      id v32 = (void *)v31;
      if (!(v30 | v31) || v30 && v31 && [(id)v30 isEqual:v31])
      {
      }

      else
      {

        id v24 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
        unint64_t v30 = *(void *)(a1 + 288);
        *(void *)(a1 + 28_Block_object_dispose(va, 8) = v24;
      }

      [*(id *)(a1 + 208) resetStats];
      [*(id *)(a1 + 208) resetError];
      ++*(void *)(a1 + 480);
      ++*(void *)(a1 + 496);
      objc_storeStrong(v3, 0LL);
      [(id)a1 tokensEmpty];
      uint64_t v33 = v6[89];
      ++*(void *)(a1 + 544);
      objc_msgSend(v33, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-path-changed");
    }
  }

  else
  {
    uint64_t v34 = nplog_obj(a1, a2, a3);
    uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v47 = "-[NSPPrivacyProxyAgentManager setupQuicProxyPath]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "%s called with null self.candidateQuicProxyPath",  buf,  0xCu);
    }
  }

void sub_10002A8E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained refreshProxyInfo:9];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

void sub_10002A93C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002AA20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002AB04(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setValue:forKey:](v2, "setValue:forKey:", &off_100103350, @"Version");
    int v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v4 = *(void **)(a1 + 208);
    if (v4)
    {
      id v5 = v4;
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 ingressProxy]);
      uint64_t v7 = v6;
      if (v6) {
        id v6 = (void *)v6[3];
      }
      id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 proxyURL]);
      -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", v8, @"IngressProxyURL");

      id v9 = *(id *)(a1 + 208);
      int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 egressProxy]);
      uint64_t v11 = v10;
      if (v10) {
        int v10 = (void *)v10[3];
      }
      __int16 v12 = (void *)objc_claimAutoreleasedReturnValue([v10 proxyURL]);
      -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", v12, @"EgressProxyURL");
    }

    id v13 = *(void **)(a1 + 216);
    if (v13)
    {
      id v14 = v13;
      unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([v14 ingressProxy]);
      BOOL v16 = v15;
      if (v15) {
        unsigned __int8 v15 = (void *)v15[3];
      }
      char v17 = (void *)objc_claimAutoreleasedReturnValue([v15 proxyURL]);
      -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", v17, @"IngressFallbackProxyURL");

      id v18 = *(id *)(a1 + 216);
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 egressProxy]);
      id v20 = v19;
      if (v19) {
        id v19 = (void *)v19[3];
      }
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v19 proxyURL]);
      -[NSMutableDictionary setValue:forKey:](v3, "setValue:forKey:", v21, @"EgressFallbackProxyURL");
    }

    if (-[NSMutableDictionary count](v3, "count")) {
      -[NSMutableDictionary setValue:forKey:](v2, "setValue:forKey:", v3, @"ConfiguredProxies");
    }
    __int128 v86 = v3;
    __int128 v87 = v2;
    uint64_t v22 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v93 = 0u;
    __int128 v94 = 0u;
    __int128 v95 = 0u;
    __int128 v96 = 0u;
    id v23 = *(id *)(a1 + 312);
    id v24 = [v23 countByEnumeratingWithState:&v93 objects:v100 count:16];
    if (v24)
    {
      id v25 = v24;
      uint64_t v26 = *(void *)v94;
      do
      {
        for (i = 0LL; i != v25; i = (char *)i + 1)
        {
          if (*(void *)v94 != v26) {
            objc_enumerationMutation(v23);
          }
          uint64_t v28 = *(void *)(*((void *)&v93 + 1) + 8LL * (void)i);
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 312) objectForKeyedSubscript:v28]);
          unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 domainFilter]);

          if (v30)
          {
            unint64_t v31 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            id v32 = (void *)objc_claimAutoreleasedReturnValue([v29 preferredPathConfigURI]);
            -[NSMutableDictionary setValue:forKey:](v31, "setValue:forKey:", v32, @"PreferredPathConfigURL");

            uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v29 domainFilter]);
            -[NSMutableDictionary setValue:forKey:](v31, "setValue:forKey:", v33, @"DomainFilter");

            -[NSMutableDictionary setValue:forKey:](v31, "setValue:forKey:", v28, @"Vendor");
            -[NSMutableArray addObject:](v22, "addObject:", v31);
          }
        }

        id v25 = [v23 countByEnumeratingWithState:&v93 objects:v100 count:16];
      }

      while (v25);
    }

    uint64_t v34 = v87;
    if (-[NSMutableArray count](v22, "count")) {
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v22, @"PreferredPaths");
    }
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);

    if (v35)
    {
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredProxy]);
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v36, @"OverridePreferredProxy");
    }

    id v37 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredObliviousProxy]);

    if (v37)
    {
      id v38 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overridePreferredObliviousProxy]);
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v38, @"OverridePreferredObliviousProxy");
    }

    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxy]);

    if (v39)
    {
      id v40 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxy]);
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v40, @"OverrideIngressProxy");
    }

    __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideFallbackIngressProxy]);

    if (v41)
    {
      id v42 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideFallbackIngressProxy]);
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v42, @"OverrideFallbackIngressProxy");
    }

    id v43 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxyKey]);

    if (v43)
    {
      id v44 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 overrideIngressProxyKey]);
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v44, @"OverrideIngressProxyKey");
    }

    uint64_t v45 = *(void *)(a1 + 160);
    if (v45) {
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v45, @"OverrideEnabledMaps");
    }
    if (*(_BYTE *)(a1 + 11))
    {
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setValue:forKey:](v87, "setValue:forKey:", v46, @"DisableProxiedContentDoHBootstrap");
    }

    id v47 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    unsigned __int8 v48 = *(void **)(a1 + 328);
    if (v48)
    {
      __int128 v85 = v22;
      __int128 v91 = 0u;
      __int128 v92 = 0u;
      __int128 v89 = 0u;
      __int128 v90 = 0u;
      id v49 = v48;
      id v50 = [v49 countByEnumeratingWithState:&v89 objects:v99 count:16];
      if (v50)
      {
        id v51 = v50;
        uint64_t v52 = *(void *)v90;
        id v53 = v47;
        do
        {
          for (j = 0LL; j != v51; j = (char *)j + 1)
          {
            if (*(void *)v90 != v52) {
              objc_enumerationMutation(v49);
            }
            uint64_t v55 = *(void *)(*((void *)&v89 + 1) + 8LL * (void)j);
            id v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 328), "objectForKey:", v55, v85, v86));

            if (v56)
            {
              __int128 v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 328) objectForKey:v55]);
              __int128 v58 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              __int128 v59 = (void *)objc_claimAutoreleasedReturnValue([v57 ingressProxy]);
              __int128 v60 = v59;
              if (v59) {
                __int128 v59 = (void *)v59[3];
              }
              __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v59 vendor]);
              -[NSMutableDictionary setValue:forKey:](v58, "setValue:forKey:", v61, @"NetworkSpecificProxyVendor");

              __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v57 ingressProxy]);
              __int128 v63 = v62;
              if (v62) {
                __int128 v62 = (void *)v62[3];
              }
              __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([v62 proxyURL]);
              -[NSMutableDictionary setValue:forKey:]( v58,  "setValue:forKey:",  v64,  @"NetworkSpecificIngressProxyURL");

              __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([v57 egressProxy]);
              __int128 v66 = v65;
              if (v65) {
                __int128 v65 = (void *)v65[3];
              }
              __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v65 proxyURL]);
              -[NSMutableDictionary setValue:forKey:]( v58,  "setValue:forKey:",  v67,  @"NetworkSpecificEgressProxyURL");

              id v47 = v53;
              -[NSMutableArray addObject:](v53, "addObject:", v58);
            }
          }

          id v51 = [v49 countByEnumeratingWithState:&v89 objects:v99 count:16];
        }

        while (v51);
      }

      uint64_t v34 = v87;
      uint64_t v22 = v85;
    }

    if (-[NSMutableArray count](v47, "count", v85)) {
      -[NSMutableDictionary setValue:forKey:](v34, "setValue:forKey:", v47, @"NetworkSpecificPaths");
    }
    __int128 v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [(id)a1 forceFallback]));
    -[NSMutableDictionary setValue:forKey:](v34, "setValue:forKey:", v68, @"ForceFallback");

    id v88 = 0LL;
    __int128 v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v34,  1LL,  &v88));
    id v70 = v88;
    __int128 v73 = v70;
    if (!v69 || v70)
    {
      uint64_t v81 = nplog_obj(v70, v71, v72);
      __int128 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
      if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v98 = v73;
      __int128 v82 = "archivedDataWithRootObject failed with error: %@";
      __int128 v83 = v80;
      uint32_t v84 = 12;
    }

    else
    {
      _CFPreferencesSetFileProtectionClass( kCFPreferencesCurrentApplication,  kCFPreferencesCurrentUser,  kCFPreferencesCurrentHost,  0LL,  3LL);
      CFPreferencesSetAppValue(@"NSPProxyAgentManagerPreferences", v69, kCFPreferencesCurrentApplication);
      uint64_t v74 = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
      int v75 = v74;
      uint64_t v78 = nplog_obj(v74, v76, v77);
      __int128 v79 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);
      __int128 v80 = v79;
      if (v75)
      {
        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "Saved proxy agent information to preference file",  buf,  2u);
        }

        goto LABEL_68;
      }

      if (!os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
      {
LABEL_68:

        return;
      }

      *(_WORD *)__int128 buf = 0;
      __int128 v82 = "Failed to write configured proxies to preference file";
      __int128 v83 = v80;
      uint32_t v84 = 2;
    }

    _os_log_error_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, v82, buf, v84);
    goto LABEL_68;
  }

void sub_10002B398(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = *(void **)(a1 + 312);
  if (!v6)
  {
    uint64_t v28 = nplog_obj(0LL, v4, v5);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    if (!os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_FAULT))
    {
LABEL_14:

      goto LABEL_10;
    }

    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v36 = "-[NSPPrivacyProxyAgentManager setupPreferredQUICProxyPathForVendor:]";
    unint64_t v30 = "%s called with null self.candidatePreferredQUICProxyPaths";
LABEL_16:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v29, OS_LOG_TYPE_FAULT, v30, buf, 0xCu);
    goto LABEL_14;
  }

  if (!v3)
  {
    uint64_t v31 = nplog_obj(v6, v4, v5);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v31);
    if (!os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v36 = "-[NSPPrivacyProxyAgentManager setupPreferredQUICProxyPathForVendor:]";
    unint64_t v30 = "%s called with null vendor";
    goto LABEL_16;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v3]);
  id v8 = *(void **)(a1 + 304);
  if (!v8)
  {
    id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    int v10 = *(void **)(a1 + 304);
    *(void *)(a1 + 304) = v9;

    id v8 = *(void **)(a1 + 304);
  }

  uint64_t v11 = objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v3]);
  __int16 v12 = &AnalyticsSendEventLazy_ptr;
  if (v11)
  {
    id v13 = (void *)v11;
    id v14 = (NSPQuicProxyPath *)objc_claimAutoreleasedReturnValue([v7 ingressProxy]);
    unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([v7 egressProxy]);
    objc_msgSend(v13, "updateIngressProxy:egressProxy:proxyPathWeight:", v14, v15, objc_msgSend(v7, "proxyPathWeight"));
  }

  else
  {
    uint64_t v34 = objc_alloc(&OBJC_CLASS___NSPQuicProxyPath);
    uint64_t v16 = objc_claimAutoreleasedReturnValue([v7 ingressProxy]);
    char v17 = (void *)objc_claimAutoreleasedReturnValue([v7 egressProxy]);
    id v33 = [v7 proxyPathWeight];
    BOOL v18 = *(_BYTE *)(a1 + 13) == 0;
    char v19 = *(_BYTE *)(a1 + 15);
    id v20 = *(void **)(a1 + 400);
    id v21 = *(id *)(a1 + 368);
    id v22 = v20;
    id v23 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v21);
    BYTE2(v32) = v19;
    BYTE1(v32) = v18;
    LOBYTE(v32) = 0;
    id v24 = (void *)v16;
    id v25 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:]( v34,  "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFa ilOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:",  a1,  v16,  v17,  v33,  1LL,  1LL,  v32,  v22,  v23);

    __int16 v12 = &AnalyticsSendEventLazy_ptr;
    uint64_t v26 = *(void **)(a1 + 304);
    id v14 = v25;
    [v26 setObject:v14 forKeyedSubscript:v3];
    -[NSPQuicProxyPath resetMultiHopProxyAgent](v14, "resetMultiHopProxyAgent");
    id v13 = v14;
  }

  [v13 resetStats];
  [v13 resetError];
  sub_100029DC4((id *)a1);
  [(id)a1 updateUserEventAgentData];
  id v27 = v12[89];
  ++*(void *)(a1 + 544);
  objc_msgSend(v27, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-path-changed");

LABEL_10:
}

void sub_10002B698(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002B77C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002B860(id *a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([a1[4] vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v13 = 138412546;
    uint64_t v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Domain filter fetch for Quic[%@] %@",  (uint8_t *)&v13,  0x16u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained(a1 + 6);
  uint64_t v11 = WeakRetained;
  if (WeakRetained && v3)
  {
    __int16 v12 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[39] objectForKeyedSubscript:a1[5]]);
    [v11 updateUserEventAgentData];
    sub_10002AB04((uint64_t)v11);
  }
}

void sub_10002BB90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = (id *)(a1 + 232);
  if (*(void *)(a1 + 232))
  {
    uint64_t v5 = (id *)(a1 + 216);
    id v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 216) egressProxy]);
    id v6 = *v5;
    uint64_t v7 = &AnalyticsSendEventLazy_ptr;
    if (*v5)
    {
      id v8 = *v3;
      id v9 = v6;
      int v10 = (void *)objc_claimAutoreleasedReturnValue([v8 ingressProxy]);
      id v11 = *v3;
      __int16 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 egressProxy]);
      id v13 = *v3;
      objc_msgSend( v9,  "updateIngressProxy:egressProxy:proxyPathWeight:",  v10,  v12,  objc_msgSend(v13, "proxyPathWeight"));
    }

    else
    {
      id v40 = objc_alloc(&OBJC_CLASS___NSPFallbackProxyPath);
      id v43 = *(id *)(a1 + 232);
      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v43 ingressProxy]);
      id v42 = *(id *)(a1 + 232);
      id v38 = (void *)objc_claimAutoreleasedReturnValue([v42 egressProxy]);
      id v41 = *(id *)(a1 + 232);
      id v14 = [v41 proxyPathWeight];
      unsigned __int8 v15 = [(id)a1 forceFallback];
      BOOL v16 = *(_BYTE *)(a1 + 13) == 0;
      char v17 = *(_BYTE *)(a1 + 15);
      BOOL v18 = *(void **)(a1 + 400);
      id v19 = *(id *)(a1 + 368);
      id v20 = v18;
      id v21 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v19);
      BYTE2(v37) = v17;
      BYTE1(v37) = v16;
      LOBYTE(v37) = v15;
      id v22 = v14;
      uint64_t v7 = &AnalyticsSendEventLazy_ptr;
      id v23 = -[NSPProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:]( v40,  "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allow FailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:",  a1,  v39,  v38,  v22,  0LL,  0LL,  v37,  v20,  v21);
      objc_storeStrong(v5, v23);

      [*(id *)(a1 + 216) resetSingleHopProxyAgent];
      [*(id *)(a1 + 216) resetMultiHopProxyAgent];
    }

    if (v44) {
      id v24 = (void *)v44[3];
    }
    else {
      id v24 = 0LL;
    }
    id v25 = v24;
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 vendor]);
    id v27 = *v5;
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v27 egressProxy]);
    uint64_t v29 = v28;
    if (v28) {
      uint64_t v28 = (void *)v28[3];
    }
    unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v28 vendor]);
    unint64_t v31 = v26;
    unint64_t v32 = v30;
    id v33 = (void *)v32;
    if (!(v31 | v32) || v31 && v32 && [(id)v31 isEqual:v32])
    {
    }

    else
    {

      id v25 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      unint64_t v31 = *(void *)(a1 + 296);
      *(void *)(a1 + 296) = v25;
    }

    [*(id *)(a1 + 216) resetStats];
    [*(id *)(a1 + 216) resetError];
    *(int64x2_t *)(a1 + 48_Block_object_dispose(va, 8) = vaddq_s64(*(int64x2_t *)(a1 + 488), vdupq_n_s64(1uLL));
    [*(id *)(a1 + 208) enableFallback:1];
    [*(id *)(a1 + 208) resetSingleHopProxyAgent];
    [*(id *)(a1 + 208) resetMultiHopProxyAgent];
    objc_storeStrong(v3, 0LL);
    [(id)a1 tokensEmpty];
    uint64_t v34 = v7[89];
    ++*(void *)(a1 + 544);
    objc_msgSend(v34, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-path-changed");
  }

  else
  {
    uint64_t v35 = nplog_obj(a1, a2, a3);
    uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v46 = "-[NSPPrivacyProxyAgentManager setupFallbackProxyPath]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "%s called with null self.candidateFallbackProxyPath",  buf,  0xCu);
    }
  }

void sub_10002BFBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Fallback[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002C0A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Fallback[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002C184(id *a1)
{
  if (!a1 || !a1[19]) {
    return;
  }
  id location = a1 + 40;
  id v3 = a1[40];
  if (!v3)
  {
    uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    objc_storeStrong(location, v4);

    id v3 = *location;
  }

  __int128 v164 = 0u;
  __int128 v165 = 0u;
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v162 objects:v177 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v163;
    do
    {
      for (i = 0LL; i != v7; i = (char *)i + 1)
      {
        if (*(void *)v163 != v8) {
          objc_enumerationMutation(v5);
        }
        [*(id *)(*((void *)&v162 + 1) + 8 * (void)i) setDelegate:a1];
      }

      id v7 = [v5 countByEnumeratingWithState:&v162 objects:v177 count:16];
    }

    while (v7);
  }

  id v118 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v126 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v158 = 0u;
  __int128 v159 = 0u;
  __int128 v160 = 0u;
  __int128 v161 = 0u;
  __int128 v129 = a1;
  id obj = a1[19];
  id v10 = [obj countByEnumeratingWithState:&v158 objects:v176 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v159;
    do
    {
      id v13 = 0LL;
      do
      {
        if (*(void *)v159 != v12) {
          objc_enumerationMutation(obj);
        }
        id v14 = *(void **)(*((void *)&v158 + 1) + 8LL * (void)v13);
        id v15 = v129[20];
        BOOL v16 = (void *)objc_claimAutoreleasedReturnValue([v14 identifier]);
        uint64_t v1 = (uint64_t)[v15 containsObject:v16];

        if ((v1 & 1) == 0)
        {
          if ([v14 hasPercentEnabled])
          {
            if ([v14 percentEnabled] <= 0x63)
            {
              uint32_t v30 = arc4random_uniform(0x64u);
              id v31 = [v14 percentEnabled];
              uint32_t v32 = v31;
              uint64_t v35 = nplog_obj(v31, v33, v34);
              char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
              BOOL v36 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
              if (v30 > v32)
              {
                if (v36)
                {
                  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v14 identifier]);
                  unsigned int v38 = [v14 percentEnabled];
                  *(_DWORD *)__int128 buf = 138412546;
                  v173 = v37;
                  __int16 v174 = 1024;
                  unsigned int v175 = v38;
                  _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Not enabling map for %@ (%u%% chance of enablement)",  buf,  0x12u);
                  goto LABEL_83;
                }

                goto LABEL_60;
              }

              if (v36)
              {
                __int128 v60 = (void *)objc_claimAutoreleasedReturnValue([v14 identifier]);
                unsigned int v61 = [v14 percentEnabled];
                *(_DWORD *)__int128 buf = 138412546;
                v173 = v60;
                __int16 v174 = 1024;
                unsigned int v175 = v61;
                _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Enabling map for %@ (%u%% chance of enablement)",  buf,  0x12u);
              }
            }

            __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v14 identifier]);
            -[NSMutableArray addObject:](v126, "addObject:", v62);
          }
        }

        __int128 v156 = 0u;
        __int128 v157 = 0u;
        __int128 v154 = 0u;
        __int128 v155 = 0u;
        char v17 = (os_log_s *)*location;
        id v18 = -[os_log_s countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v154,  v171,  16LL);
        if (v18)
        {
          id v19 = v18;
          uint64_t v20 = *(void *)v155;
LABEL_20:
          uint64_t v21 = 0LL;
          while (1)
          {
            if (*(void *)v155 != v20) {
              objc_enumerationMutation(v17);
            }
            id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v154 + 1) + 8 * v21) associatedMaps]);
            uint64_t v1 = (uint64_t)[v22 containsObject:v14];

            if ((v1 & 1) != 0) {
              goto LABEL_60;
            }
            if (v19 == (id)++v21)
            {
              id v19 = -[os_log_s countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v154,  v171,  16LL);
              if (v19) {
                goto LABEL_20;
              }
              break;
            }
          }
        }

        __int128 v152 = 0u;
        __int128 v153 = 0u;
        __int128 v150 = 0u;
        __int128 v151 = 0u;
        id v23 = *location;
        id v24 = [v23 countByEnumeratingWithState:&v150 objects:v170 count:16];
        if (v24)
        {
          id v25 = v24;
          uint64_t v26 = *(void *)v151;
          while (2)
          {
            for (j = 0LL; j != v25; j = (char *)j + 1)
            {
              if (*(void *)v151 != v26) {
                objc_enumerationMutation(v23);
              }
              uint64_t v28 = *(void **)(*((void *)&v150 + 1) + 8LL * (void)j);
              if ([v28 matchesMap:v14])
              {
                [v28 addMap:v14];
                char v29 = 1;
                goto LABEL_43;
              }
            }

            id v25 = [v23 countByEnumeratingWithState:&v150 objects:v170 count:16];
            if (v25) {
              continue;
            }
            break;
          }
        }

        char v29 = 0;
LABEL_43:

        __int128 v148 = 0u;
        __int128 v149 = 0u;
        __int128 v146 = 0u;
        __int128 v147 = 0u;
        uint64_t v1 = v118;
        id v39 = [(id)v1 countByEnumeratingWithState:&v146 objects:v169 count:16];
        if (v39)
        {
          id v40 = v39;
          uint64_t v41 = *(void *)v147;
          while (2)
          {
            for (k = 0LL; k != v40; k = (char *)k + 1)
            {
              if (*(void *)v147 != v41) {
                objc_enumerationMutation((id)v1);
              }
              id v43 = *(void **)(*((void *)&v146 + 1) + 8LL * (void)k);
              if ([v43 matchesMap:v14])
              {
                [v43 addMap:v14];
                char v17 = (os_log_s *)v1;
                goto LABEL_60;
              }
            }

            id v40 = [(id)v1 countByEnumeratingWithState:&v146 objects:v169 count:16];
            if (v40) {
              continue;
            }
            break;
          }
        }

        if ((v29 & 1) == 0)
        {
          if (![v14 proxiesCount] && objc_msgSend(v14, "hasResolver"))
          {
            unsigned int v44 = [v14 resolver];
            id v45 = v129[12];
            if ((unint64_t)[v45 count] <= v44)
            {
            }

            else
            {
              id v46 = v129[12];
              char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "objectAtIndex:", objc_msgSend(v14, "resolver")));

              if (v17)
              {
                if (-[os_log_s hasProxyIndex](v17, "hasProxyIndex"))
                {
                  id v50 = v129[11];
                  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v50,  "objectAtIndex:",  -[os_log_s proxyIndex](v17, "proxyIndex")));

                  if (v37)
                  {
                    id v51 = sub_10002991C((uint64_t)v129, v37);
                    uint64_t v52 = (NSPProxiedContentPath *)objc_claimAutoreleasedReturnValue(v51);
                  }

                  else
                  {
                    uint64_t v52 = 0LL;
                  }
                }

                else
                {
                  uint64_t v52 = 0LL;
                  uint64_t v37 = 0LL;
                }

                int v75 = -[NSPProxiedContentPath initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:]( objc_alloc(&OBJC_CLASS___NSPProxiedContentPath),  "initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:",  v129,  v14,  0LL,  v52,  v17);
                [(id)v1 addObject:v75];

LABEL_82:
LABEL_83:

LABEL_60:
                goto LABEL_61;
              }
            }

            uint64_t v73 = nplog_obj(v47, v48, v49);
            char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v73);
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              goto LABEL_60;
            }
            unsigned int v74 = [v14 resolver];
            *(_DWORD *)__int128 buf = 67109120;
            LODWORD(v173) = v74;
            __int128 v57 = v17;
            __int128 v58 = "Failed to add proxied content path, invalid resolver %u";
            uint32_t v59 = 8;
LABEL_67:
            _os_log_error_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, v58, buf, v59);
            goto LABEL_60;
          }

          id v53 = [v14 proxiesCount];
          if (!v53 || (id v53 = [v14 proxiesCount], (unint64_t)v53 >= 3))
          {
            uint64_t v56 = nplog_obj(v53, v54, v55);
            char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              goto LABEL_60;
            }
            *(_DWORD *)__int128 buf = 138412290;
            v173 = v14;
            __int128 v57 = v17;
            __int128 v58 = "Failed to add proxied content path, invalid number of proxies (%@)";
            uint32_t v59 = 12;
            goto LABEL_67;
          }

          if ([v14 proxiesCount] == (id)2)
          {
            id v63 = v129[11];
            char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "objectAtIndex:", *(unsigned int *)objc_msgSend(v14, "proxies")));

            id v64 = v129[11];
            __int128 v66 = sub_10002991C((uint64_t)v129, v17);
            __int128 v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
            __int128 v68 = sub_10002991C((uint64_t)v129, v65);
            __int128 v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
            id v70 = -[NSPProxiedContentPath initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:]( objc_alloc(&OBJC_CLASS___NSPProxiedContentPath),  "initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:",  v129,  v14,  v67,  v69,  0LL);
            [(id)v1 addObject:v70];

            goto LABEL_60;
          }

          if ([v14 proxiesCount] == (id)1)
          {
            id v71 = v129[11];
            char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "objectAtIndex:", *(unsigned int *)objc_msgSend(v14, "proxies")));

            uint64_t v72 = sub_10002991C((uint64_t)v129, v17);
            uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v72);
            uint64_t v52 = -[NSPProxiedContentPath initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:]( objc_alloc(&OBJC_CLASS___NSPProxiedContentPath),  "initWithDelegate:initialMap:ingressProxy:egressProxy:resolver:",  v129,  v14,  0LL,  v37,  0LL);
            [(id)v1 addObject:v52];
            goto LABEL_82;
          }
        }

LABEL_61:
        id v13 = (char *)v13 + 1;
      }

      while (v13 != v11);
      id v76 = [obj countByEnumeratingWithState:&v158 objects:v176 count:16];
      id v11 = v76;
    }

    while (v76);
  }

  [*location addObjectsFromArray:v118];
  id v119 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v142 = 0u;
  __int128 v143 = 0u;
  __int128 v144 = 0u;
  __int128 v145 = 0u;
  id v120 = *location;
  uint64_t v77 = v129;
  id v123 = [v120 countByEnumeratingWithState:&v142 objects:v168 count:16];
  if (!v123) {
    goto LABEL_111;
  }
  uint64_t v122 = *(void *)v143;
  do
  {
    uint64_t v78 = 0LL;
    do
    {
      if (*(void *)v143 != v122) {
        objc_enumerationMutation(v120);
      }
      __int128 v79 = *(void **)(*((void *)&v142 + 1) + 8 * v78);
      id obja = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v138 = 0u;
      __int128 v139 = 0u;
      __int128 v140 = 0u;
      __int128 v141 = 0u;
      id v124 = v79;
      __int128 v80 = (void *)objc_claimAutoreleasedReturnValue([v79 associatedMaps]);
      id v81 = [v80 countByEnumeratingWithState:&v138 objects:v167 count:16];
      uint64_t v125 = v78;
      if (v81)
      {
        id v82 = v81;
        uint64_t v83 = *(void *)v139;
        do
        {
          for (m = 0LL; m != v82; m = (char *)m + 1)
          {
            if (*(void *)v139 != v83) {
              objc_enumerationMutation(v80);
            }
            __int128 v85 = *(void **)(*((void *)&v138 + 1) + 8LL * (void)m);
            unsigned int v86 = [v85 enabled];
            if (v86)
            {
              if (![v85 hasPercentEnabled])
              {
                unsigned __int8 v87 = 1;
                goto LABEL_102;
              }

              uint64_t v1 = objc_claimAutoreleasedReturnValue([v85 identifier]);
              if ((-[NSMutableArray containsObject:](v126, "containsObject:", v1) & 1) != 0)
              {
                unsigned __int8 v87 = 1;
LABEL_100:

                goto LABEL_102;
              }
            }

            id v88 = v77[20];
            __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v85 identifier]);
            unsigned __int8 v87 = [v88 containsObject:v89];

            uint64_t v77 = v129;
            if (v86) {
              goto LABEL_100;
            }
LABEL_102:
          }

          id v82 = [v80 countByEnumeratingWithState:&v138 objects:v167 count:16];
        }

        while (v82);
      }

      __int128 v90 = (void *)objc_claimAutoreleasedReturnValue([v124 associatedMaps]);
      [v90 removeObjectsInArray:obja];

      __int128 v91 = (void *)objc_claimAutoreleasedReturnValue([v124 associatedMaps]);
      id v92 = [v91 count];

      if (!v92)
      {
        [v124 removeProxyAgents];
        -[NSMutableArray addObject:](v119, "addObject:", v124);
      }

      uint64_t v78 = v125 + 1;
    }

    while ((id)(v125 + 1) != v123);
    id v123 = [v120 countByEnumeratingWithState:&v142 objects:v168 count:16];
  }

  while (v123);
LABEL_111:

  [*location removeObjectsInArray:v119];
  __int128 v136 = 0u;
  __int128 v137 = 0u;
  __int128 v134 = 0u;
  __int128 v135 = 0u;
  id v93 = *location;
  id v94 = [v93 countByEnumeratingWithState:&v134 objects:v166 count:16];
  if (v94)
  {
    id v95 = v94;
    uint64_t v96 = *(void *)v135;
    do
    {
      id v97 = 0LL;
      do
      {
        if (*(void *)v135 != v96) {
          objc_enumerationMutation(v93);
        }
        uint64_t v98 = *(void **)(*((void *)&v134 + 1) + 8LL * (void)v97);
        id v99 = [v98 pathReady];
        if ((_DWORD)v99)
        {
          uint64_t v102 = nplog_obj(v99, v100, v101);
          uint64_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
          {
            v104 = (void *)objc_claimAutoreleasedReturnValue([v98 shortName]);
            *(_DWORD *)__int128 buf = 138412290;
            v173 = v104;
            _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEFAULT,  "Setting up proxied content path (%@)",  buf,  0xCu);
          }

          [v98 setupProxyAgentsForceUpdateDelegate:1];
        }

        else
        {
          uint64_t v105 = objc_claimAutoreleasedReturnValue([v98 ingressProxy]);
          uint64_t v106 = (void *)v105;
          if (v105) {
            uint64_t v107 = *(void **)(v105 + 24);
          }
          else {
            uint64_t v107 = 0LL;
          }
          id v108 = v107;

          uint64_t v109 = objc_claimAutoreleasedReturnValue([v98 egressProxy]);
          id v110 = (void *)v109;
          if (v109) {
            id v111 = *(void **)(v109 + 24);
          }
          else {
            id v111 = 0LL;
          }
          id v112 = v111;

          id v113 = (void *)objc_claimAutoreleasedReturnValue([v98 ingressProxy]);
          v132[0] = _NSConcreteStackBlock;
          v132[1] = 3221225472LL;
          v132[2] = sub_10002CF54;
          v132[3] = &unk_1000F9720;
          id v133 = v108;
          id v114 = v108;
          sub_10000CF58((uint64_t)v113, v132);

          id v115 = (void *)objc_claimAutoreleasedReturnValue([v98 egressProxy]);
          v130[0] = _NSConcreteStackBlock;
          v130[1] = 3221225472LL;
          v130[2] = sub_10002D038;
          v130[3] = &unk_1000F9720;
          id v131 = v112;
          id v116 = v112;
          sub_10000CF58((uint64_t)v115, v130);

          uint64_t v77 = v129;
        }

        id v97 = (char *)v97 + 1;
      }

      while (v95 != v97);
      id v117 = [v93 countByEnumeratingWithState:&v134 objects:v166 count:16];
      id v95 = v117;
    }

    while (v117);
  }

  sub_100029DC4(v77);
  [v77 updateUserEventAgentData];
  sub_10002AB04((uint64_t)v77);
}

        __int128 v58 = v87;
        if ((v28 & v45) == 1)
        {
          uint32_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v22));
          __int128 v60 = sub_1000342D8(v59);
          unsigned int v61 = (void *)objc_claimAutoreleasedReturnValue(v60);

          -[NSMutableDictionary setObject:forKeyedSubscript:]( v25,  "setObject:forKeyedSubscript:",  v61,  @"label_privacy-proxy-token-fetch-failure-proxy");
          if (v87)
          {
            __int128 v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v87));
            id v63 = (void *)objc_claimAutoreleasedReturnValue([v62 host]);

            __int128 v58 = v87;
            if (v63)
            {
              id v64 = sub_1000342D8(v62);
              __int128 v58 = (void *)objc_claimAutoreleasedReturnValue(v64);
            }

            -[NSMutableDictionary setObject:forKeyedSubscript:]( v25,  "setObject:forKeyedSubscript:",  v58,  @"label_privacy-proxy-token-fetch-server",  v85);
          }

          else
          {
            __int128 v58 = 0LL;
          }
        }

        __int128 v65 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager tierString](v86, "tierString", v85));
        if (v65) {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v25,  "setObject:forKeyedSubscript:",  v65,  @"label_privacy-proxy-tier-type");
        }
        __int128 v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
        __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v66 currentCountryPlusTimezone]);

        if (v67) {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v25,  "setObject:forKeyedSubscript:",  v67,  @"label_privacy-proxy-report-region");
        }

        __int128 v68 = v87;
        break;
    }
  }

  else
  {
    id v25 = 0LL;
    __int128 v68 = v87;
    __int128 v58 = v87;
  }

  if (v25)
  {
    v95[0] = kRTCReportingSessionInfoClientType;
    v95[1] = kRTCReportingSessionInfoClientVersion;
    v96[0] = &off_100103368;
    v96[1] = &off_100103350;
    v95[2] = kRTCReportingSessionInfoSessionID;
    v95[3] = kRTCReportingSessionInfoBatchEvent;
    v96[2] = &off_100103338;
    v96[3] = &__kCFBooleanFalse;
    v95[4] = kRTCReportingSessionInfoContainsRealtimeEvents;
    v96[4] = &__kCFBooleanTrue;
    uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v96,  v95,  5LL));
    uint64_t v73 = @"network-service-proxy-free";
    if (v86)
    {
      else {
        unsigned int v74 = *(&off_1000F9C90 + a3 - 1000);
      }
      if (v86->_subscriber) {
        uint64_t v73 = @"network-service-proxy-subscriber";
      }
    }

    else
    {
      unsigned int v74 = 0LL;
    }

    id v76 = v73;
    v93[0] = kRTCReportingUserInfoClientName;
    v93[1] = kRTCReportingUserInfoServiceName;
    v94[0] = v76;
    v94[1] = v74;
    uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v94,  v93,  2LL));
    id v88 = 0LL;
    uint64_t v78 = +[RTCReporting sendOneMessageWithSessionInfo:userInfo:category:type:payload:error:]( &OBJC_CLASS___RTCReporting,  "sendOneMessageWithSessionInfo:userInfo:category:type:payload:error:",  v72,  v77,  (unsigned __int16)a3,  0LL,  v25,  &v88);
    __int128 v79 = v88;
    id v82 = nplog_obj(v79, v80, v81);
    uint64_t v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    uint32_t v84 = v83;
    if ((v78 & 1) != 0)
    {
      if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        __int128 v90 = (int64_t)v25;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_INFO, "sent RTC report %@", buf, 0xCu);
      }
    }

    else if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218242;
      __int128 v90 = a3;
      __int128 v91 = 2112;
      id v92 = v79;
      _os_log_error_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_ERROR,  "failed to send RTC report type: %ld error: %@",  buf,  0x16u);
    }
  }

  else
  {
    int v75 = nplog_obj(v69, v70, v71);
    uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v75);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218240;
      __int128 v90 = a3;
      __int128 v91 = 1024;
      LODWORD(v92) = v85;
      _os_log_error_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_ERROR,  "failed to create RTC report payload for type [%ld], error code [%d]",  buf,  0x12u);
    }
  }
}

      id v5 = v15;
      goto LABEL_41;
    }

  __int128 v80 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.ap.promotedcontentd.proxied-requests",  1,  0);
  id v81 = (void *)objc_claimAutoreleasedReturnValue(v80);
  if (v81) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v81);
  }

  if ((v21 & 0x800000) == 0)
  {
LABEL_34:
    if ((v21 & 0x1000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_67;
  }

  -[NSPConfigurationStats setPostbackFetchEnabled:](v15, "setPostbackFetchEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x1000000) != 0) {
    goto LABEL_62;
  }
LABEL_36:
  if ((v12 & 0x2000000) != 0)
  {
LABEL_37:
    -[NSPConfigurationStats setLaunchWarningDetailsEnabled:](v15, "setLaunchWarningDetailsEnabled:", 1LL);
    id v13 = v15;
  }

void sub_10002CF54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    uint64_t v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Proxied Content[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002D038(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    uint64_t v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Proxied Content[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_10002D130(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 136);

    if (v2)
    {
      int v187 = *(unsigned __int8 *)(a1 + 10);
      if (!*(_BYTE *)(a1 + 10)) {
        *(_BYTE *)(a1 + 10) = 1;
      }
      id v3 = *(id *)(a1 + 344);

      if (!v3)
      {
        uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        objc_storeStrong((id *)(a1 + 344), v4);
      }

      __int128 v313 = 0u;
      __int128 v312 = 0u;
      __int128 v311 = 0u;
      __int128 v310 = 0u;
      id v5 = *(id *)(a1 + 344);
      id v6 = [v5 countByEnumeratingWithState:&v310 objects:v335 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v311;
        do
        {
          for (i = 0LL; i != v7; i = (char *)i + 1)
          {
            if (*(void *)v311 != v8) {
              objc_enumerationMutation(v5);
            }
            [*(id *)(*((void *)&v310 + 1) + 8 * (void)i) setDelegate:a1];
          }

          id v7 = [v5 countByEnumeratingWithState:&v310 objects:v335 count:16];
        }

        while (v7);
      }

      v201 = (id *)(a1 + 344);

      int v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      v196 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      __int128 v306 = 0u;
      __int128 v307 = 0u;
      __int128 v308 = 0u;
      __int128 v309 = 0u;
      uint64_t v204 = a1;
      id v11 = *(id *)(a1 + 136);
      id v12 = [v11 countByEnumeratingWithState:&v306 objects:v334 count:16];
      if (v12)
      {
        id v13 = v12;
        uint64_t v14 = *(void *)v307;
        do
        {
          for (j = 0LL; j != v13; j = (char *)j + 1)
          {
            if (*(void *)v307 != v14) {
              objc_enumerationMutation(v11);
            }
            BOOL v16 = *(void **)(*((void *)&v306 + 1) + 8LL * (void)j);
            __int128 v302 = 0u;
            __int128 v303 = 0u;
            __int128 v304 = 0u;
            __int128 v305 = 0u;
            char v17 = (void *)objc_claimAutoreleasedReturnValue([v16 obliviousTargets]);
            id v18 = [v17 countByEnumeratingWithState:&v302 objects:v333 count:16];
            if (v18)
            {
              id v19 = v18;
              uint64_t v20 = *(void *)v303;
              do
              {
                for (k = 0LL; k != v19; k = (char *)k + 1)
                {
                  if (*(void *)v303 != v20) {
                    objc_enumerationMutation(v17);
                  }
                  -[NSMutableSet addObject:](v10, "addObject:", v22);
                }

                id v19 = [v17 countByEnumeratingWithState:&v302 objects:v333 count:16];
              }

              while (v19);
            }
          }

          id v13 = [v11 countByEnumeratingWithState:&v306 objects:v334 count:16];
        }

        while (v13);
      }

      __int128 v300 = 0u;
      __int128 v301 = 0u;
      __int128 v298 = 0u;
      __int128 v299 = 0u;
      id obj = v10;
      id v23 = (id *)v204;
      id v190 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v298,  v332,  16LL);
      if (v190)
      {
        id v24 = (id *)(v204 + 80);
        id v25 = &AnalyticsSendEventLazy_ptr;
        uint64_t v189 = *(void *)v299;
        do
        {
          uint64_t v26 = 0LL;
          do
          {
            if (*(void *)v299 != v189)
            {
              uint64_t v27 = v26;
              objc_enumerationMutation(obj);
              uint64_t v26 = v27;
            }

            uint64_t v191 = v26;
            uint64_t v28 = *(void **)(*((void *)&v298 + 1) + 8 * v26);
            __int128 v294 = 0u;
            __int128 v295 = 0u;
            __int128 v296 = 0u;
            __int128 v297 = 0u;
            char v29 = (os_log_s *)v23[17];
            v227 = v28;
            id v211 = -[os_log_s countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v294,  v331,  16LL);
            if (v211)
            {
              char v224 = 0;
              id v30 = *(id *)v295;
              v220 = v29;
              id v207 = *(id *)v295;
              do
              {
                uint64_t v31 = 0LL;
                do
                {
                  if (*(id *)v295 != v30)
                  {
                    uint64_t v32 = v31;
                    objc_enumerationMutation(v29);
                    uint64_t v31 = v32;
                  }

                  uint64_t v215 = v31;
                  uint64_t v33 = *(void **)(*((void *)&v294 + 1) + 8 * v31);
                  __int128 v290 = 0u;
                  __int128 v291 = 0u;
                  __int128 v292 = 0u;
                  __int128 v293 = 0u;
                  v235 = (void *)objc_claimAutoreleasedReturnValue([v33 obliviousTargets]);
                  id v34 = [v235 countByEnumeratingWithState:&v290 objects:v330 count:16];
                  if (v34)
                  {
                    id v35 = v34;
                    uint64_t v36 = *(void *)v291;
                    while (2)
                    {
                      uint64_t v37 = 0LL;
                      id v230 = v35;
                      do
                      {
                        if (*(void *)v291 != v36) {
                          objc_enumerationMutation(v235);
                        }
                        unsigned int v38 = *(void **)(*((void *)&v290 + 1) + 8LL * (void)v37);
                        id v39 = (void *)objc_claimAutoreleasedReturnValue([v38 targetHost]);
                        unsigned int v40 = [v39 isEqualToString:v28];

                        if (v40)
                        {
                          uint64_t v41 = objc_claimAutoreleasedReturnValue([v23 overridePreferredObliviousProxy]);
                          if (v41)
                          {
                            id v42 = (void *)v41;
                            uint64_t v43 = v36;
                            unsigned int v44 = [v38 proxyIndex];
                            id v45 = v23[11];
                            if ((unint64_t)[v45 count] <= v44)
                            {

                              uint64_t v36 = v43;
                              id v35 = v230;
                            }

                            else
                            {
                              id v46 = (void *)objc_claimAutoreleasedReturnValue([v23 overridePreferredObliviousProxy]);
                              id v47 = v23[11];
                              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v47,  "objectAtIndex:",  objc_msgSend(v38, "proxyIndex")));
                              uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v48 proxyURL]);
                              unsigned int v50 = [v46 isEqualToString:v49];

                              id v23 = (id *)v204;
                              id v24 = (id *)(v204 + 80);

                              uint64_t v36 = v43;
                              id v35 = v230;
                              if (v50)
                              {
                                id v54 = -[NSMutableDictionary setObject:forKeyedSubscript:]( v196,  "setObject:forKeyedSubscript:",  v38,  v227);
                                uint64_t v57 = nplog_obj(v54, v55, v56);
                                __int128 v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
                                if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
                                {
                                  *(_DWORD *)__int128 buf = 138412546;
                                  v327 = v38;
                                  __int16 v328 = 2112;
                                  v329 = v227;
                                  _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_INFO,  "Selected preferred oblivious target config %@ for %@",  buf,  0x16u);
                                }

LABEL_125:
                                id v25 = &AnalyticsSendEventLazy_ptr;
                                goto LABEL_126;
                              }
                            }
                          }

                          id v51 = v23[18];
                          id v25 = &AnalyticsSendEventLazy_ptr;
                          uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v38 proxyIndex]));
                          unsigned __int8 v53 = [v51 containsObject:v52];

                          uint64_t v28 = v227;
                          v224 |= v53 ^ 1;
                        }

                        else
                        {
                          id v25 = &AnalyticsSendEventLazy_ptr;
                        }

                        uint64_t v37 = (char *)v37 + 1;
                      }

                      while (v35 != v37);
                      id v35 = [v235 countByEnumeratingWithState:&v290 objects:v330 count:16];
                      if (v35) {
                        continue;
                      }
                      break;
                    }
                  }

                  uint64_t v31 = v215 + 1;
                  char v29 = v220;
                  id v30 = v207;
                }

                while ((id)(v215 + 1) != v211);
                id v211 = -[os_log_s countByEnumeratingWithState:objects:count:]( v220,  "countByEnumeratingWithState:objects:count:",  &v294,  v331,  16LL);
              }

              while (v211);
            }

            else
            {
              char v224 = 0;
            }

            __int128 v288 = 0u;
            __int128 v289 = 0u;
            __int128 v286 = 0u;
            __int128 v287 = 0u;
            id v60 = v23[17];
            id v194 = [v60 countByEnumeratingWithState:&v286 objects:v325 count:16];
            if (v194)
            {
              char v205 = 0;
              int v221 = 0;
              uint64_t v192 = *(void *)v287;
              v193 = v60;
              do
              {
                uint64_t v61 = 0LL;
                do
                {
                  if (*(void *)v287 != v192) {
                    objc_enumerationMutation(v60);
                  }
                  uint64_t v198 = v61;
                  __int128 v62 = *(void **)(*((void *)&v286 + 1) + 8 * v61);
                  __int128 v282 = 0u;
                  __int128 v283 = 0u;
                  __int128 v284 = 0u;
                  __int128 v285 = 0u;
                  v216 = v62;
                  id v231 = (id)objc_claimAutoreleasedReturnValue([v62 obliviousTargets]);
                  id v63 = [v231 countByEnumeratingWithState:&v282 objects:v324 count:16];
                  if (v63)
                  {
                    id v64 = v63;
                    uint64_t v236 = *(void *)v283;
                    do
                    {
                      for (m = 0LL; m != v64; m = (char *)m + 1)
                      {
                        if (*(void *)v283 != v236) {
                          objc_enumerationMutation(v231);
                        }
                        __int128 v66 = *(void **)(*((void *)&v282 + 1) + 8LL * (void)m);
                        __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v66 targetHost]);
                        unsigned int v68 = [v67 isEqualToString:v28];

                        if (v68)
                        {
                          if (_os_feature_enabled_impl("NetworkServiceProxy", "RelayNameEnforcement")
                            && [v216 obliviousHTTPType] == 2
                            && (id WeakRetained = objc_loadWeakRetained(v24),
                                unsigned int v70 = [WeakRetained usesDefaultConfigurationServer],
                                WeakRetained,
                                v70))
                          {
                            unsigned int v71 = [v66 proxyIndex];
                            id v72 = v23[11];
                            id v73 = [v72 count];

                            if ((unint64_t)v73 <= v71)
                            {
                              id v81 = 0LL;
                            }

                            else
                            {
                              id v77 = v23[11];
                              uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v77,  "objectAtIndex:",  objc_msgSend(v66, "proxyIndex")));

                              v212 = v78;
                              __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v78 proxyURL]);
                              __int128 v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v79));

                              id v208 = v80;
                              id v81 = (void *)objc_claimAutoreleasedReturnValue([v80 host]);
                              id v82 = (void *)objc_claimAutoreleasedReturnValue( +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  @"cloudflare.com",  @"fastly-edge.com",  @"akamaized.net",  0LL));
                              __int128 v278 = 0u;
                              __int128 v279 = 0u;
                              __int128 v280 = 0u;
                              __int128 v281 = 0u;
                              id v83 = v82;
                              id v84 = [v83 countByEnumeratingWithState:&v278 objects:v323 count:16];
                              if (v84)
                              {
                                id v85 = v84;
                                uint64_t v86 = *(void *)v279;
                                while (2)
                                {
                                  for (n = 0LL; n != v85; n = (char *)n + 1)
                                  {
                                    if (*(void *)v279 != v86) {
                                      objc_enumerationMutation(v83);
                                    }
                                    uint64_t v88 = *(void *)(*((void *)&v278 + 1) + 8LL * (void)n);
                                    if (([v81 isEqualToString:v88] & 1) == 0)
                                    {
                                      __int128 v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @".%@",  v88));
                                      unsigned __int8 v90 = [v81 hasSuffix:v89];

                                      if ((v90 & 1) == 0) {
                                        continue;
                                      }
                                    }

                                    id v24 = (id *)(v204 + 80);
                                    id v23 = (id *)v204;
                                    id v25 = &AnalyticsSendEventLazy_ptr;
                                    goto LABEL_90;
                                  }

                                  id v85 = [v83 countByEnumeratingWithState:&v278 objects:v323 count:16];
                                  id v23 = (id *)v204;
                                  uint64_t v28 = v227;
                                  if (v85) {
                                    continue;
                                  }
                                  break;
                                }
                              }

                              id v24 = (id *)(v204 + 80);
                            }

                            uint64_t v91 = nplog_obj(v74, v75, v76);
                            id v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v91);
                            if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)__int128 buf = 138412546;
                              v327 = v28;
                              __int16 v328 = 2112;
                              v329 = v81;
                              _os_log_error_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_ERROR,  "Oblivious target %@ has proxy %@ not in the approved list",  buf,  0x16u);
                            }

                            char v205 = 1;
                            id v25 = &AnalyticsSendEventLazy_ptr;
                          }

                          else
                          {
LABEL_90:
                            id v93 = v23[18];
                            id v94 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v25[118],  "numberWithUnsignedInt:",  objc_msgSend(v66, "proxyIndex")));
                            char v95 = [v93 containsObject:v94] & v224;

                            if ((v95 & 1) == 0) {
                              v221 += [v66 weight];
                            }
                            uint64_t v28 = v227;
                          }
                        }
                      }

                      id v64 = [v231 countByEnumeratingWithState:&v282 objects:v324 count:16];
                    }

                    while (v64);
                  }

                  uint64_t v61 = v198 + 1;
                  id v60 = v193;
                }

                while ((id)(v198 + 1) != v194);
                id v194 = [v193 countByEnumeratingWithState:&v286 objects:v325 count:16];
              }

              while (v194);

              int v99 = v221;
              if (((v221 == 0) & v205) != 0)
              {
                uint64_t v100 = nplog_obj(v96, v97, v98);
                uint64_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue(v100);
                if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 138412290;
                  v327 = v28;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_ERROR,  "Oblivious target %@ has no proxies in the approved list, ignoring",  buf,  0xCu);
                }

                goto LABEL_127;
              }
            }

            else
            {

              int v99 = 0;
            }

            do
            {
              uint32_t v102 = arc4random_uniform(v99 + 1);
              uint32_t v103 = v102;
            }

            while (v99 && !v102);
            __int128 v276 = 0u;
            __int128 v277 = 0u;
            __int128 v274 = 0u;
            __int128 v275 = 0u;
            uint64_t v101 = (os_log_s *)v23[17];
            id v232 = -[os_log_s countByEnumeratingWithState:objects:count:]( v101,  "countByEnumeratingWithState:objects:count:",  &v274,  v322,  16LL);
            if (v232)
            {
              v220 = v101;
              uint32_t v104 = 0;
              uint64_t v105 = *(void *)v275;
              uint64_t v217 = *(void *)v275;
              do
              {
                uint64_t v106 = 0LL;
                do
                {
                  if (*(void *)v275 != v105) {
                    objc_enumerationMutation(v220);
                  }
                  uint64_t v237 = v106;
                  uint64_t v107 = *(void **)(*((void *)&v274 + 1) + 8 * v106);
                  __int128 v270 = 0u;
                  __int128 v271 = 0u;
                  __int128 v272 = 0u;
                  __int128 v273 = 0u;
                  id v108 = (void *)objc_claimAutoreleasedReturnValue([v107 obliviousTargets]);
                  id v109 = [v108 countByEnumeratingWithState:&v270 objects:v321 count:16];
                  if (v109)
                  {
                    id v110 = v109;
                    uint64_t v111 = *(void *)v271;
                    while (2)
                    {
                      for (ii = 0LL; ii != v110; ii = (char *)ii + 1)
                      {
                        if (*(void *)v271 != v111) {
                          objc_enumerationMutation(v108);
                        }
                        id v113 = *(void **)(*((void *)&v270 + 1) + 8LL * (void)ii);
                        id v114 = (void *)objc_claimAutoreleasedReturnValue([v113 targetHost]);
                        unsigned int v115 = [v114 isEqualToString:v227];

                        if (v115)
                        {
                          id v116 = v23[18];
                          id v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v113 proxyIndex]));
                          char v118 = [v116 containsObject:v117] & v224;

                          if ((v118 & 1) != 0)
                          {
                            id v23 = (id *)v204;
                          }

                          else
                          {
                            v104 += [v113 weight];
                            id v23 = (id *)v204;
                            if (v103 <= v104)
                            {
                              id v119 = -[NSMutableDictionary setObject:forKeyedSubscript:]( v196,  "setObject:forKeyedSubscript:",  v113,  v227);
                              uint64_t v122 = nplog_obj(v119, v120, v121);
                              id v123 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
                              if (os_log_type_enabled(v123, OS_LOG_TYPE_INFO))
                              {
                                *(_DWORD *)__int128 buf = 138412546;
                                v327 = v113;
                                __int16 v328 = 2112;
                                v329 = v227;
                                _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_INFO,  "Selected oblivious target config %@ for %@",  buf,  0x16u);
                              }

                              id v24 = (id *)(v204 + 80);
                              goto LABEL_125;
                            }
                          }
                        }
                      }

                      id v110 = [v108 countByEnumeratingWithState:&v270 objects:v321 count:16];
                      if (v110) {
                        continue;
                      }
                      break;
                    }
                  }

                  uint64_t v106 = v237 + 1;
                  id v24 = (id *)(v204 + 80);
                  id v25 = &AnalyticsSendEventLazy_ptr;
                  uint64_t v105 = v217;
                }

                while ((id)(v237 + 1) != v232);
                id v232 = -[os_log_s countByEnumeratingWithState:objects:count:]( v220,  "countByEnumeratingWithState:objects:count:",  &v274,  v322,  16LL);
              }

              while (v232);
LABEL_126:
              uint64_t v101 = v220;
            }

LABEL_127:
            uint64_t v26 = v191 + 1;
          }

          while ((id)(v191 + 1) != v190);
          id v190 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v298,  v332,  16LL);
        }

        while (v190);
      }

      v206 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v266 = 0u;
      __int128 v267 = 0u;
      __int128 v268 = 0u;
      __int128 v269 = 0u;
      id v195 = v23[17];
      v199 = (char *)[v195 countByEnumeratingWithState:&v266 objects:v320 count:16];
      if (v199)
      {
        uint64_t v197 = *(void *)v267;
        do
        {
          id v124 = 0LL;
          do
          {
            if (*(void *)v267 != v197) {
              objc_enumerationMutation(v195);
            }
            v202 = v124;
            uint64_t v125 = *(void **)(*((void *)&v266 + 1) + 8LL * (void)v124);
            __int128 v262 = 0u;
            __int128 v263 = 0u;
            __int128 v264 = 0u;
            __int128 v265 = 0u;
            id v209 = (id)objc_claimAutoreleasedReturnValue([v125 obliviousTargets]);
            id v233 = [v209 countByEnumeratingWithState:&v262 objects:v319 count:16];
            if (v233)
            {
              uint64_t v228 = *(void *)v263;
              do
              {
                uint64_t v126 = 0LL;
                do
                {
                  if (*(void *)v263 != v228) {
                    objc_enumerationMutation(v209);
                  }
                  uint64_t v238 = v126;
                  id v127 = *(void **)(*((void *)&v262 + 1) + 8 * v126);
                  __int128 v258 = 0u;
                  __int128 v259 = 0u;
                  __int128 v260 = 0u;
                  __int128 v261 = 0u;
                  id v128 = *v201;
                  id v129 = [v128 countByEnumeratingWithState:&v258 objects:v318 count:16];
                  if (v129)
                  {
                    id v130 = v129;
                    uint64_t v131 = *(void *)v259;
                    do
                    {
                      for (jj = 0LL; jj != v130; jj = (char *)jj + 1)
                      {
                        if (*(void *)v259 != v131) {
                          objc_enumerationMutation(v128);
                        }
                        id v133 = *(void **)(*((void *)&v258 + 1) + 8LL * (void)jj);
                        __int128 v134 = (void *)objc_claimAutoreleasedReturnValue([v133 obliviousConfig]);
                        __int128 v135 = (void *)objc_claimAutoreleasedReturnValue([v125 obliviousHTTPConfig]);
                        if ([v134 isEqualToData:v135])
                        {
                          __int128 v136 = (void *)objc_claimAutoreleasedReturnValue([v133 obliviousTarget]);
                          unsigned __int8 v137 = [v136 isEqual:v127];

                          if ((v137 & 1) != 0) {
                            goto LABEL_153;
                          }
                        }

                        else
                        {
                        }
                      }

                      id v130 = [v128 countByEnumeratingWithState:&v258 objects:v318 count:16];
                    }

                    while (v130);
                  }

                  __int128 v138 = (void *)objc_claimAutoreleasedReturnValue([v127 targetHost]);
                  id v128 = (id)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v196, "objectForKeyedSubscript:", v138));

                  if (v128 && ![v128 isEqual:v127])
                  {
LABEL_153:
                    id v23 = (id *)v204;
                  }

                  else
                  {
                    id v139 = *(id *)(v204 + 88);
                    v225 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v139,  "objectAtIndex:",  objc_msgSend(v127, "proxyIndex")));

                    __int128 v140 = sub_10002991C(v204, v225);
                    id v222 = (id)objc_claimAutoreleasedReturnValue(v140);
                    v218 = objc_alloc(&OBJC_CLASS___NSPObliviousPath);
                    __int128 v141 = (void *)objc_claimAutoreleasedReturnValue([v125 obliviousHTTPConfig]);
                    unsigned int v213 = [v125 obliviousHTTPType];
                    __int128 v142 = (void *)objc_claimAutoreleasedReturnValue([v125 transparencyKeyBundle]);
                    __int128 v143 = (void *)objc_claimAutoreleasedReturnValue([v125 transparencyProof]);
                    id v144 = *(id *)(v204 + 368);
                    id v145 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v144);
                    LOBYTE(v186) = 0;
                    __int128 v146 = -[NSPObliviousPath initWithDelegate:obliviousConfig:obliviousHTTPType:transparencyKeyBundle:transparencyProof:obliviousTarget:proxyInfo:allowFailOpen:networkCharacteristics:]( v218,  "initWithDelegate:obliviousConfig:obliviousHTTPType:transparencyKeyBundle:transparencyProof: obliviousTarget:proxyInfo:allowFailOpen:networkCharacteristics:",  v204,  v141,  v213,  v142,  v143,  v127,  v222,  v186,  v145);

                    id v23 = (id *)v204;
                    -[NSMutableArray addObject:](v206, "addObject:", v146);
                  }

                  uint64_t v126 = v238 + 1;
                }

                while ((id)(v238 + 1) != v233);
                id v233 = [v209 countByEnumeratingWithState:&v262 objects:v319 count:16];
              }

              while (v233);
            }

            id v124 = v202 + 1;
          }

          while (v202 + 1 != v199);
          v199 = (char *)[v195 countByEnumeratingWithState:&v266 objects:v320 count:16];
        }

        while (v199);
      }

      id v147 = *v201;
      [v147 addObjectsFromArray:v206];

      v200 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v254 = 0u;
      __int128 v255 = 0u;
      __int128 v256 = 0u;
      __int128 v257 = 0u;
      id v203 = *v201;
      v214 = (char *)[v203 countByEnumeratingWithState:&v254 objects:v317 count:16];
      if (v214)
      {
        id v210 = *(id *)v255;
        do
        {
          __int128 v148 = 0LL;
          do
          {
            if (*(id *)v255 != v210) {
              objc_enumerationMutation(v203);
            }
            v234 = v148;
            __int128 v149 = *(void **)(*((void *)&v254 + 1) + 8LL * (void)v148);
            __int128 v250 = 0u;
            __int128 v251 = 0u;
            __int128 v252 = 0u;
            __int128 v253 = 0u;
            id v150 = v23[17];
            id v223 = [v150 countByEnumeratingWithState:&v250 objects:v316 count:16];
            if (v223)
            {
              uint64_t v151 = *(void *)v251;
              v229 = v150;
              uint64_t v219 = *(void *)v251;
              do
              {
                uint64_t v152 = 0LL;
                do
                {
                  if (*(void *)v251 != v151) {
                    objc_enumerationMutation(v150);
                  }
                  uint64_t v226 = v152;
                  __int128 v153 = *(void **)(*((void *)&v250 + 1) + 8 * v152);
                  __int128 v246 = 0u;
                  __int128 v247 = 0u;
                  __int128 v248 = 0u;
                  __int128 v249 = 0u;
                  v239 = (void *)objc_claimAutoreleasedReturnValue([v153 obliviousTargets]);
                  id v154 = [v239 countByEnumeratingWithState:&v246 objects:v315 count:16];
                  if (v154)
                  {
                    id v155 = v154;
                    uint64_t v156 = *(void *)v247;
                    do
                    {
                      for (kk = 0LL; kk != v155; kk = (char *)kk + 1)
                      {
                        if (*(void *)v247 != v156) {
                          objc_enumerationMutation(v239);
                        }
                        __int128 v158 = *(void **)(*((void *)&v246 + 1) + 8LL * (void)kk);
                        __int128 v159 = (void *)objc_claimAutoreleasedReturnValue([v153 obliviousHTTPConfig]);
                        __int128 v160 = (void *)objc_claimAutoreleasedReturnValue([v149 obliviousConfig]);
                        if ([v159 isEqualToData:v160])
                        {
                          __int128 v161 = (void *)objc_claimAutoreleasedReturnValue([v149 obliviousTarget]);
                          unsigned int v162 = [v158 isEqual:v161];

                          if (v162)
                          {
                            __int128 v163 = (void *)objc_claimAutoreleasedReturnValue([v158 targetHost]);
                            __int128 v164 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v196,  "objectForKeyedSubscript:",  v163));

                            if (v164)
                            {
                              unsigned __int8 v165 = [v164 isEqual:v158];

                              if ((v165 & 1) != 0)
                              {

                                id v23 = (id *)v204;
                                goto LABEL_184;
                              }
                            }
                          }
                        }

                        else
                        {
                        }
                      }

                      id v155 = [v239 countByEnumeratingWithState:&v246 objects:v315 count:16];
                    }

                    while (v155);
                  }

                  uint64_t v152 = v226 + 1;
                  id v23 = (id *)v204;
                  id v150 = v229;
                  uint64_t v151 = v219;
                }

                while ((id)(v226 + 1) != v223);
                id v223 = [v229 countByEnumeratingWithState:&v250 objects:v316 count:16];
              }

              while (v223);
            }

            [v149 removeProxyAgents];
            -[NSMutableArray addObject:](v200, "addObject:", v149);
LABEL_184:
            __int128 v148 = v234 + 1;
          }

          while (v234 + 1 != v214);
          v214 = (char *)[v203 countByEnumeratingWithState:&v254 objects:v317 count:16];
        }

        while (v214);
      }

      id v166 = *v201;
      [v166 removeObjectsInArray:v200];

      __int128 v244 = 0u;
      __int128 v245 = 0u;
      __int128 v242 = 0u;
      __int128 v243 = 0u;
      id v167 = *v201;
      id v168 = [v167 countByEnumeratingWithState:&v242 objects:v314 count:16];
      if (v168)
      {
        id v169 = v168;
        uint64_t v170 = *(void *)v243;
        do
        {
          v171 = 0LL;
          do
          {
            if (*(void *)v243 != v170) {
              objc_enumerationMutation(v167);
            }
            v172 = *(void **)(*((void *)&v242 + 1) + 8LL * (void)v171);
            [v172 resetStats];
            [v172 resetError];
            id v173 = [v172 pathReady];
            if ((_DWORD)v173)
            {
              uint64_t v176 = nplog_obj(v173, v174, v175);
              v177 = (os_log_s *)objc_claimAutoreleasedReturnValue(v176);
              if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
              {
                v178 = (void *)objc_claimAutoreleasedReturnValue([v172 shortName]);
                *(_DWORD *)__int128 buf = 138412290;
                v327 = v178;
                _os_log_impl( (void *)&_mh_execute_header,  v177,  OS_LOG_TYPE_DEFAULT,  "Setting up oblivious path (%@)",  buf,  0xCu);
              }

              [v172 setupProxyAgentsForceUpdateDelegate:1];
            }

            else
            {
              uint64_t v179 = objc_claimAutoreleasedReturnValue([v172 proxyInfo]);
              v180 = (void *)v179;
              if (v179) {
                v181 = *(void **)(v179 + 24);
              }
              else {
                v181 = 0LL;
              }
              id v182 = v181;

              v183 = (void *)objc_claimAutoreleasedReturnValue([v172 proxyInfo]);
              v240[0] = _NSConcreteStackBlock;
              v240[1] = 3221225472LL;
              v240[2] = sub_10002E7E4;
              v240[3] = &unk_1000F9720;
              id v184 = v182;
              id v241 = v184;
              sub_10000CF58((uint64_t)v183, v240);
            }

            v171 = (char *)v171 + 1;
          }

          while (v169 != v171);
          id v185 = [v167 countByEnumeratingWithState:&v242 objects:v314 count:16];
          id v169 = v185;
        }

        while (v185);
      }

      if (!v187) {
        *(_BYTE *)(v204 + 10) = 0;
      }
      sub_100029DC4((id *)v204);
      [(id)v204 updateUserEventAgentData];
    }
  }

void sub_10002E7E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    uint64_t v8 = (void *)v7;
    id v9 = @"failed";
    if (v3) {
      id v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Oblivious[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

LABEL_285:
    goto LABEL_274;
  }

  v359 = v14;
  if (self)
  {
    v352 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v406 = 0u;
    v407 = 0u;
    v404 = 0u;
    v405 = 0u;
    id obj = self->_proxyTokenInfoArray;
    v362 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v404,  buf,  16LL);
    if (!v362) {
      goto LABEL_57;
    }
    v356 = *(id *)v405;
    while (1)
    {
      unsigned int v38 = 0LL;
      do
      {
        if (*(id *)v405 != v356) {
          objc_enumerationMutation(obj);
        }
        id v39 = *(void *)(*((void *)&v404 + 1) + 8LL * (void)v38);
        memset(v401, 0, sizeof(v401));
        v402 = 0u;
        v403 = 0u;
        unsigned int v40 = v359;
        uint64_t v41 = [v40 countByEnumeratingWithState:v401 objects:v408 count:16];
        if (!v41) {
          goto LABEL_32;
        }
        id v42 = **(void **)&v401[16];
        do
        {
          uint64_t v43 = 0LL;
          do
          {
            if (**(void **)&v401[16] != v42) {
              objc_enumerationMutation(v40);
            }
            if (v39) {
              unsigned int v44 = *(void **)(v39 + 24);
            }
            else {
              unsigned int v44 = 0LL;
            }
            id v45 = *(void **)(*(void *)&v401[8] + 8LL * (void)v43);
            id v46 = v44;
            id v47 = (void *)objc_claimAutoreleasedReturnValue([v46 vendor]);
            uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v45 vendor]);

            LODWORD(v46) = [v47 isEqualToString:v48];
            if ((_DWORD)v46)
            {
              if (v39) {
                unsigned int v50 = *(void **)(v39 + 24);
              }
              else {
                unsigned int v50 = 0LL;
              }
              id v51 = v50;
              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 tokenKeyInfo]);
              unsigned __int8 v53 = (void *)objc_claimAutoreleasedReturnValue([v45 tokenKeyInfo]);

              id v54 = v52;
              uint64_t v55 = v53;
              uint64_t v56 = (void *)v55;

              if (v39) {
                __int128 v58 = *(void **)(v39 + 24);
              }
              else {
                __int128 v58 = 0LL;
              }
              uint32_t v59 = v58;
              id v60 = (void *)objc_claimAutoreleasedReturnValue([v59 tokenChallenge]);
              uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v45 tokenChallenge]);

              __int128 v62 = v60;
              id v63 = v61;
              id v64 = (void *)v63;
              if (!(v62 | v63) || v62 && v63 && [(id)v62 isEqual:v63])
              {

                sub_10000E01C(v39, v45);
                if ((v57 & 1) != 0)
                {
                  __int128 v66 = NPGetInternalQueue(v65);
                  __int128 v67 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v66);
                  *(void *)&v386 = _NSConcreteStackBlock;
                  *((void *)&v386 + 1) = 3221225472LL;
                  *(void *)&v387 = sub_100021CC4;
                  *((void *)&v387 + 1) = &unk_1000F9A80;
                  *(void *)&v388 = v45;
                  *((void *)&v388 + 1) = v39;
                  p_block = &v386;
                  goto LABEL_50;
                }
              }

              else
              {

                sub_10000E01C(v39, v45);
                unsigned int v70 = NPGetInternalQueue(v69);
                __int128 v67 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v70);
                *(void *)&block = _NSConcreteStackBlock;
                *((void *)&block + 1) = 3221225472LL;
                *(void *)&v391 = sub_100021BE8;
                *((void *)&v391 + 1) = &unk_1000F9A80;
                *(void *)&v392 = v45;
                *((void *)&v392 + 1) = v39;
                p_block = &block;
LABEL_50:
                dispatch_async(v67, p_block);
              }

              goto LABEL_52;
            }

            uint64_t v43 = (char *)v43 + 1;
          }

          while (v41 != v43);
          uint64_t v49 = [v40 countByEnumeratingWithState:v401 objects:v408 count:16];
          uint64_t v41 = v49;
        }

        while (v49);
LABEL_32:

        -[NSMutableArray addObject:](v352, "addObject:", v39);
LABEL_52:
        unsigned int v38 = (char *)v38 + 1;
      }

      while (v38 != v362);
      unsigned int v71 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v404,  buf,  16LL);
      v362 = v71;
      if (!v71)
      {
LABEL_57:

        -[NSMutableArray removeObjectsInArray:](val->_proxyTokenInfoArray, "removeObjectsInArray:", v352);
        id v72 = val->_fallbackProxyPath;
        id v73 = val->_proxyArray;
        fallbackProxyPathList = val->_fallbackProxyPathList;
        goto LABEL_58;
      }
    }
  }

  id v73 = 0LL;
  id v72 = 0LL;
  fallbackProxyPathList = 0LL;
LABEL_58:
  uint64_t v75 = fallbackProxyPathList;
  uint64_t v76 = -[NSPFallbackProxyPath proxyPathIsValid:proxyPathList:](v72, "proxyPathIsValid:proxyPathList:", v73, v75);

  if ((v76 & 1) != 0)
  {
    if (val)
    {
      -[NSPFallbackProxyPath resetSingleHopProxyAgent](val->_fallbackProxyPath, "resetSingleHopProxyAgent");
      fallbackProxyPath = val->_fallbackProxyPath;
    }

    else
    {
      [0 resetSingleHopProxyAgent];
      fallbackProxyPath = 0LL;
    }

    -[NSPFallbackProxyPath resetMultiHopProxyAgent](fallbackProxyPath, "resetMultiHopProxyAgent");
  }

  else
  {
    id v81 = nplog_obj(v77, v78, v79);
    id v82 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
    {
      id v83 = val;
      if (val) {
        id v83 = val->_fallbackProxyPath;
      }
      id v84 = v83;
      id v85 = objc_claimAutoreleasedReturnValue([v84 ingressProxy]);
      uint64_t v86 = (void *)v85;
      if (v85) {
        unsigned __int8 v87 = *(void **)(v85 + 24);
      }
      else {
        unsigned __int8 v87 = 0LL;
      }
      uint64_t v88 = v87;
      __int128 v89 = (char *)objc_claimAutoreleasedReturnValue([v88 tcpProxyFqdn]);
      if (val) {
        unsigned __int8 v90 = val->_fallbackProxyPath;
      }
      else {
        unsigned __int8 v90 = 0LL;
      }
      uint64_t v91 = v90;
      id v92 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v91, "egressProxy"));
      id v93 = (void *)v92;
      if (v92) {
        id v94 = *(void **)(v92 + 24);
      }
      else {
        id v94 = 0LL;
      }
      char v95 = v94;
      uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v95 tcpProxyFqdn]);
      *(_DWORD *)__int128 buf = 138412546;
      v410 = v89;
      v411 = 2112;
      v412 = v96;
      _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "Fallback proxy path (%@-%@) is not valid",  buf,  0x16u);
    }

    uint64_t v97 = sub_1000290A4((id *)&val->super.isa);
    uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue(v97);
    int v99 = v98 == 0LL;

    if (v99)
    {
      uint64_t v100 = val;
      sub_100023DF4((uint64_t)val, 0LL);
      if (val) {
        goto LABEL_75;
      }
      goto LABEL_276;
    }

    sub_100026D14((id *)&val->super.isa, 0LL);
  }

  uint64_t v100 = val;
  if (val)
  {
LABEL_75:
    uint64_t v101 = v100->_quicProxyPath;
    uint32_t v102 = v100->_proxyArray;
    proxyPathList = v100->_proxyPathList;
    goto LABEL_76;
  }

LABEL_276:
  uint32_t v102 = 0LL;
  uint64_t v101 = 0LL;
  proxyPathList = 0LL;
LABEL_76:
  uint32_t v104 = proxyPathList;
  uint64_t v105 = -[NSPQuicProxyPath proxyPathIsValid:proxyPathList:](v101, "proxyPathIsValid:proxyPathList:", v102, v104);

  if ((v105 & 1) != 0)
  {
    if (val)
    {
      -[NSPQuicProxyPath resetSingleHopProxyAgent](val->_quicProxyPath, "resetSingleHopProxyAgent");
      quicProxyPath = val->_quicProxyPath;
    }

    else
    {
      [0 resetSingleHopProxyAgent];
      quicProxyPath = 0LL;
    }

    -[NSPQuicProxyPath resetMultiHopProxyAgent](quicProxyPath, "resetMultiHopProxyAgent");
  }

  else
  {
    id v110 = nplog_obj(v106, v107, v108);
    uint64_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue(v110);
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      id v112 = val;
      if (val) {
        id v112 = val->_quicProxyPath;
      }
      id v113 = v112;
      id v114 = objc_claimAutoreleasedReturnValue([v113 ingressProxy]);
      unsigned int v115 = (void *)v114;
      if (v114) {
        id v116 = *(void **)(v114 + 24);
      }
      else {
        id v116 = 0LL;
      }
      id v117 = v116;
      char v118 = (char *)objc_claimAutoreleasedReturnValue([v117 vendor]);
      if (val) {
        id v119 = val->_quicProxyPath;
      }
      else {
        id v119 = 0LL;
      }
      uint64_t v120 = v119;
      uint64_t v121 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v120, "egressProxy"));
      uint64_t v122 = (void *)v121;
      if (v121) {
        id v123 = *(void **)(v121 + 24);
      }
      else {
        id v123 = 0LL;
      }
      id v124 = v123;
      uint64_t v125 = (void *)objc_claimAutoreleasedReturnValue([v124 vendor]);
      *(_DWORD *)__int128 buf = 138412546;
      v410 = v118;
      v411 = 2112;
      v412 = v125;
      _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEFAULT,  "Quic proxy path (%@-%@) is not valid",  buf,  0x16u);
    }

    sub_1000261CC((uint64_t)val, 0LL);
  }

  candidateQuicProxyPath = val;
  if (val) {
    candidateQuicProxyPath = val->_candidateQuicProxyPath;
  }
  id v127 = candidateQuicProxyPath;
  id v128 = v127 == 0LL;

  if (!v128)
  {
    if (val)
    {
      id v129 = val->_candidateQuicProxyPath;
      id v130 = val->_proxyArray;
      uint64_t v131 = val->_proxyPathList;
    }

    else
    {
      id v130 = 0LL;
      id v129 = 0LL;
      uint64_t v131 = 0LL;
    }

    id v132 = v131;
    id v133 = -[NSPCandidateQuicProxyPath proxyPathIsValid:proxyPathList:]( v129,  "proxyPathIsValid:proxyPathList:",  v130,  v132);

    if ((v133 & 1) == 0)
    {
      unsigned __int8 v137 = nplog_obj(v134, v135, v136);
      __int128 v138 = (os_log_s *)objc_claimAutoreleasedReturnValue(v137);
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
      {
        id v139 = val;
        if (val) {
          id v139 = val->_candidateQuicProxyPath;
        }
        __int128 v140 = v139;
        __int128 v141 = objc_claimAutoreleasedReturnValue([v140 ingressProxy]);
        __int128 v142 = (void *)v141;
        if (v141) {
          __int128 v143 = *(void **)(v141 + 24);
        }
        else {
          __int128 v143 = 0LL;
        }
        id v144 = v143;
        id v145 = (char *)objc_claimAutoreleasedReturnValue([v144 vendor]);
        if (val) {
          __int128 v146 = val->_candidateQuicProxyPath;
        }
        else {
          __int128 v146 = 0LL;
        }
        id v147 = v146;
        __int128 v148 = objc_claimAutoreleasedReturnValue(-[NSPCandidateProxyPath egressProxy](v147, "egressProxy"));
        __int128 v149 = (void *)v148;
        if (v148) {
          id v150 = *(void **)(v148 + 24);
        }
        else {
          id v150 = 0LL;
        }
        uint64_t v151 = v150;
        uint64_t v152 = (void *)objc_claimAutoreleasedReturnValue([v151 vendor]);
        *(_DWORD *)__int128 buf = 138412546;
        v410 = v145;
        v411 = 2112;
        v412 = v152;
        _os_log_impl( (void *)&_mh_execute_header,  v138,  OS_LOG_TYPE_DEFAULT,  "Candidate Quic proxy path (%@-%@) is not valid",  buf,  0x16u);
      }

      sub_100023E04((uint64_t)val, 0LL);
      sub_1000261CC((uint64_t)val, 0LL);
    }
  }

  candidateFallbackProxyPath = val;
  if (val) {
    candidateFallbackProxyPath = val->_candidateFallbackProxyPath;
  }
  id v154 = candidateFallbackProxyPath;
  id v155 = v154 == 0LL;

  if (!v155)
  {
    if (val)
    {
      uint64_t v156 = val->_candidateFallbackProxyPath;
      __int128 v157 = val->_proxyArray;
      __int128 v158 = val->_fallbackProxyPathList;
    }

    else
    {
      __int128 v157 = 0LL;
      uint64_t v156 = 0LL;
      __int128 v158 = 0LL;
    }

    __int128 v159 = v158;
    __int128 v160 = -[NSPCandidateFallbackProxyPath proxyPathIsValid:proxyPathList:]( v156,  "proxyPathIsValid:proxyPathList:",  v157,  v159);

    if ((v160 & 1) == 0)
    {
      __int128 v164 = nplog_obj(v161, v162, v163);
      unsigned __int8 v165 = (os_log_s *)objc_claimAutoreleasedReturnValue(v164);
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
      {
        id v166 = val;
        if (val) {
          id v166 = val->_candidateFallbackProxyPath;
        }
        id v167 = v166;
        id v168 = objc_claimAutoreleasedReturnValue([v167 ingressProxy]);
        id v169 = (void *)v168;
        if (v168) {
          uint64_t v170 = *(void **)(v168 + 24);
        }
        else {
          uint64_t v170 = 0LL;
        }
        v171 = v170;
        v172 = (char *)objc_claimAutoreleasedReturnValue([v171 tcpProxyFqdn]);
        if (val) {
          id v173 = val->_candidateFallbackProxyPath;
        }
        else {
          id v173 = 0LL;
        }
        uint64_t v174 = v173;
        uint64_t v175 = objc_claimAutoreleasedReturnValue(-[NSPCandidateProxyPath egressProxy](v174, "egressProxy"));
        uint64_t v176 = (void *)v175;
        if (v175) {
          v177 = *(void **)(v175 + 24);
        }
        else {
          v177 = 0LL;
        }
        v178 = v177;
        uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue([v178 tcpProxyFqdn]);
        *(_DWORD *)__int128 buf = 138412546;
        v410 = v172;
        v411 = 2112;
        v412 = v179;
        _os_log_impl( (void *)&_mh_execute_header,  v165,  OS_LOG_TYPE_DEFAULT,  "Candidate Fallback proxy path (%@-%@) is not valid",  buf,  0x16u);
      }

      sub_100023E14((uint64_t)val, 0LL);
      sub_100026D14((id *)&val->super.isa, 0LL);
    }
  }

  v368 = 0u;
  v369 = 0u;
  v366 = 0u;
  v367 = 0u;
  preferredQUICProxyPaths = val;
  if (val) {
    preferredQUICProxyPaths = val->_preferredQUICProxyPaths;
  }
  v181 = preferredQUICProxyPaths;
  id v182 = [v181 countByEnumeratingWithState:&v366 objects:v394 count:16];
  if (v182)
  {
    v183 = *(void *)v367;
    do
    {
      id v184 = 0LL;
      do
      {
        if (*(void *)v367 != v183) {
          objc_enumerationMutation(v181);
        }
        if (val) {
          id v185 = val->_preferredQUICProxyPaths;
        }
        else {
          id v185 = 0LL;
        }
        uint64_t v186 = *(void *)(*((void *)&v366 + 1) + 8LL * (void)v184);
        int v187 = v185;
        v188 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v187, "objectForKeyedSubscript:", v186));

        if (val)
        {
          uint64_t v189 = val->_proxyArray;
          id v190 = val->_proxyPathList;
        }

        else
        {
          uint64_t v189 = 0LL;
          id v190 = 0LL;
        }

        uint64_t v191 = v190;
        uint64_t v192 = [v188 proxyPathIsValid:v189 proxyPathList:v191];

        if (v192) {
          [v188 resetMultiHopProxyAgent];
        }

        id v184 = (char *)v184 + 1;
      }

      while (v182 != v184);
      v193 = [v181 countByEnumeratingWithState:&v366 objects:v394 count:16];
      id v182 = v193;
    }

    while (v193);
  }

  if (val && !-[NSPPrivacyProxyAgentManager forceFallback](val, "forceFallback"))
  {
    id obja = (id *)&val->_candidatePreferredQUICProxyPaths;
    if (!val->_candidatePreferredQUICProxyPaths)
    {
      id v194 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      objc_storeStrong(obja, v194);
    }

    v353 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    v392 = 0u;
    v393 = 0u;
    block = 0u;
    v391 = 0u;
    v346 = val->_proxyArray;
    v351 = (id *)-[NSArray countByEnumeratingWithState:objects:count:]( v346,  "countByEnumeratingWithState:objects:count:",  &block,  buf,  16LL);
    if (v351)
    {
      to = *(id **)v391;
      do
      {
        v360 = 0LL;
        do
        {
          if (*(id **)v391 != to) {
            objc_enumerationMutation(v346);
          }
          id v195 = *(void **)(*((void *)&block + 1) + 8LL * (void)v360);
          if (([v195 hasPreferredPathConfigUri] & 1) == 0
            && ![v195 preferredPathPatternsCount])
          {
            goto LABEL_226;
          }

          v363 = objc_claimAutoreleasedReturnValue([v195 vendor]);
          v196 = (void *)v363;
          if (!v363) {
            goto LABEL_225;
          }
          v357 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*obja, "objectForKeyedSubscript:"));
          if (v357)
          {
            uint64_t v197 = val->_proxyPathList;
            uint64_t v198 = val->_proxyArray;
            v199 = [v357 proxyPathIsValid:v198 proxyPathList:v197];

            if ((v199 & 1) != 0)
            {
              id v203 = (void *)objc_claimAutoreleasedReturnValue([v357 preferredPathConfigURI]);
              uint64_t v204 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathConfigUri]);
              id WeakRetained = v203;
              v206 = v204;
              id v207 = (void *)v206;
              if (!(WeakRetained | v206)
                || (v212 = (void *)v206, (id v210 = WeakRetained) != 0)
                && (v212 = (void *)v206, id v210 = WeakRetained, v206)
                && (v212 = (void *)v206,
                    id v210 = WeakRetained,
                    [(id)WeakRetained isEqual:v206]))
              {

                id v208 = (void *)objc_claimAutoreleasedReturnValue([v357 preferredPathPatterns]);
                id v209 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathPatterns]);
                id v210 = v208;
                id v211 = v209;
                v212 = (void *)v211;
                if (v210 | v211 && (!v210 || !v211 || ![(id)v210 isEqual:v211]))
                {

                  goto LABEL_190;
                }
              }

              else
              {
LABEL_190:

                __int128 v243 = nplog_obj(v240, v241, v242);
                __int128 v244 = (os_log_s *)objc_claimAutoreleasedReturnValue(v243);
                if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
                {
                  __int128 v245 = objc_claimAutoreleasedReturnValue([v357 ingressProxy]);
                  __int128 v246 = (void *)v245;
                  if (v245) {
                    __int128 v247 = *(void **)(v245 + 24);
                  }
                  else {
                    __int128 v247 = 0LL;
                  }
                  __int128 v248 = v247;
                  __int128 v249 = (void *)objc_claimAutoreleasedReturnValue([v248 vendor]);
                  __int128 v250 = objc_claimAutoreleasedReturnValue([v357 egressProxy]);
                  __int128 v251 = (void *)v250;
                  if (v250) {
                    __int128 v252 = *(void **)(v250 + 24);
                  }
                  else {
                    __int128 v252 = 0LL;
                  }
                  __int128 v253 = v252;
                  __int128 v254 = (void *)objc_claimAutoreleasedReturnValue([v253 vendor]);
                  *(_DWORD *)v401 = 138412802;
                  *(void *)&v401[4] = v363;
                  *(_WORD *)&v401[12] = 2112;
                  *(void *)&v401[14] = v249;
                  *(_WORD *)&v401[22] = 2112;
                  *(void *)&v401[24] = v254;
                  _os_log_impl( (void *)&_mh_execute_header,  v244,  OS_LOG_TYPE_DEFAULT,  "Candidate preferred proxy path for vendor %@ (%@-%@) has new matching rules, updating",  v401,  0x20u);
                }

                __int128 v255 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathConfigUri]);
                [v357 setPreferredPathConfigURI:v255];

                [v357 setDomainFilter:0];
                __int128 v256 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathPatterns]);
                [v357 setPreferredPathPatterns:v256];

                -[NSMutableDictionary setObject:forKeyedSubscript:]( val->_preferredQUICProxyPaths,  "setObject:forKeyedSubscript:",  0LL,  v363);
                id WeakRetained = (unint64_t)objc_loadWeakRetained((id *)&val->_delegate);
                [(id)WeakRetained preferredProxyAgentUnregistered:v363];
              }

              [v353 addObject:v363];
              goto LABEL_224;
            }

            unsigned int v213 = nplog_obj(v200, v201, v202);
            v214 = (os_log_s *)objc_claimAutoreleasedReturnValue(v213);
            if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v215 = objc_claimAutoreleasedReturnValue([v357 ingressProxy]);
              v216 = (void *)v215;
              if (v215) {
                uint64_t v217 = *(void **)(v215 + 24);
              }
              else {
                uint64_t v217 = 0LL;
              }
              v218 = v217;
              uint64_t v219 = (void *)objc_claimAutoreleasedReturnValue([v218 vendor]);
              v220 = objc_claimAutoreleasedReturnValue([v357 egressProxy]);
              int v221 = (void *)v220;
              if (v220) {
                id v222 = *(void **)(v220 + 24);
              }
              else {
                id v222 = 0LL;
              }
              id v223 = v222;
              char v224 = (void *)objc_claimAutoreleasedReturnValue([v223 vendor]);
              *(_DWORD *)v401 = 138412802;
              *(void *)&v401[4] = v363;
              *(_WORD *)&v401[12] = 2112;
              *(void *)&v401[14] = v219;
              *(_WORD *)&v401[22] = 2112;
              *(void *)&v401[24] = v224;
              _os_log_impl( (void *)&_mh_execute_header,  v214,  OS_LOG_TYPE_DEFAULT,  "Candidate preferred proxy path for vendor %@ (%@-%@) is not valid",  v401,  0x20u);
            }

            [*obja setObject:0 forKeyedSubscript:v363];
          }

          v388 = 0u;
          v389 = 0u;
          v386 = 0u;
          v387 = 0u;
          v225 = val->_proxyPathList;
          uint64_t v226 = -[NSArray countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v386,  v408,  16LL);
          if (!v226) {
            goto LABEL_175;
          }
          v227 = *(void *)v387;
          do
          {
            for (i = 0LL; i != v226; i = (char *)i + 1)
            {
              if (*(void *)v387 != v227) {
                objc_enumerationMutation(v225);
              }
              v229 = *(void **)(*((void *)&v386 + 1) + 8LL * (void)i);
              id v230 = val->_proxyArray;
              id v231 = (void *)objc_claimAutoreleasedReturnValue( -[NSArray objectAtIndex:]( v230,  "objectAtIndex:",  *((unsigned int *)[v229 proxies] + 1)));

              if ([v231 isEqual:v195])
              {
                v347 = v229;

                if (!v347) {
                  goto LABEL_180;
                }
                v235 = val->_proxyArray;
                uint64_t v236 = (void *)objc_claimAutoreleasedReturnValue( -[NSArray objectAtIndex:]( v235,  "objectAtIndex:",  *(unsigned int *)[v347 proxies]));

                if (v236)
                {
                  uint64_t v237 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager overrideIngressProxy](val, "overrideIngressProxy"));
                  if (v237)
                  {

                    goto LABEL_199;
                  }

                  __int128 v257 = (void *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager overrideIngressProxyKey]( val,  "overrideIngressProxyKey"));
                  __int128 v258 = v257 == 0LL;

                  if (v258)
                  {
                    v345 = v236;
                  }

                  else
                  {
LABEL_199:
                    v345 = [v236 copy];

                    __int128 v259 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager overrideIngressProxy](val, "overrideIngressProxy"));
                    __int128 v260 = v259 == 0LL;

                    if (!v260)
                    {
                      __int128 v261 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager overrideIngressProxy](val, "overrideIngressProxy"));
                      [v345 setProxyURL:v261];
                    }

                    __int128 v262 = (void *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager overrideIngressProxyKey]( val,  "overrideIngressProxyKey"));
                    __int128 v263 = v262 == 0LL;

                    if (!v263)
                    {
                      [v345 clearProxyKeyInfos];
                      __int128 v264 = (void *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager overrideIngressProxyKey]( val,  "overrideIngressProxyKey"));
                      [v345 addProxyKeyInfo:v264];
                    }
                  }

                  __int128 v265 = sub_10002991C((uint64_t)val, v345);
                  v344 = (void *)objc_claimAutoreleasedReturnValue(v265);
                  __int128 v266 = sub_10002991C((uint64_t)val, v195);
                  v343 = (void *)objc_claimAutoreleasedReturnValue(v266);
                  if (v344 && v343)
                  {
                    __int128 v267 = objc_alloc(&OBJC_CLASS___NSPCandidateQuicProxyPath);
                    __int128 v268 = [v347 weight];
                    __int128 v269 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathConfigUri]);
                    __int128 v270 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathPatterns]);
                    v349 = -[NSPCandidateProxyPath initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:]( v267,  "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:",  v344,  v343,  v268,  v269,  v270);

                    v384 = 0u;
                    v385 = 0u;
                    v382 = 0u;
                    v383 = 0u;
                    __int128 v271 = val->_savedConfiguredPreferredPaths;
                    __int128 v272 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v271,  "countByEnumeratingWithState:objects:count:",  &v382,  &v404,  16LL);
                    if (v272)
                    {
                      __int128 v273 = *(void *)v383;
                      do
                      {
                        for (j = 0LL; j != v272; j = (char *)j + 1)
                        {
                          if (*(void *)v383 != v273) {
                            objc_enumerationMutation(v271);
                          }
                          __int128 v275 = *(void **)(*((void *)&v382 + 1) + 8LL * (void)j);
                          __int128 v276 = (void *)objc_claimAutoreleasedReturnValue([v275 objectForKey:@"Vendor"]);
                          __int128 v277 = (void *)objc_claimAutoreleasedReturnValue([v275 objectForKey:@"PreferredPathConfigURL"]);
                          __int128 v278 = (void *)objc_claimAutoreleasedReturnValue([v275 objectForKey:@"DomainFilter"]);
                          if (v276)
                          {
                            __int128 v279 = objc_opt_class(&OBJC_CLASS___NSString);
                            if ((objc_opt_isKindOfClass(v276, v279) & (v277 != 0LL)) == 1)
                            {
                              __int128 v280 = objc_opt_class(&OBJC_CLASS___NSString);
                              if ((objc_opt_isKindOfClass(v277, v280) & (v278 != 0LL)) == 1)
                              {
                                __int128 v281 = objc_opt_class(&OBJC_CLASS___NSData);
                                if ((objc_opt_isKindOfClass(v278, v281) & 1) != 0)
                                {
                                  if ([v276 isEqualToString:v363])
                                  {
                                    __int128 v282 = (void *)objc_claimAutoreleasedReturnValue([v195 preferredPathConfigUri]);
                                    __int128 v283 = [v282 isEqualToString:v277];

                                    if (v283) {
                                      -[NSPCandidateProxyPath setDomainFilter:](v349, "setDomainFilter:", v278);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        __int128 v272 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v271,  "countByEnumeratingWithState:objects:count:",  &v382,  &v404,  16LL);
                      }

                      while (v272);
                    }

                    [*obja setObject:v349 forKeyedSubscript:v363];
                    [v353 addObject:v363];
                  }
                }

                v239 = (os_log_s *)v347;
                goto LABEL_223;
              }
            }

            uint64_t v226 = -[NSArray countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v386,  v408,  16LL);
          }

          while (v226);
LABEL_175:

LABEL_180:
          uint64_t v238 = nplog_obj(v232, v233, v234);
          v239 = (os_log_s *)objc_claimAutoreleasedReturnValue(v238);
          if (os_log_type_enabled(v239, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)v401 = 138412290;
            *(void *)&v401[4] = v363;
            _os_log_impl( (void *)&_mh_execute_header,  v239,  OS_LOG_TYPE_INFO,  "No preferred path found for vendor %@",  v401,  0xCu);
          }

LABEL_223:
LABEL_224:
          v196 = (void *)v363;
LABEL_225:

LABEL_226:
          v360 = (id *)((char *)v360 + 1);
        }

        while (v360 != v351);
        __int128 v284 = (id *)-[NSArray countByEnumeratingWithState:objects:count:]( v346,  "countByEnumeratingWithState:objects:count:",  &block,  buf,  16LL);
        v351 = v284;
      }

      while (v284);
    }

    objc_storeStrong((id *)&val->_savedConfiguredPreferredPaths, 0LL);
    __int128 v285 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](val->_candidatePreferredQUICProxyPaths, "allKeys"));
    v380 = 0u;
    v381 = 0u;
    v378 = 0u;
    v379 = 0u;
    v358 = v285;
    v364 = [v358 countByEnumeratingWithState:&v378 objects:v401 count:16];
    if (!v364) {
      goto LABEL_270;
    }
    v361 = *(void *)v379;
LABEL_235:
    __int128 v286 = 0LL;
    while (1)
    {
      if (*(void *)v379 != v361) {
        objc_enumerationMutation(v358);
      }
      __int128 v287 = *(void **)(*((void *)&v378 + 1) + 8 * v286);
      __int128 v288 = (void *)objc_claimAutoreleasedReturnValue([*obja objectForKeyedSubscript:v287]);
      __int128 v289 = [v353 containsObject:v287];
      if ((v289 & 1) == 0)
      {
        __int128 v309 = nplog_obj(v289, v290, v291);
        __int128 v310 = (os_log_s *)objc_claimAutoreleasedReturnValue(v309);
        if (os_log_type_enabled(v310, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v311 = objc_claimAutoreleasedReturnValue([v288 ingressProxy]);
          __int128 v312 = (void *)v311;
          if (v311) {
            __int128 v313 = *(void **)(v311 + 24);
          }
          else {
            __int128 v313 = 0LL;
          }
          v314 = v313;
          v315 = (void *)objc_claimAutoreleasedReturnValue([v314 vendor]);
          v316 = objc_claimAutoreleasedReturnValue([v288 egressProxy]);
          v317 = (void *)v316;
          if (v316) {
            v318 = *(void **)(v316 + 24);
          }
          else {
            v318 = 0LL;
          }
          v319 = v318;
          v320 = (void *)objc_claimAutoreleasedReturnValue([v319 vendor]);
          *(_DWORD *)v395 = 138412802;
          v396 = v287;
          v397 = 2112;
          v398 = v315;
          v399 = 2112;
          v400 = v320;
          _os_log_impl( (void *)&_mh_execute_header,  v310,  OS_LOG_TYPE_DEFAULT,  "Preferred proxy path for vendor %@ (%@-%@) has been removed",  v395,  0x20u);
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:]( val->_candidatePreferredQUICProxyPaths,  "setObject:forKeyedSubscript:",  0LL,  v287);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( val->_preferredQUICProxyPaths,  "setObject:forKeyedSubscript:",  0LL,  v287);
        __int128 v292 = objc_loadWeakRetained((id *)&val->_delegate);
        [v292 preferredProxyAgentUnregistered:v287];
        goto LABEL_262;
      }

      if (![v288 proxyPathReady])
      {
        v321 = objc_claimAutoreleasedReturnValue([v288 ingressProxy]);
        v322 = (void *)v321;
        if (v321) {
          v323 = *(void **)(v321 + 24);
        }
        else {
          v323 = 0LL;
        }
        v324 = v323;

        v325 = objc_claimAutoreleasedReturnValue([v288 egressProxy]);
        v326 = (void *)v325;
        if (v325) {
          v327 = *(void **)(v325 + 24);
        }
        else {
          v327 = 0LL;
        }
        __int16 v328 = v327;

        v329 = (void *)objc_claimAutoreleasedReturnValue([v288 ingressProxy]);
        v376[0] = _NSConcreteStackBlock;
        v376[1] = 3221225472LL;
        v376[2] = sub_10002B698;
        v376[3] = &unk_1000F9720;
        __int128 v292 = v324;
        v377 = v292;
        sub_10000CF58((uint64_t)v329, v376);

        v330 = (void *)objc_claimAutoreleasedReturnValue([v288 egressProxy]);
        v374[0] = _NSConcreteStackBlock;
        v374[1] = 3221225472LL;
        v374[2] = sub_10002B77C;
        v374[3] = &unk_1000F9720;
        v331 = v328;
        v375 = v331;
        sub_10000CF58((uint64_t)v330, v374);

        objc_initWeak((id *)v395, val);
        v370[0] = _NSConcreteStackBlock;
        v370[1] = 3221225472LL;
        v370[2] = sub_10002B860;
        v370[3] = &unk_1000F9AD0;
        v332 = v331;
        v371 = v332;
        objc_copyWeak(&v373, (id *)v395);
        v372 = v287;
        [v288 fetchDomainFilter:v370];
        objc_destroyWeak(&v373);

        objc_destroyWeak((id *)v395);
        goto LABEL_262;
      }

      __int128 v292 = (id)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( val->_preferredQUICProxyPaths,  "objectForKeyedSubscript:",  v287));
      if (!v292) {
        goto LABEL_249;
      }
      __int128 v293 = val->_proxyPathList;
      __int128 v294 = val->_proxyArray;
      LOBYTE(v293) = [v292 proxyPathIsValid:v294 proxyPathList:v293];

LABEL_262:
      if (v364 == (id)++v286)
      {
        v333 = [v358 countByEnumeratingWithState:&v378 objects:v401 count:16];
        v364 = v333;
        if (!v333)
        {
LABEL_270:

          sub_100029DC4((id *)&val->super.isa);
          -[NSPPrivacyProxyAgentManager updateUserEventAgentData](val, "updateUserEventAgentData");
          sub_10002AB04((uint64_t)val);

          goto LABEL_271;
        }

        goto LABEL_235;
      }
    }

    __int128 v298 = nplog_obj(v295, v296, v297);
    __int128 v299 = (os_log_s *)objc_claimAutoreleasedReturnValue(v298);
    if (os_log_type_enabled(v299, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v300 = objc_claimAutoreleasedReturnValue([v292 ingressProxy]);
      v348 = (void *)v300;
      __int128 v301 = (void *)v300;
      if (v300) {
        __int128 v301 = *(void **)(v300 + 24);
      }
      __int128 v302 = v301;
      __int128 v303 = (void *)objc_claimAutoreleasedReturnValue([v302 vendor]);
      __int128 v304 = objc_claimAutoreleasedReturnValue([v292 egressProxy]);
      __int128 v305 = (void *)v304;
      if (v304) {
        __int128 v306 = *(void **)(v304 + 24);
      }
      else {
        __int128 v306 = 0LL;
      }
      __int128 v307 = v306;
      __int128 v308 = (void *)objc_claimAutoreleasedReturnValue([v307 vendor]);
      *(_DWORD *)v395 = 138412802;
      v396 = v287;
      v397 = 2112;
      v398 = v303;
      v399 = 2112;
      v400 = v308;
      _os_log_impl( (void *)&_mh_execute_header,  v299,  OS_LOG_TYPE_DEFAULT,  "Preferred proxy path for vendor %@ (%@-%@) is not valid",  v395,  0x20u);
    }

LABEL_249:
    sub_10002B398((uint64_t)val, v287);
    __int128 v292 = 0LL;
    goto LABEL_262;
  }

LABEL_271:
  sub_10002C184((id *)&val->super.isa);
  sub_10002D130((uint64_t)val);
  if (val) {
    val->_deferAgentCommit = 0;
  }
  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](val, "updateUserEventAgentData");
LABEL_274:
}

void sub_1000307AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id *location)
{
}

void sub_100031890(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    int v10 = (void *)v9;
    uint64_t v11 = @"failed";
    if (v3) {
      uint64_t v11 = @"succesfully";
    }
    int v12 = 138412546;
    uint64_t v13 = v9;
    __int16 v14 = 2112;
    id v15 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token for %@ fetched %@",  (uint8_t *)&v12,  0x16u);
  }
}

void sub_100031988(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    int v10 = (void *)v9;
    uint64_t v11 = @"failed";
    if (v3) {
      uint64_t v11 = @"succesfully";
    }
    int v12 = 138412546;
    uint64_t v13 = v9;
    __int16 v14 = 2112;
    id v15 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token for %@ fetched %@",  (uint8_t *)&v12,  0x16u);
  }
}

void sub_100031A80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    int v10 = (void *)v9;
    uint64_t v11 = @"failed";
    if (v3) {
      uint64_t v11 = @"succesfully";
    }
    int v12 = 138412546;
    uint64_t v13 = v9;
    __int16 v14 = 2112;
    id v15 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token for %@ fetched %@",  (uint8_t *)&v12,  0x16u);
  }
}

void sub_100031B78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    int v10 = (void *)v9;
    uint64_t v11 = @"failed";
    if (v3) {
      uint64_t v11 = @"succesfully";
    }
    int v12 = 138412546;
    uint64_t v13 = v9;
    __int16 v14 = 2112;
    id v15 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token for %@ fetched %@",  (uint8_t *)&v12,  0x16u);
  }
}

void sub_100031C70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[3];
    }
    uint64_t v8 = v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 vendor]);
    int v10 = (void *)v9;
    uint64_t v11 = @"failed";
    if (v3) {
      uint64_t v11 = @"succesfully";
    }
    int v12 = 138412546;
    uint64_t v13 = v9;
    __int16 v14 = 2112;
    id v15 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token for %@ fetched %@",  (uint8_t *)&v12,  0x16u);
  }
}

void sub_100031D68(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 224);
    if (v2)
    {
      id v3 = [v2 proxyPathReady];
      if ((_DWORD)v3)
      {
        uint64_t v6 = nplog_obj(v3, v4, v5);
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          id v8 = *(id *)(a1 + 224);
          uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 ingressProxy]);
          int v10 = (void *)v9;
          if (v9) {
            uint64_t v11 = *(void **)(v9 + 24);
          }
          else {
            uint64_t v11 = 0LL;
          }
          id v12 = v11;
          uint64_t v13 = (char *)objc_claimAutoreleasedReturnValue([v12 vendor]);
          id v14 = *(id *)(a1 + 224);
          uint64_t v15 = objc_claimAutoreleasedReturnValue([v14 egressProxy]);
          BOOL v16 = (void *)v15;
          if (v15) {
            char v17 = *(void **)(v15 + 24);
          }
          else {
            char v17 = 0LL;
          }
          id v18 = v17;
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 vendor]);
          *(_DWORD *)__int128 buf = 138412546;
          v180 = v13;
          __int16 v181 = 2112;
          id v182 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Setting quic proxy path (%@-%@)",  buf,  0x16u);
        }

        sub_10002A4AC(a1, v20, v21);
      }

      else
      {
        id v22 = *(id *)(a1 + 224);
        uint64_t v23 = objc_claimAutoreleasedReturnValue([v22 ingressProxy]);
        id v24 = (void *)v23;
        if (v23) {
          id v25 = *(void **)(v23 + 24);
        }
        else {
          id v25 = 0LL;
        }
        id v26 = v25;

        id v27 = *(id *)(a1 + 224);
        uint64_t v28 = objc_claimAutoreleasedReturnValue([v27 egressProxy]);
        char v29 = (void *)v28;
        if (v28) {
          id v30 = *(void **)(v28 + 24);
        }
        else {
          id v30 = 0LL;
        }
        id v31 = v30;

        id v32 = *(id *)(a1 + 224);
        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 ingressProxy]);
        v168[0] = _NSConcreteStackBlock;
        v168[1] = 3221225472LL;
        v168[2] = sub_1000328D0;
        v168[3] = &unk_1000F9720;

        id v169 = v26;
        id v34 = v26;
        sub_10000CF58((uint64_t)v33, v168);

        id v35 = *(id *)(a1 + 224);
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 egressProxy]);
        v166[0] = _NSConcreteStackBlock;
        v166[1] = 3221225472LL;
        v166[2] = sub_1000329B4;
        v166[3] = &unk_1000F9720;

        id v167 = v31;
        id v37 = v31;
        sub_10000CF58((uint64_t)v36, v166);
      }
    }

    unsigned int v38 = *(void **)(a1 + 232);
    if (v38)
    {
      id v39 = [v38 proxyPathReady];
      if ((_DWORD)v39)
      {
        uint64_t v42 = nplog_obj(v39, v40, v41);
        uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          id v44 = *(id *)(a1 + 232);
          uint64_t v45 = objc_claimAutoreleasedReturnValue([v44 ingressProxy]);
          id v46 = (void *)v45;
          if (v45) {
            id v47 = *(void **)(v45 + 24);
          }
          else {
            id v47 = 0LL;
          }
          id v48 = v47;
          uint64_t v49 = (char *)objc_claimAutoreleasedReturnValue([v48 vendor]);
          id v50 = *(id *)(a1 + 232);
          uint64_t v51 = objc_claimAutoreleasedReturnValue([v50 egressProxy]);
          uint64_t v52 = (void *)v51;
          if (v51) {
            unsigned __int8 v53 = *(void **)(v51 + 24);
          }
          else {
            unsigned __int8 v53 = 0LL;
          }
          id v54 = v53;
          uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v54 vendor]);
          *(_DWORD *)__int128 buf = 138412546;
          v180 = v49;
          __int16 v181 = 2112;
          id v182 = v55;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Setting fallback proxy path (%@-%@)",  buf,  0x16u);
        }

        sub_10002BB90(a1, v56, v57);
      }

      else
      {
        id v58 = *(id *)(a1 + 232);
        uint64_t v59 = objc_claimAutoreleasedReturnValue([v58 ingressProxy]);
        id v60 = (void *)v59;
        if (v59) {
          uint64_t v61 = *(void **)(v59 + 24);
        }
        else {
          uint64_t v61 = 0LL;
        }
        id v62 = v61;

        id v63 = *(id *)(a1 + 232);
        uint64_t v64 = objc_claimAutoreleasedReturnValue([v63 egressProxy]);
        __int128 v65 = (void *)v64;
        if (v64) {
          __int128 v66 = *(void **)(v64 + 24);
        }
        else {
          __int128 v66 = 0LL;
        }
        id v67 = v66;

        id v68 = *(id *)(a1 + 232);
        __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v68 ingressProxy]);
        v164[0] = _NSConcreteStackBlock;
        v164[1] = 3221225472LL;
        v164[2] = sub_100032A98;
        v164[3] = &unk_1000F9720;

        id v165 = v62;
        id v70 = v62;
        sub_10000CF58((uint64_t)v69, v164);

        id v71 = *(id *)(a1 + 232);
        id v72 = (void *)objc_claimAutoreleasedReturnValue([v71 egressProxy]);
        v162[0] = _NSConcreteStackBlock;
        v162[1] = 3221225472LL;
        v162[2] = sub_100032B7C;
        v162[3] = &unk_1000F9720;

        id v163 = v67;
        id v73 = v67;
        sub_10000CF58((uint64_t)v72, v162);
      }
    }

    __int128 v160 = 0u;
    __int128 v161 = 0u;
    __int128 v158 = 0u;
    __int128 v159 = 0u;
    id v74 = *(id *)(a1 + 312);
    id v75 = [v74 countByEnumeratingWithState:&v158 objects:v178 count:16];
    if (v75)
    {
      id v76 = v75;
      uint64_t v77 = *(void *)v159;
      do
      {
        for (i = 0LL; i != v76; i = (char *)i + 1)
        {
          if (*(void *)v159 != v77) {
            objc_enumerationMutation(v74);
          }
          __int128 v79 = *(void **)(*((void *)&v158 + 1) + 8LL * (void)i);
          __int128 v80 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 312) objectForKeyedSubscript:v79]);
        }

        id v76 = [v74 countByEnumeratingWithState:&v158 objects:v178 count:16];
      }

      while (v76);
    }

    __int128 v156 = 0u;
    __int128 v157 = 0u;
    __int128 v154 = 0u;
    __int128 v155 = 0u;
    id v81 = *(id *)(a1 + 336);
    id v145 = [v81 countByEnumeratingWithState:&v154 objects:v177 count:16];
    if (v145)
    {
      uint64_t v82 = *(void *)v155;
      id v143 = v81;
      uint64_t v144 = *(void *)v155;
      do
      {
        id v83 = 0LL;
        do
        {
          if (*(void *)v155 != v82) {
            objc_enumerationMutation(v81);
          }
          id v84 = *(void **)(*((void *)&v154 + 1) + 8LL * (void)v83);
          id v85 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 336) objectForKeyedSubscript:v84]);
          if (v85)
          {
            id v86 = *(id *)(a1 + 368);
            unsigned __int8 v87 = (void *)objc_claimAutoreleasedReturnValue([v86 interface]);
            uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([v87 interfaceName]);
            unsigned int v89 = [v84 isEqualToString:v88];

            if (v89)
            {
              id v90 = v84;
              id v91 = v85;
              id v92 = [(id)a1 forceFallback];
              if ((v92 & 1) == 0)
              {
                if (v90)
                {
                  __int128 v173 = 0u;
                  __int128 v174 = 0u;
                  __int128 v171 = 0u;
                  __int128 v172 = 0u;
                  id v95 = *(id *)(a1 + 88);
                  id v96 = [v95 countByEnumeratingWithState:&v171 objects:buf count:16];
                  if (v96)
                  {
                    id v97 = v96;
                    uint64_t v98 = *(void *)v172;
LABEL_50:
                    uint64_t v99 = 0LL;
                    while (1)
                    {
                      if (*(void *)v172 != v98) {
                        objc_enumerationMutation(v95);
                      }
                      uint64_t v100 = *(void **)(*((void *)&v171 + 1) + 8 * v99);
                      if ([v100 proxyHop] == 2
                        || [v100 proxyHop] == 3)
                      {
                        break;
                      }

                      if (v97 == (id)++v99)
                      {
                        id v97 = [v95 countByEnumeratingWithState:&v171 objects:buf count:16];
                        if (v97) {
                          goto LABEL_50;
                        }
                        goto LABEL_57;
                      }
                    }

                    uint32_t v104 = v100;

                    if (!v104) {
                      goto LABEL_64;
                    }
                    uint64_t v105 = sub_10002991C(a1, v91);
                    uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue(v105);
                    __int128 v140 = v104;
                    uint64_t v107 = sub_10002991C(a1, v104);
                    id v139 = (void *)objc_claimAutoreleasedReturnValue(v107);
                    __int128 v141 = objc_alloc(&OBJC_CLASS___NSPQuicProxyPath);
                    __int128 v142 = v91;
                    unsigned int v138 = [v91 supportsFallback];
                    BOOL v108 = *(_BYTE *)(a1 + 13) == 0;
                    char v109 = *(_BYTE *)(a1 + 15);
                    id v110 = *(void **)(a1 + 400);
                    id v111 = *(id *)(a1 + 368);
                    id v112 = v110;
                    id v113 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  v111);
                    BYTE2(v137) = v109;
                    BYTE1(v137) = v108;
                    LOBYTE(v137) = 0;
                    id v114 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:]( v141,  "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forc eFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:",  a1,  v106,  v139,  0LL,  v138,  1LL,  v137,  v112,  v113);

                    unsigned int v115 = *(void **)(a1 + 328);
                    if (!v115)
                    {
                      id v116 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
                      id v117 = *(void **)(a1 + 328);
                      *(void *)(a1 + 32_Block_object_dispose(va, 8) = v116;

                      unsigned int v115 = *(void **)(a1 + 328);
                    }

                    [v115 setObject:v114 forKey:v90];
                    char v118 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 336) objectForKey:v90]);

                    if (v118) {
                      [*(id *)(a1 + 336) removeObjectForKey:v90];
                    }
                    id v91 = v142;
                    id v119 = (void *)objc_claimAutoreleasedReturnValue([v142 vendor]);
                    uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Agent_%@_%@",  v90,  v119));

                    -[NSPQuicProxyPath setupNetworkSpecificMultiHopProxyRegistrations:]( v114,  "setupNetworkSpecificMultiHopProxyRegistrations:",  v120);
                    -[NSPProxyPath resetStats](v114, "resetStats");
                    -[NSPProxyPath resetError](v114, "resetError");
                    ++*(void *)(a1 + 544);
                    +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-path-changed");

                    id v81 = v143;
                    uint64_t v121 = v140;
                  }

                  else
                  {
LABEL_57:

LABEL_64:
                    uint64_t v122 = nplog_obj(v101, v102, v103);
                    uint64_t v121 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
                    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)uint64_t v170 = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEFAULT,  "Could not find a suitable egress proxy",  v170,  2u);
                    }

                    id v81 = v143;
                  }
                }

                else
                {
                  uint64_t v123 = nplog_obj(v92, v93, v94);
                  uint64_t v121 = (os_log_s *)objc_claimAutoreleasedReturnValue(v123);
                  if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)__int128 buf = 136315138;
                    v180 = "-[NSPPrivacyProxyAgentManager setupNetworkSpecificQUICProxyPathFor:andIngress:]";
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_FAULT,  "%s called with null networkPath",  buf,  0xCu);
                  }
                }
              }

              uint64_t v82 = v144;
            }
          }

          id v83 = (char *)v83 + 1;
        }

        while (v83 != v145);
        id v124 = [v81 countByEnumeratingWithState:&v154 objects:v177 count:16];
        id v145 = v124;
      }

      while (v124);
    }

    __int128 v152 = 0u;
    __int128 v153 = 0u;
    __int128 v150 = 0u;
    __int128 v151 = 0u;
    id v125 = *(id *)(a1 + 320);
    id v126 = [v125 countByEnumeratingWithState:&v150 objects:v176 count:16];
    if (v126)
    {
      id v127 = v126;
      uint64_t v128 = *(void *)v151;
      do
      {
        for (j = 0LL; j != v127; j = (char *)j + 1)
        {
          if (*(void *)v151 != v128) {
            objc_enumerationMutation(v125);
          }
          id v130 = *(void **)(*((void *)&v150 + 1) + 8LL * (void)j);
        }

        id v127 = [v125 countByEnumeratingWithState:&v150 objects:v176 count:16];
      }

      while (v127);
    }

    __int128 v148 = 0u;
    __int128 v149 = 0u;
    __int128 v146 = 0u;
    __int128 v147 = 0u;
    id v131 = *(id *)(a1 + 344);
    id v132 = [v131 countByEnumeratingWithState:&v146 objects:v175 count:16];
    if (v132)
    {
      id v133 = v132;
      uint64_t v134 = *(void *)v147;
      do
      {
        for (k = 0LL; k != v133; k = (char *)k + 1)
        {
          if (*(void *)v147 != v134) {
            objc_enumerationMutation(v131);
          }
          __int128 v136 = *(void **)(*((void *)&v146 + 1) + 8LL * (void)k);
        }

        id v133 = [v131 countByEnumeratingWithState:&v146 objects:v175 count:16];
      }

      while (v133);
    }

    sub_100029DC4((id *)a1);
    [(id)a1 updateUserEventAgentData];
    sub_10002AB04(a1);
  }

void sub_1000328D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    uint64_t v9 = @"failed";
    if (v3) {
      uint64_t v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_1000329B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    uint64_t v9 = @"failed";
    if (v3) {
      uint64_t v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Token fetch for Quic[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_100032A98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    uint64_t v9 = @"failed";
    if (v3) {
      uint64_t v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Fallback[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_100032B7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) vendor]);
    id v8 = (void *)v7;
    uint64_t v9 = @"failed";
    if (v3) {
      uint64_t v9 = @"succeeded";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Token fetch for Fallback[%@] %@",  (uint8_t *)&v10,  0x16u);
  }
}

void sub_100032C60(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 200);
    if (v2)
    {
    }

    else if (!*(_BYTE *)(a1 + 17))
    {
      uint64_t v5 = nplog_obj(0LL, v3, v4);
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "set token replenish timer", (uint8_t *)buf, 2u);
      }

      uint64_t v8 = NPGetInternalQueue(v7);
      uint64_t v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v8);
      dispatch_source_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v9);
      uint64_t v11 = *(void **)(a1 + 200);
      *(void *)(a1 + 200) = v10;

      __int16 v12 = *(void **)(a1 + 200);
      if (v12)
      {
        uint64_t v13 = v12;
        dispatch_time_t v14 = dispatch_time(0LL, 60000000000LL);
        dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0LL);

        objc_initWeak(buf, (id)a1);
        uint64_t v15 = *(void **)(a1 + 200);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_100032DEC;
        handler[3] = &unk_1000F97C0;
        BOOL v16 = v15;
        objc_copyWeak(&v18, buf);
        dispatch_source_set_event_handler(v16, handler);

        dispatch_resume(*(dispatch_object_t *)(a1 + 200));
        objc_destroyWeak(&v18);
        objc_destroyWeak(buf);
      }
    }
  }

void sub_100032DEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v59) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Replenish timer fired", (uint8_t *)&v59, 2u);
  }

  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[25]);
    dispatch_source_t v8 = v7[25];
    v7[25] = 0LL;

    uint64_t v9 = v7[26];
    if (v9
      && (dispatch_source_t v10 = v9,
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v7[26], "ingressProxy")),
          uint64_t v12 = sub_10000E688((uint64_t)v11),
          v11,
          v10,
          !v12))
    {
      id v25 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v7[26], "ingressProxy"));
      uint64_t v39 = nplog_obj(v25, v37, v38);
      char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v39);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_29;
      }
      id v30 = v7[26];
      uint64_t v40 = objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v30, "ingressProxy"));
      id v32 = (void *)v40;
      if (v40) {
        uint64_t v41 = *(void **)(v40 + 24);
      }
      else {
        uint64_t v41 = 0LL;
      }
      id v34 = v41;
      id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 proxyURL]);
      int v59 = 138412290;
      id v60 = v35;
      uint64_t v36 = "Ingress quic proxy %@ has 0 tokens";
    }

    else
    {
      uint64_t v13 = v7[27];
      if (v13
        && (dispatch_time_t v14 = v13,
            uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v7[27], "ingressProxy")),
            uint64_t v16 = sub_10000E688((uint64_t)v15),
            v15,
            v14,
            !v16))
      {
        id v25 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v7[27], "ingressProxy"));
        uint64_t v44 = nplog_obj(v25, v42, v43);
        char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_29;
        }
        id v30 = v7[27];
        uint64_t v45 = objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v30, "ingressProxy"));
        id v32 = (void *)v45;
        if (v45) {
          id v46 = *(void **)(v45 + 24);
        }
        else {
          id v46 = 0LL;
        }
        id v34 = v46;
        id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 proxyURL]);
        int v59 = 138412290;
        id v60 = v35;
        uint64_t v36 = "Ingress fallback proxy %@ has 0 tokens";
      }

      else
      {
        char v17 = v7[26];
        if (v17
          && (id v18 = v17,
              id v19 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s egressProxy](v7[26], "egressProxy")),
              uint64_t v20 = sub_10000E688((uint64_t)v19),
              v19,
              v18,
              !v20))
        {
          id v25 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s egressProxy](v7[26], "egressProxy"));
          uint64_t v49 = nplog_obj(v25, v47, v48);
          char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v49);
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_29;
          }
          id v30 = v7[26];
          uint64_t v50 = objc_claimAutoreleasedReturnValue(-[dispatch_source_s ingressProxy](v30, "ingressProxy"));
          id v32 = (void *)v50;
          if (v50) {
            uint64_t v51 = *(void **)(v50 + 24);
          }
          else {
            uint64_t v51 = 0LL;
          }
          id v34 = v51;
          id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 proxyURL]);
          int v59 = 138412290;
          id v60 = v35;
          uint64_t v36 = "Egress quic proxy %@ has 0 tokens";
        }

        else
        {
          uint64_t v21 = v7[27];
          if (!v21) {
            goto LABEL_33;
          }
          id v22 = v21;
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s egressProxy](v7[27], "egressProxy"));
          uint64_t v24 = sub_10000E688((uint64_t)v23);

          if (v24) {
            goto LABEL_33;
          }
          id v25 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_s egressProxy](v7[27], "egressProxy"));
          uint64_t v28 = nplog_obj(v25, v26, v27);
          char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_29;
          }
          id v30 = v7[27];
          uint64_t v31 = objc_claimAutoreleasedReturnValue(-[dispatch_source_s egressProxy](v30, "egressProxy"));
          id v32 = (void *)v31;
          if (v31) {
            uint64_t v33 = *(void **)(v31 + 24);
          }
          else {
            uint64_t v33 = 0LL;
          }
          id v34 = v33;
          id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 proxyURL]);
          int v59 = 138412290;
          id v60 = v35;
          uint64_t v36 = "Egress fallback proxy %@ has 0 tokens";
        }
      }
    }

    _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, v36, (uint8_t *)&v59, 0xCu);

LABEL_29:
    if (v25)
    {
      uint64_t v52 = v25;
      if (!*((_BYTE *)v7 + 17))
      {
        unsigned __int8 v53 = objc_alloc_init(&OBJC_CLASS___NSPOutageReasonStats);
        dispatch_source_t v54 = v7[64];
        v7[64] = (dispatch_source_t)v53;

        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[dispatch_source_t tierString](v7, "tierString"));
        -[dispatch_source_s setTierType:](v7[64], "setTierType:", v55);

        -[dispatch_source_s setOutageReasonType:](v7[64], "setOutageReasonType:", @"Token");
        -[dispatch_source_s setOutageReasonSubType:](v7[64], "setOutageReasonSubType:", @"TokenFetchFailure");
        id v56 = v52[3];
        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v56 proxyURL]);
        -[dispatch_source_s setTokenProxy:](v7[64], "setTokenProxy:", v57);
      }

      *((_BYTE *)v7 + 17) = 1;
      id v58 = objc_loadWeakRetained((id *)v7 + 10);
      [v58 tokenFetchOutage];

      -[dispatch_source_t updateUserEventAgentData](v7, "updateUserEventAgentData");
    }
  }

LABEL_33:
}

LABEL_34:
  return v24;
}

LABEL_44:
      sub_100032C60((uint64_t)self);
      goto LABEL_45;
    }

    if (self) {
      uint64_t v21 = self->_quicProxyPath;
    }
    else {
      uint64_t v21 = 0LL;
    }
    id v22 = v21;
    uint64_t v23 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](v22, "ingressProxy"));
    uint64_t v24 = (void *)v23;
    if (v23) {
      id v25 = *(void **)(v23 + 24);
    }
    else {
      id v25 = 0LL;
    }
    uint64_t v26 = v25;
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 proxyURL]);
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v64[3] proxyURL]);
    char v29 = sub_1000292DC((id *)&self->super.isa, v27, v28);
    id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);

    if (!v30)
    {
      sub_100032C60((uint64_t)self);
      -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");

      return;
    }

    id v34 = nplog_obj(v31, v32, v33);
    id v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      uint64_t v36 = v64[3];
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v36 vendor]);
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v66 = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_INFO,  "Selected %@ egress proxy to switch QUIC proxy path",  buf,  0xCu);
    }

    sub_1000261CC((uint64_t)self, v30);
    if (self) {
      goto LABEL_11;
    }
  }

  uint64_t v12 = 0LL;
LABEL_12:
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v12, "egressProxy"));
  dispatch_time_t v14 = sub_10000E688((uint64_t)v13);

  if (v14)
  {
    if (self)
    {
LABEL_14:
      replenishTokenTimer = self->_replenishTokenTimer;
      if (replenishTokenTimer)
      {
        dispatch_source_cancel((dispatch_source_t)replenishTokenTimer);
        uint64_t v16 = self->_replenishTokenTimer;
        self->_replenishTokenTimer = 0LL;
      }

      id WeakRetained = objc_loadWeakRetained((id *)&self->_delegate);
      [WeakRetained tokenFetchActive];

      self->_reportedTokenOutage = 0;
      goto LABEL_45;
    }

    goto LABEL_38;
  }

  uint64_t v38 = sub_100029C28((uint64_t)self, 1);
  uint64_t v39 = objc_claimAutoreleasedReturnValue(v38);
  if (!v39)
  {
    id v63 = nplog_obj(0LL, v40, v41);
    uint64_t v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      id v62 = "No egress proxy with available tokens for fallback proxy path";
      goto LABEL_43;
    }

    goto LABEL_44;
  }

  uint64_t v42 = (id *)v39;
  if (self) {
    uint64_t v43 = self->_fallbackProxyPath;
  }
  else {
    uint64_t v43 = 0LL;
  }
  uint64_t v44 = v43;
  uint64_t v45 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath ingressProxy](v44, "ingressProxy"));
  id v46 = (void *)v45;
  if (v45) {
    uint64_t v47 = *(void **)(v45 + 24);
  }
  else {
    uint64_t v47 = 0LL;
  }
  uint64_t v48 = v47;
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v48 proxyURL]);
  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v42[3] proxyURL]);
  uint64_t v51 = sub_100029598((id *)&self->super.isa, v49, v50);
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v51);

  if (!v52)
  {
    sub_100032C60((uint64_t)self);
    -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");

    return;
  }

  id v56 = nplog_obj(v53, v54, v55);
  uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
  {
    id v58 = v42[3];
    int v59 = (void *)objc_claimAutoreleasedReturnValue([v58 vendor]);
    *(_DWORD *)__int128 buf = 138412290;
    __int128 v66 = v59;
    _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_INFO,  "Selected %@ egress proxy to switch Fallback proxy path",  buf,  0xCu);
  }

  sub_100026D14((id *)&self->super.isa, v52);
  if (self) {
    goto LABEL_14;
  }
LABEL_38:
  [0 tokenFetchActive];
LABEL_45:
  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
}

            goto LABEL_45;
          }

          uint64_t v39 = *(id *)(a1 + 72);
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
          [v39 reportDisabledOnCellularName:v40];

          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
          id v18 = v41;
          uint64_t v42 = 1LL;
LABEL_38:
          [v41 cellularDisabled:v42];
          goto LABEL_39;
        }

        uint64_t v50 = *(id *)(a1 + 72);
        uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
        [v50 reportActiveOnCellularName:v51];
      }

      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      id v18 = v41;
      uint64_t v42 = 0LL;
      goto LABEL_38;
    }

    uint64_t v20 = xpc_dictionary_get_remote_connection(v4);
    uint64_t v21 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v20);
    id v22 = v21;
    if (v21
      && (pid = xpc_connection_get_pid(v21),
          id v60 = 0u,
          memset(v61, 0, sizeof(v61)),
          proc_pidinfo(pid, 13, 1uLL, &v60, 64) == 64))
    {
      uint64_t v24 = (char *)malloc(0x10uLL);
      strncpy(v24, (const char *)v61, 0x10uLL);
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    uint64_t v28 = nplog_obj(v25, v26, v27);
    char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v49 = "";
      if (v24) {
        uint64_t v49 = v24;
      }
      LODWORD(v60) = 136315138;
      *(void *)((char *)&v60 + 4) = v49;
      _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "reporting network status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v60,  0xCu);
    }

    if (v24) {
      free(v24);
    }
    sub_10006FFB4(v4, 1001LL, @"Permission denied");
  }

  uint64_t v42 = sub_1000670A8(v34);
  if ((_DWORD)v42)
  {
    uint64_t v45 = *(void *)(a1 + 32);
    if (v45)
    {
      if (*(_BYTE *)(v45 + 19))
      {
        id v46 = nplog_obj(v42, v43, v44);
        uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v48 = *(void **)(a1 + 32);
          id v56 = 138412290;
          uint64_t v57 = v48;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "%@ Primary interface changed to non Wi-Fi, reporting service active ...",  (uint8_t *)&v56,  0xCu);
        }

        sub_10006714C(*(void *)(a1 + 32), 0LL, v49);
      }

      else if (*(_BYTE *)(v45 + 20))
      {
        uint64_t v50 = nplog_obj(v42, v43, v44);
        uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v52 = *(void **)(a1 + 32);
          id v56 = 138412290;
          uint64_t v57 = v52;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "%@ Primary interface changed to non Wi-Fi, removing pending outage notification",  (uint8_t *)&v56,  0xCu);
        }

        unsigned __int8 v53 = *(void *)(a1 + 32);
        if (v53)
        {
          *(_BYTE *)(v53 + 20) = 0;
          sub_1000679B4(v53);
          sub_100073418(v53);
        }
      }
    }
  }

  sub_1000665D4(*(void *)(a1 + 32));
  sub_100067224(*(void *)(a1 + 32));
  dispatch_source_t v54 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v55 = *(void **)(v54 + 40);
  *(void *)(v54 + 40) = 0LL;
}

  -[NSPConfigurationStats setSafariPrivateDNSEnabled:](v15, "setSafariPrivateDNSEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x100000) == 0)
  {
LABEL_19:
    if ((v12 & 0x200000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_46;
  }

void sub_1000337F8(void *a1, void *a2, uint64_t a3)
{
  dispatch_source_t v8 = a2;
  if (a1)
  {
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSPSwitchEgressProxyStats);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([a1 tierString]);
    -[NSPSwitchEgressProxyStats setTierType:](v5, "setTierType:", v6);

    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v8[3] vendor]);
    -[NSPSwitchEgressProxyStats setVendor:](v5, "setVendor:", v7);

    -[NSPSwitchEgressProxyStats setPrimaryProxy:](v5, "setPrimaryProxy:", a3 ^ 1);
    -[NSPSwitchEgressProxyStats setFallbackProxy:](v5, "setFallbackProxy:", a3);
    -[NSPProxyAnalytics sendAnalytics](v5, "sendAnalytics");
  }
}

void sub_100033D7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_100033DA4(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v9 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = objc_loadWeakRetained(WeakRetained + 10);
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 24);
    }
    else {
      uint64_t v6 = 0LL;
    }
    [v3 badTokenInfoForProxy:v6];
  }

  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  dispatch_source_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0LL;
}

void sub_10003408C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_1000340B4(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v2 = objc_loadWeakRetained(WeakRetained + 10);
    [v2 tokenIssuanceLimitReached];
  }

  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

id sub_1000342D8(void *a1)
{
  id v1 = a1;
  id v2 = (void *)objc_claimAutoreleasedReturnValue([v1 host]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithString:](&OBJC_CLASS___NSMutableString, "stringWithString:", v2));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v1 port]);

  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v1 port]);
    [v3 appendFormat:@".%@", v5];
  }

  return v3;
}

LABEL_86:
  id v71 = nplog_obj(v16, v17, v18);
  id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
  if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
  {
    id v72 = (void *)objc_claimAutoreleasedReturnValue([v11 outageReasonType]);
    *(_DWORD *)__int128 buf = 138412290;
    id v75 = (uint64_t)v72;
    _os_log_error_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_ERROR,  "failed to create RTC report payload for service outage type %@",  buf,  0xCu);
  }

  uint64_t v12 = 0LL;
LABEL_92:
}

LABEL_12:
    uint64_t v11 = nplog_obj(v4, v5, v6);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "quic proxy path, single hop agent registered",  buf,  2u);
    }

    if (self) {
      self = (NSPPrivacyProxyAgentManager *)objc_loadWeakRetained((id *)&self->_delegate);
    }
    -[NSPPrivacyProxyAgentManager singleHopProxyAgentRegistered:](self, "singleHopProxyAgentRegistered:", 1LL);
    goto LABEL_17;
  }

  if (!v4) {
    goto LABEL_12;
  }
  fallbackProxyPath = 0LL;
LABEL_4:
  if (fallbackProxyPath == (NSPFallbackProxyPath *)v4)
  {
    uint64_t v9 = nplog_obj(v4, v5, v6);
    dispatch_source_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "fallback proxy path, single hop agent registered",  v13,  2u);
    }

    if (self) {
      self = (NSPPrivacyProxyAgentManager *)objc_loadWeakRetained((id *)&self->_delegate);
    }
    -[NSPPrivacyProxyAgentManager singleHopFallbackProxyAgentRegistered:]( self,  "singleHopFallbackProxyAgentRegistered:",  1LL);
LABEL_17:
  }
}

    uint64_t v11 = nplog_obj(v4, v5, v6);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "quic proxy path, single hop agent unregistered",  buf,  2u);
    }

    if (self) {
      self = (NSPPrivacyProxyAgentManager *)objc_loadWeakRetained((id *)&self->_delegate);
    }
    -[NSPPrivacyProxyAgentManager singleHopProxyAgentRegistered:](self, "singleHopProxyAgentRegistered:", 0LL);
    goto LABEL_17;
  }

  if (!v4) {
    goto LABEL_12;
  }
  fallbackProxyPath = 0LL;
LABEL_4:
  if (fallbackProxyPath == (NSPFallbackProxyPath *)v4)
  {
    uint64_t v9 = nplog_obj(v4, v5, v6);
    dispatch_source_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "fallback proxy path, single hop agent unregistered",  v13,  2u);
    }

    if (self) {
      self = (NSPPrivacyProxyAgentManager *)objc_loadWeakRetained((id *)&self->_delegate);
    }
    -[NSPPrivacyProxyAgentManager singleHopFallbackProxyAgentRegistered:]( self,  "singleHopFallbackProxyAgentRegistered:",  0LL);
LABEL_17:
  }
}

  id WeakRetained = objc_loadWeakRetained((id *)&self->_delegate);
LABEL_13:
  [WeakRetained reportPrivacyProxySuccessOnInterface:v12];

  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
}

      goto LABEL_13;
    }

    if (self->_systemIncompatible)
    {
      uint64_t v16 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        id v18 = "defer policy installation until system compatible";
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, v18, buf, 2u);
        goto LABEL_12;
      }

      goto LABEL_12;
    }

    if (self->_fraudAlert)
    {
      uint64_t v47 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installation, token limit reached";
      goto LABEL_11;
    }

    if (self->_configOutage)
    {
      uint64_t v48 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installation until config outage is resolved";
      goto LABEL_11;
    }

    if (self->_tokenOutage)
    {
      uint64_t v49 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v49);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installtion until token outage is resolved";
      goto LABEL_11;
    }

    if (self->_proxyOutage)
    {
      uint64_t v51 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installation until proxy outage is resolved";
      goto LABEL_11;
    }

    if (self->_proxyNetworkOutage)
    {
      uint64_t v52 = nplog_obj(v13, v14, v15);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installation until proxy network outage is resolved";
      goto LABEL_11;
    }

    unsigned __int8 v53 = sub_1000678B0((uint64_t)self, v12);
    if ((_DWORD)v53)
    {
      if (self->_odohOutage)
      {
        id v56 = nplog_obj(v53, v54, v55);
        char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
          goto LABEL_12;
        }
        *(_WORD *)__int128 buf = 0;
        id v18 = "defer policy installation until odoh outage is resolved";
        goto LABEL_11;
      }

      if (self->_odohAuthOutage)
      {
        uint64_t v57 = nplog_obj(v53, v54, v55);
        char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
          goto LABEL_12;
        }
        *(_WORD *)__int128 buf = 0;
        id v18 = "defer policy installation until odoh auth outage is resolved";
        goto LABEL_11;
      }
    }

    if (self->_captiveOutage)
    {
      id v58 = nplog_obj(v53, v54, v55);
      char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
        goto LABEL_12;
      }
      *(_WORD *)__int128 buf = 0;
      id v18 = "defer policy installation until captive outage is resolved";
      goto LABEL_11;
    }

    int v59 = self->_privacyProxyAgentManager;
    -[NSPPrivacyProxyAgentManager handleUnlimitedChange:]( v59,  "handleUnlimitedChange:",  sub_10006C368((BOOL)self, v12));

    if (-[NSPPrivacyProxyAgentManager isSingleHopProxyAgentRegistered]( self->_privacyProxyAgentManager,  "isSingleHopProxyAgentRegistered"))
    {
      id v60 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](self->_configuration, "proxyConfiguration"));
      uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v60 bootstrapResolver]);

      id v62 = sub_10004E560((uint64_t)self->_odohManager, v61);
      if ((v62 & 1) == 0)
      {
        __int128 v65 = nplog_obj(v62, v63, v64);
        __int128 v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v120 = self;
          _os_log_error_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_ERROR,  "%@ failed to register bootstrap DNS network agent",  buf,  0xCu);
        }
      }
    }

    id v67 = sub_1000678B0((uint64_t)self, v12);
    if ((v67 & 1) != 0)
    {
      if (v5)
      {
        id v70 = nplog_obj(v67, v68, v69);
        id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          id v72 = self->_configuration;
          id v73 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v72, "proxyConfiguration"));
          id v74 = (NSPServer *)objc_claimAutoreleasedReturnValue([v73 resolvers]);
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v120 = v74;
          _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "privacy proxy resolver info updated %@",  buf,  0xCu);
        }

        id v75 = -[NSPPrivacyProxyAgentManager isSingleHopProxyAgentRegistered]( self->_privacyProxyAgentManager,  "isSingleHopProxyAgentRegistered");
        if (!v75)
        {
          id v114 = nplog_obj(v75, v76, v77);
          uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v114);
          if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
            goto LABEL_122;
          }
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v120 = self;
          unsigned __int8 v87 = "%@ single hop proxy agent is not active, unable to set DNS policies";
          goto LABEL_116;
        }

        odohManager = self->_odohManager;
        __int128 v79 = self->_configuration;
        __int128 v80 = odohManager;
        id v81 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v79, "proxyConfiguration"));
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 resolvers]);
        sub_10004E120((uint64_t)v80, v82);
      }

      id v83 = sub_10004F17C((uint64_t)self->_odohManager);
      if ((v83 & 1) == 0)
      {
        id v86 = nplog_obj(v83, v84, v85);
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v86);
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_122;
        }
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v120 = self;
        unsigned __int8 v87 = "%@ failed to register DNS network agent";
LABEL_116:
        _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, v87, buf, 0xCu);
        goto LABEL_122;
      }
    }

    else
    {
      sub_10004E25C((uint64_t)self->_odohManager);
      sub_100069734((uint64_t)self);
    }

    uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration inProcessFlowDivert](self->_configuration, "inProcessFlowDivert"));

    if (v88)
    {
      id v90 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration inProcessFlowDivert](self->_configuration, "inProcessFlowDivert"));
      id v91 = [v90 BOOLValue];
    }

    else
    {
      id v91 = 1;
    }

    uint64_t v26 = (NSPOutageReasonStats *)objc_getProperty(self, v89, 48LL, 1);
    id v92 = (void *)objc_claimAutoreleasedReturnValue(-[NSPServiceStatusManager pausedBundleIDs](self->_serviceStatusManager, "pausedBundleIDs"));
    id v117 = v91;
    id v116 = v92;
    if (v92)
    {
      if (v26)
      {
        uint64_t v93 = objc_claimAutoreleasedReturnValue(-[NSPOutageReasonStats arrayByAddingObjectsFromArray:](v26, "arrayByAddingObjectsFromArray:", v92));

        uint64_t v26 = (NSPOutageReasonStats *)v93;
      }

      else
      {
        uint64_t v26 = v92;
      }
    }

    char v118 = (void *)objc_claimAutoreleasedReturnValue(-[NSPServiceStatusManager pausedProcessPaths](self->_serviceStatusManager, "pausedProcessPaths"));
    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
    id Property = objc_getProperty(self, v95, 264LL, 1);
    if (Property) {
      id v97 = (void *)Property[2];
    }
    else {
      id v97 = 0LL;
    }
    uint64_t v98 = v97;
    uint64_t v99 = self->_privacyProxyAgentManager;
    uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager ingressProxyURL](v99, "ingressProxyURL"));
    uint64_t v101 = self->_privacyProxyAgentManager;
    uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivacyProxyAgentManager ingressFallbackProxyURL](v101, "ingressFallbackProxyURL"));
    uint64_t v103 = [v94 set:v12 flowDivertHandle:v98 inProcessFlowDivert:v117 ingressProxyURL:v100 ingressFallbackProxyURL:v102 exception BundleIDs:v26 exceptionProcessPaths:v118];

    if ((v103 & 1) != 0)
    {
      uint64_t v107 = -[NSPConfigurationManager configurationSubscriberPoliciesCount]( self->_configurationManager,  "configurationSubscriberPoliciesCount");
      BOOL v108 = self->_serviceStatusManager;
      char v109 = v108;
      if (v107)
      {
        -[NSPServiceStatusManager reportServiceActiveShouldReport:]( v108,  "reportServiceActiveShouldReport:",  self->_userTierChangedFromNonSettingsApp);
      }

      else
      {
        id v111 = self->_configuration;
        id v112 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v111, "proxyConfiguration"));
        id v113 = (void *)objc_claimAutoreleasedReturnValue([v112 regionId]);
        -[NSPServiceStatusManager reportSubscriberUnsupportedRegion:](v109, "reportSubscriberUnsupportedRegion:", v113);
      }
    }

    else
    {
      id v110 = nplog_obj(v104, v105, v106);
      char v109 = (NSPServiceStatusManager *)objc_claimAutoreleasedReturnValue(v110);
      if (os_log_type_enabled((os_log_t)v109, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v120 = self;
        _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v109,  OS_LOG_TYPE_ERROR,  "%@ failed to set privacy proxy policies",  buf,  0xCu);
      }
    }

    goto LABEL_113;
  }

    uint64_t v33 = 0LL;
    goto LABEL_22;
  }

  if (!v14)
  {
    uint64_t v42 = nplog_obj(v16, v17, v18);
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "+[NSPCoreData getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:]";
      uint64_t v41 = "%s called with null endDate";
      goto LABEL_27;
    }

    goto LABEL_12;
  }

  id v22 = -[NSCalendar initWithCalendarIdentifier:]( objc_alloc(&OBJC_CLASS___NSCalendar),  "initWithCalendarIdentifier:",  NSCalendarIdentifierGregorian);
  if (v22)
  {
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NSTimeZone timeZoneWithAbbreviation:]( &OBJC_CLASS___NSTimeZone,  "timeZoneWithAbbreviation:",  @"UTC"));
    -[os_log_s setTimeZone:](v22, "setTimeZone:", v23);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( -[os_log_s components:fromDate:toDate:options:]( v22,  "components:fromDate:toDate:options:",  16LL,  v13,  v14,  0LL));
    uint64_t v27 = v24;
    if (v24)
    {
      id v60 = 0LL;
      uint64_t v61 = &v60;
      id v62 = 0x2020000000LL;
      uint64_t v28 = [v24 day];
      id v63 = v28;
      if ((unint64_t)v61[3] < 0x1F)
      {
        [v27 setDay:1];
        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000LL;
        __int128 v65 = sub_100077D9C;
        __int128 v66 = sub_100077DAC;
        id v67 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
        v49[0] = _NSConcreteStackBlock;
        v49[1] = 3221225472LL;
        v49[2] = sub_100078BC0;
        v49[3] = &unk_1000FA650;
        uint64_t v50 = v13;
        uint64_t v57 = &v60;
        uint64_t v51 = v22;
        uint64_t v52 = v27;
        unsigned __int8 v53 = v47;
        dispatch_source_t v54 = v15;
        uint64_t v55 = v46;
        int v59 = a4;
        id v56 = v19;
        id v58 = buf;
        [v56 performBlockAndWait:v49];
        if ([*(id *)(*(void *)&buf[8] + 40) count])
        {
          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSPCoreData computeStats:]( &OBJC_CLASS___NSPCoreData,  "computeStats:",  *(void *)(*(void *)&buf[8] + 40LL)));
        }

        else
        {
          uint64_t v37 = nplog_obj(0LL, v35, v36);
          uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v48 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "No records found", v48, 2u);
          }

          uint64_t v33 = 0LL;
        }

        _Block_object_dispose(buf, 8);
      }

      else
      {
        uint64_t v31 = nplog_obj(v28, v29, v30);
        id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v14;
          _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "Invalid dates. startDate:%@ endDate:%@",  buf,  0x16u);
        }

        uint64_t v33 = 0LL;
      }

      _Block_object_dispose(&v60, 8);
    }

    else
    {
      uint64_t v44 = nplog_obj(0LL, v25, v26);
      uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "+[NSPCoreData getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_FAULT,  "%s called with null dayComponents",  buf,  0xCu);
      }

      uint64_t v33 = 0LL;
    }
  }

  else
  {
    uint64_t v43 = nplog_obj(0LL, v20, v21);
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "+[NSPCoreData getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%s called with null calendar", buf, 0xCu);
    }

    uint64_t v33 = 0LL;
  }

LABEL_22:
  return v33;
}

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 hostnames]);
      dispatch_time_t v14 = [v13 count];
      uint64_t v15 = v10;
      uint64_t v16 = v118;
      id v133 = v15;
      if (!v14)
      {
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 urls]);
        if (![v16 count])
        {

          goto LABEL_70;
        }

        uint64_t v15 = v133;
      }

      char v17 = (void *)objc_claimAutoreleasedReturnValue([v15 processes]);
      id v18 = [v17 count];

      if (!v14) {
      if (!v18)
      }
      {
        char v118 = v16;
        __int128 v164 = 0u;
        id v165 = 0u;
        unsigned int v162 = 0u;
        id v163 = 0u;
        unsigned int v138 = (id)objc_claimAutoreleasedReturnValue([v133 hostnames]);
        id v19 = [v138 countByEnumeratingWithState:&v162 objects:v183 count:16];
        if (v19)
        {
          uint64_t v20 = v19;
          uint64_t v21 = *(void *)v163;
          do
          {
            for (k = 0LL; k != v20; k = (char *)k + 1)
            {
              if (*(void *)v163 != v21) {
                objc_enumerationMutation(v138);
              }
              uint64_t v23 = *(void **)(*((void *)&v162 + 1) + 8LL * (void)k);
              uint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
              id v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
              -[NSMutableArray addObject:](v24, "addObject:", v25);

              uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v23));
              -[NSMutableArray addObject:](v24, "addObject:", v26);
              if (([v133 isPrivacyProxy] & 1) == 0)
              {
                uint64_t v27 = +[NEPolicyCondition realUID:](&OBJC_CLASS___NEPolicyCondition, "realUID:", getuid());
                uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
                -[NSMutableArray addObject:](v24, "addObject:", v28);
              }

              if ([v133 systemProcessOnly])
              {
                char v29 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
                -[NSMutableArray addObject:](v24, "addObject:", v29);
              }

              id v30 = sub_1000846E8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v141, 0LL, 0LL, v23, v133);
              if ((_DWORD)v30)
              {
                uint64_t v31 = v30;
                id v32 = [[NEPolicy alloc] initWithOrder:v30 result:v136 conditions:v24];
                -[NSMutableArray addObject:](v137, "addObject:", v32);

                uint64_t v33 = [[NEPolicy alloc] initWithOrder:(v31 + 1) result:v135 conditions:v24];
                -[NSMutableArray addObject:](v137, "addObject:", v33);
              }
            }

            uint64_t v20 = [v138 countByEnumeratingWithState:&v162 objects:v183 count:16];
          }

          while (v20);
        }

        __int128 v160 = 0u;
        __int128 v161 = 0u;
        __int128 v158 = 0u;
        __int128 v159 = 0u;
        uint64_t v123 = (id)objc_claimAutoreleasedReturnValue([v133 urls]);
        id v34 = [v123 countByEnumeratingWithState:&v158 objects:v182 count:16];
        if (v34)
        {
          id v35 = v34;
          uint64_t v36 = *(void *)v159;
          do
          {
            for (m = 0LL; m != v35; m = (char *)m + 1)
            {
              if (*(void *)v159 != v36) {
                objc_enumerationMutation(v123);
              }
              uint64_t v38 = *(void **)(*((void *)&v158 + 1) + 8LL * (void)m);
              uint64_t v39 = sub_1000846E8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v141, 0LL, v38, 0LL, v133);
              if ((_DWORD)v39)
              {
                uint64_t v40 = v39;
                uint64_t v41 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                -[NSMutableArray addObject:](v41, "addObject:", v42);

                uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition url:](&OBJC_CLASS___NEPolicyCondition, "url:", v38));
                -[NSMutableArray addObject:](v41, "addObject:", v43);

                if (([v133 isPrivacyProxy] & 1) == 0)
                {
                  uint64_t v44 = +[NEPolicyCondition realUID:](&OBJC_CLASS___NEPolicyCondition, "realUID:", getuid());
                  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
                  -[NSMutableArray addObject:](v41, "addObject:", v45);
                }

                if ([v133 systemProcessOnly])
                {
                  id v46 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
                  -[NSMutableArray addObject:](v41, "addObject:", v46);
                }

                uint64_t v47 = [[NEPolicy alloc] initWithOrder:v40 result:v136 conditions:v41];
                -[NSMutableArray addObject:](v137, "addObject:", v47);

                uint64_t v48 = [[NEPolicy alloc] initWithOrder:(v40 + 1) result:v135 conditions:v41];
                -[NSMutableArray addObject:](v137, "addObject:", v48);
              }
            }

            id v35 = [v123 countByEnumeratingWithState:&v158 objects:v182 count:16];
          }

          while (v35);
        }

        goto LABEL_119;
      }
}

void sub_100036CC8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a1 && !*(_BYTE *)(a1 + 16))
  {
    v10[0] = 0LL;
    v10[1] = v10;
    _DWORD v10[2] = 0x3032000000LL;
    v10[3] = sub_10000CED4;
    void v10[4] = sub_10000CEE4;
    id v11 = (id)os_transaction_create("com.apple.networkserviceproxy.proxyConnectivityCheck");
    objc_initWeak(&location, (id)a1);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_100036E18;
    v7[3] = &unk_1000F9B68;
    objc_copyWeak(&v8, &location);
    void v7[4] = v10;
    [WeakRetained checkPrivacyProxyConnectivityOnInterface:v5 proxyConnectivityCheckType:a3 completionHandler:v7];

    *(_BYTE *)(a1 + 16) = 1;
    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
    _Block_object_dispose(v10, 8);
  }
}

void sub_100036DF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_100036E18(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    WeakRetained[16] = 0;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
  id v5 = WeakRetained;
}

void sub_100036E68(id *a1, void *a2)
{
  id v5 = a2;
  if (v5)
  {
    uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSPOutageReasonStats);
    id v7 = a1[63];
    a1[63] = v6;

    id v8 = (void *)objc_claimAutoreleasedReturnValue([a1 tierString]);
    [a1[63] setTierType:v8];

    [a1[63] setOutageReasonType:@"Proxy"];
    [a1[63] setOutageReasonSubType:v5];
    id v9 = a1[26];
    uint64_t v10 = objc_claimAutoreleasedReturnValue([v9 ingressProxy]);
    id v11 = (void *)v10;
    if (v10) {
      uint64_t v12 = *(void **)(v10 + 24);
    }
    else {
      uint64_t v12 = 0LL;
    }
    id v13 = v12;
    dispatch_time_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 proxyURL]);
    [a1[63] setPrimaryIngressProxy:v14];

    id v15 = a1[26];
    uint64_t v16 = objc_claimAutoreleasedReturnValue([v15 egressProxy]);
    char v17 = (void *)v16;
    if (v16) {
      id v18 = *(void **)(v16 + 24);
    }
    else {
      id v18 = 0LL;
    }
    id v19 = v18;
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 proxyURL]);
    [a1[63] setPrimaryEgressProxy:v20];

    id v21 = a1[27];
    uint64_t v22 = objc_claimAutoreleasedReturnValue([v21 ingressProxy]);
    uint64_t v23 = (void *)v22;
    if (v22) {
      uint64_t v24 = *(void **)(v22 + 24);
    }
    else {
      uint64_t v24 = 0LL;
    }
    id v25 = v24;
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 tcpProxyFqdn]);
    [a1[63] setFallbackIngressProxy:v26];

    id v27 = a1[27];
    uint64_t v28 = objc_claimAutoreleasedReturnValue([v27 egressProxy]);
    char v29 = (void *)v28;
    if (v28) {
      id v30 = *(void **)(v28 + 24);
    }
    else {
      id v30 = 0LL;
    }
    id v31 = v30;
    id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 tcpProxyFqdn]);
    [a1[63] setFallbackEgressProxy:v32];
  }

  else
  {
    uint64_t v33 = nplog_obj(0LL, v3, v4);
    id v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      int v35 = 136315138;
      uint64_t v36 = "-[NSPPrivacyProxyAgentManager setProxyOutageReason:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_FAULT,  "%s called with null outageReasonSubType",  (uint8_t *)&v35,  0xCu);
    }
  }
}

void sub_1000370F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 520))
  {
    *(void *)(a1 + 520) = a2;
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    objc_storeStrong((id *)(a1 + 272), v11);

    uint64_t v15 = nplog_obj(v12, v13, v14);
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(void *)(a1 + 520);
      id v18 = @"Unknown";
      if (v17 == 2) {
        id v18 = @"DNS";
      }
      if (v17 == 1) {
        id v19 = @"Proxy";
      }
      else {
        id v19 = (__CFString *)v18;
      }
      uint64_t v20 = v19;
      int v40 = 138412290;
      uint64_t v41 = v20;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Start probing[%@]", (uint8_t *)&v40, 0xCu);
    }

    if (a2 != 2)
    {
      if (a2 != 1)
      {
        uint64_t v38 = nplog_obj(v21, v22, v23);
        id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          uint64_t v39 = *(__CFString **)(a1 + 520);
          int v40 = 134217984;
          uint64_t v41 = v39;
          _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Bad probing reason %ld",  (uint8_t *)&v40,  0xCu);
        }

        goto LABEL_22;
      }

      uint64_t v24 = objc_alloc(&OBJC_CLASS___NSPProber);
      int v25 = *(_DWORD *)(a1 + 20);
      id v26 = *(id *)(a1 + 368);
      id v27 = sub_10001FA18((id *)&v24->super.isa, (void *)a1, @"Proxy", v25, v26, 1);
      objc_storeStrong((id *)(a1 + 240), v27);

      sub_10001FAE0(*(void *)(a1 + 240));
      sub_100021004(*(void *)(a1 + 240), v28, v29, v30);
    }

    id v31 = objc_alloc(&OBJC_CLASS___NSPProber);
    int v32 = *(_DWORD *)(a1 + 20);
    id v33 = *(id *)(a1 + 368);
    id v34 = sub_10001FA18((id *)&v31->super.isa, (void *)a1, @"Direct", v32, v33, 0);
    objc_storeStrong((id *)(a1 + 248), v34);

    sub_10001FAE0(*(void *)(a1 + 248));
    sub_100021004(*(void *)(a1 + 248), v35, v36, v37);
    return;
  }

  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 520);
    id v7 = @"Unknown";
    if (v6 == 2) {
      id v7 = @"DNS";
    }
    if (v6 == 1) {
      id v8 = @"Proxy";
    }
    else {
      id v8 = (__CFString *)v7;
    }
    id v9 = v8;
    int v40 = 138412290;
    uint64_t v41 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Already probing for %@", (uint8_t *)&v40, 0xCu);
  }

LABEL_58:
  }
}

  uint64_t v78 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.CommCenter.BrandedCalling",  1,  0);
  __int128 v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
  if (v79) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v79);
  }

  if ((v21 & 0x400000) == 0)
  {
LABEL_33:
    if ((v21 & 0x800000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_64;
  }

  -[NSPConfigurationStats setBrandedCallingEnabled:](v15, "setBrandedCallingEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x20000) == 0)
  {
LABEL_33:
    if ((v12 & 0x400000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_60;
  }

        (*((void (**)(id, void, void, void, uint64_t, void))v23 + 2))(v23, 0LL, 0LL, 0LL, 1004LL, 0LL);
        goto LABEL_52;
      }

      uint64_t v44 = sub_1000A3830((uint64_t)self, v97, v21, v98, a13);
      if ((v44 & 1) != 0)
      {
        uint64_t v47 = sub_1000428D8((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21, v98);
        if ((v47 & 1) != 0) {
          goto LABEL_7;
        }
        uint64_t v50 = nplog_obj(v47, v48, v49);
        uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_INFO,  "Not allowed to fetch private access token, rate limited",  (uint8_t *)&buf,  2u);
        }

        (*((void (**)(id, void, void, void, uint64_t, void))v23 + 2))(v23, 0LL, 0LL, 0LL, 1009LL, 0LL);
      }

      else
      {
        dispatch_source_t v54 = nplog_obj(v44, v45, v46);
        uint64_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v54);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_INFO,  "Not allowed to fetch private access token for origin",  (uint8_t *)&buf,  2u);
        }

        (*((void (**)(id, void, void, void, uint64_t, void))v23 + 2))(v23, 0LL, 0LL, 0LL, 1001LL, 0LL);
      }
    }

    else
    {
      uint64_t v42 = nplog_obj(v26, v27, v28);
      uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "Cannot fetch private access token, no attester URLs",  (uint8_t *)&buf,  2u);
      }

      (*((void (**)(id, void, void, void, uint64_t, void))v23 + 2))(v23, 0LL, 0LL, 0LL, 1005LL, 0LL);
    }
  }

  else
  {
    uint64_t v88 = nplog_obj(v26, v27, v28);
    unsigned int v89 = (os_log_s *)objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyTokenManager fetchPairedPrivateAccessTokensForChallenge:overrideAttest"
                                      "er:tokenKey:originNameKey:selectedOrigin:pairedChallenge:overridePairedAttester:pa"
                                      "iredTokenKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_FAULT,  "%s called with null completionHandler",  (uint8_t *)&buf,  0xCu);
    }

    MEMORY[0x10](0LL, 0LL, 0LL, 0LL);
  }

LABEL_360:
      ++v21[v110];
      goto LABEL_361;
    }

    uint64_t v43 = v12;
    uint64_t v44 = v10;
    if (self)
    {
      if (self->_quicProxyPath == v43)
      {
        __int128 v154 = self->_lastQuicProxySwitchedDate;
        if (!v154
          || (__int128 v155 = v154,
              __int128 v156 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
              [v156 timeIntervalSinceDate:self->_lastQuicProxySwitchedDate],
              __int128 v158 = v157,
              v156,
              v155,
              v158 > 30.0))
        {
          unsigned int v162 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
          if (!v162) {
            goto LABEL_226;
          }
          id v163 = v162[12];

          if (v163 < 6) {
            goto LABEL_226;
          }
          v604 = v23;
          id v167 = nplog_obj(v164, v165, v166);
          id v168 = (os_log_s *)objc_claimAutoreleasedReturnValue(v167);
          if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v168,  OS_LOG_TYPE_INFO,  "Quic proxy multihop path is reporting origin proxy error",  buf,  2u);
          }

          id v169 = self->_quicProxyPath;
          uint64_t v170 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v169, "egressProxy"));
          __int128 v171 = sub_10002883C((id *)&self->super.isa, v170, self->_proxyPathCustomEnumerator);

          if (v171)
          {
            __int128 v172 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self->_quicProxyPath, "egressProxy"));
            -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v172);

            __int128 v173 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
            if (v173) {
              v173[12] = 0LL;
            }

            quicProxyPath = self->_quicProxyPath;
LABEL_133:
            __int128 v174 = (void *)objc_claimAutoreleasedReturnValue([quicProxyPath networkSingleHopAgentStatistics]);
            uint64_t v23 = v604;
            if (!v174)
            {
LABEL_135:

              goto LABEL_226;
            }

LABEL_134:
            v174[12] = 0LL;
            goto LABEL_135;
          }

          probingReason = self->_probingReason;
          uint64_t v23 = v604;
          if (probingReason == 1) {
            goto LABEL_226;
          }
          if (!probingReason)
          {
            sub_100036E68((id *)&self->super.isa, @"ProxyPrimaryOriginError");
            sub_1000370F8((uint64_t)self, 1LL, v264);
            __int128 v265 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
            if (v265) {
              v265[12] = 0LL;
            }

            fallbackProxyPath = self->_quicProxyPath;
LABEL_304:
            __int128 v174 = (void *)objc_claimAutoreleasedReturnValue([fallbackProxyPath networkSingleHopAgentStatistics]);
            if (!v174) {
              goto LABEL_135;
            }
            goto LABEL_134;
          }

          v350 = self->_quicProxyPath;
LABEL_407:
          [v350 resetError];
          goto LABEL_226;
        }

        __int128 v254 = nplog_obj(v159, v160, v161);
        __int128 v255 = (os_log_s *)objc_claimAutoreleasedReturnValue(v254);
        if (os_log_type_enabled(v255, OS_LOG_TYPE_INFO))
        {
          v609 = v23;
          __int128 v256 = self->_lastQuicProxySwitchedDate;
          __int128 v257 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v256,  1LL,  2LL));
          *(_DWORD *)__int128 buf = 138412290;
          v635 = (NWPathStatus)v257;
          __int128 v258 = "ignoring origin quic proxy error, last quic proxy switched date %@";
LABEL_224:
          _os_log_impl((void *)&_mh_execute_header, v255, OS_LOG_TYPE_INFO, v258, buf, 0xCu);

          uint64_t v23 = v609;
        }

LABEL_225:
        goto LABEL_226;
      }

      if ((NSPQuicProxyPath *)self->_fallbackProxyPath == v43)
      {
        uint64_t v45 = self->_lastFallbackProxySwitchedDate;
        if (!v45
          || (id v46 = v45,
              uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
              [v47 timeIntervalSinceDate:self->_lastFallbackProxySwitchedDate],
              uint64_t v49 = v48,
              v47,
              v46,
              v49 > 30.0))
        {
          unsigned __int8 v53 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
          if (!v53) {
            goto LABEL_226;
          }
          dispatch_source_t v54 = v53[12];

          if (v54 < 6) {
            goto LABEL_226;
          }
          v604 = v23;
          id v58 = nplog_obj(v55, v56, v57);
          int v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_INFO,  "Fallback proxy multihop path is reporting origin proxy error",  buf,  2u);
          }

          id v60 = self->_fallbackProxyPath;
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v60, "egressProxy"));
          id v62 = sub_10002883C((id *)&self->super.isa, v61, self->_fallbackProxyPathCustomEnumerator);

          if (v62)
          {
            id v63 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self->_fallbackProxyPath, "egressProxy"));
            -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v63);

            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
            if (v64) {
              v64[12] = 0LL;
            }

            quicProxyPath = self->_fallbackProxyPath;
            goto LABEL_133;
          }

          v334 = self->_probingReason;
          uint64_t v23 = v604;
          if (v334 == 1) {
            goto LABEL_226;
          }
          if (!v334)
          {
            sub_100036E68((id *)&self->super.isa, @"ProxyFallbackOriginError");
            sub_1000370F8((uint64_t)self, 1LL, v335);
            v336 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
            if (v336) {
              v336[12] = 0LL;
            }

            fallbackProxyPath = self->_fallbackProxyPath;
            goto LABEL_304;
          }

          v350 = self->_fallbackProxyPath;
          goto LABEL_407;
        }

        __int128 v262 = nplog_obj(v50, v51, v52);
        __int128 v255 = (os_log_s *)objc_claimAutoreleasedReturnValue(v262);
        if (os_log_type_enabled(v255, OS_LOG_TYPE_INFO))
        {
          v609 = v23;
          __int128 v256 = self->_lastFallbackProxySwitchedDate;
          __int128 v257 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v256,  1LL,  2LL));
          *(_DWORD *)__int128 buf = 138412290;
          v635 = (NWPathStatus)v257;
          __int128 v258 = "ignoring origin fallback proxy error, last fallback proxy switched date %@";
          goto LABEL_224;
        }

        goto LABEL_225;
      }
    }

LABEL_226:
    if (!v21) {
      goto LABEL_361;
    }
    id v110 = 12LL;
    goto LABEL_360;
  }

  if ((int)v8 > 1099)
  {
    if (((1 << (v8 - 76)) & 0x33) != 0)
    {
LABEL_60:
      __int128 v66 = v12;
      id v67 = v10;
      if (self)
      {
        if (self->_quicProxyPath == v66)
        {
          unsigned int v89 = self->_lastQuicProxySwitchedDate;
          if (!v89
            || (id v90 = v89,
                id v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
                [v91 timeIntervalSinceDate:self->_lastQuicProxySwitchedDate],
                uint64_t v93 = v92,
                v91,
                v90,
                v93 > 30.0))
          {
            id v97 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
            if (!v97) {
              goto LABEL_188;
            }
            uint64_t v98 = v97[11];

            if (v98 < 3) {
              goto LABEL_188;
            }
            v605 = v23;
            uint64_t v102 = nplog_obj(v99, v100, v101);
            uint64_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
            if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_INFO,  "Quic proxy multihop path is reporting egress proxy error",  buf,  2u);
            }

            uint32_t v104 = self->_quicProxyPath;
            uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v104, "egressProxy"));
            uint64_t v106 = sub_10002883C((id *)&self->super.isa, v105, self->_proxyPathCustomEnumerator);

            if (v106)
            {
              uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self->_quicProxyPath, "egressProxy"));
              -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v107);

              BOOL v108 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
              if (v108) {
                v108[11] = 0LL;
              }

              uint64_t v88 = self->_quicProxyPath;
LABEL_83:
              char v109 = (void *)objc_claimAutoreleasedReturnValue([v88 networkSingleHopAgentStatistics]);
              uint64_t v23 = v605;
              if (!v109)
              {
LABEL_85:

                goto LABEL_188;
              }

LABEL_187:
          goto LABEL_188;
        }

        if ((NSPQuicProxyPath *)self->_fallbackProxyPath == v66)
        {
          id v68 = self->_lastFallbackProxySwitchedDate;
          if (!v68
            || (__int128 v69 = v68,
                id v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
                [v70 timeIntervalSinceDate:self->_lastFallbackProxySwitchedDate],
                id v72 = v71,
                v70,
                v69,
                v72 > 30.0))
          {
            id v76 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
            if (!v76) {
              goto LABEL_188;
            }
            uint64_t v77 = v76[11];

            if (v77 < 3) {
              goto LABEL_188;
            }
            v605 = v23;
            id v81 = nplog_obj(v78, v79, v80);
            uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
            if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_INFO,  "Fallback proxy multihop path is reporting egress proxy error",  buf,  2u);
            }

            id v83 = self->_fallbackProxyPath;
            id v84 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v83, "egressProxy"));
            id v85 = sub_10002883C((id *)&self->super.isa, v84, self->_fallbackProxyPathCustomEnumerator);

            if (v85)
            {
              id v86 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](self->_fallbackProxyPath, "egressProxy"));
              -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v86);

              unsigned __int8 v87 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
              if (v87) {
                v87[11] = 0LL;
              }

              uint64_t v88 = self->_fallbackProxyPath;
              goto LABEL_83;
            }

            __int128 v259 = self->_probingReason;
            uint64_t v23 = v605;
            if (v259 == 1) {
              goto LABEL_188;
            }
            if (!v259)
            {
              sub_100036E68((id *)&self->super.isa, @"ProxyFallbackEgressError");
              sub_1000370F8((uint64_t)self, 1LL, v260);
              __int128 v261 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
              if (v261) {
                v261[11] = 0LL;
              }

              uint64_t v238 = self->_fallbackProxyPath;
              goto LABEL_218;
            }

            __int128 v302 = self->_fallbackProxyPath;
            goto LABEL_314;
          }

          id v231 = nplog_obj(v73, v74, v75);
          int v221 = (os_log_s *)objc_claimAutoreleasedReturnValue(v231);
          if (os_log_type_enabled(v221, OS_LOG_TYPE_INFO))
          {
            v607 = v23;
            id v222 = self->_lastFallbackProxySwitchedDate;
            id v223 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v222,  1LL,  2LL));
            *(_DWORD *)__int128 buf = 138412290;
            v635 = (NWPathStatus)v223;
            char v224 = "ignoring egress fallback proxy error, last fallback proxy switched date %@";
            goto LABEL_186;
          }

          goto LABEL_187;
        }
      }

LABEL_188:
      if (!v21) {
        goto LABEL_361;
      }
      id v110 = 11LL;
      goto LABEL_360;
    }

    if ((_DWORD)v8 != 1106)
    {
      if ((_DWORD)v8 != 1107) {
        goto LABEL_168;
      }
      id v111 = v12;
      id v112 = v10;
      if (!self)
      {
LABEL_329:

        if (v21)
        {
          id v110 = 13LL;
          goto LABEL_360;
        }

        goto LABEL_361;
      }

      if ((NSPFallbackProxyPath *)self->_quicProxyPath == v111)
      {
        v239 = self->_lastQuicProxySwitchedDate;
        if (!v239
          || (v240 = v239,
              id v241 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
              [v241 timeIntervalSinceDate:self->_lastQuicProxySwitchedDate],
              __int128 v243 = v242,
              v241,
              v240,
              v243 > 30.0))
        {
          v573 = v112;
          uint64_t v121 = v23;
          __int128 v247 = self->_quicProxyPath;
          __int128 v248 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v247, "egressProxy"));
          __int128 v249 = sub_10002883C((id *)&self->super.isa, v248, self->_proxyPathCustomEnumerator);

          __int128 v250 = self->_quicProxyPath;
          if (v249)
          {
            __int128 v251 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v250, "egressProxy"));
            -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v251);

            __int128 v252 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
            if (v252) {
              v252[13] = 0LL;
            }

            uint64_t v128 = self->_quicProxyPath;
            goto LABEL_208;
          }

          v326 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v250, "networkMultiHopAgentStatistics"));
          uint64_t v23 = v121;
          id v112 = v573;
          if (!v326) {
            goto LABEL_329;
          }
          v327 = v326[13];

          if (v327 < 3) {
            goto LABEL_329;
          }
          __int16 v328 = self->_probingReason;
          if (v328 == 1) {
            goto LABEL_329;
          }
          if (!v328)
          {
            sub_100036E68((id *)&self->super.isa, @"ProxyPrimaryEgressUnavailableError");
            sub_1000370F8((uint64_t)self, 1LL, v329);
            v330 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
            if (v330) {
              v330[13] = 0LL;
            }

            v331 = self->_quicProxyPath;
            goto LABEL_322;
          }

          v426 = self->_quicProxyPath;
LABEL_509:
          [v426 resetError];
          goto LABEL_329;
        }

        v337 = nplog_obj(v244, v245, v246);
        v338 = (os_log_s *)objc_claimAutoreleasedReturnValue(v337);
        if (os_log_type_enabled(v338, OS_LOG_TYPE_INFO))
        {
          v577 = v112;
          v339 = v23;
          v340 = self->_lastQuicProxySwitchedDate;
          v341 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v340,  1LL,  2LL));
          *(_DWORD *)__int128 buf = 138412290;
          v635 = (NWPathStatus)v341;
          v342 = "ignoring unavailable quic proxy error, last quic proxy switched date %@";
LABEL_327:
          _os_log_impl((void *)&_mh_execute_header, v338, OS_LOG_TYPE_INFO, v342, buf, 0xCu);

          uint64_t v23 = v339;
          id v112 = v577;
        }
      }

      else
      {
        if (self->_fallbackProxyPath != v111) {
          goto LABEL_329;
        }
        id v113 = self->_lastFallbackProxySwitchedDate;
        if (!v113
          || (id v114 = v113,
              unsigned int v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now")),
              [v115 timeIntervalSinceDate:self->_lastFallbackProxySwitchedDate],
              id v117 = v116,
              v115,
              v114,
              v117 > 30.0))
        {
          v573 = v112;
          uint64_t v121 = v23;
          uint64_t v122 = self->_fallbackProxyPath;
          uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v122, "egressProxy"));
          id v124 = sub_10002883C((id *)&self->super.isa, v123, self->_fallbackProxyPathCustomEnumerator);

          id v125 = self->_fallbackProxyPath;
          if (v124)
          {
            id v126 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath egressProxy](v125, "egressProxy"));
            -[NSPPrivacyProxyAgentManager switchProxy:](self, "switchProxy:", v126);

            id v127 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
            if (v127) {
              v127[13] = 0LL;
            }

            uint64_t v128 = self->_fallbackProxyPath;
LABEL_208:
            __int128 v253 = (void *)objc_claimAutoreleasedReturnValue([v128 networkSingleHopAgentStatistics]);
            uint64_t v23 = v121;
            if (v253) {
              v253[13] = 0LL;
            }

            id v112 = v573;
            goto LABEL_329;
          }

          v343 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v125, "networkMultiHopAgentStatistics"));
          uint64_t v23 = v121;
          id v112 = v573;
          if (!v343) {
            goto LABEL_329;
          }
          v344 = v343[13];

          if (v344 < 3) {
            goto LABEL_329;
          }
          v345 = self->_probingReason;
          if (v345 == 1) {
            goto LABEL_329;
          }
          if (!v345)
          {
            sub_100036E68((id *)&self->super.isa, @"ProxyFallbackEgressUnavailableError");
            sub_1000370F8((uint64_t)self, 1LL, v346);
            v347 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
            if (v347) {
              v347[13] = 0LL;
            }

            v331 = self->_fallbackProxyPath;
LABEL_322:
            v348 = (void *)objc_claimAutoreleasedReturnValue([v331 networkSingleHopAgentStatistics]);
            if (v348) {
              v348[13] = 0LL;
            }

            goto LABEL_329;
          }

          v426 = self->_fallbackProxyPath;
          goto LABEL_509;
        }

        v349 = nplog_obj(v118, v119, v120);
        v338 = (os_log_s *)objc_claimAutoreleasedReturnValue(v349);
        if (os_log_type_enabled(v338, OS_LOG_TYPE_INFO))
        {
          v577 = v112;
          v339 = v23;
          v340 = self->_lastFallbackProxySwitchedDate;
          v341 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v340,  1LL,  2LL));
          *(_DWORD *)__int128 buf = 138412290;
          v635 = (NWPathStatus)v341;
          v342 = "ignoring unavailable fallback proxy error, last fallback proxy switched date %@";
          goto LABEL_327;
        }
      }

      goto LABEL_329;
    }

    uint64_t v175 = v12;
    uint64_t v176 = v10;
    if (self)
    {
      v177 = -[NWPath status](self->_path, "status");
      if (v177 == NWPathStatusSatisfied)
      {
        v575 = v175;
        v589 = v8;
        v621 = v21;
        v180 = self->_quicProxyPath;
        __int16 v181 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v180, "networkMultiHopAgentStatistics"));
        id v182 = (void *)v181;
        v618 = v12;
        if (v181) {
          v183 = *(void *)(v181 + 80);
        }
        else {
          v183 = 0LL;
        }
        v561 = v176;
        id v184 = self->_quicProxyPath;
        id v185 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](v184, "networkSingleHopAgentStatistics"));
        uint64_t v186 = (void *)v185;
        int v187 = v23;
        v188 = v10;
        if (v185) {
          uint64_t v189 = *(void *)(v185 + 80);
        }
        else {
          uint64_t v189 = 0LL;
        }
        id v190 = v189 + v183;
        uint64_t v191 = self->_fallbackProxyPath;
        uint64_t v192 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v191, "networkMultiHopAgentStatistics"));
        v193 = (void *)v192;
        if (v192) {
          id v194 = *(void *)(v192 + 80);
        }
        else {
          id v194 = 0LL;
        }
        id v195 = v190 + v194;
        v196 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
        if (v196) {
          uint64_t v197 = v196[10];
        }
        else {
          uint64_t v197 = 0LL;
        }
        uint64_t v198 = v195 + v197;

        v199 = v198 >= 3;
        uint64_t v10 = v188;
        uint64_t v12 = v618;
        uint64_t v21 = v621;
        id v8 = v589;
        uint64_t v23 = v187;
        uint64_t v176 = v561;
        uint64_t v175 = v575;
        if (!v199) {
          goto LABEL_194;
        }
        v200 = self->_probingReason;
        if (v200 == 1) {
          goto LABEL_194;
        }
        if (!v200)
        {
          sub_100036E68((id *)&self->super.isa, @"ProxyCertError");
          sub_1000370F8((uint64_t)self, 1LL, v201);
          v202 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
          if (v202) {
            v202[10] = 0LL;
          }

          id v203 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
          if (v203) {
            v203[10] = 0LL;
          }

          uint64_t v204 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
          if (v204) {
            v204[10] = 0LL;
          }

          char v205 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
          if (v205) {
            v205[10] = 0LL;
          }

          goto LABEL_194;
        }
      }

      else
      {
        id v232 = nplog_obj(v177, v178, v179);
        id v233 = (os_log_s *)objc_claimAutoreleasedReturnValue(v232);
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          v234 = -[NWPath status](self->_path, "status");
          *(_DWORD *)__int128 buf = 134217984;
          v635 = v234;
          _os_log_impl( (void *)&_mh_execute_header,  v233,  OS_LOG_TYPE_DEFAULT,  "ignoring connection cert error, path status %ld",  buf,  0xCu);
        }
      }

      -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
      -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
    }

LABEL_194:
    if (!v21) {
      goto LABEL_361;
    }
    id v110 = 10LL;
    goto LABEL_360;
  }

  v617 = v12;
  v620 = v21;
  if (((1 << (v8 + 32)) & 0x4004C000) != 0)
  {
    uint64_t v24 = v12;
    int v25 = v10;
    if (!self) {
      goto LABEL_40;
    }
    id v26 = self->_path;
    if ((id)-[NWPath status](v26, "status") != (id)1) {
      goto LABEL_35;
    }
    id v27 = self->_lastPathUnsatisfiedDate;
    if (v27)
    {
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      uint64_t v12 = self->_lastPathUnsatisfiedDate;
      [v21 timeIntervalSinceDate:v12];
      if (v28 <= 5.0)
      {

        uint64_t v12 = v617;
        uint64_t v21 = v620;
LABEL_35:

LABEL_36:
        int v32 = nplog_obj(v29, v30, v31);
        id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          v572 = self->_path;
          v558 = -[NWPath status](v572, "status");
          id v34 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate interfaceName](v25, "interfaceName"));
          uint64_t v35 = self->_path;
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v35, "interface"));
          v596 = v10;
          v603 = v25;
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v36 interfaceName]);
          v587 = v24;
          uint64_t v38 = self->_lastPathUnsatisfiedDate;
          uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v38,  1LL,  2LL));
          int v40 = self->_lastPrimaryInterfaceChangedDate;
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v40,  1LL,  2LL));
          *(_DWORD *)__int128 buf = 134219010;
          v635 = v558;
          v636 = 2112;
          v637 = v34;
          v638 = 2112;
          v639 = v37;
          v640 = 2112;
          v641 = v39;
          v642 = 2112;
          v643 = (uint64_t)v41;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "ignoring dns blocked error, path status %ld reporting interface %@ primary interface %@ last path unsatisfie d date %@, last interface change date %@",  buf,  0x34u);

          uint64_t v24 = v587;
          int v25 = v603;

          uint64_t v12 = v617;
          uint64_t v21 = v620;

          uint64_t v10 = v596;
        }

LABEL_39:
        -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
        -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
        goto LABEL_40;
      }
    }

    v600 = v10;
    v608 = v25;
    v225 = self->_lastPrimaryInterfaceChangedDate;
    if (v225)
    {
      uint64_t v10 = (NSDate *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      int v25 = self->_lastPrimaryInterfaceChangedDate;
      -[NSDate timeIntervalSinceDate:](v10, "timeIntervalSinceDate:", v25);
      if (v226 <= 5.0)
      {
        id v230 = 0;
        goto LABEL_241;
      }

      if (!v608)
      {
        id v230 = 1;
        goto LABEL_241;
      }

      v227 = v608;
    }

    else
    {
      v227 = v25;
      if (!v25)
      {
        if (v27)
        {
        }

        int v25 = 0LL;
        goto LABEL_244;
      }
    }

    v590 = v24;
    uint64_t v228 = -[NSDate interfaceIndex](v227, "interfaceIndex");
    v229 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](self->_path, "interface"));
    id v230 = v228 == [v229 interfaceIndex];

    if (!v225)
    {
      uint64_t v24 = v590;
      if (!v27)
      {
LABEL_243:

        uint64_t v10 = v600;
        int v25 = v608;
        uint64_t v12 = v617;
        uint64_t v21 = v620;
        if (!v230) {
          goto LABEL_36;
        }
LABEL_244:
        __int128 v270 = self->_quicProxyPath;
        __int128 v271 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v270, "networkMultiHopAgentStatistics"));
        __int128 v272 = (void *)v271;
        if (v271) {
          __int128 v273 = *(void *)(v271 + 72);
        }
        else {
          __int128 v273 = 0LL;
        }
        __int128 v274 = self->_quicProxyPath;
        __int128 v275 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](v274, "networkSingleHopAgentStatistics"));
        __int128 v276 = v275;
        if (v275) {
          __int128 v277 = v275[9];
        }
        else {
          __int128 v277 = 0LL;
        }
        if ((unint64_t)(v277 + v273) < 3)
        {

          uint64_t v12 = v617;
          uint64_t v21 = v620;
        }

        else
        {
          __int128 v278 = self->_fallbackProxyPath;
          if (v278)
          {
            __int128 v279 = v278;
            __int128 v280 = v24;
            __int128 v281 = self->_fallbackProxyPath;
            __int128 v282 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v281, "networkMultiHopAgentStatistics"));
            __int128 v283 = (void *)v282;
            if (v282) {
              __int128 v284 = *(void *)(v282 + 72);
            }
            else {
              __int128 v284 = 0LL;
            }
            __int128 v285 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
            if (v285) {
              __int128 v286 = v285[9];
            }
            else {
              __int128 v286 = 0LL;
            }
            __int128 v287 = v286 + v284;

            __int128 v288 = v287 > 2;
            uint64_t v12 = v617;
            uint64_t v21 = v620;
            uint64_t v24 = v280;
            uint64_t v10 = v600;
            int v25 = v608;
            if (!v288) {
              goto LABEL_40;
            }
          }

          else
          {

            uint64_t v12 = v617;
            uint64_t v21 = v620;
          }

          __int128 v303 = self->_probingReason;
          if (v303 != 2)
          {
            if (!v303)
            {
              sub_100036E68((id *)&self->super.isa, @"ProxyConnectionDNSError");
              __int128 v304 = self->_quicProxyPath;
              __int128 v305 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v304, "networkMultiHopAgentStatistics"));
              __int128 v306 = (void *)v305;
              if (v305) {
                __int128 v307 = *(void *)(v305 + 16);
              }
              else {
                __int128 v307 = 0LL;
              }
              __int128 v308 = self->_quicProxyPath;
              __int128 v309 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](v308, "networkSingleHopAgentStatistics"));
              __int128 v310 = (void *)v309;
              v591 = v24;
              if (v309) {
                __int128 v311 = *(void *)(v309 + 16);
              }
              else {
                __int128 v311 = 0LL;
              }
              __int128 v312 = v311 + v307;
              __int128 v313 = self->_fallbackProxyPath;
              v314 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v313, "networkMultiHopAgentStatistics"));
              v315 = (void *)v314;
              if (v314) {
                v316 = *(void *)(v314 + 16);
              }
              else {
                v316 = 0LL;
              }
              v317 = v312 + v316;
              v318 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
              if (v318) {
                v319 = v318[2];
              }
              else {
                v319 = 0LL;
              }

              if (v317 + v319) {
                v321 = 1LL;
              }
              else {
                v321 = 2LL;
              }
              sub_1000370F8((uint64_t)self, v321, v320);
              v322 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
              if (v322) {
                v322[9] = 0LL;
              }

              v323 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
              uint64_t v24 = v591;
              uint64_t v10 = v600;
              uint64_t v21 = v620;
              int v25 = v608;
              if (v323) {
                v323[9] = 0LL;
              }

              v324 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
              if (v324) {
                v324[9] = 0LL;
              }

              v325 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
              if (v325) {
                v325[9] = 0LL;
              }

              goto LABEL_40;
            }

            goto LABEL_39;
          }
        }

LABEL_40:
        if (v21) {
          ++v21[9];
        }
        goto LABEL_362;
      }
}
}

    accessTokenBlockedIssuers = v43->_accessTokenBlockedIssuers;
  }

  else
  {
    accessTokenBlockedIssuers = 0LL;
  }

  if (-[NSArray count](accessTokenBlockedIssuers, "count"))
  {
    uint64_t v57 = self;
    if (self) {
      uint64_t v57 = self->_accessTokenBlockedIssuers;
    }
    id v58 = v57;
    int v59 = (void *)objc_claimAutoreleasedReturnValue([v21 issuerName]);
    id v60 = (void *)objc_claimAutoreleasedReturnValue([v59 lowercaseString]);
    uint64_t v61 = [v58 containsObject:v60];

    if (v61)
    {
      __int128 v65 = nplog_obj(v62, v63, v64);
      dispatch_source_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v66 = (void *)objc_claimAutoreleasedReturnValue([v21 issuerName]);
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v66;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Cannot fetch token from issuer %@, not allowed",  (uint8_t *)&buf,  0xCu);
      }

LABEL_242:
      goto LABEL_243;
    }

    uint64_t v24 = v590;
LABEL_241:

    if (!v27) {
      goto LABEL_243;
    }
    goto LABEL_242;
  }

  if ((_DWORD)v8 != -65568)
  {
LABEL_116:
    if ((_DWORD)v8 != 60)
    {
      if ((_DWORD)v8 == 61)
      {
        __int128 v148 = v12;
        __int128 v149 = v10;
        if (!self) {
          goto LABEL_263;
        }
        __int128 v150 = self->_path;
        v560 = v148;
        if ((id)-[NWPath status](v150, "status") == (id)1)
        {
          __int128 v151 = self->_lastPathUnsatisfiedDate;
          if (!v151) {
            goto LABEL_236;
          }
          a5 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
          __int128 v152 = self->_lastPathUnsatisfiedDate;
          [a5 timeIntervalSinceDate:v152];
          if (v153 > 30.0)
          {
            v548 = v152;
            v571 = a5;
LABEL_236:
            __int128 v267 = self->_lastPrimaryInterfaceChangedDate;
            v610 = v23;
            if (v267)
            {
              a5 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
              id v8 = self->_lastPrimaryInterfaceChangedDate;
              [a5 timeIntervalSinceDate:v8];
              if (v268 <= 30.0)
              {
                __int128 v269 = 0;
                goto LABEL_309;
              }

              if (!v149)
              {
                __int128 v269 = 1;
                goto LABEL_309;
              }
            }

            else if (!v149)
            {
              if (v151)
              {
              }

              uint64_t v12 = v617;
              id v8 = v8;
              goto LABEL_366;
            }

            v332 = -[NSDate interfaceIndex](v149, "interfaceIndex");
            v333 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](self->_path, "interface"));
            __int128 v269 = v332 == [v333 interfaceIndex];

            if (!v267)
            {
              uint64_t v23 = v610;
              if (!v151)
              {
LABEL_311:

                uint64_t v12 = v617;
                id v8 = 61LL;
                if (v269)
                {
LABEL_366:
                  v386 = self->_fallbackProxyPath;
                  v387 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v386, "networkMultiHopAgentStatistics"));
                  v388 = (void *)v387;
                  uint64_t v21 = v620;
                  if (v387) {
                    v389 = *(void *)(v387 + 32);
                  }
                  else {
                    v389 = 0LL;
                  }
                  v390 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
                  if (v390) {
                    v391 = v390[4];
                  }
                  else {
                    v391 = 0LL;
                  }
                  v392 = v391 + v389;

                  if (v392 < 3)
                  {
                    uint64_t v23 = v610;
                    __int128 v148 = v560;
                    if (-[NSPPrivacyProxyAgentManager networkDiscoveredProxyPresentInAgentManager]( self,  "networkDiscoveredProxyPresentInAgentManager"))
                    {
                      v554 = v149;
                      v602 = v10;
                      v629 = 0u;
                      v630 = 0u;
                      v627 = 0u;
                      v628 = 0u;
                      v397 = self->_networkSpecificQUICProxyPaths;
                      v398 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v397,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                      if (v398)
                      {
                        v399 = v398;
                        v400 = *(void *)v628;
                        v557 = self;
                        do
                        {
                          v401 = 0LL;
                          do
                          {
                            if (*(void *)v628 != v400) {
                              objc_enumerationMutation(v397);
                            }
                            v402 = (NSDate *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKey:]( self->_networkSpecificQUICProxyPaths,  "objectForKey:",  *(void *)(*((void *)&v627 + 1) + 8LL * (void)v401)));
                            if (v402 == v148)
                            {
                              v403 = (void *)objc_claimAutoreleasedReturnValue( -[NSDate networkMultiHopAgentStatistics]( v148,  "networkMultiHopAgentStatistics"));
                              if (v403)
                              {
                                v404 = v403[4];

                                if (v404 >= 3)
                                {
                                  v408 = nplog_obj(v405, v406, v407);
                                  v409 = (os_log_s *)objc_claimAutoreleasedReturnValue(v408);
                                  if (os_log_type_enabled(v409, OS_LOG_TYPE_INFO))
                                  {
                                    v410 = v148;
                                    v411 = objc_claimAutoreleasedReturnValue(-[NSDate ingressProxy](v148, "ingressProxy"));
                                    v412 = (void *)v411;
                                    if (v411) {
                                      v413 = *(void **)(v411 + 24);
                                    }
                                    else {
                                      v413 = 0LL;
                                    }
                                    v414 = v413;
                                    v415 = (void *)objc_claimAutoreleasedReturnValue([v414 vendor]);
                                    *(_DWORD *)v632 = 138412290;
                                    v633 = v415;
                                    _os_log_impl( (void *)&_mh_execute_header,  v409,  OS_LOG_TYPE_INFO,  "Network discovered proxy: %@ exceeded the connection refused count, removing registration",  v632,  0xCu);

                                    id v8 = 61LL;
                                    uint64_t v23 = v610;
                                    __int128 v148 = v410;
                                    self = v557;
                                  }

                                  -[NSPPrivacyProxyAgentManager tearDownNetworkDiscoveredProxy]( self,  "tearDownNetworkDiscoveredProxy");
                                }
                              }
                            }

                            v401 = (char *)v401 + 1;
                          }

                          while (v399 != v401);
                          v416 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v397,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                          v399 = v416;
                        }

                        while (v416);
                      }

                      uint64_t v10 = v602;
                      uint64_t v12 = v617;
                      uint64_t v21 = v620;
                      __int128 v149 = v554;
                    }
                  }

                  else
                  {
                    v393 = self->_probingReason;
                    uint64_t v23 = v610;
                    __int128 v148 = v560;
                    if (v393 != 1)
                    {
                      if (v393)
                      {
                        -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
                        -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
                      }

                      else
                      {
                        sub_100036E68((id *)&self->super.isa, @"ProxyConnectionRefused");
                        sub_1000370F8((uint64_t)self, 1LL, v394);
                        v395 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
                        if (v395) {
                          v395[4] = 0LL;
                        }

                        v396 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
                        if (v396) {
                          v396[4] = 0LL;
                        }
                      }
                    }
                  }

                  goto LABEL_263;
                }

LABEL_260:
                __int128 v292 = nplog_obj(v289, v290, v291);
                __int128 v293 = (os_log_s *)objc_claimAutoreleasedReturnValue(v292);
                if (os_log_type_enabled(v293, OS_LOG_TYPE_DEFAULT))
                {
                  v576 = self->_path;
                  v541 = -[NWPath status](v576, "status");
                  __int128 v294 = v149;
                  __int128 v295 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate interfaceName](v149, "interfaceName"));
                  v545 = self->_path;
                  __int128 v296 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v545, "interface"));
                  __int128 v297 = (void *)objc_claimAutoreleasedReturnValue([v296 interfaceName]);
                  v550 = v294;
                  v611 = v23;
                  __int128 v298 = self->_lastPathUnsatisfiedDate;
                  __int128 v299 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v298,  1LL,  2LL));
                  __int128 v300 = self->_lastPrimaryInterfaceChangedDate;
                  __int128 v301 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v300,  1LL,  2LL));
                  *(_DWORD *)__int128 buf = 134219010;
                  v635 = v541;
                  v636 = 2112;
                  v637 = v295;
                  v638 = 2112;
                  v639 = v297;
                  v640 = 2112;
                  v641 = v299;
                  v642 = 2112;
                  v643 = (uint64_t)v301;
                  _os_log_impl( (void *)&_mh_execute_header,  v293,  OS_LOG_TYPE_DEFAULT,  "ignoring connection refused error, path status %ld reporting interface %@ primary interface %@ last path unsatisfied date %@, last interface change date %@",  buf,  0x34u);

                  uint64_t v23 = v611;
                  uint64_t v12 = v617;

                  __int128 v149 = v550;
                }

                -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
                -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
                uint64_t v21 = v620;
                id v8 = 61LL;
                __int128 v148 = v560;
LABEL_263:

                if (v21)
                {
                  id v110 = 4LL;
                  goto LABEL_360;
                }

LABEL_361:
                v384 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate ingressProxy](v12, "ingressProxy"));
                v385 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate egressProxy](v12, "egressProxy"));
                -[NSPPrivacyProxyAgentManager sendRTCReportWithFailureType:errorCode:url:ingressProxy:egressProxy:tokenServer:]( self,  "sendRTCReportWithFailureType:errorCode:url:ingressProxy:egressProxy:tokenServer:",  v23,  v8,  0LL,  v384,  v385,  0LL);

                goto LABEL_362;
              }

LABEL_310:
              goto LABEL_311;
            }

            uint64_t v23 = v610;
LABEL_309:

            if (!v151) {
              goto LABEL_311;
            }
            goto LABEL_310;
          }

          uint64_t v12 = v617;
        }

        goto LABEL_260;
      }

LABEL_168:
      unsigned int v213 = v12;
      v214 = v10;
      if (!self) {
        goto LABEL_358;
      }
      v622 = v21;
      uint64_t v215 = self->_path;
      v599 = v10;
      if ((id)-[NWPath status](v215, "status") == (id)1)
      {
        linkQuality = self->_linkQuality;
        if (linkQuality != 10 && linkQuality != 20)
        {
          v619 = v12;
          uint64_t v217 = self->_lastPathUnsatisfiedDate;
          if (!v217) {
            goto LABEL_340;
          }
          v218 = (NSDate *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
          uint64_t v6 = self->_lastPathUnsatisfiedDate;
          -[NSDate timeIntervalSinceDate:](v218, "timeIntervalSinceDate:", v6);
          if (v219 > 30.0)
          {
            v544 = v218;
LABEL_340:
            v551 = v6;
            v593 = v8;
            v357 = self->_lastPrimaryInterfaceChangedDate;
            if (v357)
            {
              uint64_t v6 = (NSDate *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
              id v8 = self->_lastPrimaryInterfaceChangedDate;
              -[NSDate timeIntervalSinceDate:](v6, "timeIntervalSinceDate:", v8);
              if (v358 <= 30.0)
              {
                v359 = 0;
                goto LABEL_419;
              }

              if (!v214)
              {
                v359 = 1;
                goto LABEL_419;
              }
            }

            else if (!v214)
            {
              if (v217)
              {
              }

              goto LABEL_489;
            }

            v566 = v214;
            v582 = v213;
            v616 = v23;
            v423 = -[NSDate interfaceIndex](v214, "interfaceIndex");
            v424 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](self->_path, "interface"));
            v425 = [v424 interfaceIndex];
            v359 = v423 == v425;

            if (!v357)
            {
              unsigned int v213 = v582;
              if (v217)
              {
              }

              v427 = v423 == v425;
              uint64_t v23 = v616;
              uint64_t v12 = v619;
              id v8 = v593;
              v214 = v566;
              if (v427) {
                goto LABEL_489;
              }
              goto LABEL_355;
            }

            uint64_t v23 = v616;
            v214 = v566;
            unsigned int v213 = v582;
LABEL_419:

            if (v217)
            {
            }

            uint64_t v12 = v619;
            id v8 = v593;
            if (v359)
            {
LABEL_489:
              v466 = self->_fallbackProxyPath;
              v467 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v466, "networkMultiHopAgentStatistics"));
              v468 = (void *)v467;
              if (v467) {
                v469 = *(void *)(v467 + 56);
              }
              else {
                v469 = 0LL;
              }
              v470 = self->_fallbackProxyPath;
              v471 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( v470,  "networkSingleHopAgentStatistics"));
              v472 = v471;
              if (v471) {
                v473 = v471[7];
              }
              else {
                v473 = 0LL;
              }
              uint64_t v10 = v599;
              if ((unint64_t)(v473 + v469) > 9)
              {
              }

              else
              {
                v474 = self->_fallbackProxyPath;
                if (v474)
                {

                  goto LABEL_541;
                }

                v569 = v214;
                v585 = v213;
                v509 = v23;
                v510 = self->_quicProxyPath;
                v511 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v510, "networkMultiHopAgentStatistics"));
                v512 = (void *)v511;
                if (v511) {
                  v513 = *(void *)(v511 + 56);
                }
                else {
                  v513 = 0LL;
                }
                v514 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
                if (v514) {
                  v515 = v514[7];
                }
                else {
                  v515 = 0LL;
                }
                v516 = v515 + v513;

                __int128 v288 = v516 > 9;
                uint64_t v23 = v509;
                v214 = v569;
                unsigned int v213 = v585;
                if (!v288)
                {
LABEL_541:
                  uint64_t v12 = v619;
                  uint64_t v21 = v622;
                  id v8 = v593;
                  if (-[NSPPrivacyProxyAgentManager networkDiscoveredProxyPresentInAgentManager]( self,  "networkDiscoveredProxyPresentInAgentManager"))
                  {
                    v570 = v214;
                    v629 = 0u;
                    v630 = 0u;
                    v627 = 0u;
                    v628 = 0u;
                    v517 = self->_networkSpecificQUICProxyPaths;
                    v518 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v517,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                    if (v518)
                    {
                      v519 = v518;
                      v520 = *(void *)v628;
                      v586 = v213;
                      v556 = v517;
                      do
                      {
                        v521 = 0LL;
                        do
                        {
                          if (*(void *)v628 != v520) {
                            objc_enumerationMutation(v517);
                          }
                          v522 = (NSDate *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKey:]( self->_networkSpecificQUICProxyPaths,  "objectForKey:",  *(void *)(*((void *)&v627 + 1) + 8LL * (void)v521)));
                          if (v522 == v213)
                          {
                            v523 = (void *)objc_claimAutoreleasedReturnValue( -[NSDate networkMultiHopAgentStatistics]( v213,  "networkMultiHopAgentStatistics"));
                            if (v523)
                            {
                              v524 = v523[7];

                              if (v524 >= 0xA)
                              {
                                v528 = nplog_obj(v525, v526, v527);
                                v529 = (os_log_s *)objc_claimAutoreleasedReturnValue(v528);
                                if (os_log_type_enabled(v529, OS_LOG_TYPE_INFO))
                                {
                                  v530 = objc_claimAutoreleasedReturnValue(-[NSDate ingressProxy](v213, "ingressProxy"));
                                  v531 = (void *)v530;
                                  v532 = v23;
                                  if (v530) {
                                    v533 = *(void **)(v530 + 24);
                                  }
                                  else {
                                    v533 = 0LL;
                                  }
                                  v534 = v533;
                                  v535 = (void *)objc_claimAutoreleasedReturnValue([v534 vendor]);
                                  *(_DWORD *)v632 = 138412290;
                                  v633 = v535;
                                  _os_log_impl( (void *)&_mh_execute_header,  v529,  OS_LOG_TYPE_INFO,  "Network discovered proxy: %@ exceeded the connection error count, removing registration",  v632,  0xCu);

                                  id v8 = v593;
                                  uint64_t v23 = v532;
                                  unsigned int v213 = v586;
                                  v517 = v556;
                                }

                                -[NSPPrivacyProxyAgentManager tearDownNetworkDiscoveredProxy]( self,  "tearDownNetworkDiscoveredProxy");
                              }
                            }
                          }

                          v521 = (char *)v521 + 1;
                        }

                        while (v519 != v521);
                        v536 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v517,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                        v519 = v536;
                      }

                      while (v536);
                    }

                    uint64_t v10 = v599;
                    uint64_t v12 = v619;
                    uint64_t v21 = v622;
                    v214 = v570;
                  }

                  goto LABEL_358;
                }
              }

              v475 = self->_probingReason;
              uint64_t v12 = v619;
              uint64_t v21 = v622;
              id v8 = v593;
              if (v475 != 1)
              {
                if (v475)
                {
                  -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
                  -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
                }

                else
                {
                  sub_100036E68((id *)&self->super.isa, @"ProxyError");
                  sub_1000370F8((uint64_t)self, 1LL, v476);
                  v477 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
                  if (v477) {
                    v477[7] = 0LL;
                  }

                  v478 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
                  if (v478) {
                    v478[7] = 0LL;
                  }

                  v479 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
                  if (v479) {
                    v479[7] = 0LL;
                  }

                  v480 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
                  if (v480) {
                    v480[7] = 0LL;
                  }
                }
              }

LABEL_358:
              if (v21)
              {
                id v110 = 7LL;
                goto LABEL_360;
              }

              goto LABEL_361;
            }

LABEL_355:
            v375 = nplog_obj(v372, v373, v374);
            v376 = (os_log_s *)objc_claimAutoreleasedReturnValue(v375);
            if (os_log_type_enabled(v376, OS_LOG_TYPE_DEFAULT))
            {
              v553 = self->_path;
              v543 = -[NWPath status](v553, "status");
              v538 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities stringFromLinkQualityValue:]( &OBJC_CLASS___NPUtilities,  "stringFromLinkQualityValue:",  self->_linkQuality));
              v540 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate interfaceName](v214, "interfaceName"));
              v547 = self->_path;
              v595 = v8;
              v377 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v547, "interface"));
              v378 = (void *)objc_claimAutoreleasedReturnValue([v377 interfaceName]);
              v563 = v214;
              v580 = v213;
              v614 = v23;
              v379 = self->_lastPathUnsatisfiedDate;
              v380 = objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v379,  1LL,  2LL));
              v381 = self->_lastPrimaryInterfaceChangedDate;
              v382 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v381,  1LL,  2LL));
              *(_DWORD *)__int128 buf = 134219266;
              v635 = v543;
              v636 = 2112;
              v637 = v538;
              v638 = 2112;
              v639 = v540;
              v640 = 2112;
              v641 = v378;
              v642 = 2112;
              v643 = v380;
              v383 = (void *)v380;
              v644 = 2112;
              v645 = v382;
              _os_log_impl( (void *)&_mh_execute_header,  v376,  OS_LOG_TYPE_DEFAULT,  "ignoring connection error, path status %ld link quality %@ reporting interface %@ primary interface %@ l ast path unsatisfied date %@, last interface change date %@",  buf,  0x3Eu);

              uint64_t v23 = v614;
              v214 = v563;

              id v8 = v595;
              unsigned int v213 = v580;
            }

            -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
            -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
            uint64_t v10 = v599;
            uint64_t v21 = v622;
            goto LABEL_358;
          }

          uint64_t v12 = v619;
        }
      }

      goto LABEL_355;
    }

    v206 = v12;
    id v207 = v10;
    if (!self) {
      goto LABEL_351;
    }
    id v208 = self->_path;
    v598 = v10;
    if ((id)-[NWPath status](v208, "status") == (id)1)
    {
      id v209 = self->_linkQuality;
      if (v209 != 10 && v209 != 20)
      {
        id v210 = self->_lastPathUnsatisfiedDate;
        if (!v210) {
          goto LABEL_336;
        }
        a5 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
        id v211 = self->_lastPathUnsatisfiedDate;
        [a5 timeIntervalSinceDate:v211];
        if (v212 > 30.0)
        {
          v544 = v211;
          v548 = a5;
LABEL_336:
          v354 = self->_lastPrimaryInterfaceChangedDate;
          if (v354)
          {
            a5 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
            id v8 = self->_lastPrimaryInterfaceChangedDate;
            [a5 timeIntervalSinceDate:v8];
            if (v355 <= 30.0)
            {
              v356 = 0;
              goto LABEL_414;
            }

            if (!v207)
            {
              v356 = 1;
              goto LABEL_414;
            }
          }

          else if (!v207)
          {
            if (v210)
            {
            }

            goto LABEL_467;
          }

          v565 = v207;
          v581 = v206;
          v615 = v23;
          v420 = -[NSDate interfaceIndex](v207, "interfaceIndex");
          v421 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](self->_path, "interface"));
          v422 = [v421 interfaceIndex];
          v356 = v420 == v422;

          if (!v354)
          {
            v206 = v581;
            if (v210)
            {
            }

            v427 = v420 == v422;
            uint64_t v23 = v615;
            uint64_t v12 = v617;
            id v8 = 60LL;
            id v207 = v565;
            if (v427) {
              goto LABEL_467;
            }
            goto LABEL_348;
          }

          uint64_t v23 = v615;
          id v207 = v565;
          v206 = v581;
LABEL_414:

          if (v210)
          {
          }

          uint64_t v12 = v617;
          id v8 = 60LL;
          if (v356)
          {
LABEL_467:
            v451 = self->_fallbackProxyPath;
            v452 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v451, "networkMultiHopAgentStatistics"));
            v453 = (void *)v452;
            if (v452) {
              v454 = *(void *)(v452 + 24);
            }
            else {
              v454 = 0LL;
            }
            v455 = self->_fallbackProxyPath;
            v456 = (void *)objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](v455, "networkSingleHopAgentStatistics"));
            v457 = v456;
            if (v456) {
              v458 = v456[3];
            }
            else {
              v458 = 0LL;
            }
            uint64_t v10 = v598;
            if ((unint64_t)(v458 + v454) > 9)
            {
            }

            else
            {
              v459 = self->_fallbackProxyPath;
              if (v459)
              {

                goto LABEL_517;
              }

              v567 = v207;
              v583 = v206;
              v481 = v23;
              v482 = self->_quicProxyPath;
              v483 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v482, "networkMultiHopAgentStatistics"));
              v484 = (void *)v483;
              if (v483) {
                v485 = *(void *)(v483 + 24);
              }
              else {
                v485 = 0LL;
              }
              v486 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
              if (v486) {
                v487 = v486[3];
              }
              else {
                v487 = 0LL;
              }
              v488 = v487 + v485;

              __int128 v288 = v488 > 9;
              uint64_t v23 = v481;
              id v207 = v567;
              v206 = v583;
              if (!v288)
              {
LABEL_517:
                uint64_t v12 = v617;
                uint64_t v21 = v620;
                id v8 = 60LL;
                if (-[NSPPrivacyProxyAgentManager networkDiscoveredProxyPresentInAgentManager]( self,  "networkDiscoveredProxyPresentInAgentManager"))
                {
                  v568 = v207;
                  v629 = 0u;
                  v630 = 0u;
                  v627 = 0u;
                  v628 = 0u;
                  v489 = self->_networkSpecificQUICProxyPaths;
                  v490 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v489,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                  if (v490)
                  {
                    v491 = v490;
                    v492 = *(void *)v628;
                    v584 = v206;
                    v555 = v489;
                    do
                    {
                      v493 = 0LL;
                      do
                      {
                        if (*(void *)v628 != v492) {
                          objc_enumerationMutation(v489);
                        }
                        v494 = (NSDate *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKey:]( self->_networkSpecificQUICProxyPaths,  "objectForKey:",  *(void *)(*((void *)&v627 + 1) + 8LL * (void)v493)));
                        if (v494 == v206)
                        {
                          v495 = (void *)objc_claimAutoreleasedReturnValue( -[NSDate networkMultiHopAgentStatistics]( v206,  "networkMultiHopAgentStatistics"));
                          if (v495)
                          {
                            v496 = v495[3];

                            if (v496 >= 0xA)
                            {
                              v500 = nplog_obj(v497, v498, v499);
                              v501 = (os_log_s *)objc_claimAutoreleasedReturnValue(v500);
                              if (os_log_type_enabled(v501, OS_LOG_TYPE_INFO))
                              {
                                v502 = objc_claimAutoreleasedReturnValue(-[NSDate ingressProxy](v206, "ingressProxy"));
                                v503 = (void *)v502;
                                v504 = v23;
                                if (v502) {
                                  v505 = *(void **)(v502 + 24);
                                }
                                else {
                                  v505 = 0LL;
                                }
                                v506 = v505;
                                v507 = (void *)objc_claimAutoreleasedReturnValue([v506 vendor]);
                                *(_DWORD *)v632 = 138412290;
                                v633 = v507;
                                _os_log_impl( (void *)&_mh_execute_header,  v501,  OS_LOG_TYPE_INFO,  "Network discovered proxy: %@ exceeded the timeout count, removing registration",  v632,  0xCu);

                                id v8 = 60LL;
                                uint64_t v23 = v504;
                                v206 = v584;
                                v489 = v555;
                              }

                              -[NSPPrivacyProxyAgentManager tearDownNetworkDiscoveredProxy]( self,  "tearDownNetworkDiscoveredProxy");
                            }
                          }
                        }

                        v493 = (char *)v493 + 1;
                      }

                      while (v491 != v493);
                      v508 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v489,  "countByEnumeratingWithState:objects:count:",  &v627,  buf,  16LL);
                      v491 = v508;
                    }

                    while (v508);
                  }

                  uint64_t v10 = v598;
                  uint64_t v12 = v617;
                  uint64_t v21 = v620;
                  id v207 = v568;
                }

                goto LABEL_351;
              }
            }

            v460 = self->_probingReason;
            uint64_t v12 = v617;
            uint64_t v21 = v620;
            id v8 = 60LL;
            if (v460 != 1)
            {
              if (v460)
              {
                -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
                -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
              }

              else
              {
                sub_100036E68((id *)&self->super.isa, @"ProxyConnectionTimeout");
                sub_1000370F8((uint64_t)self, 1LL, v461);
                v462 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
                if (v462) {
                  v462[3] = 0LL;
                }

                v463 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
                if (v463) {
                  v463[3] = 0LL;
                }

                v464 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
                if (v464) {
                  v464[3] = 0LL;
                }

                v465 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
                if (v465) {
                  v465[3] = 0LL;
                }
              }
            }

LABEL_351:
            if (v21)
            {
              id v110 = 3LL;
              goto LABEL_360;
            }

            goto LABEL_361;
          }

LABEL_348:
          v363 = nplog_obj(v360, v361, v362);
          v364 = (os_log_s *)objc_claimAutoreleasedReturnValue(v363);
          if (os_log_type_enabled(v364, OS_LOG_TYPE_DEFAULT))
          {
            v552 = self->_path;
            v542 = -[NWPath status](v552, "status");
            v537 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities stringFromLinkQualityValue:]( &OBJC_CLASS___NPUtilities,  "stringFromLinkQualityValue:",  self->_linkQuality));
            v539 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate interfaceName](v207, "interfaceName"));
            v546 = self->_path;
            v594 = v8;
            v365 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v546, "interface"));
            v366 = (void *)objc_claimAutoreleasedReturnValue([v365 interfaceName]);
            v562 = v207;
            v579 = v206;
            v613 = v23;
            v367 = self->_lastPathUnsatisfiedDate;
            v368 = objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v367,  1LL,  2LL));
            v369 = self->_lastPrimaryInterfaceChangedDate;
            v370 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v369,  1LL,  2LL));
            *(_DWORD *)__int128 buf = 134219266;
            v635 = v542;
            v636 = 2112;
            v637 = v537;
            v638 = 2112;
            v639 = v539;
            v640 = 2112;
            v641 = v366;
            v642 = 2112;
            v643 = v368;
            v371 = (void *)v368;
            v644 = 2112;
            v645 = v370;
            _os_log_impl( (void *)&_mh_execute_header,  v364,  OS_LOG_TYPE_DEFAULT,  "ignoring connection timeout error, path status %ld link quality %@ reporting interface %@ primary interfac e %@ last path unsatisfied date %@, last interface change date %@",  buf,  0x3Eu);

            uint64_t v23 = v613;
            id v207 = v562;

            id v8 = v594;
            v206 = v579;

            uint64_t v12 = v617;
          }

          -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
          -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
          uint64_t v10 = v598;
          uint64_t v21 = v620;
          goto LABEL_351;
        }

        uint64_t v12 = v617;
      }
    }

    goto LABEL_348;
  }

  id v129 = v12;
  id v130 = v10;
  if (!self) {
    goto LABEL_114;
  }
  id v131 = self->_path;
  if ((id)-[NWPath status](v131, "status") != (id)1) {
    goto LABEL_109;
  }
  id v132 = self->_linkQuality;
  if (v132 == 10 || v132 == 20) {
    goto LABEL_109;
  }
  id v133 = self->_lastPathUnsatisfiedDate;
  if (v133)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    uint64_t v12 = self->_lastPathUnsatisfiedDate;
    [v5 timeIntervalSinceDate:v12];
    if (v134 <= 30.0)
    {

      uint64_t v12 = v617;
LABEL_109:

LABEL_110:
      unsigned int v138 = nplog_obj(v135, v136, v137);
      id v139 = (os_log_s *)objc_claimAutoreleasedReturnValue(v138);
      if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
      {
        v574 = self->_path;
        v549 = -[NWPath status](v574, "status");
        __int128 v140 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities stringFromLinkQualityValue:]( &OBJC_CLASS___NPUtilities,  "stringFromLinkQualityValue:",  self->_linkQuality));
        __int128 v141 = (void *)objc_claimAutoreleasedReturnValue(-[NSDate interfaceName](v130, "interfaceName"));
        v559 = self->_path;
        v597 = v10;
        __int128 v142 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v559, "interface"));
        id v143 = (void *)objc_claimAutoreleasedReturnValue([v142 interfaceName]);
        v606 = v129;
        uint64_t v144 = self->_lastPathUnsatisfiedDate;
        v588 = v130;
        id v145 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v144,  1LL,  2LL));
        __int128 v146 = self->_lastPrimaryInterfaceChangedDate;
        __int128 v147 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v146,  1LL,  2LL));
        *(_DWORD *)__int128 buf = 134219266;
        v635 = v549;
        v636 = 2112;
        v637 = v140;
        v638 = 2112;
        v639 = v141;
        v640 = 2112;
        v641 = v143;
        v642 = 2112;
        v643 = (uint64_t)v145;
        v644 = 2112;
        v645 = v147;
        _os_log_impl( (void *)&_mh_execute_header,  v139,  OS_LOG_TYPE_DEFAULT,  "ignoring DNS timeout error, path status %ld link quality %@ reporting interface %@ primary interface %@ last p ath unsatisfied date %@, last interface change date %@",  buf,  0x3Eu);

        id v129 = v606;
        uint64_t v21 = v620;

        uint64_t v10 = v597;
        uint64_t v12 = v617;

        id v130 = v588;
      }

LABEL_113:
      -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
      -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
      goto LABEL_114;
    }
  }

  v601 = v10;
  v351 = self->_lastPrimaryInterfaceChangedDate;
  v612 = v129;
  v592 = v130;
  if (v351)
  {
    a5 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    uint64_t v10 = self->_lastPrimaryInterfaceChangedDate;
    [a5 timeIntervalSinceDate:v10];
    if (v352 <= 30.0)
    {
      v578 = v5;
      v353 = 0;
      goto LABEL_409;
    }

    if (!v130)
    {
      v578 = v5;
      v353 = 1;
      goto LABEL_409;
    }
  }

  else if (!v130)
  {
    if (v133)
    {
    }

    uint64_t v12 = v617;
    uint64_t v21 = v620;
    goto LABEL_443;
  }

  v564 = v12;
  v578 = v5;
  v417 = -[NSDate interfaceIndex](v130, "interfaceIndex");
  v418 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](self->_path, "interface"));
  v419 = [v418 interfaceIndex];
  v353 = v417 == v419;

  if (!v351)
  {
    if (v133)
    {
    }

    v427 = v417 == v419;
    uint64_t v10 = v601;
    id v129 = v612;
    uint64_t v12 = v617;
    uint64_t v21 = v620;
    id v130 = v592;
    if (!v427) {
      goto LABEL_110;
    }
    goto LABEL_443;
  }

  id v129 = v612;
  id v130 = v592;
  uint64_t v12 = v564;
LABEL_409:

  if (v133)
  {
  }

  uint64_t v10 = v601;
  uint64_t v12 = v617;
  uint64_t v21 = v620;
  if (!v353) {
    goto LABEL_110;
  }
LABEL_443:
  v428 = self->_quicProxyPath;
  v429 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v428, "networkMultiHopAgentStatistics"));
  v430 = (void *)v429;
  if (v429) {
    v431 = *(void *)(v429 + 64);
  }
  else {
    v431 = 0LL;
  }
  v432 = self->_quicProxyPath;
  v433 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkSingleHopAgentStatistics](v432, "networkSingleHopAgentStatistics"));
  v434 = (void *)v433;
  if (v433) {
    v435 = *(void *)(v433 + 64);
  }
  else {
    v435 = 0LL;
  }
  v436 = v435 + v431;
  v437 = self->_fallbackProxyPath;
  v438 = objc_claimAutoreleasedReturnValue(-[NSPProxyPath networkMultiHopAgentStatistics](v437, "networkMultiHopAgentStatistics"));
  v439 = (void *)v438;
  if (v438) {
    v440 = *(void *)(v438 + 64);
  }
  else {
    v440 = 0LL;
  }
  v441 = v436 + v440;
  v442 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
  if (v442) {
    v443 = v442[8];
  }
  else {
    v443 = 0LL;
  }
  v444 = v441 + v443;

  v199 = v444 >= 3;
  uint64_t v10 = v601;
  id v129 = v612;
  id v130 = v592;
  if (v199)
  {
    v445 = self->_probingReason;
    if (v445 != 1)
    {
      if (!v445)
      {
        sub_100036E68((id *)&self->super.isa, @"ProxyConnectionDNSTimeout");
        sub_1000370F8((uint64_t)self, 1LL, v446);
        v447 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_quicProxyPath,  "networkMultiHopAgentStatistics"));
        if (v447) {
          v447[8] = 0LL;
        }

        v448 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_quicProxyPath,  "networkSingleHopAgentStatistics"));
        if (v448) {
          v448[8] = 0LL;
        }

        v449 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkMultiHopAgentStatistics]( self->_fallbackProxyPath,  "networkMultiHopAgentStatistics"));
        if (v449) {
          v449[8] = 0LL;
        }

        v450 = (void *)objc_claimAutoreleasedReturnValue( -[NSPProxyPath networkSingleHopAgentStatistics]( self->_fallbackProxyPath,  "networkSingleHopAgentStatistics"));
        if (v450) {
          v450[8] = 0LL;
        }

        goto LABEL_114;
      }

      goto LABEL_113;
    }
  }

LABEL_114:
  if (v21) {
    ++v21[8];
  }
LABEL_362:
  -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
}

void sub_10003AD10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10003AD30(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained refreshProxyInfo:11];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

LABEL_18:
    uint64_t v22 = nplog_obj(v4, v5, v6);
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      if (self)
      {
        uint64_t v24 = self->_probingReason;
        int v25 = @"Unknown";
        if (v24 == 2) {
          int v25 = @"DNS";
        }
        if (v24 == 1) {
          id v26 = @"Proxy";
        }
        else {
          id v26 = (__CFString *)v25;
        }
      }

      else
      {
        id v26 = 0LL;
      }

      id v27 = v26;
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Invalid probing reason: %@", buf, 0xCu);
    }

    goto LABEL_52;
  }

  uint64_t v28 = self->_directPathProber == v4;
  uint64_t v29 = nplog_obj(v4, v5, v6);
  uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
  id v31 = v30;
  if (v28)
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      int v32 = self->_probingReason;
      id v33 = @"Unknown";
      if (v32 == 2) {
        id v33 = @"DNS";
      }
      if (v32 == 1) {
        id v34 = @"Proxy";
      }
      else {
        id v34 = (__CFString *)v33;
      }
      uint64_t v35 = v34;
      uint64_t v36 = v35;
      uint64_t v37 = self->_directPathProber;
      if (v37) {
        uint64_t v37 = (NSPProber *)v37->_probeSuccessCount;
      }
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v35;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "Probing(%@): Direct path probe successful %lu times",  buf,  0x16u);
    }

    uint64_t v38 = self->_directPathProber;
    uint64_t v39 = v38;
    if (!v38 || !v38->_probeFailedCount)
    {
      int v40 = self->_directPathProber;
      uint64_t v41 = v40;
      if (!v40 || !v40->_probeRedirectedCount)
      {
        uint64_t v52 = self->_directPathProber;
        if (v52)
        {
          unsigned __int8 v53 = v52->_probeServerErrorCount == 0;

          if (!v53) {
            goto LABEL_43;
          }
        }

        else
        {
        }

        dispatch_source_t v54 = self->_directPathProber;
        if (v54)
        {
          uint64_t v55 = v54->_probeSuccessCount > 1;

          if (v55)
          {
            id v56 = self->_path;
            uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[NWPath interface](v56, "interface"));
            sub_100036CC8((uint64_t)self, v57, 1LL);

            id v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
            objc_storeStrong((id *)&self->_probeEndTime, v58);

            sub_100027BE8((uint64_t)self);
          }
        }

        goto LABEL_52;
      }
    }

LABEL_43:
    -[NSPProxyPath resetStats](self->_quicProxyPath, "resetStats");
    -[NSPProxyPath resetError](self->_quicProxyPath, "resetError");
    -[NSPProxyPath resetStats](self->_fallbackProxyPath, "resetStats");
    -[NSPProxyPath resetError](self->_fallbackProxyPath, "resetError");
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    objc_storeStrong((id *)&self->_probeEndTime, v42);

    sub_100027BE8((uint64_t)self);
LABEL_52:
    -[NSPPrivacyProxyAgentManager updateUserEventAgentData](self, "updateUserEventAgentData");
    goto LABEL_53;
  }

  if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager probeSuccess:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_FAULT,  "%s called with null (prober == self.directPathProber)",  buf,  0xCu);
  }

LABEL_53:
}

    goto LABEL_19;
  }

      id v26 = nplog_obj(v23, v24, v25);
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = self;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "%@ already checking connectivity for interface %@",  buf,  0x16u);
      }

      if (v9) {
        (*((void (**)(id, void))v9 + 2))(v9, 0LL);
      }
LABEL_29:

      return;
  }
    }
  }
}

  return v12;
}

  return v9;
}

    v15[2](v15, 4LL, 0LL, 0LL, 0LL);
    goto LABEL_6;
  }

  [v11 setAuthType:4];
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 data]);
  [v9 setHTTPBody:v20];

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  id v34 = 0x3032000000LL;
  uint64_t v35 = sub_1000A8328;
  uint64_t v36 = sub_1000A8338;
  uint64_t v37 = 0LL;
  id v27 = _NSConcreteStackBlock;
  uint64_t v28 = 3221225472LL;
  uint64_t v29 = sub_1000A9C54;
  uint64_t v30 = &unk_1000FA940;
  p___int128 buf = &buf;
  id v31 = v15;
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v10 dataTaskWithRequest:v9 completionHandler:&v27]);
  objc_storeStrong((id *)(*((void *)&buf + 1) + 40LL), v21);
  objc_msgSend(*(id *)(*((void *)&buf + 1) + 40), "resume", v27, v28, v29, v30);

  _Block_object_dispose(&buf, 8);
LABEL_6:
}

  return v16;
}
}

void sub_10003B3B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10003B3D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2
    && (!*(void *)(v2 + 264)
     || ((id v3 = objc_loadWeakRetained((id *)(v2 + 80)), v4 = v3, (v5 = *(void *)(a1 + 32)) == 0)
       ? (uint64_t v6 = 0LL)
       : (uint64_t v6 = *(void *)(v5 + 264)),
         [v3 reportPrivacyProxySuccessOnInterface:v6],
         v4,
         (uint64_t v2 = *(void *)(a1 + 32)) != 0)))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }

  else
  {
    id WeakRetained = 0LL;
  }

  [WeakRetained proxyConnectivityActive];

  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;
}

LABEL_14:
    id v19 = nplog_obj(v6, v7, v8);
    id WeakRetained = (id)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled((os_log_t)WeakRetained, OS_LOG_TYPE_ERROR))
    {
      if (self)
      {
        uint64_t v28 = self->_probingReason;
        uint64_t v29 = @"Unknown";
        if (v28 == 2) {
          uint64_t v29 = @"DNS";
        }
        if (v28 == 1) {
          uint64_t v30 = @"Proxy";
        }
        else {
          uint64_t v30 = (__CFString *)v29;
        }
      }

      else
      {
        uint64_t v30 = 0LL;
      }

      id v31 = v30;
      int v32 = 138412290;
      id v33 = (const char *)v31;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)WeakRetained,  OS_LOG_TYPE_ERROR,  "Invalid probing reason: %@",  (uint8_t *)&v32,  0xCu);
    }

    goto LABEL_15;
  }

  directPathProber = self->_directPathProber;
  uint64_t v21 = nplog_obj(v6, v7, v8);
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  uint64_t v23 = v22;
  if (directPathProber == v9)
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v24 = self->_probingReason;
      int v25 = @"Unknown";
      if (v24 == 2) {
        int v25 = @"DNS";
      }
      if (v24 == 1) {
        id v26 = @"Proxy";
      }
      else {
        id v26 = (__CFString *)v25;
      }
      id v27 = v26;
      int v32 = 138412290;
      id v33 = (const char *)v27;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "Probing(%@): Direct path probe received server error",  (uint8_t *)&v32,  0xCu);
    }

    sub_100027BE8((uint64_t)self);
    goto LABEL_25;
  }

  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
  {
    int v32 = 136315138;
    id v33 = "-[NSPPrivacyProxyAgentManager probeServerError:httpStatusCode:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "%s called with null (prober == self.directPathProber)",  (uint8_t *)&v32,  0xCu);
  }

LABEL_26:
}
  }

  if (!self)
  {
    uint64_t v20 = [0 isNetworkOutage];
    uint64_t v21 = [0 isServiceOutage];
    if (v7) {
      goto LABEL_118;
    }
    uint64_t v24 = v21;
    id v26 = 0LL;
    goto LABEL_95;
  }

  uint64_t v20 = -[NSPServiceStatusManager isNetworkOutage](self->_serviceStatusManager, "isNetworkOutage");
  uint64_t v21 = (id)-[NSPServiceStatusManager isServiceOutage](self->_serviceStatusManager, "isServiceOutage");
  uint64_t v24 = v21;
  if (self->_systemIncompatible)
  {
    -[NSPServiceStatusManager reportSystemIncompatibility](self->_serviceStatusManager, "reportSystemIncompatibility");
    int v25 = self->_toggleStats;
    -[NSPToggleStats setSystemIncompatibleCount:]( v25,  "setSystemIncompatibleCount:",  (char *)-[NSPToggleStats systemIncompatibleCount](v25, "systemIncompatibleCount") + 1);
LABEL_19:
    id v26 = 0LL;
LABEL_20:
    id v27 = 1;
LABEL_21:

    goto LABEL_22;
  }

  if (self->_fraudAlert)
  {
    -[NSPServiceStatusManager reportFraudAlert](self->_serviceStatusManager, "reportFraudAlert");
    int v25 = self->_toggleStats;
    -[NSPToggleStats setFraudAlertCount:]( v25,  "setFraudAlertCount:",  (char *)-[NSPToggleStats fraudAlertCount](v25, "fraudAlertCount") + 1);
    goto LABEL_19;
  }

  if (self->_captiveOutage)
  {
    id v46 = self->_lastCaptiveOutageReasonStats;
LABEL_42:
    id v26 = v46;
    -[NSPServiceStatusManager reportServiceOutageWithType:outageReasonStats:]( self->_serviceStatusManager,  "reportServiceOutageWithType:outageReasonStats:",  2LL,  v46);
    int v25 = self->_toggleStats;
    -[NSPToggleStats setNetworkOutageCount:]( v25,  "setNetworkOutageCount:",  (char *)-[NSPToggleStats networkOutageCount](v25, "networkOutageCount") + 1);
    id v27 = 0;
    goto LABEL_21;
  }

  if (self->_proxyOutage)
  {
    id v26 = (NSPOutageReasonStats *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager lastProxyOutageReason]( self->_privacyProxyAgentManager,  "lastProxyOutageReason"));
    -[NSPServiceStatusManager reportServiceOutageWithType:outageReasonStats:]( self->_serviceStatusManager,  "reportServiceOutageWithType:outageReasonStats:",  5LL,  v26);
    int v25 = self->_toggleStats;
    -[NSPToggleStats setProxyOutageCount:]( v25,  "setProxyOutageCount:",  (char *)-[NSPToggleStats proxyOutageCount](v25, "proxyOutageCount") + 1);
    goto LABEL_20;
  }

  if (self->_proxyNetworkOutage)
  {
    id v46 = (NSPOutageReasonStats *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager lastProxyOutageReason]( self->_privacyProxyAgentManager,  "lastProxyOutageReason"));
    goto LABEL_42;
  }

  if (self->_odohOutage || self->_odohAuthOutage)
  {
    uint64_t v50 = sub_1000509A8((id *)&self->_odohManager->super.isa);
    id v26 = (NSPOutageReasonStats *)objc_claimAutoreleasedReturnValue(v50);
    -[NSPServiceStatusManager reportServiceOutageWithType:outageReasonStats:]( self->_serviceStatusManager,  "reportServiceOutageWithType:outageReasonStats:",  4LL,  v26);
    int v25 = self->_toggleStats;
    -[NSPToggleStats setOdohOutageCount:]( v25,  "setOdohOutageCount:",  (char *)-[NSPToggleStats odohOutageCount](v25, "odohOutageCount") + 1);
    goto LABEL_20;
  }

  if (self->_tokenOutage)
  {
    id v26 = (NSPOutageReasonStats *)objc_claimAutoreleasedReturnValue( -[NSPPrivacyProxyAgentManager lastTokenOutageReason]( self->_privacyProxyAgentManager,  "lastTokenOutageReason"));
    -[NSPServiceStatusManager reportServiceOutageWithType:outageReasonStats:]( self->_serviceStatusManager,  "reportServiceOutageWithType:outageReasonStats:",  3LL,  v26);
    int v25 = self->_toggleStats;
    -[NSPToggleStats setTokenOutageCount:]( v25,  "setTokenOutageCount:",  (char *)-[NSPToggleStats tokenOutageCount](v25, "tokenOutageCount") + 1);
    goto LABEL_20;
  }

  if (self->_configOutage)
  {
    id v26 = self->_lastConfigOutageReasonStats;
    id v27 = 1;
    -[NSPServiceStatusManager reportServiceOutageWithType:outageReasonStats:]( self->_serviceStatusManager,  "reportServiceOutageWithType:outageReasonStats:",  1LL,  v26);
    int v25 = self->_toggleStats;
    -[NSPToggleStats setConfigOutageCount:]( v25,  "setConfigOutageCount:",  (char *)-[NSPToggleStats configOutageCount](v25, "configOutageCount") + 1);
    goto LABEL_21;
  }

  id v26 = 0LL;
  if (v7)
  {
LABEL_113:

    goto LABEL_35;
  }

LABEL_19:
        id v1 = recv(*((_DWORD *)WeakRetained + 8), v26, 0x100uLL, 0);
      }

      while (v1 > 0);
    }

    if (v1 < 0)
    {
      uint64_t v13 = __error();
      if (*v13 != 35)
      {
        uint64_t v16 = nplog_obj(v13, v14, v15);
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          id v19 = __error();
          uint64_t v20 = strerror(*v19);
          *(_DWORD *)__str = 136315138;
          *(void *)uint64_t v23 = v20;
          _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "recv %s from kernel event socket failed",  (uint8_t *)__str,  0xCu);
        }

        dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 39));
        id v18 = (void *)*((void *)WeakRetained + 39);
        *((void *)WeakRetained + 39) = 0LL;
      }
    }
  }
}

  unsigned __int8 v53 = objc_claimAutoreleasedReturnValue( +[NSSortDescriptor sortDescriptorWithKey:ascending:]( &OBJC_CLASS___NSSortDescriptor,  "sortDescriptorWithKey:ascending:",  @"date",  0LL));
  if (v53)
  {
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](&OBJC_CLASS___NSArray, "arrayWithObject:"));
    [v54 setSortDescriptors:v17];

    [v54 setFetchLimit:*(void *)(a1 + 56)];
    id v18 = *(void **)(a1 + 40);
    id v60 = 0LL;
    id v19 = objc_claimAutoreleasedReturnValue([v18 executeFetchRequest:v54 error:&v60]);
    oslog = (os_log_s *)v60;
    uint64_t v20 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v21 = *(void **)(v20 + 40);
    *(void *)(v20 + 40) = v19;

    uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) == 0LL;
    id v26 = nplog_obj(v23, v24, v25);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    uint64_t v28 = v27;
    if (v22)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        __int128 v66 = (const char *)oslog;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
      }
    }

    else
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v47 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) count];
        *(_DWORD *)__int128 buf = 134217984;
        __int128 v66 = v47;
        _os_log_debug_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "Found %lu events", buf, 0xCu);
      }

      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) reverseObjectEnumerator]);
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 allObjects]);

      id v58 = 0u;
      int v59 = 0u;
      id v56 = 0u;
      uint64_t v57 = 0u;
      id v31 = v30;
      int v32 = [v31 countByEnumeratingWithState:&v56 objects:v71 count:16];
      uint64_t v35 = v32;
      if (v32)
      {
        uint64_t v36 = *(void *)v57;
        do
        {
          uint64_t v37 = 0LL;
          do
          {
            if (*(void *)v57 != v36) {
              objc_enumerationMutation(v31);
            }
            uint64_t v38 = *(void **)(*((void *)&v56 + 1) + 8LL * (void)v37);
            uint64_t v39 = nplog_obj(v32, v33, v34);
            int v40 = (os_log_s *)objc_claimAutoreleasedReturnValue(v39);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v41 = (char *)objc_claimAutoreleasedReturnValue([v38 date]);
              uint64_t v42 = [v38 eventType];
              uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v38 vendor]);
              *(_DWORD *)__int128 buf = 138412802;
              __int128 v66 = v41;
              id v67 = 1024;
              id v68 = v42;
              __int128 v69 = 2112;
              id v70 = v43;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEBUG,  "Event Date:%@ type:%u vendor:%@",  buf,  0x1Cu);
            }

            uint64_t v37 = (char *)v37 + 1;
          }

          while (v35 != v37);
          int v32 = [v31 countByEnumeratingWithState:&v56 objects:v71 count:16];
          uint64_t v35 = v32;
        }

        while (v32);
      }

      uint64_t v44 = *(void *)(*(void *)(a1 + 48) + 8LL);
      uint64_t v28 = *(os_log_s **)(v44 + 40);
      *(void *)(v44 + 40) = v31;
    }
  }

  else
  {
    uint64_t v50 = nplog_obj(0LL, v16, 0LL);
    oslog = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      __int128 v66 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
      _os_log_fault_impl( (void *)&_mh_execute_header,  oslog,  OS_LOG_TYPE_FAULT,  "%s called with null sortDescriptor",  buf,  0xCu);
    }
  }

  uint64_t v45 = (os_log_s *)v53;
LABEL_32:
}

LABEL_24:
  uint64_t v50 = _os_feature_enabled_impl("NetworkServiceProxy", "TransparencyValidation");
  if (!(_DWORD)v50)
  {
LABEL_28:
    (*((void (**)(id, uint64_t))v9 + 2))(v9, 1LL);
    goto LABEL_38;
  }

  unsigned __int8 v53 = nplog_obj(v50, v51, v52);
  dispatch_source_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_error_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "Keys do not have transparency proof, blocking",  buf,  2u);
  }

  (*((void (**)(id, void))v9 + 2))(v9, 0LL);
LABEL_38:
}

      id v34 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
LABEL_17:
      v34();

      goto LABEL_18;
    }
  }

  id v31 = nplog_obj(v9, v10, v11);
  int v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v36 = 0;
    _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "Failed to fetch device identity certificate",  v36,  2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
LABEL_18:
}

LABEL_15:
    self = v16;
LABEL_16:
    uint64_t v16 = 0LL;
LABEL_17:

    goto LABEL_18;
  }

  uint64_t v28 = bswap32(v12[1]) >> 16;
  uint64_t v29 = v8 - 4;
  if (v8 - 4 < v28 || ((unsigned __int16)(v28 - 257) >> 8) != 255)
  {
    uint64_t v43 = nplog_obj(v22, v23, v24);
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
    if (!os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR))
    {
LABEL_27:

      goto LABEL_15;
    }

    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v115[0]) = v28;
    id v67 = "Invalid issuer name length %u";
    goto LABEL_48;
  }

  uint64_t v30 = v28 + 1;
  id v31 = calloc(1uLL, (v28 + 1));
  if (!v31)
  {
    uint64_t v45 = nplog_obj(0LL, v32, v33);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v115[0]) = v30;
    id v19 = "calloc of %u bytes failed";
    goto LABEL_31;
  }

  id v34 = v31;
  uint64_t v35 = (char *)(v12 + 2);
  memcpy(v31, v35, v28);
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v34));
  objc_setProperty_atomic(v16, v37, v36, 24LL);

  free(v34);
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge issuerName](v16, "issuerName"));

  if (!v38)
  {
    uint64_t v47 = nplog_obj(v39, v40, v41);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)__int128 buf = 0;
    id v19 = "Invalid origin name";
    goto LABEL_8;
  }

  if (v29 == v28)
  {
    uint64_t v42 = nplog_obj(v39, v40, v41);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      id v19 = "Invalid challenge length";
      goto LABEL_8;
    }

    goto LABEL_14;
  }

  uint64_t v48 = &v35[v28];
  uint64_t v49 = &v35[v28];
  uint64_t v52 = *v49;
  uint64_t v50 = (unsigned __int16 *)(v49 + 1);
  uint64_t v51 = v52;
  unsigned __int8 v53 = v29 + ~v28;
  dispatch_source_t v54 = v53 - v52;
  if (v53 < v52)
  {
    uint64_t v55 = nplog_obj(v39, v40, v41);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v55);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 67109376;
    LODWORD(v115[0]) = v51;
    WORD2(v115[0]) = 2048;
    *(void *)((char *)v115 + 6) = v53;
    id v19 = "Invalid nonce length %u, cannot fit in %zu";
    uint64_t v20 = v18;
    uint64_t v21 = 18;
    goto LABEL_32;
  }

  if ((_DWORD)v51)
  {
    if ((_DWORD)v51 != 32)
    {
      id v70 = nplog_obj(v39, v40, v41);
      id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v115[0]) = v51;
      id v19 = "Invalid nonce length %u";
      goto LABEL_31;
    }

    id v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v50, v51));
    objc_setProperty_atomic(v16, v57, v56, 32LL);

    id v58 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge redemptionNonce](v16, "redemptionNonce"));
    if (!v58)
    {
      id v76 = nplog_obj(v59, v60, v61);
      id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v76);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      *(_WORD *)__int128 buf = 0;
      id v19 = "Invalid nonce";
      goto LABEL_8;
    }

    uint64_t v50 = (unsigned __int16 *)(v48 + 33);
    unsigned __int8 v53 = v54;
  }

  id v62 = -[NSPPrivateAccessTokenChallenge typeRequiresRedemptionNonce](v16, "typeRequiresRedemptionNonce");
  if (v62)
  {
    __int128 v65 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge redemptionNonce](v16, "redemptionNonce"));

    if (!v65)
    {
      uint64_t v78 = nplog_obj(v62, v63, v64);
      id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      *(_WORD *)__int128 buf = 0;
      id v19 = "Redemption nonce is required";
      goto LABEL_8;
    }
  }

  if (v53 <= 1)
  {
    __int128 v66 = nplog_obj(v62, v63, v64);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)__int128 buf = 0;
    id v19 = "Invalid challenge length";
    goto LABEL_8;
  }

  id v73 = *v50;
  id v72 = v50 + 1;
  id v71 = v73;
  id v74 = __rev16(v73);
  if (v53 - 2 < v74)
  {
    id v75 = nplog_obj(v62, v63, v64);
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v75);
    if (!os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 67109376;
    LODWORD(v115[0]) = v74;
    WORD2(v115[0]) = 2048;
    *(void *)((char *)v115 + 6) = v53 - 2;
    id v67 = "Invalid origin info length %u, cannot fit in %zu";
    id v68 = (os_log_s *)v44;
    __int128 v69 = 18;
    goto LABEL_49;
  }

  if (v74 >= 0xA01)
  {
    uint64_t v77 = nplog_obj(v62, v63, v64);
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v77);
    if (!os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v115[0]) = v74;
    id v67 = "Invalid origin info length %u";
LABEL_48:
    id v68 = (os_log_s *)v44;
    __int128 v69 = 8;
LABEL_49:
    _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, v67, buf, v69);
    goto LABEL_27;
  }

  if (v71)
  {
    id v85 = v74 + 1;
    id v86 = calloc(1uLL, (v74 + 1));
    if (v86)
    {
      unsigned int v89 = v86;
      memcpy(v86, v72, v74);
      id v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v89));
      objc_setProperty_atomic(v16, v91, v90, 56LL);

      free(v89);
      uint64_t v93 = objc_msgSend(objc_getProperty(v16, v92, 56, 1), "componentsSeparatedByString:", @",");
      uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(v93);
      objc_setProperty_atomic(v16, v95, v94, 48LL);

      id v96 = (void *)objc_claimAutoreleasedReturnValue(-[NSPPrivateAccessTokenChallenge originNames](v16, "originNames"));
      id v97 = (void *)objc_claimAutoreleasedReturnValue([v96 firstObject]);
      objc_setProperty_atomic(v16, v98, v97, 40LL);

      goto LABEL_73;
    }

    id v111 = nplog_obj(0LL, v87, v88);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v111);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v115[0]) = v85;
    id v19 = "calloc of %u bytes failed";
LABEL_31:
    uint64_t v20 = v18;
    uint64_t v21 = 8;
    goto LABEL_32;
  }

void sub_10003C934( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10003C954(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    [v2 timeIntervalSinceReferenceDate];
    int64_t v4 = (uint64_t)v3;
  }

  else
  {
    int64_t v4 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "TokenFetchDate", v4);
  if (*(_BYTE *)(a1 + 48)) {
    int64_t v5 = 1LL;
  }
  else {
    int64_t v5 = -1LL;
  }
  xpc_dictionary_set_int64(xdict, "TokenFetchOnNetworkChange", v5);
  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", xdict);
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0LL;
}

void sub_10003CAC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10003CADC(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (double v3 = *(id *)(v2 + 240)) != 0LL && (v4 = v3[10], v3, v4))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      uint64_t v6 = *(id *)(v5 + 240);
      id v7 = v6;
      if (v6) {
        uint64_t v6 = (void *)v6[10];
      }
    }

    else
    {
      id v7 = 0LL;
      uint64_t v6 = 0LL;
    }

    [v6 timeIntervalSinceReferenceDate];
    xpc_dictionary_set_int64(xdict, "ProxyPathProber", (uint64_t)v8);
  }

  else
  {
    xpc_dictionary_set_int64(xdict, "ProxyPathProber", -1LL);
  }

  uint64_t v9 = *(void *)(a1 + 32);
  else {
    int64_t v12 = -1LL;
  }
  xpc_dictionary_set_int64(xdict, "ProxyPathProbeOnNetworkChange", v12);
  uint64_t v13 = *(void *)(a1 + 32);
  if (v13 && (v14 = *(id *)(v13 + 248)) != 0LL && (uint64_t v15 = v14[10], v14, v15))
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (v16)
    {
      uint64_t v17 = *(id *)(v16 + 248);
      id v18 = v17;
      if (v17) {
        uint64_t v17 = (void *)v17[10];
      }
    }

    else
    {
      id v18 = 0LL;
      uint64_t v17 = 0LL;
    }

    [v17 timeIntervalSinceReferenceDate];
    xpc_dictionary_set_int64(xdict, "DirectPathProber", (uint64_t)v19);
  }

  else
  {
    xpc_dictionary_set_int64(xdict, "DirectPathProber", -1LL);
  }

  uint64_t v20 = *(void *)(a1 + 32);
  if (v20
    && (uint64_t v21 = (unsigned __int8 *)*(id *)(v20 + 248)) != 0LL
    && (int v22 = v21[9], v21, v22))
  {
    int64_t v23 = 1LL;
  }

  else
  {
    int64_t v23 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "DirectPathProbeOnNetworkChange", v23);
  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", xdict);
  uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8LL);
  int v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = 0LL;
}

void sub_10003CE2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    id v17 = v3;
    uint64_t count = nw_array_get_count(v3);
    uint64_t v4 = v17;
    if (count)
    {
      uint64_t object_at_index = nw_array_get_object_at_index(v17, 0LL);
      id v7 = (nw_endpoint *)objc_claimAutoreleasedReturnValue(object_at_index);
      address = nw_endpoint_get_address(v7);
      uint64_t v9 = nw_endpoint_copy_address_string(v7);
      if (!v9)
      {
LABEL_12:

        uint64_t v4 = v17;
        goto LABEL_13;
      }

      uint64_t v10 = v9;
      int sa_family = address->sa_family;
      if (sa_family == 30)
      {
        int64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities createMaskedIPv6Address:prefix:]( &OBJC_CLASS___NPUtilities,  "createMaskedIPv6Address:prefix:",  v12,  56LL));
      }

      else
      {
        if (sa_family != 2)
        {
LABEL_9:
          uint64_t v15 = *(void *)(a1 + 32);
          if (v15) {
            uint64_t v16 = *(void *)(v15 + 536);
          }
          else {
            uint64_t v16 = 0LL;
          }
          [*(id *)(a1 + 40) setTokenServerAddress:v16];
          [*(id *)(a1 + 40) sendAnalytics];
          free(v10);
          goto LABEL_12;
        }

        int64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities createMaskedIPv4Address:prefix:]( &OBJC_CLASS___NPUtilities,  "createMaskedIPv4Address:prefix:",  v12,  24LL));
      }

      uint64_t v14 = v13;
      sub_100027E08(*(void *)(a1 + 32), v13);

      goto LABEL_9;
    }
  }

id sub_10003D960()
{
  if (qword_1001170C8 != -1) {
    dispatch_once(&qword_1001170C8, &stru_1000F9CD0);
  }
  return (id)qword_1001170C0;
}

uint64_t sub_10003D9A0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = sub_10003D960();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  id v8 = (id)objc_claimAutoreleasedReturnValue([v7 arrayForKey:@"AppleLanguages"]);

  if (v8
    || (os_unfair_lock_lock((os_unfair_lock_t)&unk_1001170B8),
        id v8 = [0 copy],
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001170B8),
        v8))
  {
    id v9 = sub_10003D960();
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    int v11 = (void *)objc_claimAutoreleasedReturnValue([v10 localizations]);
    int64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle preferredLocalizationsFromArray:forPreferences:]( &OBJC_CLASS___NSBundle,  "preferredLocalizationsFromArray:forPreferences:",  v11,  v8));
  }

  else
  {
    int64_t v12 = 0LL;
  }

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v6 localizations]);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle preferredLocalizationsFromArray:forPreferences:]( &OBJC_CLASS___NSBundle,  "preferredLocalizationsFromArray:forPreferences:",  v13,  v12));

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 firstObject]);
  if (qword_1001170D0 != -1) {
    dispatch_once(&qword_1001170D0, &stru_1000F9CF0);
  }
  uint64_t v16 = CFBundleCopyLocalizedStringForLocalization(qword_1001170D8, v4, v3, 0LL, v15);

  return v16;
}

uint64_t sub_10003DB38(void *a1)
{
  id v1 = a1;
  if (!qword_1001170E0)
  {
    unsigned __int8 v14 = 0;
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    unsigned int v3 = [v2 fileExistsAtPath:@"/System/Library/PrivateFrameworks/UIKitCore.framework" isDirectory:&v14];
    int v4 = v14;

    if (v3 && v4 != 0)
    {
      uint64_t v6 = objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithPath:]( &OBJC_CLASS___NSBundle,  "bundleWithPath:",  @"/System/Library/PrivateFrameworks/UIKitCore.framework"));
      id v7 = (void *)qword_1001170E0;
      qword_1001170E0 = v6;

      if (qword_1001170E0)
      {
        [(id)qword_1001170E0 load];
        qword_1001170E8 = (uint64_t)[(id)qword_1001170E0 classNamed:@"UIDevice"];
        uint64_t v10 = nplog_obj(qword_1001170E8, v8, v9);
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136315650;
          uint64_t v16 = "NSPResourcesGetUIDeviceClass";
          __int16 v17 = 2112;
          uint64_t v18 = qword_1001170E0;
          __int16 v19 = 2112;
          uint64_t v20 = qword_1001170E8;
          _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "%s: bundle %@ class %@", buf, 0x20u);
        }
      }
    }
  }

  uint64_t v12 = objc_claimAutoreleasedReturnValue([(id) qword_1001170E8 modelSpecificLocalizedStringKeyForKey:v1]);

  return v12;
}

uint64_t sub_10003DCCC(void *a1)
{
  id v1 = a1;
  id v2 = sub_10003D960();
  unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 URLForResource:v1 withExtension:@"png"]);

  return v4;
}

void sub_10003DD24(id a1)
{
  id v1 = -[NSBundle initWithPath:]( objc_alloc(&OBJC_CLASS___NSBundle),  "initWithPath:",  @"/System/Library/PrivateFrameworks/NetworkServiceProxy.framework");
  id v2 = (void *)qword_1001170C0;
  qword_1001170C0 = (uint64_t)v1;
}

void sub_10003DD58(id a1)
{
  id v1 = CFURLCreateFromFileSystemRepresentation( kCFAllocatorDefault,  (const UInt8 *)"/System/Library/PrivateFrameworks/NetworkServiceProxy.framework",  63LL,  0);
  qword_1001170D8 = (uint64_t)CFBundleCreate(kCFAllocatorDefault, v1);
  CFRelease(v1);
}

void sub_10003E570(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    unsigned int v3 = -[NSPEventsPredictor initWithMLModel:](objc_alloc(&OBJC_CLASS___NSPEventsPredictor), "initWithMLModel:", v4);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
}

id *sub_10003EA30(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v7.receiver = a1;
    v7.super_class = (Class)&OBJC_CLASS___NSPToken;
    id v5 = (id *)objc_msgSendSuper2(&v7, "init");
    a1 = v5;
    if (v5) {
      objc_storeStrong(v5 + 3, a2);
    }
  }

  return a1;
}

void sub_10003ED60(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 16), a2);
  }
}

id sub_10003F07C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  if (v3) {
    id Property = objc_getProperty(v3, v4, 56LL, 1);
  }
  else {
    id Property = 0LL;
  }
  id v6 = Property;

  uint64_t v7 = objc_claimAutoreleasedReturnValue([v3 issuerName]);
  uint64_t v9 = (void *)v7;
  if (v6)
  {
    if (v3) {
      id v10 = objc_getProperty(v3, v8, 56LL, 1);
    }
    else {
      id v10 = 0LL;
    }
    id v11 = v10;
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@-%@", v9, v11));
  }

  else
  {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v7));
  }

  return v12;
}

id sub_10003F16C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = +[NPUtilities copyDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "copyDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens",  v3);

  if (v4)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSArray);
    uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSData);
    uint64_t v7 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  v6,  objc_opt_class(&OBJC_CLASS___NSPToken),  0LL);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    id v18 = 0LL;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v8,  v4,  &v18));
    id v10 = v18;

    if (!v9 || v10)
    {
      uint64_t v15 = nplog_obj(v11, v12, v13);
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v20 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "unarchivedObjectOfClass for token array failed with error: %@",  buf,  0xCu);
      }

      id v14 = 0LL;
    }

    else
    {
      id v14 = v9;
    }
  }

  else
  {
    id v14 = 0LL;
  }

  return v14;
}

id sub_10003F308(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = +[NPUtilities copyDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "copyDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens",  v3);

  if (v4)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSArray);
    uint64_t v6 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  objc_opt_class(&OBJC_CLASS___NSPToken),  0LL);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    id v17 = 0LL;
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v7,  v4,  &v17));
    id v9 = v17;

    if (!v8 || v9)
    {
      uint64_t v14 = nplog_obj(v10, v11, v12);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v19 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "unarchivedObjectOfClass for token array failed with error: %@",  buf,  0xCu);
      }

      id v13 = 0LL;
    }

    else
    {
      id v13 = v8;
    }
  }

  else
  {
    id v13 = 0LL;
  }

  return v13;
}

void sub_10003F488(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  id v16 = 0LL;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v5,  1LL,  &v16));
  id v8 = v16;
  uint64_t v11 = nplog_obj(v8, v9, v10);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  id v13 = v12;
  if (v7) {
    BOOL v14 = v8 == 0LL;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      id v15 = [v5 count];
      *(_DWORD *)__int128 buf = 134218242;
      id v18 = v15;
      __int16 v19 = 2112;
      id v20 = v6;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Saving %lu private access tokens for %@ in the keychain",  buf,  0x16u);
    }

    +[NPUtilities saveDataToKeychain:withIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "saveDataToKeychain:withIdentifier:accountName:",  v7,  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens",  v6);
  }

  else
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v18 = v8;
      _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for token array failed with error: %@",  buf,  0xCu);
    }
  }
}

void sub_10003F620(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  id v33 = 0LL;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v5,  1LL,  &v33));
  id v8 = v33;
  uint64_t v11 = v8;
  if (v7) {
    BOOL v12 = v8 == 0LL;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v15 = v5;
    id v16 = [v15 countByEnumeratingWithState:&v29 objects:v36 count:16];
    if (v16)
    {
      id v17 = v16;
      int v18 = 0;
      uint64_t v19 = *(void *)v30;
      do
      {
        id v20 = 0LL;
        do
        {
          if (*(void *)v30 != v19) {
            objc_enumerationMutation(v15);
          }
          uint64_t v21 = *(void *)(*((void *)&v29 + 1) + 8LL * (void)v20);
          if (v21) {
            int v22 = *(void **)(v21 + 8);
          }
          else {
            int v22 = 0LL;
          }
          v18 += objc_msgSend(v22, "count", (void)v29);
          id v20 = (char *)v20 + 1;
        }

        while (v17 != v20);
        id v23 = [v15 countByEnumeratingWithState:&v29 objects:v36 count:16];
        id v17 = v23;
      }

      while (v23);
    }

    else
    {
      int v18 = 0;
    }

    uint64_t v27 = nplog_obj(v24, v25, v26);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 67109378;
      LODWORD(v35[0]) = v18;
      WORD2(v35[0]) = 2112;
      *(void *)((char *)v35 + 6) = v6;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "Saving %u private access tokens for %@ in the keychain",  buf,  0x12u);
    }

    +[NPUtilities saveDataToKeychain:withIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "saveDataToKeychain:withIdentifier:accountName:",  v7,  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens",  v6);
  }

  else
  {
    uint64_t v13 = nplog_obj(v8, v9, v10);
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v35[0] = v11;
      _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for token array failed with error: %@",  buf,  0xCu);
    }
  }
}

void sub_10003F878(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  uint64_t v7 = nplog_obj(v4, v5, v6);
  id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v9 = 138412290;
    id v10 = v3;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Clearing private access tokens for %@ in the keychain",  (uint8_t *)&v9,  0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens",  v3);
}

void sub_10003F948(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  uint64_t v7 = nplog_obj(v4, v5, v6);
  id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v9 = 138412290;
    id v10 = v3;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Clearing long lived tokens for %@ in the keychain",  (uint8_t *)&v9,  0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens",  v3);
}

void sub_10003FA18(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  uint64_t v7 = nplog_obj(v4, v5, v6);
  id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v9 = 138412290;
    id v10 = v3;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Clearing one-time tokens for %@ in the keychain",  (uint8_t *)&v9,  0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens",  v3);
}

id sub_10003FAE8(uint64_t a1, void *a2, void *a3, _DWORD *a4)
{
  id v7 = a2;
  id v8 = a3;
  uint64_t v9 = objc_opt_self(a1);
  if (v7)
  {
    uint64_t v12 = v9;
    id v13 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v7);
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    id v15 = sub_10003F16C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v14);
    if (![v15 count])
    {
      id v20 = 0LL;
LABEL_30:

      goto LABEL_31;
    }

    id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v15));
    sub_10003FE50(v12, v16);
    if (![v16 count])
    {
      sub_10003F488((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v16, v14);
      id v20 = 0LL;
LABEL_29:

      goto LABEL_30;
    }

    id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 firstObject]);
    uint64_t v18 = objc_opt_class(&OBJC_CLASS___NSData);
    if ((objc_opt_isKindOfClass(v17, v18) & 1) != 0)
    {
      uint64_t v19 = v17;
    }

    else
    {
      uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSPToken);
      if ((objc_opt_isKindOfClass(v17, v21) & 1) == 0)
      {
        id v23 = 0LL;
        goto LABEL_19;
      }

      if (v17) {
        int v22 = (void *)v17[1];
      }
      else {
        int v22 = 0LL;
      }
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v22 firstObject]);
    }

    id v23 = v19;
    if (v19)
    {
      if (v8)
      {
        BOOL v24 = sub_1000AB9F4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v19, v8);
        if (!v24)
        {
          uint64_t v38 = nplog_obj(v24, v25, v26);
          __int128 v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            int v41 = 138412290;
            uint64_t v42 = (const char *)v14;
            __int128 v32 = "Cached token from keychain for %@ has non-matching key, flushing tokens";
            goto LABEL_26;
          }

void sub_10003FE50(uint64_t a1, void *a2)
{
  id v4 = a2;
  objc_opt_self(a1);
  uint64_t v36 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  id v5 = v4;
  id v6 = [v5 countByEnumeratingWithState:&v41 objects:v46 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v42;
    uint64_t v9 = &OBJC_IVAR___NSPProxyTokenInfo__tokenConsumedCount;
    uint64_t v34 = *(void *)v42;
    do
    {
      uint64_t v10 = 0LL;
      id v35 = v7;
      do
      {
        if (*(void *)v42 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v11 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)v10);
        uint64_t v12 = objc_opt_class(v9 + 1002);
        if ((objc_opt_isKindOfClass(v11, v12) & 1) != 0)
        {
          id v13 = v11;
          BOOL v14 = v13;
          if (v13)
          {
            id v15 = v13[3];
            BOOL v16 = v15 != 0LL;
            if (!v15 || (id v2 = v14[3], [v2 timeIntervalSinceNow], v17 > 0.0))
            {
              id v18 = v14[2];
              goto LABEL_11;
            }

LABEL_24:
            -[NSMutableArray addObject:](v36, "addObject:", v14);
          }

          else
          {
            id v15 = 0LL;
            BOOL v16 = 0;
            id v18 = 0LL;
LABEL_11:
            id v19 = v18;
            if ([v19 count])
            {
              if (v14) {
                id v20 = v14[2];
              }
              else {
                id v20 = 0LL;
              }
              id v21 = v5;
              id v22 = v20;
              id v23 = [v22 count];
              BOOL v24 = v2;
              if (v14) {
                id v25 = v14[1];
              }
              else {
                id v25 = 0LL;
              }
              id v26 = [v25 count];

              if (v16)
              {

                BOOL v27 = v23 >= v26;
                id v2 = v24;
                uint64_t v8 = v34;
                uint64_t v9 = &OBJC_IVAR___NSPProxyTokenInfo__tokenConsumedCount;
              }

              else
              {

                BOOL v27 = v23 >= v26;
                uint64_t v8 = v34;
                uint64_t v9 = &OBJC_IVAR___NSPProxyTokenInfo__tokenConsumedCount;
                id v2 = v24;
              }

              id v5 = v21;
              id v7 = v35;
              if (!v27) {
                goto LABEL_24;
              }
            }

            else
            {

              if (v16) {
            }
              }
          }
        }

        uint64_t v10 = (char *)v10 + 1;
      }

      while (v7 != v10);
      id v28 = [v5 countByEnumeratingWithState:&v41 objects:v46 count:16];
      id v7 = v28;
    }

    while (v28);
  }

  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  uint64_t v29 = v36;
  id v30 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v37,  v45,  16LL);
  if (v30)
  {
    id v31 = v30;
    uint64_t v32 = *(void *)v38;
    do
    {
      for (i = 0LL; i != v31; i = (char *)i + 1)
      {
        if (*(void *)v38 != v32) {
          objc_enumerationMutation(v29);
        }
        [v5 removeObject:*(void *)(*((void *)&v37 + 1) + 8 * (void)i)];
      }

      id v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v37,  v45,  16LL);
    }

    while (v31);
  }
}

void sub_10004013C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v23 = a3;
  id v7 = a4;
  id v8 = a2;
  uint64_t v9 = objc_opt_self(a1);
  id v10 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v8);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

  id v12 = sub_10003F16C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v11);
  if (![v12 count])
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    if (v7) {
      goto LABEL_3;
    }
LABEL_7:
    [v13 addObject:v23];
    goto LABEL_8;
  }

  id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v12));
  sub_10003FE50(v9, v13);
  if (!v7) {
    goto LABEL_7;
  }
LABEL_3:
  BOOL v14 = sub_10003EA30((id *)objc_alloc(&OBJC_CLASS___NSPToken), v7);
  id v15 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  sub_100011668((uint64_t)v14, v15);

  if (v14) {
    id v16 = v14[1];
  }
  else {
    id v16 = 0LL;
  }
  [v16 addObject:v23];
  [v13 addObject:v14];

LABEL_8:
  objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenCache);
  id v17 = +[NPUtilities totalDataInKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "totalDataInKeychainWithIdentifier:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens");
  uint64_t v20 = nplog_obj(v17, v18, v19);
  id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  id v22 = v21;
  if ((unint64_t)v17 < 0x186A1)
  {
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134217984;
      id v25 = v17;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "Keychain tokens total %zu bytes, not flushing keychain",  buf,  0xCu);
    }
  }

  else
  {
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      id v25 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Keychain tokens total %zu bytes, flushing keychain",  buf,  0xCu);
    }

    +[NPUtilities removeDataFromKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens");
  }

  sub_10003F488((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v13, v11);
}

id sub_1000403AC(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  objc_opt_self(a1);
  if (a3) {
    id v6 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    id v6 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  id v7 = +[NPUtilities copyDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "copyDataFromKeychainWithIdentifier:accountName:",  v6,  v5);

  if (v7)
  {
    uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSArray);
    uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
    id v10 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v8,  v9,  objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo),  0LL);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    id v21 = 0LL;
    id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v11,  v7,  &v21));
    id v13 = v21;

    if (!v12 || v13)
    {
      uint64_t v18 = nplog_obj(v14, v15, v16);
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v23 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "unarchivedObjectOfClass for auxiliary auth info array failed with error: %@",  buf,  0xCu);
      }

      id v17 = 0LL;
    }

    else
    {
      id v17 = v12;
    }
  }

  else
  {
    id v17 = 0LL;
  }

  return v17;
}

NSMutableArray *sub_10004055C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = objc_opt_self(a1);
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  id v7 = sub_1000403AC(v6, v5, a3);
  id v8 = [v7 countByEnumeratingWithState:&v42 objects:v47 count:16];
  if (!v8) {
    goto LABEL_9;
  }
  id v9 = v8;
  uint64_t v10 = *(void *)v43;
  do
  {
    uint64_t v11 = 0LL;
    do
    {
      if (*(void *)v43 != v10) {
        objc_enumerationMutation(v7);
      }
      uint64_t v12 = *(void *)(*((void *)&v42 + 1) + 8LL * (void)v11);
      uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
      if ((objc_opt_isKindOfClass(v12, v13) & 1) == 0)
      {
        id v37 = v5;

        uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v41 = 0u;
        id v36 = v7;
        id v15 = v7;
        id v16 = [v15 countByEnumeratingWithState:&v38 objects:v46 count:16];
        if (!v16) {
          goto LABEL_28;
        }
        id v17 = v16;
        uint64_t v18 = *(void *)v39;
        while (1)
        {
          uint64_t v19 = 0LL;
          do
          {
            if (*(void *)v39 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v20 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)v19);
            uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
            if ((objc_opt_isKindOfClass(v20, v21) & 1) != 0)
            {
              -[NSMutableArray addObject:](v14, "addObject:", v20);
              goto LABEL_26;
            }

            uint64_t v22 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
            if ((objc_opt_isKindOfClass(v20, v22) & 1) != 0)
            {
              id v23 = v20;
              id v25 = v23;
              if (!v23) {
                goto LABEL_25;
              }
              id v26 = objc_getProperty(v23, v24, 8LL, 1);
              if (!v26) {
                goto LABEL_25;
              }
              id v28 = v26;
              id v29 = objc_getProperty(v25, v27, 16LL, 1);
              if (v29)
              {
                id v31 = v29;
                objc_msgSend(objc_getProperty(v25, v30, 16, 1), "timeIntervalSinceNow");
                double v33 = v32;

                if (v33 <= 0.0) {
                  goto LABEL_25;
                }
              }

              else
              {
              }

              -[NSMutableArray addObject:](v14, "addObject:", objc_getProperty(v25, v34, 8LL, 1));
LABEL_25:
            }

void sub_100040830(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = objc_opt_self(a1);
  uint64_t v9 = nplog_obj(v6, v7, v8);
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 138412290;
    id v13 = v5;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Clearing auxiliary auth info for %@ in the keychain",  (uint8_t *)&v12,  0xCu);
  }

  if (a3) {
    uint64_t v11 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    uint64_t v11 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  +[NPUtilities removeDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:accountName:",  v11,  v5);
}

void sub_10004091C(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7 = a2;
  id v8 = a3;
  objc_opt_self(a1);
  id v39 = 0LL;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v7,  1LL,  &v39));
  uint64_t v10 = (char *)v39;
  id v13 = v10;
  if (v9) {
    BOOL v14 = v10 == 0LL;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    uint64_t v15 = nplog_obj(v10, v11, v12);
    id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v41 = v13;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for auxiliary auth info array failed with error: %@",  buf,  0xCu);
    }

    goto LABEL_29;
  }

  uint64_t v34 = v10;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  id v17 = v7;
  id v18 = [v17 countByEnumeratingWithState:&v35 objects:v44 count:16];
  if (!v18)
  {
    uint64_t v20 = 0LL;
    goto LABEL_23;
  }

  id v19 = v18;
  uint64_t v20 = 0LL;
  uint64_t v21 = *(void *)v36;
  do
  {
    for (i = 0LL; i != v19; i = (char *)i + 1)
    {
      if (*(void *)v36 != v21) {
        objc_enumerationMutation(v17);
      }
      id Property = *(id *)(*((void *)&v35 + 1) + 8LL * (void)i);
      uint64_t v24 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
      if ((objc_opt_isKindOfClass(Property, v24) & 1) != 0) {
        goto LABEL_17;
      }
      uint64_t v25 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
      if ((objc_opt_isKindOfClass(Property, v25) & 1) != 0)
      {
        if (Property) {
          id Property = objc_getProperty(Property, v26, 8LL, 1);
        }
LABEL_17:
        id v27 = Property;
        goto LABEL_19;
      }

      id v27 = 0LL;
LABEL_19:
      uint64_t v20 = &v20[(void)[v27 contentListsCount]];
    }

    id v19 = [v17 countByEnumeratingWithState:&v35 objects:v44 count:16];
  }

  while (v19);
LABEL_23:

  uint64_t v31 = nplog_obj(v28, v29, v30);
  double v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134218242;
    __int128 v41 = v20;
    __int16 v42 = 2112;
    id v43 = v8;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Saving %lu auxiliary auth info entries for %@ in the keychain",  buf,  0x16u);
  }

  if (a4) {
    double v33 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    double v33 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  +[NPUtilities saveDataToKeychain:withIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "saveDataToKeychain:withIdentifier:accountName:",  v9,  v33,  v8);
  id v13 = v34;
LABEL_29:
}

void sub_100040BF0(uint64_t a1, int a2)
{
  id v3 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  if (a2) {
    id v3 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  id v4 = v3;
  id v5 = +[NPUtilities totalDataInKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "totalDataInKeychainWithIdentifier:",  v4);
  uint64_t v8 = nplog_obj(v5, v6, v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if ((unint64_t)v5 < 0x186A1)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 134217984;
      id v12 = v5;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Keychain auxiliary auth data total %zu bytes, not flushing keychain",  (uint8_t *)&v11,  0xCu);
    }
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134217984;
      id v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Keychain auxiliary auth data total %zu bytes, flushing keychain",  (uint8_t *)&v11,  0xCu);
    }

    +[NPUtilities removeDataFromKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:",  v4);
  }
}

void sub_100040D3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v29 objects:v34 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v30;
    do
    {
      uint64_t v9 = 0LL;
      do
      {
        if (*(void *)v30 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void **)(*((void *)&v29 + 1) + 8LL * (void)v9);
        uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
        if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0)
        {
          id v12 = v10;
          BOOL v14 = v12;
          if (v12)
          {
            id v15 = objc_getProperty(v12, v13, 16LL, 1);
            if (v15)
            {
              id v17 = v15;
              objc_msgSend(objc_getProperty(v14, v16, 16, 1), "timeIntervalSinceNow");
              double v19 = v18;

              if (v19 <= 0.0) {
                -[NSMutableArray addObject:](v4, "addObject:", v14);
              }
            }
          }
        }

        uint64_t v9 = (char *)v9 + 1;
      }

      while (v7 != v9);
      id v7 = [v5 countByEnumeratingWithState:&v29 objects:v34 count:16];
    }

    while (v7);
  }

  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  uint64_t v20 = v4;
  id v21 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v20,  "countByEnumeratingWithState:objects:count:",  &v25,  v33,  16LL);
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = *(void *)v26;
    do
    {
      uint64_t v24 = 0LL;
      do
      {
        if (*(void *)v26 != v23) {
          objc_enumerationMutation(v20);
        }
        objc_msgSend(v5, "removeObject:", *(void *)(*((void *)&v25 + 1) + 8 * (void)v24), (void)v25);
        uint64_t v24 = (char *)v24 + 1;
      }

      while (v22 != v24);
      id v22 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v20,  "countByEnumeratingWithState:objects:count:",  &v25,  v33,  16LL);
    }

    while (v22);
  }
}

void sub_100040F68(uint64_t a1, void *a2, unsigned int a3, void *a4, void *a5, void *a6, int a7)
{
  id v43 = a2;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  uint64_t v15 = objc_opt_self(a1);
  id v16 = sub_1000403AC((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v12, a7);
  id v17 = [v16 mutableCopy];

  sub_100040D3C(v15, v17);
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  id v18 = v17;
  id v19 = [v18 countByEnumeratingWithState:&v45 objects:v50 count:16];
  if (v19)
  {
    id v20 = v19;
    id v40 = v12;
    int v41 = a7;
    char v42 = 0;
    uint64_t v21 = *(void *)v46;
    while (1)
    {
      id v22 = 0LL;
      do
      {
        if (*(void *)v46 != v21) {
          objc_enumerationMutation(v18);
        }
        uint64_t v23 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)v22);
        uint64_t v24 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
        if ((objc_opt_isKindOfClass(v23, v24) & 1) != 0)
        {
          if (v14)
          {
            id v25 = 0LL;
            goto LABEL_24;
          }

          id v25 = v23;
        }

        else
        {
          uint64_t v26 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
          if ((objc_opt_isKindOfClass(v23, v26) & 1) != 0)
          {
            if (v23)
            {
              id v28 = objc_getProperty(v23, v27, 16LL, 1);
              id Property = objc_getProperty(v23, v29, 8LL, 1);
            }

            else
            {
              id v28 = 0LL;
              id Property = 0LL;
            }

            id v25 = Property;
            if (v14)
            {
              if (!v28 || ([v28 isEqual:v14] & 1) == 0)
              {
LABEL_23:

                goto LABEL_24;
              }
            }

            else if (v28)
            {
              goto LABEL_23;
            }
          }

          else
          {
            id v25 = 0LL;
          }
        }

        id v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "label", v40));
        unsigned int v31 = [v25 authType];

        if (v31 == a3)
        {
          [v25 addContentList:v43];
          char v42 = 1;
        }

id sub_100041334(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v45 = a4;
  uint64_t v10 = objc_opt_self(a1);
  id v11 = sub_1000403AC((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v9, a5);
  id v12 = [v11 mutableCopy];

  sub_100040D3C(v10, v12);
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  id v13 = (NSMutableArray *)v12;
  id v14 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v50,  v55,  16LL);
  if (!v14) {
    goto LABEL_19;
  }
  id v15 = v14;
  uint64_t v16 = *(void *)v51;
  do
  {
    for (i = 0LL; i != v15; i = (char *)i + 1)
    {
      if (*(void *)v51 != v16) {
        objc_enumerationMutation(v13);
      }
      id Property = *(id *)(*((void *)&v50 + 1) + 8LL * (void)i);
      uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
      if ((objc_opt_isKindOfClass(Property, v19) & 1) != 0) {
        goto LABEL_10;
      }
      uint64_t v20 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
      if ((objc_opt_isKindOfClass(Property, v20) & 1) != 0)
      {
        if (Property) {
          id Property = objc_getProperty(Property, v21, 8LL, 1);
        }
LABEL_10:
        id v22 = Property;
        goto LABEL_12;
      }

      id v22 = 0LL;
LABEL_12:
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 label]);
      if ([v23 isEqualToString:v45])
      {
        unsigned int v24 = [v22 authType];

        if (v24 == a2)
        {
          id v25 = (void *)objc_claimAutoreleasedReturnValue([v22 contentLists]);
          id v26 = [v25 count];

          if (v26)
          {
            __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v22 contentLists]);
            id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 firstObject]);

            SEL v29 = (void *)objc_claimAutoreleasedReturnValue([v22 contentLists]);
            [v29 removeObjectAtIndex:0];

            goto LABEL_20;
          }
        }
      }

      else
      {
      }
    }

    id v15 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v50,  v55,  16LL);
  }

  while (v15);
LABEL_19:
  id v28 = 0LL;
LABEL_20:

  if (-[NSMutableArray count](v13, "count"))
  {
    __int128 v44 = v28;
    __int128 v30 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    unsigned int v31 = v13;
    id v32 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v31,  "countByEnumeratingWithState:objects:count:",  &v46,  v54,  16LL);
    if (!v32) {
      goto LABEL_36;
    }
    id v33 = v32;
    uint64_t v34 = *(void *)v47;
    while (1)
    {
      for (j = 0LL; j != v33; j = (char *)j + 1)
      {
        if (*(void *)v47 != v34) {
          objc_enumerationMutation(v31);
        }
        id v36 = *(id *)(*((void *)&v46 + 1) + 8LL * (void)j);
        uint64_t v37 = objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyAuxiliaryAuthInfo);
        if ((objc_opt_isKindOfClass(v36, v37) & 1) != 0) {
          goto LABEL_30;
        }
        uint64_t v38 = objc_opt_class(&OBJC_CLASS___NSPAuxiliaryAuthInfo);
        if ((objc_opt_isKindOfClass(v36, v38) & 1) != 0)
        {
          if (v36) {
            id v36 = objc_getProperty(v36, v39, 8LL, 1);
          }
LABEL_30:
          id v40 = v36;
          goto LABEL_32;
        }

        id v40 = 0LL;
LABEL_32:
        int v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "contentLists", v44));
        id v42 = [v41 count];

        if (v42) {
          -[NSMutableArray addObject:](v30, "addObject:", v40);
        }
      }

      id v33 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v31,  "countByEnumeratingWithState:objects:count:",  &v46,  v54,  16LL);
      if (!v33)
      {
LABEL_36:

        id v28 = v44;
        goto LABEL_38;
      }
    }
  }

  __int128 v30 = v13;
LABEL_38:
  if (-[NSMutableArray count](v30, "count", v44)) {
    sub_10004091C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v30, v9, a5);
  }
  else {
    sub_100040830((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v9, a5);
  }
  sub_100040BF0((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, a5);

  return v28;
}

id sub_10004172C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  if (v5)
  {
    id v10 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v5);
    id v11 = (id)objc_claimAutoreleasedReturnValue(v10);
    objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenCache);
    id v12 = +[NPUtilities copyDataFromKeychainWithIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "copyDataFromKeychainWithIdentifier:accountName:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens",  v11);

    if (!v12)
    {
      id v20 = 0LL;
LABEL_24:

      goto LABEL_25;
    }

    id v13 = +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", objc_opt_class(&OBJC_CLASS___NSData), 0LL);
    id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    id v37 = 0LL;
    id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v14,  v12,  &v37));
    uint64_t v16 = (char *)v37;

    if (!v15 || v16)
    {
      uint64_t v21 = nplog_obj(v17, v18, v19);
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        SEL v39 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "unarchivedObjectOfClass for token data failed with error: %@",  buf,  0xCu);
      }

      id v20 = 0LL;
    }

    else
    {
      id v20 = v15;
    }

    if (!v20)
    {
LABEL_23:
      id v12 = 0LL;
      goto LABEL_24;
    }

    if (v6 && !(BOOL v23 = sub_1000AB9F4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v20, v6)))
    {
      uint64_t v34 = nplog_obj(v23, v24, v25);
      id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
LABEL_22:

        sub_10003F948((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v11);
        goto LABEL_23;
      }

      *(_DWORD *)__int128 buf = 138412290;
      SEL v39 = (const char *)v11;
      id v33 = "Cached long-lived token from keychain for %@ has non-matching key, flushing tokens";
    }

    else
    {
      BOOL v26 = sub_1000ABB98((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v20, v5);
      BOOL v27 = v26;
      uint64_t v30 = nplog_obj(v26, v28, v29);
      unsigned int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      id v32 = v31;
      if (v27)
      {
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 138412290;
          SEL v39 = (const char *)v11;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Received cached long-lived token from keychain for %@",  buf,  0xCu);
        }

        id v20 = v20;
        id v12 = v20;
        goto LABEL_24;
      }

      if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 138412290;
      SEL v39 = (const char *)v11;
      id v33 = "Cached long-lived token from keychain for %@ has non-matching challenege, flushing tokens";
    }

    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 0xCu);
    goto LABEL_22;
  }

  uint64_t v36 = nplog_obj(v7, v8, v9);
  id v11 = (id)objc_claimAutoreleasedReturnValue(v36);
  if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    SEL v39 = "+[NSPPrivateAccessTokenCache copyLongLivedTokenFromCacheForChallenge:tokenKey:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v11,  OS_LOG_TYPE_FAULT,  "%s called with null challenge",  buf,  0xCu);
  }

  id v12 = 0LL;
LABEL_25:

  return v12;
}

void sub_100041A88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  objc_opt_self(a1);
  id v7 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v6);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  id v22 = 0LL;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v5,  1LL,  &v22));

  id v10 = v22;
  id v13 = v10;
  if (v9) {
    BOOL v14 = v10 == 0LL;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenCache);
    id v17 = +[NPUtilities removeDataFromKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens");
    uint64_t v20 = nplog_obj(v17, v18, v19);
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Saving long-lived token for %@ in the keychain",  buf,  0xCu);
    }

    +[NPUtilities saveDataToKeychain:withIdentifier:accountName:]( &OBJC_CLASS___NPUtilities,  "saveDataToKeychain:withIdentifier:accountName:",  v9,  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens",  v8);
  }

  else
  {
    uint64_t v15 = nplog_obj(v10, v11, v12);
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v13;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for token data failed with error: %@",  buf,  0xCu);
    }
  }
}

id sub_100041C4C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, _DWORD *a6, void *a7)
{
  id v12 = a2;
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  uint64_t v16 = objc_opt_self(a1);
  if (v12)
  {
    uint64_t v19 = v16;
    id v20 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v12);
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    id v22 = sub_10003F308((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21);
    id v23 = [v22 mutableCopy];

    sub_10003FE50(v19, v23);
    if (![v23 count])
    {
      id v67 = 0LL;
LABEL_67:

      goto LABEL_68;
    }

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 firstObject]);
    uint64_t v25 = v24;
    if (v24) {
      uint64_t v24 = (void *)v24[1];
    }
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue([v24 firstObject]);
    if (v25) {
      BOOL v27 = (void *)v25[2];
    }
    else {
      BOOL v27 = 0LL;
    }
    id v28 = v27;
    id v89 = (id)objc_claimAutoreleasedReturnValue([v28 firstObject]);

    if (v25) {
      uint64_t v29 = (void *)v25[4];
    }
    else {
      uint64_t v29 = 0LL;
    }
    id v87 = v29;
    uint64_t v88 = v26;
    if (!v26) {
      goto LABEL_22;
    }
    if (v13)
    {
      BOOL v30 = sub_1000AB9F4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v26, v13);
      if (!v30)
      {
        uint64_t v33 = nplog_obj(v30, v31, v32);
        uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v95 = (const char *)v21;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Cached one-time token from keychain for %@ has non-matching key, but not expired. Returning token.",  buf,  0xCu);
        }
      }
    }

    BOOL v35 = sub_1000ABB98((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v26, v12);
    if (!v35)
    {
      uint64_t v68 = nplog_obj(v35, v36, v37);
      __int128 v69 = (os_log_s *)objc_claimAutoreleasedReturnValue(v68);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v95 = (const char *)v21;
        _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "Cached one-time token from keychain for %@ has non-matching challenege, flushing tokens",  buf,  0xCu);
      }

      sub_10003FA18((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21);
      id v67 = 0LL;
      goto LABEL_66;
    }

    if (v87)
    {
      id v38 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v14);
      SEL v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
      id v40 = [v87 isEqualToString:v39];
      if ((v40 & 1) == 0)
      {
        id v70 = v23;
        uint64_t v76 = nplog_obj(v40, v41, v42);
        id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v76);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v95 = (const char *)v21;
          id v73 = "Cached one-time token from keychain for %@ has non-matching long-lived token challenge, flushing one-time tokens";
          id v74 = v72;
          uint32_t v75 = 12;
          goto LABEL_73;
        }

LABEL_65:
        sub_10003FA18((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v21);
        id v67 = 0LL;
        id v23 = v70;
        BOOL v26 = v88;
LABEL_66:

        goto LABEL_67;
      }
    }

    id v43 = sub_10004172C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v14, 0LL);
    SEL v39 = v43;
    if (v43)
    {
      id v43 = [v43 isEqualToData:v15];
      if ((v43 & 1) != 0)
      {

LABEL_22:
        if (v25) {
          __int128 v46 = (void *)v25[1];
        }
        else {
          __int128 v46 = 0LL;
        }
        [v46 removeObjectAtIndex:0];
        if (v89)
        {
          if (v25) {
            __int128 v47 = (void *)v25[2];
          }
          else {
            __int128 v47 = 0LL;
          }
          [v47 removeObjectAtIndex:0];
        }

        if (v25) {
          __int128 v48 = (void *)v25[1];
        }
        else {
          __int128 v48 = 0LL;
        }
        if (![v48 count]) {
          [v23 removeObjectAtIndex:0];
        }
        if (a6)
        {
          __int128 v80 = v25;
          id v81 = v23;
          uint64_t v82 = v21;
          id v83 = v15;
          id v84 = v14;
          id v85 = v12;
          *a6 = 0;
          __int128 v90 = 0u;
          __int128 v91 = 0u;
          __int128 v92 = 0u;
          __int128 v93 = 0u;
          id v49 = v23;
          id v50 = [v49 countByEnumeratingWithState:&v90 objects:v98 count:16];
          if (v50)
          {
            id v51 = v50;
            uint64_t v52 = *(void *)v91;
            do
            {
              __int128 v53 = 0LL;
              do
              {
                if (*(void *)v91 != v52) {
                  objc_enumerationMutation(v49);
                }
                uint64_t v54 = *(void *)(*((void *)&v90 + 1) + 8LL * (void)v53);
                if (v54) {
                  uint64_t v55 = *(void **)(v54 + 8);
                }
                else {
                  uint64_t v55 = 0LL;
                }
                if (objc_msgSend(v55, "count", v80, v81, v82, v83, v84, v85))
                {
                  id v56 = v54 ? *(void **)(v54 + 8) : 0LL;
                  uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v56 firstObject]);
                  BOOL v58 = sub_1000AB9F4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v57, v13);

                  if (v58)
                  {
                    if (v54) {
                      int v59 = *(void **)(v54 + 8);
                    }
                    else {
                      int v59 = 0LL;
                    }
                    id v60 = v59;
                    *a6 += [v60 count];
                  }
                }

                __int128 v53 = (char *)v53 + 1;
              }

              while (v51 != v53);
              id v61 = [v49 countByEnumeratingWithState:&v90 objects:v98 count:16];
              id v51 = v61;
            }

            while (v61);
          }

          id v14 = v84;
          id v12 = v85;
          uint64_t v21 = v82;
          id v15 = v83;
          uint64_t v25 = v80;
          id v23 = v81;
        }

        sub_10003F620((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v23, v21);
        uint64_t v65 = nplog_obj(v62, v63, v64);
        __int128 v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v78 = " with salt";
          if (!v89) {
            uint64_t v78 = "";
          }
          *(_DWORD *)__int128 buf = 136446466;
          id v95 = v78;
          __int16 v96 = 2112;
          id v97 = v21;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEBUG,  "Received cached one-time token%{public}s from keychain for %@",  buf,  0x16u);
        }

        if (a7) {
          *a7 = v89;
        }
        id v67 = v26;
        goto LABEL_66;
      }
    }

    id v70 = v23;
    uint64_t v71 = nplog_obj(v43, v44, v45);
    id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      id v73 = "Matching long-lived token not found in the cache, flushing one-time tokens";
      id v74 = v72;
      uint32_t v75 = 2;
LABEL_73:
      _os_log_error_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, v73, buf, v75);
      goto LABEL_65;
    }

    goto LABEL_65;
  }

  uint64_t v79 = nplog_obj(v16, v17, v18);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v79);
  if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    id v95 = "+[NSPPrivateAccessTokenCache copyOneTimeTokenFromCacheForChallenge:tokenKey:longLivedTokenChallenge:longLivedT"
          "oken:tokensRemaining:outSalt:]";
    _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v21,  OS_LOG_TYPE_FAULT,  "%s called with null challenge",  buf,  0xCu);
  }

  id v67 = 0LL;
LABEL_68:

  return v67;
}

void sub_100042298(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v15 = a2;
  id v16 = a3;
  id v17 = a4;
  uint64_t v18 = a5;
  id v19 = a6;
  id v20 = a7;
  id v21 = a8;
  uint64_t v22 = objc_opt_self(a1);
  if ([v16 count])
  {
    uint64_t v25 = (os_log_s *)sub_10004172C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v20, 0LL);
    id v28 = v25;
    if (v25)
    {
      uint64_t v25 = (os_log_s *)-[os_log_s isEqualToData:](v25, "isEqualToData:", v21);
      if ((v25 & 1) != 0)
      {
        __int128 v69 = v28;
        id v70 = v21;
        uint64_t v71 = v20;
        id v73 = v18;
        id v74 = v17;
        id v75 = v15;
        id v76 = v16;
        id v29 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v15);
        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(v29);
        id v30 = sub_10003F308((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v68);
        id v31 = [v30 mutableCopy];

        sub_10003FE50(v22, v31);
        id v32 = v31;
        id v72 = v19;
        id v33 = v19;
        objc_opt_self(v22);
        uint64_t v34 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        __int128 v81 = 0u;
        __int128 v82 = 0u;
        __int128 v83 = 0u;
        __int128 v84 = 0u;
        BOOL v35 = (NSMutableArray *)v32;
        id v36 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v35,  "countByEnumeratingWithState:objects:count:",  &v81,  buf,  16LL);
        if (!v36) {
          goto LABEL_23;
        }
        id v37 = v36;
        uint64_t v38 = *(void *)v82;
        while (1)
        {
          SEL v39 = 0LL;
          do
          {
            if (*(void *)v82 != v38) {
              objc_enumerationMutation(v35);
            }
            uint64_t v40 = *(void *)(*((void *)&v81 + 1) + 8LL * (void)v39);
            if (v40) {
              uint64_t v41 = *(void **)(v40 + 8);
            }
            else {
              uint64_t v41 = 0LL;
            }
            id v42 = v41;
            if (![v42 count])
            {

LABEL_17:
              -[NSMutableArray addObject:](v34, "addObject:", v40);
              goto LABEL_18;
            }

            if (v40) {
              id v43 = *(void **)(v40 + 8);
            }
            else {
              id v43 = 0LL;
            }
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v43 firstObject]);
            BOOL v45 = sub_1000AB9F4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenResponse, v44, v33);

            if (!v45) {
              goto LABEL_17;
            }
LABEL_18:
            SEL v39 = (char *)v39 + 1;
          }

          while (v37 != v39);
          id v46 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v35,  "countByEnumeratingWithState:objects:count:",  &v81,  buf,  16LL);
          id v37 = v46;
          if (!v46)
          {
LABEL_23:

            __int128 v79 = 0u;
            __int128 v80 = 0u;
            __int128 v77 = 0u;
            __int128 v78 = 0u;
            __int128 v47 = v34;
            id v48 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v47,  "countByEnumeratingWithState:objects:count:",  &v77,  v85,  16LL);
            id v20 = v71;
            if (v48)
            {
              id v49 = v48;
              uint64_t v50 = *(void *)v78;
              do
              {
                for (i = 0LL; i != v49; i = (char *)i + 1)
                {
                  if (*(void *)v78 != v50) {
                    objc_enumerationMutation(v47);
                  }
                  -[NSMutableArray removeObject:]( v35,  "removeObject:",  *(void *)(*((void *)&v77 + 1) + 8LL * (void)i));
                }

                id v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v47,  "countByEnumeratingWithState:objects:count:",  &v77,  v85,  16LL);
              }

              while (v49);
            }

            id v17 = v74;
            if (!v35) {
              BOOL v35 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            }
            uint64_t v18 = v73;
            if (!v73 || (-[NSDate timeIntervalSinceNow](v73, "timeIntervalSinceNow"), v52 < 0.0))
            {
              __int128 v53 = -[NSDate initWithTimeIntervalSinceNow:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSinceNow:",  86400.0);

              uint64_t v18 = v53;
            }

            id v15 = v75;
            uint64_t v54 = sub_10003EA30((id *)objc_alloc(&OBJC_CLASS___NSPToken), v18);
            uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v76));
            sub_100011668((uint64_t)v54, v55);

            id v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v74));
            sub_10003ED60((uint64_t)v54, v56);

            id v57 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v71);
            BOOL v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
            sub_10001F910((uint64_t)v54, v58);

            -[NSMutableArray addObject:](v35, "addObject:", v54);
            objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenCache);
            int v59 = (const char *)+[NPUtilities totalDataInKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "totalDataInKeychainWithIdentifier:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens");
            uint64_t v62 = nplog_obj(v59, v60, v61);
            uint64_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue(v62);
            uint64_t v64 = v63;
            if ((unint64_t)v59 < 0x186A1)
            {
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)__int128 buf = 134217984;
                id v87 = v59;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEBUG,  "Keychain one-time tokens total %zu bytes, not flushing keychain",  buf,  0xCu);
              }
            }

            else
            {
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 134217984;
                id v87 = v59;
                _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "Keychain one-time tokens total %zu bytes, flushing keychain",  buf,  0xCu);
              }

              +[NPUtilities removeDataFromKeychainWithIdentifier:]( &OBJC_CLASS___NPUtilities,  "removeDataFromKeychainWithIdentifier:",  @"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens");
            }

            sub_10003F620((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v35, v68);

            id v16 = v76;
            id v19 = v72;
            id v28 = v69;
            id v21 = v70;
            goto LABEL_46;
          }
        }
      }
    }

    uint64_t v65 = nplog_obj(v25, v26, v27);
    __int128 v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_ERROR,  "Matching long-lived token not found in the cache, not adding one-time token",  buf,  2u);
    }
  }

  else
  {
    uint64_t v67 = nplog_obj(0LL, v23, v24);
    id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v87 = "+[NSPPrivateAccessTokenCache addOneTimeTokensToCacheForChallenge:tokens:salts:expirationTime:tokenKey:longLi"
            "vedTokenChallenge:longLivedToken:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "%s called with null (tokens.count > 0)",  buf,  0xCu);
    }
  }

void sub_100042878(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = sub_10003F07C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v3);
  id v5 = (id)objc_claimAutoreleasedReturnValue(v4);

  sub_10003FA18((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v5);
}

uint64_t sub_1000428D8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 issuerName]);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 originNames]);
  id v9 = [v8 count];

  if (v6 && (unint64_t)v9 >= 2)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 originNames]);
    unsigned __int8 v11 = [v10 containsObject:v6];

    if ((v11 & 1) != 0)
    {
      uint64_t v106 = v7;
      uint64_t v107 = v5;
      id v105 = v6;
      BOOL v108 = (os_log_s *)v6;
LABEL_7:
      char v104 = 0;
      goto LABEL_8;
    }

    uint64_t v85 = nplog_obj(v12, v13, v14);
    id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v85);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      id v86 = (void *)objc_claimAutoreleasedReturnValue([v5 originNames]);
      *(_DWORD *)__int128 buf = 138412546;
      id v149 = v6;
      __int16 v150 = 2112;
      __int128 v151 = v86;
      _os_log_error_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_ERROR,  "Failed to find origin name %@ in %@",  buf,  0x16u);
    }
  }

  else
  {
    uint64_t v15 = objc_claimAutoreleasedReturnValue([v5 originName]);
    if (v15)
    {
      uint64_t v107 = v5;
      BOOL v108 = (os_log_s *)v15;
      id v105 = v6;
      uint64_t v106 = v7;
      goto LABEL_7;
    }

    id v87 = [v5 typeRequiresOriginName];
    if (!(_DWORD)v87)
    {
      id v105 = v6;
      uint64_t v106 = v7;
      uint64_t v107 = v5;
      BOOL v108 = 0LL;
      char v104 = 1;
LABEL_8:
      id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      id v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v135 = 0u;
      __int128 v136 = 0u;
      __int128 v137 = 0u;
      __int128 v138 = 0u;
      id v18 = (id)qword_1001170F0;
      id v19 = [v18 countByEnumeratingWithState:&v135 objects:v147 count:16];
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v136;
        do
        {
          for (i = 0LL; i != v20; i = (char *)i + 1)
          {
            if (*(void *)v136 != v21) {
              objc_enumerationMutation(v18);
            }
            uint64_t v23 = *(void *)(*((void *)&v135 + 1) + 8LL * (void)i);
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001170F0 objectForKeyedSubscript:v23]);
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:@"Time"]);
            [v16 timeIntervalSinceDate:v25];
            if (v26 >= 21600.0) {
              -[NSMutableArray addObject:](v17, "addObject:", v23);
            }
          }

          id v20 = [v18 countByEnumeratingWithState:&v135 objects:v147 count:16];
        }

        while (v20);
      }

      __int128 v133 = 0u;
      __int128 v134 = 0u;
      __int128 v131 = 0u;
      __int128 v132 = 0u;
      uint64_t v27 = v17;
      id v28 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v131,  v146,  16LL);
      if (v28)
      {
        id v29 = v28;
        uint64_t v30 = *(void *)v132;
        do
        {
          for (j = 0LL; j != v29; j = (char *)j + 1)
          {
            if (*(void *)v132 != v30) {
              objc_enumerationMutation(v27);
            }
            [(id)qword_1001170F0 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v131 + 1) + 8 * (void)j)];
          }

          id v29 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v131,  v146,  16LL);
        }

        while (v29);
      }

      id v110 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v129 = 0u;
      __int128 v130 = 0u;
      __int128 v127 = 0u;
      __int128 v128 = 0u;
      id obj = (id)qword_1001170F8;
      id v32 = [obj countByEnumeratingWithState:&v127 objects:v145 count:16];
      if (v32)
      {
        id v33 = v32;
        uint64_t v34 = *(void *)v128;
        do
        {
          for (k = 0LL; k != v33; k = (char *)k + 1)
          {
            if (*(void *)v128 != v34) {
              objc_enumerationMutation(obj);
            }
            uint64_t v36 = *(void *)(*((void *)&v127 + 1) + 8LL * (void)k);
            id v37 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001170F8 objectForKeyedSubscript:v36]);
            __int128 v123 = 0u;
            __int128 v124 = 0u;
            __int128 v125 = 0u;
            __int128 v126 = 0u;
            id v38 = [v37 countByEnumeratingWithState:&v123 objects:v144 count:16];
            if (!v38) {
              goto LABEL_37;
            }
            id v39 = v38;
            char v40 = 0;
            uint64_t v41 = *(void *)v124;
            do
            {
              for (m = 0LL; m != v39; m = (char *)m + 1)
              {
                if (*(void *)v124 != v41) {
                  objc_enumerationMutation(v37);
                }
                [v16 timeIntervalSinceDate:*(void *)(*((void *)&v123 + 1) + 8 * (void)m)];
                v40 |= v43 < 300.0;
              }

              id v39 = [v37 countByEnumeratingWithState:&v123 objects:v144 count:16];
            }

            while (v39);
            if ((v40 & 1) == 0) {
LABEL_37:
            }
              -[NSMutableArray addObject:](v110, "addObject:", v36);
          }

          id v33 = [obj countByEnumeratingWithState:&v127 objects:v145 count:16];
        }

        while (v33);
      }

      __int128 v121 = 0u;
      __int128 v122 = 0u;
      __int128 v119 = 0u;
      __int128 v120 = 0u;
      uint64_t v44 = v110;
      id v45 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v44,  "countByEnumeratingWithState:objects:count:",  &v119,  v143,  16LL);
      if (v45)
      {
        id v46 = v45;
        uint64_t v47 = *(void *)v120;
        do
        {
          for (n = 0LL; n != v46; n = (char *)n + 1)
          {
            if (*(void *)v120 != v47) {
              objc_enumerationMutation(v44);
            }
            [(id)qword_1001170F0 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v119 + 1) + 8 * (void)n)];
          }

          id v46 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v44,  "countByEnumeratingWithState:objects:count:",  &v119,  v143,  16LL);
        }

        while (v46);
      }

      id v49 = v108;
      if ([v107 tokenType] != 3)
      {
LABEL_55:
        if ((v104 & 1) != 0) {
          goto LABEL_70;
        }
        uint64_t v64 = (void *)qword_1001170F8;
        if (!qword_1001170F8)
        {
          uint64_t v65 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          __int128 v66 = (void *)qword_1001170F8;
          qword_1001170F8 = (uint64_t)v65;

          uint64_t v64 = (void *)qword_1001170F8;
        }

        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v64 objectForKeyedSubscript:v108]);
        uint64_t v68 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if (!v67) {
          goto LABEL_69;
        }
        __int128 v117 = 0u;
        __int128 v118 = 0u;
        __int128 v115 = 0u;
        __int128 v116 = 0u;
        id v54 = v67;
        id v69 = [v54 countByEnumeratingWithState:&v115 objects:v140 count:16];
        if (v69)
        {
          id v70 = v69;
          uint64_t v71 = *(void *)v116;
          do
          {
            for (ii = 0LL; ii != v70; ii = (char *)ii + 1)
            {
              if (*(void *)v116 != v71) {
                objc_enumerationMutation(v54);
              }
              uint64_t v73 = *(void *)(*((void *)&v115 + 1) + 8LL * (void)ii);
              [v16 timeIntervalSinceDate:v73];
              if (v74 < 300.0) {
                -[NSMutableArray addObject:](v68, "addObject:", v73);
              }
            }

            id v70 = [v54 countByEnumeratingWithState:&v115 objects:v140 count:16];
          }

          while (v70);
        }

        id v49 = v108;
        if ((unint64_t)-[NSMutableArray count](v68, "count") < 0xA)
        {
LABEL_69:
          -[NSMutableArray addObject:](v68, "addObject:", v16);
          [(id)qword_1001170F8 setObject:v68 forKeyedSubscript:v49];

LABEL_70:
          uint64_t v75 = qword_100117100;
          id v76 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          if (!v75) {
            goto LABEL_81;
          }
          __int128 v113 = 0u;
          __int128 v114 = 0u;
          __int128 v111 = 0u;
          __int128 v112 = 0u;
          id v77 = (id)qword_100117100;
          id v78 = [v77 countByEnumeratingWithState:&v111 objects:v139 count:16];
          if (v78)
          {
            id v79 = v78;
            uint64_t v80 = *(void *)v112;
            do
            {
              for (jj = 0LL; jj != v79; jj = (char *)jj + 1)
              {
                if (*(void *)v112 != v80) {
                  objc_enumerationMutation(v77);
                }
                uint64_t v82 = *(void *)(*((void *)&v111 + 1) + 8LL * (void)jj);
                [v16 timeIntervalSinceDate:v82];
                if (v83 < 60.0) {
                  -[NSMutableArray addObject:](v76, "addObject:", v82);
                }
              }

              id v79 = [v77 countByEnumeratingWithState:&v111 objects:v139 count:16];
            }

            while (v79);
          }

          if ((unint64_t)-[NSMutableArray count](v76, "count") > 9)
          {
            __int128 v91 = (void *)qword_100117100;
            qword_100117100 = (uint64_t)v76;

            uint64_t v95 = nplog_obj(v92, v93, v94);
            id v54 = (id)objc_claimAutoreleasedReturnValue(v95);
            if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v54,  OS_LOG_TYPE_ERROR,  "Overall token rate exceeded, rejecting request",  buf,  2u);
            }

            uint64_t v84 = 0LL;
          }

          else
          {
LABEL_81:
            -[NSMutableArray addObject:](v76, "addObject:", v16);
            id v54 = (id)qword_100117100;
            qword_100117100 = (uint64_t)v76;
            uint64_t v84 = 1LL;
          }

          id v49 = v108;
          goto LABEL_97;
        }

        [(id)qword_1001170F8 setObject:v68 forKeyedSubscript:v108];

        uint64_t v99 = nplog_obj(v96, v97, v98);
        uint64_t v100 = (os_log_s *)objc_claimAutoreleasedReturnValue(v99);
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          uint64_t v101 = "Origin rate exceeded, rejecting request";
LABEL_100:
          _os_log_error_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, v101, buf, 2u);
          goto LABEL_96;
        }

        goto LABEL_96;
      }

      uint64_t v50 = (void *)qword_1001170F0;
      if (!qword_1001170F0)
      {
        id v51 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        double v52 = (void *)qword_1001170F0;
        qword_1001170F0 = (uint64_t)v51;

        uint64_t v50 = (void *)qword_1001170F0;
      }

      __int128 v53 = (void *)objc_claimAutoreleasedReturnValue([v50 objectForKeyedSubscript:v108]);
      id v54 = v53;
      if (v53)
      {
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"Issuer"]);
        unsigned __int8 v56 = [v55 isEqualToString:v106];

        if ((v56 & 1) != 0)
        {
LABEL_54:

          goto LABEL_55;
        }

        id v57 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"Time"]);
        [v16 timeIntervalSinceDate:v57];
        double v59 = v58;

        if (v59 < 21600.0)
        {
          uint64_t v102 = nplog_obj(v60, v61, v62);
          uint64_t v100 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int128 buf = 0;
            uint64_t v101 = "Issuer name changed, rejecting request";
            goto LABEL_100;
          }

LABEL_96:
          uint64_t v84 = 0LL;
LABEL_97:

          id v7 = v106;
          id v5 = v107;
          id v6 = v105;
          goto LABEL_98;
        }
      }

      v141[0] = @"Issuer";
      v141[1] = @"Time";
      v142[0] = v106;
      v142[1] = v16;
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v142,  v141,  2LL));
      [(id)qword_1001170F0 setObject:v63 forKeyedSubscript:v108];

      goto LABEL_54;
    }

    uint64_t v90 = nplog_obj(v87, v88, v89);
    id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v90);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_ERROR,  "Failed to find origin name in challenge",  buf,  2u);
    }
  }

  uint64_t v84 = 0LL;
LABEL_98:

  return v84;
}

id *sub_1000432E4(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)&OBJC_CLASS___NSPPrivacyProxyConfigAgent;
    id v10 = (id *)objc_msgSendSuper2(&v12, "init");
    a1 = v10;
    if (v10)
    {
      [v10 setActive:1];
      [a1 setKernelActivated:0];
      [a1 setUserActivated:0];
      [a1 setVoluntary:1];
      [a1 setAgentUUID:v8];
      [a1 setAgentDescription:v9];
      objc_storeWeak(a1 + 7, v7);
    }
  }

  return a1;
}

void sub_1000433FC(id a1)
{
  id v1 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_proxy_config_get_agent_domain(a1));
  uint64_t v2 = objc_claimAutoreleasedReturnValue(v1);
  id v3 = (void *)qword_100117108;
  qword_100117108 = v2;
}

void sub_100043470(id a1)
{
  id v1 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_proxy_config_get_agent_type(a1));
  uint64_t v2 = objc_claimAutoreleasedReturnValue(v1);
  id v3 = (void *)qword_100117118;
  qword_100117118 = v2;
}

id *sub_100043720(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)&OBJC_CLASS___NSPPrivacyProxyTokenAgent;
    id v10 = (id *)objc_msgSendSuper2(&v12, "init");
    a1 = v10;
    if (v10)
    {
      [v10 setActive:1];
      [a1 setKernelActivated:0];
      [a1 setUserActivated:0];
      [a1 setVoluntary:0];
      [a1 setAgentUUID:v8];
      [a1 setAgentDescription:v9];
      objc_storeWeak(a1 + 4, v7);
    }
  }

  return a1;
}

void sub_100043A44(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v4 = ((uint64_t (*)(void))NPGetInternalQueue)();
    id v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
    dispatch_assert_queue_V2(v5);

    uint64_t v9 = *(void *)(a1 + 8);
    if (!a2)
    {
      if (!v9)
      {
        uint64_t v33 = nplog_obj(0LL, v6, v7, v8);
        unsigned __int8 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "DNS proxy not stopping because it was not running",  buf,  2u);
        }

        goto LABEL_19;
      }

      mrc_dns_proxy_invalidate();
      uint64_t v13 = *(void **)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;

      uint64_t v18 = nplog_obj(v14, v15, v16, v17);
      unsigned __int8 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        objc_super v12 = "DNS proxy request to stop";
        goto LABEL_9;
      }

uint64_t sub_100043D10(uint64_t result)
{
  if (result)
  {
    if (qword_100117130 != -1) {
      dispatch_once(&qword_100117130, &stru_1000F9D78);
    }
    return byte_100117128;
  }

  return result;
}

void sub_100043D54(id a1)
{
  uint64_t v1 = getpid();
}

void sub_100043DA8(id a1, int a2, int a3)
{
  uint64_t v5 = nplog_obj(a1, *(void *)&a2, *(void *)&a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v7 = off_1000F9DD8[a2 + 1];
    }
    int v8 = 136315394;
    uint64_t v9 = v7;
    __int16 v10 = 1024;
    int v11 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "DNS proxy event handler got %s event (error %d)",  (uint8_t *)&v8,  0x12u);
  }
}

void sub_100043E90(void *a1, void *a2, void *a3, int a4, uint64_t a5)
{
  id v8 = a2;
  id v9 = a3;
  if (a1 && v8 && (a5 & 0xC) != 4)
  {
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSArray);
    id v78 = a1;
    if ((objc_opt_isKindOfClass(v8, v10) & 1) != 0
      || (id v11 = v8,
          uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSSet),
          char v13 = objc_opt_isKindOfClass(v11, v12),
          v11,
          (v13 & 1) != 0))
    {
      id v14 = v8;
      uint64_t v15 = objc_opt_class(&OBJC_CLASS___NSSet);
      char isKindOfClass = objc_opt_isKindOfClass(v14, v15);
      if ((isKindOfClass & 1) != 0) {
        uint64_t v17 = ")}";
      }
      else {
        uint64_t v17 = ")";
      }
      uint64_t v18 = "{(";
      if ((isKindOfClass & 1) == 0) {
        uint64_t v18 = "(";
      }
      id v71 = v9;
      uint64_t v75 = (4 * a4 + 4);
      [a1 appendFormat:@"\n%*s%@ = %s", v75, " ", v9, v18];
      __int128 v85 = 0u;
      __int128 v86 = 0u;
      __int128 v83 = 0u;
      __int128 v84 = 0u;
      id v19 = v14;
      id v20 = [v19 countByEnumeratingWithState:&v83 objects:v88 count:16];
      if (v20)
      {
        id v21 = v20;
        uint64_t v73 = v17;
        id v69 = v8;
        uint64_t v22 = (4 * a4 + 8);
        uint64_t v23 = (a4 + 2);
        uint64_t v24 = *(void *)v84;
        do
        {
          for (i = 0LL; i != v21; i = (char *)i + 1)
          {
            if (*(void *)v84 != v24) {
              objc_enumerationMutation(v19);
            }
            uint64_t v26 = *(void **)(*((void *)&v83 + 1) + 8LL * (void)i);
            if ((objc_opt_respondsToSelector(v26, "descriptionWithIndent:options:") & 1) != 0)
            {
              uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 descriptionWithIndent:v23 options:a5]);
              [v78 appendFormat:@"\n%*s{%@", v22, " ", v27];

              objc_msgSend(v78, "appendFormat:", @"\n%*s},", v22, " ", v65);
            }

            else
            {
              id v28 = v26;
              uint64_t v29 = objc_opt_class(&OBJC_CLASS___NSString);
              if (v28 && (char v30 = objc_opt_isKindOfClass(v28, v29), v28, (a5 & 3) == 3) && (v30 & 1) != 0)
              {
                objc_msgSend(v78, "appendFormat:", @"\n%*s<%lu-char-str>,", v22, " ", objc_msgSend(v28, "length"));
              }

              else
              {
                id v31 = (void *)objc_claimAutoreleasedReturnValue([v28 description]);
                [v78 appendFormat:@"\n%*s%@,", v22, " ", v31];
              }
            }
          }

          id v21 = [v19 countByEnumeratingWithState:&v83 objects:v88 count:16];
        }

        while (v21);

        a1 = v78;
        objc_msgSend(v78, "appendFormat:", @"\n%*s", v75, " ");
        id v8 = v69;
        uint64_t v17 = v73;
      }

      else
      {
      }

      objc_msgSend(a1, "appendFormat:", @"%s", v17);

      id v9 = v71;
    }

    else
    {
      id v32 = v11;
      uint64_t v33 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      char v34 = objc_opt_isKindOfClass(v32, v33);

      if ((v34 & 1) == 0)
      {
        id v55 = v32;
        uint64_t v56 = objc_opt_class(&OBJC_CLASS___NSUUID);
        char v57 = objc_opt_isKindOfClass(v55, v56);

        if ((v57 & 1) != 0)
        {
          id v58 = (id)objc_claimAutoreleasedReturnValue([v55 UUIDString]);
          [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v58];
        }

        else
        {
          if (sub_100044644(v55))
          {
            if ((~(_DWORD)a5 & 3LL) != 0) {
              [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v55];
            }
            else {
              [a1 appendFormat:@"\n%*s%@ = <%lu-char-str>", (4 * a4 + 4), " ", v9, objc_msgSend(v55, "length")];
            }
            goto LABEL_28;
          }

          if (sub_100044688(v55))
          {
            uint64_t v59 = (4 * a4 + 4);
            id v60 = v55;
            id v61 = [v60 length];
            uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v60 description]);

            [a1 appendFormat:@"\n%*s%@ = %u:%@", v59, " ", v9, v61, v62];
            goto LABEL_28;
          }

          id v58 = v55;
          if ((((uint64_t (*)(void))objc_opt_respondsToSelector)() & 1) != 0)
          {
            uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "descriptionWithIndent:options:"));
            [a1 appendFormat:@"\n%*s%@ = {%@", (4 * (a4 + 1)), " ", v9, v63];

            objc_msgSend(a1, "appendFormat:", @"\n%*s}", (4 * (a4 + 1)), " ", v66, v67);
          }

          else
          {
            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v58 description]);
            [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v64];
          }
        }

        goto LABEL_28;
      }

      id v35 = v32;
      int v36 = 4 * a4;
      uint64_t v37 = " ";
      [a1 appendFormat:@"\n%*s%@ = {", (4 * a4 + 4), " ", v9];
      __int128 v81 = 0u;
      __int128 v82 = 0u;
      __int128 v79 = 0u;
      __int128 v80 = 0u;
      id v38 = v35;
      id v39 = [v38 countByEnumeratingWithState:&v79 objects:v87 count:16];
      if (v39)
      {
        id v40 = v39;
        uint64_t v68 = (v36 + 4);
        id v70 = v8;
        id v72 = v9;
        uint64_t v76 = (v36 + 8);
        unsigned int v74 = a4 + 2;
        uint64_t v41 = *(void *)v80;
        do
        {
          for (j = 0LL; j != v40; j = (char *)j + 1)
          {
            if (*(void *)v80 != v41) {
              objc_enumerationMutation(v38);
            }
            uint64_t v43 = *(void *)(*((void *)&v79 + 1) + 8LL * (void)j);
            int v44 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:v43]);
            if ((objc_opt_respondsToSelector(v44, "descriptionWithIndent:options:") & 1) != 0)
            {
              id v45 = (void *)objc_claimAutoreleasedReturnValue([v44 descriptionWithIndent:v74 options:a5]);
              [a1 appendFormat:@"\n%*s%@ = {%@", v76, v37, v43, v45];

              objc_msgSend(a1, "appendFormat:", @"\n%*s},", v76, v37);
            }

            else
            {
              id v46 = v38;
              uint64_t v47 = v41;
              id v48 = v40;
              id v49 = v37;
              id v50 = v44;
              uint64_t v51 = objc_opt_class(&OBJC_CLASS___NSString);
              if (v50 && (char v52 = objc_opt_isKindOfClass(v50, v51), v50, (a5 & 3) == 3) && (v52 & 1) != 0)
              {
                id v53 = [v50 length];
                uint64_t v37 = v49;
                a1 = v78;
                [v78 appendFormat:@"\n%*s%@ = <%lu-char-str>", v76, v49, v43, v53];
              }

              else
              {
                id v54 = (void *)objc_claimAutoreleasedReturnValue([v50 description]);
                uint64_t v37 = v49;
                a1 = v78;
                [v78 appendFormat:@"\n%*s%@ = %@", v76, v49, v43, v54];
              }

              id v40 = v48;
              uint64_t v41 = v47;
              id v38 = v46;
            }
          }

          id v40 = [v38 countByEnumeratingWithState:&v79 objects:v87 count:16];
        }

        while (v40);

        objc_msgSend(a1, "appendFormat:", @"\n%*s", v68, v37);
        id v8 = v70;
        id v9 = v72;
      }

      else
      {
      }

      [a1 appendString:@"}"];
    }
  }

LABEL_28:
}

    sub_100073E3C(a1);
    return;
  }

  if (v27)
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "%@ Wi-Fi interface is primary", buf, 0xCu);
  }

  id v28 = sub_100073E7C(a1);
  if ((_DWORD)v28)
  {
    id v31 = nplog_obj(v28, v29, v30);
    id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      uint64_t v33 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "%@ Wi-Fi network [%@] is already evaluated",  buf,  0x16u);
    }
  }

  else
  {
    sub_100073D80(a1);
    char v34 = *(id *)(a1 + 120);
    id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 currentKnownNetworkProfile]);
    int v36 = objc_claimAutoreleasedReturnValue([v35 networkName]);
    uint64_t v37 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v36;

    uint64_t v41 = nplog_obj(v38, v39, v40);
    uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = *(id *)(a1 + 120);
      int v44 = (void *)objc_claimAutoreleasedReturnValue([v43 currentKnownNetworkProfile]);
      id v45 = (void *)objc_claimAutoreleasedReturnValue([v44 networkName]);
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v45;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "%@ performing captive evaluation of Wi-Fi network [%@]",  buf,  0x16u);
    }

    *(_BYTE *)(a1 + 20) = 0;
    sub_1000679B4(a1);
    sub_100073418(a1);
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000LL;
    id v55 = sub_100057300;
    uint64_t v56 = sub_100057310;
    char v57 = (id)os_transaction_create("com.apple.networkserviceproxy.captive-evaluation");
    objc_initWeak(&location, (id)a1);
    id v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSPCaptiveWiFiHandler sharedHandler](&OBJC_CLASS___NSPCaptiveWiFiHandler, "sharedHandler"));
    uint64_t v47 = *(id *)(a1 + 120);
    id v48 = (void *)objc_claimAutoreleasedReturnValue([v47 interfaceName]);
    v51[0] = _NSConcreteStackBlock;
    v51[1] = 3221225472LL;
    v51[2] = sub_100073F20;
    v51[3] = &unk_1000FA410;
    objc_copyWeak(&v52, &location);
    v51[4] = buf;
    id v49 = [v46 evaluate:v48 completionHandler:v51];

    if ((v49 & 1) == 0)
    {
      id v50 = *(void **)(*(void *)&buf[8] + 40LL);
      *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
    }

    objc_destroyWeak(&v52);

    objc_destroyWeak(&location);
    _Block_object_dispose(buf, 8);
  }

uint64_t sub_100044644(void *a1)
{
  id v1 = a1;
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString);
  char isKindOfClass = objc_opt_isKindOfClass(v1, v2);

  return isKindOfClass & 1;
}

uint64_t sub_100044688(void *a1)
{
  id v1 = a1;
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSData);
  char isKindOfClass = objc_opt_isKindOfClass(v1, v2);

  return isKindOfClass & 1;
}

id sub_1000446CC(id result, int a2, uint64_t a3, int a4, char a5)
{
  if (result && (a5 & 0xC) != 4LL)
  {
    uint64_t v7 = @"NO";
    if (a2) {
      uint64_t v7 = @"YES";
    }
    return [result appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", a3, v7, v5, v6];
  }

  return result;
}

id sub_100044730(id result, uint64_t a2, uint64_t a3, int a4, char a5)
{
  if (result)
  {
    if ((a5 & 0xC) != 4LL) {
      return [result appendFormat:@"\n%*s%@ = %lld", (4 * a4 + 4), " ", a3, a2, v5, v6];
    }
  }

  return result;
}

id *sub_10004477C(id *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v15 = v12;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v9)
  {
    uint64_t v40 = nplog_obj(v12, v13, v14);
    uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "%s called with null agentUUID",  (uint8_t *)&buf,  0xCu);
    }

    goto LABEL_19;
  }

  if (!v11)
  {
    uint64_t v42 = nplog_obj(v12, v13, v14);
    uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "%s called with null agentDescription",  (uint8_t *)&buf,  0xCu);
    }

void sub_100044C7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_100044CA8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100044CB8(uint64_t a1)
{
}

uint64_t sub_100044CC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_6;
  }
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
  unsigned int v6 = [v5 isEqual:&off_100103380];
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
    unsigned int v8 = [v7 isEqual:*(void *)(a1 + 32)];

    if (v8)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v10 = v3;
      uint64_t v5 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v10;
      goto LABEL_5;
    }

id *sub_100044D90(id *a1)
{
  if (a1) {
    a1 = (id *)objc_claimAutoreleasedReturnValue([a1[2] agentDescription]);
  }
  return a1;
}

void sub_100044DB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v6 = v3;
  if (a1)
  {
    if (v3)
    {
    }

    else
    {
      uint64_t v7 = nplog_obj(0LL, v4, v5);
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        int v9 = 136315138;
        id v10 = "-[NSPPrivacyProxyNetworkRegistration addResumableSessionData:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "%s called with null resumableSessionData",  (uint8_t *)&v9,  0xCu);
      }
    }
  }
}

void *sub_100044E8C(void *result, uint64_t a2)
{
  if (result)
  {
    id result = (void *)result[3];
    if (result) {
      return [result setLowWaterMark:a2];
    }
  }

  return result;
}

void sub_100044F88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100044FA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) agentDescription]);
    int v14 = 138412290;
    uint64_t v15 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Resumable session low water mark hit for %@ agent",  (uint8_t *)&v14,  0xCu);
  }

  uint64_t v7 = *(void *)(a1 + 40);
  if (v7) {
    id WeakRetained = objc_loadWeakRetained((id *)(v7 + 8));
  }
  else {
    id WeakRetained = 0LL;
  }
  char v9 = objc_opt_respondsToSelector(WeakRetained, "resumableSessionLowWaterMarkReached");

  if ((v9 & 1) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 40);
    if (v10) {
      id v11 = objc_loadWeakRetained((id *)(v10 + 8));
    }
    else {
      id v11 = 0LL;
    }
    [v11 resumableSessionLowWaterMarkReached];
  }

  uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = 0LL;
}

void sub_1000451E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1000451FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = *(_DWORD *)(a1 + 64);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) agentDescription]);
    v13[0] = 67109378;
    v13[1] = v6;
    __int16 v14 = 2112;
    uint64_t v15 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Received error %d for %@ agent",  (uint8_t *)v13,  0x12u);
  }

  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v8 + 8));
    uint64_t v10 = *(void *)(a1 + 40);
  }

  else
  {
    uint64_t v10 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained reportErrorForNetworkRegistration:v10 error:*(unsigned int *)(a1 + 64) withOptions:*(void *)(a1 + 48)];

  uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8LL);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = 0LL;
}

uint64_t sub_100045314(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_8;
  }
  id v5 = v3;
  int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sessionType]);
  if (([v6 isEqual:&off_100103380] & 1) == 0)
  {

LABEL_8:
    uint64_t v12 = 0LL;
    goto LABEL_9;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 agentUUID]);
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    char v9 = *(void **)(v8 + 16);
  }
  else {
    char v9 = 0LL;
  }
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 agentUUID]);
  unsigned __int8 v11 = [v7 isEqual:v10];

  if ((v11 & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v12 = 1LL;
LABEL_9:

  return v12;
}

void sub_1000453F8(id *a1, uint64_t a2, uint64_t a3)
{
  if (!a1[3])
  {
    uint64_t v54 = nplog_obj(a1, a2, a3);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v54);
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
      goto LABEL_40;
    }
    *(_DWORD *)id v58 = 136315138;
    *(void *)&v58[4] = "-[NSPPrivacyProxyNetworkRegistration resetProxyAgent]";
    uint64_t v56 = "%s called with null self.proxyConfigAgentRegistration";
LABEL_42:
    _os_log_fault_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_FAULT, v56, v58, 0xCu);
    goto LABEL_40;
  }

  id v4 = a1[2];
  if (v4)
  {
    [v4 setActive:1];
    [a1[2] setVoluntary:0];
    [a1[2] setUserActivated:0];
    [a1[2] setKernelActivated:0];
    id v5 = a1[2];
    id v7 = a1[4];
    if (v5) {
      objc_setProperty_atomic(v5, v6, v7, 32LL);
    }

    id v8 = a1[2];
    id v10 = a1[5];
    if (v8) {
      objc_setProperty_atomic(v8, v9, v10, 40LL);
    }

    id v11 = [a1[3] isRegistered];
    int v12 = (int)v11;
    uint64_t v15 = nplog_obj(v11, v13, v14);
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v17)
      {
        id v18 = a1[2];
        id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 agentDescription]);
        id v20 = a1[2];
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 agentUUID]);
        id Property = a1[2];
        BOOL v24 = Property;
        if (Property) {
          id Property = objc_getProperty(Property, v23, 40LL, 1);
        }
        id v25 = Property;
        *(_DWORD *)id v58 = 138412802;
        *(void *)&v58[4] = v19;
        *(_WORD *)&v58[12] = 2112;
        *(void *)&v58[14] = v21;
        *(_WORD *)&v58[22] = 2112;
        id v59 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Updated %@ proxy agent (%@) with hash %@",  v58,  0x20u);
      }

      id v26 = a1[2];
      id v27 = a1[3];
      [v27 updateNetworkAgent:v26];
    }

    else
    {
      if (v17)
      {
        id v28 = a1[2];
        id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 agentDescription]);
        id v30 = a1[2];
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 agentUUID]);
        id v32 = a1[2];
        char v34 = v32;
        if (v32) {
          id v32 = objc_getProperty(v32, v33, 40LL, 1);
        }
        id v35 = v32;
        *(_DWORD *)id v58 = 138412802;
        *(void *)&v58[4] = v29;
        *(_WORD *)&v58[12] = 2112;
        *(void *)&v58[14] = v31;
        *(_WORD *)&v58[22] = 2112;
        id v59 = v35;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Registered %@ proxy agent (%@) with hash %@",  v58,  0x20u);
      }

      id v36 = a1[2];
      id v27 = a1[3];
      [v27 registerNetworkAgent:v36];
    }

    *(void *)id v58 = _NSConcreteStackBlock;
    *(void *)&v58[8] = 3221225472LL;
    *(void *)&v58[16] = sub_100045314;
    id v59 = &unk_1000F9370;
    id v60 = a1;
    uint64_t v37 = objc_retainBlock(v58);
    if ([a1[3] isRegistered])
    {
      id v38 = objc_alloc(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
      id v39 = a1[3];
      id v40 = a1[2];
      id v41 = v39;
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v40 agentUUID]);
      id v43 = a1[2];
      int v44 = (void *)objc_claimAutoreleasedReturnValue([v43 agentUUID]);
      id v45 = [v38 initWithNetworkAgentRegistration:v41 sessionType:&off_100103380 configurationIdentifier:v42 agentUUID:v44 name:0];

      if (v45)
      {
        uint64_t v46 = [a1[2] isActive];
        else {
          uint64_t v47 = v46;
        }
        [v45 setAgentFlags:v47];
        id v48 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        [v48 setFileHandle:v45 matchingPredicate:v37];
      }

      else
      {
        id v48 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        [v48 removeFileHandleMatchingPredicate:v37];
      }
    }

    else
    {
      id v45 = (id)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
      [v45 removeFileHandleMatchingPredicate:v37];
    }

    id v49 = a1 + 1;
    id WeakRetained = objc_loadWeakRetained(a1 + 1);
    if ((objc_opt_respondsToSelector(WeakRetained, "deferCommit") & 1) != 0)
    {
      id v51 = objc_loadWeakRetained(v49);
      unsigned __int8 v52 = [v51 deferCommit];

      if ((v52 & 1) != 0) {
        goto LABEL_36;
      }
    }

    else
    {
    }

    __int16 v53 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    [v53 commit];

LABEL_36:
    return;
  }

  uint64_t v57 = nplog_obj(0LL, a2, a3);
  id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)id v58 = 136315138;
    *(void *)&v58[4] = "-[NSPPrivacyProxyNetworkRegistration resetProxyAgent]";
    uint64_t v56 = "%s called with null self.proxyConfigAgent";
    goto LABEL_42;
  }

void sub_100045950(uint64_t a1)
{
  if (a1)
  {
    id v2 = [*(id *)(a1 + 24) isRegistered];
    if ((_DWORD)v2)
    {
      uint64_t v5 = nplog_obj(v2, v3, v4);
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        id v7 = *(id *)(a1 + 16);
        id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 agentUUID]);
        *(_DWORD *)__int128 buf = 138412290;
        BOOL v17 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Un-registering proxy agent with UUID %@",  buf,  0xCu);
      }

      [*(id *)(a1 + 24) unregisterNetworkAgent];
      char v9 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      v15[2] = sub_100045AF4;
      v15[3] = &unk_1000F9370;
      v15[4] = a1;
      [v9 removeFileHandleMatchingPredicate:v15];

      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
      if ((objc_opt_respondsToSelector(WeakRetained, "deferCommit") & 1) != 0)
      {
        id v11 = objc_loadWeakRetained((id *)(a1 + 8));
        unsigned __int8 v12 = [v11 deferCommit];

        if ((v12 & 1) != 0) {
          goto LABEL_10;
        }
      }

      else
      {
      }

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v13 commit];

LABEL_10:
      uint64_t v14 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = 0LL;
    }
  }

id sub_100045AF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_100103380])
    {
      int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        id v8 = *(void **)(v7 + 16);
      }
      else {
        id v8 = 0LL;
      }
      char v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id sub_100045BD0(uint64_t a1)
{
  if (a1)
  {
    id v1 = *(id *)(a1 + 32);
    if (v1 && (id v2 = (unsigned __int8 *)malloc(0x20uLL)) != 0LL)
    {
      id v3 = v2;
      CC_SHA256([v1 bytes], (CC_LONG)objc_msgSend(v1, "length"), v2);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v3, 16LL));
      free(v3);
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return v4;
}

id *sub_100045CC4(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_10004477C(result, a2, 0LL, @"MultiHop", a3);
  }
  return result;
}

uint64_t sub_100045CE0( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, char a10, char a11, char a12, char a13, void *a14, void *a15, char a16, char a17, void *a18, unsigned __int8 a19, char a20, void *a21, char a22, void *a23, void *a24, void *a25, char a26, void *a27)
{
  id v144 = a2;
  id v33 = a3;
  id v143 = a4;
  id v142 = a5;
  id v141 = a6;
  id v140 = a7;
  id v139 = a8;
  id v137 = a9;
  id v34 = a14;
  id v35 = a15;
  id v36 = a18;
  id v138 = a21;
  id v136 = a23;
  id v135 = a24;
  id v37 = a25;
  id v38 = a27;
  id v41 = v38;
  __int128 v129 = v33;
  if (!a1)
  {
    uint64_t v113 = 0LL;
    uint64_t v42 = v144;
    goto LABEL_109;
  }

  uint64_t v42 = v144;
  if (!v144)
  {
    uint64_t v115 = nplog_obj(v38, v39, v40);
    log = (os_log_s *)objc_claimAutoreleasedReturnValue(v115);
    if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT))
    {
LABEL_113:
      uint64_t v113 = 0LL;
      goto LABEL_108;
    }

    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    __int128 v116 = "%s called with null firstHopProxyURL";
LABEL_131:
    _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, v116, buf, 0xCu);
    goto LABEL_113;
  }

  if (!v33)
  {
    uint64_t v117 = nplog_obj(v38, v39, v40);
    log = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);
    if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_113;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    __int128 v116 = "%s called with null secondHopProxyURL";
    goto LABEL_131;
  }

  id v128 = v37;
  id v43 = (const char *)[v144 UTF8String];
  int v44 = (const char *)[v33 UTF8String];
  nw_endpoint_t url = nw_endpoint_create_url(v43);
  nw_endpoint_t v46 = nw_endpoint_create_url(v44);
  nw_endpoint_t v49 = v46;
  log = url;
  if (!url)
  {
    uint64_t v118 = nplog_obj(v46, v47, v48);
    __int128 v133 = (os_log_s *)objc_claimAutoreleasedReturnValue(v118);
    if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxyEndpoint",  buf,  0xCu);
    }

    uint64_t v113 = 0LL;
    goto LABEL_106;
  }

  if (!v46)
  {
    uint64_t v119 = nplog_obj(0LL, v47, v48);
    __int128 v133 = (os_log_s *)objc_claimAutoreleasedReturnValue(v119);
    id v37 = v128;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_FAULT,  "%s called with null secondHopProxyEndpoint",  buf,  0xCu);
    }

    uint64_t v113 = 0LL;
    goto LABEL_107;
  }

  masque = (os_log_s *)nw_proxy_hop_create_masque(url);
  uint64_t v51 = nw_proxy_hop_create_masque(v49);
  __int128 v132 = (void *)v51;
  __int128 v133 = masque;
  if (!masque)
  {
    uint64_t v120 = nplog_obj(v51, v52, v53);
    uint64_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v120);
    if (!os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
    {
LABEL_123:
      uint64_t v113 = 0LL;
      goto LABEL_105;
    }

    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    __int128 v121 = "%s called with null firstHopProxy";
LABEL_133:
    _os_log_fault_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_FAULT, v121, buf, 0xCu);
    goto LABEL_123;
  }

  if (!v51)
  {
    uint64_t v122 = nplog_obj(0LL, v52, v53);
    uint64_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
    if (!os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
      goto LABEL_123;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    __int128 v121 = "%s called with null secondHopProxy";
    goto LABEL_133;
  }

  uint64_t v54 = masque;
  id v55 = v141;
  if ([v55 isEqualToString:@"RFC9298"])
  {
    uint64_t v56 = 2LL;
  }

  else if ([v55 isEqualToString:@"draft-12"])
  {
    uint64_t v56 = 2LL;
  }

  else
  {
    uint64_t v56 = 1LL;
  }

  nw_proxy_hop_set_masque_version(v54, v56);

  id v57 = v132;
  id v58 = v140;
  if ([v58 isEqualToString:@"RFC9298"])
  {
    uint64_t v59 = 2LL;
  }

  else if ([v58 isEqualToString:@"draft-12"])
  {
    uint64_t v59 = 2LL;
  }

  else
  {
    uint64_t v59 = 1LL;
  }

  nw_proxy_hop_set_masque_version(v57, v59);

  if (a10) {
    nw_proxy_hop_set_supports_resumption(v54, 1LL);
  }
  if (a11) {
    nw_proxy_hop_set_supports_resumption(v57, 1LL);
  }
  __int128 v127 = v35;
  if (a12) {
    nw_proxy_hop_set_use_x25519(v54, 1LL);
  }
  __int128 v131 = v49;
  __int128 v126 = v34;
  if (a13) {
    nw_proxy_hop_set_use_x25519(v57, 1LL);
  }
  __int128 v167 = 0u;
  __int128 v168 = 0u;
  __int128 v165 = 0u;
  __int128 v166 = 0u;
  id v60 = v139;
  id v61 = [v60 countByEnumeratingWithState:&v165 objects:v175 count:16];
  if (v61)
  {
    id v62 = v61;
    uint64_t v63 = *(void *)v166;
    do
    {
      for (i = 0LL; i != v62; i = (char *)i + 1)
      {
        if (*(void *)v166 != v63) {
          objc_enumerationMutation(v60);
        }
        nw_endpoint_t v65 = sub_100046934(*(void **)(*((void *)&v165 + 1) + 8LL * (void)i));
        if (v65) {
          nw_proxy_hop_add_next_hop_host(v54, v65);
        }
      }

      id v62 = [v60 countByEnumeratingWithState:&v165 objects:v175 count:16];
    }

    while (v62);
  }

  __int128 v163 = 0u;
  __int128 v164 = 0u;
  __int128 v161 = 0u;
  __int128 v162 = 0u;
  id v66 = v137;
  id v67 = [v66 countByEnumeratingWithState:&v161 objects:v174 count:16];
  if (v67)
  {
    id v68 = v67;
    uint64_t v69 = *(void *)v162;
    do
    {
      for (j = 0LL; j != v68; j = (char *)j + 1)
      {
        if (*(void *)v162 != v69) {
          objc_enumerationMutation(v66);
        }
        nw_endpoint_t v71 = sub_100046934(*(void **)(*((void *)&v161 + 1) + 8LL * (void)j));
        if (v71) {
          nw_proxy_hop_add_next_hop_host(v57, v71);
        }
      }

      id v68 = [v66 countByEnumeratingWithState:&v161 objects:v174 count:16];
    }

    while (v68);
  }

  __int128 v159 = 0u;
  __int128 v160 = 0u;
  __int128 v157 = 0u;
  __int128 v158 = 0u;
  id v72 = v143;
  id v73 = [v72 countByEnumeratingWithState:&v157 objects:v173 count:16];
  if (v73)
  {
    id v74 = v73;
    uint64_t v75 = *(void *)v158;
    do
    {
      for (k = 0LL; k != v74; k = (char *)k + 1)
      {
        if (*(void *)v158 != v75) {
          objc_enumerationMutation(v72);
        }
        id v77 = *(void **)(*((void *)&v157 + 1) + 8LL * (void)k);
        if ([v77 length]) {
          nw_proxy_hop_add_server_raw_public_key(v54, [v77 bytes], objc_msgSend(v77, "length"));
        }
      }

      id v74 = [v72 countByEnumeratingWithState:&v157 objects:v173 count:16];
    }

    while (v74);
  }

  __int128 v155 = 0u;
  __int128 v156 = 0u;
  __int128 v153 = 0u;
  __int128 v154 = 0u;
  id v78 = v142;
  id v79 = [v78 countByEnumeratingWithState:&v153 objects:v172 count:16];
  if (v79)
  {
    id v80 = v79;
    uint64_t v81 = *(void *)v154;
    do
    {
      for (m = 0LL; m != v80; m = (char *)m + 1)
      {
        if (*(void *)v154 != v81) {
          objc_enumerationMutation(v78);
        }
        __int128 v83 = *(void **)(*((void *)&v153 + 1) + 8LL * (void)m);
        if ([v83 length]) {
          nw_proxy_hop_add_server_raw_public_key(v57, [v83 bytes], objc_msgSend(v83, "length"));
        }
      }

      id v80 = [v78 countByEnumeratingWithState:&v153 objects:v172 count:16];
    }

    while (v80);
  }

  id v34 = v126;
  if (v126)
  {
    [v126 getUUIDBytes:buf];
    if (a16) {
      __int128 v85 = "PrivateToken token=";
    }
    else {
      __int128 v85 = "PrivacyToken token=";
    }
    uint64_t v84 = nw_proxy_hop_add_token_header(v54, "proxy-authorization", v85, "", buf);
  }

  id v35 = v127;
  if (v127)
  {
    [v127 getUUIDBytes:buf];
    if (a17) {
      __int128 v86 = "PrivateToken token=";
    }
    else {
      __int128 v86 = "PrivacyToken token=";
    }
    uint64_t v84 = nw_proxy_hop_add_token_header(v57, "proxy-authorization", v86, "", buf);
  }

  if (a20)
  {
    if (os_variant_has_internal_diagnostics("com.apple.networkserviceproxy")
      && [v138 length])
    {
      id v87 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v138));
      uint64_t v88 = (const char *)[v87 UTF8String];

      if (!v88) {
        goto LABEL_79;
      }
    }

    else
    {
      uint64_t v88 = "";
    }

    uint64_t v84 = nw_proxy_hop_add_extra_header(v57, "sec-ch-geohash", v88);
  }

LABEL_79:
  if (a22) {
    uint64_t v84 = nw_proxy_hop_add_extra_header(v57, "sec-ch-filter-dns", "?1");
  }
  nw_endpoint_t v49 = v131;
  if (a26) {
    uint64_t v84 = nw_proxy_hop_supports_udp_proxying_over_http2(v54, 1LL);
  }
  uint64_t v89 = nw_array_create(v84);
  uint64_t v92 = (os_log_s *)v89;
  if (v89)
  {
    nw_array_append(v89, v54);
    nw_array_append(v92, v57);
    uint64_t default_privacy_proxy = nw_proxy_config_create_default_privacy_proxy(v92);
    if (default_privacy_proxy)
    {
      uint64_t v96 = (void *)default_privacy_proxy;
      if (v36)
      {
        [v36 getUUIDBytes:buf];
        nw_proxy_config_set_fallback_proxy_agent(v96, buf);
      }

      nw_proxy_config_set_is_privacy_proxy(v96, 1LL, a19);
      __int128 v151 = 0u;
      __int128 v152 = 0u;
      __int128 v149 = 0u;
      __int128 v150 = 0u;
      id v97 = v136;
      id v98 = [v97 countByEnumeratingWithState:&v149 objects:v170 count:16];
      if (v98)
      {
        id v99 = v98;
        uint64_t v100 = *(void *)v150;
        do
        {
          for (n = 0LL; n != v99; n = (char *)n + 1)
          {
            if (*(void *)v150 != v100) {
              objc_enumerationMutation(v97);
            }
            nw_proxy_config_add_preferred_domain( v96,  [*(id *)(*((void *)&v149 + 1) + 8 * (void)n) UTF8String]);
          }

          id v99 = [v97 countByEnumeratingWithState:&v149 objects:v170 count:16];
        }

        while (v99);
      }

      __int128 v147 = 0u;
      __int128 v148 = 0u;
      __int128 v145 = 0u;
      __int128 v146 = 0u;
      id v102 = v135;
      id v103 = [v102 countByEnumeratingWithState:&v145 objects:v169 count:16];
      if (v103)
      {
        id v104 = v103;
        uint64_t v105 = *(void *)v146;
        do
        {
          for (ii = 0LL; ii != v104; ii = (char *)ii + 1)
          {
            if (*(void *)v146 != v105) {
              objc_enumerationMutation(v102);
            }
            uint64_t v107 = *(void **)(*((void *)&v145 + 1) + 8LL * (void)ii);
            *(_OWORD *)__int128 buf = 0uLL;
            [v107 getUUIDBytes:buf];
            nw_proxy_config_add_alternate_agent(v96, buf);
          }

          id v104 = [v102 countByEnumeratingWithState:&v145 objects:v169 count:16];
        }

        while (v104);
      }

      if (v41)
      {
        id v108 = v96;
        nw_proxy_config_set_epoch(v108, [v41 unsignedShortValue]);
      }

      uint64_t v109 = nw_proxy_config_copy_agent_data(v96);
      id v110 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v109;

      objc_storeStrong((id *)(a1 + 40), a25);
      sub_1000453F8((id *)a1, v111, v112);
      uint64_t v113 = 1LL;
      nw_endpoint_t v49 = v131;
      goto LABEL_104;
    }

    uint64_t v124 = nplog_obj(0LL, v94, v95);
    __int128 v125 = (os_log_s *)objc_claimAutoreleasedReturnValue(v124);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
    }

    uint64_t v96 = 0LL;
  }

  else
  {
    uint64_t v123 = nplog_obj(0LL, v90, v91);
    uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(v123);
    if (os_log_type_enabled((os_log_t)v96, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v96,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }
  }

  uint64_t v113 = 0LL;
LABEL_104:

  uint64_t v42 = v144;
LABEL_105:

LABEL_106:
  id v37 = v128;
LABEL_107:

LABEL_108:
LABEL_109:

  return v113;
}

nw_endpoint_t sub_100046934(void *a1)
{
  id v1 = a1;
  if ([v1 containsString:@":"])
  {
    id v2 = (void *)objc_claimAutoreleasedReturnValue([v1 componentsSeparatedByString:@":"]);
    if ([v2 count] == (id)2)
    {
      id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 firstObject]);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 lastObject]);
      nw_endpoint_t host = nw_endpoint_create_host( (const char *)[v3 UTF8String],  (const char *)objc_msgSend(v4, "UTF8String"));
    }

    else
    {
      nw_endpoint_t host = nw_endpoint_create_host((const char *)[v1 UTF8String], "443");
    }
  }

  else
  {
    nw_endpoint_t host = 0LL;
  }

  return host;
}

id *sub_100046A14(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_10004477C(result, a2, 0LL, @"SingleHop", a3);
  }
  return result;
}

uint64_t sub_100046A30( uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, int a8, void *a9, unsigned __int8 a10, void *a11, void *a12)
{
  id v18 = a2;
  id v74 = a3;
  id v19 = a4;
  id v73 = a7;
  id v20 = a9;
  id v21 = a11;
  id v22 = a12;
  id v25 = v22;
  if (!a1)
  {
    uint64_t v59 = 0LL;
    id v60 = v73;
    goto LABEL_39;
  }

  if (!v18)
  {
    uint64_t v62 = nplog_obj(v22, v23, v24);
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v62);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v80 = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supports"
            "Resumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:fallbackProx"
            "yConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "%s called with null proxyURL", buf, 0xCu);
    }

    uint64_t v59 = 0LL;
    id v60 = v73;
    goto LABEL_38;
  }

  id v72 = v18;
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v18 UTF8String]);
  id v29 = url;
  if (!url)
  {
    uint64_t v63 = nplog_obj(0LL, v27, v28);
    id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    id v60 = v73;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v80 = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supports"
            "Resumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:fallbackProx"
            "yConfigHash:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopEndpoint",  buf,  0xCu);
    }

    uint64_t v59 = 0LL;
    goto LABEL_37;
  }

  masque = (os_log_s *)nw_proxy_hop_create_masque(url);
  id v33 = masque;
  if (!masque)
  {
    uint64_t v64 = nplog_obj(0LL, v31, v32);
    nw_endpoint_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v64);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v80 = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supports"
            "Resumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:fallbackProx"
            "yConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", buf, 0xCu);
    }

    uint64_t v59 = 0LL;
    goto LABEL_36;
  }

  id v70 = v29;
  id v34 = masque;
  id v71 = v19;
  id v35 = v19;
  uint64_t v69 = v33;
  if ([v35 isEqualToString:@"RFC9298"])
  {
    uint64_t v36 = 2LL;
  }

  else if ([v35 isEqualToString:@"draft-12"])
  {
    uint64_t v36 = 2LL;
  }

  else
  {
    uint64_t v36 = 1LL;
  }

  id v37 = v25;
  nw_proxy_hop_set_masque_version(v34, v36);

  if (a5) {
    nw_proxy_hop_set_supports_resumption(v34, 1LL);
  }
  if (a6) {
    nw_proxy_hop_set_use_x25519(v34, 1LL);
  }
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  id v38 = v74;
  id v39 = [v38 countByEnumeratingWithState:&v75 objects:v81 count:16];
  if (v39)
  {
    id v40 = v39;
    uint64_t v41 = *(void *)v76;
    do
    {
      for (i = 0LL; i != v40; i = (char *)i + 1)
      {
        if (*(void *)v76 != v41) {
          objc_enumerationMutation(v38);
        }
        id v43 = *(void **)(*((void *)&v75 + 1) + 8LL * (void)i);
        if ([v43 length]) {
          nw_proxy_hop_add_server_raw_public_key(v34, [v43 bytes], objc_msgSend(v43, "length"));
        }
      }

      id v40 = [v38 countByEnumeratingWithState:&v75 objects:v81 count:16];
    }

    while (v40);
  }

  uint64_t v44 = (uint64_t)v73;
  if (v73)
  {
    [v73 getUUIDBytes:buf];
    if (a8) {
      id v45 = "PrivateToken token=";
    }
    else {
      id v45 = "PrivacyToken token=";
    }
    uint64_t v44 = nw_proxy_hop_add_token_header(v34, "proxy-authorization", v45, "", buf);
  }

  uint64_t v46 = nw_array_create(v44);
  nw_endpoint_t v49 = (os_log_s *)v46;
  id v19 = v71;
  id v25 = v37;
  if (v46)
  {
    nw_array_append(v46, v34);
    uint64_t default_privacy_proxy = nw_proxy_config_create_default_privacy_proxy(v49);
    id v33 = v69;
    if (default_privacy_proxy)
    {
      uint64_t v53 = (void *)default_privacy_proxy;
      if (v20)
      {
        [v20 getUUIDBytes:buf];
        nw_proxy_config_set_fallback_proxy_agent(v53, buf);
      }

      nw_proxy_config_set_is_privacy_proxy(v53, 1LL, a10);
      if (v25)
      {
        id v54 = v53;
        nw_proxy_config_set_epoch(v54, [v25 unsignedShortValue]);
      }

      uint64_t v55 = nw_proxy_config_copy_agent_data(v53);
      uint64_t v56 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v55;

      objc_storeStrong((id *)(a1 + 40), a11);
      sub_1000453F8((id *)a1, v57, v58);
      uint64_t v59 = 1LL;
      goto LABEL_35;
    }

    uint64_t v66 = nplog_obj(0LL, v51, v52);
    id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v80 = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supports"
            "Resumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:fallbackProx"
            "yConfigHash:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
    }

    uint64_t v53 = 0LL;
  }

  else
  {
    uint64_t v65 = nplog_obj(0LL, v47, v48);
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(v65);
    id v33 = v69;
    if (os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v80 = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supports"
            "Resumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:fallbackProx"
            "yConfigHash:configEpoch:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v53,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }
  }

  uint64_t v59 = 0LL;
LABEL_35:

  id v29 = v70;
LABEL_36:

  id v60 = v73;
LABEL_37:

  id v18 = v72;
LABEL_38:

LABEL_39:
  return v59;
}

id *sub_100046FA4(id *a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a3;
    id v9 = a2;
    id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"ObliviousHop-%@",  v8));
    id v11 = sub_10004477C(v4, v9, v8, v10, v7);

    uint64_t v4 = v11;
  }

  return v4;
}

uint64_t sub_10004705C( uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, int a8, void *a9, unsigned __int8 a10, void *a11, void *a12, unsigned int a13, void *a14)
{
  id v19 = a2;
  id v84 = a3;
  id v83 = a4;
  id v82 = a7;
  id v20 = a9;
  id v21 = a11;
  id v22 = a12;
  id v23 = a14;
  id v81 = v23;
  if (!a1)
  {
    uint64_t v57 = 0LL;
    id v26 = v19;
    uint64_t v47 = v82;
    uint64_t v27 = v20;
    uint64_t v62 = v23;
    goto LABEL_48;
  }

  id v26 = v19;
  if (!v19)
  {
    uint64_t v67 = nplog_obj(v23, v24, v25);
    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
    uint64_t v27 = v20;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supp"
            "ortsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviou"
            "sConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
      id v68 = "%s called with null proxyURL";
      goto LABEL_68;
    }

LABEL_54:
    uint64_t v57 = 0LL;
    uint64_t v47 = v82;
    uint64_t v62 = v81;
    goto LABEL_47;
  }

  uint64_t v27 = v20;
  if (!v21)
  {
    uint64_t v69 = nplog_obj(v23, v24, v25);
    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v69);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supp"
            "ortsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviou"
            "sConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
      id v68 = "%s called with null obliviousConfig";
      goto LABEL_68;
    }

    goto LABEL_54;
  }

  if (!v22)
  {
    uint64_t v70 = nplog_obj(v23, v24, v25);
    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
    if (!os_log_type_enabled(v65, OS_LOG_TYPE_FAULT)) {
      goto LABEL_54;
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:suppor"
          "tsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviousCon"
          "fig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
    id v68 = "%s called with null obliviousPath";
LABEL_68:
    _os_log_fault_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_FAULT, v68, buf, 0xCu);
    goto LABEL_54;
  }

  uint64_t v28 = a1;
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v19 UTF8String]);
  if (!url)
  {
    id v34 = v22;
    uint64_t v71 = nplog_obj(0LL, v29, v30);
    id v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
    uint64_t v47 = v82;
    uint64_t v62 = v81;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supp"
            "ortsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviou"
            "sConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopEndpoint",  buf,  0xCu);
    }

    uint64_t v57 = 0LL;
    goto LABEL_46;
  }

  masque = (void *)nw_proxy_hop_create_masque();
  id v34 = v22;
  if (!masque)
  {
    uint64_t v72 = nplog_obj(0LL, v32, v33);
    id v73 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supp"
            "ortsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviou"
            "sConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", buf, 0xCu);
    }

    id v35 = 0LL;
    uint64_t v57 = 0LL;
    uint64_t v47 = v82;
    uint64_t v62 = v81;
    goto LABEL_46;
  }

  id v35 = masque;
  id v36 = v83;
  if ([v36 isEqualToString:@"RFC9298"])
  {
    uint64_t v37 = 2LL;
  }

  else if ([v36 isEqualToString:@"draft-12"])
  {
    uint64_t v37 = 2LL;
  }

  else
  {
    uint64_t v37 = 1LL;
  }

  nw_proxy_hop_set_masque_version(v35, v37);

  if (a5) {
    nw_proxy_hop_set_supports_resumption(v35, 1LL);
  }
  id v80 = v26;
  if (a6) {
    nw_proxy_hop_set_use_x25519(v35, 1LL);
  }
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  id v38 = v84;
  id v39 = [v38 countByEnumeratingWithState:&v85 objects:v91 count:16];
  if (v39)
  {
    id v40 = v39;
    uint64_t v41 = *(void *)v86;
    do
    {
      for (i = 0LL; i != v40; i = (char *)i + 1)
      {
        if (*(void *)v86 != v41) {
          objc_enumerationMutation(v38);
        }
        id v43 = *(void **)(*((void *)&v85 + 1) + 8LL * (void)i);
        if ([v43 length]) {
          nw_proxy_hop_add_server_raw_public_key(v35, [v43 bytes], objc_msgSend(v43, "length"));
        }
      }

      id v40 = [v38 countByEnumeratingWithState:&v85 objects:v91 count:16];
    }

    while (v40);
  }

  uint64_t v47 = v82;
  if (v82)
  {
    [v82 getUUIDBytes:buf];
    if (a8) {
      uint64_t v48 = "PrivateToken token=";
    }
    else {
      uint64_t v48 = "PrivacyToken token=";
    }
    uint64_t oblivious_http_with_context = nw_proxy_hop_add_token_header(v35, "proxy-authorization", v48, "", buf);
  }

  uint64_t v27 = v20;
  if (a13 > 1)
  {
    if (a13 != 2)
    {
LABEL_43:
      uint64_t v63 = nplog_obj(oblivious_http_with_context, v45, v46);
      uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:su"
              "pportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obli"
              "viousConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_FAULT,  "%s called with null obliviousHop",  buf,  0xCu);
      }

      uint64_t v57 = 0LL;
      id v26 = v80;
      uint64_t v62 = v81;
      goto LABEL_46;
    }

    uint64_t oblivious_http_with_context = nw_proxy_hop_create_oblivious_http_with_context( [v21 bytes],  objc_msgSend(v21, "length"),  objc_msgSend(v34, "UTF8String"),  0);
    nw_endpoint_t v49 = (void *)oblivious_http_with_context;
  }

  else
  {
    uint64_t oblivious_http_with_context = nw_proxy_hop_create_oblivious_http( [v21 bytes],  objc_msgSend(v21, "length"),  objc_msgSend(v34, "UTF8String"));
    nw_endpoint_t v49 = (void *)oblivious_http_with_context;
    if (a13 == 1) {
      uint64_t oblivious_http_with_context = nw_proxy_hop_set_enable_chunked_oblivious_http(oblivious_http_with_context, 1LL);
    }
  }

  if (!v49) {
    goto LABEL_43;
  }
  uint64_t v50 = nw_array_create(oblivious_http_with_context);
  uint64_t v53 = (void *)v50;
  if (v50)
  {
    nw_array_append(v50, v35);
    nw_array_append(v53, v49);
    uint64_t default_privacy_proxy = (os_log_s *)nw_proxy_config_create_default_privacy_proxy(v53);
    if (default_privacy_proxy)
    {
      if (v20)
      {
        [v20 getUUIDBytes:buf];
        nw_proxy_config_set_fallback_proxy_agent(default_privacy_proxy, buf);
      }

      uint64_t v57 = 1LL;
      nw_proxy_config_set_is_privacy_proxy(default_privacy_proxy, 1LL, a10);
      uint64_t v58 = nw_proxy_config_copy_agent_data(default_privacy_proxy);
      uint64_t v59 = *(void **)(v28 + 32);
      *(void *)(v28 + 32) = v58;

      objc_storeStrong((id *)(v28 + 40), a14);
      sub_1000453F8((id *)v28, v60, v61);
    }

    else
    {
      uint64_t v75 = nplog_obj(0LL, v54, v55);
      __int128 v76 = (os_log_s *)objc_claimAutoreleasedReturnValue(v75);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:su"
              "pportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obli"
              "viousConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
      }

      uint64_t v57 = 0LL;
    }

    uint64_t v62 = v81;
  }

  else
  {
    uint64_t v74 = nplog_obj(0LL, v51, v52);
    uint64_t default_privacy_proxy = (os_log_s *)objc_claimAutoreleasedReturnValue(v74);
    uint64_t v62 = v81;
    if (os_log_type_enabled(default_privacy_proxy, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v90 = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersion:supp"
            "ortsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:fallbackAgentUUID:shouldFailOpen:obliviou"
            "sConfig:obliviousPath:obliviousHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  default_privacy_proxy,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }

    uint64_t v57 = 0LL;
  }

  id v26 = v80;
  uint64_t v47 = v82;
LABEL_46:

  id v22 = v34;
  uint64_t v65 = url;
LABEL_47:

LABEL_48:
  return v57;
}

  -[NSPConfigurationStats setExposureNotificationsEnabled:](v15, "setExposureNotificationsEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x1000) == 0)
  {
LABEL_29:
    if ((v12 & 0x2000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_56;
  }

        uint64_t v13 = (char *)v13 + 1;
      }

      while (v11 != v13);
      uint64_t v31 = [v9 countByEnumeratingWithState:&v32 objects:v36 count:16];
      id v11 = v31;
    }

    while (v31);
  }

  -[NSPProxyAnalytics sendAnalytics](v4, "sendAnalytics");
}

id *sub_1000477A0(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_10004477C(result, a2, 0LL, @"MultiHopFallback", a3);
  }
  return result;
}

uint64_t sub_1000477BC( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, char a10, char a11, char a12, char a13, void *a14, void *a15, char a16, char a17, unsigned __int8 a18, char a19, void *a20, char a21, char a22, void *a23)
{
  id v122 = a2;
  id v30 = a3;
  id v128 = a4;
  id v127 = a5;
  id v31 = a6;
  id v32 = a7;
  id v126 = a8;
  id v125 = a9;
  id v124 = a14;
  id v123 = a15;
  id v121 = a20;
  id v33 = a23;
  id v36 = v33;
  uint64_t v120 = a1;
  if (!a1)
  {
    uint64_t v100 = 0LL;
    uint64_t v37 = v122;
    goto LABEL_92;
  }

  uint64_t v37 = v122;
  if (!v122)
  {
    uint64_t v102 = nplog_obj(v33, v34, v35);
    nw_endpoint_t url = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
    if (!os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
LABEL_96:
      uint64_t v100 = 0LL;
      goto LABEL_91;
    }

    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    id v103 = "%s called with null firstHopProxyURL";
LABEL_112:
    _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, v103, buf, 0xCu);
    goto LABEL_96;
  }

  if (!v30)
  {
    uint64_t v104 = nplog_obj(v33, v34, v35);
    nw_endpoint_t url = (os_log_s *)objc_claimAutoreleasedReturnValue(v104);
    if (!os_log_type_enabled(url, OS_LOG_TYPE_FAULT)) {
      goto LABEL_96;
    }
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    id v103 = "%s called with null secondHopProxyURL";
    goto LABEL_112;
  }

  id v38 = (const char *)[v122 UTF8String];
  id v39 = (const char *)[v30 UTF8String];
  nw_endpoint_t url = nw_endpoint_create_url(v38);
  nw_endpoint_t v41 = nw_endpoint_create_url(v39);
  nw_endpoint_t v44 = v41;
  id v119 = v30;
  if (!url)
  {
    uint64_t v105 = nplog_obj(v41, v42, v43);
    masque = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
    if (!os_log_type_enabled(masque, OS_LOG_TYPE_FAULT))
    {
LABEL_100:
      uint64_t v100 = 0LL;
      goto LABEL_90;
    }

    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    uint64_t v106 = "%s called with null firstHopProxyEndpoint";
LABEL_114:
    _os_log_fault_impl((void *)&_mh_execute_header, masque, OS_LOG_TYPE_FAULT, v106, buf, 0xCu);
    goto LABEL_100;
  }

  if (!v41)
  {
    uint64_t v107 = nplog_obj(0LL, v42, v43);
    masque = (os_log_s *)objc_claimAutoreleasedReturnValue(v107);
    if (!os_log_type_enabled(masque, OS_LOG_TYPE_FAULT)) {
      goto LABEL_100;
    }
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    uint64_t v106 = "%s called with null secondHopProxyEndpoint";
    goto LABEL_114;
  }

  masque = (os_log_s *)nw_proxy_hop_create_masque(url);
  uint64_t v46 = nw_proxy_hop_create_masque(v44);
  nw_endpoint_t v49 = (void *)v46;
  id v118 = v32;
  if (!masque)
  {
    uint64_t v108 = nplog_obj(v46, v47, v48);
    uint64_t v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_FAULT)) {
      goto LABEL_104;
    }
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    uint64_t v109 = "%s called with null firstHopProxy";
LABEL_116:
    _os_log_fault_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_FAULT, v109, buf, 0xCu);
    goto LABEL_104;
  }

  if (v46)
  {
    __int128 v116 = v44;
    uint64_t v117 = url;
    uint64_t v50 = masque;
    id v51 = v31;
    __int128 v114 = v36;
    if ([v51 isEqualToString:@"RFC9298"])
    {
      uint64_t v52 = 2LL;
    }

    else if ([v51 isEqualToString:@"draft-12"])
    {
      uint64_t v52 = 2LL;
    }

    else
    {
      uint64_t v52 = 1LL;
    }

    nw_proxy_hop_set_masque_version(v50, v52);

    id v53 = v49;
    id v54 = v32;
    if ([v54 isEqualToString:@"RFC9298"])
    {
      uint64_t v55 = 2LL;
    }

    else if ([v54 isEqualToString:@"draft-12"])
    {
      uint64_t v55 = 2LL;
    }

    else
    {
      uint64_t v55 = 1LL;
    }

    nw_proxy_hop_set_masque_version(v53, v55);

    if (a10) {
      nw_proxy_hop_set_supports_resumption(v50, 1LL);
    }
    uint64_t v115 = v49;
    if (a11) {
      nw_proxy_hop_set_supports_resumption(v53, 1LL);
    }
    uint64_t v56 = masque;
    if (a12) {
      nw_proxy_hop_set_use_x25519(v50, 1LL);
    }
    id v57 = v31;
    if (a13) {
      nw_proxy_hop_set_use_x25519(v53, 1LL);
    }
    __int128 v143 = 0u;
    __int128 v144 = 0u;
    __int128 v141 = 0u;
    __int128 v142 = 0u;
    id v58 = v126;
    id v59 = [v58 countByEnumeratingWithState:&v141 objects:v150 count:16];
    if (v59)
    {
      id v60 = v59;
      uint64_t v61 = *(void *)v142;
      do
      {
        for (i = 0LL; i != v60; i = (char *)i + 1)
        {
          if (*(void *)v142 != v61) {
            objc_enumerationMutation(v58);
          }
          nw_endpoint_t v63 = sub_100046934(*(void **)(*((void *)&v141 + 1) + 8LL * (void)i));
          if (v63) {
            nw_proxy_hop_add_next_hop_host(v50, v63);
          }
        }

        id v60 = [v58 countByEnumeratingWithState:&v141 objects:v150 count:16];
      }

      while (v60);
    }

    __int128 v139 = 0u;
    __int128 v140 = 0u;
    __int128 v137 = 0u;
    __int128 v138 = 0u;
    id v64 = v125;
    id v65 = [v64 countByEnumeratingWithState:&v137 objects:v149 count:16];
    if (v65)
    {
      id v66 = v65;
      uint64_t v67 = *(void *)v138;
      do
      {
        for (j = 0LL; j != v66; j = (char *)j + 1)
        {
          if (*(void *)v138 != v67) {
            objc_enumerationMutation(v64);
          }
          nw_endpoint_t v69 = sub_100046934(*(void **)(*((void *)&v137 + 1) + 8LL * (void)j));
          if (v69) {
            nw_proxy_hop_add_next_hop_host(v53, v69);
          }
        }

        id v66 = [v64 countByEnumeratingWithState:&v137 objects:v149 count:16];
      }

      while (v66);
    }

    __int128 v135 = 0u;
    __int128 v136 = 0u;
    __int128 v133 = 0u;
    __int128 v134 = 0u;
    id v70 = v128;
    id v71 = [v70 countByEnumeratingWithState:&v133 objects:v148 count:16];
    if (v71)
    {
      id v72 = v71;
      uint64_t v73 = *(void *)v134;
      do
      {
        for (k = 0LL; k != v72; k = (char *)k + 1)
        {
          if (*(void *)v134 != v73) {
            objc_enumerationMutation(v70);
          }
          uint64_t v75 = *(void **)(*((void *)&v133 + 1) + 8LL * (void)k);
          if ([v75 length]) {
            nw_proxy_hop_add_server_raw_public_key(v50, [v75 bytes], objc_msgSend(v75, "length"));
          }
        }

        id v72 = [v70 countByEnumeratingWithState:&v133 objects:v148 count:16];
      }

      while (v72);
    }

    __int128 v131 = 0u;
    __int128 v132 = 0u;
    __int128 v129 = 0u;
    __int128 v130 = 0u;
    id v76 = v127;
    id v77 = [v76 countByEnumeratingWithState:&v129 objects:v147 count:16];
    if (v77)
    {
      id v78 = v77;
      uint64_t v79 = *(void *)v130;
      do
      {
        for (m = 0LL; m != v78; m = (char *)m + 1)
        {
          if (*(void *)v130 != v79) {
            objc_enumerationMutation(v76);
          }
          id v81 = *(void **)(*((void *)&v129 + 1) + 8LL * (void)m);
          if ([v81 length]) {
            nw_proxy_hop_add_server_raw_public_key(v53, [v81 bytes], objc_msgSend(v81, "length"));
          }
        }

        id v78 = [v76 countByEnumeratingWithState:&v129 objects:v147 count:16];
      }

      while (v78);
    }

    if (v124)
    {
      [v124 getUUIDBytes:buf];
      if (a16) {
        id v82 = "PrivateToken token=";
      }
      else {
        id v82 = "PrivacyToken token=";
      }
      nw_proxy_hop_add_token_header(v50, "proxy-authorization", v82, "", buf);
    }

    id v31 = v57;
    uint64_t v83 = (uint64_t)v123;
    if (v123)
    {
      [v123 getUUIDBytes:buf];
      if (a17) {
        id v84 = "PrivateToken token=";
      }
      else {
        id v84 = "PrivacyToken token=";
      }
      uint64_t v83 = nw_proxy_hop_add_token_header(v53, "proxy-authorization", v84, "", buf);
    }

    masque = v56;
    nw_endpoint_t v49 = v115;
    if (!a19) {
      goto LABEL_79;
    }
    if (os_variant_has_internal_diagnostics("com.apple.networkserviceproxy")
      && [v121 length])
    {
      id v85 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v121));
      __int128 v86 = (const char *)[v85 UTF8String];

      if (!v86) {
        goto LABEL_79;
      }
    }

    else
    {
      __int128 v86 = "";
    }

    uint64_t v83 = nw_proxy_hop_add_extra_header(v53, "sec-ch-geohash", v86);
LABEL_79:
    if (a21) {
      uint64_t v83 = nw_proxy_hop_add_extra_header(v53, "sec-ch-filter-dns", "?1");
    }
    uint64_t v87 = nw_array_create(v83);
    uint64_t v90 = (os_log_s *)v87;
    if (v87)
    {
      nw_array_append(v87, v50);
      nw_array_append(v90, v53);
      if (a22) {
        nw_proxy_hop_supports_udp_proxying_over_http2(v50, 1LL);
      }
      uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy(v90);
      uint64_t v37 = v122;
      id v36 = v114;
      if (fallback_privacy_proxy)
      {
        uint64_t v94 = (void *)fallback_privacy_proxy;
        nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 1LL, a18);
        if (v114)
        {
          id v95 = v94;
          nw_proxy_config_set_epoch(v95, [v114 unsignedShortValue]);
        }

        uint64_t v96 = nw_proxy_config_copy_agent_data(v94);
        id v97 = *(void **)(v120 + 32);
        *(void *)(v120 + 32) = v96;

        sub_1000453F8((id *)v120, v98, v99);
        uint64_t v100 = 1LL;
      }

      else
      {
        uint64_t v112 = nplog_obj(0LL, v92, v93);
        uint64_t v113 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);
        if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                 "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHop"
                 "sArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:fir"
                 "stProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopU"
                 "sesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSF"
                 "ilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
        }

        uint64_t v94 = 0LL;
        uint64_t v100 = 0LL;
      }
    }

    else
    {
      uint64_t v111 = nplog_obj(0LL, v88, v89);
      uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(v111);
      if (os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstPr"
               "oxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArr"
               "ay:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProx"
               "yHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStand"
               "ardToken:secondProxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHi"
               "nt:fallbackSupportsUDPProxying:configEpoch:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v94,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
      }

      uint64_t v100 = 0LL;
      uint64_t v37 = v122;
      id v36 = v114;
    }

    nw_endpoint_t v44 = v116;
    nw_endpoint_t url = v117;
    goto LABEL_89;
  }

  uint64_t v110 = nplog_obj(0LL, v47, v48);
  uint64_t v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v110);
  if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v146 = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:firstProxyH"
           "opKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopNextHopsArray:secon"
           "dProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:firstProxyHopUsesX255"
           "19:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondP"
           "roxyHopUsesStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsU"
           "DPProxying:configEpoch:]";
    uint64_t v109 = "%s called with null secondHopProxy";
    goto LABEL_116;
  }

LABEL_104:
  uint64_t v100 = 0LL;
LABEL_89:

  id v32 = v118;
LABEL_90:

  id v30 = v119;
LABEL_91:

LABEL_92:
  return v100;
}

id *sub_100048210(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_10004477C(result, a2, 0LL, @"SingleHopFallback", a3);
  }
  return result;
}

uint64_t sub_10004822C( uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, int a8, unsigned __int8 a9, void *a10)
{
  id v17 = a2;
  id v69 = a3;
  id v18 = a4;
  id v19 = a7;
  id v20 = a10;
  id v23 = v20;
  if (a1)
  {
    if (v17)
    {
      nw_endpoint_t url = nw_endpoint_create_url((const char *)[v17 UTF8String]);
      uint64_t v27 = url;
      if (url)
      {
        masque = (os_log_s *)nw_proxy_hop_create_masque(url);
        id v31 = masque;
        if (masque)
        {
          int v65 = a8;
          id v68 = v17;
          id v32 = masque;
          id v33 = v18;
          if ([v33 isEqualToString:@"RFC9298"])
          {
            uint64_t v34 = 2LL;
          }

          else if ([v33 isEqualToString:@"draft-12"])
          {
            uint64_t v34 = 2LL;
          }

          else
          {
            uint64_t v34 = 1LL;
          }

          id v66 = v27;
          uint64_t v67 = v23;
          nw_proxy_hop_set_masque_version(v32, v34);

          if (a5) {
            nw_proxy_hop_set_supports_resumption(v32, 1LL);
          }
          id v35 = v18;
          if (a6) {
            nw_proxy_hop_set_use_x25519(v32, 1LL);
          }
          __int128 v72 = 0u;
          __int128 v73 = 0u;
          __int128 v70 = 0u;
          __int128 v71 = 0u;
          id v36 = v69;
          id v37 = [v36 countByEnumeratingWithState:&v70 objects:v76 count:16];
          if (v37)
          {
            id v38 = v37;
            uint64_t v39 = *(void *)v71;
            do
            {
              for (i = 0LL; i != v38; i = (char *)i + 1)
              {
                if (*(void *)v71 != v39) {
                  objc_enumerationMutation(v36);
                }
                nw_endpoint_t v41 = *(void **)(*((void *)&v70 + 1) + 8LL * (void)i);
                if ([v41 length]) {
                  nw_proxy_hop_add_server_raw_public_key(v32, [v41 bytes], objc_msgSend(v41, "length"));
                }
              }

              id v38 = [v36 countByEnumeratingWithState:&v70 objects:v76 count:16];
            }

            while (v38);
          }

          uint64_t v42 = (uint64_t)v19;
          if (v19)
          {
            [v19 getUUIDBytes:buf];
            if (v65) {
              uint64_t v43 = "PrivateToken token=";
            }
            else {
              uint64_t v43 = "PrivacyToken token=";
            }
            uint64_t v42 = nw_proxy_hop_add_token_header(v32, "proxy-authorization", v43, "", buf);
          }

          uint64_t v44 = nw_array_create(v42);
          uint64_t v47 = (os_log_s *)v44;
          if (v44)
          {
            nw_array_append(v44, v32);
            uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy(v47);
            id v18 = v35;
            if (fallback_privacy_proxy)
            {
              id v51 = (void *)fallback_privacy_proxy;
              nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 1LL, a9);
              id v23 = v67;
              id v17 = v68;
              uint64_t v27 = v66;
              if (v67)
              {
                id v52 = v51;
                nw_proxy_config_set_epoch(v52, [v67 unsignedShortValue]);
              }

              uint64_t v53 = nw_proxy_config_copy_agent_data(v51);
              id v54 = *(void **)(a1 + 32);
              *(void *)(a1 + 32) = v53;

              sub_1000453F8((id *)a1, v55, v56);
              uint64_t v57 = 1LL;
            }

            else
            {
              uint64_t v63 = nplog_obj(0LL, v49, v50);
              id v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
              id v23 = v67;
              id v17 = v68;
              uint64_t v27 = v66;
              if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)__int128 buf = 136315138;
                uint64_t v75 = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:pro"
                      "xyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
                _os_log_fault_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
              }

              id v51 = 0LL;
              uint64_t v57 = 0LL;
            }
          }

          else
          {
            uint64_t v62 = nplog_obj(0LL, v45, v46);
            id v51 = (void *)objc_claimAutoreleasedReturnValue(v62);
            id v18 = v35;
            if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              uint64_t v75 = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxy"
                    "Version:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v51,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
            }

            uint64_t v57 = 0LL;
            id v23 = v67;
            id v17 = v68;
            uint64_t v27 = v66;
          }
        }

        else
        {
          uint64_t v61 = nplog_obj(0LL, v29, v30);
          uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            uint64_t v75 = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVe"
                  "rsion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHop",  buf,  0xCu);
          }

          uint64_t v57 = 0LL;
        }
      }

      else
      {
        uint64_t v60 = nplog_obj(0LL, v25, v26);
        id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          uint64_t v75 = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
                "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopEndpoint",  buf,  0xCu);
        }

        uint64_t v57 = 0LL;
      }
    }

    else
    {
      uint64_t v59 = nplog_obj(v20, v21, v22);
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v75 = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersio"
              "n:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "%s called with null proxyURL",  buf,  0xCu);
      }

      uint64_t v57 = 0LL;
    }
  }

  else
  {
    uint64_t v57 = 0LL;
  }

  return v57;
}

id *sub_10004874C(id *a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a3;
    id v9 = a2;
    id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"ObliviousHopFallback-%@",  v8));
    id v11 = sub_10004477C(v4, v9, v8, v10, v7);

    uint64_t v4 = v11;
  }

  return v4;
}

uint64_t sub_100048804( uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, int a8, unsigned __int8 a9, void *a10, void *a11, unsigned int a12)
{
  id v19 = a2;
  id v77 = a3;
  id v76 = a4;
  id v75 = a7;
  id v20 = a10;
  id v21 = a11;
  uint64_t v24 = v21;
  if (!a1)
  {
    uint64_t v54 = 0LL;
    uint64_t v61 = v75;
    goto LABEL_46;
  }

  if (!v19)
  {
    uint64_t v63 = nplog_obj(v21, v22, v23);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      id v64 = "%s called with null proxyURL";
      goto LABEL_66;
    }

LABEL_52:
    uint64_t v54 = 0LL;
    uint64_t v61 = v75;
    goto LABEL_45;
  }

  if (!v20)
  {
    uint64_t v65 = nplog_obj(v21, v22, v23);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      id v64 = "%s called with null obliviousConfig";
      goto LABEL_66;
    }

    goto LABEL_52;
  }

  if (!v21)
  {
    uint64_t v66 = nplog_obj(0LL, v22, v23);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      goto LABEL_52;
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVersio"
          "n:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:oblivi"
          "ousPath:obliviousHTTPType:]";
    id v64 = "%s called with null obliviousPath";
LABEL_66:
    _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v64, buf, 0xCu);
    goto LABEL_52;
  }

  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v19 UTF8String]);
  uint64_t v28 = url;
  id v74 = v19;
  if (!url)
  {
    uint64_t v67 = nplog_obj(0LL, v26, v27);
    id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
    uint64_t v61 = v75;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopEndpoint",  buf,  0xCu);
    }

    uint64_t v54 = 0LL;
    goto LABEL_44;
  }

  masque = (void *)nw_proxy_hop_create_masque(url);
  if (!masque)
  {
    uint64_t v68 = nplog_obj(0LL, v30, v31);
    id v69 = (os_log_s *)objc_claimAutoreleasedReturnValue(v68);
    if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", buf, 0xCu);
    }

    id v32 = 0LL;
    uint64_t v54 = 0LL;
    uint64_t v61 = v75;
    goto LABEL_44;
  }

  id v32 = masque;
  id v33 = v76;
  __int128 v73 = v28;
  if ([v33 isEqualToString:@"RFC9298"])
  {
    uint64_t v34 = 2LL;
  }

  else if ([v33 isEqualToString:@"draft-12"])
  {
    uint64_t v34 = 2LL;
  }

  else
  {
    uint64_t v34 = 1LL;
  }

  nw_proxy_hop_set_masque_version(v32, v34);

  if (a5) {
    nw_proxy_hop_set_supports_resumption(v32, 1LL);
  }
  if (a6) {
    nw_proxy_hop_set_use_x25519(v32, 1LL);
  }
  __int128 v80 = 0u;
  __int128 v81 = 0u;
  __int128 v78 = 0u;
  __int128 v79 = 0u;
  id v35 = v77;
  id v36 = [v35 countByEnumeratingWithState:&v78 objects:v84 count:16];
  if (v36)
  {
    id v37 = v36;
    uint64_t v38 = *(void *)v79;
    do
    {
      for (i = 0LL; i != v37; i = (char *)i + 1)
      {
        if (*(void *)v79 != v38) {
          objc_enumerationMutation(v35);
        }
        id v40 = *(void **)(*((void *)&v78 + 1) + 8LL * (void)i);
        if ([v40 length]) {
          nw_proxy_hop_add_server_raw_public_key(v32, [v40 bytes], objc_msgSend(v40, "length"));
        }
      }

      id v37 = [v35 countByEnumeratingWithState:&v78 objects:v84 count:16];
    }

    while (v37);
  }

  uint64_t oblivious_http_with_context = (uint64_t)v75;
  if (v75)
  {
    [v75 getUUIDBytes:buf];
    if (a8) {
      uint64_t v44 = "PrivateToken token=";
    }
    else {
      uint64_t v44 = "PrivacyToken token=";
    }
    uint64_t oblivious_http_with_context = nw_proxy_hop_add_token_header(v32, "proxy-authorization", v44, "", buf);
  }

  if (a12 > 1)
  {
    if (a12 != 2)
    {
LABEL_40:
      uint64_t v59 = nplog_obj(oblivious_http_with_context, v41, v42);
      uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVe"
              "rsion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfi"
              "g:obliviousPath:obliviousHTTPType:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_FAULT,  "%s called with null obliviousHop",  buf,  0xCu);
      }

      uint64_t v54 = 0LL;
      goto LABEL_43;
    }

    uint64_t oblivious_http_with_context = nw_proxy_hop_create_oblivious_http_with_context( [v20 bytes],  objc_msgSend(v20, "length"),  objc_msgSend(v24, "UTF8String"),  0);
    uint64_t v45 = (void *)oblivious_http_with_context;
  }

  else
  {
    uint64_t oblivious_http_with_context = nw_proxy_hop_create_oblivious_http( [v20 bytes],  objc_msgSend(v20, "length"),  objc_msgSend(v24, "UTF8String"));
    uint64_t v45 = (void *)oblivious_http_with_context;
    if (a12 == 1) {
      uint64_t oblivious_http_with_context = nw_proxy_hop_set_enable_chunked_oblivious_http(oblivious_http_with_context, 1LL);
    }
  }

  if (!v45) {
    goto LABEL_40;
  }
  uint64_t v46 = nw_array_create(oblivious_http_with_context);
  uint64_t v49 = (void *)v46;
  if (!v46)
  {
    uint64_t v70 = nplog_obj(0LL, v47, v48);
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }

    goto LABEL_64;
  }

  nw_array_append(v46, v32);
  nw_array_append(v49, v45);
  uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy(v49);
  uint64_t v53 = (os_log_s *)fallback_privacy_proxy;
  if (!fallback_privacy_proxy)
  {
    uint64_t v71 = nplog_obj(0LL, v51, v52);
    __int128 v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v83 = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration:proxyKeyArray:proxyVers"
            "ion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandardToken:shouldFailOpen:obliviousConfig:ob"
            "liviousPath:obliviousHTTPType:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
    }

LABEL_64:
    uint64_t v54 = 0LL;
    goto LABEL_39;
  }

  uint64_t v54 = 1LL;
  nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 1LL, a9);
  uint64_t v55 = nw_proxy_config_copy_agent_data(v53);
  uint64_t v56 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v55;

  sub_1000453F8((id *)a1, v57, v58);
LABEL_39:

LABEL_43:
  uint64_t v61 = v75;
  uint64_t v28 = v73;
LABEL_44:

  id v19 = v74;
LABEL_45:

LABEL_46:
  return v54;
}

  id v74 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.trustd.TrustURLSession",  1,  0);
  id v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
  if (v75) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v75);
  }

  if ((v21 & 0x4000) == 0)
  {
LABEL_31:
    if ((v21 & 0x8000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_58;
  }

  -[NSPConfigurationStats setNewsURLResolutionEnabled:](v15, "setNewsURLResolutionEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x10000) == 0)
  {
LABEL_27:
    if ((v12 & 0x800) == 0) {
      goto LABEL_28;
    }
    goto LABEL_54;
  }
}
}

id *sub_100048EB4(id *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a2;
    id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"ProxiedContent-%@",  a3));
    id v10 = sub_10004477C(v4, v8, 0LL, v9, v7);

    uint64_t v4 = v10;
  }

  return v4;
}

BOOL sub_100048F60( id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, int a8, char a9, void *a10, void *a11, char a12, char a13, void *a14, void *a15, void *a16, char a17)
{
  id v124 = a2;
  id v123 = a3;
  id v126 = a4;
  id v119 = a5;
  id v125 = a6;
  id v118 = a7;
  id v23 = a10;
  id v117 = a11;
  id v122 = a14;
  id v121 = a15;
  id obj = a16;
  id v24 = a16;
  uint64_t v27 = v24;
  self = a1;
  if (!a1)
  {
    BOOL v77 = 0LL;
    id v33 = v123;
    uint64_t v28 = v124;
    goto LABEL_84;
  }

  uint64_t v28 = v124;
  if (!v124)
  {
    uint64_t v103 = nplog_obj(v24, v25, v26);
    id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v103);
    id v33 = v123;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxyURL",  buf,  0xCu);
    }

    BOOL v77 = 0LL;
    goto LABEL_83;
  }

  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v124 UTF8String]);
  id v32 = url;
  id v33 = v123;
  if (!url)
  {
    uint64_t v104 = nplog_obj(0LL, v30, v31);
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v104);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxyEndpoint",  buf,  0xCu);
    }

    BOOL v77 = 0LL;
    goto LABEL_82;
  }

  masque = (os_log_s *)nw_proxy_hop_create_masque(url);
  id v37 = masque;
  if (!masque)
  {
    uint64_t v105 = nplog_obj(0LL, v35, v36);
    id v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxy",  buf,  0xCu);
    }

    BOOL v77 = 0LL;
    goto LABEL_81;
  }

  uint64_t v38 = masque;
  id v39 = v125;
  if ([v39 isEqualToString:@"RFC9298"])
  {
    uint64_t v40 = 2LL;
  }

  else if ([v39 isEqualToString:@"draft-12"])
  {
    uint64_t v40 = 2LL;
  }

  else
  {
    uint64_t v40 = 1LL;
  }

  int v41 = a8;
  __int128 v114 = v37;
  __int128 v116 = v27;
  nw_proxy_hop_set_masque_version(v38, v40);

  if (v41)
  {
    nw_proxy_hop_set_supports_resumption(v38, 1LL);
    *(_OWORD *)__int128 buf = 0uLL;
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([self[2] agentUUID]);
    [v42 getUUIDBytes:buf];

    nw_proxy_hop_set_resumable_session_agent(v38, buf);
  }

  nw_proxy_hop_set_supports_l4s(v38, 1LL);
  nw_proxy_hop_set_use_x25519(v38, 1LL);
  CFPropertyListRef v43 = CFPreferencesCopyAppValue(@"NSPEnableMultipath", kCFPreferencesCurrentApplication);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  uint64_t v45 = v23;
  if (!v44 || (uint64_t v46 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v44, v46) & 1) == 0))
  {

    if (v123) {
      goto LABEL_19;
    }
    goto LABEL_41;
  }

  id v47 = [v44 BOOLValue];
  int v48 = (int)v47;
  uint64_t v51 = nplog_obj(v47, v49, v50);
  uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v48;
    _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "Detected enable multipath in preferences file: %{public}d",  buf,  8u);
  }

  if (v48) {
    nw_proxy_hop_set_enable_multipath(v38, 1LL);
  }
  if (!v123) {
LABEL_41:
  }
    nw_proxy_hop_add_extra_header(v38, "user-agent", "");
LABEL_19:
  __int128 v137 = 0u;
  __int128 v138 = 0u;
  __int128 v135 = 0u;
  __int128 v136 = 0u;
  id v53 = v126;
  id v54 = [v53 countByEnumeratingWithState:&v135 objects:v141 count:16];
  if (v54)
  {
    id v55 = v54;
    uint64_t v56 = *(void *)v136;
    do
    {
      for (i = 0LL; i != v55; i = (char *)i + 1)
      {
        if (*(void *)v136 != v56) {
          objc_enumerationMutation(v53);
        }
        uint64_t v58 = *(void **)(*((void *)&v135 + 1) + 8LL * (void)i);
        if ([v58 length]) {
          nw_proxy_hop_add_server_raw_public_key(v38, [v58 bytes], objc_msgSend(v58, "length"));
        }
      }

      id v55 = [v53 countByEnumeratingWithState:&v135 objects:v141 count:16];
    }

    while (v55);
  }

  id v23 = v45;
  if (v45)
  {
    [v45 getUUIDBytes:buf];
    if (a12) {
      uint64_t v60 = "PrivateToken token=";
    }
    else {
      uint64_t v60 = "PrivacyToken token=";
    }
    uint64_t v59 = nw_proxy_hop_add_token_header(v38, "proxy-authorization", v60, "", buf);
  }

  uint64_t v61 = nw_array_create(v59);
  if (v61)
  {
    id v64 = (os_log_s *)v61;
    nw_array_append(v61, v38);
    if (!v123)
    {
LABEL_66:
      uint64_t default_privacy_proxy = (void *)nw_proxy_config_create_default_privacy_proxy(v64);
      BOOL v77 = default_privacy_proxy != 0LL;
      if (default_privacy_proxy)
      {
        if (v121)
        {
          [v121 getUUIDBytes:buf];
          nw_proxy_config_set_fallback_proxy_agent(default_privacy_proxy, buf);
        }

        if (a17)
        {
          nw_proxy_config_set_is_privacy_proxy(default_privacy_proxy, 1LL, 0LL);
        }

        else
        {
          nw_proxy_config_set_is_privacy_proxy(default_privacy_proxy, 0LL, 1LL);
          nw_proxy_config_set_use_fast_fallback(default_privacy_proxy, 1LL);
        }

        __int128 v129 = 0u;
        __int128 v130 = 0u;
        __int128 v127 = 0u;
        __int128 v128 = 0u;
        id v89 = v122;
        id v90 = [v89 countByEnumeratingWithState:&v127 objects:v139 count:16];
        if (v90)
        {
          id v91 = v90;
          uint64_t v92 = *(void *)v128;
          do
          {
            for (j = 0LL; j != v91; j = (char *)j + 1)
            {
              if (*(void *)v128 != v92) {
                objc_enumerationMutation(v89);
              }
              id v94 = objc_msgSend(*(id *)(*((void *)&v127 + 1) + 8 * (void)j), "UTF8String", v112);
              uint64_t port = nw_endpoint_get_port(v32);
              host_with_numeric_uint64_t port = (void *)nw_endpoint_create_host_with_numeric_port(v94, port);
              nw_proxy_config_add_resolved_endpoint(default_privacy_proxy, host_with_numeric_port);
            }

            id v91 = [v89 countByEnumeratingWithState:&v127 objects:v139 count:16];
          }

          while (v91);
        }

        objc_setProperty_atomic(self, v97, default_privacy_proxy, 48LL);
        uint64_t v98 = nw_proxy_config_copy_agent_data(default_privacy_proxy);
        id v99 = self[4];
        self[4] = (id)v98;

        objc_storeStrong(self + 5, obj);
        sub_1000453F8(self, v100, v101);
        id v23 = v45;
      }

      else
      {
        uint64_t v108 = nplog_obj(0LL, v86, v87);
        uint64_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
        if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxy"
                               "HopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                               "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentU"
                               "UID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:r"
                               "esolvedAddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v109,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
        }
      }

      uint64_t v28 = v124;
      id v37 = v114;
      uint64_t v27 = v116;

      id v33 = v123;
      goto LABEL_81;
    }

    uint64_t v65 = (const char *)[v123 UTF8String];
    if (v65 && (uint64_t v65 = (const char *)nw_endpoint_create_url(v65)) != 0LL)
    {
      uint64_t v68 = (char *)v65;
      id v69 = (void *)nw_proxy_hop_create_masque(v65);
      if (v69)
      {
        uint64_t v112 = v68;
        id v72 = v69;
        id v73 = v118;
        if ([v73 isEqualToString:@"RFC9298"])
        {
          uint64_t v74 = 2LL;
        }

        else if (objc_msgSend(v73, "isEqualToString:", @"draft-12", v68, a16))
        {
          uint64_t v74 = 2LL;
        }

        else
        {
          uint64_t v74 = 1LL;
        }

        nw_proxy_hop_set_masque_version(v72, v74);

        if (a9)
        {
          nw_proxy_hop_set_supports_resumption(v72, 1LL);
          *(_OWORD *)__int128 buf = 0uLL;
          __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([self[2] agentUUID]);
          [v78 getUUIDBytes:buf];

          nw_proxy_hop_set_resumable_session_agent(v72, buf);
        }

        nw_proxy_hop_set_supports_l4s(v72, 1LL);
        nw_proxy_hop_set_use_x25519(v72, 1LL);
        nw_proxy_hop_add_extra_header(v72, "user-agent", "");
        __int128 v133 = 0u;
        __int128 v134 = 0u;
        __int128 v131 = 0u;
        __int128 v132 = 0u;
        id v79 = v119;
        id v80 = [v79 countByEnumeratingWithState:&v131 objects:v140 count:16];
        if (v80)
        {
          id v81 = v80;
          uint64_t v82 = *(void *)v132;
          do
          {
            for (k = 0LL; k != v81; k = (char *)k + 1)
            {
              if (*(void *)v132 != v82) {
                objc_enumerationMutation(v79);
              }
              id v84 = *(void **)(*((void *)&v131 + 1) + 8LL * (void)k);
              if (objc_msgSend(v84, "length", v112)) {
                nw_proxy_hop_add_server_raw_public_key(v72, [v84 bytes], objc_msgSend(v84, "length"));
              }
            }

            id v81 = [v79 countByEnumeratingWithState:&v131 objects:v140 count:16];
          }

          while (v81);
        }

        if (v117)
        {
          [v117 getUUIDBytes:buf];
          if (a13) {
            id v85 = "PrivateToken token=";
          }
          else {
            id v85 = "PrivacyToken token=";
          }
          nw_proxy_hop_add_token_header(v72, "proxy-authorization", v85, "", buf);
        }

        nw_array_append(v64, v72);

        id v23 = v45;
        goto LABEL_66;
      }

      uint64_t v110 = nplog_obj(0LL, v70, v71);
      uint64_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue(v110);
      if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHo"
                             "pURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersio"
                             "n:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:eg"
                             "ressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedA"
                             "ddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_FAULT,  "%s called with null secondHopProxy",  buf,  0xCu);
      }
    }

    else
    {
      uint64_t v75 = nplog_obj(v65, v66, v67);
      id v76 = (os_log_s *)objc_claimAutoreleasedReturnValue(v75);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHo"
                             "pURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersio"
                             "n:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:eg"
                             "ressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedA"
                             "ddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_FAULT,  "%s called with null secondHopProxyEndpoint",  buf,  0xCu);
      }
    }
  }

  else
  {
    uint64_t v106 = nplog_obj(0LL, v62, v63);
    uint64_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);
    if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }

    id v64 = 0LL;
  }

  BOOL v77 = 0LL;
  uint64_t v28 = v124;
  id v37 = v114;
  uint64_t v27 = v116;
LABEL_81:

LABEL_82:
LABEL_83:

LABEL_84:
  return v77;
}

id *sub_100049A04(id *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a2;
    id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"ProxiedContentFallback-%@",  a3));
    id v10 = sub_10004477C(v4, v8, 0LL, v9, v7);

    uint64_t v4 = v10;
  }

  return v4;
}

BOOL sub_100049AB0( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, int a8, char a9, void *a10, void *a11, char a12, char a13, char a14)
{
  id v21 = a2;
  id v22 = a3;
  id v23 = a4;
  id v99 = a5;
  id v24 = a6;
  id v98 = a7;
  id v25 = a10;
  id v26 = a11;
  SEL v97 = v26;
  if (!a1)
  {
    BOOL v64 = 0LL;
    goto LABEL_69;
  }

  if (!v21)
  {
    uint64_t v81 = nplog_obj(v26, v27, v28);
    id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxyURL",  buf,  0xCu);
    }

    BOOL v64 = 0LL;
    goto LABEL_68;
  }

  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v21 UTF8String]);
  id v32 = url;
  if (!url)
  {
    uint64_t v82 = nplog_obj(0LL, v30, v31);
    uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxyEndpoint",  buf,  0xCu);
    }

    BOOL v64 = 0LL;
    goto LABEL_67;
  }

  masque = (os_log_s *)nw_proxy_hop_create_masque(url);
  uint64_t v36 = masque;
  id v93 = v24;
  if (!masque)
  {
    uint64_t v83 = nplog_obj(0LL, v34, v35);
    uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_FAULT,  "%s called with null firstHopProxy",  buf,  0xCu);
    }

    BOOL v64 = 0LL;
    goto LABEL_66;
  }

  id v91 = masque;
  uint64_t v92 = v32;
  id v95 = v25;
  id v37 = masque;
  id v38 = v24;
  if ([v38 isEqualToString:@"RFC9298"])
  {
    uint64_t v39 = 2LL;
  }

  else if ([v38 isEqualToString:@"draft-12"])
  {
    uint64_t v39 = 2LL;
  }

  else
  {
    uint64_t v39 = 1LL;
  }

  nw_proxy_hop_set_masque_version(v37, v39);

  if (a8) {
    nw_proxy_hop_set_supports_resumption(v37, 1LL);
  }
  nw_proxy_hop_set_supports_l4s(v37, 1LL);
  uint64_t v96 = v22;
  if (!v22) {
    nw_proxy_hop_add_extra_header(v37, "user-agent", "");
  }
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v104 = 0u;
  __int128 v105 = 0u;
  id v94 = v23;
  id v40 = v23;
  id v41 = [v40 countByEnumeratingWithState:&v104 objects:v111 count:16];
  if (v41)
  {
    id v42 = v41;
    uint64_t v43 = *(void *)v105;
    do
    {
      for (i = 0LL; i != v42; i = (char *)i + 1)
      {
        if (*(void *)v105 != v43) {
          objc_enumerationMutation(v40);
        }
        uint64_t v45 = *(void **)(*((void *)&v104 + 1) + 8LL * (void)i);
        if ([v45 length]) {
          nw_proxy_hop_add_server_raw_public_key(v37, [v45 bytes], objc_msgSend(v45, "length"));
        }
      }

      id v42 = [v40 countByEnumeratingWithState:&v104 objects:v111 count:16];
    }

    while (v42);
  }

  id v25 = v95;
  if (v95)
  {
    [v95 getUUIDBytes:buf];
    if (a12) {
      id v47 = "PrivateToken token=";
    }
    else {
      id v47 = "PrivacyToken token=";
    }
    uint64_t v46 = nw_proxy_hop_add_token_header(v37, "proxy-authorization", v47, "", buf);
  }

  uint64_t v48 = nw_array_create(v46);
  id v22 = v96;
  if (!v48)
  {
    uint64_t v84 = nplog_obj(0LL, v49, v50);
    id v85 = (os_log_s *)objc_claimAutoreleasedReturnValue(v84);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_FAULT,  "%s called with null proxyHopArray",  buf,  0xCu);
    }

    uint64_t v51 = 0LL;
    BOOL v64 = 0LL;
    id v23 = v94;
    goto LABEL_65;
  }

  uint64_t v51 = (os_log_s *)v48;
  nw_array_append(v48, v37);
  id v23 = v94;
  if (!v96) {
    goto LABEL_59;
  }
  uint64_t v52 = (const char *)[v96 UTF8String];
  if (v52 && (uint64_t v52 = (const char *)nw_endpoint_create_url(v52)) != 0LL)
  {
    id v55 = (char *)v52;
    uint64_t v56 = (void *)nw_proxy_hop_create_masque(v52);
    if (v56)
    {
      id v59 = v56;
      id v60 = v98;
      if ([v60 isEqualToString:@"RFC9298"])
      {
        uint64_t v61 = 2LL;
      }

      else if ([v60 isEqualToString:@"draft-12"])
      {
        uint64_t v61 = 2LL;
      }

      else
      {
        uint64_t v61 = 1LL;
      }

      id v90 = v21;
      nw_proxy_hop_set_masque_version(v59, v61);

      if (a9) {
        nw_proxy_hop_set_supports_resumption(v59, 1LL);
      }
      nw_proxy_hop_set_supports_l4s(v59, 1LL);
      nw_proxy_hop_add_extra_header(v59, "user-agent", "");
      __int128 v102 = 0u;
      __int128 v103 = 0u;
      __int128 v100 = 0u;
      __int128 v101 = 0u;
      id v65 = v99;
      id v66 = [v65 countByEnumeratingWithState:&v100 objects:v108 count:16];
      if (v66)
      {
        id v67 = v66;
        uint64_t v68 = *(void *)v101;
        do
        {
          for (j = 0LL; j != v67; j = (char *)j + 1)
          {
            if (*(void *)v101 != v68) {
              objc_enumerationMutation(v65);
            }
            uint64_t v70 = *(void **)(*((void *)&v100 + 1) + 8LL * (void)j);
            if (objc_msgSend(v70, "length", v90)) {
              nw_proxy_hop_add_server_raw_public_key(v59, [v70 bytes], objc_msgSend(v70, "length"));
            }
          }

          id v67 = [v65 countByEnumeratingWithState:&v100 objects:v108 count:16];
        }

        while (v67);
      }

      if (v97)
      {
        [v97 getUUIDBytes:buf];
        if (a13) {
          uint64_t v71 = "PrivateToken token=";
        }
        else {
          uint64_t v71 = "PrivacyToken token=";
        }
        nw_proxy_hop_add_token_header(v59, "proxy-authorization", v71, "", buf);
      }

      nw_array_append(v51, v59);

      id v21 = v90;
      id v25 = v95;
      id v22 = v96;
      id v23 = v94;
LABEL_59:
      uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy(v51);
      uint64_t v75 = (void *)fallback_privacy_proxy;
      BOOL v64 = fallback_privacy_proxy != 0;
      if (fallback_privacy_proxy)
      {
        if (a14)
        {
          nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 1LL, 0LL);
        }

        else
        {
          nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 0LL, 1LL);
          nw_proxy_config_set_use_fast_fallback(v75, 1LL);
        }

        uint64_t v76 = nw_proxy_config_copy_agent_data(v75);
        BOOL v77 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v76;

        sub_1000453F8((id *)a1, v78, v79);
      }

      else
      {
        uint64_t v86 = nplog_obj(0LL, v73, v74);
        uint64_t v87 = (os_log_s *)objc_claimAutoreleasedReturnValue(v86);
        if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL"
                 ":firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopS"
                 "upportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProx"
                 "yHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_FAULT,  "%s called with null proxyConfiguration",  buf,  0xCu);
        }
      }

      goto LABEL_65;
    }

    uint64_t v88 = nplog_obj(0LL, v57, v58);
    id v89 = (os_log_s *)objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_FAULT,  "%s called with null secondHopProxy",  buf,  0xCu);
    }
  }

  else
  {
    uint64_t v62 = nplog_obj(v52, v53, v54);
    uint64_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue(v62);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v110 = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
             "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHopSupportsR"
             "esumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStan"
             "dardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_FAULT,  "%s called with null secondHopProxyEndpoint",  buf,  0xCu);
    }
  }

  BOOL v64 = 0LL;
LABEL_65:
  uint64_t v36 = v91;
  id v32 = v92;
LABEL_66:

  id v24 = v93;
LABEL_67:

LABEL_68:
LABEL_69:

  return v64;
}

void sub_10004A8DC(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v3 = -[NSPEventsDenormalizer initWithMLModel:]( objc_alloc(&OBJC_CLASS___NSPEventsDenormalizer),  "initWithMLModel:",  v4);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
}

id *sub_10004ACA8(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v17.receiver = a1;
    v17.super_class = (Class)&OBJC_CLASS___NSPPvDConfigurationFetcher;
    a1 = (id *)objc_msgSendSuper2(&v17, "init");
    if (a1)
    {
      id v7 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
      id v8 = a1[2];
      a1[2] = v7;

      uint64_t v10 = NPGetInternalQueue(v9);
      id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      [a1[2] setUnderlyingQueue:v11];

      unsigned __int8 v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
      [v12 setWaitsForConnectivity:1];
      id v13 = a1[2];
      uint64_t v14 = objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v12,  a1,  v13));
      id v15 = a1[1];
      a1[1] = (id)v14;

      objc_storeWeak(a1 + 3, v5);
      objc_storeWeak(a1 + 4, v6);
    }
  }

  return a1;
}

LABEL_31:
        continue;
      }

      id v20 = v18;
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"protocol"]);
      id v22 = (id)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"proxy"]);
      if (!v21) {
        goto LABEL_30;
      }
      id v23 = objc_opt_class(&OBJC_CLASS___NSString);
      if ((objc_opt_isKindOfClass(v21, v23) & 1) == 0) {
        goto LABEL_30;
      }
      if (!v22) {
        goto LABEL_30;
      }
      id v24 = objc_opt_class(&OBJC_CLASS___NSString);
      if ((objc_opt_isKindOfClass(v22, v24) & 1) == 0) {
        goto LABEL_30;
      }
      id v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v22));
      id v26 = v25;
      if (v25)
      {
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v25 host]);
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v26 path]);
        if (([v28 containsString:@"masque"] & 1) == 0)
        {

          id v11 = v78;
LABEL_28:

LABEL_29:
          uint64_t v16 = v77;
LABEL_30:

          goto LABEL_31;
        }

        uint64_t v76 = [v21 isEqualToString:@"connect-udp"];

        id v11 = v78;
        if (!v76) {
          goto LABEL_29;
        }
        uint64_t v29 = v26;

        uint64_t v74 = 1;
        uint64_t v75 = v29;
        uint64_t v16 = v77;
        id v11 = v78;
      }

      if (v26) {
        goto LABEL_34;
      }
    }

    uint64_t v14 = [v16 countByEnumeratingWithState:&v79 objects:v85 count:16];
    if (v14) {
      continue;
    }
    break;
  }
}

    goto LABEL_8;
  }

  id v20 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  id v21 = (void *)*((void *)v2 + 10);
  *((void *)v2 + 10) = v20;

  *((_DWORD *)v2 + 7) = 0;
  id v22 = (dispatch_source_s *)*((void *)v2 + 30);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10006340C;
  handler[3] = &unk_1000F9450;
  id v23 = v2;
  uint64_t v70 = v23;
  dispatch_source_set_event_handler(v22, handler);
  dispatch_resume(*((dispatch_object_t *)v2 + 30));
  mach_service = xpc_connection_create_mach_service( (const char *)[@"com.apple.networkserviceproxy" UTF8String],  0,  1uLL);
  id v25 = (void *)v23[31];
  v23[31] = mach_service;

  id v26 = xpc_connection_create_mach_service("com.apple.networkserviceproxy.fetch-token", 0LL, 1uLL);
  uint64_t v27 = (void *)v23[32];
  v23[32] = v26;

  uint64_t v28 = (void *)v23[31];
  if (v28)
  {
    if (xpc_get_type(v28) == (xpc_type_t)&_xpc_type_connection)
    {
      uint64_t v30 = (void *)v23[32];
      if (v30)
      {
        type = xpc_get_type(v30);
        if (type == (xpc_type_t)&_xpc_type_connection)
        {
          id v32 = (_xpc_connection_s *)v23[31];
          id v33 = NPGetInternalQueue(type);
          uint64_t v34 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v33);
          xpc_connection_set_target_queue(v32, v34);

          uint64_t v35 = (_xpc_connection_s *)v23[31];
          v67[0] = _NSConcreteStackBlock;
          v67[1] = 3221225472LL;
          v67[2] = sub_1000634A0;
          v67[3] = &unk_1000F9FE0;
          uint64_t v36 = v23;
          uint64_t v68 = v36;
          xpc_connection_set_event_handler(v35, v67);
          id v37 = (_xpc_connection_s *)v23[32];
          uint64_t v39 = NPGetInternalQueue(v38);
          id v40 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v39);
          xpc_connection_set_target_queue(v37, v40);

          id v41 = (_xpc_connection_s *)v23[32];
          uint64_t v62 = _NSConcreteStackBlock;
          uint64_t v63 = 3221225472LL;
          BOOL v64 = sub_1000636C4;
          id v65 = &unk_1000F9FE0;
          id v42 = v36;
          id v66 = v42;
          xpc_connection_set_event_handler(v41, &v62);
          id inited = objc_initWeak(&location, v42);
          uint64_t v44 = NPGetInternalQueue(inited);
          uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
          *(void *)&__int128 buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472LL;
          uint64_t v74 = sub_100075430;
          uint64_t v75 = &unk_1000FA4B0;
          objc_copyWeak(&v76, &location);
          os_state_add_handler(v45, &buf);

          objc_destroyWeak(&v76);
          objc_destroyWeak(&location);
          objc_opt_self(&OBJC_CLASS___NSPServer);
          if (os_variant_allows_internal_security_policies("com.apple.networkserviceproxy"))
          {
            uint64_t v46 = CFPreferencesCopyAppValue(@"NSPOutageIntervalSeconds", kCFPreferencesCurrentApplication);
            id v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
            if (v47
              && (uint64_t v48 = objc_opt_class(&OBJC_CLASS___NSNumber),
                  char isKindOfClass = objc_opt_isKindOfClass(v47, v48),
                  (isKindOfClass & 1) != 0))
            {
              uint64_t v52 = nplog_obj(isKindOfClass, v50, v51);
              uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v47;
                _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "Detected outage interval in preferences file: %{public}@",  (uint8_t *)&buf,  0xCu);
              }

              uint64_t v54 = objc_msgSend(v47, "unsignedIntegerValue", v62, v63, v64, v65);
            }

            else
            {
              uint64_t v54 = 0LL;
            }
          }

          else
          {
            uint64_t v54 = 0LL;
          }

          v42[38] = v54;
          id v55 = objc_alloc_init(&OBJC_CLASS___NSPToggleStats);
          uint64_t v56 = (void *)v42[41];
          v42[41] = v55;

          goto LABEL_21;
        }
      }
    }
  }

LABEL_8:
  uint64_t v29 = 0LL;
LABEL_22:

  return v29;
}

LABEL_34:
  id v7 = v73;
  id v37 = v75;
  if ((v74 & 1) == 0) {
    goto LABEL_37;
  }
LABEL_40:
  id v40 = v37;
  uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"https://%@:443",  v11));
  id v41 = v11;
  id v42 = (void *)objc_claimAutoreleasedReturnValue([v7 port]);

  if (v42)
  {
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v7 port]);
    uint64_t v44 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"https://%@:%@", v41, v43));

    uint64_t v39 = (os_log_s *)v44;
  }

  uint64_t v45 = (id)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v39));
  uint64_t v48 = v45;
  if (v45)
  {
    if (v72
      && (uint64_t v45 = objc_loadWeakRetained((id *)&v72->_serverDelegate)) != 0LL
      && (uint64_t v49 = v45,
          uint64_t v50 = objc_loadWeakRetained((id *)&v72->_serverDelegate),
          uint64_t v51 = objc_opt_respondsToSelector(v50, "networkDiscoveredProxyInTrustedProxyList:"),
          v50,
          v49,
          (v51 & 1) != 0))
    {
      id WeakRetained = objc_loadWeakRetained((id *)&v72->_serverDelegate);
      uint64_t v53 = [WeakRetained networkDiscoveredProxyInTrustedProxyList:v48];

      uint64_t v57 = nplog_obj(v54, v55, v56);
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
      id v59 = v58;
      if (v53)
      {
        id v11 = v78;
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "proxyURL found, setting up configuration",  buf,  2u);
        }

        id v37 = v40;
        id v60 = (os_log_s *)objc_claimAutoreleasedReturnValue([v40 path]);
        id v59 = v60;
        id v7 = v73;
        if (v60
          && ((-[os_log_s containsString:](v60, "containsString:", @"/.well-known/masque/udp") & 1) != 0
           || -[os_log_s containsString:](v59, "containsString:", @"masque")))
        {
          uint64_t v61 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyProxyInfo);
          -[NSPPrivacyProxyProxyInfo setProxyURL:](v61, "setProxyURL:", v39);
          -[NSPPrivacyProxyProxyInfo setProxyVersion:](v61, "setProxyVersion:", @"RFC9298");
          -[NSPPrivacyProxyProxyInfo setProxyHop:](v61, "setProxyHop:", 1LL);
          -[NSPPrivacyProxyProxyInfo setSupportsFallback:](v61, "setSupportsFallback:", 0LL);
          -[NSPPrivacyProxyProxyInfo setVendor:](v61, "setVendor:", v78);
          -[NSPPrivacyProxyProxyInfo setTcpProxyFqdn:](v61, "setTcpProxyFqdn:", v39);
          uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
          -[NSPPrivacyProxyProxyInfo setTokenKeyInfo:](v61, "setTokenKeyInfo:", v62);

          p_delegate = (id *)&v72->_delegate;
          BOOL v64 = objc_loadWeakRetained((id *)&v72->_delegate);
          if (v64)
          {
            id v65 = v64;
            id v66 = objc_loadWeakRetained(p_delegate);
            id v67 = objc_opt_respondsToSelector(v66, "setupMasqueProxyWith:");

            if ((v67 & 1) != 0)
            {
              uint64_t v68 = objc_loadWeakRetained(p_delegate);
              [v68 setupMasqueProxyWith:v61];
            }
          }

          id v7 = v73;
LABEL_59:
          id v11 = v78;
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      id v11 = v78;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v84 = v48;
        uint64_t v71 = "proxyURL not found in the allow list: %@";
        goto LABEL_68;
      }
    }

    else
    {
      id v69 = nplog_obj(v45, v46, v47);
      id v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(v69);
      id v11 = v78;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v84 = v48;
        uint64_t v71 = "Something went wrong. Could not confirm the proxyURL: %@";
LABEL_68:
        _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, v71, buf, 0xCu);
      }
    }

    id v7 = v73;
    goto LABEL_60;
  }

  uint64_t v70 = nplog_obj(0LL, v46, v47);
  id v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
  if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
    goto LABEL_59;
  }
  *(_DWORD *)__int128 buf = 138412290;
  id v11 = v78;
  uint64_t v84 = v78;
  _os_log_error_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_ERROR,  "Could not create a proxyURL from identifier: %@",  buf,  0xCu);
LABEL_60:
  id v37 = v40;
LABEL_61:

LABEL_62:
LABEL_63:

LABEL_64:
}

  uint64_t v36 = *(void *)(a1 + 72);
  if (v36) {
    (*(void (**)(uint64_t, uint64_t))(v36 + 16))(v36, a2);
  }
  id v37 = *(void *)(*(void *)(a1 + 80) + 8LL);
  id v38 = *(void **)(v37 + 40);
  *(void *)(v37 + 40) = 0LL;
}

    os_unfair_lock_lock(v27);
    uint64_t v39 = *(unsigned __int8 *)(a1 + 21);
    os_unfair_lock_unlock(v27);
    sub_100073B98(a1, v39 == 0);
    return;
  }

  objc_super v17 = nplog_obj(v8, v9, v10);
  id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 138412290;
    *(void *)&buf[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "%@ captive probe timed out",  (uint8_t *)buf,  0xCu);
  }

  if (*(_BYTE *)(a1 + 19)
    || (os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28)),
        id v19 = *(void *)(a1 + 280),
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 28)),
        v19 < 3))
  {
    uint64_t v27 = (os_unfair_lock_s *)(a1 + 28);
    goto LABEL_34;
  }

  id v23 = nplog_obj(v20, v21, v22);
  id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 138412290;
    *(void *)&buf[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "%@ timeout evaluation reached max retry count",  (uint8_t *)buf,  0xCu);
  }

  sub_100073D80(a1);
}

  return v21;
}

void sub_10004BA08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10004BA24(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10004BA34(uint64_t a1)
{
}

void sub_10004BA3C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  id v11 = v8;
  if (v8)
  {
    uint64_t v12 = nplog_obj(v8, v9, v10);
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue([v11 localizedDescription]);
      uint64_t v15 = a1[4];
      *(_DWORD *)__int128 buf = 138543618;
      uint64_t v43 = v14;
      __int16 v44 = 2112;
      uint64_t v45 = v15;
      uint64_t v16 = "Fetching proxy configuration resulted in error: %{public}@ with url: %@";
      objc_super v17 = v13;
      uint32_t v18 = 22;
      goto LABEL_4;
    }
  }

  else
  {
    id v19 = (os_log_s *)[a3 statusCode];
    id v22 = v19;
    if (v7 && v19 == (os_log_s *)200)
    {
      id v41 = 0LL;
      uint64_t v23 = objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v7,  0LL,  &v41));
      id v13 = (os_log_s *)v41;
      uint64_t v24 = *(void *)(a1[6] + 8LL);
      id v25 = *(void **)(v24 + 40);
      *(void *)(v24 + 40) = v23;

      uint64_t v29 = *(void *)(*(void *)(a1[6] + 8LL) + 40LL);
      if (!v29)
      {
        uint64_t v30 = nplog_obj(v26, v27, v28);
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          uint64_t v40 = a1[4];
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v43 = v13;
          __int16 v44 = 2112;
          uint64_t v45 = v40;
          _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Fetching proxy configuration resulted in malformed JSON object: %@ with url: %@",  buf,  0x16u);
        }

        uint64_t v29 = *(void *)(*(void *)(a1[6] + 8LL) + 40LL);
      }

      uint64_t v32 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      uint64_t isKindOfClass = objc_opt_isKindOfClass(v29, v32);
      if ((isKindOfClass & 1) == 0)
      {
        uint64_t v36 = nplog_obj(isKindOfClass, v34, v35);
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_13;
        }
        uint64_t v39 = (os_log_s *)a1[4];
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v43 = v39;
        uint64_t v16 = "Fetching proxy configuration resulted in JSON object that is not a dictionary with url: %@";
        objc_super v17 = v14;
        uint32_t v18 = 12;
LABEL_4:
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
LABEL_13:
      }
    }

    else
    {
      uint64_t v37 = nplog_obj(v19, v20, v21);
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = a1[4];
        *(_DWORD *)__int128 buf = 134218242;
        uint64_t v43 = v22;
        __int16 v44 = 2112;
        uint64_t v45 = v38;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Fetching proxy configuration resulted in unexpected response: %ld with url: %@",  buf,  0x16u);
      }
    }
  }

  (*(void (**)(void))(a1[5] + 16LL))();
}

void sub_10004BCF8(void *a1, void *a2, void *a3)
{
  id v37 = a2;
  id v36 = a3;
  id val = a1;
  if (a1)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKey:@"identifier"]);
    if (v5)
    {
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKey:@"proxies"]);
      if (!v6)
      {

        goto LABEL_40;
      }

      id v7 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKey:@"expires"]);

      if (v7)
      {
        if ([val configurationValidated:v37 withURL:v36])
        {
          id v8 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKey:@"proxies"]);
          uint64_t v38 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          objc_initWeak(&location, val);
          __int128 v55 = 0u;
          __int128 v56 = 0u;
          __int128 v53 = 0u;
          __int128 v54 = 0u;
          id obj = v8;
          id v9 = [obj countByEnumeratingWithState:&v53 objects:v59 count:16];
          if (!v9) {
            goto LABEL_27;
          }
          uint64_t v10 = *(void *)v54;
          while (1)
          {
            for (i = 0LL; i != v9; i = (char *)i + 1)
            {
              if (*(void *)v54 != v10) {
                objc_enumerationMutation(obj);
              }
              uint64_t v12 = *(void **)(*((void *)&v53 + 1) + 8LL * (void)i);
              uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSDictionary);
              if ((objc_opt_isKindOfClass(v12, v13) & 1) != 0)
              {
                id v14 = v12;
                uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"proxy"]);
                if (v15
                  && (uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"proxy"]),
                      uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSString),
                      char isKindOfClass = objc_opt_isKindOfClass(v16, v17),
                      v16,
                      v15,
                      (isKindOfClass & 1) != 0))
                {
                  id v19 = (id)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"proxy"]);
                }

                else
                {
                  id v19 = 0LL;
                }
              }

              else
              {
                uint64_t v20 = objc_opt_class(&OBJC_CLASS___NSString);
                if ((objc_opt_isKindOfClass(v12, v20) & 1) == 0) {
                  continue;
                }
                id v19 = v12;
              }

              if (v19)
              {
                uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v19));
                id v22 = v21;
                if (v21)
                {
                  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v21 host]);
                  BOOL v24 = v23 == 0LL;
                }
              }
            }

            id v9 = [obj countByEnumeratingWithState:&v53 objects:v59 count:16];
            if (!v9)
            {
LABEL_27:

              __int128 v51 = 0u;
              __int128 v52 = 0u;
              __int128 v49 = 0u;
              __int128 v50 = 0u;
              id v25 = v38;
              id v26 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v25,  "countByEnumeratingWithState:objects:count:",  &v49,  v58,  16LL);
              if (v26)
              {
                uint64_t v27 = *(void *)v50;
                do
                {
                  for (j = 0LL; j != v26; j = (char *)j + 1)
                  {
                    if (*(void *)v50 != v27) {
                      objc_enumerationMutation(v25);
                    }
                    uint64_t v29 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)j);
                    if (v29)
                    {
                      uint64_t v30 = objc_alloc_init(&OBJC_CLASS___NSURLComponents);
                      -[NSURLComponents setPath:](v30, "setPath:", @"/.well-known/pvd");
                      -[NSURLComponents setScheme:](v30, "setScheme:", @"https");
                      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v29 port]);
                      BOOL v32 = v31 == 0LL;

                      if (!v32)
                      {
                        id v33 = (void *)objc_claimAutoreleasedReturnValue([v29 port]);
                        -[NSURLComponents setPort:](v30, "setPort:", v33);
                      }

                      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v29 host]);
                      -[NSURLComponents setHost:](v30, "setHost:", v34);

                      uint64_t v43 = 0LL;
                      __int16 v44 = &v43;
                      uint64_t v45 = 0x3032000000LL;
                      uint64_t v46 = sub_10004BA24;
                      id v47 = sub_10004BA34;
                      id v48 = (id)objc_claimAutoreleasedReturnValue(-[NSURLComponents URL](v30, "URL"));
                      uint64_t v35 = v44[5];
                      v41[0] = _NSConcreteStackBlock;
                      v41[1] = 3221225472LL;
                      v41[2] = sub_10004C22C;
                      v41[3] = &unk_1000F9E28;
                      objc_copyWeak(&v42, &location);
                      v41[4] = &v43;
                      [val fetchIndividualProxyConfig:v35 completionHander:v41];
                      objc_destroyWeak(&v42);
                      _Block_object_dispose(&v43, 8);
                    }
                  }

                  id v26 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v25,  "countByEnumeratingWithState:objects:count:",  &v49,  v58,  16LL);
                }

                while (v26);
              }

              objc_destroyWeak(&location);
              break;
            }
          }
        }
      }
    }
  }

void sub_10004C1CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, id location)
{
}

void sub_10004C22C(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v3 = (id *)(a1 + 40);
    id v4 = a2;
    id WeakRetained = objc_loadWeakRetained(v3);
    [WeakRetained didReceiveProxyConfig:v4 from:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];
  }

uint64_t sub_10004C498()
{
  if (qword_100117140 != -1) {
    dispatch_once(&qword_100117140, &stru_1000F9E48);
  }
  return byte_100117138;
}

void sub_10004C4D8(id a1)
{
  int v2 = 0;
  size_t v1 = 4LL;
  if (!sysctlbyname("kern.hv_vmm_present", &v2, &v1, 0LL, 0LL)) {
    byte_100117138 = v2 != 0;
  }
}

uint64_t sub_10004C7FC(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = -[NSKeyedArchiver initRequiringSecureCoding:]( objc_alloc(&OBJC_CLASS___NSKeyedArchiver),  "initRequiringSecureCoding:",  1LL);
  if (!v4)
  {
    uint64_t v13 = nplog_obj(0LL, v2, v3);
    id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    __int16 v19 = 0;
    id v14 = "NSKeyedArchiver initialize failed";
    uint64_t v15 = (uint8_t *)&v19;
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v14, v15, 2u);
    goto LABEL_10;
  }

  [a1 encodeWithCoder:v4];
  _CFPreferencesSetFileProtectionClass( kCFPreferencesCurrentApplication,  kCFPreferencesCurrentUser,  kCFPreferencesCurrentHost,  0LL,  3LL);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(-[NSKeyedArchiver encodedData](v4, "encodedData"));
  CFPreferencesSetAppValue(@"DeviceIdentityInfo", v5, kCFPreferencesCurrentApplication);

  uint64_t v6 = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
  LODWORD(v5) = v6;
  uint64_t v9 = nplog_obj(v6, v7, v8);
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  id v11 = v10;
  if ((_DWORD)v5)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Saved device identity info to preference file",  v17,  2u);
    }

    uint64_t v12 = 1LL;
    goto LABEL_11;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    id v14 = "Failed to write device identity info to preference file";
    uint64_t v15 = buf;
    goto LABEL_14;
  }

void sub_10004CAC8(id a1)
{
  size_t v1 = objc_alloc(&OBJC_CLASS___NSPDeviceIdentityCertificate);
  if (!v1)
  {
    id v5 = 0LL;
    goto LABEL_24;
  }

  v30.receiver = v1;
  v30.super_class = (Class)&OBJC_CLASS___NSPDeviceIdentityCertificate;
  uint64_t v2 = objc_msgSendSuper2(&v30, "init");
  if (!v2)
  {
    uint64_t v28 = nplog_obj(0LL, v3, v4);
    id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
    }

    id v5 = 0LL;
    goto LABEL_23;
  }

  id v5 = v2;
  CFPropertyListRef v6 = CFPreferencesCopyAppValue(@"DeviceIdentityInfo", kCFPreferencesCurrentApplication);
  if (!v6)
  {
    uint64_t v18 = nplog_obj(0LL, v7, v8);
    id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "no saved device identity info", buf, 2u);
    }

    goto LABEL_23;
  }

  uint64_t v9 = v6;
  id v29 = 0LL;
  uint64_t v10 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v6,  &v29);
  id v11 = (os_log_s *)v29;
  id v14 = v11;
  if (v10) {
    BOOL v15 = v11 == 0LL;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15)
  {
    uint64_t v16 = nplog_obj(v11, v12, v13);
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      BOOL v32 = v14;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Failed to create a decoder for the device identity info: %@",  buf,  0xCu);
    }

    CFRelease(v9);
LABEL_22:

    goto LABEL_23;
  }

  CFRelease(v9);
  __int16 v19 = [v5 initWithCoder:v10];
  if (!v19)
  {
    uint64_t v22 = nplog_obj(0LL, v20, v21);
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Failed to decode device identity info",  buf,  2u);
    }

    id v5 = 0LL;
    goto LABEL_22;
  }

  id v5 = v19;
  if (v19[2] != 1LL)
  {
    uint64_t v24 = nplog_obj(v19, v20, v21);
    id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      id v26 = (os_log_s *)v5[2];
      *(_DWORD *)__int128 buf = 134218240;
      BOOL v32 = v26;
      __int16 v33 = 2048;
      uint64_t v34 = 1LL;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "Saved disk version of device identity info (%ld) does not match latest supported version (%ld)",  buf,  0x16u);
    }

    id v5 = [v5 init];
    goto LABEL_22;
  }

  id v14 = (os_log_s *)v10;
LABEL_23:

LABEL_24:
  uint64_t v27 = (void *)qword_100117148;
  qword_100117148 = (uint64_t)v5;
}

void sub_10004D38C(_Unwind_Exception *a1)
{
}

void sub_10004D3D8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue(v9);
  id v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
  dispatch_assert_queue_V2(v11);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  BOOL v15 = WeakRetained;
  if (WeakRetained)
  {
    if (v7 && v8 && !v9)
    {
      uint64_t v16 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
    }

    else
    {
      uint64_t v17 = nplog_obj(WeakRetained, v13, v14);
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v19 = 138412290;
        id v20 = v9;
        _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "failed to sign data from host with error %@",  (uint8_t *)&v19,  0xCu);
      }

      uint64_t v16 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
    }

    v16();
  }
}

void sub_10004D514(uint64_t a1, __SecKey *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = NPGetInternalQueue(v8);
  uint64_t v10 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v9);
  dispatch_assert_queue_V2(v10);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSPDeviceIdentityStats);
    uint64_t v15 = nplog_obj(v12, v13, v14);
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    uint64_t v17 = v16;
    if (v8)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFErrorRef v53 = v8;
        _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "device identity request failed with error: %@",  buf,  0xCu);
      }

      uint64_t v18 = MobileActivationErrorDomain;
      if ((mobileactivationErrorHasDomainAndErrorCode(v8, MobileActivationErrorDomain, -8LL) & 1) == 0
        && (mobileactivationErrorHasDomainAndErrorCode(v8, v18, -6LL) & 1) == 0
        && (mobileactivationErrorHasDomainAndErrorCode(v8, v18, -24LL) & 1) == 0)
      {
        int v19 = *(id **)(a1 + 40);
        if (v19)
        {
          id v20 = v19[3];
          if (!v20
            || (uint64_t v21 = v20, [v19[3] timeIntervalSinceNow], v23 = v22, v21, v23 < 0.0))
          {
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            uint32_t v25 = arc4random_uniform(3u);
            id v26 = objc_opt_new(&OBJC_CLASS___NSDateComponents);
            -[NSDateComponents setDay:](v26, "setDay:", v25);
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
            uint64_t v28 = objc_claimAutoreleasedReturnValue([v27 dateByAddingComponents:v26 toDate:v24 options:0]);
            id v29 = v19[3];
            v19[3] = (id)v28;

            uint64_t v33 = nplog_obj(v30, v31, v32);
            uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              __int128 v50 = v24;
              __int128 v49 = v26;
              id v35 = v19[3];
              id v36 = (__CFError *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v35,  1LL,  2LL));
              *(_DWORD *)__int128 buf = 138412290;
              CFErrorRef v53 = v36;
              _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Device identity would be fetched on %@",  buf,  0xCu);

              id v26 = v49;
              uint64_t v24 = v50;
            }

            uint64_t v37 = sub_10004C7FC(v19);
            if ((v37 & 1) == 0)
            {
              uint64_t v40 = nplog_obj(v37, v38, v39);
              id v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_error_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "Failed to write device identity info to file",  buf,  2u);
              }
            }
          }
        }
      }

      -[NSPDeviceIdentityStats setSuccess:](v12, "setSuccess:", 0LL);
      id v42 = (void *)objc_claimAutoreleasedReturnValue(-[__CFError domain](v8, "domain"));
      -[NSPDeviceIdentityStats setErrorDomain:](v12, "setErrorDomain:", v42);

      -[NSPDeviceIdentityStats setErrorCode:](v12, "setErrorCode:", -[__CFError code](v8, "code"));
      (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    }

    else
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "device identity request successful", buf, 2u);
      }

      CFErrorRef error = 0LL;
      CFDataRef v43 = SecKeyCreateSignature(a2, kSecKeyAlgorithmECDSASignatureMessageX962SHA256, *(CFDataRef *)(a1 + 32), &error);
      CFDataRef v46 = v43;
      if (!v43 || error)
      {
        uint64_t v47 = nplog_obj(v43, v44, v45);
        id v48 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFErrorRef v53 = error;
          _os_log_error_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_ERROR,  "failed to sign data with error %@",  buf,  0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
      }

      else
      {
        (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
        -[NSPDeviceIdentityStats setSuccess:](v12, "setSuccess:", 1LL);
      }

      [*(id *)(a1 + 40) resetDeviceIdentityInfo];
    }

    -[NSPProxyAnalytics sendAnalytics](v12, "sendAnalytics");
  }

  if (a2) {
    CFRelease(a2);
  }
}

id *sub_10004D9BC(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v38.receiver = a1;
    v38.super_class = (Class)&OBJC_CLASS___NSPServerODoH;
    uint64_t v10 = (id *)objc_msgSendSuper2(&v38, "init");
    a1 = v10;
    if (v10)
    {
      objc_storeWeak(v10 + 3, v7);
      objc_storeStrong(a1 + 8, a3);
      objc_storeStrong(a1 + 19, a4);
      objc_opt_self(&OBJC_CLASS___NSPServerODoH);
      id v11 = (void *)CFPreferencesCopyAppValue(@"NSPPreferredResolver", kCFPreferencesCurrentApplication);
      if (v11
        && (uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSString),
            uint64_t isKindOfClass = objc_opt_isKindOfClass(v11, v12),
            (isKindOfClass & 1) != 0))
      {
        uint64_t v16 = nplog_obj(isKindOfClass, v14, v15);
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          id v41 = v11;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Detected preferred resolver: %{public}@",  buf,  0xCu);
        }

        id v18 = v11;
      }

      else
      {
        id v18 = 0LL;
      }

      id v19 = a1[2];
      a1[2] = v18;

      objc_opt_self(&OBJC_CLASS___NSPServerODoH);
      id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      id v21 = [v20 copyAuxiliaryDataForKey:@"NSPServerODoHAuxilaryData"];

      if (v21 && (uint64_t v22 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v21, v22) & 1) == 0))
      {
        uint64_t v24 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        uint64_t v25 = objc_opt_class(&OBJC_CLASS___NSString);
        id v26 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v24,  v25,  objc_opt_class(&OBJC_CLASS___NSDate),  0LL);
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
        id v39 = 0LL;
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v27,  v21,  &v39));
        id v29 = v39;

        if (!v28 || v29)
        {
          uint64_t v33 = nplog_obj(v30, v31, v32);
          uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v41 = v29;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_INFO,  "failed to unarchivedObjectOfClasses with error %@",  buf,  0xCu);
          }

          id v23 = 0LL;
        }

        else
        {
          id v23 = v28;
        }

        if (v23)
        {
          uint64_t v35 = objc_claimAutoreleasedReturnValue( [v23 objectForKeyedSubscript:@"NSPServerODoHAuxilaryDataResolverSwitchedDateKey"]);
          id v36 = a1[17];
          a1[17] = (id)v35;
        }
      }

      else
      {

        id v23 = 0LL;
      }
    }
  }

  return a1;
}

id sub_10004DCD8(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    id v2 = *(id *)(a1 + 112);
    id v3 = [v2 countByEnumeratingWithState:&v35 objects:v41 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v36;
      while (2)
      {
        for (i = 0LL; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v36 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = *(void **)(*((void *)&v35 + 1) + 8LL * (void)i);
          id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 dohURL]);
          unsigned __int8 v9 = [v8 isEqualToString:*(void *)(a1 + 16)];

          if ((v9 & 1) != 0)
          {
            id v24 = v7;
            goto LABEL_32;
          }
        }

        id v4 = [v2 countByEnumeratingWithState:&v35 objects:v41 count:16];
        if (v4) {
          continue;
        }
        break;
      }
    }
  }

  id v2 = *(id *)(a1 + 120);
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  id v10 = [v2 countByEnumeratingWithState:&v31 objects:v40 count:16];
  if (v10)
  {
    id v11 = v10;
    int v12 = 0;
    uint64_t v13 = *(void *)v32;
    do
    {
      for (j = 0LL; j != v11; j = (char *)j + 1)
      {
        if (*(void *)v32 != v13) {
          objc_enumerationMutation(v2);
        }
        v12 += [*(id *)(*((void *)&v31 + 1) + 8 * (void)j) weight];
      }

      id v11 = [v2 countByEnumeratingWithState:&v31 objects:v40 count:16];
    }

    while (v11);
    if (v12)
    {
      uint32_t v15 = v12 + 1;
      do
        uint32_t v16 = arc4random_uniform(v15);
      while (!v16);
      uint32_t v17 = v16;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      id v2 = v2;
      id v18 = [v2 countByEnumeratingWithState:&v27 objects:v39 count:16];
      if (v18)
      {
        id v19 = v18;
        uint32_t v20 = 0;
        uint64_t v21 = *(void *)v28;
        while (2)
        {
          for (k = 0LL; k != v19; k = (char *)k + 1)
          {
            if (*(void *)v28 != v21) {
              objc_enumerationMutation(v2);
            }
            id v23 = *(void **)(*((void *)&v27 + 1) + 8LL * (void)k);
            v20 += objc_msgSend(v23, "weight", (void)v27);
            if (v17 <= v20)
            {
              id v25 = v23;

              goto LABEL_33;
            }
          }

          id v19 = [v2 countByEnumeratingWithState:&v27 objects:v39 count:16];
          if (v19) {
            continue;
          }
          break;
        }
      }
    }
  }

  id v24 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "firstObject", (void)v27));
LABEL_32:
  id v25 = v24;
LABEL_33:

  return v25;
}

void sub_10004DF70(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 112);
    id v3 = [v2 mutableCopy];
    id v4 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = v3;

    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v5 = *(id *)(a1 + 120);
    id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v12;
      do
      {
        for (i = 0LL; i != v7; i = (char *)i + 1)
        {
          if (*(void *)v12 != v8) {
            objc_enumerationMutation(v5);
          }
          id v10 = *(void **)(*((void *)&v11 + 1) + 8LL * (void)i);
        }

        id v7 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }

      while (v7);
    }
  }

void sub_10004E09C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Candidate resolver restore timer fired", v8, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained) {
    sub_10004DF70((uint64_t)WeakRetained);
  }
}

void sub_10004E120(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 112), a2);
    sub_10004DF70(a1);
    [*(id *)(a1 + 32) setResolver:0];
  }
}

void sub_10004E178(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      int v10 = 138412290;
      __int128 v11 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "%@ cleaning up DNS network agent",  (uint8_t *)&v10,  0xCu);
    }

    sub_10004E25C((uint64_t)a1);
    id v6 = (void *)a1[4];
    a1[4] = 0LL;

    id v7 = (void *)a1[5];
    a1[5] = 0LL;

    sub_10004E3F8((uint64_t)a1);
    uint64_t v8 = (void *)a1[6];
    a1[6] = 0LL;

    unsigned __int8 v9 = (void *)a1[7];
    a1[7] = 0LL;
  }

uint64_t sub_10004E25C(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = *(dispatch_source_s **)(a1 + 128);
  if (v2)
  {
    dispatch_source_cancel(v2);
    id v3 = *(void **)(a1 + 128);
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  }

  id v4 = *(id *)(a1 + 32);
  if (!v4) {
    return 1LL;
  }
  uint64_t v5 = *(void *)(a1 + 40);

  if (!v5) {
    return 1LL;
  }
  id v6 = [*(id *)(a1 + 40) isRegistered];
  if (!(_DWORD)v6) {
    return 1LL;
  }
  uint64_t v9 = nplog_obj(v6, v7, v8);
  int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    id v11 = *(id *)(a1 + 32);
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 agentUUID]);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v19 = a1;
    __int16 v20 = 2112;
    uint64_t v21 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "%@ un-registering DNS network agent with UUID %@",  buf,  0x16u);
  }

  id v13 = [*(id *)(a1 + 40) unregisterNetworkAgent];
  __int128 v14 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_10004FE6C;
  v17[3] = &unk_1000F9370;
  void v17[4] = a1;
  [v14 removeFileHandleMatchingPredicate:v17];

  uint32_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v15 commit];

  return (uint64_t)v13;
}

void sub_10004E3F8(uint64_t a1)
{
  id v2 = *(id *)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 56);

    if (v3)
    {
      id v4 = [*(id *)(a1 + 56) isRegistered];
      if ((_DWORD)v4)
      {
        uint64_t v7 = nplog_obj(v4, v5, v6);
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          id v9 = *(id *)(a1 + 48);
          int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 agentUUID]);
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v15 = a1;
          __int16 v16 = 2112;
          uint32_t v17 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "%@ un-registering bootstrap DNS network agent with UUID %@",  buf,  0x16u);
        }

        [*(id *)(a1 + 56) unregisterNetworkAgent];
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472LL;
        _DWORD v13[2] = sub_10004FF48;
        v13[3] = &unk_1000F9370;
        v13[4] = a1;
        [v11 removeFileHandleMatchingPredicate:v13];

        __int128 v12 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        [v12 commit];
      }
    }
  }

uint64_t sub_10004E560(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_49;
  }
  if (!v3)
  {
    sub_10004E3F8(a1);
    objc_storeStrong((id *)(a1 + 48), 0LL);
    objc_storeStrong((id *)(a1 + 56), 0LL);
LABEL_17:
    a1 = 1LL;
    goto LABEL_49;
  }

  uint64_t v6 = (id *)(a1 + 48);
  uint64_t v5 = *(void **)(a1 + 48);
  if (!v5)
  {
    uint64_t v7 = -[NSPPrivacyProxyDNSAgent initWithDelegate:]( objc_alloc(&OBJC_CLASS___NSPPrivacyProxyBootstrapDNSAgent),  "initWithDelegate:",  a1);
    objc_storeStrong((id *)(a1 + 48), v7);

    uint64_t v8 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyBootstrapDNSAgent));
    objc_storeStrong((id *)(a1 + 56), v8);

    uint64_t v5 = *(void **)(a1 + 48);
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 resolver]);

  if (!v9) {
    [*v6 setResolver:v4];
  }
  int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager singleHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "singleHopProxyAgentUUID"));
  [*v6 setProxyAgentUUID:v10];

  uint64_t v14 = nplog_obj(v11, v12, v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    id v16 = *(id *)(a1 + 48);
    uint32_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 resolver]);
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 dohURL]);
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "%@ setting up bootstrap DNS network agent to %{public}@",  buf,  0x16u);
  }

  id v19 = [*(id *)(a1 + 56) isRegistered];
  if (!(_DWORD)v19)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000LL;
    id v121 = sub_10004EF88;
    id v122 = sub_10004EF98;
    id v123 = 0LL;
    uint64_t v33 = nplog_obj(v19, v20, v21);
    __int128 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      id v35 = *v6;
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v35 agentUUID]);
      *(_DWORD *)__int128 v114 = 138412546;
      uint64_t v115 = a1;
      __int16 v116 = 2112;
      id v117 = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_INFO,  "%@ looking for bootstrap DNS network agent registration file handle with agent UUID %@",  v114,  0x16u);
    }

    __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    v113[0] = _NSConcreteStackBlock;
    v113[1] = 3221225472LL;
    v113[2] = sub_10004EFA0;
    v113[3] = &unk_1000F92F8;
    v113[4] = a1;
    v113[5] = buf;
    [v37 iterateFileHandlesWithBlock:v113];

    uint64_t v40 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v40)
    {
      id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 handle]);
      uint64_t v42 = dup((int)[v41 fileDescriptor]);

      if ((v42 & 0x80000000) != 0)
      {
        uint64_t v95 = nplog_obj(v43, v44, v45);
        uint64_t v96 = (os_log_s *)objc_claimAutoreleasedReturnValue(v95);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
        {
          __int128 v103 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&buf[8] + 40) agentUUID]);
          __int128 v104 = __error();
          __int128 v105 = strerror(*v104);
          *(_DWORD *)__int128 v114 = 138412802;
          uint64_t v115 = a1;
          __int16 v116 = 2112;
          id v117 = v103;
          __int16 v118 = 2080;
          id v119 = v105;
          _os_log_error_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_ERROR,  "%@: failed to dup the bootstrap DNS network agent registration file handle [%@], error: %s",  v114,  0x20u);
        }

        goto LABEL_47;
      }

      uint64_t v46 = nplog_obj(v43, v44, v45);
      uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        id v48 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&buf[8] + 40) agentUUID]);
        *(_DWORD *)__int128 v114 = 138412546;
        uint64_t v115 = a1;
        __int16 v116 = 2112;
        id v117 = v48;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "%@: re-using existing bootstrap DNS network agent registration file handle [%@]",  v114,  0x16u);
      }

      id v49 = *(id *)(a1 + 56);
      id v50 = *(id *)(a1 + 48);
      unsigned __int8 v51 = [v49 setRegisteredNetworkAgent:v50 fileDescriptor:v42];

      if ((v51 & 1) == 0)
      {
        uint64_t v97 = nplog_obj(v52, v53, v54);
        id v98 = (os_log_s *)objc_claimAutoreleasedReturnValue(v97);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
        {
          id v106 = *v6;
          __int128 v107 = (void *)objc_claimAutoreleasedReturnValue([v106 agentUUID]);
          *(_DWORD *)__int128 v114 = 138412546;
          uint64_t v115 = a1;
          __int16 v116 = 2112;
          id v117 = v107;
          _os_log_error_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_ERROR,  "%@: failed to set the registered bootstrap DNS network agent [%@]",  v114,  0x16u);
        }

        close(v42);
        goto LABEL_47;
      }

      id v55 = *(id *)(a1 + 56);
      unsigned int v56 = [v55 isRegistered];

      if (v56)
      {
        uint64_t v60 = nplog_obj(v57, v58, v59);
        uint64_t v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
        {
          id v62 = *v6;
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 agentUUID]);
          *(_DWORD *)__int128 v114 = 138412546;
          uint64_t v115 = a1;
          __int16 v116 = 2112;
          id v117 = v63;
          _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_INFO,  "%@ updating registered bootstrap DNS network agent [%@]",  v114,  0x16u);
        }

        id v64 = *(id *)(a1 + 56);
        id v65 = *(id *)(a1 + 48);
        unsigned __int8 v66 = [v64 updateNetworkAgent:v65];

        if ((v66 & 1) == 0)
        {
          uint64_t v70 = nplog_obj(v67, v68, v69);
          uint64_t v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
          {
            id v110 = *v6;
            uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v110 agentUUID]);
            *(_DWORD *)__int128 v114 = 138412546;
            uint64_t v115 = a1;
            __int16 v116 = 2112;
            id v117 = v111;
            _os_log_error_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "%@: failed to update the registered bootstrap DNS network agent [%@]",  v114,  0x16u);
          }

void sub_10004EF24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t sub_10004EF88(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10004EF98(uint64_t a1)
{
}

uint64_t sub_10004EFA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
  unsigned int v6 = [v5 isEqual:&off_1001033F8];
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      id v9 = *(void **)(v8 + 48);
    }
    else {
      id v9 = 0LL;
    }
    int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 agentUUID]);
    unsigned int v11 = [v7 isEqual:v10];

    if (v11)
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v13 = v3;
      uint64_t v5 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = v13;
      goto LABEL_7;
    }

LABEL_7:
  uint64_t v14 = v6 ^ 1;
LABEL_9:

  return v14;
}

  uint64_t v14 = v6 ^ 1;

LABEL_9:
  return v14;
}

  [v4 setFetchLimit:*(unsigned int *)(a1 + 56)];
  int v10 = *(void **)(a1 + 40);
  uint64_t v29 = 0LL;
  unsigned int v11 = objc_claimAutoreleasedReturnValue([v10 executeFetchRequest:v4 error:&v29]);
  uint64_t v12 = (os_log_s *)v29;
  id v13 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = v11;

  uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) == 0LL;
  id v19 = nplog_obj(v16, v17, v18);
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  uint64_t v21 = v20;
  if (v15)
  {
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v31 = (const char *)v12;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
    }

    goto LABEL_14;
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    id v25 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) count];
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v31 = v25;
    _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Fetched %lu events", buf, 0xCu);
  }

  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) reverseObjectEnumerator]);
    id v23 = objc_claimAutoreleasedReturnValue([v22 allObjects]);

    id v24 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v21 = *(os_log_s **)(v24 + 40);
    *(void *)(v24 + 40) = v23;
LABEL_14:
  }

id sub_10004F0A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_1001033F8])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 48);
      }
      else {
        uint64_t v8 = 0LL;
      }
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

uint64_t sub_10004F17C(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!a1) {
    return v1;
  }
  id v3 = (id *)(a1 + 32);
  id v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    uint64_t v4 = -[NSPPrivacyProxyDNSAgent initWithDelegate:]( objc_alloc(&OBJC_CLASS___NSPPrivacyProxyDNSAgent),  "initWithDelegate:",  v1);
    objc_storeStrong((id *)(v1 + 32), v4);

    uint64_t v5 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(&OBJC_CLASS___NSPPrivacyProxyDNSAgent));
    objc_storeStrong((id *)(v1 + 40), v5);

    id v2 = *(void **)(v1 + 32);
  }

  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v2 resolver]);

  if (!v6)
  {
    id v7 = sub_10004DCD8(v1);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [*(id *)(v1 + 32) setResolver:v8];
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager singleHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "singleHopProxyAgentUUID"));
  [*v3 setProxyAgentUUID:v9];

  uint64_t v13 = nplog_obj(v10, v11, v12);
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    id v15 = *(id *)(v1 + 32);
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 resolver]);
    uint32_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 dohURL]);
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "%@ setting up DNS network agent to %{public}@",  buf,  0x16u);
  }

  if (!*(void *)(v1 + 128))
  {
    uint64_t v19 = NPGetInternalQueue(v18);
    uint64_t v20 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v19);
    dispatch_source_t v21 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v20);
    uint64_t v22 = *(void **)(v1 + 128);
    *(void *)(v1 + 12_Block_object_dispose(va, 8) = v21;

    id v23 = *(void **)(v1 + 128);
    if (v23)
    {
      id v24 = v23;
      dispatch_time_t v25 = dispatch_time(0x8000000000000000LL, 1800000000000LL);
      dispatch_source_set_timer(v24, v25, 0x1A3185C5000uLL, 0LL);

      objc_initWeak((id *)location, (id)v1);
      uint64_t v26 = *(void **)(v1 + 128);
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_10004E09C;
      __int128 v129 = (uint64_t (*)(uint64_t, uint64_t))&unk_1000F97C0;
      id v27 = v26;
      objc_copyWeak((id *)&v130, (id *)location);
      dispatch_source_set_event_handler(v27, buf);

      dispatch_resume(*(dispatch_object_t *)(v1 + 128));
      objc_destroyWeak((id *)&v130);
      objc_destroyWeak((id *)location);
    }
  }

  id v28 = [*(id *)(v1 + 40) isRegistered];
  if (!(_DWORD)v28)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000LL;
    __int128 v129 = sub_10004EF88;
    __int128 v130 = sub_10004EF98;
    id v131 = 0LL;
    uint64_t v40 = nplog_obj(v28, v29, v30);
    id v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      id v42 = *v3;
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 agentUUID]);
      *(_DWORD *)id location = 138412546;
      *(void *)&location[4] = v1;
      __int16 v124 = 2112;
      id v125 = v43;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_INFO,  "%@ looking for DNS network agent registration file handle with agent UUID %@",  location,  0x16u);
    }

    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    v122[0] = _NSConcreteStackBlock;
    v122[1] = 3221225472LL;
    v122[2] = sub_10004FC90;
    v122[3] = &unk_1000F92F8;
    v122[4] = v1;
    v122[5] = buf;
    [v44 iterateFileHandlesWithBlock:v122];

    uint64_t v47 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v47)
    {
      id v48 = (void *)objc_claimAutoreleasedReturnValue([v47 handle]);
      uint64_t v49 = dup((int)[v48 fileDescriptor]);

      if ((v49 & 0x80000000) != 0)
      {
        uint64_t v104 = nplog_obj(v50, v51, v52);
        __int128 v105 = (os_log_s *)objc_claimAutoreleasedReturnValue(v104);
        if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
        {
          uint64_t v112 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&buf[8] + 40) agentUUID]);
          uint64_t v113 = __error();
          __int128 v114 = strerror(*v113);
          *(_DWORD *)id location = 138412802;
          *(void *)&location[4] = v1;
          __int16 v124 = 2112;
          id v125 = v112;
          __int16 v126 = 2080;
          __int128 v127 = v114;
          _os_log_error_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_ERROR,  "%@: failed to dup the DNS network agent registration file handle [%@], error: %s",  location,  0x20u);
        }

        goto LABEL_48;
      }

      uint64_t v53 = nplog_obj(v50, v51, v52);
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        id v55 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&buf[8] + 40) agentUUID]);
        *(_DWORD *)id location = 138412546;
        *(void *)&location[4] = v1;
        __int16 v124 = 2112;
        id v125 = v55;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "%@: re-using existing DNS network agent registration file handle [%@]",  location,  0x16u);
      }

      id v56 = *(id *)(v1 + 40);
      id v57 = *(id *)(v1 + 32);
      unsigned __int8 v58 = [v56 setRegisteredNetworkAgent:v57 fileDescriptor:v49];

      if ((v58 & 1) == 0)
      {
        uint64_t v106 = nplog_obj(v59, v60, v61);
        __int128 v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
        {
          id v115 = *v3;
          __int16 v116 = (void *)objc_claimAutoreleasedReturnValue([v115 agentUUID]);
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v124 = 2112;
          id v125 = v116;
          _os_log_error_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_ERROR,  "%@: failed to set the registered DNS network agent [%@]",  location,  0x16u);
        }

        close(v49);
        goto LABEL_48;
      }

      id v62 = *(id *)(v1 + 40);
      unsigned int v63 = [v62 isRegistered];

      if (v63)
      {
        uint64_t v67 = nplog_obj(v64, v65, v66);
        uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
        {
          id v69 = *v3;
          uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v69 agentUUID]);
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v124 = 2112;
          id v125 = v70;
          _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_INFO,  "%@ updating registered DNS network agent [%@]",  location,  0x16u);
        }

        id v71 = *(id *)(v1 + 40);
        id v72 = *(id *)(v1 + 32);
        unsigned __int8 v73 = [v71 updateNetworkAgent:v72];

        if ((v73 & 1) == 0)
        {
          uint64_t v77 = nplog_obj(v74, v75, v76);
          unsigned __int8 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue(v77);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            id v119 = *v3;
            uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v119 agentUUID]);
            *(_DWORD *)id location = 138412546;
            *(void *)&location[4] = v1;
            __int16 v124 = 2112;
            id v125 = v120;
            _os_log_error_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_ERROR,  "%@: failed to update the registered DNS network agent [%@]",  location,  0x16u);
          }

LABEL_47:
LABEL_48:
          uint64_t v1 = 0LL;
          goto LABEL_49;
        }
      }
    }

    else
    {
      uint64_t v81 = nplog_obj(0LL, v45, v46);
      id v82 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
      {
        id v83 = *v3;
        id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 agentUUID]);
        *(_DWORD *)id location = 138412546;
        *(void *)&location[4] = v1;
        __int16 v124 = 2112;
        id v125 = v84;
        _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_INFO,  "%@ registering DNS network agent [%@]",  location,  0x16u);
      }

      id v85 = *(id *)(v1 + 40);
      id v86 = *(id *)(v1 + 32);
      unsigned __int8 v87 = [v85 registerNetworkAgent:v86];

      if ((v87 & 1) == 0)
      {
        uint64_t v108 = nplog_obj(v88, v89, v90);
        unsigned __int8 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          id v117 = *v3;
          __int16 v118 = (void *)objc_claimAutoreleasedReturnValue([v117 agentUUID]);
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v124 = 2112;
          id v125 = v118;
          _os_log_error_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_ERROR,  "%@: failed to register DNS network agent [%@]",  location,  0x16u);
        }

        goto LABEL_47;
      }

      id v91 = *(id *)(v1 + 40);
      unsigned int v92 = [v91 isRegistered];

      if (v92)
      {
        id v93 = objc_alloc(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
        id v94 = *(id *)(v1 + 40);
        id v95 = *(id *)(v1 + 32);
        uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v95 agentUUID]);
        id v97 = *v3;
        id v98 = (void *)objc_claimAutoreleasedReturnValue([v97 agentUUID]);
        id v99 = [v93 initWithNetworkAgentRegistration:v94 sessionType:&off_1001033F8 configurationIdentifier:v96 agentUUID:v98];
        __int128 v100 = *(void **)(*(void *)&buf[8] + 40LL);
        *(void *)(*(void *)&buf[8] + 40LL) = v99;

        id v101 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        uint64_t v102 = *(void *)(*(void *)&buf[8] + 40LL);
        v121[0] = _NSConcreteStackBlock;
        v121[1] = 3221225472LL;
        v121[2] = sub_10004FD90;
        v121[3] = &unk_1000F9370;
        void v121[4] = v1;
        [v101 setFileHandle:v102 matchingPredicate:v121];

        __int128 v103 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
        [v103 commit];
      }
    }

    uint64_t v1 = 1LL;
LABEL_49:
    _Block_object_dispose(buf, 8);

    return v1;
  }

  uint64_t v31 = nplog_obj(v28, v29, v30);
  __int128 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    id v33 = *(id *)(v1 + 32);
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v33 agentUUID]);
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "%@ updating DNS network agent with UUID %@",  buf,  0x16u);
  }

  uint64_t v35 = *(void *)(v1 + 32);
  id v36 = *(id *)(v1 + 40);
  LOBYTE(v35) = [v36 updateNetworkAgent:v35];

  if ((v35 & 1) != 0) {
    return 1LL;
  }
  uint64_t v79 = nplog_obj(v37, v38, v39);
  uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue(v79);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
  {
    id v110 = *(id *)(v1 + 32);
    uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v110 agentUUID]);
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v111;
    _os_log_error_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_ERROR,  "%@: failed to update the registered DNS network agent [%@]",  buf,  0x16u);
  }

  return 0LL;
}
}

  -[NSPConfigurationStats setMailTrackersEnabled:](v15, "setMailTrackersEnabled:", 1LL);
  uint64_t v13 = v15;
  if ((v12 & 0x40) == 0)
  {
LABEL_22:
    if ((v12 & 0x80) == 0) {
      goto LABEL_23;
    }
    goto LABEL_49;
  }

void sub_10004FC2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t sub_10004FC90(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
  unsigned int v6 = [v5 isEqual:&off_1001033F8];
  if (v6)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      id v9 = *(void **)(v8 + 32);
    }
    else {
      id v9 = 0LL;
    }
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 agentUUID]);
    unsigned int v11 = [v7 isEqual:v10];

    if (v11)
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v13 = v3;
      uint64_t v5 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = v13;
      goto LABEL_7;
    }

id sub_10004FD90(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_1001033F8])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 32);
      }
      else {
        uint64_t v8 = 0LL;
      }
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id sub_10004FE6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_1001033F8])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 32);
      }
      else {
        uint64_t v8 = 0LL;
      }
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id sub_10004FF48(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NENetworkAgentRegistrationFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sessionType]);
    if ([v5 isEqual:&off_1001033F8])
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v3 agentUUID]);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 48);
      }
      else {
        uint64_t v8 = 0LL;
      }
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 agentUUID]);
      id v10 = [v6 isEqual:v9];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

void sub_100050024(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    id v5 = *(id *)(a1 + 64);
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 interface]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 interfaceName]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v4 interface]);

    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 interfaceName]);
    unsigned __int8 v10 = [v7 isEqualToString:v9];

    if ((v10 & 1) == 0)
    {
      uint64_t v11 = objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      uint64_t v12 = *(void **)(a1 + 80);
      *(void *)(a1 + 80) = v11;
    }

    if ([v4 status] == (id)2)
    {
      uint64_t v13 = objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      uint64_t v14 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = v13;
    }

    objc_storeStrong((id *)(a1 + 64), a2);
    id v15 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:]( &OBJC_CLASS___NPUtilities,  "copyCurrentNetworkCharacteristicsForPath:",  *(void *)(a1 + 64));
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"Signature"]);
    uint32_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) objectForKeyedSubscript:@"Signature"]);
    unint64_t v18 = v16;
    unint64_t v19 = v17;
    uint64_t v20 = (void *)v19;
    if (!(v18 | v19) || v18 && v19 && [(id)v18 isEqual:v19])
    {
    }

    else
    {

      uint64_t v24 = nplog_obj(v21, v22, v23);
      dispatch_time_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v26 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "proxy agent: network signature changed",  v26,  2u);
      }

      *(void *)(a1 + 104) = 0LL;
      objc_storeStrong((id *)(a1 + 88), v15);
      [*(id *)(a1 + 40) resetError];
      [*(id *)(a1 + 56) resetError];
    }
  }
}

id *sub_100050234(id *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    id v3 = result;
    uint64_t v4 = nplog_obj(result, a2, a3);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      v6[0] = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Resetting error due to configuration change",  (uint8_t *)v6,  2u);
    }

    [v3[5] resetError];
    return (id *)[v3[7] resetError];
  }

  return result;
}

id *sub_1000502B0(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    [result[5] resetError];
    return (id *)[v1[7] resetError];
  }

  return result;
}

void sub_1000502E0(id *a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (a1)
  {
    id v17 = v4;
    unsigned __int8 v6 = [v4 isEqualToString:a1[2]];
    id v5 = v17;
    if ((v6 & 1) == 0)
    {
      objc_storeStrong(a1 + 2, a2);
      id v7 = v17;
      objc_opt_self(&OBJC_CLASS___NSPServerODoH);
      CFPreferencesSetAppValue(@"NSPPreferredResolver", v7, kCFPreferencesCurrentApplication);

      uint64_t v8 = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
      if (!(_DWORD)v8)
      {
        uint64_t v11 = nplog_obj(v8, v9, v10);
        uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Failed to write preferred resolver to preference file",  buf,  2u);
        }
      }

      if ([a1[5] isRegistered])
      {
        id v15 = sub_10004DCD8((uint64_t)a1);
        id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
        [a1[4] setResolver:v16];

        sub_10004F17C((uint64_t)a1);
      }

      sub_100050234(a1, v13, v14);
      id v5 = v17;
    }
  }
}

void sub_100050418(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  id v7 = a2;
  if (!*(void *)(a1 + 16))
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resolver]);
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    *(_OWORD *)id location = 0u;
    __int128 v52 = 0u;
    id v14 = *(id *)(a1 + 120);
    id v15 = (char *)[v14 countByEnumeratingWithState:location objects:&buf count:16];
    if (v15)
    {
      uint64_t v16 = *(void *)v52;
      while (2)
      {
        for (i = 0LL; i != v15; ++i)
        {
          if (*(void *)v52 != v16) {
            objc_enumerationMutation(v14);
          }
          unint64_t v18 = (void *)*((void *)location[1] + (void)i);
          if (v18 != v13 && [v18 weight])
          {

            if (v13) {
              [*(id *)(a1 + 120) removeObject:v13];
            }
            if ([*(id *)(a1 + 40) isRegistered])
            {
              id v19 = sub_10004DCD8(a1);
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              [*(id *)(a1 + 32) setResolver:v20];

              sub_10004F17C(a1);
            }

            uint64_t v24 = nplog_obj(v21, v22, v23);
            dispatch_time_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
            {
              LOWORD(buf) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "Switching resolvers",  (uint8_t *)&buf,  2u);
            }

            uint64_t v26 = objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
            id v27 = *(void **)(a1 + 136);
            *(void *)(a1 + 136) = v26;

            uint64_t v31 = nplog_obj(v28, v29, v30);
            __int128 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            {
              LOWORD(buf) = 0;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Updating odoh userevent agent data",  (uint8_t *)&buf,  2u);
            }

            id v33 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v33,  "setObject:forKeyedSubscript:",  *(void *)(a1 + 136),  @"NSPServerODoHAuxilaryDataResolverSwitchedDateKey");
            location[0] = 0LL;
            __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v33,  1LL,  location));
            id v35 = location[0];
            uint64_t v38 = v35;
            if (!v34 || v35)
            {
              uint64_t v41 = nplog_obj(v35, v36, v37);
              uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v38;
                _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject failed with error: %@",  (uint8_t *)&buf,  0xCu);
              }
            }

            else
            {
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
              [v39 setAuxiliaryData:v34 forKey:@"NSPServerODoHAuxilaryData"];

              uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
              -[os_log_s commit](v40, "commit");
            }

            goto LABEL_36;
          }
        }

        id v15 = (char *)[v14 countByEnumeratingWithState:location objects:&buf count:16];
        if (v15) {
          continue;
        }
        break;
      }
    }
  }

  if (!*(_BYTE *)(a1 + 8))
  {
    uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSPOutageReasonStats);
    -[NSPOutageReasonStats setTierType:](v8, "setTierType:", @"SUBSCRIBER");
    id v9 = -[NSPOutageReasonStats setOutageReasonType:](v8, "setOutageReasonType:", @"DNS");
    if (a3 == 80)
    {
      uint64_t v12 = @"ODoHAuthFailure";
    }

    else
    {
      if (a3 != 94)
      {
        uint64_t v45 = nplog_obj(v9, v10, v11);
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = a3;
          _os_log_error_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "unexpected error code %d",  (uint8_t *)&buf,  8u);
        }

        uint64_t v44 = 0LL;
        goto LABEL_35;
      }

      uint64_t v12 = @"ODoHBadMessage";
    }

    -[NSPOutageReasonStats setOutageReasonSubType:](v8, "setOutageReasonSubType:", v12);
    id v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resolver]);
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 dohURL]);
    -[NSPOutageReasonStats setOdohProxy:](v8, "setOdohProxy:", v43);

    uint64_t v44 = v8;
LABEL_35:

    uint64_t v47 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = v44;

    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v56 = 0x3032000000LL;
    id v57 = sub_10004EF88;
    unsigned __int8 v58 = sub_10004EF98;
    id v59 = (id)os_transaction_create("com.apple.networkserviceproxy.dnsConnectivityCheck");
    objc_initWeak(location, (id)a1);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 24));
    v49[0] = _NSConcreteStackBlock;
    v49[1] = 3221225472LL;
    v49[2] = sub_100050958;
    v49[3] = &unk_1000F9B68;
    objc_copyWeak(&v50, location);
    v49[4] = &buf;
    [WeakRetained checkPrivacyProxyConnectivityOnInterface:v7 proxyConnectivityCheckType:a4 completionHandler:v49];

    *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
    objc_destroyWeak(&v50);
    objc_destroyWeak(location);
    _Block_object_dispose(&buf, 8);
  }

LABEL_36:
}

              (*((void (**)(id, void))v9 + 2))(v9, 0LL);
LABEL_37:

              goto LABEL_38;
            }

            unsigned __int8 v58 = nplog_obj(v28, v29, v30);
            uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
            if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
              goto LABEL_36;
            }
            *(_WORD *)__int128 buf = 0;
            id v57 = "Failed to match issuer name in transparency blob for token keys, blocking";
          }

          else
          {
            id v55 = nplog_obj(v22, v23, v24);
            uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue(v55);
            if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
              goto LABEL_36;
            }
            *(_WORD *)__int128 buf = 0;
            id v57 = "Failed to parse transparency blob for token keys, blocking";
          }

void sub_100050928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23)
{
}

void sub_100050958(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    WeakRetained[8] = 0;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
  id v5 = WeakRetained;
}

id *sub_1000509A8(id *a1)
{
  if (a1) {
    a1 = (id *)a1[18];
  }
  return a1;
}

void sub_100050CCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_100050CF8(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v6 = (uint64_t)WeakRetained;
  if (!WeakRetained) {
    goto LABEL_39;
  }
  id v7 = WeakRetained[17];
  if (v7)
  {
    uint64_t v8 = v7;
    id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    [v9 timeIntervalSinceDate:*(void *)(v6 + 136)];
    double v11 = v10;

    if (v11 <= 30.0)
    {
      uint64_t v18 = nplog_obj(v12, v13, v14);
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        id v19 = *(void **)(v6 + 136);
        *(_DWORD *)__int128 buf = 138412290;
        id v59 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Ignoring DNS error, last resolver switched date %@",  buf,  0xCu);
      }

      goto LABEL_38;
    }
  }

  int v15 = *(_DWORD *)(a1 + 56);
  if (v15 == 94)
  {
    unint64_t v20 = *(void *)(v6 + 104) + 1LL;
    *(void *)(v6 + 104) = v20;
    if (v20 < 3)
    {
LABEL_37:
      id v17 = (os_log_s *)*(id *)(v6 + 152);
      -[os_log_s setOdohBadMessageCount:]( v17,  "setOdohBadMessageCount:",  (char *)-[os_log_s odohBadMessageCount](v17, "odohBadMessageCount") + 1);
LABEL_38:

      goto LABEL_39;
    }

    id v21 = *(id *)(v6 + 64);
    if ([v21 status] == (id)1)
    {
      id v22 = *(id *)(v6 + 72);
      if (!v22) {
        goto LABEL_18;
      }
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      uint64_t v24 = *(void **)(a1 + 40);
      if (v24) {
        uint64_t v24 = (void *)v24[9];
      }
      uint64_t v1 = v24;
      [v23 timeIntervalSinceDate:v1];
      if (v25 > 30.0)
      {
        id v57 = v23;
LABEL_18:
        id v26 = *(id *)(v6 + 80);
        if (v26)
        {
          id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
          id v27 = *(void **)(a1 + 40);
          if (v27) {
            id v27 = (void *)v27[10];
          }
          uint64_t v3 = v27;
          [v2 timeIntervalSinceDate:v3];
          if (v28 <= 30.0)
          {
            BOOL v30 = 0;
            goto LABEL_46;
          }

          uint64_t v29 = *(void **)(a1 + 32);
          if (!v29)
          {
            BOOL v30 = 1;
            goto LABEL_46;
          }
        }

        else
        {
          uint64_t v29 = *(void **)(a1 + 32);
          if (!v29)
          {
            if (v22)
            {
            }

            goto LABEL_54;
          }
        }

        id v51 = [v29 interfaceIndex];
        uint64_t v52 = *(void *)(a1 + 40);
        if (v52) {
          __int128 v53 = *(void **)(v52 + 64);
        }
        else {
          __int128 v53 = 0LL;
        }
        __int128 v54 = (void *)objc_claimAutoreleasedReturnValue([v53 interface]);
        BOOL v30 = v51 == [v54 interfaceIndex];

        if (!v26)
        {
LABEL_47:
          if (v22)
          {
          }

          if (v30)
          {
LABEL_54:
            sub_100050418(v6, *(void **)(a1 + 32), 94, 5LL);
            *(void *)(v6 + 104) = 0LL;
            goto LABEL_37;
          }

void sub_1000511B4(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v4 = nplog_obj(v1, v2, v3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "remove userevent agent data", v8, 2u);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v6 setAuxiliaryData:@"NIL" forKey:@"NSPServerODoHAuxilaryData"];

  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v7 commit];
}

void sub_10005194C(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = -[NSPEventsNormalizer initWithMLModel:](objc_alloc(&OBJC_CLASS___NSPEventsNormalizer), "initWithMLModel:", v4);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
}

id sub_100051D98(uint64_t a1)
{
  return [*(id *)(a1 + 32) analyticsDict];
}

id sub_10005725C()
{
  if (qword_100117170 != -1) {
    dispatch_once(&qword_100117170, &stru_1000F9F50);
  }
  return (id)qword_100117168;
}

void sub_1000572A0(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NSPServer);
  uint64_t v2 = (void *)qword_100117168;
  qword_100117168 = (uint64_t)v1;

  if (qword_100117168) {
    *(_DWORD *)(qword_100117168 + 32) = -1;
  }
}

id sub_1000572E4(void *a1)
{
  if (a1)
  {
    uint64_t v1 = NPGetInternalQueue(a1);
    a1 = (void *)objc_claimAutoreleasedReturnValue(v1);
  }

  return a1;
}

uint64_t sub_100057300(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100057310(uint64_t a1)
{
}

void sub_100057318(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    switch(xpc_dictionary_get_int64(object, "NSPServerCommandType"))
    {
      case 1LL:
        sub_100057818(*(void *)(a1 + 32), object);
        break;
      case 2LL:
        sub_1000578B0(*(void *)(a1 + 32), object);
        break;
      case 3LL:
        sub_100057A34(*(void *)(a1 + 32), object);
        break;
      case 4LL:
        sub_100057BE8(*(void *)(a1 + 32), object);
        break;
      case 5LL:
        sub_100057DDC(*(void *)(a1 + 32), object);
        break;
      case 6LL:
        sub_100057FE8(*(void *)(a1 + 32), object);
        break;
      case 7LL:
        sub_100058818(*(void *)(a1 + 32), object);
        break;
      case 11LL:
        sub_100058A0C(*(void *)(a1 + 32), object);
        break;
      case 12LL:
        sub_100058AE4(*(void *)(a1 + 32), (uint64_t)object);
        break;
      case 13LL:
        sub_100058C90(*(void *)(a1 + 32), object);
        break;
      case 14LL:
        sub_100058E08(*(void *)(a1 + 32), object);
        break;
      case 15LL:
        sub_100059008(*(void *)(a1 + 32), object);
        break;
      case 16LL:
        sub_100059148(*(void *)(a1 + 32), object);
        break;
      case 17LL:
        sub_100059720(*(void *)(a1 + 32), object);
        break;
      case 18LL:
        sub_100059934(*(void *)(a1 + 32), object);
        break;
      case 19LL:
        sub_10005AEA8(*(void *)(a1 + 32), object);
        break;
      case 20LL:
        sub_10005B358(*(void *)(a1 + 32), object);
        break;
      case 21LL:
        sub_10005B6A4(*(void *)(a1 + 32), object);
        break;
      case 22LL:
        sub_10005B8D0(*(void *)(a1 + 32), object);
        break;
      case 23LL:
        sub_10005BAB0(*(void *)(a1 + 32), object);
        break;
      case 24LL:
        sub_10005BCC0(*(void *)(a1 + 32), object);
        break;
      case 25LL:
        sub_10005BF54(*(void *)(a1 + 32), object);
        break;
      case 26LL:
        sub_10005C390(*(void *)(a1 + 32), object);
        break;
      case 27LL:
        sub_10005C490(*(void *)(a1 + 32), object);
        break;
      case 28LL:
        sub_10005C54C(*(void *)(a1 + 32), v5, v6);
        break;
      case 29LL:
        sub_10005C5D4(*(void *)(a1 + 32), v5, v6);
        break;
      case 30LL:
        sub_1000594A8(*(void *)(a1 + 32), object);
        break;
      case 31LL:
        sub_10005C180(*(void *)(a1 + 32), object);
        break;
      case 32LL:
        sub_10005C65C(*(void *)(a1 + 32), object);
        break;
      case 33LL:
        sub_100059B64(*(void *)(a1 + 32), object);
        break;
      case 34LL:
        sub_100059D94(*(void *)(a1 + 32), object);
        break;
      case 35LL:
        sub_10005A118(*(void *)(a1 + 32), object);
        break;
      case 36LL:
        sub_10005A654(*(void *)(a1 + 32), object);
        break;
      case 37LL:
        sub_10005CE58(*(void *)(a1 + 32), object);
        break;
      case 38LL:
        sub_10005D0AC(*(void *)(a1 + 32), object);
        break;
      case 39LL:
        sub_10005D6C4(*(void *)(a1 + 32), object);
        break;
      case 40LL:
        sub_10005D8D8(*(void *)(a1 + 32), object);
        break;
      case 41LL:
        sub_10005DD48(*(void *)(a1 + 32), object);
        break;
      case 42LL:
        sub_10005DFA8(*(void *)(a1 + 32), object);
        break;
      case 43LL:
        sub_10005D28C(*(void *)(a1 + 32), object);
        break;
      case 44LL:
        sub_10005D4E0(*(void *)(a1 + 32), object);
        break;
      case 45LL:
        sub_10005E19C(*(void *)(a1 + 32), object);
        break;
      case 46LL:
        sub_10005E5B8(*(void *)(a1 + 32), object);
        break;
      case 47LL:
        sub_10005E7CC(*(void *)(a1 + 32), object);
        break;
      case 48LL:
        sub_10005DAF8(*(void *)(a1 + 32), object);
        break;
      case 49LL:
        sub_10005C8A8(*(void *)(a1 + 32), object);
        break;
      case 50LL:
        sub_10005CB7C(*(void *)(a1 + 32), object);
        break;
      case 51LL:
        sub_10005E9EC(*(id **)(a1 + 32), object);
        break;
      case 52LL:
        sub_10005FFFC(*(void *)(a1 + 32), object);
        break;
      case 53LL:
        sub_1000603C0(*(_BYTE **)(a1 + 32), object);
        break;
      case 54LL:
        sub_100060618(*(void *)(a1 + 32), object);
        break;
      case 55LL:
        sub_10006082C(*(void *)(a1 + 32), object);
        break;
      case 56LL:
        sub_100060A4C(*(void *)(a1 + 32), object);
        break;
      case 57LL:
        sub_100060C60(*(void *)(a1 + 32), object);
        break;
      case 58LL:
        sub_100060E74(*(void *)(a1 + 32), object);
        break;
      case 59LL:
        sub_100061050(*(id **)(a1 + 32), object);
        break;
      case 60LL:
        sub_10005FDD0(*(void *)(a1 + 32), object);
        break;
      case 61LL:
        sub_100061294(*(void *)(a1 + 32), object);
        break;
      case 62LL:
        sub_1000614E8(*(void *)(a1 + 32), object);
        break;
      case 63LL:
        sub_10005A878(*(void *)(a1 + 32), object);
        break;
      case 64LL:
        sub_10005AABC(*(void *)(a1 + 32), object);
        break;
      case 65LL:
        sub_100061740(*(void *)(a1 + 32), object);
        break;
      case 66LL:
        sub_100061954(*(void *)(a1 + 32), object);
        break;
      case 67LL:
        sub_1000623B0(*(void *)(a1 + 32), object);
        break;
      case 68LL:
        sub_100062874(*(void *)(a1 + 32), object);
        break;
      case 69LL:
        sub_100062AC8(*(void *)(a1 + 32), object);
        break;
      case 70LL:
        sub_10005F588(*(id **)(a1 + 32), object);
        break;
      case 71LL:
        sub_10005F6B8(*(void *)(a1 + 32), object);
        break;
      case 72LL:
        sub_10005F8B0(*(void *)(a1 + 32), object);
        break;
      case 73LL:
        sub_10005FB30(*(void *)(a1 + 32), object);
        break;
      default:
        xpc_connection_cancel(*(xpc_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
        goto LABEL_3;
    }
  }

  else
  {
LABEL_3:
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0LL;
  }
}

void sub_100057818(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    uint64_t v6 = nplog_obj(v3, v4, v5);
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Handling fetch configuration", v8, 2u);
    }

    sub_10006F54C(v3, "NSPServerConfiguration", *(void **)(a1 + 40));
  }

void sub_1000578B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      uint64_t v5 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  objc_opt_class(&OBJC_CLASS___NSPConfiguration),  0LL);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerConfiguration");
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (v8) {
        id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v6,  v8,  0LL));
      }
      else {
        id v9 = 0LL;
      }

      uint64_t v13 = nplog_obj(v10, v11, v12);
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Handling set configuration", buf, 2u);
      }

      [*(id *)(a1 + 56) updateConfiguration:v9];
      id v15 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v15);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v15);
      uint64_t v18 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v18) {
        xpc_connection_send_message(v18, reply);
      }
    }

    else
    {
      sub_10006F67C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_100057A34(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = (NSString *)xpc_dictionary_get_string(v3, "NSPServerEdgeSetIdentifier");
    uint64_t v8 = string;
    if (string)
    {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      uint64_t v8 = string;
    }

    uint64_t v9 = nplog_obj(string, v6, v7);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v21 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Handling fetch edge set for %@",  buf,  0xCu);
    }

    uint64_t v11 = *(void **)(a1 + 40);
    if (v8)
    {
      id v12 = v11;
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 edgeSets]);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:v8]);

      if (!v14)
      {
        uint64_t v18 = 0LL;
        goto LABEL_13;
      }

      id v19 = v14;
      uint64_t v15 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v19, 1LL));
    }

    else
    {
      unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v11 edgeSets]);
      id v17 = [v16 count];

      if (!v17)
      {
        uint64_t v18 = 0LL;
        goto LABEL_14;
      }

      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgeSets]);
      uint64_t v15 = objc_claimAutoreleasedReturnValue([v14 allValues]);
    }

    uint64_t v18 = (void *)v15;
LABEL_13:

LABEL_14:
    sub_10006F54C(v4, "NSPServerWaldoInfos", v18);
  }
}

void sub_100057BE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerEdgeSetIdentifier");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      uint64_t v6 = +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", objc_opt_class(&OBJC_CLASS___NPWaldo), 0LL);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerWaldoInfo");
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (v9) {
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v7,  v9,  0LL));
      }
      else {
        uint64_t v10 = 0LL;
      }

      uint64_t v14 = nplog_obj(v11, v12, v13);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v19 = string;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Handling set edge set for %@",  buf,  0xCu);
      }

      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      v16[2] = sub_10006F738;
      v16[3] = &unk_1000FA1C0;
      id v17 = v4;
      sub_10006F74C(a1, v10, string, v16);
    }

    else
    {
      sub_10006F67C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_100057DDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = (NSString *)xpc_dictionary_get_string(v3, "NSPServerAppLabel");
    uint64_t v8 = string;
    if (string)
    {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      uint64_t v8 = string;
    }

    unint64_t v20 = v4;
    uint64_t v9 = nplog_obj(string, v6, v7);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v27 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Handling fetch app rule for label %@",  buf,  0xCu);
    }

    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
    id v12 = [v11 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = 0LL;
      uint64_t v15 = *(void *)v22;
LABEL_8:
      uint64_t v16 = 0LL;
      while (1)
      {
        if (*(void *)v22 != v15) {
          objc_enumerationMutation(v11);
        }
        uint64_t v17 = *(void *)(*((void *)&v21 + 1) + 8 * v16);
        if (!v8
          || (uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v21 + 1) + 8 * v16) label]),
              unsigned int v19 = [v18 isEqualToString:v8],
              v18,
              v19))
        {
          if (!v14) {
            uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          }
          -[NSMutableArray addObject:](v14, "addObject:", v17);
          if (v8) {
            break;
          }
        }

        if (v13 == (id)++v16)
        {
          id v13 = [v11 countByEnumeratingWithState:&v21 objects:v25 count:16];
          if (v13) {
            goto LABEL_8;
          }
          break;
        }
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    uint64_t v4 = v20;
    sub_10006F54C(v20, "NSPServerAppRules", v14);
  }
}

void sub_100057FE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerAppLabel");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      uint64_t v6 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  objc_opt_class(&OBJC_CLASS___NSPAppRule),  0LL);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerAppRule");
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (v9) {
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v7,  v9,  0LL));
      }
      else {
        uint64_t v10 = 0LL;
      }

      uint64_t v14 = nplog_obj(v11, v12, v13);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v98 = string;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Handling set app rule for %@",  buf,  0xCu);
      }

      if (!string)
      {
        sub_10006F67C(v4, "NSPServerErrorString", @"App Rule label is nil");
LABEL_41:

        goto LABEL_42;
      }

      uint64_t v90 = v10;
      id v16 = v10;
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
      id v18 = [v17 count];

      if (!v18) {
        goto LABEL_19;
      }
      unint64_t v22 = 0LL;
      while (1)
      {
        __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
        __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectAtIndexedSubscript:v22]);

        double v25 = (void *)objc_claimAutoreleasedReturnValue([v24 label]);
        unsigned __int8 v26 = [v25 isEqualToString:string];

        if ((v26 & 1) != 0) {
          break;
        }
        ++v22;
        id v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
        id v28 = [v27 count];
      }

      if (v22 != 0x7FFFFFFFFFFFFFFFLL)
      {
        id v54 = *(id *)(a1 + 40);
        id v55 = (void *)objc_claimAutoreleasedReturnValue([v54 appRules]);
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v55 objectAtIndexedSubscript:v22]);

        if (v16)
        {
          uint64_t v59 = nplog_obj(v56, v57, v58);
          __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v98 = string;
            _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Merging new settings into existing %@ app rule",  buf,  0xCu);
          }

          [v31 merge:v16];
        }

        else
        {
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v31 edgeSetIdentifier]);

          if (!v61)
          {
            __int16 v62 = (void *)objc_claimAutoreleasedReturnValue([v31 matchSigningIdentifier]);
            v91[0] = _NSConcreteStackBlock;
            v91[1] = 3221225472LL;
            v91[2] = sub_10006FD9C;
            v91[3] = &unk_1000FA1C0;
            id v92 = v31;
            sub_10006F74C(a1, 0LL, v62, v91);
          }

          uint64_t v89 = v31;
          [v31 teardownNetworkAgent];
          unsigned int v63 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
          id v64 = [v63 mutableCopy];

          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSPConfiguration defaultConfiguration]( &OBJC_CLASS___NSPConfiguration,  "defaultConfiguration"));
          __int16 v66 = (void *)objc_claimAutoreleasedReturnValue([v65 appRules]);
          id v67 = [v66 count];

          if (!v67) {
            goto LABEL_55;
          }
          unint64_t v71 = 0LL;
          while (1)
          {
            id v72 = (void *)objc_claimAutoreleasedReturnValue([v65 appRules]);
            unsigned __int8 v73 = (void *)objc_claimAutoreleasedReturnValue([v72 objectAtIndexedSubscript:v71]);

            uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v73 label]);
            unsigned __int8 v75 = [v74 isEqualToString:string];

            if ((v75 & 1) != 0) {
              break;
            }
            ++v71;
            uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v65 appRules]);
            id v77 = [v76 count];
          }

          if (v71 != 0x7FFFFFFFFFFFFFFFLL)
          {
            uint64_t v81 = nplog_obj(v68, v69, v70);
            id v82 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412546;
              id v98 = string;
              __int16 v99 = 2112;
              __int128 v100 = string;
              _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "Replacing %@ app rule with the default %@ app rule",  buf,  0x16u);
            }

            id v83 = (void *)objc_claimAutoreleasedReturnValue([v65 appRules]);
            id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:v71]);
            id v85 = [v84 copy];

            [v64 replaceObjectAtIndex:v22 withObject:v85];
          }

          else
          {
LABEL_55:
            uint64_t v78 = nplog_obj(v68, v69, v70);
            uint64_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              id v98 = string;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "Removing %@ app rule", buf, 0xCu);
            }

            [v64 removeObjectAtIndex:v22];
          }

          uint64_t v80 = -[NSArray initWithArray:](objc_alloc(&OBJC_CLASS___NSArray), "initWithArray:", v64);
          [*(id *)(a1 + 40) setAppRules:v80];

          id v16 = 0LL;
          uint64_t v31 = v89;
        }
      }

      else
      {
LABEL_19:
        if (!v16) {
          goto LABEL_37;
        }
        uint64_t v29 = nplog_obj(v19, v20, v21);
        BOOL v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v98 = string;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Adding new %@ app rule", buf, 0xCu);
        }

        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSPConfiguration defaultConfiguration](&OBJC_CLASS___NSPConfiguration, "defaultConfiguration"));
        __int128 v93 = 0u;
        __int128 v94 = 0u;
        __int128 v95 = 0u;
        __int128 v96 = 0u;
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 appRules]);
        id v33 = [v32 countByEnumeratingWithState:&v93 objects:v101 count:16];
        if (v33)
        {
          id v34 = v33;
          unsigned __int8 v87 = v4;
          uint64_t v88 = v31;
          id v86 = string;
          uint64_t v35 = *(void *)v94;
          while (2)
          {
            for (i = 0LL; i != v34; i = (char *)i + 1)
            {
              if (*(void *)v94 != v35) {
                objc_enumerationMutation(v32);
              }
              uint64_t v37 = *(void **)(*((void *)&v93 + 1) + 8LL * (void)i);
              id v38 = (void *)objc_claimAutoreleasedReturnValue([v37 label]);
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v16 label]);
              unsigned int v40 = [v38 isEqualToString:v39];

              if (v40)
              {
                uint64_t v44 = nplog_obj(v41, v42, v43);
                uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
                string = v86;
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 138412290;
                  id v98 = v86;
                  _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Merging new settings into default %@ app rule",  buf,  0xCu);
                }

                id v46 = [v37 copy];
                [v46 merge:v16];

                id v16 = v46;
                uint64_t v4 = v87;
                goto LABEL_34;
              }
            }

            id v34 = [v32 countByEnumeratingWithState:&v93 objects:v101 count:16];
            if (v34) {
              continue;
            }
            break;
          }

          string = v86;
          uint64_t v4 = v87;
LABEL_34:
          uint64_t v31 = v88;
        }

        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) appRules]);
        id v48 = [v47 mutableCopy];

        [v48 addObject:v16];
        uint64_t v49 = -[NSArray initWithArray:](objc_alloc(&OBJC_CLASS___NSArray), "initWithArray:", v48);
        [*(id *)(a1 + 40) setAppRules:v49];
      }

LABEL_37:
      [*(id *)(a1 + 40) evaluateEnableRatios];
      [*(id *)(a1 + 40) saveToKeychain];
      sub_100066738(a1);
      [*(id *)(a1 + 40) setup];
      sub_10006762C(a1);
      id v50 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v50);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v50);
      __int128 v53 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v53) {
        xpc_connection_send_message(v53, reply);
      }

      uint64_t v10 = v90;
      goto LABEL_41;
    }

    sub_10006F67C(v4, "NSPServerErrorString", @"Permission denied");
  }

void sub_100058818(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = (NSString *)xpc_dictionary_get_string(v3, "NSPServerEdgeSetIdentifier");
    uint64_t v8 = string;
    if (string)
    {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      uint64_t v8 = string;
    }

    uint64_t v9 = nplog_obj(string, v6, v7);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v19 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Handling establish trust for %@",  buf,  0xCu);
    }

    if (v8)
    {
      id v11 = *(id *)(a1 + 40);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 edgeSets]);
      uint64_t v13 = (NSString *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v8]);

      if (v13)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472LL;
        v15[2] = sub_10006FE78;
        v15[3] = &unk_1000FA210;
        id v16 = v4;
        uint64_t v17 = v8;
        -[NSString establishTrustWithCompletionHandler:](v13, "establishTrustWithCompletionHandler:", v15);

        uint64_t v14 = v16;
      }

      else
      {
        uint64_t v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Edge set %@ does not exist",  v8);
        sub_10006F67C(v4, "NSPServerErrorString", v14);
      }
    }

    else
    {
      uint64_t v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Edge set identifier (%p) is nil",  0LL);
      sub_10006F67C(v4, "NSPServerErrorString", v13);
    }
  }
}

void sub_100058A0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v6 = v3;
  if (a1)
  {
    uint64_t v7 = nplog_obj(v3, v4, v5);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot refresh Waldo", v13, 2u);
    }

    id v9 = v6;
    xpc_object_t reply = xpc_dictionary_create_reply(v9);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v9);
    uint64_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

    if (reply && v12)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", 0);
      xpc_connection_send_message(v12, reply);
    }
  }
}

void sub_100058AE4(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(a2, "NSPServerUsageData");
    id v3 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    uint64_t v6 = nplog_obj(v3, v4, v5);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Handling a usage report", buf, 2u);
    }

    if (v3)
    {
      id v20 = 0LL;
      id v11 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NPUsageReport),  v3,  &v20);
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      id v13 = v20;
      id v16 = v13;
      if (!v12)
      {
        uint64_t v17 = nplog_obj(v13, v14, v15);
        id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          unint64_t v22 = v16;
          _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Failed to decode the usage report: %@",  buf,  0xCu);
        }
      }
    }

    else
    {
      uint64_t v19 = nplog_obj(v8, v9, v10);
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "reportUsage message does not contain a usage report",  buf,  2u);
      }
    }
  }

void sub_100058C90(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    double v5 = xpc_dictionary_get_double(v3, "NSPServerLatitude");
    double v6 = xpc_dictionary_get_double(v4, "NSPServerLongtitude");
    else {
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSince1970:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSince1970:"));
    }
    string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerSigningIdentifier");
    id v11 = string;
    if (string)
    {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      id v11 = string;
    }

    uint64_t v12 = nplog_obj(string, v9, v10);
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      int v14 = 134218754;
      double v15 = v5;
      __int16 v16 = 2048;
      double v17 = v6;
      __int16 v18 = 2112;
      uint64_t v19 = v7;
      __int16 v20 = 2112;
      uint64_t v21 = v11;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Handling set latitude and longitude <%f, %f> at %@ for %@",  (uint8_t *)&v14,  0x2Au);
    }
  }
}

void sub_100058E08(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = (NSString *)xpc_dictionary_get_string(v3, "NSPServerSigningIdentifier");
    if (string) {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
    }
    double v6 = (NSString *)xpc_dictionary_get_string(v4, "NSPServerEndpoint");
    uint64_t v9 = v6;
    if (v6)
    {
      double v6 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v6);
      uint64_t v9 = v6;
    }

    uint64_t v10 = nplog_obj(v6, v7, v8);
    id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      int v20 = 138412546;
      uint64_t v21 = string;
      __int16 v22 = 2112;
      __int128 v23 = v9;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Handling request for current state for %@ %@",  (uint8_t *)&v20,  0x16u);
    }

    xpc_object_t reply = xpc_dictionary_create_reply(v4);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
    int v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
    if (v14)
    {
      double v15 = (void *)objc_claimAutoreleasedReturnValue([0 telemetryService]);
      if (v15)
      {
        id v16 = reply;
        xpc_dictionary_set_string(v16, "NSPServerTelemetryService", (const char *)[v15 UTF8String]);
      }

      double v17 = (void *)objc_claimAutoreleasedReturnValue([0 telemetryURL]);
      __int16 v18 = (void *)objc_claimAutoreleasedReturnValue([v17 absoluteString]);
      if (v18)
      {
        id v19 = reply;
        xpc_dictionary_set_string(v19, "NSPServerTelemetryURL", (const char *)[v18 UTF8String]);
      }

      xpc_connection_send_message(v14, reply);
    }
  }
}

void sub_100059008(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    nsdictionary_from_xpc_xpc_object_t object = get_nsdictionary_from_xpc_object(v3, "NSPServerTestLatencyMap");
    double v6 = (void *)objc_claimAutoreleasedReturnValue(nsdictionary_from_xpc_object);
    uint64_t v9 = nplog_obj(v6, v7, v8);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      double v15 = v6;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Handling set test latency map %@",  buf,  0xCu);
    }

    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSPManager sharedManager](&OBJC_CLASS___NSPManager, "sharedManager"));
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_10006FF28;
    v12[3] = &unk_1000F9720;
    id v13 = v4;
    [v11 ingestTestLatencyMap:v6 local:1 completionHandler:v12];
  }
}

void sub_100059148(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerConfiguration");
      double v6 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      id v7 = [[NSPPrivacyProxyConfiguration alloc] initWithData:v6];
      if (v7)
      {
        uint64_t v8 = nplog_large_obj();
        uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(v34) = 138412290;
          *(void *)((char *)&v34 + 4) = v7;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set privacy proxy configuration %@",  (uint8_t *)&v34,  0xCu);
        }

        uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSPConfiguration);
        id v11 = v10;
        if (v10)
        {
          -[NSPConfiguration merge:](v10, "merge:", *(void *)(a1 + 40));
          -[NSPConfiguration setProxyConfiguration:](v11, "setProxyConfiguration:", v7);
          uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
          -[NSPConfiguration setConfigurationFetchDate:](v11, "setConfigurationFetchDate:", v12);

          id v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v11, "proxyConfiguration"));
          id v14 = [v13 disableUntil];

          if (v14)
          {
            double v15 = objc_alloc(&OBJC_CLASS___NSDate);
            id v16 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v11, "proxyConfiguration"));
            double v17 = -[NSDate initWithTimeIntervalSince1970:]( v15,  "initWithTimeIntervalSince1970:",  (double)(unint64_t)[v16 disableUntil]);

            -[NSDate timeIntervalSinceNow](v17, "timeIntervalSinceNow");
            if (v18 > 0.0) {
              -[NSPConfiguration setResurrectionDate:](v11, "setResurrectionDate:", v17);
            }
          }

          [*(id *)(a1 + 56) updateConfiguration:v11];
          id v19 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v19);
          xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v19);
          __int16 v22 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

          if (reply && v22) {
            xpc_connection_send_message(v22, reply);
          }
        }

        else
        {
          sub_10006F67C( v4,  "NSPServerErrorString",  @"Failed to parse privacyProxyConfiguration to NSPConfiguration");
        }
      }

      else
      {
        sub_10006F67C( v4,  "NSPServerErrorString",  @"Failed to parse configuration data to privacyProxyConfiguration");
      }
    }

    else
    {
      xpc_connection_t v23 = xpc_dictionary_get_remote_connection(v4);
      __int128 v24 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v23);
      double v25 = v24;
      if (v24
        && (pid_t pid = xpc_connection_get_pid(v24),
            __int128 v34 = 0u,
            memset(v35, 0, sizeof(v35)),
            proc_pidinfo(pid, 13, 1uLL, &v34, 64) == 64))
      {
        id v27 = (char *)malloc(0x10uLL);
        strncpy(v27, (const char *)v35, 0x10uLL);
      }

      else
      {
        id v27 = 0LL;
      }

      uint64_t v31 = nplog_obj(v28, v29, v30);
      uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        id v33 = "";
        if (v27) {
          id v33 = v27;
        }
        LODWORD(v34) = 136315138;
        *(void *)((char *)&v34 + 4) = v33;
        _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "set current privacy proxy configuration failed due to missing entitlement for %s",  (uint8_t *)&v34,  0xCu);
      }

      if (v27) {
        free(v27);
      }
      sub_10006F67C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_1000594A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v6 = v3;
  if (a1)
  {
    uint64_t v7 = nplog_obj(v3, v4, v5);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "processing privacy proxy configuration convert request",  buf,  2u);
    }

    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v6, "NSPServerConfiguration");
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    if (v10)
    {
      id v11 = [[NSPPrivacyProxySignedConfiguration alloc] initWithData:v10];
      if (v11)
      {
        id v12 = objc_alloc_init(&OBJC_CLASS___NSPConfigurationSignatureInfo);
        id v13 = (void *)objc_claimAutoreleasedReturnValue([v11 certificates]);
        [v12 setCertificates:v13];

        id v14 = (void *)objc_claimAutoreleasedReturnValue([v11 signature]);
        [v12 setSignature:v14];

        objc_msgSend(v12, "setSignatureAlgorithm:", (int)objc_msgSend(v11, "algorithm"));
        double v15 = objc_alloc_init(&OBJC_CLASS___NSData);
        double v25 = v15;
        char v16 = NSPPrivacyProxyConfigurationRawConfig(v10, &v25);
        double v17 = v25;

        if ((v16 & 1) != 0)
        {
          id v18 = *(id *)(a1 + 40);
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 configServerHost]);
          id v20 = *(id *)(a1 + 40);
          uint64_t v21 = [v20 ignoreInvalidCerts] ^ 1;
          v22[0] = _NSConcreteStackBlock;
          v22[1] = 3221225472LL;
          v22[2] = sub_100070080;
          v22[3] = &unk_1000FA238;
          xpc_connection_t v23 = v17;
          id v24 = v6;
          +[NSPConfiguration verifyConfigurationSignature:configuration:host:validateCert:completionHandler:]( &OBJC_CLASS___NSPConfiguration,  "verifyConfigurationSignature:configuration:host:validateCert:completionHandler:",  v12,  v23,  v19,  v21,  v22);
        }

        else
        {
          sub_10006FFB4(v6, 1005LL, @"could not extract raw configuration data");
        }
      }

      else
      {
        sub_10006FFB4(v6, 1005LL, @"invalid configuration data");
      }
    }

    else
    {
      sub_10006FFB4(v6, 1004LL, @"invalid parameter");
    }
  }
}

void sub_100059720(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set privacy proxy status",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 56),  "configurationEnabled:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      double v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      char v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        id v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        id v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      xpc_connection_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        id v24 = "";
        if (v18) {
          id v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "setting privacy proxy status failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100059934(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v27) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get privacy proxy status",  (uint8_t *)&v27,  2u);
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) enabled]);
      unsigned __int8 v11 = [v10 BOOLValue];
      id v12 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v12);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v12);
      double v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v15)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyEnabled", v11);
        xpc_connection_send_message(v15, reply);
      }
    }

    else
    {
      xpc_connection_t v16 = xpc_dictionary_get_remote_connection(v4);
      double v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v16);
      id v18 = v17;
      if (v17
        && (pid_t pid = xpc_connection_get_pid(v17),
            __int128 v27 = 0u,
            memset(v28, 0, sizeof(v28)),
            proc_pidinfo(pid, 13, 1uLL, &v27, 64) == 64))
      {
        uint64_t v20 = (char *)malloc(0x10uLL);
        strncpy(v20, (const char *)v28, 0x10uLL);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      uint64_t v24 = nplog_obj(v21, v22, v23);
      __int128 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v26 = "";
        if (v20) {
          unsigned __int8 v26 = v20;
        }
        LODWORD(v27) = 136315138;
        *(void *)((char *)&v27 + 4) = v26;
        _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "getting privacy proxy status failed due to missing entitlement for %s",  (uint8_t *)&v27,  0xCu);
      }

      if (v20) {
        free(v20);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100059B64(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process proxy service status request",  (uint8_t *)&v26,  2u);
      }

      id v10 = *(void **)(a1 + 72);
      if (v10)
      {
        xpc_object_t reply = (xpc_object_t)objc_claimAutoreleasedReturnValue([v10 serviceStatus]);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([reply serialize]);
        sub_100070150(v4, "NSPServerPrivacyProxyServiceStatus", v12);
      }

      else
      {
        id v23 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v23);
        xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v23);
        id v12 = (void *)objc_claimAutoreleasedReturnValue(remote_connection);

        if (reply && v12) {
          xpc_connection_send_message((xpc_connection_t)v12, reply);
        }
      }
    }

    else
    {
      xpc_connection_t v13 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v13);
      double v15 = v14;
      if (v14
        && (pid_t pid = xpc_connection_get_pid(v14),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        double v17 = (char *)malloc(0x10uLL);
        strncpy(v17, (const char *)v27, 0x10uLL);
      }

      else
      {
        double v17 = 0LL;
      }

      uint64_t v21 = nplog_obj(v18, v19, v20);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v17) {
          __int128 v25 = v17;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "getting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v17) {
        free(v17);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100059D94(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v3_Block_object_dispose(va, 8) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process proxy report service status",  (uint8_t *)&v38,  2u);
      }

      int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyServiceStatus");
      switch(int64)
      {
        case 0LL:
          [*(id *)(a1 + 72) reportServiceDisabledShouldReport:0];
          goto LABEL_26;
        case 1LL:
          [*(id *)(a1 + 72) reportServiceActiveShouldReport:0];
          goto LABEL_26;
        case 2LL:
          __int128 v26 = *(void **)(a1 + 72);
          uint64_t v27 = 0LL;
          goto LABEL_25;
        case 3LL:
          [*(id *)(a1 + 72) reportFraudAlert];
          goto LABEL_26;
        case 4LL:
          uint64_t v28 = *(void **)(a1 + 72);
          id v29 = *(id *)(a1 + 40);
          id v30 = v28;
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v29 proxyConfiguration]);
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 regionId]);
          [v30 reportUnsupportedRegion:v32];
          goto LABEL_23;
        case 5LL:
          [*(id *)(a1 + 72) reportSystemIncompatibility];
          goto LABEL_26;
        case 6LL:
          id v33 = *(void **)(a1 + 72);
          id v29 = *(id *)(a1 + 40);
          id v30 = v33;
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v29 proxyConfiguration]);
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 regionId]);
          [v30 reportSubscriberUnsupportedRegion:v32];
LABEL_23:

          goto LABEL_26;
        case 7LL:
          __int128 v26 = *(void **)(a1 + 72);
          uint64_t v27 = 2LL;
LABEL_25:
          [v26 reportServiceOutageWithType:v27 outageReasonStats:0];
LABEL_26:
          id v34 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v34);
          xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v34);
          uint64_t v36 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

          if (reply && v36) {
            xpc_connection_send_message(v36, reply);
          }

          break;
        default:
          sub_10006FFB4(v4, 1004LL, @"Invalid status");
          uint64_t v24 = nplog_obj(v21, v22, v23);
          xpc_object_t reply = (xpc_object_t)objc_claimAutoreleasedReturnValue(v24);
          if (os_log_type_enabled((os_log_t)reply, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v3_Block_object_dispose(va, 8) = 134217984;
            *(void *)((char *)&v38 + 4) = int64;
            _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)reply,  OS_LOG_TYPE_ERROR,  "report service status for privacy proxy failed due to bad value: %lld",  (uint8_t *)&v38,  0xCu);
          }

          break;
      }
    }

    else
    {
      xpc_connection_t v11 = xpc_dictionary_get_remote_connection(v4);
      id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v11);
      xpc_connection_t v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v38 = 0u,
            memset(v39, 0, sizeof(v39)),
            proc_pidinfo(pid, 13, 1uLL, &v38, 64) == 64))
      {
        double v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v39, 0x10uLL);
      }

      else
      {
        double v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = "";
        if (v15) {
          uint64_t v37 = v15;
        }
        LODWORD(v3_Block_object_dispose(va, 8) = 136315138;
        *(void *)((char *)&v38 + 4) = v37;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "reporting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v38,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005A118(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v60) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process proxy report network status",  (uint8_t *)&v60,  2u);
      }

      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerPrivacyProxyNetworkStatus");
      xpc_connection_t v11 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      id v12 = -[PrivacyProxyNetworkStatus initWithData:]( objc_alloc(&OBJC_CLASS___PrivacyProxyNetworkStatus),  "initWithData:",  v11);
      xpc_connection_t v13 = v12;
      if (!v12)
      {
        sub_10006FFB4(v4, 1004LL, @"Invalid status");
        uint64_t v33 = nplog_obj(v30, v31, v32);
        xpc_object_t reply = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v60) = 0;
          uint64_t v35 = "report service status for privacy proxy failed due to missing value";
          uint64_t v36 = reply;
          uint32_t v37 = 2;
LABEL_48:
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v35, (uint8_t *)&v60, v37);
          goto LABEL_44;
        }

        goto LABEL_44;
      }

      if (-[PrivacyProxyNetworkStatus networkType](v12, "networkType") == 1)
      {
        id v14 = -[PrivacyProxyNetworkStatus networkStatus](v13, "networkStatus");
        if (v14 == (id)2)
        {
          id v43 = *(id *)(a1 + 72);
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
          [v43 reportBlockedOnWiFiName:v44];
        }

        else
        {
          if (v14 != (id)1)
          {
            if (!v14)
            {
              id v15 = *(id *)(a1 + 72);
              uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
              [v15 reportDisabledOnWiFiName:v16];

              uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
              uint64_t v18 = v17;
              uint64_t v19 = 1LL;
LABEL_29:
              [v17 wifiDisabled:v19];
LABEL_39:

LABEL_40:
              id v52 = v4;
              xpc_object_t reply = (os_log_s *)xpc_dictionary_create_reply(v52);
              xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v52);
              id v54 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

              if (reply && v54) {
                xpc_connection_send_message(v54, reply);
              }

              goto LABEL_44;
            }

            sub_10006FFB4(v4, 1004LL, @"Invalid status");
            uint64_t v48 = nplog_obj(v45, v46, v47);
            xpc_object_t reply = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
            if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR)) {
              goto LABEL_47;
            }
            goto LABEL_44;
          }

          id v43 = *(id *)(a1 + 72);
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
          [v43 reportActiveOnWiFiName:v44];
        }

        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
        uint64_t v18 = v17;
        uint64_t v19 = 0LL;
        goto LABEL_29;
      }

      id v38 = -[PrivacyProxyNetworkStatus networkStatus](v13, "networkStatus");
      if (v38 == (id)2)
      {
        id v50 = *(id *)(a1 + 72);
        id v51 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v13, "networkName"));
        [v50 reportBlockedOnCellularName:v51];
      }

      else
      {
        if (v38 != (id)1)
        {
          if (v38)
          {
            sub_10006FFB4(v4, 1004LL, @"Invalid status");
            uint64_t v58 = nplog_obj(v55, v56, v57);
            xpc_object_t reply = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
            if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR))
            {
LABEL_47:
              id v59 = -[PrivacyProxyNetworkStatus networkStatus](v13, "networkStatus");
              LODWORD(v60) = 134217984;
              *(void *)((char *)&v60 + 4) = v59;
              uint64_t v35 = "report service status for privacy proxy failed due to bad value: %lld";
              uint64_t v36 = reply;
              uint32_t v37 = 12;
              goto LABEL_48;
            }

LABEL_45:
}
}

  -[NSPConfigurationStats setSafariPrivateAllEnabled:](v15, "setSafariPrivateAllEnabled:", 1LL);
  xpc_connection_t v13 = v15;
  if ((v12 & 0x200000) == 0)
  {
LABEL_20:
    if ((v12 & 0x20) == 0) {
      goto LABEL_21;
    }
    goto LABEL_47;
  }

void sub_10005A654(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process proxy service status timeline request",  (uint8_t *)&v26,  2u);
      }

      id v10 = *(void **)(a1 + 72);
      if (v10)
      {
        xpc_object_t reply = (xpc_object_t)objc_claimAutoreleasedReturnValue([v10 serviceStatusTimeline]);
        sub_10006F54C(v4, "NSPServerPrivacyProxyServiceStatusTimeline", reply);
      }

      else
      {
        id v22 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v22);
        xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v22);
        uint64_t v24 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

        if (reply && v24) {
          xpc_connection_send_message(v24, reply);
        }
      }
    }

    else
    {
      xpc_connection_t v12 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v12);
      id v14 = v13;
      if (v13
        && (pid_t pid = xpc_connection_get_pid(v13),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v16 = (char *)malloc(0x10uLL);
        strncpy(v16, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      uint64_t v20 = nplog_obj(v17, v18, v19);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v16) {
          uint64_t v25 = v16;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "getting service status timelinefor privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v16) {
        free(v16);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005A878(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process get app statuses request",  (uint8_t *)&v26,  2u);
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) anyAppEnabledDate]);
      xpc_connection_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) appStatuses]);
      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      id v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      if (v14)
      {
        sub_1000709DC(reply, "NSPServerPrivacyProxyAnyAppEnabledDate", (uint64_t)v10);
        sub_1000709DC(reply, "NSPServerPrivacyProxyAppStatuses", (uint64_t)v11);
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v19) {
          uint64_t v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "getting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005AABC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      uint64_t v5 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  objc_opt_class(&OBJC_CLASS___PrivacyProxyAppStatus),  0LL);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerPrivacyProxyAppStatus");
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (v8) {
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v6,  v8,  0LL));
      }
      else {
        uint64_t v9 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buffer) = 138412290;
        *(void *)((char *)&buffer + 4) = v9;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "process set app status request: %@",  (uint8_t *)&buffer,  0xCu);
      }

      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v9 bundleIdentifier]);
      if (v25)
      {
      }

      else
      {
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);

        if (!v26)
        {
          uint64_t v35 = @"Invalid app info";
          goto LABEL_27;
        }
      }

      id v27 = [v9 appStatus];
      if (v27 == (id)2 || [v9 appStatus] == (id)1)
      {
        id v28 = *(id *)(a1 + 72);
        id v29 = (void *)objc_claimAutoreleasedReturnValue([v9 bundleIdentifier]);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);
        unsigned int v31 = [v28 changePausedState:v27 == (id)2 forApp:v29 path:v30];

        if (v31)
        {
          if ((sub_100070208(a1) & 1) == 0)
          {
            if (v27 == (id)2)
            {
              uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
              uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
              id v34 = (void *)objc_claimAutoreleasedReturnValue([v32 nextDateAfterDate:v33 matchingUnit:32 value:0 options:1024]);

              [*(id *)(a1 + 56) setResetDate:v34];
            }

            else
            {
              [*(id *)(a1 + 56) clearResetDate];
            }
          }

          sub_10007081C(a1);
        }

        id v36 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v36);
        xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v36);
        id v39 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

        if (reply && v39) {
          xpc_connection_send_message(v39, reply);
        }

        goto LABEL_34;
      }

      uint64_t v35 = @"Invalid app status";
LABEL_27:
      sub_10006FFB4(v4, 1004LL, v35);
LABEL_34:

      goto LABEL_35;
    }

    xpc_connection_t v10 = xpc_dictionary_get_remote_connection(v4);
    xpc_connection_t v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v10);
    xpc_connection_t v12 = v11;
    if (v11
      && (pid_t pid = xpc_connection_get_pid(v11),
          __int128 buffer = 0u,
          memset(v42, 0, sizeof(v42)),
          proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
    {
      id v14 = (char *)malloc(0x10uLL);
      strncpy(v14, (const char *)v42, 0x10uLL);
    }

    else
    {
      id v14 = 0LL;
    }

    uint64_t v18 = nplog_obj(v15, v16, v17);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      unsigned int v40 = "";
      if (v14) {
        unsigned int v40 = v14;
      }
      LODWORD(buffer) = 136315138;
      *(void *)((char *)&buffer + 4) = v40;
      _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "getting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
    }

    if (v14) {
      free(v14);
    }
    sub_10006FFB4(v4, 1001LL, @"Permission denied");
  }

LABEL_35:
}

        unsigned int v31 = 0LL;
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v2,  1LL,  &v31));
        uint64_t v23 = v31;
        __int128 v26 = nplog_obj(v23, v24, v25);
        id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
        id v28 = v27;
        if (!v22 || v23)
        {
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v33 = v23;
            _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "archivedDataWithRootObject for server data failed with error: %@",  buf,  0xCu);
          }
        }

        else
        {
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Saving server data in UEA", buf, 2u);
          }

          id v29 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          [v29 setAuxiliaryData:v22 forKey:@"NSPServerAuxilaryData"];

          id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          -[os_log_s commit](v28, "commit");
        }

        goto LABEL_43;
      }
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v21,  @"NSPServerPrivateCloudComputeEnvironment");
    goto LABEL_35;
  }

  if (self->_captiveOutageWaitingForUserActivity)
  {
    uint64_t v48 = self->_primaryInterface;
    if (v48)
    {
      uint64_t v49 = v48;
      id v50 = self->_primaryPhysicalInterfaceEvaluator;
      if (v50)
      {
        id v51 = v50;
        id v52 = sub_1000670A8((uint64_t)self);

        if (v52)
        {
          uint64_t v56 = nplog_obj(v53, v54, v55);
          uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(handler) = 138412290;
            *(void *)((char *)&handler + 4) = self;
            _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "%@ Primary interface changed to non Wi-Fi, removing the pending outage notification ...",  (uint8_t *)&handler,  0xCu);
          }

          self->_captiveOutageWaitingForUserActivity = 0;
          sub_1000679B4((uint64_t)self);
          sub_100073418((uint64_t)self);
        }
      }

      else
      {
      }
    }
  }

  -[NSPServer proxyTokenFetchEnabled:](self, "proxyTokenFetchEnabled:", v4);

  objc_initWeak(&location, self);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  __int128 v157 = sub_100064360;
  __int128 v158 = &unk_1000FA098;
  objc_copyWeak((id *)&v159, &location);
  xpc_activity_register("com.apple.networkserviceproxy.metadata-refresh-12h", XPC_ACTIVITY_CHECK_IN, &buf);
  *(void *)&handler = _NSConcreteStackBlock;
  *((void *)&handler + 1) = 3221225472LL;
  __int128 v153 = sub_1000644C0;
  __int128 v154 = &unk_1000FA098;
  objc_copyWeak(v155, &location);
  xpc_activity_register("com.apple.networkserviceproxy.metadata-refresh-22h", XPC_ACTIVITY_CHECK_IN, &handler);
  *(void *)__int128 v145 = _NSConcreteStackBlock;
  __int128 v146 = 3221225472LL;
  __int128 v147 = sub_100064620;
  __int128 v148 = &unk_1000FA098;
  objc_copyWeak(v149, &location);
  xpc_activity_register("com.apple.networkserviceproxy.publish-daily-stats", XPC_ACTIVITY_CHECK_IN, v145);
  objc_destroyWeak(v149);
  objc_destroyWeak(v155);
  objc_destroyWeak((id *)&v159);
  objc_destroyWeak(&location);
  id v59 = NPGetInternalQueue(v58);
  __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  __int128 v157 = sub_100073FC8;
  __int128 v158 = &unk_1000FA438;
  __int128 v159 = self;
  uint64_t v61 = CNPluginMonitorStart(0LL, v60, &buf);

  uint64_t v65 = nplog_obj(v62, v63, v64);
  __int16 v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
  id v67 = v66;
  if (v61)
  {
    if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
    {
      LODWORD(handler) = 138412290;
      *(void *)((char *)&handler + 4) = self;
      _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_INFO,  "%@: Started CNPluginMonitor",  (uint8_t *)&handler,  0xCu);
    }
  }

  else if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
  {
    LODWORD(handler) = 138412290;
    *(void *)((char *)&handler + 4) = self;
    _os_log_error_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_ERROR,  "%@: Failed to start CNPluginMonitor",  (uint8_t *)&handler,  0xCu);
  }

  uint64_t v69 = NPGetInternalQueue(v68);
  uint64_t v70 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v69);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  __int128 v157 = sub_100072F58;
  __int128 v158 = &unk_1000F9FE0;
  __int128 v159 = self;
  xpc_set_event_stream_handler("com.apple.distnoted.matching", v70, &buf);

  uint64_t v74 = nplog_obj(v71, v72, v73);
  unsigned __int8 v75 = (os_log_s *)objc_claimAutoreleasedReturnValue(v74);
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(handler) = 138412290;
    *(void *)((char *)&handler + 4) = self;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEBUG,  "%@ registered for apps installation/uninstallation event",  (uint8_t *)&handler,  0xCu);
  }

LABEL_51:
  uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
  [v76 setDelegate:self];

  id v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
  uint64_t v78 = v77;
  if (self) {
    lastGeohash = self->_lastGeohash;
  }
  else {
    lastGeohash = 0LL;
  }
  [v77 setLastGeohash:lastGeohash];

  uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
  uint64_t v81 = v80;
  if (self)
  {
    [v80 setLastCountryPlusTimezone:self->_lastCountryPlusTimezone];

    id v82 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    [v82 start];

    id inited = objc_initWeak((id *)&handler, self);
    id v84 = NPGetInternalQueue(inited);
    id v85 = (void *)objc_claimAutoreleasedReturnValue(v84);
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472LL;
    __int128 v157 = sub_100075BA4;
    __int128 v158 = &unk_1000FA500;
    objc_copyWeak((id *)&v159, (id *)&handler);
    self->_userActivityNotificationHandle = IOPMScheduleUserActivityLevelNotification(v85, &buf);

    if (!self->_userActivityNotificationHandle)
    {
      uint64_t v89 = nplog_obj(v86, v87, v88);
      uint64_t v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v89);
      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 v145 = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_ERROR,  "Failed to register for user activity notifications",  v145,  2u);
      }
    }

    objc_destroyWeak((id *)&v159);
    objc_destroyWeak((id *)&handler);
  }

  else
  {
    [v80 setLastCountryPlusTimezone:0];

    __int128 v142 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    [v142 start];
  }

  sub_100068D18((id *)&self->super.isa);
  sub_100068E30((uint64_t *)self);
  sub_100063EFC((uint64_t)self);
  if (self)
  {
    if (self->_configOutage) {
      -[NSPServer checkPrivacyProxyConnectivityOnInterface:proxyConnectivityCheckType:completionHandler:]( self,  "checkPrivacyProxyConnectivityOnInterface:proxyConnectivityCheckType:completionHandler:",  0LL,  3LL,  0LL);
    }
    sub_1000665D4((uint64_t)self);
    if (self->_linkQualityMonitoringSocket == -1)
    {
      __int128 v93 = socket(32, 3, 1);
      self->_linkQualityMonitoringSocket = v93;
      if ((_DWORD)v93 == -1)
      {
        id v101 = nplog_obj(v93, v94, v95);
        uint64_t v102 = (os_log_s *)objc_claimAutoreleasedReturnValue(v101);
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
        {
          __int128 v137 = __error();
          __int128 v138 = strerror(*v137);
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v138;
          _os_log_error_impl( (void *)&_mh_execute_header,  v102,  OS_LOG_TYPE_ERROR,  "failed to create link quality monitoring socket %s",  (uint8_t *)&buf,  0xCu);
        }
      }

      else
      {
        __int128 v151 = 1;
        *(void *)__int128 v145 = 0x100000001LL;
        LODWORD(v146) = 2;
        __int128 v96 = ioctl(v93, 0x800C6502uLL, v145);
        if ((_DWORD)v96 || (__int128 v96 = ioctl(self->_linkQualityMonitoringSocket, 0x8004667EuLL, &v151), (_DWORD)v96))
        {
          __int16 v99 = nplog_obj(v96, v97, v98);
          __int128 v100 = (os_log_s *)objc_claimAutoreleasedReturnValue(v99);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v100,  OS_LOG_TYPE_ERROR,  "failed to set ioctl on link quality monitoring socket",  (uint8_t *)&buf,  2u);
          }

          close(self->_linkQualityMonitoringSocket);
          self->_linkQualityMonitoringSocket = -1;
        }

        else
        {
          linkQualityMonitoringSocket = self->_linkQualityMonitoringSocket;
          id v123 = NPGetInternalQueue(v96);
          __int16 v124 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v123);
          id v125 = (OS_dispatch_source *)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  linkQualityMonitoringSocket,  0LL,  v124);
          linkQualityMonitoringSource = self->_linkQualityMonitoringSource;
          self->_linkQualityMonitoringSource = v125;

          if (self->_linkQualityMonitoringSource)
          {
            objc_initWeak(&location, self);
            __int128 v127 = self->_linkQualityMonitoringSource;
            *(void *)&__int128 buf = _NSConcreteStackBlock;
            *((void *)&buf + 1) = 3221225472LL;
            __int128 v157 = sub_10007579C;
            __int128 v158 = &unk_1000F97C0;
            __int128 v128 = v127;
            objc_copyWeak((id *)&v159, &location);
            dispatch_source_set_cancel_handler(v128, &buf);

            __int128 v129 = self->_linkQualityMonitoringSource;
            *(void *)&handler = _NSConcreteStackBlock;
            *((void *)&handler + 1) = 3221225472LL;
            __int128 v153 = sub_1000757D8;
            __int128 v154 = &unk_1000F97C0;
            __int128 v130 = v129;
            objc_copyWeak(v155, &location);
            dispatch_source_set_event_handler(v130, &handler);

            objc_destroyWeak(v155);
            objc_destroyWeak((id *)&v159);
            objc_destroyWeak(&location);
            id v131 = (dispatch_object_s *)self->_linkQualityMonitoringSource;
          }

          else
          {
            id v131 = 0LL;
          }

          dispatch_resume(v131);
          __int128 v135 = nplog_obj(v132, v133, v134);
          __int128 v136 = (os_log_s *)objc_claimAutoreleasedReturnValue(v135);
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(location) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_DEFAULT,  "registered for link quality changes",  (uint8_t *)&location,  2u);
          }

          sub_100067224((uint64_t)self);
        }
      }
    }

    sub_100068FA4((id *)&self->super.isa, v91, v92);
    if (self->_trialClient
      || (uint64_t v104 = (TRIClient *)objc_claimAutoreleasedReturnValue( +[TRIClient clientWithIdentifier:]( &OBJC_CLASS___TRIClient,  "clientWithIdentifier:",  265LL)),  trialClient = self->_trialClient,  self->_trialClient = v104,  trialClient,  self->_trialClient))
    {
      if (!self->_trialNotificationToken)
      {
        objc_initWeak((id *)&handler, self);
        uint64_t v108 = self->_trialClient;
        uint64_t v109 = NPGetInternalQueue(v108);
        id v110 = (void *)objc_claimAutoreleasedReturnValue(v109);
        *(void *)&__int128 buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472LL;
        __int128 v157 = sub_100075B74;
        __int128 v158 = &unk_1000FA4D8;
        objc_copyWeak((id *)&v159, (id *)&handler);
        uint64_t v111 = (TRINotificationToken *)objc_claimAutoreleasedReturnValue( -[TRIClient addUpdateHandlerForNamespaceName:queue:usingBlock:]( v108,  "addUpdateHandlerForNamespaceName:queue:usingBlock:",  @"NETWORK_SERVICE_PROXY_CONFIG_UPDATE",  v110,  &buf));
        trialNotificationToken = self->_trialNotificationToken;
        self->_trialNotificationToken = v111;

        objc_destroyWeak((id *)&v159);
        objc_destroyWeak((id *)&handler);
      }
    }

    else
    {
      __int128 v139 = nplog_obj(v103, v106, v107);
      __int128 v140 = (os_log_s *)objc_claimAutoreleasedReturnValue(v139);
      if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPServer setupTrialUpdateHandler]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v140,  OS_LOG_TYPE_FAULT,  "%s called with null self.trialClient",  (uint8_t *)&buf,  0xCu);
      }
    }

    if (!self->_toggleStatsTimer)
    {
      uint64_t v113 = NPGetInternalQueue(v103);
      __int128 v114 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v113);
      id v115 = (OS_dispatch_source *)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  v114);
      toggleStatsTimer = self->_toggleStatsTimer;
      self->_toggleStatsTimer = v115;

      id v117 = self->_toggleStatsTimer;
      if (v117)
      {
        __int16 v118 = v117;
        id v119 = dispatch_time(0LL, 600000000000LL);
        dispatch_source_set_timer(v118, v119, 0x8BB2C97000uLL, 0LL);

        objc_initWeak((id *)&handler, self);
        uint64_t v120 = self->_toggleStatsTimer;
        *(void *)&__int128 buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472LL;
        __int128 v157 = sub_1000638E8;
        __int128 v158 = &unk_1000F97C0;
        id v121 = v120;
        objc_copyWeak((id *)&v159, (id *)&handler);
        dispatch_source_set_event_handler(v121, &buf);

        dispatch_resume((dispatch_object_t)self->_toggleStatsTimer);
        objc_destroyWeak((id *)&v159);
        objc_destroyWeak((id *)&handler);
      }
    }
  }

  else
  {
    sub_1000665D4(0LL);
    sub_100068FA4(0LL, v143, v144);
  }

  sub_1000691BC((id *)&self->super.isa);
}

  uint64_t v56 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v57 = *(void **)(v56 + 40);
  *(void *)(v56 + 40) = 0LL;
}

          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, v57, buf, 2u);
          goto LABEL_36;
        }
      }

      else
      {
      }
    }

    xpc_connection_t v12 = [v10 countByEnumeratingWithState:&v68 objects:v80 count:16];
    if (v12) {
      continue;
    }
    break;
  }

void sub_10005AEA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerSigningIdentifier");
      uint64_t v8 = string;
      BOOL v9 = 1;
      if (string)
      {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
        uint64_t v8 = string;
        if (string)
        {
          string = (NSString *)-[NSString isEqualToString:](string, "isEqualToString:", @"com.apple.Preferences");
          if ((string & 1) != 0
            || (string = (NSString *)[v8 hasPrefix:@"com.apple.systempreferences"], (_DWORD)string))
          {
            BOOL v9 = 0;
          }
        }
      }

      *(_BYTE *)(a1 + 24) = v9;
      uint64_t v15 = nplog_obj(string, v6, v7);
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v53) = 138412290;
        *(void *)((char *)&v53 + 4) = v8;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Handling set privacy proxy user tier from %@",  (uint8_t *)&v53,  0xCu);
      }

      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyUserTier");
      uint64_t v20 = uint64;
      if (uint64 - 3 > 0xFFFFFFFFFFFFFFFDLL)
      {
        BOOL v29 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxySetUntilTomorrow");
        if (v20 == 1 || !v29)
        {
          if (v29)
          {
            id v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            id v36 = (void *)objc_claimAutoreleasedReturnValue([v34 nextDateAfterDate:v35 matchingUnit:32 value:0 options:1024]);
          }

          else
          {
            id v36 = 0LL;
          }

          uint32_t v37 = *(void **)(a1 + 56);
          id v38 = *(id *)(a1 + 72);
          id v39 = v37;
          uint64_t v40 = [v38 hasPausedApps] ^ 1;
          if (*(_BYTE *)(a1 + 24)) {
            uint64_t v41 = 3LL;
          }
          else {
            uint64_t v41 = 1LL;
          }
          unsigned __int8 v42 = [v39 setUserTier:v20 resetDate:v36 clearResetDate:v40 changeSource:v41];

          if ((v42 & 1) != 0)
          {
            id v46 = v4;
            xpc_object_t reply = xpc_dictionary_create_reply(v46);
            xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v46);
            uint64_t v49 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

            if (reply && v49) {
              xpc_connection_send_message(v49, reply);
            }
          }

          else
          {
            uint64_t v50 = nplog_obj(v43, v44, v45);
            id v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v53) = 134217984;
              *(void *)((char *)&v53 + 4) = v20;
              _os_log_error_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_ERROR,  "failed to set user tier %lld",  (uint8_t *)&v53,  0xCu);
            }

            sub_10006FFB4(v4, 1003LL, @"failed to set user tier");
          }

          goto LABEL_44;
        }

        uint64_t v32 = nplog_obj(v29, v30, v31);
        uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v53) = 134217984;
          *(void *)((char *)&v53 + 4) = 2LL;
          _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "user tier %lld cannot be set temporarily",  (uint8_t *)&v53,  0xCu);
        }

        uint64_t v23 = @"user tier cannot be set temporarily";
      }

      else
      {
        uint64_t v21 = nplog_obj(uint64, v18, v19);
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v53) = 134217984;
          *(void *)((char *)&v53 + 4) = v20;
          _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "invalid user tier type %lld",  (uint8_t *)&v53,  0xCu);
        }

        uint64_t v23 = @"invalid user tier";
      }

      sub_10006FFB4(v4, 1003LL, v23);
LABEL_44:

      goto LABEL_45;
    }

    xpc_connection_t v10 = xpc_dictionary_get_remote_connection(v4);
    xpc_connection_t v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v10);
    xpc_connection_t v12 = v11;
    if (v11
      && (pid_t pid = xpc_connection_get_pid(v11),
          __int128 v53 = 0u,
          memset(v54, 0, sizeof(v54)),
          proc_pidinfo(pid, 13, 1uLL, &v53, 64) == 64))
    {
      id v14 = (char *)malloc(0x10uLL);
      strncpy(v14, (const char *)v54, 0x10uLL);
    }

    else
    {
      id v14 = 0LL;
    }

    uint64_t v27 = nplog_obj(v24, v25, v26);
    id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      id v52 = "";
      if (v14) {
        id v52 = v14;
      }
      LODWORD(v53) = 136315138;
      *(void *)((char *)&v53 + 4) = v52;
      _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "setting user tier for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v53,  0xCu);
    }

    if (v14) {
      free(v14);
    }
    sub_10006FFB4(v4, 1001LL, @"Permission denied");
  }

void sub_10005B358(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get privacy proxy user tier",  (uint8_t *)&buffer,  2u);
      }

      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      if (!v12) {
        goto LABEL_30;
      }
      xpc_connection_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) userTier]);

      if (v13)
      {
        id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) userTier]);
        if (v14)
        {
          id v15 = reply;
          xpc_dictionary_set_uint64( v15,  "NSPServerPrivacyProxyUserTier",  [v14 unsignedIntValue]);
        }
      }

      id v16 = *(id *)(a1 + 40);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 userTier]);
      if ([v17 unsignedIntegerValue] == (id)1)
      {
        id v18 = *(id *)(a1 + 40);
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 willResetSubscriberTierTomorrow]);
        if ([v19 BOOLValue])
        {
          id v20 = *(id *)(a1 + 40);
          uint64_t v21 = objc_claimAutoreleasedReturnValue([v20 resetTomorrowDate]);
          if (v21)
          {
            uint64_t v22 = (void *)v21;
            id v36 = v20;
            uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) resetTomorrowDate]);
            unsigned int v37 = [v23 isDateInTomorrow:v24];

            if (v37) {
              xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxySetUntilTomorrow", 1);
            }
            goto LABEL_29;
          }
        }
      }

LABEL_29:
      xpc_connection_send_message(v12, reply);
LABEL_30:

      goto LABEL_31;
    }

    xpc_connection_t v25 = xpc_dictionary_get_remote_connection(v4);
    uint64_t v26 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v25);
    uint64_t v27 = v26;
    if (v26
      && (pid_t pid = xpc_connection_get_pid(v26),
          __int128 buffer = 0u,
          memset(v39, 0, sizeof(v39)),
          proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
    {
      BOOL v29 = (char *)malloc(0x10uLL);
      strncpy(v29, (const char *)v39, 0x10uLL);
    }

    else
    {
      BOOL v29 = 0LL;
    }

    uint64_t v33 = nplog_obj(v30, v31, v32);
    id v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = "";
      if (v29) {
        uint64_t v35 = v29;
      }
      LODWORD(buffer) = 136315138;
      *(void *)((char *)&buffer + 4) = v35;
      _os_log_error_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "getting user tier for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
    }

    if (v29) {
      free(v29);
    }
    sub_10006FFB4(v4, 1001LL, @"Permission denied");
  }

void sub_10005B6A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set privacy proxy traffic state",  (uint8_t *)&v26,  2u);
      }

      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTrafficMask");
      objc_msgSend( *(id *)(a1 + 56),  "setProxyTrafficState:proxyTraffic:",  uint64,  xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTraffic"));
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      id v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14) {
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      id v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        xpc_connection_t v25 = "";
        if (v19) {
          xpc_connection_t v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "setting privacy proxy traffic state failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005B8D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v22) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get privacy proxy traffic state",  (uint8_t *)&v22,  2u);
      }

      xpc_connection_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) proxyTrafficState]);
      sub_100070934(v4, "NSPServerPrivacyProxyTraffic", v10);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      xpc_connection_t v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v22 = 0u,
            memset(v23, 0, sizeof(v23)),
            proc_pidinfo(pid, 13, 1uLL, &v22, 64) == 64))
      {
        xpc_connection_t v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v23, 0x10uLL);
      }

      else
      {
        xpc_connection_t v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = "";
        if (v15) {
          uint64_t v21 = v15;
        }
        LODWORD(v22) = 136315138;
        *(void *)((char *)&v22 + 4) = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "getting traffic state for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v22,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005BAB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v23) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing privacy proxy policy get request",  (uint8_t *)&v23,  2u);
      }

      xpc_connection_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 currentPolicy]);
      if (v11) {
        sub_100070150(v4, "NSPServerPrivacyProxyPolicy", v11);
      }
      else {
        sub_10006FFB4(v4, 1005LL, @"nil privacy proxy policy");
      }
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      id v14 = v13;
      if (v13
        && (pid_t pid = xpc_connection_get_pid(v13),
            __int128 v23 = 0u,
            memset(v24, 0, sizeof(v24)),
            proc_pidinfo(pid, 13, 1uLL, &v23, 64) == 64))
      {
        uint64_t v16 = (char *)malloc(0x10uLL);
        strncpy(v16, (const char *)v24, 0x10uLL);
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      uint64_t v20 = nplog_obj(v17, v18, v19);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        __int128 v22 = "";
        if (v16) {
          __int128 v22 = v16;
        }
        LODWORD(v23) = 136315138;
        *(void *)((char *)&v23 + 4) = v22;
        _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "getting privacy proxy policy failed due to missing entitlement for %s",  (uint8_t *)&v23,  0xCu);
      }

      if (v16) {
        free(v16);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005BCC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing privacy proxy policy set request",  (uint8_t *)&buffer,  2u);
      }

      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerPrivacyProxyPolicy");
      id v11 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      xpc_connection_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      xpc_connection_t v13 = -[NSPPrivacyProxyPolicy initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivacyProxyPolicy),  "initWithData:",  v11);
      unsigned __int8 v14 = [v12 set:v13 flowDivertHandle:0 inProcessFlowDivert:0 ingressProxyURL:0 ingressFallbackProxyURL:0 exceptio nBundleIDs:0 exceptionProcessPaths:0];
      id v15 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v15);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v15);
      uint64_t v18 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v18)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", v14);
        xpc_connection_send_message(v18, reply);
      }
    }

    else
    {
      xpc_connection_t v19 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v20 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v19);
      uint64_t v21 = v20;
      if (v20
        && (pid_t pid = xpc_connection_get_pid(v20),
            __int128 buffer = 0u,
            memset(v31, 0, sizeof(v31)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        __int128 v23 = (char *)malloc(0x10uLL);
        strncpy(v23, (const char *)v31, 0x10uLL);
      }

      else
      {
        __int128 v23 = 0LL;
      }

      uint64_t v27 = nplog_obj(v24, v25, v26);
      id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        BOOL v29 = "";
        if (v23) {
          BOOL v29 = v23;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v29;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "setting privacy proxy policy failed due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
      }

      if (v23) {
        free(v23);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005BF54(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing privacy proxy policy removal request",  (uint8_t *)&v26,  2u);
      }

      xpc_connection_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      [v10 remove:0];

      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      unsigned __int8 v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", 1);
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        xpc_connection_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        xpc_connection_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v19) {
          uint64_t v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "removing privacy proxy policy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005C180(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v24) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing privacy proxy policy merge request",  (uint8_t *)&v24,  2u);
      }

      xpc_connection_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy]);
      id v11 = v10;
      if (v10)
      {
        xpc_connection_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 dictionaryRepresentation]);
        sub_100070150(v4, "NSPServerPrivacyProxyPolicy", v12);
      }

      else
      {
        sub_10006FFB4(v4, 1005LL, @"failed to merge policy with traffic state");
      }
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      xpc_connection_t v15 = v14;
      if (v14
        && (pid_t pid = xpc_connection_get_pid(v14),
            __int128 v24 = 0u,
            memset(v25, 0, sizeof(v25)),
            proc_pidinfo(pid, 13, 1uLL, &v24, 64) == 64))
      {
        uint64_t v17 = (char *)malloc(0x10uLL);
        strncpy(v17, (const char *)v25, 0x10uLL);
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      uint64_t v21 = nplog_obj(v18, v19, v20);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        uint64_t v23 = "";
        if (v17) {
          uint64_t v23 = v17;
        }
        LODWORD(v24) = 136315138;
        *(void *)((char *)&v24 + 4) = v23;
        _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "getting privacy proxy policy failed due to missing entitlement for %s",  (uint8_t *)&v24,  0xCu);
      }

      if (v17) {
        free(v17);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005C390(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v6 = v3;
  if (a1)
  {
    uint64_t v7 = nplog_obj(v3, v4, v5);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)xpc_connection_t v15 = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "processing location authorization request",  v15,  2u);
    }

    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    unsigned __int8 v10 = [v9 isAuthorized];

    id v11 = v6;
    xpc_object_t reply = xpc_dictionary_create_reply(v11);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
    unsigned __int8 v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

    if (reply && v14)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", v10);
      xpc_connection_send_message(v14, reply);
    }
  }
}

void sub_10005C490(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = a2;
    uint64_t v5 = nplog_obj(v2, v3, v4);
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)BOOL v9 = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "processing request to set location monitor interval",  v9,  2u);
    }

    double v7 = xpc_dictionary_get_double(v2, "NSPServerLocationMonitorInterval");
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    [v8 setMonitorTimeInterval:v7 * 60.0];
  }

void sub_10005C54C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = nplog_obj(a1, a2, a3);
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "processing request to start location monitor",  v6,  2u);
    }

    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    [v5 start];
  }

void sub_10005C5D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = nplog_obj(a1, a2, a3);
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "processing request to stop location monitor",  v6,  2u);
    }

    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
    [v5 stop];
  }

void sub_10005C65C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v27) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "process proxy info request",  (uint8_t *)&v27,  2u);
      }

      id v10 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyInfo);
      id v11 = *(void **)(a1 + 56);
      if (v11) {
        [v11 copyProxyInfo:v10];
      }
      xpc_connection_t v12 = *(void **)(a1 + 64);
      if (v12) {
        [v12 copyProxyInfo:v10];
      }
      xpc_connection_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));

      if (v13)
      {
        unsigned __int8 v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));
        [v14 copyTokenInfo:v10];
      }

      xpc_connection_t v15 = (void *)objc_claimAutoreleasedReturnValue([v10 serialize]);
      sub_100070150(v4, "NSPServerPrivacyProxyInfo", v15);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      uint64_t v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      uint64_t v18 = v17;
      if (v17
        && (pid_t pid = xpc_connection_get_pid(v17),
            __int128 v27 = 0u,
            memset(v28, 0, sizeof(v28)),
            proc_pidinfo(pid, 13, 1uLL, &v27, 64) == 64))
      {
        uint64_t v20 = (char *)malloc(0x10uLL);
        strncpy(v20, (const char *)v28, 0x10uLL);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      uint64_t v24 = nplog_obj(v21, v22, v23);
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        __int128 v26 = "";
        if (v20) {
          __int128 v26 = v20;
        }
        LODWORD(v27) = 136315138;
        *(void *)((char *)&v27 + 4) = v26;
        _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "getting info for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v27,  0xCu);
      }

      if (v20) {
        free(v20);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005C8A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v29) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to override the ingress proxy",  (uint8_t *)&v29,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      if (!-[NSString length](string, "length"))
      {

        string = 0LL;
      }

      id v11 = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyFallbackURL");
      if (v11) {
        id v11 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v11);
      }
      if (!-[NSString length](v11, "length"))
      {

        id v11 = 0LL;
      }

      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerPrivacyProxyKey");
      xpc_connection_t v13 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (![v13 length])
      {

        xpc_connection_t v13 = 0LL;
      }

      [*(id *)(a1 + 64) overrideIngressProxy:string fallbackProxy:v11 key:v13];
      id v14 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v14);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v14);
      uint64_t v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v17) {
        xpc_connection_send_message(v17, reply);
      }
    }

    else
    {
      xpc_connection_t v18 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v19 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v18);
      uint64_t v20 = v19;
      if (v19
        && (pid_t pid = xpc_connection_get_pid(v19),
            __int128 v29 = 0u,
            memset(v30, 0, sizeof(v30)),
            proc_pidinfo(pid, 13, 1uLL, &v29, 64) == 64))
      {
        uint64_t v22 = (char *)malloc(0x10uLL);
        strncpy(v22, (const char *)v30, 0x10uLL);
      }

      else
      {
        uint64_t v22 = 0LL;
      }

      uint64_t v26 = nplog_obj(v23, v24, v25);
      __int128 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        id v28 = "";
        if (v22) {
          id v28 = v22;
        }
        LODWORD(v29) = 136315138;
        *(void *)((char *)&v29 + 4) = v28;
        _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "overriding preferred proxy failed due to missing entitlement for %s",  (uint8_t *)&v29,  0xCu);
      }

      if (v22) {
        free(v22);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005CB7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v33) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get the overridden ingress proxy",  (uint8_t *)&v33,  2u);
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) overrideIngressProxy]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) overrideFallbackIngressProxy]);
      xpc_connection_t v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) overrideIngressProxyKey]);
      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      if (v15)
      {
        id v16 = v10;
        if (v16)
        {
          id v17 = reply;
          xpc_dictionary_set_string(v17, "NSPServerPrivacyProxyURL", (const char *)[v16 UTF8String]);
        }

        id v18 = v11;
        if (v18)
        {
          id v19 = reply;
          xpc_dictionary_set_string( v19,  "NSPServerPrivacyProxyFallbackURL",  (const char *)[v18 UTF8String]);
        }

        if (v12)
        {
          id v20 = reply;
          uint64_t v21 = (void *)_CFXPCCreateXPCObjectFromCFObject(v12);
          xpc_dictionary_set_value(v20, "NSPServerPrivacyProxyKey", v21);
        }

        xpc_connection_send_message(v15, reply);
      }
    }

    else
    {
      xpc_connection_t v22 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v23 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v22);
      uint64_t v24 = v23;
      if (v23
        && (pid_t pid = xpc_connection_get_pid(v23),
            __int128 v33 = 0u,
            memset(v34, 0, sizeof(v34)),
            proc_pidinfo(pid, 13, 1uLL, &v33, 64) == 64))
      {
        uint64_t v26 = (char *)malloc(0x10uLL);
        strncpy(v26, (const char *)v34, 0x10uLL);
      }

      else
      {
        uint64_t v26 = 0LL;
      }

      uint64_t v30 = nplog_obj(v27, v28, v29);
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        uint64_t v32 = "";
        if (v26) {
          uint64_t v32 = v26;
        }
        LODWORD(v33) = 136315138;
        *(void *)((char *)&v33 + 4) = v32;
        _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "get preferred proxy failed due to missing entitlement for %s",  (uint8_t *)&v33,  0xCu);
      }

      if (v26) {
        free(v26);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005CE58(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to override the preferred proxy",  (uint8_t *)&v26,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      if (!-[NSString length](string, "length"))
      {

        string = 0LL;
      }

      [*(id *)(a1 + 64) overridePreferredProxy:string];
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      id v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14) {
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      id v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      id v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        id v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        id v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v19) {
          uint64_t v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "overriding preferred proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005D0AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v22) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get the preferred proxy",  (uint8_t *)&v22,  2u);
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) overridePreferredProxy]);
      sub_10006F67C(v4, "NSPServerPrivacyProxyURL", v10);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      xpc_connection_t v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v22 = 0u,
            memset(v23, 0, sizeof(v23)),
            proc_pidinfo(pid, 13, 1uLL, &v22, 64) == 64))
      {
        xpc_connection_t v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v23, 0x10uLL);
      }

      else
      {
        xpc_connection_t v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = "";
        if (v15) {
          uint64_t v21 = v15;
        }
        LODWORD(v22) = 136315138;
        *(void *)((char *)&v22 + 4) = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "get preferred proxy failed due to missing entitlement for %s",  (uint8_t *)&v22,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005D28C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to override the preferred resolver",  (uint8_t *)&v26,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      if (!-[NSString length](string, "length"))
      {

        string = 0LL;
      }

      sub_1000502E0(*(id **)(a1 + 192), string);
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      id v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14) {
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v19) {
          uint64_t v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "overriding preferred resolver failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005D4E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v23) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get the preferred resolver",  (uint8_t *)&v23,  2u);
      }

      id v10 = *(void **)(a1 + 192);
      if (v10) {
        id v10 = (void *)v10[2];
      }
      id v11 = v10;
      sub_10006F67C(v4, "NSPServerPrivacyProxyURL", v11);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      id v14 = v13;
      if (v13
        && (pid_t pid = xpc_connection_get_pid(v13),
            __int128 v23 = 0u,
            memset(v24, 0, sizeof(v24)),
            proc_pidinfo(pid, 13, 1uLL, &v23, 64) == 64))
      {
        uint64_t v16 = (char *)malloc(0x10uLL);
        strncpy(v16, (const char *)v24, 0x10uLL);
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      uint64_t v20 = nplog_obj(v17, v18, v19);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = "";
        if (v16) {
          uint64_t v22 = v16;
        }
        LODWORD(v23) = 136315138;
        *(void *)((char *)&v23 + 4) = v22;
        _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "get preferred resolver failed due to missing entitlement for %s",  (uint8_t *)&v23,  0xCu);
      }

      if (v16) {
        free(v16);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005D6C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set Geohash sharing preference",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 56),  "setGeohashSharingPreference:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyGeohashSharingEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      xpc_connection_t v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        uint64_t v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      __int128 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "reporting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005D8D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get Geohash sharing preference",  (uint8_t *)&v26,  2u);
      }

      unsigned __int8 v10 = [*(id *)(a1 + 56) getGeohashSharingPreference];
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      xpc_connection_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyGeohashSharingEnabled", v10);
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v19) {
          __int128 v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "getting service status for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005DAF8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      string = xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyGeohash");
      if (string)
      {
        string = (const char *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  string));
        uint64_t v8 = (char *)string;
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      uint64_t v19 = nplog_obj(string, v6, v7);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v26) = 138412290;
        *(void *)((char *)&v26 + 4) = v8;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "Handling set Geohash override: %@",  (uint8_t *)&v26,  0xCu);
      }

      [*(id *)(a1 + 56) setGeohashOverride:v8];
      id v21 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v21);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v21);
      uint64_t v24 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v24) {
        xpc_connection_send_message(v24, reply);
      }
    }

    else
    {
      xpc_connection_t v9 = xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v9);
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        xpc_connection_t v13 = (char *)malloc(0x10uLL);
        strncpy(v13, (const char *)v27, 0x10uLL);
      }

      else
      {
        xpc_connection_t v13 = 0LL;
      }

      uint64_t v17 = nplog_obj(v14, v15, v16);
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v13) {
          __int128 v25 = v13;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "overriding geohash failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005DD48(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      xpc_connection_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v27) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get privacy proxy account type",  (uint8_t *)&v27,  2u);
      }

      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      if (v12)
      {
        xpc_connection_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) proxyAccountType]);
        if (v13)
        {
          id v14 = reply;
          xpc_dictionary_set_uint64( v14,  "NSPServerPrivacyProxyAccountType",  [v13 unsignedIntValue]);
        }

        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) proxyAccountUnlimited]);
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyAccountUnlimited", (BOOL)[v15 BOOLValue]);

        xpc_connection_send_message(v12, reply);
      }
    }

    else
    {
      xpc_connection_t v16 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v16);
      uint64_t v18 = v17;
      if (v17
        && (pid_t pid = xpc_connection_get_pid(v17),
            __int128 v27 = 0u,
            memset(v28, 0, sizeof(v28)),
            proc_pidinfo(pid, 13, 1uLL, &v27, 64) == 64))
      {
        uint64_t v20 = (char *)malloc(0x10uLL);
        strncpy(v20, (const char *)v28, 0x10uLL);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      uint64_t v24 = nplog_obj(v21, v22, v23);
      __int128 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        __int128 v26 = "";
        if (v20) {
          __int128 v26 = v20;
        }
        LODWORD(v27) = 136315138;
        *(void *)((char *)&v27 + 4) = v26;
        _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "getting privacy proxy account type failed due to missing entitlement for %s",  (uint8_t *)&v27,  0xCu);
      }

      if (v20) {
        free(v20);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005DFA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      xpc_connection_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v22) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get privacy proxy effective user tier",  (uint8_t *)&v22,  2u);
      }

      unsigned __int8 v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [*(id *)(a1 + 56) effectiveUserTier]));
      sub_100070934(v4, "NSPServerPrivacyProxyEffectiveUserTier", v10);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      xpc_connection_t v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v22 = 0u,
            memset(v23, 0, sizeof(v23)),
            proc_pidinfo(pid, 13, 1uLL, &v22, 64) == 64))
      {
        uint64_t v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v23, 0x10uLL);
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = "";
        if (v15) {
          uint64_t v21 = v15;
        }
        LODWORD(v22) = 136315138;
        *(void *)((char *)&v22 + 4) = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "getting effective user tier for privacy proxy failed due to missing entitlement for %s",  (uint8_t *)&v22,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005E19C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      xpc_connection_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to send RTC report",  (uint8_t *)&buffer,  2u);
      }

      int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyRTCReportType");
      int64_t v11 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyRTCReportErrorCode");
      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyRTCReportURL");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      if (int64 == 1005)
      {
        xpc_connection_t v13 = objc_alloc_init(&OBJC_CLASS___NSPOutageReasonStats);
        id v14 = v13;
        switch(v11)
        {
          case 4001LL:
            -[NSPOutageReasonStats setOutageReasonType:](v13, "setOutageReasonType:", @"Token");
            -[NSPOutageReasonStats setOutageReasonSubType:](v14, "setOutageReasonSubType:", @"TokenFetchFailure");
            -[NSPOutageReasonStats setTokenProxy:]( v14,  "setTokenProxy:",  @"https://dummy-api.foobar.com/v1/fetchAuthTokens");
            break;
          case 4002LL:
            -[NSPOutageReasonStats setOutageReasonType:](v13, "setOutageReasonType:", @"Captive");
            -[NSPOutageReasonStats setOutageReasonSubType:]( v14,  "setOutageReasonSubType:",  @"CaptiveProbeRedirected");
            break;
          case 4003LL:
            -[NSPOutageReasonStats setOutageReasonType:](v13, "setOutageReasonType:", @"Proxy");
            -[NSPOutageReasonStats setOutageReasonSubType:]( v14,  "setOutageReasonSubType:",  @"ProxyConnectionTimeout");
            -[NSPOutageReasonStats setPrimaryIngressProxy:]( v14,  "setPrimaryIngressProxy:",  @"https://dummy-canary.foobar.com:443");
            -[NSPOutageReasonStats setPrimaryEgressProxy:]( v14,  "setPrimaryEgressProxy:",  @"https://dummy.exp.vendorA-masque.net:2495");
            -[NSPOutageReasonStats setFallbackIngressProxy:]( v14,  "setFallbackIngressProxy:",  @"https://dummy-h2.foobar.com:443");
            -[NSPOutageReasonStats setFallbackEgressProxy:]( v14,  "setFallbackEgressProxy:",  @"https://dummy.vendorB.com:443");
            break;
          case 4004LL:
            -[NSPOutageReasonStats setOutageReasonType:](v13, "setOutageReasonType:", @"DNS");
            -[NSPOutageReasonStats setOutageReasonSubType:](v14, "setOutageReasonSubType:", @"ODoHAuthFailure");
            -[NSPOutageReasonStats setOdohProxy:](v14, "setOdohProxy:", @"https://odoh.vendorA-dns.com/dns-query");
            break;
          default:
            break;
        }

        __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) userTier]);
        id v26 = [v25 intValue];
        if (v26 >= 3) {
          __int128 v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v26));
        }
        else {
          __int128 v27 = *(&off_1000FA520 + (int)v26);
        }
        -[NSPOutageReasonStats setTierType:](v14, "setTierType:", v27);

        [*(id *)(a1 + 64) sendRTCReportForServiceOutage:v14];
      }

      else
      {
        [*(id *)(a1 + 64) sendRTCReportWithFailureType:int64 errorCode:v11 url:string ingressProxy:0 egressProxy:0 tokenServer:0];
      }

      id v28 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v28);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v28);
      uint64_t v31 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v31) {
        xpc_connection_send_message(v31, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 buffer = 0u,
            memset(v34, 0, sizeof(v34)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v34, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v32 = "";
        if (v19) {
          uint64_t v32 = v19;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v32;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "failed to send RTC report due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005E5B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      xpc_connection_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to force fallback",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 64),  "forceFallback:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyForceFallback"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      xpc_connection_t v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        uint64_t v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "failed to force fallback due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005E7CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      xpc_connection_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get force fallback",  (uint8_t *)&v26,  2u);
      }

      unsigned __int8 v10 = [*(id *)(a1 + 64) forceFallback];
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      xpc_connection_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyForceFallback", v10);
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v19) {
          __int128 v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "failed to get force fallback due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10005E9EC(id *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v3, "NSPServerEffectiveAuditToken");
    uint64_t v6 = objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    string = xpc_dictionary_get_string(v4, "NSPServerSigningIdentifier");
    if (string) {
      unint64_t v8 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
    }
    else {
      unint64_t v8 = 0LL;
    }
    uint64_t v89 = (void *)v8;
    if (v6 | v8 && (sub_10006F5DC(v4, @"com.apple.private.network.socket-delegate") & 1) == 0)
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      __int128 v26 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      __int128 v27 = v26;
      if (v26
        && (pid_t pid = xpc_connection_get_pid(v26),
            __int128 v136 = 0u,
            memset(buffer, 0, sizeof(buffer)),
            proc_pidinfo(pid, 13, 1uLL, buffer, 64) == 64))
      {
        uint64_t v29 = (char *)malloc(0x10uLL);
        strncpy(v29, (const char *)&buffer[2], 0x10uLL);
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      uint64_t v57 = nplog_obj(v54, v55, v56);
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        id v85 = "";
        if (v29) {
          id v85 = v29;
        }
        LODWORD(buffer[0]) = 136315138;
        *(void *)((char *)buffer + 4) = v85;
        _os_log_error_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_ERROR,  "failed to fetch private access token due to missing delegation entitlement for %s",  (uint8_t *)buffer,  0xCu);
      }

      if (v29) {
        free(v29);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
      goto LABEL_83;
    }

    if (xpc_dictionary_get_BOOL(v4, "NSPServerTokenSystemClient")) {
      char v86 = sub_10006F5DC(v4, @"com.apple.private.network.system-token-fetch");
    }
    else {
      char v86 = 0;
    }
    xpc_connection_t v9 = xpc_dictionary_get_string(v4, "NSPServerPrivateAccessTokenOriginName");
    if (v9) {
      unsigned __int8 v87 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v9);
    }
    else {
      unsigned __int8 v87 = 0LL;
    }
    unsigned __int8 v10 = (void *)objc_claimAutoreleasedReturnValue([a1[5] privateAccessTokensAllowTools]);
    else {
      int v88 = 0;
    }

    xpc_connection_t v11 = xpc_dictionary_get_remote_connection(v4);
    xpc_connection_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v11);
    xpc_connection_t v13 = v12;
    if (v12) {
      uint64_t v14 = xpc_connection_get_pid(v12);
    }
    else {
      uint64_t v14 = 0LL;
    }

    xpc_connection_t v15 = (NSString *)(id)v8;
    unint64_t v18 = (unint64_t)v15;
    LOBYTE(v121) = 0;
    LOBYTE(v119[0]) = 0;
    LOBYTE(v113) = 0;
    if (v15)
    {
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[RBSProcessPredicate predicateMatchingBundleIdentifier:]( &OBJC_CLASS___RBSProcessPredicate,  "predicateMatchingBundleIdentifier:",  v15));
      v133[0] = 0LL;
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[RBSProcessHandle handleForPredicate:error:]( &OBJC_CLASS___RBSProcessHandle,  "handleForPredicate:error:",  v19,  v133));
      id v21 = v133[0];

      sub_100070B20(v20, &v121, v119, &v113);
      if ((_DWORD)v14)
      {
LABEL_21:
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[RBSProcessIdentifier identifierWithPid:]( &OBJC_CLASS___RBSProcessIdentifier,  "identifierWithPid:",  v14));
        if (v22)
        {
          id v127 = 0LL;
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[RBSProcessHandle handleForIdentifier:error:]( &OBJC_CLASS___RBSProcessHandle,  "handleForIdentifier:error:",  v22,  &v127));
          id v24 = v127;

          sub_100070B20(v23, &v121, v119, &v113);
          id v21 = v24;
        }

        else
        {
          uint64_t v23 = v20;
        }

LABEL_30:
        uint64_t v30 = nplog_obj(v15, v16, v17);
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
        BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
        int v33 = v121;
        int v34 = LOBYTE(v119[0]);
        if (v32)
        {
          id v82 = "";
          LODWORD(buffer[0]) = 138413314;
          if ((_BYTE)v121) {
            id v83 = "";
          }
          else {
            id v83 = "not ";
          }
          *(void *)((char *)buffer + 4) = v18;
          WORD2(buffer[1]) = 1024;
          if (LOBYTE(v119[0])) {
            id v84 = "";
          }
          else {
            id v84 = "not ";
          }
          *(_DWORD *)((char *)&buffer[1] + 6) = v14;
          if (!(_BYTE)v113) {
            id v82 = "not ";
          }
          WORD1(buffer[2]) = 2080;
          *(void *)((char *)&buffer[2] + 4) = v83;
          WORD2(buffer[3]) = 2080;
          *(void *)((char *)&buffer[3] + 6) = v84;
          HIWORD(buffer[4]) = 2080;
          buffer[5] = v82;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "%@ (%u) is %sapplication, is %srunning, is %sforeground",  (uint8_t *)buffer,  0x30u);
        }

        BOOL v35 = 0;
        if (v33 && v34) {
          BOOL v35 = (_BYTE)v113 != 0;
        }
        LOBYTE(buffer[0]) = v35;

        int v36 = LOBYTE(buffer[0]);
        if (((v36 | v88) & 1) == 0)
        {
          id v37 = [(id)v18 isEqualToString:@"com.apple.DPSubmissionService"];
          if ((v37 & 1) == 0 && (v86 & 1) == 0)
          {
            xpc_connection_t v49 = xpc_dictionary_get_remote_connection(v4);
            uint64_t v50 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v49);
            id v51 = v50;
            if (v50
              && (pid_t v52 = xpc_connection_get_pid(v50),
                  __int128 v136 = 0u,
                  memset(buffer, 0, sizeof(buffer)),
                  proc_pidinfo(v52, 13, 1uLL, buffer, 64) == 64))
            {
              __int128 v53 = (char *)malloc(0x10uLL);
              strncpy(v53, (const char *)&buffer[2], 0x10uLL);
            }

            else
            {
              __int128 v53 = 0LL;
            }

            uint64_t v62 = nplog_obj(v59, v60, v61);
            unsigned int v63 = (os_log_s *)objc_claimAutoreleasedReturnValue(v62);
            if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
            {
              id v64 = "";
              if (v53) {
                id v64 = v53;
              }
              LODWORD(buffer[0]) = 136315138;
              *(void *)((char *)buffer + 4) = v64;
              _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_INFO,  "Cannot fetch private access token, %s is not a foreground app",  (uint8_t *)buffer,  0xCu);
            }

            if (v53) {
              free(v53);
            }
            sub_10006FFB4(v4, 1001LL, @"Permission denied, not foreground app");
            goto LABEL_82;
          }
        }

        uint64_t v40 = nplog_obj(v37, v38, v39);
        uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buffer[0]) = 0;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEBUG,  "processing request to fetch a private access token",  (uint8_t *)buffer,  2u);
        }

        buffer[0] = 0LL;
        buffer[1] = buffer;
        buffer[2] = 0x3032000000LL;
        buffer[3] = sub_100057300;
        buffer[4] = sub_100057310;
        buffer[5] = 0LL;
        v133[0] = 0LL;
        v133[1] = v133;
        v133[2] = (id)0x3032000000LL;
        v133[3] = sub_100057300;
        void v133[4] = sub_100057310;
        id v134 = 0LL;
        id v127 = 0LL;
        __int128 v128 = &v127;
        uint64_t v129 = 0x3032000000LL;
        __int128 v130 = sub_100057300;
        id v131 = sub_100057310;
        id v132 = 0LL;
        uint64_t v121 = 0LL;
        id v122 = (id *)&v121;
        uint64_t v123 = 0x3032000000LL;
        __int16 v124 = sub_100057300;
        id v125 = sub_100057310;
        id v126 = 0LL;
        v119[0] = 0LL;
        v119[1] = v119;
        v119[2] = 0x3032000000LL;
        v119[3] = sub_100057300;
        v119[4] = sub_100057310;
        id v120 = 0LL;
        uint64_t v113 = 0LL;
        __int128 v114 = &v113;
        uint64_t v115 = 0x3032000000LL;
        __int16 v116 = sub_100057300;
        id v117 = sub_100057310;
        id v118 = 0LL;
        v111[0] = 0LL;
        v111[1] = v111;
        v111[2] = 0x3032000000LL;
        v111[3] = sub_100057300;
        v111[4] = sub_100057310;
        id v112 = 0LL;
        xpc_object_t value = xpc_dictionary_get_value(v4, "NSPServerPrivateAccessTokenChallenges");
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(value);
        size_t type = xpc_dictionary_get_BOOL(v4, "NSPServerHasPairedTokenChallenges");
        int v47 = type;
        if (v43)
        {
          size_t type = (size_t)xpc_get_type(v43);
          if ((_UNKNOWN *)type == &_xpc_type_array)
          {
            if (!v47)
            {
              v109[0] = _NSConcreteStackBlock;
              v109[1] = 3221225472LL;
              v109[2] = sub_100071650;
              v109[3] = &unk_1000FA288;
              v109[4] = a1;
              v109[5] = buffer;
              v109[6] = &v127;
              v109[7] = v119;
              v109[8] = v111;
              size_t type = xpc_array_apply(v43, v109);
              uint64_t v48 = v128;
              goto LABEL_64;
            }

            size_t type = xpc_array_get_count(v43);
            if (type == 2)
            {
              applier[0] = _NSConcreteStackBlock;
              applier[1] = 3221225472LL;
              applier[2] = sub_1000713E4;
              applier[3] = &unk_1000FA260;
              applier[4] = a1;
              applier[5] = &v127;
              applier[6] = buffer;
              applier[7] = v119;
              applier[8] = v111;
              applier[9] = &v121;
              applier[10] = v133;
              applier[11] = &v113;
              size_t type = xpc_array_apply(v43, applier);
            }
          }
        }

        if (!v128[5]) {
          goto LABEL_72;
        }
        if (!v47) {
          goto LABEL_65;
        }
        uint64_t v48 = v122;
LABEL_64:
        if (v48[5])
        {
LABEL_65:
          if (!(v6 | v18))
          {
            memset(buf, 0, sizeof(buf));
            xpc_dictionary_get_audit_token(v4, buf);
            uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 32LL));
          }

          if ((v86 & 1) == 0)
          {
            id v65 = a1[5];
            __int16 v66 = (void *)objc_claimAutoreleasedReturnValue([v65 privateAccessTokensEnabledStatus]);
            unsigned __int8 v67 = [v66 BOOLValue];

            if ((v67 & 1) == 0)
            {
              uint64_t v80 = nplog_obj(v68, v69, v70);
              uint64_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);
              if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
              {
                LOWORD(buf[0]) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_INFO,  "Cannot fetch private access token, feature disabled",  (uint8_t *)buf,  2u);
              }

              sub_10006FFB4(v4, 1008LL, @"Feature disabled");
              goto LABEL_81;
            }
          }

          unint64_t v71 = xpc_dictionary_get_string(v4, "NSPServerPrivateAccessTokenCustomAttester");
          if (v71)
          {
            id v72 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v71);
            if (v72)
            {
              nsdictionary_from_xpc_xpc_object_t object = get_nsdictionary_from_xpc_object( v4,  "NSPServerPrivateAccessTokenCustomAttesterHeaders");
              uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(nsdictionary_from_xpc_object);
LABEL_77:
              BOOL v77 = v114[5] != 0;
              v90[0] = _NSConcreteStackBlock;
              v90[1] = 3221225472LL;
              v90[2] = sub_10007180C;
              v90[3] = &unk_1000FA300;
              char v105 = v47;
              id v98 = &v127;
              __int16 v99 = buffer;
              __int128 v100 = v119;
              id v101 = v111;
              id v91 = v87;
              uint64_t v102 = &v121;
              __int128 v103 = v133;
              uint64_t v104 = &v113;
              uint64_t v6 = (uint64_t)(id)v6;
              id v92 = (id)v6;
              id v93 = (id)v18;
              char v106 = v88;
              char v107 = v86;
              id v94 = v4;
              __int128 v95 = a1;
              uint64_t v78 = v72;
              __int128 v96 = v78;
              id v79 = v74;
              id v97 = v79;
              sub_100071D50(a1, 1, v77, v90);

LABEL_81:
              _Block_object_dispose(v111, 8);

              _Block_object_dispose(&v113, 8);
              _Block_object_dispose(v119, 8);

              _Block_object_dispose(&v121, 8);
              _Block_object_dispose(&v127, 8);

              _Block_object_dispose(v133, 8);
              _Block_object_dispose(buffer, 8);

LABEL_82:
LABEL_83:

              goto LABEL_84;
            }
          }

          else
          {
            id v72 = 0LL;
          }

          uint64_t v74 = 0LL;
          goto LABEL_77;
        }

void sub_10005F508( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

void sub_10005F588(id *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v3, "NSPServerPrivateAccessTokenChallenge");
    uint64_t v6 = (NSPPrivateAccessTokenChallenge *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    xpc_connection_t v9 = v6;
    if (v6
      && (v6 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v6)) != 0LL && (unsigned __int8 v10 = v6,  v17 = 0LL,  v11 = sub_100070CFC(a1, v6, &v17),  v12 = v17,  v10,  v12))
    {
      xpc_connection_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 key]);
      sub_100070150(v4, "NSPServerPrivateAccessTokenKey", v13);
    }

    else
    {
      uint64_t v14 = nplog_obj(v6, v7, v8);
      xpc_connection_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Failed to find a known token key", v16, 2u);
      }

      sub_10006FFB4(v4, 1005LL, @"No key found");
    }
  }
}

void sub_10005F6B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    uint64_t v7 = sub_10006F5DC(v4, @"com.apple.private.network.system-token-fetch");
    if ((v7 & 1) != 0)
    {
      nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerPrivateAccessTokenChallenge");
      xpc_connection_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
      if (v13)
      {
        uint64_t v14 = get_nsdata_from_xpc_object(v4, "NSPServerPrivateAccessToken");
        id v17 = (void *)objc_claimAutoreleasedReturnValue(v14);
        if (v17)
        {
          unint64_t v18 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v13);
          if (v18)
          {
            id v21 = (os_log_s *)v18;
            sub_10004013C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v18, v17, 0LL);
          }

          else
          {
            uint64_t v25 = nplog_obj(0LL, v19, v20);
            __int128 v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__int128 v27 = 0;
              _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "Failed to parse challenge, cannot add token to cache",  v27,  2u);
            }

            id v21 = 0LL;
          }
        }

        else
        {
          uint64_t v24 = nplog_obj(0LL, v15, v16);
          id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)id v28 = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Failed to get token data, cannot add token to cache",  v28,  2u);
          }
        }
      }

      else
      {
        uint64_t v23 = nplog_obj(0LL, v11, v12);
        id v17 = (void *)objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v29 = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v17,  OS_LOG_TYPE_ERROR,  "Failed to get challenge, cannot add token to cache",  v29,  2u);
        }
      }
    }

    else
    {
      uint64_t v22 = nplog_obj(v7, v8, v9);
      xpc_connection_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "System client entitlement missing, cannot add token to cache",  buf,  2u);
      }
    }
  }
}

void sub_10005F8B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    uint64_t v7 = sub_10006F5DC(v4, @"com.apple.private.network.system-token-fetch");
    if ((v7 & 1) == 0)
    {
      uint64_t v25 = nplog_obj(v7, v8, v9);
      xpc_connection_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "System client entitlement missing, cannot add auxiliary authentication data to cache",  buf,  2u);
      }

      goto LABEL_24;
    }

    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v4, "NSPServerAuxiliaryAuthenticationData");
    xpc_connection_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    if (v13)
    {
      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerAuxiliaryAuthenticationLabel");
      if (string)
      {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
        if (string)
        {
          id v17 = string;
          unint64_t v18 = (NSString *)xpc_dictionary_get_string(v4, "NSPServerAuxiliaryAuthenticationCacheKey");
          if (v18
            && (unint64_t v18 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v18)) != 0LL)
          {
            id v21 = v18;
            int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerAuxiliaryAuthenticationType");
            if (int64 == 1)
            {
              sub_100040F68((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v13, 0, v21, v17, 0LL, 0);
            }

            else
            {
              uint64_t v31 = nplog_obj(int64, v23, v24);
              BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)int v33 = 0;
                _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "Failed to get known type, cannot add auxiliary authentication data to cache",  v33,  2u);
              }
            }
          }

          else
          {
            uint64_t v30 = nplog_obj(v18, v19, v20);
            id v21 = (NSString *)objc_claimAutoreleasedReturnValue(v30);
            if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int v34 = 0;
              _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v21,  OS_LOG_TYPE_ERROR,  "Failed to get cache key, cannot add auxiliary authentication data to cache",  v34,  2u);
            }
          }

          goto LABEL_23;
        }
      }

      uint64_t v26 = nplog_obj(string, v15, v16);
      id v17 = (NSString *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
      {
        __int16 v35 = 0;
        __int128 v27 = "Failed to get label, cannot add auxiliary authentication data to cache";
        id v28 = (uint8_t *)&v35;
LABEL_16:
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v17, OS_LOG_TYPE_ERROR, v27, v28, 2u);
      }
    }

    else
    {
      uint64_t v29 = nplog_obj(0LL, v11, v12);
      id v17 = (NSString *)objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v36 = 0;
        __int128 v27 = "Failed to get data, cannot add auxiliary authentication data to cache";
        id v28 = v36;
        goto LABEL_16;
      }
    }

void sub_10005FB30(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_16;
  }
  uint64_t v5 = NPGetInternalQueue(v3);
  uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
  dispatch_assert_queue_V2(v6);

  uint64_t v7 = sub_10006F5DC(v4, @"com.apple.private.network.system-token-fetch");
  if ((v7 & 1) == 0)
  {
    uint64_t v23 = nplog_obj(v7, v8, v9);
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "System client entitlement missing, cannot fetch auxiliary authentication data from cache",  buf,  2u);
    }

    uint64_t v25 = @"Missing entitlement";
    uint64_t v26 = v4;
    int64_t v27 = 1001LL;
    goto LABEL_15;
  }

  string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerAuxiliaryAuthenticationLabel");
  if (!string
    || (string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string)) == 0LL)
  {
    uint64_t v28 = nplog_obj(string, v11, v12);
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v36 = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "Failed to get label, cannot fetch auxiliary authentication data from cache",  v36,  2u);
    }

    uint64_t v25 = @"Missing label";
    uint64_t v26 = v4;
    int64_t v27 = 1004LL;
LABEL_15:
    sub_10006FFB4(v26, v27, v25);
    goto LABEL_16;
  }

  xpc_connection_t v13 = string;
  uint64_t v14 = (NSString *)xpc_dictionary_get_string(v4, "NSPServerAuxiliaryAuthenticationCacheKey");
  if (v14
    && (uint64_t v14 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v14)) != 0LL)
  {
    id v17 = v14;
    int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerAuxiliaryAuthenticationType");
    if (int64 == 1)
    {
      id v21 = sub_100041334((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, 0, v17, v13, 1);
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      sub_100070150(v4, "NSPServerAuxiliaryAuthenticationData", v22);
    }

    else
    {
      uint64_t v32 = nplog_obj(int64, v19, v20);
      int v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v34 = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "Failed to get known type, cannot fetch auxiliary authentication data from cache",  v34,  2u);
      }

      sub_10006FFB4(v4, 1004LL, @"Unknown type");
    }
  }

  else
  {
    uint64_t v30 = nplog_obj(v14, v15, v16);
    uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int16 v35 = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Failed to get cache key, cannot fetch auxiliary authentication data from cache",  v35,  2u);
    }

    sub_10006FFB4(v4, 1004LL, @"Missing cache key");
  }

LABEL_16:
}

void sub_10005FDD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = xpc_dictionary_get_string(v3, "NSPServerPrivateAccessTokenOriginName");
    if (string
      && (uint64_t v6 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string)) != 0LL)
    {
      uint64_t v7 = v6;
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSString lowercaseString](v6, "lowercaseString"));

      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "proxyConfiguration", 0));
      unsigned __int8 v10 = (void *)objc_claimAutoreleasedReturnValue([v9 authInfo]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 accessTokenKnownOrigins]);

      id v12 = [v11 countByEnumeratingWithState:&v24 objects:v28 count:16];
      if (v12)
      {
        id v13 = v12;
        uint64_t v14 = *(void *)v25;
        while (2)
        {
          for (i = 0LL; i != v13; i = (char *)i + 1)
          {
            if (*(void *)v25 != v14) {
              objc_enumerationMutation(v11);
            }
            uint64_t v16 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
            if (([v8 isEqualToString:v16] & 1) == 0)
            {
              id v17 = (void *)objc_claimAutoreleasedReturnValue([@"." stringByAppendingString:v16]);
              unsigned __int8 v18 = [v8 hasSuffix:v17];

              if ((v18 & 1) == 0) {
                continue;
              }
            }

            BOOL v19 = 1;
            goto LABEL_17;
          }

          id v13 = [v11 countByEnumeratingWithState:&v24 objects:v28 count:16];
          BOOL v19 = 0;
          if (v13) {
            continue;
          }
          break;
        }
      }

      else
      {
        BOOL v19 = 0;
      }

void sub_10005FFFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) == 0)
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      uint64_t v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      unsigned __int8 v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            __int128 buffer = 0u,
            memset(v50, 0, sizeof(v50)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        id v12 = (char *)malloc(0x10uLL);
        strncpy(v12, (const char *)v50, 0x10uLL);
      }

      else
      {
        id v12 = 0LL;
      }

      uint64_t v16 = nplog_obj(v13, v14, v15);
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v40 = "";
        if (v12) {
          uint64_t v40 = v12;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v40;
        _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "failed to start proxying to MPTCP converter proxy due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
      }

      if (v12) {
        free(v12);
      }
      uint64_t v5 = @"Permission denied";
      goto LABEL_13;
    }

    if (*(_BYTE *)(a1 + 23))
    {
      uint64_t v5 = @"proxying to MPTCP converter proxy is already started";
      uint64_t v6 = v4;
      int64_t v7 = 1004LL;
LABEL_14:
      sub_10006FFB4(v6, v7, v5);
      goto LABEL_15;
    }

    id v18 = [*(id *)(a1 + 56) effectiveUserTier];
    uint64_t v21 = nplog_obj(v18, v19, v20);
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    uint64_t v23 = v22;
    if (v18 == (id)2)
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "unable to start proxying to MPTCP converter proxy because Private Relay is enabled",  (uint8_t *)&buffer,  2u);
      }

      uint64_t v5 = @"Private Relay is enabled";
LABEL_13:
      uint64_t v6 = v4;
      int64_t v7 = 1001LL;
      goto LABEL_14;
    }

    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buffer) = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "processing request to start proxying to MPTCP converter proxy",  (uint8_t *)&buffer,  2u);
    }

    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472LL;
    uint64_t v46 = sub_100071E5C;
    int v47 = &unk_1000F9720;
    id v48 = v4;
    __int128 v24 = v45;
    if (objc_getProperty((id)a1, v25, 264LL, 1))
    {
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      id Property = objc_getProperty((id)a1, v29, 264LL, 1);
      if (Property) {
        uint64_t v31 = (void *)Property[2];
      }
      else {
        uint64_t v31 = 0LL;
      }
      id v32 = v31;
      unsigned __int8 v33 = [v28 addPoliciesForMPTCPConverterProxy:v32];

      if ((v33 & 1) != 0)
      {
        uint64_t v37 = 1LL;
        *(_BYTE *)(a1 + 23) = 1;
        sub_1000679B4(a1);
LABEL_37:
        v46((uint64_t)v24, v37);

        goto LABEL_15;
      }

      uint64_t v41 = nplog_obj(v34, v35, v36);
      unsigned __int8 v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "failed to add policies for MPTCP converter proxy",  (uint8_t *)&buffer,  2u);
      }

      id v44 = objc_getProperty((id)a1, v43, 264LL, 1);
      sub_10009D6E8((uint64_t)v44, 0);
    }

    else
    {
      uint64_t v38 = nplog_obj(0LL, v26, v27);
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "flow divert provider is unavailable",  (uint8_t *)&buffer,  2u);
      }
    }

    uint64_t v37 = 0LL;
    goto LABEL_37;
  }

void sub_1000603C0(_BYTE *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_22;
  }
  uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
  if ((v5 & 1) == 0)
  {
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
    id v18 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
    uint64_t v19 = v18;
    if (v18
      && (pid_t pid = xpc_connection_get_pid(v18),
          __int128 v31 = 0u,
          memset(v32, 0, sizeof(v32)),
          proc_pidinfo(pid, 13, 1uLL, &v31, 64) == 64))
    {
      uint64_t v21 = (char *)malloc(0x10uLL);
      strncpy(v21, (const char *)v32, 0x10uLL);
    }

    else
    {
      uint64_t v21 = 0LL;
    }

    uint64_t v25 = nplog_obj(v22, v23, v24);
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = "";
      if (v21) {
        uint64_t v30 = v21;
      }
      LODWORD(v31) = 136315138;
      *(void *)((char *)&v31 + 4) = v30;
      _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "failed to stop proxying to MPTCP converter proxy due to missing entitlement for %s",  (uint8_t *)&v31,  0xCu);
    }

    if (v21) {
      free(v21);
    }
    uint64_t v27 = @"Permission denied";
    uint64_t v28 = v4;
    int64_t v29 = 1001LL;
    goto LABEL_21;
  }

  int v8 = a1[23];
  uint64_t v9 = nplog_obj(v5, v6, v7);
  unsigned __int8 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  uint64_t v11 = v10;
  if (!v8)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31) = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "proxying to MPTCP converter proxy is not started",  (uint8_t *)&v31,  2u);
    }

    uint64_t v27 = @"proxying to MPTCP converter proxy is not started";
    uint64_t v28 = v4;
    int64_t v29 = 1004LL;
LABEL_21:
    sub_10006FFB4(v28, v29, v27);
    goto LABEL_22;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(v31) = 0;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "processing request to stop proxying to MPTCP converter proxy",  (uint8_t *)&v31,  2u);
  }

  sub_10006A0F4(a1, v12);
  id v13 = v4;
  xpc_object_t reply = xpc_dictionary_create_reply(v13);
  xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v13);
  uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);

  if (reply && v16) {
    xpc_connection_send_message(v16, reply);
  }

LABEL_22:
}

void sub_100060618(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set Private Access Tokens enabled",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 56),  "setPrivateAccessTokensEnabled:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyPrivateAccessTokensEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        id v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        id v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "setting private access token enablement failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_10006082C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling get Private Access Tokens enabled",  (uint8_t *)&v26,  2u);
      }

      unsigned __int8 v10 = [*(id *)(a1 + 56) getPrivateAccessTokensEnabled];
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      xpc_connection_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyPrivateAccessTokensEnabled", v10);
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      id v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v19) {
          __int128 v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "getting private access token enablement failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100060A4C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set Private Access Tokens allow tools",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 56),  "setPrivateAccessTokensAllowTools:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyPrivateAccessTokensEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        id v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        id v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "setting private access token enablement failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100060C60(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set Preferred Path Routing enablement",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 56),  "setPreferredPathRoutingEnabled:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        id v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        id v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "setting preferred path routing enablement failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100060E74(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v22) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Getting domain filters",  (uint8_t *)&v22,  2u);
      }

      id v10 = [*(id *)(a1 + 64) copyDomainFiltersDictionary];
      sub_100070150(v4, "NSPServerPrivacyProxyDomainFilters", v10);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      id v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v22 = 0u,
            memset(v23, 0, sizeof(v23)),
            proc_pidinfo(pid, 13, 1uLL, &v22, 64) == 64))
      {
        xpc_connection_t v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v23, 0x10uLL);
      }

      else
      {
        xpc_connection_t v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = "";
        if (v15) {
          uint64_t v21 = v15;
        }
        LODWORD(v22) = 136315138;
        *(void *)((char *)&v22 + 4) = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "getting domain filters failed due to missing entitlement for %s",  (uint8_t *)&v22,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100061050(id *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set in-process flow divert",  (uint8_t *)&v26,  2u);
      }

      objc_msgSend( a1[7],  "setInProcessFlowDivert:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyInProcessFlowDivertEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }

      xpc_connection_t v14 = (void *)objc_claimAutoreleasedReturnValue([a1[7] mergeProxyTrafficStateWithCurrentPolicy]);
      [a1 policiesUpdated:a1[7] policy:v14 resolverInfoChanged:1];
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v19) {
          __int128 v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "setting in-process flow divert failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100061294(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to override proxied content map enabled",  (uint8_t *)&v26,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerProxiedContentMapIdentifier");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      objc_msgSend( *(id *)(a1 + 64),  "overrideProxiedContentMap:enabled:",  string,  xpc_dictionary_get_BOOL(v4, "NSPServerProxiedContentMapEnabled"));
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      xpc_connection_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14) {
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        uint64_t v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int128 v25 = "";
        if (v19) {
          __int128 v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "overriding proxied content map enabled failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_1000614E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v27) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get the override proxied content map enabled state",  (uint8_t *)&v27,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerProxiedContentMapIdentifier");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      unsigned __int8 v11 = [*(id *)(a1 + 64) proxiedContentMapIsOverrideEnabled:string];
      id v12 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v12);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v12);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v15)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerProxiedContentMapEnabled", v11);
        xpc_connection_send_message(v15, reply);
      }
    }

    else
    {
      xpc_connection_t v16 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v16);
      uint64_t v18 = v17;
      if (v17
        && (pid_t pid = xpc_connection_get_pid(v17),
            __int128 v27 = 0u,
            memset(v28, 0, sizeof(v28)),
            proc_pidinfo(pid, 13, 1uLL, &v27, 64) == 64))
      {
        uint64_t v20 = (char *)malloc(0x10uLL);
        strncpy(v20, (const char *)v28, 0x10uLL);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      uint64_t v24 = nplog_obj(v21, v22, v23);
      __int128 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        __int128 v26 = "";
        if (v20) {
          __int128 v26 = v20;
        }
        LODWORD(v27) = 136315138;
        *(void *)((char *)&v27 + 4) = v26;
        _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "get proxied content map enabled failed due to missing entitlement for %s",  (uint8_t *)&v27,  0xCu);
      }

      if (v20) {
        free(v20);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100061740(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v25) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Handling set DoH bootstrap enablement",  (uint8_t *)&v25,  2u);
      }

      objc_msgSend( *(id *)(a1 + 64),  "setProxiedContentMapDoHBootstrapEnabled:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled"));
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v10);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v13) {
        xpc_connection_send_message(v13, reply);
      }
    }

    else
    {
      xpc_connection_t v14 = xpc_dictionary_get_remote_connection(v4);
      xpc_connection_t v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v14);
      xpc_connection_t v16 = v15;
      if (v15
        && (pid_t pid = xpc_connection_get_pid(v15),
            __int128 v25 = 0u,
            memset(v26, 0, sizeof(v26)),
            proc_pidinfo(pid, 13, 1uLL, &v25, 64) == 64))
      {
        uint64_t v18 = (char *)malloc(0x10uLL);
        strncpy(v18, (const char *)v26, 0x10uLL);
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      uint64_t v22 = nplog_obj(v19, v20, v21);
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = "";
        if (v18) {
          uint64_t v24 = v18;
        }
        LODWORD(v25) = 136315138;
        *(void *)((char *)&v25 + 4) = v24;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "setting doh bootstrap enablement failed due to missing entitlement for %s",  (uint8_t *)&v25,  0xCu);
      }

      if (v18) {
        free(v18);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100061954(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      string = xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyTokenEventsVendor");
      if (string) {
        uint64_t v6 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      else {
        uint64_t v6 = 0LL;
      }
      BOOL v17 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsMostRecent");
      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsLimit");
      BOOL v19 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsStats");
      BOOL v20 = v19;
      uint64_t v23 = nplog_obj(v19, v21, v22);
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG);
      if (v20)
      {
        if (v25)
        {
          LODWORD(buffer[0]) = 138412290;
          *(void *)((char *)buffer + 4) = v6;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "Getting Privacy Proxy Token Events Stats vendor: %@",  (uint8_t *)buffer,  0xCu);
        }

        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSPCoreData getMinMaxDate](&OBJC_CLASS___NSPCoreData, "getMinMaxDate"));
        __int128 v27 = v26;
        if (v26)
        {
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKey:@"minDate"]);
          int64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 objectForKey:@"maxDate"]);
          id v32 = v29;
          if (v28)
          {
            if (v29)
            {
              double v33 = (double)uint64;
              if (v17)
              {
                uint64_t v34 = objc_claimAutoreleasedReturnValue([v29 dateByAddingTimeInterval:v33 * -86400.0]);
                uint64_t v35 = v28;
                uint64_t v28 = (void *)v34;
              }

              else
              {
                uint64_t v57 = objc_claimAutoreleasedReturnValue([v28 dateByAddingTimeInterval:v33 * 86400.0]);
                uint64_t v35 = v32;
                id v32 = (id)v57;
              }

              id obja = v27;
              uint64_t v58 = v32;

              uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 30LL));
              uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSPCoreData getTokenCountStatsForMultipleWindows:minDate:maxDate:windowDuration:]( &OBJC_CLASS___NSPCoreData,  "getTokenCountStatsForMultipleWindows:minDate:maxDate:windowDuration:",  v6,  v28,  v58,  v59));

              id v61 = v60;
              id v32 = v28;
              id v62 = v58;
              uint64_t v63 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
              __int16 v66 = (void *)v63;
              if (v63)
              {
                __int128 v100 = (void *)v63;
                uint64_t v104 = v4;
                unsigned __int8 v67 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
                if (v67)
                {
                  uint64_t v70 = v67;
                  uint64_t v102 = v6;
                  id v97 = v62;
                  id v98 = v32;
                  -[NSMutableString appendFormat:](v67, "appendFormat:", @"Stats from %@ to %@\n", v32, v62);
                  -[NSMutableString appendString:]( v70,  "appendString:",  @"Time(HH:MM-HH:MM)   Mean    Standard Deviation\n");
                  __int128 v111 = 0u;
                  __int128 v112 = 0u;
                  __int128 v109 = 0u;
                  __int128 v110 = 0u;
                  id v96 = v61;
                  id v106 = v61;
                  id v71 = [v106 countByEnumeratingWithState:&v109 objects:buffer count:16];
                  if (v71)
                  {
                    id v72 = v71;
                    uint64_t v73 = 0LL;
                    uint64_t v74 = 0LL;
                    uint64_t v75 = *(void *)v110;
                    do
                    {
                      uint64_t v76 = 0LL;
                      uint64_t v77 = v73;
                      uint64_t v78 = v74;
                      do
                      {
                        if (*(void *)v110 != v75) {
                          objc_enumerationMutation(v106);
                        }
                        id v79 = *(void **)(*((void *)&v109 + 1) + 8LL * (void)v76);
                        else {
                          uint64_t v74 = (v78 + 1);
                        }
                        else {
                          uint64_t v73 = 0LL;
                        }
                        uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v109 + 1) + 8 * (void)v76) valueForKey:@"mean"]);
                        [v80 doubleValue];
                        uint64_t v82 = v81;

                        id v83 = (void *)objc_claimAutoreleasedReturnValue([v79 valueForKey:@"stdDev"]);
                        [v83 doubleValue];
                        double v85 = v84;

                        if (v85 >= 0.0) {
                          -[NSMutableString appendFormat:]( v70,  "appendFormat:",  @"%02d:%02d-%02d:%02d         %05.2f   %05.2f\n",  v78,  v77,  v74,  v73,  v82,  *(void *)&v85);
                        }
                        else {
                          -[NSMutableString appendFormat:]( v70,  "appendFormat:",  @"%02d:%02d-%02d:%02d         -----   -----\n",  v78,  v77,  v74,  v73,  v94,  v95);
                        }
                        uint64_t v76 = (char *)v76 + 1;
                        uint64_t v77 = v73;
                        uint64_t v78 = v74;
                      }

                      while (v72 != v76);
                      id v72 = [v106 countByEnumeratingWithState:&v109 objects:buffer count:16];
                    }

                    while (v72);
                  }

                  __int16 v66 = v100;
                  [v100 addObject:v70];
                  id v86 = v100;
                  uint64_t v6 = v102;
                  uint64_t v4 = v104;
                  id v62 = v97;
                  id v32 = v98;
                  id v61 = v96;
                }

                else
                {
                  uint64_t v92 = nplog_obj(0LL, v68, v69);
                  id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue(v92);
                  if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT))
                  {
                    LODWORD(buffer[0]) = 136315138;
                    *(void *)((char *)buffer + 4) = "-[NSPServer formatTokenEventsStatsForDisplay:minDate:maxDate:]";
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_FAULT,  "%s called with null statsStr",  (uint8_t *)buffer,  0xCu);
                  }

                  uint64_t v70 = 0LL;
                  id v86 = 0LL;
                  __int16 v66 = v100;
                }
              }

              else
              {
                uint64_t v91 = nplog_obj(0LL, v64, v65);
                uint64_t v70 = (NSMutableString *)objc_claimAutoreleasedReturnValue(v91);
                if (os_log_type_enabled((os_log_t)v70, OS_LOG_TYPE_FAULT))
                {
                  LODWORD(buffer[0]) = 136315138;
                  *(void *)((char *)buffer + 4) = "-[NSPServer formatTokenEventsStatsForDisplay:minDate:maxDate:]";
                  _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v70,  OS_LOG_TYPE_FAULT,  "%s called with null result",  (uint8_t *)buffer,  0xCu);
                }

                id v86 = 0LL;
              }

              sub_100070A70(v4, v86);
              __int128 v27 = obja;
            }

            else
            {
              uint64_t v90 = nplog_obj(0LL, v30, v31);
              id v62 = (id)objc_claimAutoreleasedReturnValue(v90);
              if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_FAULT))
              {
                LODWORD(buffer[0]) = 136315138;
                *(void *)((char *)buffer + 4) = "-[NSPServer dumpPrivacyProxyTokenEvents:]";
                _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v62,  OS_LOG_TYPE_FAULT,  "%s called with null maxDate",  (uint8_t *)buffer,  0xCu);
              }

              id v32 = v28;
            }
          }

          else
          {
            uint64_t v89 = nplog_obj(v29, v30, v31);
            id v62 = (id)objc_claimAutoreleasedReturnValue(v89);
            if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_FAULT))
            {
              LODWORD(buffer[0]) = 136315138;
              *(void *)((char *)buffer + 4) = "-[NSPServer dumpPrivacyProxyTokenEvents:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v62,  OS_LOG_TYPE_FAULT,  "%s called with null minDate",  (uint8_t *)buffer,  0xCu);
            }
          }
        }

        else
        {
          sub_10006FFB4(v4, 1007LL, @"Failed to retrieve data");
        }
      }

      else
      {
        __int128 v103 = v4;
        if (v25)
        {
          int v88 = "No";
          LODWORD(buffer[0]) = 138412802;
          *(void *)((char *)buffer + 4) = v6;
          if (v17) {
            int v88 = "Yes";
          }
          WORD6(buffer[0]) = 2080;
          *(void *)((char *)buffer + 14) = v88;
          WORD3(buffer[1]) = 2048;
          *((void *)&buffer[1] + 1) = uint64;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "Getting Privacy Proxy Token Events vendor: %@, most_recent: %s, limist:%llu",  (uint8_t *)buffer,  0x20u);
        }

        id v101 = v6;
        id v36 = (id)objc_claimAutoreleasedReturnValue( +[NSPCoreData fetchEvents:mostRecent:limit:]( &OBJC_CLASS___NSPCoreData,  "fetchEvents:mostRecent:limit:",  v6,  v17,  uint64));
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( [@"Date" stringByPaddingToLength:27 withString:@" " startingAtIndex:0]);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( [@"Vendor" stringByPaddingToLength:22 withString:@" " startingAtIndex:0]);
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( [@"Event" stringByPaddingToLength:22 withString:@" " startingAtIndex:0]);
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( [@"Token count" stringByPaddingToLength:22 withString:@" " startingAtIndex:0]);
        unsigned __int8 v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@%@%@%@",  v38,  v39,  v40,  v41));

        [v37 addObject:v42];
        id v105 = v42;
        SEL v43 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( &stru_1001009D0,  "stringByPaddingToLength:withString:startingAtIndex:",  objc_msgSend(v42, "length"),  @"-",  0));
        uint64_t v44 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v43));

        uint64_t v45 = v37;
        __int16 v99 = (void *)v44;
        [v37 addObject:v44];
        __int128 v111 = 0u;
        __int128 v112 = 0u;
        __int128 v109 = 0u;
        __int128 v110 = 0u;
        id obj = v36;
        id v46 = [obj countByEnumeratingWithState:&v109 objects:buffer count:16];
        if (v46)
        {
          id v47 = v46;
          uint64_t v48 = *(void *)v110;
          do
          {
            for (i = 0LL; i != v47; i = (char *)i + 1)
            {
              if (*(void *)v110 != v48) {
                objc_enumerationMutation(obj);
              }
              uint64_t v50 = *(void **)(*((void *)&v109 + 1) + 8LL * (void)i);
              id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 vendor]);
              pid_t v52 = (void *)objc_claimAutoreleasedReturnValue( [v51 stringByPaddingToLength:20 withString:@" " startingAtIndex:0]);

              __int128 v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSPCoreData tokenTypeEnumToString:]( NSPCoreData,  "tokenTypeEnumToString:",  [v50 eventType]));
              uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( [v53 stringByPaddingToLength:20 withString:@" " startingAtIndex:0]);

              uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v50 date]);
              uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@  %@  %@  %d",  v55,  v52,  v54,  [v50 tokenCount]));

              [v45 addObject:v56];
            }

            id v47 = [obj countByEnumeratingWithState:&v109 objects:buffer count:16];
          }

          while (v47);
        }

        __int128 v27 = obj;

        uint64_t v4 = v103;
        sub_100070A70(v103, v45);

        uint64_t v6 = v101;
      }
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      uint64_t v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      uint64_t v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8), memset(buffer, 0, 64), proc_pidinfo(pid, 13, 1uLL, buffer, 64) == 64))
      {
        unsigned __int8 v11 = (char *)malloc(0x10uLL);
        strncpy(v11, (const char *)&buffer[1], 0x10uLL);
      }

      else
      {
        unsigned __int8 v11 = 0LL;
      }

      uint64_t v15 = nplog_obj(v12, v13, v14);
      xpc_connection_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v87 = "";
        if (v11) {
          unsigned __int8 v87 = v11;
        }
        LODWORD(buffer[0]) = 136315138;
        *(void *)((char *)buffer + 4) = v87;
        _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "dumping privacy proxy token events failed due to missing entitlement for %s",  (uint8_t *)buffer,  0xCu);
      }

      if (v11) {
        free(v11);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_1000623B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy") & 1) != 0)
    {
      uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      if (v5)
      {
        xpc_object_t value = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsEnableProactiveTokenFetch");
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(value);

        if (v7)
        {
          uint64_t v8 = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsEnableProactiveTokenFetch"));
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
          -[NSMutableDictionary setObject:forKey:]( v5,  "setObject:forKey:",  v9,  @"NSPEventsKeyProactiveTokenFetchEnabled");
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        xpc_object_t v20 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetStatsDuration");
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);

        if (v21)
        {
          uint64_t v22 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetStatsDuration"));
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
          -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v23, @"NSPEventsKeyStatsDuration");
        }

        else
        {
          uint64_t v23 = 0LL;
        }

        xpc_object_t v24 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountThreshold");
        BOOL v25 = (void *)objc_claimAutoreleasedReturnValue(v24);

        if (v25)
        {
          __int128 v26 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountThreshold"));
          __int128 v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
          -[NSMutableDictionary setObject:forKey:]( v5,  "setObject:forKey:",  v27,  @"NSPEventsKeyLowerTokenCountThreshold");
        }

        else
        {
          __int128 v27 = 0LL;
        }

        xpc_object_t v28 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountProbability");
        int64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);

        if (v29)
        {
          uint64_t v30 = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  xpc_dictionary_get_double(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountProbability"));
          uint64_t v31 = objc_claimAutoreleasedReturnValue(v30);
          -[NSMutableDictionary setObject:forKey:]( v5,  "setObject:forKey:",  v31,  @"NSPEventsKeyLowerTokenCountProbability");
        }

        else
        {
          uint64_t v31 = 0LL;
        }

        xpc_object_t v32 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountThreshold");
        double v33 = (void *)objc_claimAutoreleasedReturnValue(v32);

        if (v33)
        {
          uint64_t v34 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountThreshold"));
          uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
          -[NSMutableDictionary setObject:forKey:]( v5,  "setObject:forKey:",  v35,  @"NSPEventsKeyUpperLWMCountThreshold");
        }

        else
        {
          uint64_t v35 = 0LL;
        }

        xpc_object_t v36 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountProbabilityOffset");
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);

        if (v37)
        {
          uint64_t v38 = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  xpc_dictionary_get_double(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountProbabilityOffset"));
          uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
          -[NSMutableDictionary setObject:forKey:]( v5,  "setObject:forKey:",  v39,  @"NSPEventsKeyUpperLWMCountProbabilityOffset");
        }

        else
        {
          uint64_t v39 = 0LL;
        }

        uint64_t v40 = (void *)v31;
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSPCoreData updateProactiveTokenFetchConfiguration:statsDuration:lowerTokenCountThreshold:lowerTokenCountProbability:upperLWMCountThreshold:upperLWMCountProbabilityOffset:]( &OBJC_CLASS___NSPCoreData,  "updateProactiveTokenFetchConfiguration:statsDuration:lowerTokenCountThreshold:lowerTokenCountP robability:upperLWMCountThreshold:upperLWMCountProbabilityOffset:",  v9,  v23,  v27,  v31,  v35,  v39));
        if (v41)
        {
          uint64_t v48 = v23;
          xpc_connection_t v49 = v27;
          unsigned __int8 v42 = v9;
          id v43 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v43);
          xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v43);
          id v46 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

          if (reply && v46) {
            xpc_connection_send_message(v46, reply);
          }

          uint64_t v9 = v42;
          uint64_t v23 = v48;
          __int128 v27 = v49;
        }

        else
        {
          sub_10006FFB4(v4, 1007LL, @"updateProactiveTokenFetchConfiguration Failed");
        }
      }

      else
      {
        sub_10006FFB4(v4, 1007LL, @"Failed allocate dictionary");
      }
    }

    else
    {
      xpc_connection_t v10 = xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v10);
      uint64_t v12 = v11;
      if (v11
        && (pid_t pid = xpc_connection_get_pid(v11),
            __int128 buffer = 0u,
            memset(v51, 0, sizeof(v51)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        uint64_t v14 = (char *)malloc(0x10uLL);
        strncpy(v14, (const char *)v51, 0x10uLL);
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      uint64_t v18 = nplog_obj(v15, v16, v17);
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        id v47 = "";
        if (v14) {
          id v47 = v14;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v47;
        _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "Setting Proactive Token Fetch Params failed due to missing entitlement for %s",  (uint8_t *)&buffer,  0xCu);
      }

      if (v14) {
        free(v14);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100062874(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v26) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to override the preferred oblivious proxy",  (uint8_t *)&v26,  2u);
      }

      string = (NSString *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      }
      if (!-[NSString length](string, "length"))
      {

        string = 0LL;
      }

      [*(id *)(a1 + 64) overridePreferredObliviousProxy:string];
      id v11 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v11);
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v11);
      uint64_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

      if (reply && v14) {
        xpc_connection_send_message(v14, reply);
      }
    }

    else
    {
      xpc_connection_t v15 = xpc_dictionary_get_remote_connection(v4);
      uint64_t v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = v16;
      if (v16
        && (pid_t pid = xpc_connection_get_pid(v16),
            __int128 v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        BOOL v19 = (char *)malloc(0x10uLL);
        strncpy(v19, (const char *)v27, 0x10uLL);
      }

      else
      {
        BOOL v19 = 0LL;
      }

      uint64_t v23 = nplog_obj(v20, v21, v22);
      xpc_object_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        BOOL v25 = "";
        if (v19) {
          BOOL v25 = v19;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "overriding preferred oblivious proxy failed due to missing entitlement for %s",  (uint8_t *)&v26,  0xCu);
      }

      if (v19) {
        free(v19);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100062AC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = sub_10006F5DC(v3, @"com.apple.private.networkserviceproxy");
    if ((v5 & 1) != 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v22) = 0;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "processing request to get the preferred oblivious proxy",  (uint8_t *)&v22,  2u);
      }

      xpc_connection_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) overridePreferredObliviousProxy]);
      sub_10006F67C(v4, "NSPServerPrivacyProxyURL", v10);
    }

    else
    {
      xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v4);
      uint64_t v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
      uint64_t v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            __int128 v22 = 0u,
            memset(v23, 0, sizeof(v23)),
            proc_pidinfo(pid, 13, 1uLL, &v22, 64) == 64))
      {
        xpc_connection_t v15 = (char *)malloc(0x10uLL);
        strncpy(v15, (const char *)v23, 0x10uLL);
      }

      else
      {
        xpc_connection_t v15 = 0LL;
      }

      uint64_t v19 = nplog_obj(v16, v17, v18);
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = "";
        if (v15) {
          uint64_t v21 = v15;
        }
        LODWORD(v22) = 136315138;
        *(void *)((char *)&v22 + 4) = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "get preferred oblivious proxy failed due to missing entitlement for %s",  (uint8_t *)&v22,  0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_10006FFB4(v4, 1001LL, @"Permission denied");
    }
  }
}

void sub_100062CA8(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Requesting clean exit after client request",  v5,  2u);
  }

  xpc_transaction_exit_clean();
}

void sub_100062D10(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    int64_t int64 = xpc_dictionary_get_int64(object, "NSPServerCommandType");
    switch(int64)
    {
      case 'F':
        sub_10005F588(*(id **)(a1 + 32), object);
        break;
      case 'G':
        sub_10005F6B8(*(void *)(a1 + 32), object);
        break;
      case 'H':
        sub_10005F8B0(*(void *)(a1 + 32), object);
        break;
      case 'I':
        sub_10005FB30(*(void *)(a1 + 32), object);
        break;
      default:
        if (int64 == 60)
        {
          sub_10005FDD0(*(void *)(a1 + 32), object);
        }

        else
        {
          if (int64 != 51)
          {
            xpc_connection_cancel(*(xpc_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
            goto LABEL_3;
          }

          sub_10005E9EC(*(id **)(a1 + 32), object);
        }

        break;
    }
  }

  else
  {
LABEL_3:
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0LL;
  }
}

void sub_100062E28(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Requesting clean exit after client token request",  v5,  2u);
  }

  xpc_transaction_exit_clean();
}

void sub_1000633F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id location)
{
}

void sub_10006340C(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 11))
    {
      [*(id *)(v2 + 104) removeObserver:v2 forKeyPath:@"path" context:v2];
      uint64_t v4 = *(void **)(v2 + 104);
      *(void *)(v2 + 104) = 0LL;
    }

    id Property = (dispatch_source_s *)objc_getProperty((id)v2, a2, 240LL, 1);
    dispatch_source_cancel(Property);
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7 && *(_BYTE *)(v7 + 9))
    {
      *(_BYTE *)(v7 + 10) = 1;
      id v8 = *(id *)(a1 + 32);
      if (v8) {
        id v8 = objc_getProperty(v8, v6, 264LL, 1);
      }
      sub_10009D6E8((uint64_t)v8, 0);
    }
  }

  exit(0);
}

void sub_1000634A0(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      id v9 = object;
      xpc_connection_t v10 = v9;
      if (v8)
      {
        *(void *)&__int128 buf = 0LL;
        *((void *)&buf + 1) = &buf;
        uint64_t v19 = 0x3032000000LL;
        uint64_t v20 = sub_100057300;
        uint64_t v21 = sub_100057310;
        id v11 = v9;
        id v22 = v11;
        uint64_t v12 = NPGetInternalQueue(v11);
        uint64_t v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
        xpc_connection_set_target_queue((xpc_connection_t)v11, v13);

        uint64_t v14 = *(_xpc_connection_s **)(*((void *)&buf + 1) + 40LL);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_100057318;
        handler[3] = &unk_1000F9F78;
        void handler[4] = v8;
        void handler[5] = &buf;
        xpc_connection_set_event_handler(v14, handler);
        xpc_connection_resume(*(xpc_connection_t *)(*((void *)&buf + 1) + 40LL));
        if (deviceClassIsHomepod())
        {
          dispatch_time_t v15 = dispatch_time(0LL, 30000000000LL);
          dispatch_after(v15, &_dispatch_main_q, &stru_1000F9F98);
        }

        _Block_object_dispose(&buf, 8);
      }
    }

    else
    {
      xpc_type_t type = xpc_get_type(object);
      if (type == (xpc_type_t)&_xpc_type_error)
      {
        uint64_t v6 = nplog_obj(type, v4, v5);
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = xpc_dictionary_get_string(object, _xpc_error_key_description);
          _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Exiting, got invalid XPC connection: %s",  (uint8_t *)&buf,  0xCu);
        }

        exit(1);
      }
    }
  }
}

void sub_1000636A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1000636C4(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      id v9 = object;
      xpc_connection_t v10 = v9;
      if (v8)
      {
        *(void *)&__int128 buf = 0LL;
        *((void *)&buf + 1) = &buf;
        uint64_t v19 = 0x3032000000LL;
        uint64_t v20 = sub_100057300;
        uint64_t v21 = sub_100057310;
        id v11 = v9;
        id v22 = v11;
        uint64_t v12 = NPGetInternalQueue(v11);
        uint64_t v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
        xpc_connection_set_target_queue((xpc_connection_t)v11, v13);

        uint64_t v14 = *(_xpc_connection_s **)(*((void *)&buf + 1) + 40LL);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_100062D10;
        handler[3] = &unk_1000F9F78;
        void handler[4] = v8;
        void handler[5] = &buf;
        xpc_connection_set_event_handler(v14, handler);
        xpc_connection_resume(*(xpc_connection_t *)(*((void *)&buf + 1) + 40LL));
        if (deviceClassIsHomepod())
        {
          dispatch_time_t v15 = dispatch_time(0LL, 30000000000LL);
          dispatch_after(v15, &_dispatch_main_q, &stru_1000F9FB8);
        }

        _Block_object_dispose(&buf, 8);
      }
    }

    else
    {
      xpc_type_t type = xpc_get_type(object);
      if (type == (xpc_type_t)&_xpc_type_error)
      {
        uint64_t v6 = nplog_obj(type, v4, v5);
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = xpc_dictionary_get_string(object, _xpc_error_key_description);
          _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Exiting, got invalid token fetch XPC connection: %s",  (uint8_t *)&buf,  0xCu);
        }

        exit(1);
      }
    }
  }
}

void sub_1000638C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1000638E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Toggle stats timer fired", (uint8_t *)v9, 2u);
  }

  uint64_t v6 = (void *)os_transaction_create("com.apple.networkserviceproxy.toggleStatsTimerFired");
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained[41] resetStats];
  }
}

void sub_100063980(id *a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a1[5] enabled]);
    unsigned __int8 v5 = [v4 BOOLValue];

    uint64_t v9 = nplog_obj(v6, v7, v8);
    xpc_connection_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if ((v5 & 1) != 0)
    {
      if (v11)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Refreshing metadata in response to XPC activity notification",  buf,  2u);
      }

      xpc_activity_set_state(v3, 4LL);
      objc_initWeak(&location, a1);
      *(void *)__int128 buf = 0LL;
      uint64_t v18 = buf;
      uint64_t v19 = 0x3032000000LL;
      uint64_t v20 = sub_100057300;
      uint64_t v21 = sub_100057310;
      id v22 = (id)os_transaction_create("com.apple.networkserviceproxy.configRefresh");
      id v12 = a1[7];
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _DWORD v13[2] = sub_100063CAC;
      v13[3] = &unk_1000FA028;
      objc_copyWeak(&v16, &location);
      uint64_t v14 = v3;
      dispatch_time_t v15 = buf;
      [v12 refreshConfigurationWithReason:1 completionHandler:v13];

      objc_destroyWeak(&v16);
      _Block_object_dispose(buf, 8);

      objc_destroyWeak(&location);
    }

    else
    {
      if (v11)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Metadata refresh XPC activity is finished because NSP is disabled",  buf,  2u);
      }

      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      v24[2] = sub_100063BB0;
      _OWORD v24[3] = &unk_1000F9450;
      BOOL v25 = v3;
      sub_100063BBC(a1, v24);
    }
  }
}

void sub_100063B80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

BOOL sub_100063BB0(uint64_t a1)
{
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5LL);
}

void sub_100063BBC(void *a1, void *a2)
{
  id v3 = a2;
  xpc_activity_unregister("com.apple.networkserviceproxy.metadata-refresh-22h");
  objc_initWeak(&location, a1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100064110;
  handler[3] = &unk_1000FA070;
  objc_copyWeak(&v7, &location);
  id v4 = v3;
  id v6 = v4;
  xpc_activity_register("com.apple.networkserviceproxy.metadata-refresh-22h", XPC_ACTIVITY_CHECK_IN, handler);

  objc_destroyWeak(&v7);
  objc_destroyWeak(&location);
}

void sub_100063C90(_Unwind_Exception *a1)
{
}

void sub_100063CAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = @"failure";
    if (v3) {
      id v7 = @"success";
    }
    *(_DWORD *)__int128 buf = 138412290;
    xpc_object_t v28 = (void *)v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Configuration refresh activity finished with result %@",  buf,  0xCu);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v9 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained[8] removeExpiredTokens];
    sub_100063EFC((uint64_t)v9);
    uint32_t v10 = arc4random_uniform(0x64u);
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue([v9[5] proxyConfiguration]);
    unsigned int v12 = [v11 hasPreferredPathEnabledPercentage];

    unsigned int v16 = 80;
    if (v12)
    {
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v9[5] proxyConfiguration]);
      unsigned int v18 = [v17 preferredPathEnabledPercentage];

      if (v18 >= 0x50) {
        unsigned int v16 = 80;
      }
      else {
        unsigned int v16 = v18;
      }
    }

    uint64_t v19 = nplog_obj(v13, v14, v15);
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = "Disabling";
      if (v10 < v16) {
        uint64_t v21 = "Enabling";
      }
      *(_DWORD *)__int128 buf = 136446210;
      xpc_object_t v28 = (void *)v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "%{public}s preferred path routing based on random value",  buf,  0xCu);
    }

    [v9[7] setPreferredPathRoutingEnabled:v10 < v16];
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472LL;
    v25[2] = sub_100064034;
    _OWORD v25[3] = &unk_1000F9450;
    id v26 = *(id *)(a1 + 32);
    sub_100063BBC(v9, v25);
  }

  uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v23 = *(void **)(v22 + 40);
  *(void *)(v22 + 40) = 0LL;

  if (deviceClassIsHomepod())
  {
    dispatch_time_t v24 = dispatch_time(0LL, 30000000000LL);
    dispatch_after(v24, &_dispatch_main_q, &stru_1000FA000);
  }
}

void sub_100063EFC(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[AKAccountManager sharedInstance](&OBJC_CLASS___AKAccountManager, "sharedInstance"));
    int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 primaryAuthKitAccount]);
    SEL v4 = NSSelectorFromString(@"privateAttestationEnabledForAccount:");
    uint64_t v5 = objc_opt_respondsToSelector(v2, v4);
    if ((v5 & 1) != 0)
    {
      uint64_t v5 = (uint64_t)[v2 performSelector:v4 withObject:v3];
      BOOL v8 = v5 != 0;
    }

    else
    {
      BOOL v8 = 1LL;
    }

    uint64_t v9 = nplog_obj(v5, v6, v7);
    uint32_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11[0] = 67109120;
      v11[1] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Private access tokens enabled on account: %u",  (uint8_t *)v11,  8u);
    }
  }

BOOL sub_100064034(uint64_t a1)
{
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5LL);
}

void sub_100064040(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  SEL v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Requesting clean exit after refresh activity",  v5,  2u);
  }

  xpc_transaction_exit_clean();
}

void sub_1000640A8(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  SEL v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Requesting clean exit after publish stats activity",  v5,  2u);
  }

  xpc_transaction_exit_clean();
}

void sub_100064110(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  uint64_t v7 = nplog_obj(state, v5, v6);
  BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    xpc_activity_state_t v22 = state;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Metadata refresh XPC activity 22 hour state %ld",  buf,  0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    if (!WeakRetained)
    {
      xpc_activity_set_state(v3, 5LL);
      goto LABEL_11;
    }

    uint64_t v14 = WeakRetained;
    uint64_t v15 = NPGetInternalQueue(WeakRetained);
    unsigned int v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v15);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_100064354;
    v18[3] = &unk_1000F9A80;
    id v19 = v14;
    uint64_t v20 = v3;
    xpc_object_t v12 = v14;
    dispatch_async(v16, v18);
  }

  else
  {
    if (state) {
      goto LABEL_9;
    }
    objc_opt_self(&OBJC_CLASS___NSPServer);
    xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_REPEATING, 1);
    xpc_dictionary_set_int64(v12, XPC_ACTIVITY_DELAY, 79200LL);
    xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_ALLOW_BATTERY, 1);
    xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_REQUIRE_INEXPENSIVE_NETWORK_CONNECTIVITY, 0);
    xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_SHOULD_WAKE_DEVICE, 1);
    xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY, 1);
    xpc_dictionary_set_int64(v12, XPC_ACTIVITY_GRACE_PERIOD, 3600LL);
    xpc_activity_set_criteria(v3, v12);
  }

LABEL_9:
  uint64_t v17 = *(void *)(a1 + 32);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 16))(v17, v9, v10, v11);
  }
LABEL_11:
}

uint64_t sub_100064354(uint64_t a1)
{
  return sub_100063980(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

void sub_100064360(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  uint64_t v7 = nplog_obj(state, v5, v6);
  BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    xpc_activity_state_t v17 = state;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Metadata refresh XPC activity 12 hour state %ld",  buf,  0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    uint64_t v10 = WeakRetained;
    if (WeakRetained)
    {
      uint64_t v11 = NPGetInternalQueue(WeakRetained);
      xpc_object_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v11);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _DWORD v13[2] = sub_1000644B4;
      v13[3] = &unk_1000F9A80;
      id v14 = v10;
      uint64_t v15 = v3;
      dispatch_async(v12, v13);
    }

    else
    {
      xpc_activity_set_state(v3, 5LL);
    }
  }
}

void sub_1000644B4(uint64_t a1)
{
}

void sub_1000644C0(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  uint64_t v7 = nplog_obj(state, v5, v6);
  BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    xpc_activity_state_t v17 = state;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Metadata refresh XPC activity 22 hour state %ld",  buf,  0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    uint64_t v10 = WeakRetained;
    if (WeakRetained)
    {
      uint64_t v11 = NPGetInternalQueue(WeakRetained);
      xpc_object_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v11);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _DWORD v13[2] = sub_100064614;
      v13[3] = &unk_1000F9A80;
      id v14 = v10;
      uint64_t v15 = v3;
      dispatch_async(v12, v13);
    }

    else
    {
      xpc_activity_set_state(v3, 5LL);
    }
  }
}

void sub_100064614(uint64_t a1)
{
}

void sub_100064620(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  uint64_t v7 = nplog_obj(state, v5, v6);
  BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    xpc_activity_state_t v19 = state;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Publish daily stats XPC activity state %ld",  buf,  0xCu);
  }

  if (deviceClassIsHomepod(v9))
  {
    dispatch_time_t v10 = dispatch_time(0LL, 10000000000LL);
    dispatch_after(v10, &_dispatch_main_q, &stru_1000FA0B8);
    xpc_activity_set_state(v3, 5LL);
  }

  else if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    xpc_object_t v12 = WeakRetained;
    if (WeakRetained)
    {
      uint64_t v13 = NPGetInternalQueue(WeakRetained);
      id v14 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v13);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      v15[2] = sub_10006481C;
      v15[3] = &unk_1000F9A80;
      id v16 = v12;
      xpc_activity_state_t v17 = v3;
      dispatch_async(v14, v15);
    }

    else
    {
      xpc_activity_set_state(v3, 5LL);
    }
  }
}

void sub_1000647B4(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  SEL v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Requesting clean exit after daily stats event",  v5,  2u);
  }

  xpc_transaction_exit_clean();
}

void sub_10006481C(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 32);
  uint64_t v3 = (_xpc_activity_s *)*(id *)(a1 + 40);
  uint64_t v6 = v3;
  if (v2)
  {
    uint64_t v7 = nplog_obj(v3, v4, v5);
    BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Publish daily stats", buf, 2u);
    }

    [v2[7] publishDailyConfigurationStats];
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v2[5] enabled]);
    unsigned int v10 = [v9 BOOLValue];

    if (v10)
    {
      [v2[9] publishDailyServiceStatus];
      [v2[9] publishDailyNetworkStatus];
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v2[5] geohashSharingEnabledStatus]);
      unsigned int v12 = [v11 BOOLValue];

      uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NSPIPAddressLocationPreferenceStats);
      id v14 = v13;
      if (v12) {
        uint64_t v15 = 1LL;
      }
      else {
        uint64_t v15 = 2LL;
      }
      -[NSPIPAddressLocationPreferenceStats setLocationPreference:](v13, "setLocationPreference:", v15);
      id v16 = (void *)objc_claimAutoreleasedReturnValue([v2[5] userTier]);
      id v17 = [v16 intValue];
      if (v17 >= 3) {
        unsigned int v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v17));
      }
      else {
        unsigned int v18 = *(&off_1000FA520 + (int)v17);
      }
      -[NSPIPAddressLocationPreferenceStats setTierType:](v14, "setTierType:", v18);

      -[NSPProxyAnalytics sendAnalytics](v14, "sendAnalytics");
    }

    BOOL v19 = xpc_activity_set_state(v6, 5LL);
    if (deviceClassIsHomepod(v19))
    {
      dispatch_time_t v20 = dispatch_time(0LL, 30000000000LL);
      dispatch_after(v20, &_dispatch_main_q, &stru_1000FA048);
    }
  }
}

void sub_1000649CC(uint64_t a1)
{
  if (a1)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100064A3C;
    block[3] = &unk_1000F9450;
    void block[4] = a1;
    if (qword_100117158 != -1) {
      dispatch_once(&qword_100117158, block);
    }
  }

void sub_100064A3C(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    if (objc_getProperty(v3, a2, 248LL, 1))
    {
      id Property = *(id *)(a1 + 32);
      if (Property) {
        id Property = objc_getProperty(Property, v4, 248LL, 1);
      }
      xpc_connection_resume((xpc_connection_t)Property);
      +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-xpc-listen-ready",  random());
    }

    uint64_t v6 = *(void **)(a1 + 32);
    if (v6 && objc_getProperty(v6, v4, 256LL, 1))
    {
      id v8 = *(id *)(a1 + 32);
      if (v8) {
        id v8 = objc_getProperty(v8, v7, 256LL, 1);
      }
      xpc_connection_resume((xpc_connection_t)v8);
    }
  }

void sub_100064AE0(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = NPGetInternalQueue(a1);
    uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100064B50;
    block[3] = &unk_1000F9450;
    void block[4] = a1;
    dispatch_async(v3, block);
  }

void sub_100064B50(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100064BC0;
  block[3] = &unk_1000F9450;
  void block[4] = *(void *)(a1 + 32);
  if (qword_100117160 != -1) {
    dispatch_once(&qword_100117160, block);
  }
}

void sub_100064BC0(uint64_t a1)
{
  uint64_t v2 = MKBDeviceUnlockedSinceBoot();
  if ((_DWORD)v2)
  {
    CFPreferencesFlushCaches(v2);
    sub_100064D38(*(void **)(a1 + 32), v3, v4);
  }

  else
  {
    int out_token = -1;
    id inited = objc_initWeak(&location, *(id *)(a1 + 32));
    uint64_t v6 = NPGetInternalQueue(inited);
    uint64_t v7 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v6);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100065028;
    handler[3] = &unk_1000FA0E0;
    objc_copyWeak(&v19, &location);
    uint32_t v8 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", &out_token, v7, handler);

    if (v8)
    {
      uint64_t v12 = nplog_obj(v9, v10, v11);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v17 = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Failed to register for first unlock notification.",  v17,  2u);
      }
    }

    else if (MKBDeviceUnlockedSinceBoot())
    {
      uint64_t v14 = notify_cancel(out_token);
      CFPreferencesFlushCaches(v14);
      sub_100064D38(*(void **)(a1 + 32), v15, v16);
    }

    objc_destroyWeak(&v19);
    objc_destroyWeak(&location);
  }

void sub_100064D0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_100064D38(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Creating configuration from settings on disk",  buf,  2u);
    }

    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSPConfiguration defaultConfiguration](&OBJC_CLASS___NSPConfiguration, "defaultConfiguration"));
    uint64_t v9 = v6;
    if (v6)
    {
      id v10 = [v6 copy];
      uint64_t v11 = (void *)a1[5];
      a1[5] = v10;

      if (a1[5])
      {
        id v15 = -[NSPConfiguration initFromPreferences](objc_alloc(&OBJC_CLASS___NSPConfiguration), "initFromPreferences");
        id v16 = [[NSPConfigurationSignatureInfo alloc] initFromPreferences];
        id v17 = v16;
        if (v15 && v16)
        {
          objc_initWeak((id *)buf, a1);
          int v18 = os_variant_allows_internal_security_policies("com.apple.networkserviceproxy");
          if (v18) {
            uint64_t v19 = [v15 ignoreInvalidCerts] ^ 1;
          }
          else {
            uint64_t v19 = 1LL;
          }
          dispatch_time_t v20 = (void *)objc_claimAutoreleasedReturnValue([v15 proxyConfigurationData]);
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v15 configServerHost]);
          v25[0] = _NSConcreteStackBlock;
          v25[1] = 3221225472LL;
          v25[2] = sub_1000650B0;
          _OWORD v25[3] = &unk_1000FA108;
          objc_copyWeak(&v28, (id *)buf);
          id v26 = v15;
          id v27 = v9;
          char v29 = v18 ^ 1;
          +[NSPConfiguration verifyConfigurationSignature:configuration:host:validateCert:completionHandler:]( &OBJC_CLASS___NSPConfiguration,  "verifyConfigurationSignature:configuration:host:validateCert:completionHandler:",  v17,  v20,  v21,  v19,  v25);

          objc_destroyWeak(&v28);
          objc_destroyWeak((id *)buf);
        }

        else
        {
          sub_1000653B8((uint64_t)a1);
        }

        goto LABEL_14;
      }

      uint64_t v24 = nplog_obj(v12, v13, v14);
      id v15 = (id)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v31 = "-[NSPServer configurationSetup]";
        uint64_t v23 = "%s called with null self.configuration";
        goto LABEL_20;
      }
    }

    else
    {
      uint64_t v22 = nplog_obj(0LL, v7, v8);
      id v15 = (id)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v31 = "-[NSPServer configurationSetup]";
        uint64_t v23 = "%s called with null defaultConfiguration";
LABEL_20:
        _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v15, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
      }
    }

void sub_100064FFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_100065028(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Received first unlock notification.", v9, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    CFPreferencesFlushCaches();
    sub_100064D38(WeakRetained, v7, v8);
  }
}

void sub_1000650B0(uint64_t a1, int a2)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v5 = objc_alloc(&OBJC_CLASS___NSPPrivacyProxyConfiguration);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) proxyConfigurationData]);
    id v7 = [v5 initWithData:v6];
    [*(id *)(a1 + 32) setProxyConfiguration:v7];

    [WeakRetained[5] merge:*(void *)(a1 + 32)];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) configServerPath]);
    id v9 = WeakRetained[5];
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 configServerPath]);
    if ([v8 isEqualToString:v10])
    {
      if (*(_BYTE *)(a1 + 56))
      {
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) configServerHost]);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[5] configServerHost]);
        unsigned int v13 = [v11 isEqualToString:v12];
      }

      else
      {
        unsigned int v13 = 1;
      }
    }

    else
    {
      unsigned int v13 = 0;
    }

    if (a2)
    {
      id v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) proxyConfiguration]);
      if (v17) {
        unsigned int v18 = v13;
      }
      else {
        unsigned int v18 = 0;
      }

      if (v18 == 1)
      {
        uint64_t v22 = nplog_obj(v19, v20, v21);
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(v31) = 0;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "Starting with configuration settings from disk",  (uint8_t *)&v31,  2u);
        }

void sub_1000653B8(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSPConfigurationManager);
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = -[NSPConfigurationManager initWithDelegate:configuration:](v2, "initWithDelegate:configuration:", a1, v3);
  id v5 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v4;

  if (*(void *)(a1 + 56))
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    v20[2] = sub_1000655EC;
    v20[3] = &unk_1000F9450;
    v20[4] = a1;
    [v9 startOwnerModeWithEventName:@"com.apple.networkserviceproxy.file-descriptor-maintainer" handlesReceivedCallback:v20];

    uint64_t v11 = NPGetInternalQueue(v10);
    uint64_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v11);
    xpc_set_event_stream_handler("com.apple.networkserviceproxy", v12, &stru_1000FA148);

    uint64_t v14 = NPGetInternalQueue(v13);
    uint64_t v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    v19[2] = sub_100066818;
    v19[3] = &unk_1000F9FE0;
    void v19[4] = a1;
    xpc_set_event_stream_handler("com.apple.notifyd.matching", v15, v19);

    xpc_object_t v16 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_BOOL(v16, "Ready", 1);
    pid_t v17 = getpid();
    xpc_dictionary_set_int64(v16, "PID", v17);
    xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", v16);
  }

  else
  {
    uint64_t v18 = nplog_obj(v6, v7, v8);
    xpc_object_t v16 = (xpc_object_t)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v22 = "-[NSPServer start]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v16,  OS_LOG_TYPE_FAULT,  "%s called with null self.configurationManager",  buf,  0xCu);
    }
  }
}

void sub_1000655EC(uint64_t a1)
{
  uint64_t v2 = kdebug_trace(732954640LL, 0LL, 0LL, 0LL, 0LL);
  uint64_t v5 = nplog_obj(v2, v3, v4);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Handling received file handles and auxiliary data",  buf,  2u);
  }

  id v7 = sub_1000572E4(*(void **)(a1 + 32));
  uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000656C0;
  block[3] = &unk_1000F9450;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(v8, block);
}

void sub_1000656C0(uint64_t a1)
{
  id v164 = objc_alloc_init(&OBJC_CLASS___NWParameters);
  [v164 avoidNetworkAgentWithDomain:@"NetworkExtension" type:@"VPN"];
  [v164 avoidNetworkAgentWithDomain:@"NetworkExtension" type:@"AppVPN"];
  uint64_t v2 = -[NWPathEvaluator initWithEndpoint:parameters:]( objc_alloc(&OBJC_CLASS___NWPathEvaluator),  "initWithEndpoint:parameters:",  0LL,  v164);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    objc_storeStrong((id *)(v3 + 104), v2);
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = *(void **)(v4 + 104);
  }
  else {
    uint64_t v5 = 0LL;
  }
  [v5 addObserver:v4 forKeyPath:@"path" options:5 context:*(void *)(a1 + 32)];
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6) {
    goto LABEL_102;
  }
  *(_BYTE *)(v6 + 11) = 1;
  id v7 = *(id **)(a1 + 32);
  if (!v7) {
    goto LABEL_102;
  }
  uint64_t v8 = objc_alloc_init(&OBJC_CLASS___CWFInterface);
  id v9 = v7[15];
  v7[15] = v8;

  [v7[15] activate];
  objc_initWeak(&location, v7);
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  __int128 v171 = sub_100074570;
  __int128 v172 = &unk_1000FA488;
  objc_copyWeak(v173, &location);
  id v10 = v7[15];
  [v10 setEventHandler:&buf];

  id v11 = v7[15];
  id v168 = 0LL;
  [v11 startMonitoringEventType:2 error:&v168];
  id v12 = v168;

  if (v12)
  {
    uint64_t v16 = nplog_obj(v13, v14, v15);
    pid_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v12;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Failed to register for SSID changes: %@",  v174,  0xCu);
    }
  }

  id v18 = v7[15];
  id v167 = 0LL;
  [v18 startMonitoringEventType:19 error:&v167];
  id v19 = v167;

  if (v19)
  {
    uint64_t v23 = nplog_obj(v20, v21, v22);
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v19;
      _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "Failed to register for IPv4 changes: %@",  v174,  0xCu);
    }
  }

  id v25 = v7[15];
  id v166 = 0LL;
  [v25 startMonitoringEventType:20 error:&v166];
  id v26 = v166;

  if (v26)
  {
    uint64_t v30 = nplog_obj(v27, v28, v29);
    int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v26;
      _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Failed to register for IPv6 changes: %@",  v174,  0xCu);
    }
  }

  id v32 = v7[15];
  id v165 = 0LL;
  [v32 startMonitoringEventType:30 error:&v165];
  id v33 = v165;

  if (v33)
  {
    uint64_t v37 = nplog_obj(v34, v35, v36);
    uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v33;
      _os_log_error_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "Failed to register for known network profile changes: %@",  v174,  0xCu);
    }
  }

  sub_10006A1A8((uint64_t)v7);

  objc_destroyWeak(v173);
  objc_destroyWeak(&location);
  uint64_t v39 = *(void *)(a1 + 32);
  if (!v39) {
    goto LABEL_102;
  }
  if (*(void *)(v39 + 128)) {
    goto LABEL_25;
  }
  SCDynamicStoreRef v135 = SCDynamicStoreCreate( kCFAllocatorDefault,  @"networkserviceproxy event agent",  (SCDynamicStoreCallBack)sub_100074C98,  0LL);
  *(void *)(v39 + 12_Block_object_dispose((const void *)(v71 - 176), 8) = v135;
  if (v135)
  {
    __int128 v138 = v135;
    uint64_t v139 = NPGetInternalQueue(v135);
    __int128 v140 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v139);
    LODWORD(v13_Block_object_dispose((const void *)(v71 - 176), 8) = SCDynamicStoreSetDispatchQueue(v138, v140);

    if ((_DWORD)v138)
    {
      CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( kCFAllocatorDefault,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetPvD);
      __int128 v145 = (void *)objc_claimAutoreleasedReturnValue(NetworkServiceEntity);
      CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( kCFAllocatorDefault,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  0LL);
      __int128 v147 = (void *)objc_claimAutoreleasedReturnValue(NetworkInterfaceEntity);
      __int128 v148 = *(const __SCDynamicStore **)(v39 + 128);
      *(void *)&__int128 buf = v147;
      *((void *)&buf + 1) = v145;
      uint64_t v149 = SCDynamicStoreSetNotificationKeys( v148,  0LL,  (CFArrayRef)+[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &buf,  2LL));
      if (!(_DWORD)v149)
      {
        uint64_t v152 = nplog_obj(v149, v150, v151);
        __int128 v153 = (os_log_s *)objc_claimAutoreleasedReturnValue(v152);
        if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
        {
          CFErrorRef Error = SCCopyLastError();
          *(_DWORD *)__int128 v174 = 138412290;
          *(void *)&v174[4] = Error;
          _os_log_error_impl( (void *)&_mh_execute_header,  v153,  OS_LOG_TYPE_ERROR,  "Failed to update the dynamic store notification keys: %@",  v174,  0xCu);
        }
      }

LABEL_25:
      sub_10006A2F8(v39);
      goto LABEL_26;
    }

    uint64_t v160 = nplog_obj(v141, v142, v143);
    __int128 v159 = (os_log_s *)objc_claimAutoreleasedReturnValue(v160);
    if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v162 = SCCopyLastError();
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v162;
      _os_log_error_impl( (void *)&_mh_execute_header,  v159,  OS_LOG_TYPE_ERROR,  "Failed to set dynamic store dispatch queue: %@",  v174,  0xCu);
    }
  }

  else
  {
    uint64_t v158 = nplog_obj(0LL, v136, v137);
    __int128 v159 = (os_log_s *)objc_claimAutoreleasedReturnValue(v158);
    if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v161 = SCCopyLastError();
      *(_DWORD *)__int128 v174 = 138412290;
      *(void *)&v174[4] = v161;
      _os_log_error_impl( (void *)&_mh_execute_header,  v159,  OS_LOG_TYPE_ERROR,  "Failed to create dynamic store: %@",  v174,  0xCu);
    }
  }

LABEL_26:
  uint64_t v43 = *(void *)(a1 + 32);
  if (v43)
  {
    uint64_t v44 = nplog_obj(v40, v41, v42);
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEBUG,  "Restoring server state",  (uint8_t *)&buf,  2u);
    }

    id v46 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
    id v47 = [v46 copyAuxiliaryDataForKey:@"NSPServerAuxilaryData"];

    uint64_t v48 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v47, v48) & 1) != 0) {
      goto LABEL_91;
    }
    uint64_t v49 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v50 = objc_opt_class(&OBJC_CLASS___NSString);
    uint64_t v51 = objc_opt_class(&OBJC_CLASS___NSDate);
    pid_t v52 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v49,  v50,  v51,  objc_opt_class(&OBJC_CLASS___NSNumber),  0LL);
    __int128 v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
    *(void *)__int128 v174 = 0LL;
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v53,  v47,  v174));
    id v55 = *(id *)v174;

    if (!v54 || v55)
    {
      uint64_t v154 = nplog_obj(v56, v57, v58);
      id v134 = (os_log_s *)objc_claimAutoreleasedReturnValue(v154);
      if (os_log_type_enabled(v134, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v55;
        _os_log_impl( (void *)&_mh_execute_header,  v134,  OS_LOG_TYPE_INFO,  "unarchive failed with error %@",  (uint8_t *)&buf,  0xCu);
      }
    }

    else
    {
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerConfigOutage"]);
      if (v59)
      {
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerConfigOutage"]);
        uint64_t v61 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char isKindOfClass = objc_opt_isKindOfClass(v60, v61);

        if ((isKindOfClass & 1) != 0)
        {
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerConfigOutage"]);
          *(_BYTE *)(v43 + 13) = [v63 BOOLValue];
        }
      }

      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerTokenOutage"]);
      if (v64)
      {
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerTokenOutage"]);
        uint64_t v66 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v67 = objc_opt_isKindOfClass(v65, v66);

        if ((v67 & 1) != 0)
        {
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerTokenOutage"]);
          *(_BYTE *)(v43 + 14) = [v68 BOOLValue];
        }
      }

      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutage"]);
      if (v69)
      {
        uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutage"]);
        uint64_t v71 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v72 = objc_opt_isKindOfClass(v70, v71);

        if ((v72 & 1) != 0)
        {
          uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutage"]);
          *(_BYTE *)(v43 + 15) = [v73 BOOLValue];
        }
      }

      uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"]);
      if (v74)
      {
        uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"]);
        uint64_t v76 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v77 = objc_opt_isKindOfClass(v75, v76);

        if ((v77 & 1) != 0)
        {
          uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"]);
          *(_BYTE *)(v43 + 16) = [v78 BOOLValue];
        }
      }

      id v79 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"]);
      if (v79)
      {
        uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"]);
        uint64_t v81 = objc_opt_class(&OBJC_CLASS___NSDate);
        char v82 = objc_opt_isKindOfClass(v80, v81);

        if ((v82 & 1) != 0)
        {
          id v83 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"]);
          [v83 timeIntervalSinceNow];
          if (v84 > 10.0) {
            objc_storeStrong((id *)(v43 + 200), v83);
          }
        }
      }

      double v85 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"]);
      if (v85)
      {
        id v86 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"]);
        uint64_t v87 = objc_opt_class(&OBJC_CLASS___NSDate);
        char v88 = objc_opt_isKindOfClass(v86, v87);

        if ((v88 & 1) != 0)
        {
          uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"]);
          [v89 timeIntervalSinceNow];
          if (v90 > 10.0) {
            objc_storeStrong((id *)(v43 + 208), v89);
          }
        }
      }

      uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"]);
      if (v91)
      {
        uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"]);
        uint64_t v93 = objc_opt_class(&OBJC_CLASS___NSDate);
        char v94 = objc_opt_isKindOfClass(v92, v93);

        if ((v94 & 1) != 0)
        {
          uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"]);
          [v95 timeIntervalSinceNow];
          if (v96 > 10.0) {
            objc_storeStrong((id *)(v43 + 232), v95);
          }
        }
      }

      id v97 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerCaptiveOutage"]);
      if (v97)
      {
        id v98 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerCaptiveOutage"]);
        uint64_t v99 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v100 = objc_opt_isKindOfClass(v98, v99);

        if ((v100 & 1) != 0)
        {
          id v101 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerCaptiveOutage"]);
          *(_BYTE *)(v43 + 19) = [v101 BOOLValue];
        }
      }

      uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue( [v54 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"]);
      if (v102)
      {
        __int128 v103 = (void *)objc_claimAutoreleasedReturnValue( [v54 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"]);
        uint64_t v104 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v105 = objc_opt_isKindOfClass(v103, v104);

        if ((v105 & 1) != 0)
        {
          id v106 = (void *)objc_claimAutoreleasedReturnValue( [v54 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"]);
          *(_BYTE *)(v43 + 20) = [v106 BOOLValue];
        }
      }

      char v107 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"MPTCPProxyStatus"]);
      if (v107)
      {
        uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"MPTCPProxyStatus"]);
        uint64_t v109 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v110 = objc_opt_isKindOfClass(v108, v109);

        if ((v110 & 1) != 0)
        {
          __int128 v111 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"MPTCPProxyStatus"]);
          *(_BYTE *)(v43 + 23) = [v111 BOOLValue];
        }
      }

      __int128 v112 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerFraudAlert"]);
      if (v112)
      {
        uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerFraudAlert"]);
        uint64_t v114 = objc_opt_class(&OBJC_CLASS___NSNumber);
        char v115 = objc_opt_isKindOfClass(v113, v114);

        if ((v115 & 1) != 0)
        {
          __int16 v116 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerFraudAlert"]);
          *(_BYTE *)(v43 + 22) = [v116 BOOLValue];
        }
      }

      id v117 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastGeohash"]);
      if (v117)
      {
        id v118 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastGeohash"]);
        uint64_t v119 = objc_opt_class(&OBJC_CLASS___NSString);
        char v120 = objc_opt_isKindOfClass(v118, v119);

        if ((v120 & 1) != 0)
        {
          uint64_t v121 = objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastGeohash"]);
          id v122 = *(void **)(v43 + 344);
          *(void *)(v43 + 344) = v121;
        }
      }

      uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"]);
      if (v123)
      {
        __int16 v124 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"]);
        uint64_t v125 = objc_opt_class(&OBJC_CLASS___NSString);
        char v126 = objc_opt_isKindOfClass(v124, v125);

        if ((v126 & 1) != 0)
        {
          uint64_t v127 = objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"]);
          __int128 v128 = *(void **)(v43 + 352);
          *(void *)(v43 + 352) = v127;
        }
      }

      uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"]);
      if (!v129) {
        goto LABEL_90;
      }
      __int128 v130 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"]);
      uint64_t v131 = objc_opt_class(&OBJC_CLASS___NSString);
      char v132 = objc_opt_isKindOfClass(v130, v131);

      if ((v132 & 1) == 0) {
        goto LABEL_90;
      }
      uint64_t v133 = objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"]);
      id v134 = *(os_log_s **)(v43 + 360);
      *(void *)(v43 + 360) = v133;
    }

LABEL_90:
LABEL_91:

    uint64_t v155 = *(void *)(a1 + 32);
    goto LABEL_92;
  }

LABEL_102:
  uint64_t v155 = 0LL;
LABEL_92:
  sub_1000665D4(v155);
  sub_100066738(*(void *)(a1 + 32));
  uint64_t v156 = *(void *)(a1 + 32);
  if (v156) {
    __int128 v157 = *(void **)(v156 + 56);
  }
  else {
    __int128 v157 = 0LL;
  }
  [v157 setup];
  sub_1000649CC(*(void *)(a1 + 32));
}

    (*((void (**)(id, void, void, void, void, void, void))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL);
    goto LABEL_85;
  }

  if (!v130)
  {
    uint64_t v24 = 0LL;
    id v25 = self;
LABEL_10:
    if (v25) {
      v25->_totalRequestedTokenCount += a9;
    }
    uint64_t v28 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenInfo);
    uint64_t v158 = 0LL;
    SCDynamicStoreRef v135 = [[RSABSSATokenBlinder alloc] initWithPublicKey:v137 error:&v158];
    uint64_t v29 = (char *)v158;
    __int16 v124 = v29;
    if (v29)
    {
      id v32 = nplog_obj(v29, v30, v31);
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        __int128 v163 = v124;
        id v164 = 2112;
        id v165 = v132;
        _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "RSABSSATokenBlinder initWithPublicKey failed with error %@ for %@",  buf,  0x16u);
      }

void sub_10006659C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_1000665D4(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 104);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 path]);
    if ([v3 hasKernelExtensionFilter])
    {
      unsigned int v4 = 1;
    }

    else
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 104) path]);
      unsigned int v4 = [v5 hasCustomPFRules];
    }

    if (v4 != (*(_BYTE *)(a1 + 12) != 0))
    {
      *(_BYTE *)(a1 + 12) = v4;
      if (*(_BYTE *)(a1 + 9))
      {
        uint64_t v9 = nplog_obj(v6, v7, v8);
        id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if ((v4 & 1) != 0)
        {
          if (v11)
          {
            *(_WORD *)uint64_t v13 = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "system is incompatible", v13, 2u);
          }

          [*(id *)(a1 + 72) reportSystemIncompatibility];
          [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
        }

        else
        {
          if (v11)
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "system is compatible", buf, 2u);
          }

          id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy]);
          [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:v12 resolverInfoChanged:1];
        }
      }
    }
  }

void sub_100066738(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100057300;
    v5[4] = sub_100057310;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.resetUEADates");
    uint64_t v2 = NPGetInternalQueue(v6);
    uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_1000673F8;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_1000667FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100066818(uint64_t a1, void *a2)
{
  id v3 = a2;
  string = xpc_dictionary_get_string(v3, _xpc_event_key_name);
  uint64_t v5 = strcmp(string, "com.apple.networkextension.app-paths-changed");
  if ((_DWORD)v5)
  {
    uint64_t v8 = strcmp(string, "com.apple.networkserviceproxy.reset");
    if (!(_DWORD)v8)
    {
      uint64_t v11 = nplog_obj(v8, v9, v10);
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315138;
        pid_t v17 = "com.apple.networkserviceproxy.reset";
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received a %s notification, resetting",  (uint8_t *)&v16,  0xCu);
      }

      sub_10006697C(*(void *)(a1 + 32));
      exit(0);
    }
  }

  else
  {
    uint64_t v13 = nplog_obj(v5, v6, v7);
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "UUID cache changed", (uint8_t *)&v16, 2u);
    }

    uint64_t v15 = *(void *)(a1 + 32);
    if (v15 && *(_BYTE *)(v15 + 9))
    {
      [*(id *)(v15 + 40) setup];
      sub_10006762C(v15);
    }
  }
}

void sub_10006697C(uint64_t a1)
{
  if (a1)
  {
    [*(id *)(a1 + 56) resetConfigurationManager];
    [*(id *)(a1 + 40) setup];
    sub_10006762C(a1);
  }

void sub_100066A30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 138412290;
    uint64_t v7 = a1;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "%@ forcePathChange called",  (uint8_t *)&v6,  0xCu);
  }
}

void sub_100066C44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100066C5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id v3 = *(void **)(v2 + 104);
  }
  else {
    id v3 = 0LL;
  }
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 path]);
  if ([v4 status] == (id)1)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 interface]);
    uint64_t v8 = v5;
    if (v5)
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v5 interfaceName]);
      uint64_t v9 = v5;
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10)
    {
      int v16 = 0LL;
      goto LABEL_15;
    }

    if (*(_BYTE *)(v10 + 8))
    {
      uint64_t v11 = nplog_obj(v5, v6, v7);
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v56) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Retry subscription check",  (uint8_t *)&v56,  2u);
      }

      sub_1000697AC(v10, v13, v14);
      uint64_t v15 = (void *)os_transaction_create("com.apple.networkserviceproxy.subscriptionCheckOnPathChange");
      sub_100068D18((id *)v10);
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v8 = 0LL;
  }

  int v16 = *(void **)(a1 + 32);
  if (v16) {
    int v16 = (void *)v16[11];
  }
LABEL_15:
  pid_t v17 = v16;
  uint64_t v20 = v17;
  if (!v8 || v17)
  {
    uint64_t v29 = *(void *)(a1 + 32);
    if (!v29 || (uint64_t v30 = *(void **)(v29 + 88)) == 0LL || !v9)
    {

      goto LABEL_30;
    }

    id v31 = v30;
    id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 interfaceName]);
    unsigned __int8 v33 = [v32 isEqualToString:v9];

    if ((v33 & 1) != 0) {
      goto LABEL_30;
    }
  }

  uint64_t v21 = nplog_obj(v17, v18, v19);
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    uint64_t v23 = *(void **)(a1 + 32);
    if (v23) {
      uint64_t v23 = (void *)v23[11];
    }
    uint64_t v24 = v23;
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 interfaceName]);
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v8 interfaceName]);
    int v56 = 138412546;
    uint64_t v57 = v25;
    __int16 v58 = 2112;
    uint64_t v59 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "Primary interface changed from %@ to %@",  (uint8_t *)&v56,  0x16u);
  }

  uint64_t v27 = *(void *)(a1 + 32);
  if (!v27 || (objc_storeStrong((id *)(v27 + 88), v8), (uint64_t v28 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v34 = 0LL;
    goto LABEL_44;
  }

  *(_DWORD *)(v28 + 36) = 0;
LABEL_30:
  uint64_t v34 = *(void *)(a1 + 32);
  if (v34)
  {
    if (!*(void *)(v34 + 88)) {
      goto LABEL_62;
    }
    id Property = objc_getProperty((id)v34, v18, 264LL, 1);
    uint64_t v36 = *(void *)(a1 + 32);
    if (v36) {
      uint64_t v37 = *(void **)(v36 + 88);
    }
    else {
      uint64_t v37 = 0LL;
    }
    uint64_t v38 = Property;
    id v39 = [v37 interfaceIndex];
    if (v38)
    {
      id v40 = v39;
      uint64_t v41 = v38[3];
      if (v41) {
        NEFlowDirectorSetDelegateInterface(v41, v40);
      }
    }

    uint64_t v34 = *(void *)(a1 + 32);
    if (v34)
    {
LABEL_62:
      if (!*(void *)(v34 + 56)
        || ([*(id *)(v34 + 56) handlePathChange:v4], (uint64_t v34 = *(void *)(a1 + 32)) != 0))
      {
        if (!*(void *)(v34 + 64)
          || ([*(id *)(v34 + 64) handlePathChange:v4], (uint64_t v34 = *(void *)(a1 + 32)) != 0))
        {
          if (*(void *)(v34 + 192))
          {
            sub_100050024(*(void *)(v34 + 192), v4);
            uint64_t v34 = *(void *)(a1 + 32);
          }
        }
      }
    }
  }

uint64_t sub_1000670A8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = *(id *)(result + 104);
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 path]);
    if ([v3 status] == (id)1)
    {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 104) path]);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 interface]);
      id v6 = [v5 type];

      if (v6 != (id)1) {
        return 1LL;
      }
    }

    else
    {
    }

    return 0LL;
  }

  return result;
}

void sub_10006714C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if ((_DWORD)a2)
    {
      *(_BYTE *)(a1 + 19) = 1;
      uint64_t v4 = nplog_obj(a1, a2, a3);
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "reporting captive network outage", v7, 2u);
      }

      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_1000679B4(a1);
      *(_BYTE *)(a1 + 20) = 0;
    }

    else
    {
      *(_BYTE *)(a1 + 19) = 0;
      id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy]);
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:v6 resolverInfoChanged:0];
      sub_1000679B4(a1);
    }

    sub_100073418(a1);
  }

void sub_100067224(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 88);
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 interfaceName]);

    if (*(int *)(a1 + 32) >= 1 && v3 != 0LL)
    {
      *(_OWORD *)__str = 0u;
      __int128 v20 = 0u;
      snprintf(__str, 0x10uLL, "%s", (const char *)[v3 UTF8String]);
      LODWORD(v20) = -1;
      uint64_t v5 = ioctl(*(_DWORD *)(a1 + 32), 0xC020698AuLL, __str);
      if ((v5 & 0x80000000) != 0)
      {
        uint64_t v11 = nplog_obj(v5, v6, v7);
        id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          uint64_t v13 = __error();
          uint64_t v14 = strerror(*v13);
          *(_DWORD *)__int128 buf = 136315138;
          int v16 = v14;
          _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "failed to get link quality metrics %s",  buf,  0xCu);
        }
      }

      else if ((_DWORD)v20 != *(_DWORD *)(a1 + 36))
      {
        uint64_t v8 = nplog_obj(v5, v6, v7);
        uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NPUtilities stringFromLinkQualityValue:]( &OBJC_CLASS___NPUtilities,  "stringFromLinkQualityValue:",  v20));
          *(_DWORD *)__int128 buf = 138412546;
          int v16 = (char *)v3;
          __int16 v17 = 2112;
          id v18 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Interface %@, link quality changed to %@",  buf,  0x16u);
        }

        *(_DWORD *)(a1 + 36) = v20;
        objc_msgSend(*(id *)(a1 + 64), "handleLinkQualityChange:");
      }
    }
  }

void sub_1000673F8(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id v3 = *(void **)(v2 + 40);
  }
  else {
    id v3 = 0LL;
  }
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 resurrectionDate]);

  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      uint64_t v6 = *(void **)(v5 + 40);
    }
    else {
      uint64_t v6 = 0LL;
    }
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 resurrectionDate]);
    [v7 timeIntervalSinceReferenceDate];
    int64_t v9 = (uint64_t)v8;

    xpc_dictionary_set_int64(xdict, "ResurrectionDate", v9);
  }

  uint64_t v10 = *(void *)(a1 + 32);
  if (v10) {
    uint64_t v11 = *(void **)(v10 + 64);
  }
  else {
    uint64_t v11 = 0LL;
  }
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 tokenIssuanceRestrictedUntilDate]);

  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13) {
      uint64_t v14 = *(void **)(v13 + 64);
    }
    else {
      uint64_t v14 = 0LL;
    }
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 tokenIssuanceRestrictedUntilDate]);
    [v15 timeIntervalSinceReferenceDate];
    int64_t v17 = (uint64_t)v16;
  }

  else
  {
    int64_t v17 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "TokenIssuanceRestrictedUntilDate", v17);
  uint64_t v18 = *(void *)(a1 + 32);
  if (v18 && (uint64_t v19 = *(void **)(v18 + 160)) != 0LL)
  {
    [v19 timeIntervalSinceReferenceDate];
    int64_t v21 = (uint64_t)v20;
  }

  else
  {
    int64_t v21 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "SubscriptionCheckDate", v21);
  uint64_t v22 = *(void *)(a1 + 32);
  if (v22 && *(_BYTE *)(v22 + 8)) {
    int64_t v23 = 1LL;
  }
  else {
    int64_t v23 = -1LL;
  }
  xpc_dictionary_set_int64(xdict, "SubscriptionCheckOnNetworkChange", v23);
  uint64_t v24 = *(void *)(a1 + 32);
  if (v24 && (id v25 = *(void **)(v24 + 200)) != 0LL)
  {
    [v25 timeIntervalSinceReferenceDate];
    int64_t v27 = (uint64_t)v26;
  }

  else
  {
    int64_t v27 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "ProxyRestoreDate", v27);
  uint64_t v28 = *(void *)(a1 + 32);
  if (v28 && (uint64_t v29 = *(void **)(v28 + 208)) != 0LL)
  {
    [v29 timeIntervalSinceReferenceDate];
    int64_t v31 = (uint64_t)v30;
  }

  else
  {
    int64_t v31 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "ODoHRestoreDate", v31);
  uint64_t v32 = *(void *)(a1 + 32);
  if (v32 && (unsigned __int8 v33 = *(void **)(v32 + 232)) != 0LL)
  {
    [v33 timeIntervalSinceReferenceDate];
    int64_t v35 = (uint64_t)v34;
  }

  else
  {
    int64_t v35 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "odohAuthRestoreDate", v35);
  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", xdict);
  uint64_t v36 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v37 = *(void **)(v36 + 40);
  *(void *)(v36 + 40) = 0LL;
}

void sub_10006762C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) enabled]);
  if ([v2 BOOLValue])
  {
    int v3 = *(unsigned __int8 *)(a1 + 9);

    if (!v3)
    {
      uint64_t v7 = nplog_obj(v4, v5, v6);
      double v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Starting the provider", buf, 2u);
      }

      *(_BYTE *)(a1 + 9) = 1;
      id Property = objc_getProperty((id)a1, v9, 264LL, 1);
      sub_10009D77C((uint64_t)Property, v11, v12);
      return;
    }
  }

  else
  {
  }

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) enabled]);
  if ([v13 BOOLValue])
  {

LABEL_14:
    sub_1000649CC(a1);
    return;
  }

  int v14 = *(unsigned __int8 *)(a1 + 9);

  if (!v14) {
    goto LABEL_14;
  }
  uint64_t v18 = nplog_obj(v15, v16, v17);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v22 = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Stopping the provider", v22, 2u);
  }

  *(_BYTE *)(a1 + 9) = 0;
  id v21 = objc_getProperty((id)a1, v20, 264LL, 1);
  sub_10009D6E8((uint64_t)v21, 1);
  sub_1000649CC(a1);
}

void sub_100067790(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100057300;
    v5[4] = sub_100057310;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.applyConfiguration");
    uint64_t v2 = NPGetInternalQueue(v6);
    int v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_10006786C;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100067854( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006786C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    [*(id *)(v2 + 40) setup];
    sub_10006762C(v2);
  }

  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

uint64_t sub_1000678B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount])
    {
      uint64_t v5 = 0LL;
      while (1)
      {
        unsigned int v6 = [v4 conditionsAtIndex:v5] - 2;
        if (v6 < 0x14 && ((0xC0041u >> v6) & 1) != 0) {
          break;
        }
      }

      a1 = 1LL;
    }

    else
    {
LABEL_7:
      a1 = 0LL;
    }
  }

  return a1;
}

void sub_1000679B4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v5 = nplog_obj(v2, v3, v4);
    unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Saving server state", buf, 2u);
    }

    BOOL v7 = *(_BYTE *)(a1 + 13) == 0;
    if (*(_BYTE *)(a1 + 13))
    {
      double v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v8,  @"NSPServerConfigOutage");
    }

    if (*(_BYTE *)(a1 + 14))
    {
      SEL v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v9,  @"NSPServerTokenOutage");

      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 15))
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v10,  @"NSPServerProxyOutage");

      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 16))
    {
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v11,  @"NSPServerProxyNetworkOutage");

      BOOL v7 = 0;
    }

    uint64_t v12 = *(void *)(a1 + 200);
    if (v12)
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v12,  @"NSPServerProxyOutageRestoreDate");
      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 17))
    {
      uint64_t v13 = *(void *)(a1 + 208);
      if (v13)
      {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v13,  @"NSPServerODoHOutageRestoreDate");
        BOOL v7 = 0;
      }
    }

    if (*(_BYTE *)(a1 + 18))
    {
      uint64_t v14 = *(void *)(a1 + 232);
      if (v14)
      {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v14,  @"NSPServerODoHAuthOutageRestoreDate");
        BOOL v7 = 0;
      }
    }

    if (*(_BYTE *)(a1 + 19))
    {
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v15,  @"NSPServerCaptiveOutage");

      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 20))
    {
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v16,  @"NSPServerCaptiveOutageWaitingForUserActivity");

      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 23))
    {
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v17,  @"MPTCPProxyStatus");

      BOOL v7 = 0;
    }

    if (*(_BYTE *)(a1 + 22))
    {
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v18,  @"NSPServerFraudAlert");

      BOOL v7 = 0;
    }

    uint64_t v19 = *(void *)(a1 + 344);
    if (v19)
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v19,  @"NSPServerLastGeohash");
      BOOL v7 = 0;
    }

    uint64_t v20 = *(void *)(a1 + 352);
    if (v20)
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v20,  @"NSPServerLastCountryPlusTimezone");
      uint64_t v21 = *(void *)(a1 + 360);
      if (!v21) {
        goto LABEL_35;
      }
    }

    else
    {
      uint64_t v21 = *(void *)(a1 + 360);
      if (!v21)
      {
        if (v7)
        {
          double v30 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          [v30 setAuxiliaryData:@"NIL" forKey:@"NSPServerAuxilaryData"];

          id v23 = (id)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          [v23 commit];
LABEL_43:

          return;
        }

void sub_100068C74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id a17, uint64_t a18, id location)
{
}

void sub_100068D08(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 192), a2);
  }
}

void sub_100068D18(id *a1)
{
  if (a1)
  {
    id v2 = a1[5];
    uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 cloudSubscriptionCheckEnabled]);
    if (v3)
    {
      uint64_t v4 = (void *)v3;
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a1[5] cloudSubscriptionCheckEnabled]);
      unsigned int v6 = [v5 BOOLValue];

      if (!v6) {
        return;
      }
    }

    else
    {
    }

    objc_initWeak(&location, a1);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_100072378;
    v7[3] = &unk_1000FA378;
    objc_copyWeak(&v8, &location);
    +[CSFFeatureManager requestFeatureWithId:completion:]( &OBJC_CLASS___CSFFeatureManager,  "requestFeatureWithId:completion:",  @"networking.privacy.subscriber",  v7);
    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }

void sub_100068E14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_100068E30(uint64_t *val)
{
  if (val && !val[17])
  {
    objc_initWeak(&location, val);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_100072984;
    v10[3] = &unk_1000F97C0;
    objc_copyWeak(&v11, &location);
    uint64_t v2 = objc_claimAutoreleasedReturnValue( +[CSFFeatureManager registerForFeatureChangeNotificationsUsingBlock:]( &OBJC_CLASS___CSFFeatureManager,  "registerForFeatureChangeNotificationsUsingBlock:",  v10));
    uint64_t v4 = (void *)val[17];
    uint64_t v3 = val + 17;
    *uint64_t v3 = v2;

    if (!*v3)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      SEL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v14 = "-[NSPServer registerForPrivacyProxySubscriptionChanges]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "%s called with null self.featureChangeToken",  buf,  0xCu);
      }
    }

    objc_destroyWeak(&v11);
    objc_destroyWeak(&location);
  }

void sub_100068F7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_100068FA4(id *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      LOWORD(v23) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "checking trial config version",  (uint8_t *)&v23,  2u);
    }

    id v6 = a1[27];
    if (v6
      || (uint64_t v7 = objc_claimAutoreleasedReturnValue(+[TRIClient clientWithIdentifier:](&OBJC_CLASS___TRIClient, "clientWithIdentifier:", 265LL)),
          id v8 = a1[27],
          a1[27] = (id)v7,
          v8,
          (id v6 = a1[27]) != 0LL))
    {
      [v6 refresh];
      id v11 = a1[27];
      uint64_t v12 = (char *)objc_claimAutoreleasedReturnValue( [v11 levelForFactor:@"configVersionPull" withNamespaceName:@"NETWORK_SERVICE_PROXY_CONFIG_UPDATE"]);

      uint64_t v16 = nplog_obj(v13, v14, v15);
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        int v23 = 138412290;
        uint64_t v24 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "Trilevel for config pull version %@",  (uint8_t *)&v23,  0xCu);
      }

      if (v12 && [v12 longValue])
      {
        id v18 = [v12 longValue];
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([a1[5] trialConfigVersion]);
        id v20 = [v19 longValue];

        if (v18 != v20)
        {
          id v21 = a1[7];
          objc_msgSend(v21, "setConfigurationTrialVersion:", objc_msgSend(v12, "longValue"));
        }
      }
    }

    else
    {
      uint64_t v22 = nplog_obj(0LL, v9, v10);
      uint64_t v12 = (char *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT))
      {
        int v23 = 136315138;
        uint64_t v24 = "-[NSPServer checkTrialConfigVersion]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v12,  OS_LOG_TYPE_FAULT,  "%s called with null self.trialClient",  (uint8_t *)&v23,  0xCu);
      }
    }
  }

void sub_1000691BC(id *a1)
{
  if (a1)
  {
    if (sub_100070208((uint64_t)a1))
    {
      uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1[5] resetTomorrowDate]);
      [v2 timeIntervalSinceNow];
      int64_t v4 = (uint64_t)v3;

      xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REPEATING, 0);
      xpc_dictionary_set_int64(v5, XPC_ACTIVITY_DELAY, v4);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REQUIRE_INEXPENSIVE_NETWORK_CONNECTIVITY, 0);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY, 0);
      xpc_dictionary_set_int64(v5, XPC_ACTIVITY_GRACE_PERIOD, 10800LL);
      xpc_dictionary_set_string(v5, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
      objc_initWeak(location, a1);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_1000704E8;
      handler[3] = &unk_1000FA098;
      objc_copyWeak(&v27, location);
      xpc_activity_register("com.apple.networkserviceproxy.reset-tomorrow", v5, handler);
      objc_destroyWeak(&v27);
      objc_destroyWeak(location);

      return;
    }

    xpc_activity_unregister("com.apple.networkserviceproxy.reset-tomorrow");
    if (sub_100070358((uint64_t)a1))
    {
      id v6 = [a1[9] hasPausedApps];
      int v9 = (int)v6;
      if ((_DWORD)v6)
      {
        uint64_t v10 = nplog_obj(v6, v7, v8);
        id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(location[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Resetting all paused apps, date is no longer tomorrow",  (uint8_t *)location,  2u);
        }

        [a1[9] clearAllPausedApps];
      }

      id v12 = a1[5];
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 userTier]);
      if ([v13 unsignedIntegerValue] == (id)1)
      {
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([a1[5] willResetSubscriberTierTomorrow]);
        unsigned int v15 = [v14 BOOLValue];

        if (v15)
        {
          uint64_t v19 = nplog_obj(v16, v17, v18);
          id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(location[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Resetting user tier to subscriber, date is no longer tomorrow",  (uint8_t *)location,  2u);
          }

          id v21 = [a1[7] setUserTier:2 resetDate:0 clearResetDate:1 changeSource:2];
          if ((v21 & 1) == 0)
          {
            uint64_t v24 = nplog_obj(v21, v22, v23);
            uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              LOWORD(location[0]) = 0;
              _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "Failed to set user tier to subscriber",  (uint8_t *)location,  2u);
            }
          }

          goto LABEL_19;
        }
      }

      else
      {
      }

      [a1[7] clearResetDate];
LABEL_19:
      if (v9) {
        sub_10007081C((uint64_t)a1);
      }
    }
  }

void sub_1000694C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_100069734(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 17) = 0;
    uint64_t v2 = *(void **)(a1 + 208);
    *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;

    double v3 = *(dispatch_source_s **)(a1 + 176);
    if (v3)
    {
      dispatch_source_cancel(v3);
      int64_t v4 = *(void **)(a1 + 176);
      *(void *)(a1 + 176) = 0LL;
    }

    *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = 0;
    xpc_object_t v5 = *(void **)(a1 + 232);
    *(void *)(a1 + 232) = 0LL;

    id v6 = *(dispatch_source_s **)(a1 + 184);
    if (v6)
    {
      dispatch_source_cancel(v6);
      uint64_t v7 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = 0LL;
    }
  }

void sub_1000697AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    xpc_object_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "reset subscription check timer", v9, 2u);
    }

    id v6 = *(dispatch_source_s **)(a1 + 144);
    if (v6)
    {
      dispatch_source_cancel(v6);
      uint64_t v7 = *(void **)(a1 + 144);
      *(void *)(a1 + 144) = 0LL;
    }

    uint64_t v8 = *(void **)(a1 + 160);
    *(void *)(a1 + 152) = 0LL;
    *(void *)(a1 + 160) = 0LL;
    *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;

    sub_100066738(a1);
  }

void sub_100069848(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 136))
    {
      +[CSFFeatureManager unregisterForFeatureChangeNotificationsUsingObserver:]( &OBJC_CLASS___CSFFeatureManager,  "unregisterForFeatureChangeNotificationsUsingObserver:");
      uint64_t v2 = *(void **)(a1 + 136);
      *(void *)(a1 + 136) = 0LL;
    }
  }

void sub_100069890(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = NPGetInternalQueue(a1);
    double v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    xpc_set_event_stream_handler("com.apple.distnoted.matching", v3, &stru_1000FA3E8);

    uint64_t v7 = nplog_obj(v4, v5, v6);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      int v9 = 138412290;
      uint64_t v10 = a1;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "%@ un-registered for apps installation/uninstallation event",  (uint8_t *)&v9,  0xCu);
    }
  }

void sub_100069960(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(dispatch_source_s **)(a1 + 312);
    if (v2)
    {
      dispatch_source_cancel(v2);
      double v3 = *(void **)(a1 + 312);
      *(void *)(a1 + 312) = 0LL;
    }

    *(_DWORD *)(a1 + 36) = 0;
  }

void sub_10006999C(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v4 = nplog_obj(v1, v2, v3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "remove server userevent agent data", v8, 2u);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v6 setAuxiliaryData:@"NIL" forKey:@"NSPServerAuxilaryData"];

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  [v7 commit];
}

void sub_100069A48(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 224);
    if (v2)
    {
      id v3 = *(id *)(a1 + 216);
      [v3 removeUpdateHandlerForToken:v2];

      uint64_t v4 = *(void **)(a1 + 224);
      *(void *)(a1 + 224) = 0LL;
    }

    uint64_t v5 = *(void **)(a1 + 216);
    *(void *)(a1 + 216) = 0LL;
  }

void sub_10006A0F4(_BYTE *a1, const char *a2)
{
  if (objc_getProperty(a1, a2, 264LL, 1))
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
    [v5 removePoliciesForMPTCPConverterProxy:1];

    a1[23] = 0;
    sub_1000679B4((uint64_t)a1);
  }

  else
  {
    uint64_t v6 = nplog_obj(0LL, v3, v4);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "flow divert provider is unavailable",  v8,  2u);
    }
  }

void sub_10006A1A8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) currentKnownNetworkProfile]);
    uint64_t v5 = v2;
    if (v2)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v2 networkName]);
      if (!v6)
      {
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) currentScanResult]);
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v7 networkName]);
      }

      unsigned __int8 v8 = [v5 isPrivacyProxyEnabled];
      int v9 = *(void **)(a1 + 72);
      if ((v8 & 1) != 0)
      {
        [v9 reportActiveOnWiFiName:v6];
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
        id v11 = v10;
        uint64_t v12 = 0LL;
      }

      else
      {
        [v9 reportDisabledOnWiFiName:v6];
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
        id v11 = v10;
        uint64_t v12 = 1LL;
      }

      [v10 wifiDisabled:v12];
    }

    else
    {
      uint64_t v13 = nplog_obj(0LL, v3, v4);
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "No current Wi-Fi network, clearing state",  v16,  2u);
      }

      [*(id *)(a1 + 72) clearNetworkStatusForType:1];
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
      [v15 wifiDisabled:0];
    }
  }

void sub_10006A2F8(uint64_t a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = SCPreferencesCreateWithAuthorization( kCFAllocatorDefault,  @"networkserviceproxy",  0LL,  kSCPreferencesUseEntitlementAuthorization);
  if (v2)
  {
    uint64_t v5 = v2;
    uint64_t v6 = SCNetworkSetCopyCurrent(v2);
    if (v6)
    {
      int v9 = v6;
      CFArrayRef v10 = SCNetworkSetCopyServices(v6);
      if (v10)
      {
        uint64_t v13 = v10;
        uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        CFIndex Count = CFArrayGetCount(v13);
        if (Count >= 1)
        {
          CFIndex v16 = Count;
          for (CFIndex i = 0LL; i != v16; ++i)
          {
            ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v13, i);
            if (SCNetworkServiceGetEnabled(ValueAtIndex))
            {
              SCNetworkInterfaceRef Interface = SCNetworkServiceGetInterface(ValueAtIndex);
              if (Interface)
              {
                id v20 = Interface;
                if (SCNetworkInterfaceGetDisablePrivateRelay())
                {
                  CFStringRef BSDName = SCNetworkInterfaceGetBSDName(v20);
                  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(BSDName);
                  if (v22) {
                    -[NSMutableArray addObject:](v14, "addObject:", v22);
                  }
                }
              }
            }
          }
        }

        CFRelease(v9);
        CFRelease(v13);
        CFRelease(v5);
        goto LABEL_26;
      }

      uint64_t v27 = nplog_obj(0LL, v11, v12);
      uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        CFErrorRef Error = SCCopyLastError();
        *(_DWORD *)__int128 buf = 138412290;
        CFErrorRef v51 = Error;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Failed to copy services: %@",  buf,  0xCu);
      }

      CFRelease(v9);
    }

    else
    {
      uint64_t v25 = nplog_obj(0LL, v7, v8);
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        CFErrorRef v42 = SCCopyLastError();
        *(_DWORD *)__int128 buf = 138412290;
        CFErrorRef v51 = v42;
        _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "Failed to get current set: %@",  buf,  0xCu);
      }
    }

    CFRelease(v5);
  }

  else
  {
    uint64_t v23 = nplog_obj(0LL, v3, v4);
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v41 = SCCopyLastError();
      *(_DWORD *)__int128 buf = 138412290;
      CFErrorRef v51 = v41;
      _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "Failed to create SCPreferences: %@",  buf,  0xCu);
    }
  }

  uint64_t v14 = 0LL;
LABEL_26:
  if (-[NSMutableArray count](v14, "count"))
  {
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    uint64_t v44 = v14;
    uint64_t v29 = v14;
    id v30 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v45,  v49,  16LL);
    if (v30)
    {
      id v33 = v30;
      uint64_t v34 = *(void *)v46;
      do
      {
        int64_t v35 = 0LL;
        do
        {
          if (*(void *)v46 != v34) {
            objc_enumerationMutation(v29);
          }
          uint64_t v36 = *(__CFError **)(*((void *)&v45 + 1) + 8LL * (void)v35);
          uint64_t v37 = nplog_obj(v30, v31, v32);
          uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138543362;
            CFErrorRef v51 = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "Interface disabled: %{public}@",  buf,  0xCu);
          }

          id v39 = (void *)sub_100074C28(v36);
          [*(id *)(a1 + 72) reportDisabledOnInterfaceName:v36 displayName:v39 type:3];

          int64_t v35 = (char *)v35 + 1;
        }

        while (v33 != v35);
        id v30 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v45,  v49,  16LL);
        id v33 = v30;
      }

      while (v30);
    }

    uint64_t v14 = v44;
  }

  else
  {
    [*(id *)(a1 + 72) clearNetworkStatusForType:3];
  }

  id v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
  [v40 replaceDisabledInterfaces:v14];
}

void sub_10006AA24(uint64_t a1)
{
  if (!a1 || [*(id *)(a1 + 56) effectiveUserTier] == (id)1) {
    return;
  }
  uint64_t v4 = *(void **)(a1 + 120);
  if (!v4)
  {
    uint64_t v18 = nplog_obj(0LL, v2, v3);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    id v20 = "%@ no Wi-Fi interface";
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, v20, buf, 0xCu);
    goto LABEL_28;
  }

  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 currentKnownNetworkProfile]);

  if (!v5)
  {
    uint64_t v21 = nplog_obj(v6, v7, v8);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    id v20 = "%@ there is no current Wi-Fi network profile";
    goto LABEL_27;
  }

  int v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) currentKnownNetworkProfile]);
  CFArrayRef v10 = (void *)objc_claimAutoreleasedReturnValue([v9 networkName]);

  if (!v10)
  {
    uint64_t v22 = nplog_obj(v11, v12, v13);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    id v20 = "%@ no network name in the current Wi-Fi network profile";
    goto LABEL_27;
  }

  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) interfaceName]);
  unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) globalIPv4InterfaceName]);
  CFIndex v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) globalIPv4InterfaceName]);
  BOOL v17 = v14
     && (([v14 isEqual:v15] & 1) != 0
      || ([v14 isEqual:v16] & 1) != 0);

  uint64_t v26 = nplog_obj(v23, v24, v25);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
  BOOL v27 = os_log_type_enabled(v19, OS_LOG_TYPE_INFO);
  if (!v17)
  {
    if (v27)
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      id v20 = "%@ Wi-Fi interface is not primary";
      goto LABEL_27;
    }

void sub_10006AF28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

LABEL_95:
  BOOL v27 = 1;
LABEL_22:
  uint64_t v28 = nplog_obj(v21, v22, v23);
  uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "remove policies", buf, 2u);
  }

  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
  [v30 remove:0];

  if (self) {
    uint64_t v31 = self->_odohManager;
  }
  else {
    uint64_t v31 = 0LL;
  }
  sub_10004E25C((uint64_t)v31);
  if (v27) {
    uint64_t v32 = v24;
  }
  else {
    uint64_t v32 = v20;
  }
  if (v26 && (v32 & 1) == 0)
  {
    if (self) {
      privacyProxyAgentManager = self->_privacyProxyAgentManager;
    }
    else {
      privacyProxyAgentManager = 0LL;
    }
    -[NSPPrivacyProxyAgentManager sendRTCReportForServiceOutage:]( privacyProxyAgentManager,  "sendRTCReportForServiceOutage:",  v26);
  }

  if (self)
  {
LABEL_35:
    int64_t v35 = objc_getProperty(self, v34, 368LL, 1);
    uint64_t v36 = sub_100043D10((uint64_t)v35);
    if ((_DWORD)v36)
    {
      uint64_t v39 = objc_getProperty(self, v37, 368LL, 1);
      sub_100043A44((uint64_t)v39, -[NSPServer isSubscriberUnlimited](self, "isSubscriberUnlimited"));

      uint64_t v41 = objc_getProperty(self, v40, 264LL, 1);
LABEL_37:
      CFErrorRef v42 = (os_log_s *)v41;
      id v43 = -[NSPServer isSubscriberUnlimited](self, "isSubscriberUnlimited");
      if (v42)
      {
        uint64_t v44 = v43;
        __int128 v45 = *((void *)v42 + 3);
        if (v45) {
          NEFlowDirectorRedirectDNSToLoopback(v45, v44);
        }
      }

      goto LABEL_122;
    }

    goto LABEL_120;
  }

LABEL_118:
  uint64_t v36 = sub_100043D10(0LL);
  if ((v36 & 1) != 0)
  {
    sub_100043A44(0, (int)[0 isSubscriberUnlimited]);
    uint64_t v41 = 0LL;
    goto LABEL_37;
  }

LABEL_120:
  char v115 = nplog_obj(v36, v37, v38);
  CFErrorRef v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v115);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "DNS proxy not supported on this platform",  buf,  2u);
  }

        goto LABEL_121;
      }

      uint64_t v5 = v120;
      if (v72) {
        goto LABEL_77;
      }
LABEL_121:
      uint64_t v7 = v116;
      uint64_t v8 = v119 + 1;
    }

    while ((id)(v119 + 1) != v117);
    __int128 v111 = [obj countByEnumeratingWithState:&v174 objects:v186 count:16];
    id v117 = v111;
  }

  while (v111);
LABEL_125:

LABEL_128:
  return v137;
}

LABEL_122:
}

BOOL sub_10006C368(BOOL a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount])
    {
      unint64_t v5 = 0LL;
      do
      {
        unsigned int v6 = [v4 conditionsAtIndex:v5];
        a1 = v6 == 18;
        if (v6 == 18) {
          break;
        }
        ++v5;
      }

      while (v5 < (unint64_t)[v4 conditionsCount]);
    }

    else
    {
      a1 = 0LL;
    }
  }

  return a1;
}

void sub_10006CB0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006CB2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = @"failure";
    if (v3) {
      uint64_t v7 = @"success";
    }
    int v10 = 138412290;
    uint64_t v11 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Configuration refresh activity finished with result %@",  (uint8_t *)&v10,  0xCu);
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  int v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;
}

void sub_10006D7A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location, char a23)
{
}

void sub_10006D7D0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v8 = nplog_obj(v5, v6, v7);
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v10 = @"failure";
    if ((_DWORD)a2) {
      int v10 = @"success";
    }
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v44 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Configuration refresh activity finished with result %@",  buf,  0xCu);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 88));
  uint64_t v12 = WeakRetained;
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32))
    {
      id v13 = objc_msgSend(WeakRetained[10], "containsObject:");
      if (!(_DWORD)v13)
      {
        if ((_DWORD)a2)
        {
          uint64_t v28 = nplog_obj(v13, v14, v15);
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            uint64_t v29 = "Success reported while checking configuration, ignore reporting any errors";
LABEL_26:
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, v29, buf, 2u);
          }

id sub_10006DBCC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) currentKnownNetworkProfile]);
  int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 networkName]);

  if (!v3)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) currentScanResult]);
    int v3 = (void *)objc_claimAutoreleasedReturnValue([v4 networkName]);
  }

  return v3;
}

void sub_10006DC38(uint64_t a1, void *a2)
{
  id v5 = a2;
  if ([v5 type] == (id)3)
  {
    int v3 = (void *)objc_claimAutoreleasedReturnValue([v5 interfaceName]);
    uint64_t v4 = (void *)sub_100074C28(v3);
    [*(id *)(a1 + 72) reportBlockedOnInterfaceName:v3 displayName:v4 type:3];
  }
}

void sub_10006DCB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 18)) {
    BOOL v3 = (_DWORD)a2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    uint64_t v5 = nplog_obj(a1, a2, a3);
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v26[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "report odoh auth outage", (uint8_t *)v26, 2u);
    }

    id v9 = *(id *)(a1 + 232);
    if (v9)
    {
      id v9 = [v9 timeIntervalSinceNow];
      unint64_t v11 = (unint64_t)v10;
    }

    else if (*(void *)(a1 + 304))
    {
      unint64_t v11 = *(void *)(a1 + 304);
    }

    else
    {
      unint64_t v11 = 1800LL;
    }

    if (!*(void *)(a1 + 184))
    {
      uint64_t v12 = nplog_obj(v9, v7, v8);
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v26[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Setting odoh auth outage restore timer",  (uint8_t *)v26,  2u);
      }

      uint64_t v15 = NPGetInternalQueue(v14);
      id v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v15);
      dispatch_source_t v17 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v16);
      unsigned int v18 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = v17;

      uint64_t v19 = *(void **)(a1 + 184);
      if (v19)
      {
        uint64_t v20 = v19;
        dispatch_time_t v21 = dispatch_time(0x8000000000000000LL, 1000000000 * v11);
        dispatch_source_set_timer(v20, v21, 0xFFFFFFFFFFFFFFFFLL, 0LL);

        objc_initWeak(&location, (id)a1);
        uint64_t v22 = *(void **)(a1 + 184);
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 3221225472LL;
        v26[2] = sub_10006EE38;
        _OWORD v26[3] = &unk_1000F97C0;
        uint64_t v23 = v22;
        objc_copyWeak(&v27, &location);
        dispatch_source_set_event_handler(v23, v26);

        dispatch_resume(*(dispatch_object_t *)(a1 + 184));
        uint64_t v24 = objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceNow:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceNow:",  (double)v11));
        uint64_t v25 = *(void **)(a1 + 232);
        *(void *)(a1 + 232) = v24;

        sub_100066738(a1);
        objc_destroyWeak(&v27);
        objc_destroyWeak(&location);
      }
    }

    *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = 1;
    [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
    sub_1000679B4(a1);
  }

void sub_10006DEE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10006DEFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 17)) {
    BOOL v3 = (_DWORD)a2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    uint64_t v5 = nplog_obj(a1, a2, a3);
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v26[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "report odoh outage", (uint8_t *)v26, 2u);
    }

    id v9 = *(id *)(a1 + 208);
    if (v9)
    {
      id v9 = [v9 timeIntervalSinceNow];
      unint64_t v11 = (unint64_t)v10;
    }

    else if (*(void *)(a1 + 304))
    {
      unint64_t v11 = *(void *)(a1 + 304);
    }

    else
    {
      unint64_t v11 = 1800LL;
    }

    if (!*(void *)(a1 + 176))
    {
      uint64_t v12 = nplog_obj(v9, v7, v8);
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v26[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Setting odoh outage restore timer",  (uint8_t *)v26,  2u);
      }

      uint64_t v15 = NPGetInternalQueue(v14);
      id v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v15);
      dispatch_source_t v17 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v16);
      unsigned int v18 = *(void **)(a1 + 176);
      *(void *)(a1 + 176) = v17;

      uint64_t v19 = *(void **)(a1 + 176);
      if (v19)
      {
        uint64_t v20 = v19;
        dispatch_time_t v21 = dispatch_time(0x8000000000000000LL, 1000000000 * v11);
        dispatch_source_set_timer(v20, v21, 0xFFFFFFFFFFFFFFFFLL, 0LL);

        objc_initWeak(&location, (id)a1);
        uint64_t v22 = *(void **)(a1 + 176);
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 3221225472LL;
        v26[2] = sub_10006ECF8;
        _OWORD v26[3] = &unk_1000F97C0;
        uint64_t v23 = v22;
        objc_copyWeak(&v27, &location);
        dispatch_source_set_event_handler(v23, v26);

        dispatch_resume(*(dispatch_object_t *)(a1 + 176));
        uint64_t v24 = objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceNow:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceNow:",  (double)v11));
        uint64_t v25 = *(void **)(a1 + 208);
        *(void *)(a1 + 20_Block_object_dispose(va, 8) = v24;

        sub_100066738(a1);
        objc_destroyWeak(&v27);
        objc_destroyWeak(&location);
      }
    }

    *(_BYTE *)(a1 + 17) = 1;
    [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
    sub_1000679B4(a1);
  }

void sub_10006E12C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10006E824(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = *(id *)(a1 + 200);
  if (v4)
  {
    id v4 = [v4 timeIntervalSinceNow];
    unint64_t v6 = (unint64_t)v5;
  }

  else if (*(void *)(a1 + 304))
  {
    unint64_t v6 = *(void *)(a1 + 304);
  }

  else
  {
    unint64_t v6 = 3600LL;
  }

  if (!*(void *)(a1 + 168))
  {
    uint64_t v7 = nplog_obj(v4, a2, a3);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Setting proxy outage restore timer",  (uint8_t *)buf,  2u);
    }

    uint64_t v10 = NPGetInternalQueue(v9);
    unint64_t v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
    dispatch_source_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v11);
    id v13 = *(void **)(a1 + 168);
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = v12;

    uint64_t v14 = *(void **)(a1 + 168);
    if (v14)
    {
      uint64_t v15 = v14;
      dispatch_time_t v16 = dispatch_time(0x8000000000000000LL, 1000000000 * v6);
      dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0LL);

      objc_initWeak(buf, (id)a1);
      dispatch_source_t v17 = *(void **)(a1 + 168);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_10006E9F8;
      handler[3] = &unk_1000F97C0;
      unsigned int v18 = v17;
      objc_copyWeak(&v22, buf);
      dispatch_source_set_event_handler(v18, handler);

      dispatch_resume(*(dispatch_object_t *)(a1 + 168));
      uint64_t v19 = objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceNow:", (double)v6));
      uint64_t v20 = *(void **)(a1 + 200);
      *(void *)(a1 + 200) = v19;

      sub_100066738(a1);
      objc_destroyWeak(&v22);
      objc_destroyWeak(buf);
    }
  }

void sub_10006E9DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10006E9F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  double v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Proxy outage restore timer fired", v11, 2u);
  }

  unint64_t v6 = (void *)os_transaction_create("com.apple.networkserviceproxy.proxyRestoreTimerFired");
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 21));
    uint64_t v9 = (void *)v8[21];
    v8[21] = 0LL;

    uint64_t v10 = (void *)v8[25];
    v8[25] = 0LL;

    [v8 proxyConnectivityActive];
  }
}

void sub_10006EAB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 15) || (_DWORD)a2 != 0)
    {
      uint64_t v5 = nplog_obj(a1, a2, a3);
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "report proxy outage", v9, 2u);
      }

      sub_10006E824(a1, v7, v8);
      *(_BYTE *)(a1 + 15) = 1;
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_1000679B4(a1);
    }
  }

void sub_10006EB68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 16) || (_DWORD)a2 != 0)
    {
      uint64_t v5 = nplog_obj(a1, a2, a3);
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "report proxy network outage", v9, 2u);
      }

      sub_10006E824(a1, v7, v8);
      *(_BYTE *)(a1 + 16) = 1;
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_1000679B4(a1);
    }
  }

void sub_10006ECF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_source_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Proxy outage restore timer fired", v17, 2u);
  }

  unint64_t v6 = (void *)os_transaction_create("com.apple.networkserviceproxy.odohRestoreTimerFired");
  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[22]);
    uint64_t v9 = *(void **)(v8 + 176);
    *(void *)(v8 + 176) = 0LL;

    uint64_t v10 = *(void **)(v8 + 208);
    *(void *)(v8 + 20_Block_object_dispose(va, 8) = 0LL;

    if (*(_BYTE *)(v8 + 17))
    {
      uint64_t v14 = nplog_obj(v11, v12, v13);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "restore odoh connectivity", buf, 2u);
      }

      *(_BYTE *)(v8 + 17) = 0;
      dispatch_time_t v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v8 + 56) mergeProxyTrafficStateWithCurrentPolicy]);
      [(id)v8 policiesUpdated:*(void *)(v8 + 56) policy:v16 resolverInfoChanged:1];
      sub_1000502B0(*(id **)(v8 + 192));
      sub_1000679B4(v8);
    }
  }
}

void sub_10006EE38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_source_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "odoh auth outage restore timer fired", v17, 2u);
  }

  unint64_t v6 = (void *)os_transaction_create("com.apple.networkserviceproxy.odohAuthOutageRestoreTimerFired");
  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[23]);
    uint64_t v9 = *(void **)(v8 + 184);
    *(void *)(v8 + 184) = 0LL;

    uint64_t v10 = *(void **)(v8 + 232);
    *(void *)(v8 + 232) = 0LL;

    if (*(_BYTE *)(v8 + 18))
    {
      uint64_t v14 = nplog_obj(v11, v12, v13);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "restore odoh auth connectivity", buf, 2u);
      }

      *(_BYTE *)(v8 + 1_Block_object_dispose(va, 8) = 0;
      dispatch_time_t v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v8 + 56) mergeProxyTrafficStateWithCurrentPolicy]);
      [(id)v8 policiesUpdated:*(void *)(v8 + 56) policy:v16 resolverInfoChanged:1];
      sub_1000502B0(*(id **)(v8 + 192));
      sub_1000679B4(v8);
    }
  }
}

void sub_10006F54C(void *a1, const char *a2, void *a3)
{
  id v9 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v5);
  uint64_t v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v8)
  {
    if (v9) {
      sub_1000709DC(reply, a2, (uint64_t)v9);
    }
    xpc_connection_send_message(v8, reply);
  }
}

uint64_t sub_10006F5DC(void *a1, void *a2)
{
  id v3 = a2;
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(a1);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(remote_connection);
  if (v5)
  {
    unint64_t v6 = (void *)xpc_connection_copy_entitlement_value(v5, [v3 UTF8String]);
    uint64_t v7 = v6;
    if (v6 && xpc_get_type(v6) == (xpc_type_t)&_xpc_type_BOOL) {
      int v8 = xpc_BOOL_get_value(v7) << 31 >> 31;
    }
    else {
      LOBYTE(v_Block_object_dispose(va, 8) = 0;
    }
  }

  else
  {
    LOBYTE(v_Block_object_dispose(va, 8) = 0;
  }

  return v8 & 1;
}

void sub_10006F67C(void *a1, const char *a2, void *a3)
{
  id v11 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v5);
  int v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v8)
  {
    if (v11)
    {
      id v9 = reply;
      id v10 = v11;
      xpc_dictionary_set_string(v9, a2, (const char *)[v10 UTF8String]);
    }

    xpc_connection_send_message(v8, reply);
  }
}

void sub_10006F738(uint64_t a1, void *a2)
{
}

void sub_10006F74C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (v8)
  {
    if (v7)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      _DWORD v11[2] = sub_10006FCD4;
      v11[3] = &unk_1000FA1E8;
      id v12 = v8;
      uint64_t v13 = a1;
      id v14 = v7;
      id v15 = v10;
      [v14 resolveWithCompletionHandler:v11];
    }

    else
    {
      sub_10006F844(a1, 0LL, v8);
    }
  }

  else
  {
    (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Edge set identifier is nil");
  }
}

void sub_10006F844(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = *(id *)(a1 + 40);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 edgeSets]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v6]);

    if (v9)
    {
      uint64_t v13 = nplog_obj(v10, v11, v12);
      id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v5)
      {
        if (v15)
        {
          int v43 = 138412290;
          id v44 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Merging new edge with current edge set for %@",  (uint8_t *)&v43,  0xCu);
        }

        [v9 merge:v5 missingSettingsOnly:0];
        [v9 link];
        [v9 saveToKeychain];
      }

      else
      {
        if (v15)
        {
          int v43 = 138412290;
          id v44 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Merging default with current edge set for %@",  (uint8_t *)&v43,  0xCu);
        }

        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSPConfiguration defaultConfiguration](&OBJC_CLASS___NSPConfiguration, "defaultConfiguration"));
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 edgeSets]);
        id v30 = (void *)objc_claimAutoreleasedReturnValue([v29 objectForKeyedSubscript:v6]);

        if (v30)
        {
          [v9 merge:v30 missingSettingsOnly:0];
          [v9 link];
          [v9 saveToKeychain];
        }

        else
        {
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgeSets]);
          id v32 = [v31 mutableCopy];

          [v32 removeObjectForKey:v6];
          uint64_t v33 = -[NSDictionary initWithDictionary:](objc_alloc(&OBJC_CLASS___NSDictionary), "initWithDictionary:", v32);
          [*(id *)(a1 + 40) setEdgeSets:v33];

          [v9 removeFromKeychain];
        }

        [v9 removeDayPassesFromKernel];
        [v9 teardownNetworkAgent];
      }

      id v34 = (void *)objc_claimAutoreleasedReturnValue([v9 edgesGeneration]);

      if (!v34)
      {
        [v9 setEdgesGeneration:&off_100103668];
        [v9 setUsedEdgesGeneration:&off_100103668];
      }

      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v9 edgesGeneration]);
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v35 unsignedIntValue] + 1));
      [v9 setEdgesGeneration:v36];

      sub_100066A30(a1, v37, v38);
      [v9 cancelProbes];
      id v39 = objc_alloc(&OBJC_CLASS___NPUsageReport);
      uint64_t SigningIdentifier = getSigningIdentifier();
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(SigningIdentifier);
      id v19 = [v39 initWithSigningIdentifier:v41 fallbackReason:0];

      CFErrorRef v42 = (void *)objc_claimAutoreleasedReturnValue([v9 keybag]);
      objc_msgSend(v19, "setKeybagGeneration:", objc_msgSend(v42, "generation"));

      [v9 handleUsageReport:v19];
    }

    else
    {
      if (!v5)
      {
LABEL_21:

        goto LABEL_22;
      }

      uint64_t v16 = nplog_obj(v10, v11, v12);
      dispatch_source_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v43 = 138412290;
        id v44 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Adding new edge set %@",  (uint8_t *)&v43,  0xCu);
      }

      unsigned int v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) edgeSets]);
      id v19 = [v18 mutableCopy];

      [v19 setObject:v5 forKeyedSubscript:v6];
      uint64_t v20 = -[NSDictionary initWithDictionary:](objc_alloc(&OBJC_CLASS___NSDictionary), "initWithDictionary:", v19);
      [*(id *)(a1 + 40) setEdgeSets:v20];

      [v5 link];
      sub_100066A30(a1, v21, v22);
      id v23 = objc_alloc(&OBJC_CLASS___NPUsageReport);
      uint64_t v24 = getSigningIdentifier();
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      id v26 = [v23 initWithSigningIdentifier:v25 fallbackReason:0];

      id v27 = (void *)objc_claimAutoreleasedReturnValue([v5 keybag]);
      objc_msgSend(v26, "setKeybagGeneration:", objc_msgSend(v27, "generation"));

      [v5 handleUsageReport:v26];
      [v5 setEdgesGeneration:&off_100103668];
      [v5 setUsedEdgesGeneration:&off_100103680];
      [v5 setShouldSave:1];
      [*(id *)(a1 + 40) saveToKeychain];
    }

    goto LABEL_21;
  }

uint64_t sub_10006FCD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v8 = 138412290;
      uint64_t v9 = v7;
      _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "%@: failed to resolve new edge set",  (uint8_t *)&v8,  0xCu);
    }
  }

  sub_10006F844(*(void *)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 32));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16LL))();
}

void sub_10006FD9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (v3)
  {
    uint64_t v7 = nplog_obj(v3, v4, v5);
    int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) matchSigningIdentifier]);
      int v10 = 138412546;
      uint64_t v11 = v9;
      __int16 v12 = 2112;
      uint64_t v13 = v6;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Failed to remove edge set %@: %@",  (uint8_t *)&v10,  0x16u);
    }
  }
}

void sub_10006FE78(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if ((a2 & 1) != 0)
  {
    id v3 = v2;
    message = (NSString *)xpc_dictionary_create_reply(v3);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v3);
    uint64_t v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

    if (message) {
      BOOL v6 = v5 == 0LL;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6) {
      xpc_connection_send_message(v5, message);
    }
  }

  else
  {
    message = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to establish trust with edge set %@",  *(void *)(a1 + 40));
    sub_10006F67C(v2, "NSPServerErrorString", message);
  }
}

void sub_10006FF28(uint64_t a1, BOOL a2)
{
  id v3 = *(id *)(a1 + 32);
  xpc_object_t xdict = xpc_dictionary_create_reply(v3);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v3);
  uint64_t v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (xdict) {
    BOOL v6 = v5 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    xpc_dictionary_set_BOOL(xdict, "NSPServerCommandResult", a2);
    xpc_connection_send_message(v5, xdict);
  }
}

void sub_10006FFB4(void *a1, int64_t a2, void *a3)
{
  id v11 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v5);
  int v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v8)
  {
    xpc_dictionary_set_int64(reply, "NSPServerErrorCode", a2);
    if (v11)
    {
      id v9 = reply;
      id v10 = v11;
      xpc_dictionary_set_string(v9, "NSPServerErrorString", (const char *)[v10 UTF8String]);
    }

    xpc_connection_send_message(v8, reply);
  }
}

void sub_100070080(uint64_t a1, int a2)
{
  if (!a2)
  {
    sub_10006FFB4(*(void **)(a1 + 40), 1006LL, @"invalid configuration data signature");
    return;
  }

  id v3 = [[NSPPrivacyProxyConfiguration alloc] initWithData:*(void *)(a1 + 32)];
  id v8 = v3;
  if (!v3)
  {
    uint64_t v7 = *(void **)(a1 + 40);
LABEL_8:
    sub_10006FFB4(v7, 1005LL, @"invalid configuration data");
    goto LABEL_9;
  }

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 dictionaryRepresentation]);

  id v5 = *(void **)(a1 + 40);
  if (!v4)
  {
    uint64_t v7 = v5;
    goto LABEL_8;
  }

  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue([v8 dictionaryRepresentation]);
  sub_100070150(v5, "NSPServerPrivacyProxyConfigDictionary", v6);

LABEL_9:
}

void sub_100070150(void *a1, const char *a2, void *a3)
{
  id v11 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v5);
  id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v8)
  {
    if (v11)
    {
      id v9 = reply;
      id v10 = (void *)_CFXPCCreateXPCObjectFromCFObject(v11);
      xpc_dictionary_set_value(v9, a2, v10);
    }

    xpc_connection_send_message(v8, reply);
  }
}

id sub_100070208(uint64_t a1)
{
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 userTier]);
  id v5 = [v4 unsignedIntegerValue];
  if (v5 == (id)1
    && (id v6 = *(id *)(a1 + 40),
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v6 willResetSubscriberTierTomorrow]),
        BOOL v15 = v6,
        ([v14 BOOLValue] & 1) != 0))
  {
    int v7 = 0;
  }

  else
  {
    id v1 = *(id *)(a1 + 72);
    if (![v1 hasPausedApps])
    {

      id v12 = 0LL;
      goto LABEL_12;
    }

    int v7 = 1;
  }

  id v8 = *(id *)(a1 + 40);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 resetTomorrowDate]);
  if (v9)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
    id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) resetTomorrowDate]);
    id v12 = [v10 isDateInTomorrow:v11];
  }

  else
  {
    id v12 = 0LL;
  }

  if (v7) {
LABEL_12:
  }
  if (v5 == (id)1)
  {
  }

  return v12;
}

uint64_t sub_100070358(uint64_t a1)
{
  uint64_t v3 = a1;
  if (a1)
  {
    id v4 = *(id *)(a1 + 40);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 userTier]);
    id v6 = [v5 unsignedIntegerValue];
    if (v6 == (id)1
      && (id v1 = *(id *)(v3 + 40),
          uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 willResetSubscriberTierTomorrow]),
          ([v2 BOOLValue] & 1) != 0))
    {
      int v7 = 0;
    }

    else
    {
      id v8 = *(id *)(v3 + 72);
      if (![v8 hasPausedApps])
      {

        uint64_t v3 = 0LL;
        if (v6 != (id)1) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }

      uint64_t v21 = v8;
      int v7 = 1;
    }

    id v9 = *(id *)(v3 + 40);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 resetTomorrowDate]);
    if (v10)
    {
      id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
      uint64_t v12 = objc_claimAutoreleasedReturnValue([*(id *)(v3 + 40) resetTomorrowDate]);
      int v13 = v7;
      id v14 = v6;
      BOOL v15 = v5;
      id v16 = v4;
      dispatch_source_t v17 = v2;
      id v18 = v1;
      id v19 = (void *)v12;
      unsigned int v22 = [v11 isDateInTomorrow:v12] ^ 1;

      id v1 = v18;
      uint64_t v2 = v17;
      id v4 = v16;
      id v5 = v15;
      id v6 = v14;
      int v7 = v13;
    }

    else
    {
      unsigned int v22 = 0;
    }

    if (v7) {
    uint64_t v3 = v22;
    }
    if (v6 != (id)1) {
      goto LABEL_16;
    }
LABEL_15:

LABEL_16:
  }

  return v3;
}

void sub_1000704E8(uint64_t a1, xpc_activity_t activity)
{
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  uint64_t v6 = nplog_obj(state, v4, v5);
  int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    xpc_activity_state_t v15 = state;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Tomorrow timer activity state %ld",  buf,  0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    id v9 = WeakRetained;
    if (WeakRetained)
    {
      uint64_t v10 = NPGetInternalQueue(WeakRetained);
      id v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100070614;
      block[3] = &unk_1000F9450;
      id v13 = v9;
      dispatch_async(v11, block);
    }
  }

void sub_100070614(uint64_t a1)
{
  if (sub_100070358(*(void *)(a1 + 32)))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2) {
      uint64_t v3 = *(void **)(v2 + 72);
    }
    else {
      uint64_t v3 = 0LL;
    }
    id v4 = [v3 hasPausedApps];
    int v7 = (int)v4;
    if ((_DWORD)v4)
    {
      uint64_t v8 = nplog_obj(v4, v5, v6);
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Resetting all paused apps after activity timer",  buf,  2u);
      }

      uint64_t v10 = *(void *)(a1 + 32);
      if (v10) {
        id v11 = *(void **)(v10 + 72);
      }
      else {
        id v11 = 0LL;
      }
      [v11 clearAllPausedApps];
    }

    uint64_t v12 = *(void **)(a1 + 32);
    if (v12) {
      uint64_t v12 = (void *)v12[5];
    }
    id v13 = v12;
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 userTier]);
    if ([v14 unsignedIntegerValue] == (id)1)
    {
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        id v16 = *(void **)(v15 + 40);
      }
      else {
        id v16 = 0LL;
      }
      dispatch_source_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 willResetSubscriberTierTomorrow]);
      unsigned int v18 = [v17 BOOLValue];

      if (v18)
      {
        uint64_t v22 = nplog_obj(v19, v20, v21);
        id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id v34 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Resetting user tier to subscriber after activity timer",  v34,  2u);
        }

        uint64_t v24 = *(void *)(a1 + 32);
        if (v24) {
          uint64_t v25 = *(void **)(v24 + 56);
        }
        else {
          uint64_t v25 = 0LL;
        }
        id v26 = [v25 setUserTier:2 resetDate:0 clearResetDate:1 changeSource:2];
        if ((v26 & 1) == 0)
        {
          uint64_t v29 = nplog_obj(v26, v27, v28);
          id v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v33 = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Failed to set user tier to subscriber",  v33,  2u);
          }
        }

        goto LABEL_28;
      }
    }

    else
    {
    }

    uint64_t v31 = *(void *)(a1 + 32);
    if (v31) {
      id v32 = *(void **)(v31 + 56);
    }
    else {
      id v32 = 0LL;
    }
    [v32 clearResetDate];
LABEL_28:
    if (v7) {
      sub_10007081C(*(void *)(a1 + 32));
    }
  }

void sub_10007081C(uint64_t a1)
{
  if (a1)
  {
    v11[0] = 0LL;
    v11[1] = v11;
    _DWORD v11[2] = 0x3032000000LL;
    v11[3] = sub_100057300;
    void v11[4] = sub_100057310;
    id v12 = (id)os_transaction_create("com.apple.networkserviceproxy.policiesUpdated");
    id v2 = *(id *)(a1 + 56);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 mergeProxyTrafficStateWithCurrentPolicy]);

    uint64_t v5 = NPGetInternalQueue(v4);
    uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100073F7C;
    block[3] = &unk_1000F9320;
    void block[4] = a1;
    id v9 = v3;
    uint64_t v10 = v11;
    id v7 = v3;
    dispatch_async(v6, block);

    _Block_object_dispose(v11, 8);
  }

void sub_10007091C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100070934(void *a1, const char *a2, void *a3)
{
  id v10 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v5);
  uint64_t v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v8)
  {
    if (v10)
    {
      id v9 = reply;
      xpc_dictionary_set_uint64(v9, a2, [v10 unsignedIntValue]);
    }

    xpc_connection_send_message(v8, reply);
  }
}

void sub_1000709DC(void *a1, const char *a2, uint64_t a3)
{
  id v8 = a1;
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  a3,  1LL,  0LL));
  if (v5)
  {
    id v6 = v8;
    id v7 = (void *)_CFXPCCreateXPCObjectFromCFObject(v5);
    xpc_dictionary_set_value(v6, a2, v7);
  }
}

void sub_100070A70(void *a1, void *a2)
{
  id v9 = a2;
  id v3 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v3);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v3);
  id v6 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

  if (reply && v6)
  {
    if (v9)
    {
      id v7 = reply;
      id v8 = (void *)_CFXPCCreateXPCObjectFromCFObject(v9);
      xpc_dictionary_set_value(v7, "NSPServerPrivacyProxyTokenEvents", v8);
    }

    xpc_connection_send_message(v6, reply);
  }
}

void sub_100070B20(void *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  id v7 = a1;
  id v8 = v7;
  if (v7)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 currentState]);
    unsigned int v10 = [v9 isRunning];

    if (v10) {
      *a3 = 1;
    }
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v8 currentState]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 endowmentNamespaces]);
    unsigned int v13 = [v12 containsObject:@"com.apple.frontboard.visibility"];

    if (v13)
    {
      *a4 = 1;
    }

    else
    {
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      id v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "currentState", 0));
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 assertions]);

      id v16 = [v15 countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v16)
      {
        id v17 = v16;
        uint64_t v18 = *(void *)v23;
        while (2)
        {
          for (CFIndex i = 0LL; i != v17; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v23 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v22 + 1) + 8 * (void)i) domain]);
            unsigned int v21 = [v20 containsString:@"com.apple.webkit:Foreground"];

            if (v21)
            {
              *a4 = 1;
              goto LABEL_18;
            }
          }

          id v17 = [v15 countByEnumeratingWithState:&v22 objects:v26 count:16];
          if (v17) {
            continue;
          }
          break;
        }
      }

id sub_100070CFC(id *a1, void *a2, void *a3)
{
  id v74 = a2;
  if (!a1)
  {
    id v66 = 0LL;
    id v11 = v74;
    goto LABEL_70;
  }

  uint64_t v69 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a1[5] proxyConfiguration]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 authInfo]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 nonDefaultAttesters]);

  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  id v7 = v6;
  id v71 = [v7 countByEnumeratingWithState:&v85 objects:v94 count:16];
  if (!v71)
  {
    id v9 = 0LL;
    uint64_t v59 = v7;
    goto LABEL_67;
  }

  uint64_t v78 = 0LL;
  id v9 = 0LL;
  uint64_t v10 = *(void *)v86;
  *(void *)&__int128 v8 = 138412290LL;
  __int128 v68 = v8;
  id v11 = v74;
  uint64_t v73 = v7;
  uint64_t v70 = *(void *)v86;
  do
  {
    uint64_t v12 = 0LL;
    do
    {
      if (*(void *)v86 != v10) {
        objc_enumerationMutation(v7);
      }
      uint64_t v72 = v12;
      unsigned int v13 = *(void **)(*((void *)&v85 + 1) + 8 * v12);
      __int128 v81 = 0u;
      __int128 v82 = 0u;
      __int128 v83 = 0u;
      __int128 v84 = 0u;
      uint64_t v75 = v13;
      id obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "associatedIssuers", v68));
      id v14 = [obj countByEnumeratingWithState:&v81 objects:v93 count:16];
      if (!v14) {
        goto LABEL_59;
      }
      id v15 = v14;
      uint64_t v16 = *(void *)v82;
      while (2)
      {
        id v17 = 0LL;
        id v76 = v15;
        do
        {
          if (*(void *)v82 != v16) {
            objc_enumerationMutation(obj);
          }
          uint64_t v18 = *(void **)(*((void *)&v81 + 1) + 8LL * (void)v17);
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 issuerName]);
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 issuerName]);
          unsigned int v21 = [v19 isEqualToString:v20];

          if (os_variant_allows_internal_security_policies("com.apple.networkserviceproxy")
            && (__int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v11 issuerName]),
                unsigned int v23 = [v22 containsString:@";"],
                v22,
                v23))
          {
            __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v11 issuerName]);
            uint64_t v25 = objc_claimAutoreleasedReturnValue([v24 componentsSeparatedByString:@";"]);
            id v26 = (void *)objc_claimAutoreleasedReturnValue([(id)v25 firstObject]);

            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v18 issuerName]);
            LOBYTE(v25) = [v27 isEqualToString:v26];

            if ((v25 & 1) == 0) {
              goto LABEL_57;
            }
          }

          else if (!v21)
          {
            goto LABEL_57;
          }

          if (!a3) {
            goto LABEL_65;
          }
          id v28 = v18;
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 tokenKeys]);
          id v30 = [v29 count];

          if (v30)
          {
            id v77 = v9;
            __int128 v91 = 0u;
            __int128 v92 = 0u;
            __int128 v89 = 0u;
            __int128 v90 = 0u;
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v28 tokenKeys]);
            id v32 = [v31 countByEnumeratingWithState:&v89 objects:v97 count:16];
            if (v32)
            {
              id v33 = v32;
              id v34 = 0LL;
              uint64_t v35 = *(void *)v90;
              while (2)
              {
                for (CFIndex i = 0LL; i != v33; CFIndex i = (char *)i + 1)
                {
                  if (*(void *)v90 != v35) {
                    objc_enumerationMutation(v31);
                  }
                  uint64_t v37 = *(void **)(*((void *)&v89 + 1) + 8LL * (void)i);
                  if (([v37 hasExpiration] & 1) == 0
                    && ![v37 hasRotation])
                  {
LABEL_45:
                    id v52 = v37;

                    uint64_t v51 = 3LL;
                    unsigned __int8 v49 = v34;
                    id v34 = v52;
                    id v11 = v74;
                    id v9 = v77;
                    goto LABEL_51;
                  }

                  else {
                    id v38 = [v37 expiration];
                  }
                  id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSince1970:",  (double)(unint64_t)v38));
                  [v39 timeIntervalSinceNow];
                  double v41 = v40;

                  BOOL v43 = v41 < 30.0 && v34 != 0LL;
                  if (v41 >= 0.0 && !v43)
                  {
                    if (v41 >= 30.0) {
                      goto LABEL_45;
                    }
                    id v44 = v37;

                    id v34 = v44;
                  }
                }

                id v33 = [v31 countByEnumeratingWithState:&v89 objects:v97 count:16];
                if (v33) {
                  continue;
                }
                break;
              }

              id v11 = v74;
              if (v34)
              {
                uint64_t v48 = nplog_obj(v45, v46, v47);
                unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
                id v9 = v77;
                if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
                {
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v28 issuerName]);
                  *(_DWORD *)__int128 buf = v68;
                  double v96 = v50;
                  _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_INFO,  "Returning a key for %@ that is about to expire",  buf,  0xCu);
                }

                uint64_t v51 = 2LL;
LABEL_51:

                goto LABEL_52;
              }
            }

            else
            {
            }

            uint64_t v53 = nplog_obj(v45, v46, v47);
            uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
            id v9 = v77;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            {
              int v56 = (void *)objc_claimAutoreleasedReturnValue([v28 issuerName]);
              *(_DWORD *)__int128 buf = v68;
              double v96 = v56;
              _os_log_error_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "Failed to find a non-expired key for %@, choosing the last available key",  buf,  0xCu);
            }

            unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 tokenKeys]);
            id v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[os_log_s lastObject](v49, "lastObject"));
            uint64_t v51 = 1LL;
            goto LABEL_51;
          }

          uint64_t v51 = 0LL;
          id v34 = 0LL;
LABEL_52:

          *a3 = v34;
          if (v51 == 3)
          {
LABEL_65:
            id v66 = v75;

            id v7 = v73;
            goto LABEL_69;
          }

          if (!v9 || v51 > v78)
          {
            id v55 = v75;

            uint64_t v78 = v51;
            id v9 = v55;
          }

          id v15 = v76;
LABEL_57:
          id v17 = (char *)v17 + 1;
        }

        while (v17 != v15);
        id v15 = [obj countByEnumeratingWithState:&v81 objects:v93 count:16];
        if (v15) {
          continue;
        }
        break;
      }

LABEL_59:
      uint64_t v12 = v72 + 1;
      id v7 = v73;
      uint64_t v10 = v70;
    }

    while ((id)(v72 + 1) != v71);
    id v71 = [v73 countByEnumeratingWithState:&v85 objects:v94 count:16];
  }

  while (v71);

  if (v78 == 1)
  {
    id v57 = v69[5];
    __int16 v58 = (void *)objc_claimAutoreleasedReturnValue([v57 configurationFetchDate]);
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v58,  1LL,  2LL));

    uint64_t v63 = nplog_obj(v60, v61, v62);
    uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v74 issuerName]);
      *(_DWORD *)id v97 = 138412546;
      id v98 = v59;
      __int16 v99 = 2112;
      char v100 = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "Configuration with fetch date %@ has no non-expired keys for issuer %@",  v97,  0x16u);
    }

    [v69 refreshProxyInfo:6];
    id v7 = v73;
LABEL_67:

    id v11 = v74;
  }

  id v9 = v9;
  id v66 = v9;
LABEL_69:

LABEL_70:
  return v66;
}

  -[NSPConfigurationStats setAppMetricsEnabled:](v15, "setAppMetricsEnabled:", 1LL);
  unsigned int v13 = v15;
  if ((v12 & 0x400000) == 0)
  {
LABEL_34:
    if ((v12 & 0x800000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_61;
  }

uint64_t sub_1000713E4(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (v4 && xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenChallenge");
    id v7 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
    uint64_t v8 = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessPairedTokenChallenge");
    uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);
    uint64_t v10 = (void *)v9;
    if (v7 && !*(void *)(*(void *)(a1[5] + 8LL) + 40LL))
    {
      uint64_t v18 = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenKey");
      id v11 = (NSPPrivateAccessTokenChallenge *)objc_claimAutoreleasedReturnValue(v18);
      if (v11)
      {
        id v15 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenKey);
        -[NSPPrivacyProxyTokenKey setKey:](v15, "setKey:", v11);
      }

      else
      {
        id v15 = 0LL;
      }

      uint64_t v19 = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenOriginNameKey");
      id v14 = (void *)objc_claimAutoreleasedReturnValue(v19);
      id v17 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v7);
      if (v17)
      {
        uint64_t v20 = (id *)a1[4];
        id v27 = 0LL;
        id v21 = sub_100070CFC(v20, v17, &v27);
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
        id v23 = v27;
        __int128 v24 = v23;
        if (v15 || (id v15 = (NSPPrivacyProxyTokenKey *)v23) != 0LL)
        {
          objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), v22);
          objc_storeStrong((id *)(*(void *)(a1[5] + 8LL) + 40LL), v17);
          objc_storeStrong((id *)(*(void *)(a1[7] + 8LL) + 40LL), v15);
          objc_storeStrong((id *)(*(void *)(a1[8] + 8LL) + 40LL), v14);
        }
      }
    }

    else
    {
      if (!v9 || *(void *)(*(void *)(a1[9] + 8LL) + 40LL)) {
        goto LABEL_21;
      }
      id v11 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v9);
      if (!v11)
      {
LABEL_20:

LABEL_21:
        goto LABEL_22;
      }

      uint64_t v12 = (id *)a1[4];
      id v26 = 0LL;
      id v13 = sub_100070CFC(v12, v11, &v26);
      id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      id v15 = (NSPPrivacyProxyTokenKey *)v26;
      if (!v15)
      {
LABEL_19:

        goto LABEL_20;
      }

      objc_storeStrong((id *)(*(void *)(a1[10] + 8LL) + 40LL), v14);
      objc_storeStrong((id *)(*(void *)(a1[9] + 8LL) + 40LL), v11);
      uint64_t v16 = *(void *)(a1[11] + 8LL);
      id v15 = v15;
      id v17 = *(NSPPrivateAccessTokenChallenge **)(v16 + 40);
      *(void *)(v16 + 40) = v15;
    }

    goto LABEL_19;
  }

uint64_t sub_100071650(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (!v4 || xpc_get_type(v4) != (xpc_type_t)&_xpc_type_dictionary) {
    goto LABEL_13;
  }
  nsdata_from_xpc_xpc_object_t object = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenChallenge");
  id v7 = (void *)objc_claimAutoreleasedReturnValue(nsdata_from_xpc_object);
  uint64_t v8 = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenKey");
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (v9)
  {
    uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenKey);
    -[NSPPrivacyProxyTokenKey setKey:](v10, "setKey:", v9);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  uint64_t v11 = get_nsdata_from_xpc_object(v5, "NSPServerPrivateAccessTokenOriginNameKey");
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  if (!v7
    || (id v13 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v7)) == 0LL)
  {

LABEL_13:
    uint64_t v20 = 1LL;
    goto LABEL_14;
  }

  id v14 = v13;
  id v15 = (id *)a1[4];
  id v22 = 0LL;
  id v16 = sub_100070CFC(v15, v14, &v22);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  id v18 = v22;
  uint64_t v19 = v18;
  if (v10 || (uint64_t v10 = (NSPPrivacyProxyTokenKey *)v18) != 0LL)
  {
    objc_storeStrong((id *)(*(void *)(a1[5] + 8LL) + 40LL), v17);
    objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), v14);
    objc_storeStrong((id *)(*(void *)(a1[7] + 8LL) + 40LL), v10);
    objc_storeStrong((id *)(*(void *)(a1[8] + 8LL) + 40LL), v12);
  }

  uint64_t v20 = 0LL;
LABEL_14:

  return v20;
}

void sub_10007180C(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_BYTE *)(a1 + 144))
  {
    id v4 = a3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));
    uint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 40LL);
    uint64_t v32 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL);
    uint64_t v26 = *(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL);
    uint64_t v28 = *(void *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 40LL);
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 120) + 8LL) + 40LL);
    uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 128) + 8LL) + 40LL);
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 136) + 8LL) + 40LL);
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    __int16 v11 = *(_WORD *)(a1 + 145);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472LL;
    uint8_t v36[2] = sub_100071A50;
    v36[3] = &unk_1000FA2B0;
    uint64_t v12 = *(void *)(a1 + 48);
    id v13 = (NSString *)*(id *)(a1 + 56);
    uint64_t v14 = *(void *)(a1 + 64);
    uint64_t v37 = v13;
    uint64_t v38 = v14;
    LOWORD(v25) = v11;
    objc_msgSend( v5,  "fetchPairedPrivateAccessTokensForChallenge:overrideAttester:tokenKey:originNameKey:selectedOrigin:pairedChallenge: overridePairedAttester:pairedTokenKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:",  v32,  v30,  v28,  v26,  v10,  v6,  v7,  v8,  v9,  v12,  v25,  v4,  v36);

    string = v37;
  }

  else
  {
    id v16 = *(void **)(a1 + 56);
    id v33 = a3;
    string = (NSString *)xpc_dictionary_get_string(v16, "NSPServerAuxiliaryAuthenticationCacheKey");
    if (string) {
      string = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
    }
    id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));
    uint64_t v29 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 40LL);
    uint64_t v31 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL);
    uint64_t v18 = *(void *)(a1 + 80);
    uint64_t v27 = *(void *)(a1 + 72);
    uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 40LL);
    uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL);
    uint64_t v21 = *(void *)(a1 + 32);
    uint64_t v22 = *(void *)(a1 + 40);
    __int16 v23 = *(_WORD *)(a1 + 145);
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472LL;
    v34[2] = sub_100071C7C;
    _OWORD v34[3] = &unk_1000FA2D8;
    uint64_t v24 = *(void *)(a1 + 48);
    id v35 = *(id *)(a1 + 56);
    LOWORD(v25) = v23;
    objc_msgSend( v17,  "fetchPrivateAccessTokenForChallenge:overrideAttester:customAttester:customAttesterHeaders:tokenKey:originNameKey:s electedOrigin:auxiliaryAuthInfoCacheKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:",  v31,  v29,  v27,  v18,  v19,  v20,  v21,  string,  v22,  v24,  v25,  v33,  v34);
  }
}

void sub_100071A50(uint64_t a1, void *a2, void *a3, void *a4, int64_t a5, void *a6)
{
  id v24 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a6;
  if (v24 && v11)
  {
    xpc_object_t reply = (__CFString *)xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*(xpc_object_t *)(a1 + 32));
    id v16 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);
    if (v16)
    {
      id v17 = reply;
      uint64_t v18 = (void *)_CFXPCCreateXPCObjectFromCFObject(v24);
      xpc_dictionary_set_value(v17, "NSPServerPrivateAccessTokenPairLongLived", v18);

      uint64_t v19 = v17;
      uint64_t v20 = (void *)_CFXPCCreateXPCObjectFromCFObject(v11);
      xpc_dictionary_set_value(v19, "NSPServerPrivateAccessTokenPairOneTime", v20);

      if (v12)
      {
        uint64_t v21 = v19;
        uint64_t v22 = (void *)_CFXPCCreateXPCObjectFromCFObject(v12);
        xpc_dictionary_set_value(v21, "NSPServerPrivateAccessTokenPairOneTimeSalt", v22);
      }

      xpc_connection_send_message(v16, v19);
    }
  }

  else
  {
    xpc_object_t reply = @"Eligible account not found";
    switch(a5)
    {
      case 1003LL:
        break;
      case 1004LL:
      case 1005LL:
      case 1011LL:
        [*(id *)(a1 + 40) refreshProxyInfo:6];
        int64_t v23 = a5 - 1005;
        a5 = qword_1000C3900[v23];
        xpc_object_t reply = *(&off_1000FA538 + v23);
        break;
      case 1007LL:
        xpc_object_t reply = @"Paired token issuance server error";
        break;
      case 1008LL:
        xpc_object_t reply = @"Unsupported token type";
        break;
      case 1009LL:
        xpc_object_t reply = @"Rate limited";
        break;
      case 1010LL:
        xpc_object_t reply = @"Device authentication invalid";
        break;
      case 1012LL:
        xpc_object_t reply = @"Network connectivity error";
        break;
      default:
LABEL_11:
        xpc_object_t reply = @"Invalid parameter";
        a5 = 1004LL;
        break;
    }

    if (v13) {
      xpc_object_t reply = (__CFString *)objc_claimAutoreleasedReturnValue( -[__CFString stringByAppendingFormat:]( reply,  "stringByAppendingFormat:",  @": %@",  v13));
    }
    sub_10006FFB4(*(void **)(a1 + 32), a5, reply);
  }
}

void sub_100071C7C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v12 = a2;
  id v7 = a4;
  uint64_t v8 = v7;
  if (!v12)
  {
    uint64_t v9 = a3 - 1003;
    if ((unint64_t)(a3 - 1003) > 9)
    {
      id v11 = @"Invalid parameter";
      int64_t v10 = 1004LL;
      if (!v7)
      {
LABEL_8:
        sub_10006FFB4(*(void **)(a1 + 32), v10, v11);

        goto LABEL_9;
      }
    }

    else
    {
      int64_t v10 = qword_1000C3938[v9];
      id v11 = *(&off_1000FA570 + v9);
      if (!v7) {
        goto LABEL_8;
      }
    }

    id v11 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString stringByAppendingFormat:](v11, "stringByAppendingFormat:", @": %@", v7));
    goto LABEL_8;
  }

  sub_100070150(*(void **)(a1 + 32), "NSPServerPrivateAccessToken", v12);
LABEL_9:
}

void sub_100071D50(void *a1, int a2, int a3, void *a4)
{
  id v7 = a4;
  if (a1)
  {
    objc_initWeak(&location, a1);
    uint64_t v8 = @"networking.privacy.subscriber";
    if (a2) {
      uint64_t v8 = @"networking.privacy.attestation";
    }
    if (a3) {
      uint64_t v9 = @"cloud.llm";
    }
    else {
      uint64_t v9 = v8;
    }
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_100072BD8;
    v10[3] = &unk_1000FA3C8;
    objc_copyWeak(&v12, &location);
    id v11 = v7;
    +[CSFFeatureManager requestFeatureWithId:completion:]( &OBJC_CLASS___CSFFeatureManager,  "requestFeatureWithId:completion:",  v9,  v10);

    objc_destroyWeak(&v12);
    objc_destroyWeak(&location);
  }
}

void sub_100071E40(_Unwind_Exception *a1)
{
}

void sub_100071E5C(uint64_t a1, char a2)
{
  uint64_t v4 = NPGetInternalQueue(a1);
  id v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100071EEC;
  v6[3] = &unk_1000FA328;
  char v8 = a2;
  id v7 = *(id *)(a1 + 32);
  dispatch_async(v5, v6);
}

void sub_100071EEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  id v7 = v6;
  if (v4)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)id v12 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "proxy setup for MPTCP converter proxy is successful",  v12,  2u);
    }

    id v8 = *(id *)(a1 + 32);
    xpc_object_t reply = xpc_dictionary_create_reply(v8);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(v8);
    id v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue(remote_connection);

    if (reply)
    {
      if (v11) {
        xpc_connection_send_message(v11, reply);
      }
    }
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "failed to setup proxying to MPTCP converter proxy",  buf,  2u);
    }

    sub_10006FFB4(*(void **)(a1 + 32), 1004LL, @"Setup Failure");
  }

void sub_1000720C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000720DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = @"failure";
    if (v3) {
      id v7 = @"success";
    }
    int v10 = 138412290;
    id v11 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Configuration refresh activity finished with result %@",  (uint8_t *)&v10,  0xCu);
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;
}

void sub_100072378(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v16[0] = 0LL;
  v16[1] = v16;
  v16[2] = 0x3032000000LL;
  v16[3] = sub_100057300;
  void v16[4] = sub_100057310;
  id v17 = (id)os_transaction_create("com.apple.networkserviceproxy.subscriptionStatus");
  uint64_t v7 = NPGetInternalQueue(v17);
  uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_1000724B8;
  v11[3] = &unk_1000FA350;
  objc_copyWeak(&v15, (id *)(a1 + 32));
  id v12 = v6;
  id v13 = v5;
  uint64_t v14 = v16;
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v8, v11);

  objc_destroyWeak(&v15);
  _Block_object_dispose(v16, 8);
}

void sub_1000724A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000724B8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v5 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32))
    {
      uint64_t v6 = nplog_obj(WeakRetained, v3, v4);
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v58 = *(void *)(a1 + 32);
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v58;
        _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Received error %@ while looking up feature status",  (uint8_t *)&buf,  0xCu);
      }

      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) domain]);
      if ([v8 isEqualToString:@"CloudFeaturesLocalErrorDomain"])
      {
        BOOL v9 = [*(id *)(a1 + 32) code] == (id)3;

        if (v9)
        {
          [*(id *)(v5 + 56) setProxyAccountType:1 unlimited:0];
          sub_1000697AC(v5, v10, v11);
          goto LABEL_35;
        }
      }

      else
      {
      }

      if ((deviceClassIsHomepod() & 1) == 0)
      {
        uint64_t v27 = *(dispatch_source_s **)(v5 + 144);
        if (v27)
        {
          dispatch_source_cancel(v27);
          uint64_t v28 = *(void **)(v5 + 144);
          *(void *)(v5 + 144) = 0LL;
        }

        unint64_t v29 = *(void *)(v5 + 152);
        if (v29 < 8)
        {
          int v32 = dword_1000C38C8[v29];
        }

        else
        {
          uint64_t v30 = nplog_obj(v27, v25, v26);
          uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(void *)&__int128 buf = 0x804000100LL;
            _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Failed subscription check after %u attempts",  (uint8_t *)&buf,  8u);
          }

          int v32 = 10800;
        }

        uint64_t v38 = arc4random_uniform(6u);
        int v39 = v38;
        ++*(void *)(v5 + 152);
        uint64_t v42 = nplog_obj(v38, v40, v41);
        BOOL v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
        uint64_t v44 = (v39 + v32);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Retry: checking subscription after %lu seconds",  (uint8_t *)&buf,  0xCu);
        }

        id inited = objc_initWeak(&location, (id)v5);
        uint64_t v46 = NPGetInternalQueue(inited);
        uint64_t v47 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v46);
        dispatch_source_t v48 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v47);
        unsigned __int8 v49 = *(void **)(v5 + 144);
        *(void *)(v5 + 144) = v48;

        if (*(void *)(v5 + 144))
        {
          uint64_t v50 = (dispatch_source_s *)*(id *)(v5 + 144);
          dispatch_time_t v51 = dispatch_time(0x8000000000000000LL, 1000000000LL * v44);
          dispatch_source_set_timer(v50, v51, 0xFFFFFFFFFFFFFFFFLL, 0LL);

          id v52 = *(void **)(v5 + 144);
          *(void *)&__int128 buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472LL;
          uint64_t v61 = sub_100072B1C;
          uint64_t v62 = &unk_1000F97C0;
          uint64_t v53 = v52;
          objc_copyWeak(&v63, &location);
          dispatch_source_set_event_handler(v53, &buf);

          dispatch_resume(*(dispatch_object_t *)(v5 + 144));
          objc_destroyWeak(&v63);
        }

        uint64_t v54 = objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceNow:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceNow:",  (double)v44));
        id v55 = *(void **)(v5 + 160);
        *(void *)(v5 + 160) = v54;

        sub_100066738(v5);
        objc_destroyWeak(&location);
      }
    }

    else
    {
      id v12 = *(void **)(a1 + 40);
      if (v12)
      {
        id v13 = [v12 canUse];
        if ((_DWORD)v13)
        {
          id v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) limit]);

          uint64_t v20 = nplog_obj(v17, v18, v19);
          uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = "";
            if (!v16) {
              uint64_t v22 = " (unlimited)";
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v22;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "privacy proxy feature available%{public}s",  (uint8_t *)&buf,  0xCu);
          }

          [*(id *)(v5 + 56) setProxyAccountType:2 unlimited:v16 == 0];
        }

        else
        {
          uint64_t v33 = nplog_obj(v13, v14, v15);
          id v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "privacy proxy feature unavailable",  (uint8_t *)&buf,  2u);
          }

          id v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v5 + 56) currentConfiguration]);
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 proxyAccountType]);
          BOOL v37 = [v36 unsignedIntegerValue] == (id)2;

          if (v37) {
            [*(id *)(v5 + 72) reportServiceDisabledShouldReport:1];
          }
          [*(id *)(v5 + 56) setProxyAccountType:1 unlimited:0];
        }

        sub_1000697AC(v5, v23, v24);
      }
    }
  }

void sub_100072968( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_100072984(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = v6;
  v6[2] = 0x3032000000LL;
  v6[3] = sub_100057300;
  void v6[4] = sub_100057310;
  id v7 = (id)os_transaction_create("com.apple.networkserviceproxy.subscriptionCheckNotification");
  uint64_t v2 = NPGetInternalQueue(v7);
  uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100072A7C;
  v4[3] = &unk_1000F9B20;
  objc_copyWeak(&v5, (id *)(a1 + 32));
  v4[4] = v6;
  dispatch_async(v3, v4);

  objc_destroyWeak(&v5);
  _Block_object_dispose(v6, 8);
}

void sub_100072A64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100072A7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "feature change notification received", v10, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    sub_100068D18(WeakRetained);
    sub_100063EFC((uint64_t)v7);
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  BOOL v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;
}

void sub_100072B1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Subscription check retry timer fired", v10, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 18));
    uint64_t v8 = (void *)v7[18];
    v7[18] = 0LL;

    BOOL v9 = (void *)os_transaction_create("com.apple.networkserviceproxy.subscriptionCheck");
    sub_100068D18(v7);
  }
}

void sub_100072BD8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = NPGetInternalQueue(v6);
  uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_100072CC4;
  v11[3] = &unk_1000FA3A0;
  objc_copyWeak(&v15, (id *)(a1 + 40));
  id v12 = v6;
  id v13 = v5;
  id v14 = *(id *)(a1 + 32);
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v8, v11);

  objc_destroyWeak(&v15);
}

void sub_100072CC4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32)) {
      goto LABEL_3;
    }
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) accessToken]);

    if (!v8)
    {
      if (!*(void *)(a1 + 32))
      {
        uint64_t v14 = nplog_obj(WeakRetained, v3, v4);
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          unsigned int v15 = [*(id *)(a1 + 40) canUse];
          int v18 = 67109120;
          LODWORD(v19) = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "No access token received, status %u",  (uint8_t *)&v18,  8u);
        }

        goto LABEL_5;
      }

LABEL_3:
      uint64_t v6 = nplog_obj(WeakRetained, v3, v4);
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = *(void *)(a1 + 32);
        unsigned int v17 = [*(id *)(a1 + 40) canUse];
        int v18 = 138412546;
        uint64_t v19 = v16;
        __int16 v20 = 1024;
        unsigned int v21 = v17;
        _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Received error %@ while looking up access token, can use %u",  (uint8_t *)&v18,  0x12u);
      }

void sub_100072EC0(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
  [v2 handleAppInstallation:*(void *)(a1 + 32)];

  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

void sub_100072F0C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
  [v2 handleAppUninstallation:*(void *)(a1 + 32)];

  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0LL;
}

void sub_100072F58(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 && v3 && *(_BYTE *)(v5 + 9) && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    string = xpc_dictionary_get_string(v4, _xpc_event_key_name);
    uint64_t v7 = strcmp(string, "ApplicationInstalled");
    if (!(_DWORD)v7)
    {
      uint64_t v10 = nplog_obj(v7, v8, v9);
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "%@ received app installation event",  buf,  0xCu);
      }
    }

    uint64_t v13 = strcmp(string, "ApplicationUninstalled");
    int v16 = v13;
    if (!(_DWORD)v13)
    {
      uint64_t v17 = nplog_obj(v13, v14, v15);
      int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        uint64_t v19 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "%@ received app uninstallation event",  buf,  0xCu);
      }
    }

    uint64_t v20 = *(void *)(a1 + 32);
    if (v20)
    {
      xpc_object_t value = xpc_dictionary_get_value(v4, "UserInfo");
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(value);
      uint64_t v23 = v22;
      if (v22 && xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v25 = (void *)_CFXPCCreateCFObjectFromXPCObject(v23);
        uint64_t v28 = nplog_obj(v25, v26, v27);
        unint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v20;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "%@ apps installation/uninstallation event was received with user info: %@",  buf,  0x16u);
        }

        id v30 = (id)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:@"bundleIDs"]);
        uint64_t v31 = objc_opt_class(&OBJC_CLASS___NSArray);
        if (v30 && (char isKindOfClass = objc_opt_isKindOfClass(v30, v31), v30, (isKindOfClass & 1) != 0))
        {
          uint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }

        else
        {
          uint64_t v24 = 0LL;
        }
      }

      else
      {
        uint64_t v24 = 0LL;
      }
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    id v33 = -[NSMutableArray count](v24, "count");
    if (v33)
    {
      uint64_t v36 = nplog_obj(v33, v34, v35);
      BOOL v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
      {
        uint64_t v38 = *(void *)(a1 + 32);
        int v39 = "installed";
        *(_DWORD *)__int128 buf = 138412802;
        if (!v16) {
          int v39 = "uninstalled";
        }
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v24;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v54 = (uint64_t (*)(uint64_t, uint64_t))v39;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "%@ %@ apps were %s", buf, 0x20u);
      }

      uint64_t v40 = *(void *)(a1 + 32);
      uint64_t v41 = v24;
      if (v40)
      {
        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000LL;
        uint64_t v54 = sub_100057300;
        id v55 = sub_100057310;
        uint64_t v42 = (void *)os_transaction_create("com.apple.networkserviceproxy.appsInstallOrUninstall");
        id v56 = v42;
        if (v16)
        {
          dispatch_time_t v43 = dispatch_time(0LL, 2000000000LL);
          uint64_t v44 = NPGetInternalQueue(v43);
          uint64_t v45 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v44);
          uint64_t v47 = _NSConcreteStackBlock;
          uint64_t v48 = 3221225472LL;
          unsigned __int8 v49 = sub_100072EC0;
          uint64_t v50 = &unk_1000F9428;
          dispatch_time_t v51 = v41;
          id v52 = buf;
          dispatch_after(v43, v45, &v47);
        }

        else
        {
          uint64_t v46 = NPGetInternalQueue(v42);
          uint64_t v45 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v46);
          uint64_t v47 = _NSConcreteStackBlock;
          uint64_t v48 = 3221225472LL;
          unsigned __int8 v49 = sub_100072F0C;
          uint64_t v50 = &unk_1000F9428;
          dispatch_time_t v51 = v41;
          id v52 = buf;
          dispatch_async(v45, &v47);
        }

        _Block_object_dispose(buf, 8);
      }
    }
  }
}

void sub_1000733F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100073418(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_100057300;
  v5[4] = sub_100057310;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.setUserEventAgentCaptiveOutage");
  uint64_t v2 = NPGetInternalQueue(v6);
  id v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000734F0;
  v4[3] = &unk_1000F9428;
  v4[4] = a1;
  void v4[5] = v5;
  dispatch_async(v3, v4);

  _Block_object_dispose(v5, 8);
}

void sub_1000734D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000734F0(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v2 = *(void *)(a1 + 32);
  int64_t v3 = -1LL;
  if (v2 && *(_BYTE *)(v2 + 19)) {
    int64_t v3 = 1LL;
  }
  xpc_dictionary_set_int64(xdict, "CaptiveOutage", v3);
  uint64_t v4 = *(void *)(a1 + 32);
  int64_t v5 = -1LL;
  if (v4 && *(_BYTE *)(v4 + 20)) {
    int64_t v5 = 1LL;
  }
  xpc_dictionary_set_int64(xdict, "CaptiveOutageWaitingForUserActivity", v5);
  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", xdict);
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0LL;
}

void sub_1000735A8(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    sub_100073604(WeakRetained, a2);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  int64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

void sub_100073604(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (v3 > 4) {
      uint64_t v7 = @"unknown";
    }
    else {
      uint64_t v7 = *(&off_1000FA5C0 + (int)v3);
    }
    buf[0] = 138412546;
    *(void *)&buf[1] = a1;
    __int16 v42 = 2112;
    dispatch_time_t v43 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%@ received captive probe result [%@]",  (uint8_t *)buf,  0x16u);
  }

  if (v3 != 2)
  {
    if (v3 != 1)
    {
      if (!v3)
      {
        sub_100073D80(a1);
        if (*(_BYTE *)(a1 + 19))
        {
          uint64_t v14 = nplog_obj(v11, v12, v13);
          uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            buf[0] = 138412290;
            *(void *)&buf[1] = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "%@ captive probe was successful, reporting service active ...",  (uint8_t *)buf,  0xCu);
          }

          sub_10006714C(a1, 0LL, v16);
        }
      }

      return;
    }

    uint64_t v25 = nplog_obj(v8, v9, v10);
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 138412290;
      *(void *)&buf[1] = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "%@ captive probe received HTTP redirect",  (uint8_t *)buf,  0xCu);
    }

    uint64_t v27 = (os_unfair_lock_s *)(a1 + 28);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
    int v28 = *(unsigned __int8 *)(a1 + 21);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 28));
    if (!v28)
    {
      unint64_t v29 = objc_alloc_init(&OBJC_CLASS___NSPOutageReasonStats);
      id v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) tierToString]);
      -[NSPOutageReasonStats setTierType:](v29, "setTierType:", v30);

      -[NSPOutageReasonStats setOutageReasonType:](v29, "setOutageReasonType:", @"Captive");
      -[NSPOutageReasonStats setOutageReasonSubType:](v29, "setOutageReasonSubType:", @"CaptiveProbeRedirected");
      objc_storeStrong((id *)(a1 + 288), v29);
      uint64_t v31 = IOPMGetUserActivityLevel(buf, v40);
      if ((_DWORD)v31 || (buf[0] & 1) == 0)
      {
        if (!*(_BYTE *)(a1 + 19))
        {
          uint64_t v37 = nplog_obj(v31, v32, v33);
          uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_INFO,  "(inactive user) captive network outage cannot be reported now",  (uint8_t *)buf,  2u);
          }

          *(_WORD *)(a1 + 19) = 256;
          sub_1000679B4(a1);
          sub_100073418(a1);
        }
      }

      else
      {
        uint64_t v34 = nplog_obj(v31, v32, v33);
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_INFO,  "(active user) captive network outage can be reported",  (uint8_t *)buf,  2u);
        }

        sub_10006714C(a1, 1LL, v36);
      }
    }

void sub_1000739FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 28));
    int v2 = *(unsigned __int8 *)(v1 + 21);
    os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 28));
    if (v2)
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = &v11;
      uint64_t v13 = 0x3032000000LL;
      uint64_t v14 = sub_100057300;
      uint64_t v15 = sub_100057310;
      id v16 = (id)os_transaction_create("com.apple.networkserviceproxy.captive-evaluation");
      unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSPCaptiveWiFiHandler sharedHandler](&OBJC_CLASS___NSPCaptiveWiFiHandler, "sharedHandler"));
      objc_initWeak(&location, (id)v1);
      id v4 = *(id *)(v1 + 120);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 interfaceName]);
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472LL;
      v8[2] = sub_1000735A8;
      v8[3] = &unk_1000FA410;
      objc_copyWeak(&v9, &location);
      v8[4] = &v11;
      unsigned __int8 v6 = [v3 evaluate:v5 completionHandler:v8];

      if ((v6 & 1) == 0)
      {
        uint64_t v7 = (void *)v12[5];
        void v12[5] = 0LL;
      }

      objc_destroyWeak(&v9);
      objc_destroyWeak(&location);

      _Block_object_dispose(&v11, 8);
    }
  }

void sub_100073B60( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_100073B98(uint64_t a1, char a2)
{
  id v4 = (os_unfair_lock_s *)(a1 + 28);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
  if ((a2 & 1) != 0)
  {
    unint64_t v5 = 1LL;
  }

  else
  {
    unint64_t v5 = *(void *)(a1 + 280) + 1LL;
    if (v5 > 6) {
      goto LABEL_5;
    }
  }

  *(void *)(a1 + 280) = v5;
LABEL_5:
  unsigned __int8 v6 = *(dispatch_source_s **)(a1 + 272);
  if (v6)
  {
    dispatch_source_cancel(v6);
    uint64_t v7 = *(void **)(a1 + 272);
    *(void *)(a1 + 272) = 0LL;
  }

  uint64_t v8 = arc4random_uniform(6u);
  LODWORD(v9) = dword_1000C38E8[*(void *)(a1 + 280) - 1];
  double v10 = (double)v8 + (double)v9;
  uint64_t v13 = nplog_obj(v8, v11, v12);
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    LODWORD(v24) = 134217984;
    *(double *)((char *)&v24 + 4) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "wait time for the next captive evaluation is [%f] seconds",  (uint8_t *)&v24,  0xCu);
  }

  uint64_t v16 = NPGetInternalQueue(v15);
  uint64_t v17 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v16);
  dispatch_source_t v18 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v17);
  unint64_t v19 = *(void **)(a1 + 272);
  *(void *)(a1 + 272) = v18;

  uint64_t v20 = *(void **)(a1 + 272);
  if (v20)
  {
    uint64_t v21 = v20;
    dispatch_time_t v22 = dispatch_time(0LL, (uint64_t)(v10 * 1000000000.0));
    dispatch_source_set_timer(v21, v22, 0xFFFFFFFFFFFFFFFFLL, 0LL);

    uint64_t v23 = *(dispatch_source_s **)(a1 + 272);
    *(void *)&__int128 v24 = _NSConcreteStackBlock;
    *((void *)&v24 + 1) = 3221225472LL;
    uint64_t v25 = sub_1000739FC;
    uint64_t v26 = &unk_1000F9450;
    uint64_t v27 = a1;
    dispatch_source_set_event_handler(v23, &v24);
    dispatch_resume(*(dispatch_object_t *)(a1 + 272));
    *(_BYTE *)(a1 + 21) = 1;
  }

  os_unfair_lock_unlock(v4);
}

void sub_100073D80(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 28);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
  int v3 = *(unsigned __int8 *)(a1 + 21);
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    os_unfair_lock_lock(v2);
    id v4 = *(dispatch_source_s **)(a1 + 272);
    if (v4)
    {
      dispatch_source_cancel(v4);
      unint64_t v5 = *(void **)(a1 + 272);
      *(void *)(a1 + 272) = 0LL;
    }

    *(void *)(a1 + 280) = 0LL;
    *(_BYTE *)(a1 + 21) = 0;
    os_unfair_lock_unlock(v2);
    uint64_t v9 = nplog_obj(v6, v7, v8);
    double v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "stopped captive evaluation retry", v11, 2u);
    }
  }

void sub_100073E3C(uint64_t a1)
{
  int v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSPCaptiveWiFiHandler sharedHandler](&OBJC_CLASS___NSPCaptiveWiFiHandler, "sharedHandler"));
  [v2 abort];

  int v3 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0LL;
}

uint64_t sub_100073E7C(uint64_t a1)
{
  id v2 = *(id *)(a1 + 96);
  if (v2)
  {
    int v3 = v2;
    id v4 = *(id *)(a1 + 120);
    if (v4)
    {
      unint64_t v5 = v4;
      id v6 = *(id *)(a1 + 120);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 currentKnownNetworkProfile]);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 networkName]);
      unsigned __int8 v9 = [v8 isEqualToString:*(void *)(a1 + 96)];

      if ((v9 & 1) != 0) {
        return 1LL;
      }
    }

    else
    {
    }
  }

  return 0LL;
}

void sub_100073F20(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    sub_100073604((uint64_t)WeakRetained, a2, v4);
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100073F7C(void *a1)
{
  id v2 = (void *)a1[4];
  if (v2) {
    uint64_t v3 = v2[7];
  }
  else {
    uint64_t v3 = 0LL;
  }
  [v2 policiesUpdated:v3 policy:a1[5] resolverInfoChanged:0];
  uint64_t v4 = *(void *)(a1[6] + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0LL;
}

void sub_100073FC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a2 == 1)
  {
    uint64_t v5 = nplog_obj(a1, a2, a3);
    id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v24 = 138412290;
      uint64_t v25 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "%@ CNPluginMonitor received kCNPluginMonitorEventTypePluginListChanged event",  (uint8_t *)&v24,  0xCu);
    }

    uint64_t v8 = (void *)CNPluginMonitorEventCopyDisplayIDs(a3);
    uint64_t v11 = nplog_obj(v8, v9, v10);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = *(void *)(a1 + 32);
      int v24 = 138412546;
      uint64_t v25 = v13;
      __int16 v26 = 2112;
      uint64_t v27 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "%@ CNPluginMonitor received plugins %@",  (uint8_t *)&v24,  0x16u);
    }

    id Property = *(id *)(a1 + 32);
    if (v8)
    {
      if (Property) {
        id Property = objc_getProperty(Property, v14, 48LL, 1);
      }
      id v16 = [Property isEqualToArray:v8];
    }

    else if (!Property || (id v16 = objc_getProperty(Property, v14, 48LL, 1)) == 0LL)
    {
LABEL_18:

      return;
    }

    uint64_t v19 = nplog_obj(v16, v17, v18);
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = *(void *)(a1 + 32);
      int v24 = 138412546;
      uint64_t v25 = v21;
      __int16 v26 = 2112;
      uint64_t v27 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "%@ CNPluginMonitor received new captive plugins %@",  (uint8_t *)&v24,  0x16u);
    }

    uint64_t v23 = *(void **)(a1 + 32);
    if (v23)
    {
      objc_setProperty_atomic(v23, v22, v8, 48LL);
      uint64_t v23 = *(void **)(a1 + 32);
    }

    sub_10007081C((uint64_t)v23);
    goto LABEL_18;
  }

void sub_1000743A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1000743C4(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112))
    {
      nw_resolver_cancel();
      id v2 = *(void **)(a1 + 112);
      *(void *)(a1 + 112) = 0LL;
    }
  }

void sub_100074404(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (a2 == 2)
  {
    uint64_t count = nw_array_get_count(v5);
    uint64_t v10 = nplog_obj(count, v8, v9);
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    uint64_t v12 = v11;
    if (count)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        int v17 = 138412290;
        uint64_t v18 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "DNS probe passed on %@",  (uint8_t *)&v17,  0xCu);
      }

      if (WeakRetained) {
        uint64_t v14 = (void *)WeakRetained[8];
      }
      else {
        uint64_t v14 = 0LL;
      }
      uint64_t v15 = 0LL;
    }

    else
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 32);
        int v17 = 138412290;
        uint64_t v18 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "DNS probe blocked on %@",  (uint8_t *)&v17,  0xCu);
      }

      if (WeakRetained) {
        uint64_t v14 = (void *)WeakRetained[8];
      }
      else {
        uint64_t v14 = 0LL;
      }
      uint64_t v15 = 1LL;
    }

    [v14 updateDNSFilteringHint:v15];
    sub_1000743C4((uint64_t)WeakRetained);
  }
}

void sub_100074570(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = NPGetInternalQueue(WeakRetained);
    uint64_t v7 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v6);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    v8[2] = sub_100074624;
    v8[3] = &unk_1000F9A80;
    id v9 = v3;
    id v10 = v5;
    dispatch_async(v7, v8);
  }
}

void sub_100074624(uint64_t a1)
{
  id v2 = (char *)[*(id *)(a1 + 32) type];
  if ((unint64_t)(v2 - 19) < 2)
  {
    uint64_t v18 = nplog_obj(v2, v3, v4);
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      uint64_t v20 = *(void **)(a1 + 40);
      if (v20) {
        uint64_t v20 = (void *)v20[15];
      }
      uint64_t v21 = v20;
      dispatch_time_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 networkName]);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v40 = v22;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "IPv4/IPv6 changed for SSID [%@]", buf, 0xCu);
    }

    uint64_t v23 = *(void *)(a1 + 40);
    if (v23)
    {
      int v24 = *(void **)(v23 + 120);
      if (v24
        && (id v25 = v24,
            __int16 v26 = (void *)objc_claimAutoreleasedReturnValue([v25 currentKnownNetworkProfile]),
            v26,
            v25,
            !v26))
      {
        uint64_t v35 = nplog_obj(v27, v28, v29);
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "Wi-Fi disassociated", buf, 2u);
        }

        sub_100073E3C(v23);
        sub_100073D80(v23);
      }

      else
      {
        sub_10006AA24(v23);
      }
    }
  }

  else if (v2 == (char *)2)
  {
    uint64_t v30 = nplog_obj(2LL, v3, v4);
    uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      uint64_t v32 = *(void **)(a1 + 40);
      if (v32) {
        uint64_t v32 = (void *)v32[15];
      }
      uint64_t v33 = v32;
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v33 networkName]);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v40 = v34;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "Wi-Fi SSID changed to [%@]", buf, 0xCu);
    }

    sub_10006A1A8(*(void *)(a1 + 40));
  }

  else if (v2 == (char *)30)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v5 + 120) currentKnownNetworkProfile]);
      id v38 = v6;
      if (!v6) {
        goto LABEL_32;
      }
      unsigned __int8 v7 = [v38 isCaptive];
      uint64_t v8 = v38;
      if ((v7 & 1) == 0)
      {
        unsigned int v9 = [v38 wasCaptive];
        uint64_t v8 = v38;
        if (!v9) {
          goto LABEL_32;
        }
      }

      id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 captiveProfile]);
      uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0)
      {
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"user-portal-url"]);
        uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v12, v13) & 1) != 0)
        {
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v12));
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 scheme]);
          unsigned int v16 = [v15 isEqualToString:@"https"];

          if (v16) {
            int v17 = (void *)objc_claimAutoreleasedReturnValue([v14 host]);
          }
          else {
            int v17 = 0LL;
          }

          if (v17)
          {
            uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
            [v37 setCaptivePortalExceptionHostname:v17];

            goto LABEL_33;
          }

LABEL_32:
          int v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
          [v17 setCaptivePortalExceptionHostname:0];
LABEL_33:

          return;
        }
      }

      goto LABEL_32;
    }
  }

uint64_t sub_100074C28(void *a1)
{
  id v1 = a1;
  id v2 = (const __SCNetworkInterface *)_SCNetworkInterfaceCreateWithBSDName(kCFAllocatorDefault, v1, 0xFFFFFFFFLL);
  uint64_t v3 = (uint64_t)v1;
  if (v2)
  {
    uint64_t v4 = v2;
    CFStringRef LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(v2);
    uint64_t v3 = objc_claimAutoreleasedReturnValue(LocalizedDisplayName);

    CFRelease(v4);
  }

  return v3;
}

void sub_100074C98(const __SCDynamicStore *a1, void *a2)
{
  id v4 = sub_10005725C();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  sub_10006A2F8((uint64_t)v5);

  id v6 = a2;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v34 objects:v40 count:16];
  if (v7)
  {
    id v9 = v7;
    uint64_t v10 = *(void *)v35;
    uint64_t v11 = kSCEntNetPvD;
    *(void *)&__int128 v8 = 138412290LL;
    __int128 v33 = v8;
    do
    {
      uint64_t v12 = 0LL;
      do
      {
        if (*(void *)v35 != v10) {
          objc_enumerationMutation(v6);
        }
        uint64_t v13 = *(__CFString **)(*((void *)&v34 + 1) + 8LL * (void)v12);
        if (-[__CFString containsString:](v13, "containsString:", v11, v33))
        {
          uint64_t v14 = (id)SCDynamicStoreCopyValue(a1, v13);
          uint64_t v17 = nplog_obj(v14, v15, v16);
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
          BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_INFO);
          if (v14)
          {
            if (v19)
            {
              *(_DWORD *)__int128 buf = v33;
              int v39 = v14;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "Discovered PvD dictionary: %@",  buf,  0xCu);
            }

            id v20 = sub_10005725C();
            uint64_t v21 = (id *)objc_claimAutoreleasedReturnValue(v20);
            id v22 = v14;
            if (v21)
            {
              id v23 = v21[8];
              if (v23) {
                [v23 didReceiveUpdatedPvDOptions:v22];
              }
            }
          }

          else
          {
            if (v19)
            {
              *(_DWORD *)__int128 buf = v33;
              int v39 = 0LL;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "PvD key is not longer present: %@",  buf,  0xCu);
            }

            id v24 = sub_10005725C();
            uint64_t v25 = objc_claimAutoreleasedReturnValue(v24);
            uint64_t v21 = (id *)v25;
            if (v25)
            {
              __int16 v26 = *(void **)(v25 + 64);
              if (v26)
              {
                id v27 = [v26 networkDiscoveredProxyPresentInAgentManager];
                if ((_DWORD)v27)
                {
                  uint64_t v30 = nplog_obj(v27, v28, v29);
                  uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "Clean up network discovered proxy",  buf,  2u);
                  }

                  [v21[8] tearDownNetworkDiscoveredProxy];
                }
              }
            }
          }
        }

        uint64_t v12 = (char *)v12 + 1;
      }

      while (v9 != v12);
      id v32 = [v6 countByEnumeratingWithState:&v34 objects:v40 count:16];
      id v9 = v32;
    }

    while (v32);
  }
}

LABEL_29:
    }
  }

  else
  {
    id v63 = nplog_obj(v50, v51, v52);
    uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138543362;
      uint64_t v75 = v20;
      _os_log_error_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_ERROR,  "Failed to disable private relay on %{public}@",  buf,  0xCu);
    }

    CFRelease(v34);
  }

  CFRelease(v19);
LABEL_31:

  serviceStatusManager = self->_serviceStatusManager;
LABEL_32:
  -[NSPServiceStatusManager reportDisabledOnInterfaceName:displayName:type:]( serviceStatusManager,  "reportDisabledOnInterfaceName:displayName:type:",  v15,  v9,  v5,  v72);

  unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyPolicyHandler sharedHandler]( &OBJC_CLASS___NSPPrivacyProxyPolicyHandler,  "sharedHandler"));
  [v49 interface:v15 disabled:1];
}

  return v4;
}

_DWORD *sub_100075430(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (*(_DWORD *)(a2 + 16) == 3 && WeakRetained != 0LL)
  {
    id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    __int128 v8 = v7;
    id v9 = (void *)v4[5];
    if (v9)
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 diagnostics]);
      uint64_t v11 = (objc_class *)objc_opt_class(&OBJC_CLASS___NSPConfiguration);
      uint64_t v12 = NSStringFromClass(v11);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v8, "setObject:forKeyedSubscript:", v10, v13);
    }

    uint64_t v14 = (void *)v4[7];
    if (v14)
    {
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 diagnostics]);
      uint64_t v16 = (objc_class *)objc_opt_class(&OBJC_CLASS___NSPConfigurationManager);
      uint64_t v17 = NSStringFromClass(v16);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v8, "setObject:forKeyedSubscript:", v15, v18);
    }

    id v19 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyInfo);
    id v20 = (void *)v4[7];
    if (v20) {
      [v20 copyProxyInfo:v19];
    }
    uint64_t v21 = (void *)v4[8];
    if (v21) {
      [v21 copyProxyInfo:v19];
    }
    id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));

    if (v22)
    {
      id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyTokenManager sharedTokenManager]( &OBJC_CLASS___NSPPrivacyTokenManager,  "sharedTokenManager"));
      [v23 copyTokenInfo:v19];
    }

    id v24 = (void *)objc_claimAutoreleasedReturnValue([v19 diagnostics]);
    uint64_t v25 = (objc_class *)objc_opt_class(&OBJC_CLASS___PrivacyProxyInfo);
    __int16 v26 = NSStringFromClass(v25);
    id v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v8, "setObject:forKeyedSubscript:", v24, v27);

    uint64_t v28 = (void *)v4[9];
    if (v28)
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 diagnostics]);
      if (v29)
      {
        uint64_t v30 = (objc_class *)objc_opt_class(&OBJC_CLASS___NSPServiceStatusManager);
        uint64_t v31 = NSStringFromClass(v30);
        id v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        -[NSMutableDictionary setObject:forKeyedSubscript:](v8, "setObject:forKeyedSubscript:", v29, v32);
      }
    }

    id v46 = 0LL;
    __int128 v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v8,  200LL,  0LL,  &v46));
    id v34 = v46;
    id v35 = [v33 length];
    if (v34)
    {
      uint64_t v38 = nplog_obj(v35, v36, v37);
      int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v48 = v34;
        uint64_t v40 = "serializing state data failed with error: %@";
        uint64_t v41 = v39;
        uint32_t v42 = 12;
LABEL_28:
        _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
      }
    }

    else
    {
      unsigned int v43 = v35;
      if (v35 <= 0x8000)
      {
        id v6 = calloc(1uLL, v35 + 200LL);
        *id v6 = 1;
        v6[1] = v43;
        __strlcpy_chk(v6 + 34, "Privacy Proxy Summary", 64LL, 64LL);
        memcpy(v6 + 50, [v33 bytes], v43);
LABEL_30:

        goto LABEL_31;
      }

      uint64_t v44 = nplog_obj(v35, v36, v37);
      int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v4_Block_object_dispose(va, 8) = v43;
        uint64_t v40 = "serialized data length %u exceed max state dump size";
        uint64_t v41 = v39;
        uint32_t v42 = 8;
        goto LABEL_28;
      }
    }

    id v6 = 0LL;
    goto LABEL_30;
  }

  id v6 = 0LL;
LABEL_31:

  return v6;
}

void sub_10007579C(uint64_t a1)
{
  id WeakRetained = (int *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    close(WeakRetained[8]);
    id WeakRetained = v2;
    v2[8] = -1;
  }
}

void sub_1000757D8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    ssize_t v1 = recv(*((_DWORD *)WeakRetained + 8), v26, 0x100uLL, 0);
    if (v1 >= 1)
    {
      do
      {
        BOOL v4 = v26[1] == 1 && v26[2] == 1;
        if (!v4 || v26[3] != 2) {
          goto LABEL_19;
        }
        if (v1 >= (unint64_t)v26[0])
        {
          if (v27 != 20) {
            goto LABEL_19;
          }
          if (v26[0] > 0x33u)
          {
            v29[15] = 0;
            snprintf(__str, 0x11uLL, "%s%d", v29, v28);
            uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue([*((id *)WeakRetained + 11) interfaceName]);
            id v7 = v12;
            goto LABEL_14;
          }

          uint64_t v8 = nplog_obj(v1, v2, v3);
          id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__str = 0;
            id v9 = v7;
            uint64_t v10 = "Received undersize KEV_DL_LINK_QUALITY_METRIC_CHANGED from kernel";
            uint32_t v11 = 2;
LABEL_25:
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)__str, v11);
          }
        }

        else
        {
          uint64_t v6 = nplog_obj(v1, v2, v3);
          id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__str = 67109632;
            *(_DWORD *)id v23 = 256;
            *(_WORD *)&void v23[4] = 1024;
            *(_DWORD *)&void v23[6] = v26[0];
            __int16 v24 = 1024;
            int v25 = v27;
            id v9 = v7;
            uint64_t v10 = "buffer too small (%u vs %u) for event code %u";
            uint32_t v11 = 20;
            goto LABEL_25;
          }
        }

void sub_100075B6C(uint64_t a1)
{
}

void sub_100075B74(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    BOOL v4 = WeakRetained;
    sub_100068FA4(WeakRetained, v2, v3);
    id WeakRetained = v4;
  }
}

void sub_100075BA4(uint64_t a1, char a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v10 = WeakRetained;
    uint64_t v6 = nplog_obj(WeakRetained, v4, v5);
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = "active";
      if ((a2 & 1) == 0) {
        uint64_t v8 = "not active";
      }
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v12 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "received user activity notification, user is %s",  buf,  0xCu);
    }

    id WeakRetained = v10;
    if ((a2 & 1) != 0 && *((_BYTE *)v10 + 20))
    {
      sub_10006714C((uint64_t)v10, 1LL, v9);
      id WeakRetained = v10;
    }
  }
}

void sub_100075F64(id a1)
{
  ssize_t v1 = objc_alloc_init(&OBJC_CLASS___NSPCoreData);
  uint64_t v2 = (void *)qword_1001171B8;
  qword_1001171B8 = (uint64_t)v1;
}

void sub_100076478(id a1, NSPersistentStoreDescription *a2, NSError *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  uint64_t v8 = v5;
  if (v5)
  {
    uint64_t v9 = nplog_obj(v5, v6, v7);
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = 138412546;
      uint64_t v12 = v4;
      __int16 v13 = 2112;
      uint64_t v14 = v8;
      _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Failed to load CoreData persistent store %@ with error %@",  (uint8_t *)&v11,  0x16u);
    }
  }
}

LABEL_103:
                    LOBYTE(v4_Block_object_dispose(va, 8) = 0;
                    goto LABEL_71;
                  }

                  uint64_t v59 = v56;
                  uint64_t v60 = objc_claimAutoreleasedReturnValue( +[NSPCoreData getNSPEventsProbability:count:]( &OBJC_CLASS___NSPCoreData,  "getNSPEventsProbability:count:",  v48,  -[os_log_s integerValue](v56, "integerValue")));
                  id v63 = (void *)v60;
                  if (v60)
                  {
                    __int128 v147 = (void *)v60;
                    uint64_t v64 = nplog_obj(v60, v61, v62);
                    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v64);
                    if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
                    {
                      id v66 = COERCE_DOUBLE(-[os_log_s integerValue](v59, "integerValue"));
                      char v67 = [v23 integerValue];
                      [v147 doubleValue];
                      *(_DWORD *)__int128 buf = 134218754;
                      __int128 v159 = v66;
                      uint64_t v160 = 2048;
                      CFErrorRef v161 = *(double *)&v67;
                      CFErrorRef v162 = 2112;
                      __int128 v163 = v152;
                      id v164 = 2048;
                      id v165 = 1.0 - v68;
                      _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_INFO,  "Probability of seeing atleast %ld LWM events in next %ld mins for vendor:%@ is %f",  buf,  0x2Au);
                    }

                    id v71 = (void *)objc_claimAutoreleasedReturnValue( [v8 objectForKey:@"NSPEventsKeyUpperLWMCountProbabilityOffset"]);
                    LOBYTE(v4_Block_object_dispose(va, 8) = v71 != 0LL;
                    if (!v71)
                    {
                      SCDynamicStoreRef v135 = nplog_obj(0LL, v69, v70);
                      uint64_t v136 = (os_log_s *)objc_claimAutoreleasedReturnValue(v135);
                      if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)__int128 buf = 136315138;
                        __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_FAULT,  "%s called with null probabilityOffset",  buf,  0xCu);
                      }

                      id v63 = v147;
                      goto LABEL_41;
                    }

                    id v63 = v147;
                    [v147 doubleValue];
                    uint64_t v73 = 1.0 - v72;
                    [v151 doubleValue];
                    uint64_t v75 = v74;
                    id v76 = [v71 doubleValue];
                    uint64_t v80 = v75 + v79;
                    if (v73 <= v80)
                    {
                      __int128 v84 = 0;
                    }

                    else
                    {
                      __int128 v81 = nplog_obj(v76, v77, v78);
                      __int128 v82 = (os_log_s *)objc_claimAutoreleasedReturnValue(v81);
                      if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)__int128 buf = 138412290;
                        __int128 v159 = v152;
                        _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_INFO,  "Trigger Token fetch for vendor:%@",  buf,  0xCu);
                      }

                      __int128 v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
                      [(id)qword_100117188 setObject:v83 forKey:*(void *)&v152];

                      __int128 v84 = 1;
                    }

                    __int128 v88 = objc_alloc_init(&OBJC_CLASS___NSPProactiveTokenFetchAnalytics);
                    __int128 v89 = v88;
                    if (v88)
                    {
                      -[NSPProactiveTokenFetchAnalytics setStats:](v88, "setStats:", v143);
                      -[NSPProactiveTokenFetchAnalytics setType:](v89, "setType:", @"TokenEventLWM");
                      -[NSPProactiveTokenFetchAnalytics setFromDate:](v89, "setFromDate:", v150);
                      -[NSPProactiveTokenFetchAnalytics setToDate:](v89, "setToDate:", v149);
                      id v63 = v147;
                      -[NSPProactiveTokenFetchAnalytics setTokenFetchTriggered:]( v89,  "setTokenFetchTriggered:",  v73 > v80);
                      -[NSPProactiveTokenFetchAnalytics setVendor:](v89, "setVendor:", *(void *)&v152);
                      -[NSPProxyAnalytics sendAnalytics](v89, "sendAnalytics");
                    }

                    if (v73 > v80)
                    {
LABEL_41:

LABEL_70:
                      __int16 v24 = v139;
LABEL_71:
                      char v120 = (os_log_s *)v141;

                      __int128 v33 = v140;
                      uint32_t v42 = v144;
                      uint64_t v38 = v145;
LABEL_72:

LABEL_73:
LABEL_74:

LABEL_75:
LABEL_76:

                      goto LABEL_77;
                    }
                  }

                  else
                  {
                    __int128 v84 = 0;
                  }

                  uint32_t v42 = v144;
                  uint64_t v38 = v145;
                  p_superclass = &OBJC_CLASS___NSPAuxiliaryAuthInfo.superclass;
                }

                else
                {
                  __int128 v84 = 0;
                }

                LOBYTE(v4_Block_object_dispose(va, 8) = v84 != 0;
              }

              uint64_t v151 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:@"NSPEventsKeyLowerTokenCountProbability"]);
              if (v151)
              {
                __int128 v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSPCoreData getNSPTokenStatsForSingleWindow:startDate:endDate:windowStartTime:windowDuration:statsCategory:]( &OBJC_CLASS___NSPCoreData,  "getNSPTokenStatsForSingleWindow:startDate:endDate:windowStartTime:windowDuration:statsCategory:",  *(void *)&v152,  v38,  v42,  log,  v23,  9LL));
                if (v92)
                {
                  __int128 v148 = v23;
                  uint64_t v137 = v12;
                  __int128 v138 = v8;
                  uint64_t v155 = 0u;
                  uint64_t v156 = 0u;
                  __int128 v153 = 0u;
                  uint64_t v154 = 0u;
                  uint64_t v59 = v92;
                  uint64_t v95 = -[os_log_s countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v153,  v157,  16LL);
                  if (v95)
                  {
                    double v96 = v95;
                    id v97 = *(void *)v154;
                    while (2)
                    {
                      for (CFIndex i = 0LL; i != v96; CFIndex i = (char *)i + 1)
                      {
                        if (*(void *)v154 != v97) {
                          objc_enumerationMutation(v59);
                        }
                        __int16 v99 = *(void *)(*((void *)&v153 + 1) + 8LL * (void)i);
                        if (v99)
                        {
                          char v100 = objc_claimAutoreleasedReturnValue( [p_superclass + 449 getNSPEventsProbability:*(void *)(*((void *)&v153 + 1) + 8 * (void)i) count:a4]);
                          __int128 v103 = (void *)v100;
                          if (v100)
                          {
                            uint64_t v104 = nplog_obj(v100, v101, v102);
                            char v105 = (os_log_s *)objc_claimAutoreleasedReturnValue(v104);
                            if (os_log_type_enabled(v105, OS_LOG_TYPE_INFO))
                            {
                              id v106 = [v148 integerValue];
                              [v103 doubleValue];
                              *(_DWORD *)__int128 buf = 134218754;
                              __int128 v159 = *(double *)&a4;
                              uint64_t v160 = 2048;
                              CFErrorRef v161 = *(double *)&v106;
                              CFErrorRef v162 = 2112;
                              __int128 v163 = v152;
                              id v164 = 2048;
                              id v165 = v107;
                              _os_log_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_INFO,  "Probability of reaching less than %ld tokens in next %ld mins for vendor:%@ is %f",  buf,  0x2Au);
                            }

                            [v103 doubleValue];
                            uint64_t v109 = v108;
                            char v110 = [v151 doubleValue];
                            uint64_t v114 = v113;
                            if (v109 > v113)
                            {
                              char v115 = nplog_obj(v110, v111, v112);
                              __int16 v116 = (os_log_s *)objc_claimAutoreleasedReturnValue(v115);
                              if (os_log_type_enabled(v116, OS_LOG_TYPE_INFO))
                              {
                                *(_DWORD *)__int128 buf = 138412290;
                                __int128 v159 = v152;
                                _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_INFO,  "Trigger Token fetch for vendor:%@",  buf,  0xCu);
                              }

                              id v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
                              [(id)qword_100117188 setObject:v117 forKey:*(void *)&v152];
                            }

                            id v118 = objc_alloc_init(&OBJC_CLASS___NSPProactiveTokenFetchAnalytics);
                            uint64_t v119 = v118;
                            if (v118)
                            {
                              -[NSPProactiveTokenFetchAnalytics setStats:](v118, "setStats:", v99);
                              -[NSPProactiveTokenFetchAnalytics setType:](v119, "setType:", @"TokenCount");
                              -[NSPProactiveTokenFetchAnalytics setFromDate:](v119, "setFromDate:", v150);
                              -[NSPProactiveTokenFetchAnalytics setToDate:](v119, "setToDate:", v149);
                              -[NSPProactiveTokenFetchAnalytics setTokenFetchTriggered:]( v119,  "setTokenFetchTriggered:",  v109 > v114);
                              -[NSPProactiveTokenFetchAnalytics setVendor:](v119, "setVendor:", *(void *)&v152);
                              -[NSPProxyAnalytics sendAnalytics](v119, "sendAnalytics");
                            }

                            if (v109 > v114)
                            {

                              LOBYTE(v4_Block_object_dispose(va, 8) = 1;
                              goto LABEL_69;
                            }

                            LOBYTE(v4_Block_object_dispose(va, 8) = 0;
                            p_superclass = (__objc2_class **)(&OBJC_CLASS___NSPAuxiliaryAuthInfo + 8);
                          }
                        }
                      }

                      double v96 = -[os_log_s countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v153,  v157,  16LL);
                      if (v96) {
                        continue;
                      }
                      break;
                    }
                  }

LABEL_69:
                  uint64_t v12 = v137;
                  uint64_t v8 = v138;
                  id v23 = v148;
                }

                else
                {
                  char v132 = nplog_obj(0LL, v93, v94);
                  uint64_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue(v132);
                  if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)__int128 buf = 136315138;
                    __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_FAULT,  "%s called with null tokenStatsArray",  buf,  0xCu);
                  }

                  uint64_t v59 = 0LL;
                  LOBYTE(v4_Block_object_dispose(va, 8) = 0;
                }

                goto LABEL_70;
              }

              __int128 v130 = nplog_obj(0LL, v90, v91);
              uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(v130);
              __int16 v24 = v139;
              if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)__int128 buf = 136315138;
                __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
                uint64_t v131 = "%s called with null lowTokenCountProbability";
LABEL_110:
                _os_log_fault_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_FAULT, v131, buf, 0xCu);
                goto LABEL_103;
              }

              goto LABEL_103;
            }

            uint64_t v129 = nplog_obj(0LL, v40, v41);
            log = (os_log_t)objc_claimAutoreleasedReturnValue(v129);
            if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT))
            {
LABEL_96:
              LOBYTE(v4_Block_object_dispose(va, 8) = 0;
              char v120 = (os_log_s *)v141;
              goto LABEL_72;
            }

            *(_DWORD *)__int128 buf = 136315138;
            __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
            __int128 v128 = "%s called with null maxDate";
          }

          else
          {
            uint64_t v127 = nplog_obj(v39, v40, v41);
            log = (os_log_t)objc_claimAutoreleasedReturnValue(v127);
            if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_96;
            }
            *(_DWORD *)__int128 buf = 136315138;
            __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
            __int128 v128 = "%s called with null minDate";
          }

          _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, v128, buf, 0xCu);
          goto LABEL_96;
        }

        __int128 v87 = nplog_obj(v18, v19, v20);
        id v23 = (void *)objc_claimAutoreleasedReturnValue(v87);
        if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v23,  OS_LOG_TYPE_ERROR,  "Failed to allocate dictionary for previous triggers",  buf,  2u);
        }
      }

      else
      {
        __int128 v85 = nplog_obj(v13, v14, v15);
        id v23 = (void *)objc_claimAutoreleasedReturnValue(v85);
        if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v23,  OS_LOG_TYPE_INFO,  "Proactive Token Fetch is disabled",  buf,  2u);
        }
      }
    }

    else
    {
      uint64_t v123 = nplog_obj(0LL, v10, v11);
      id v23 = (void *)objc_claimAutoreleasedReturnValue(v123);
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v23,  OS_LOG_TYPE_FAULT,  "%s called with null enabled",  buf,  0xCu);
      }
    }

    LOBYTE(v4_Block_object_dispose(va, 8) = 0;
LABEL_77:

    goto LABEL_78;
  }

  id v122 = nplog_obj(0LL, v6, v7);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v159 = COERCE_DOUBLE("+[NSPCoreData triggerProactiveTokenFetch:lowerTokenCountThreshold:]");
    _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "%s called with null config", buf, 0xCu);
  }

  LOBYTE(v4_Block_object_dispose(va, 8) = 0;
LABEL_78:

  return v48 & 1;
}

void sub_100077D84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100077D9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100077DAC(uint64_t a1)
{
}

void sub_100077DB4(uint64_t a1)
{
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSExpression expressionForKeyPath:]( &OBJC_CLASS___NSExpression,  "expressionForKeyPath:",  @"date"));
    id v52 = v5;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v52, 1LL));
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NSExpression expressionForFunction:arguments:]( &OBJC_CLASS___NSExpression,  "expressionForFunction:arguments:",  @"min:",  v6));

    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSExpression expressionForKeyPath:]( &OBJC_CLASS___NSExpression,  "expressionForKeyPath:",  @"date"));
    dispatch_time_t v51 = v8;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v51, 1LL));
    id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSExpression expressionForFunction:arguments:]( &OBJC_CLASS___NSExpression,  "expressionForFunction:arguments:",  @"max:",  v9));

    int v11 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
    uint64_t v14 = v11;
    if (v11)
    {
      -[NSExpressionDescription setName:](v11, "setName:", @"minDate");
      -[NSExpressionDescription setExpression:](v14, "setExpression:", v7);
      -[NSExpressionDescription setExpressionResultType:](v14, "setExpressionResultType:", 900LL);
      uint64_t v15 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
      uint64_t v18 = v15;
      if (v15)
      {
        -[NSExpressionDescription setName:](v15, "setName:", @"maxDate");
        -[NSExpressionDescription setExpression:](v18, "setExpression:", v10);
        -[NSExpressionDescription setExpressionResultType:](v18, "setExpressionResultType:", 900LL);
        v50[0] = v14;
        v50[1] = v18;
        id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v50, 2LL));
        [v4 setPropertiesToFetch:v19];

        [v4 setResultType:2];
        id v20 = *(void **)(a1 + 32);
        id v45 = 0LL;
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 executeFetchRequest:v4 error:&v45]);
        id v22 = (os_log_s *)v45;
        int v25 = v22;
        if (v21 && (id v22 = (os_log_s *)[v21 count]) != 0)
        {
          uint64_t v26 = objc_claimAutoreleasedReturnValue([v21 firstObject]);
          uint64_t v28 = *(void *)(a1 + 40);
          uint64_t v27 = a1 + 40;
          uint64_t v29 = *(void *)(v28 + 8);
          uint64_t v30 = *(void **)(v29 + 40);
          *(void *)(v29 + 40) = v26;

          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)(*(void *)v27 + 8) + 40) objectForKey:@"minDate"]);
          uint64_t v32 = objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)v27 + 8) + 40) objectForKey:@"maxDate"]);
          id v35 = (void *)v32;
          if (v31 && v32)
          {
            uint64_t v36 = nplog_obj(v32, v33, v34);
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v44 = (char *)objc_claimAutoreleasedReturnValue([v31 description]);
              uint64_t v38 = objc_claimAutoreleasedReturnValue([v35 description]);
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v47 = v44;
              __int16 v48 = 2112;
              uint64_t v49 = v38;
              unsigned int v43 = (void *)v38;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEBUG,  "Min date: %@, Max date: %@",  buf,  0x16u);
            }
          }
        }

        else
        {
          uint64_t v42 = nplog_obj(v22, v23, v24);
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v42);
          if (os_log_type_enabled((os_log_t)v31, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v47 = (const char *)v25;
            _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v31,  OS_LOG_TYPE_ERROR,  "Error fetching min and max dates: %@",  buf,  0xCu);
          }
        }
      }

      else
      {
        uint64_t v41 = nplog_obj(0LL, v16, v17);
        int v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          uint64_t v47 = "+[NSPCoreData getMinMaxDate]_block_invoke";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_FAULT,  "%s called with null maxDateExpressionDescription",  buf,  0xCu);
        }
      }
    }

    else
    {
      uint64_t v40 = nplog_obj(0LL, v12, v13);
      uint64_t v18 = (NSExpressionDescription *)objc_claimAutoreleasedReturnValue(v40);
      if (os_log_type_enabled((os_log_t)v18, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        uint64_t v47 = "+[NSPCoreData getMinMaxDate]_block_invoke";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v18,  OS_LOG_TYPE_FAULT,  "%s called with null minDateExpressionDescription",  buf,  0xCu);
      }
    }
  }

  else
  {
    uint64_t v39 = nplog_obj(0LL, v2, v3);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v39);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v47 = "+[NSPCoreData getMinMaxDate]_block_invoke";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "%s called with null fetchRequest",  buf,  0xCu);
    }
  }
}

void sub_1000782F4(_Unwind_Exception *a1)
{
}

void sub_100078B80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_100078BC0(uint64_t a1)
{
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  if (v4)
  {
    uint64_t v5 = (os_log_s *)*(id *)(a1 + 32);
    uint64_t v7 = v5;
    if ((*(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) & 0x8000000000000000LL) != 0)
    {
      int v25 = v5;
    }

    else
    {
      *(void *)&__int128 v6 = 138412290LL;
      __int128 v28 = v6;
      do
      {
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) components:28 fromDate:v7]);
        objc_msgSend(v8, "setHour:", objc_msgSend(*(id *)(a1 + 56), "hour"));
        objc_msgSend(v8, "setMinute:", objc_msgSend(*(id *)(a1 + 56), "minute"));
        objc_msgSend(v8, "setSecond:", objc_msgSend(*(id *)(a1 + 56), "second"));
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) dateFromComponents:v8]);
        [*(id *)(a1 + 64) doubleValue];
        int v11 = (void *)objc_claimAutoreleasedReturnValue([v9 dateByAddingTimeInterval:v10 * 60.0]);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"(date >= %@) AND (date < %@) AND (vendor == %@) AND (eventType == %ld)",  v9,  v11,  *(void *)(a1 + 72),  *(void *)(a1 + 104),  v28));
        [v4 setPredicate:v12];
        uint64_t v13 = *(void **)(a1 + 80);
        id v31 = 0LL;
        id v14 = [v13 countForFetchRequest:v4 error:&v31];
        id v15 = v31;
        if (v15)
        {
          uint64_t v18 = v15;
          uint64_t v19 = nplog_obj(v15, v16, v17);
          id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v18 localizedDescription]);
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v33 = (const char *)v7;
            __int16 v34 = 2112;
            id v35 = v21;
            _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Error fetching objects for date %@: %@",  buf,  0x16u);
          }
        }

        else
        {
          uint64_t v22 = nplog_obj(0LL, v16, v17);
          uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v29 = *(const char **)(a1 + 72);
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v11 description]);
            *(_DWORD *)__int128 buf = 138413058;
            uint64_t v33 = v29;
            __int16 v34 = 2112;
            id v35 = v30;
            __int16 v36 = 2112;
            uint64_t v37 = v26;
            __int16 v38 = 2048;
            id v39 = v14;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "vendor:%@ Objects with date attribute between %@ and %@: %lu",  buf,  0x2Au);
          }

          uint64_t v24 = *(void **)(*(void *)(*(void *)(a1 + 96) + 8LL) + 40LL);
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v14));
          [v24 addObject:v18];
        }

        int v25 = (os_log_s *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 40) dateByAddingComponents:*(void *)(a1 + 48) toDate:v7 options:0]);
        --*(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL);
        uint64_t v7 = v25;
      }

      while ((*(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) & 0x8000000000000000LL) == 0);
    }
  }

  else
  {
    uint64_t v27 = nplog_obj(0LL, v2, v3);
    int v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v33 = "+[NSPCoreData getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:]_block_invoke";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_FAULT,  "%s called with null fetchRequest",  buf,  0xCu);
    }
  }
}

void sub_10007901C(_Unwind_Exception *a1)
{
}

void sub_100079778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

void sub_1000797F8(uint64_t a1)
{
  uint64_t v2 = (char *)*(id *)(a1 + 32);
  if ((*(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL) & 0x8000000000000000LL) == 0)
  {
    *(void *)&__int128 v3 = 138412290LL;
    __int128 v29 = v3;
    while (1)
    {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) components:540 fromDate:v2]);
      objc_msgSend(v4, "setHour:", objc_msgSend(*(id *)(a1 + 56), "hour"));
      objc_msgSend(v4, "setMinute:", objc_msgSend(*(id *)(a1 + 56), "minute"));
      objc_msgSend(v4, "setSecond:", objc_msgSend(*(id *)(a1 + 56), "second"));
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) dateFromComponents:v4]);
      [*(id *)(a1 + 64) doubleValue];
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 dateByAddingTimeInterval:v6 * 60.0]);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"(date >= %@) AND (date < %@) AND (vendor == %@) AND (eventType != %ld)",  v5,  v7,  *(void *)(a1 + 72),  4LL,  v29));
      [*(id *)(a1 + 80) setPredicate:v8];
      uint64_t v9 = *(void **)(a1 + 88);
      uint64_t v10 = *(void *)(a1 + 80);
      id v34 = 0LL;
      int v11 = (void *)objc_claimAutoreleasedReturnValue([v9 executeFetchRequest:v10 error:&v34]);
      id v12 = v34;
      uint64_t v33 = v12;
      if (v11)
      {
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v11 valueForKey:@"tokenCount"]);
        uint64_t v18 = nplog_obj(v15, v16, v17);
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
        id v20 = v19;
        if (!v15)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            __int16 v36 = "+[NSPCoreData getNSPTokenStatsForSingleWindow:startDate:endDate:windowStartTime:windowDuration:statsCa"
                  "tegory:]_block_invoke";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "%s called with null tokenCount",  buf,  0xCu);
          }

          break;
        }

        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          id v31 = *(const char **)(a1 + 72);
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v5 description]);
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v7 description]);
          id v30 = [v11 count];
          id v25 = [v15 count];
          *(_DWORD *)__int128 buf = 138413314;
          __int16 v36 = v31;
          __int16 v37 = 2112;
          __int16 v38 = v32;
          __int16 v39 = 2112;
          uint64_t v40 = v24;
          __int16 v41 = 2048;
          id v42 = v30;
          __int16 v43 = 2048;
          id v44 = v25;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "vendor:%@ Objects with date attribute between %@ and %@: %lu %lu",  buf,  0x34u);
        }

        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
        unsigned int v22 = [v21 isDateInWeekend:v5];

        if (v22) {
          uint64_t v23 = *(void *)(a1 + 104);
        }
        else {
          uint64_t v23 = *(void *)(a1 + 112);
        }
        [*(id *)(*(void *)(v23 + 8) + 40) addObjectsFromArray:v15];
        if ([v4 weekday] == *(id *)(a1 + 128)) {
          [*(id *)(*(void *)(*(void *)(a1 + 120) + 8) + 40) addObjectsFromArray:v15];
        }
      }

      else
      {
        uint64_t v26 = nplog_obj(v12, v13, v14);
        int v11 = (void *)objc_claimAutoreleasedReturnValue(v26);
        if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
        {
          __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v33 localizedDescription]);
          *(_DWORD *)__int128 buf = 138412546;
          __int16 v36 = v2;
          __int16 v37 = 2112;
          __int16 v38 = v28;
          _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v11,  OS_LOG_TYPE_ERROR,  "Error fetching objects for date %@: %@",  buf,  0x16u);
        }
      }

      uint64_t v27 = (char *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 40) dateByAddingComponents:*(void *)(a1 + 48) toDate:v2 options:0]);
      --*(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL);
      uint64_t v2 = v27;
      if ((*(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL) & 0x8000000000000000LL) != 0) {
        goto LABEL_21;
      }
    }
  }

  uint64_t v27 = v2;
LABEL_21:
}

void sub_100079CD8(_Unwind_Exception *a1)
{
}

void sub_10007A278(uint64_t a1)
{
  uint64_t v2 = -[NSPTokenEvent initWithContext:]( objc_alloc(&OBJC_CLASS___NSPTokenEvent),  "initWithContext:",  *(void *)(a1 + 32));
  uint64_t v5 = v2;
  if (v2)
  {
    -[NSPTokenEvent setDate:](v2, "setDate:", *(void *)(a1 + 40));
    -[NSPTokenEvent setEventType:](v5, "setEventType:", *(unsigned int *)(a1 + 64));
    -[NSPTokenEvent setVendor:](v5, "setVendor:", *(void *)(a1 + 48));
    -[NSPTokenEvent setTokenCount:](v5, "setTokenCount:", *(unsigned int *)(a1 + 56));
    double v6 = *(void **)(a1 + 32);
    id v16 = 0LL;
    unsigned int v7 = [v6 save:&v16];
    uint64_t v8 = (os_log_s *)v16;
    int v11 = v8;
    if (v7)
    {
      uint64_t v12 = nplog_obj(v8, v9, v10);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v18 = (const char *)v5;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Successfully saved NSP Event %@ ", buf, 0xCu);
      }
    }

    else
    {
      uint64_t v15 = nplog_obj(v8, v9, v10);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v18 = (const char *)v5;
        __int16 v19 = 2112;
        id v20 = v11;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Failed to save NSP Event %@ error %@",  buf,  0x16u);
      }
    }
  }

  else
  {
    uint64_t v14 = nplog_obj(0LL, v3, v4);
    int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v18 = "+[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%s called with null event", buf, 0xCu);
    }
  }
}

void sub_10007A4E4(_Unwind_Exception *a1)
{
}

void sub_10007A5F0(uint64_t a1)
{
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"date <= %@",  *(void *)(a1 + 32)));
    [v4 setPredicate:v5];

    double v6 = *(void **)(a1 + 40);
    id v26 = 0LL;
    unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([v6 executeFetchRequest:v4 error:&v26]);
    uint64_t v8 = (os_log_s *)v26;
    int v11 = v8;
    if (v7)
    {
      uint64_t v12 = nplog_obj(v8, v9, v10);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        uint64_t v14 = (const char *)[v7 count];
        uint64_t v15 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 134218242;
        __int128 v29 = v14;
        __int16 v30 = 2112;
        uint64_t v31 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Found %lu events older than %@", buf, 0x16u);
      }

      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      id v16 = v7;
      id v17 = [v16 countByEnumeratingWithState:&v22 objects:v27 count:16];
      if (v17)
      {
        uint64_t v18 = *(void *)v23;
        do
        {
          for (CFIndex i = 0LL; i != v17; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v23 != v18) {
              objc_enumerationMutation(v16);
            }
            [*(id *)(a1 + 40) deleteObject:*(void *)(*((void *)&v22 + 1) + 8 * (void)i)];
          }

          id v17 = [v16 countByEnumeratingWithState:&v22 objects:v27 count:16];
        }

        while (v17);
      }
    }

    else
    {
      uint64_t v21 = nplog_obj(v8, v9, v10);
      id v16 = (id)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        __int128 v29 = (const char *)v11;
        _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v16,  OS_LOG_TYPE_ERROR,  "executeFetchRequest failed %@",  buf,  0xCu);
      }
    }
  }

  else
  {
    uint64_t v20 = nplog_obj(0LL, v2, v3);
    int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      __int128 v29 = "+[NSPCoreData purgeEventsOlderThanDate:]_block_invoke";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "%s called with null fetchRequest",  buf,  0xCu);
    }
  }
}

void sub_10007A914(_Unwind_Exception *a1)
{
}

void sub_10007AAEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10007AB04(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  uint64_t v5 = v2;
  if (v2)
  {
    [v2 setFetchBatchSize:6];
    [v5 setFetchLimit:50];
    double v6 = *(void **)(a1 + 32);
    id v20 = 0LL;
    uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 executeFetchRequest:v5 error:&v20]);
    uint64_t v8 = (os_log_s *)v20;
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v7;

    BOOL v11 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) == 0LL;
    uint64_t v15 = nplog_obj(v12, v13, v14);
    id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    id v17 = v16;
    if (v11)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        __int128 v22 = (const char *)v8;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
      }
    }

    else if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) count];
      *(_DWORD *)__int128 buf = 134217984;
      __int128 v22 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "Found %lu events ", buf, 0xCu);
    }
  }

  else
  {
    uint64_t v19 = nplog_obj(0LL, v3, v4);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      __int128 v22 = "+[NSPCoreData fetchEvents]_block_invoke";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "%s called with null fetchRequest",  buf,  0xCu);
    }
  }
}

void sub_10007B0F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10007B110(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = nplog_obj(a1, a2, a3);
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    id v46 = *(const char **)(a1 + 56);
    *(_DWORD *)__int128 buf = 134217984;
    id v66 = v46;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Fetching %lu events", buf, 0xCu);
  }

  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  if (!v54)
  {
    uint64_t v48 = nplog_obj(0LL, v5, v6);
    id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      goto LABEL_32;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v66 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
    uint64_t v49 = "%s called with null fetchRequest";
    goto LABEL_39;
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (v9)
    {
      __int128 v63 = 0u;
      __int128 v64 = 0u;
      __int128 v61 = 0u;
      __int128 v62 = 0u;
      id v10 = *(id *)(a1 + 32);
      id v11 = [v10 countByEnumeratingWithState:&v61 objects:v72 count:16];
      if (v11)
      {
        uint64_t v12 = *(void *)v62;
        do
        {
          for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v62 != v12) {
              objc_enumerationMutation(v10);
            }
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"vendor == %@",  *(void *)(*((void *)&v61 + 1) + 8LL * (void)i)));
            -[NSMutableArray addObject:](v9, "addObject:", v14);
          }

          id v11 = [v10 countByEnumeratingWithState:&v61 objects:v72 count:16];
        }

        while (v11);
      }

      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSCompoundPredicate orPredicateWithSubpredicates:]( &OBJC_CLASS___NSCompoundPredicate,  "orPredicateWithSubpredicates:",  v9));
      [v54 setPredicate:v15];

      goto LABEL_14;
    }

    uint64_t v51 = nplog_obj(0LL, v7, v8);
    id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      goto LABEL_32;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v66 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
    uint64_t v49 = "%s called with null predicates";
LABEL_39:
    _os_log_fault_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v49, buf, 0xCu);
    goto LABEL_32;
  }

void sub_10007B910( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10007B928(uint64_t a1)
{
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSPTokenEvent fetchRequest](&OBJC_CLASS___NSPTokenEvent, "fetchRequest"));
  if (!v4)
  {
    uint64_t v26 = nplog_obj(0LL, v2, v3);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v31 = "+[NSPCoreData fetchEvents:mostRecent:limit:]_block_invoke";
    uint64_t v27 = "%s called with null fetchRequest";
    goto LABEL_20;
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"vendor == %@",  *(void *)(a1 + 32)));
    [v4 setPredicate:v5];
  }

  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSSortDescriptor sortDescriptorWithKey:ascending:]( &OBJC_CLASS___NSSortDescriptor,  "sortDescriptorWithKey:ascending:",  @"date",  0LL));
    if (v8)
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](&OBJC_CLASS___NSArray, "arrayWithObject:", v8));
      [v4 setSortDescriptors:v9];

      goto LABEL_7;
    }

    uint64_t v28 = nplog_obj(0LL, v6, v7);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v31 = "+[NSPCoreData fetchEvents:mostRecent:limit:]_block_invoke";
    uint64_t v27 = "%s called with null sortDescriptor";
LABEL_20:
    _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_15;
  }

id sub_100080220(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = +[NSPAppRule copyUUIDsForSigningIdentifier:executablePath:]( &OBJC_CLASS___NSPAppRule,  "copyUUIDsForSigningIdentifier:executablePath:",  v3,  0LL);

  return v4;
}

id sub_10008026C(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, int a8)
{
  id v15 = a4;
  id v16 = a7;
  id v17 = a3;
  objc_opt_self(a1);
  uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v15)
  {
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v15));
    -[NSMutableArray addObject:](v18, "addObject:", v19);
  }

  if ((_DWORD)a5)
  {
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition schemeUsingPort:](&OBJC_CLASS___NEPolicyCondition, "schemeUsingPort:", a5));
    -[NSMutableArray addObject:](v18, "addObject:", v20);
  }

  if ((_DWORD)a6 == 17 || (_DWORD)a6 == 6)
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", a6));
    -[NSMutableArray addObject:](v18, "addObject:", v21);
  }

  BOOL v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  -[NSMutableArray addObject:](v18, "addObject:", v22);

  if (a8)
  {
    id v23 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    -[NSMutableArray addObject:](v18, "addObject:", v24);
  }

  if (v16) {
    -[NSMutableArray addObjectsFromArray:](v18, "addObjectsFromArray:", v16);
  }
  id v25 = [[NEPolicy alloc] initWithOrder:a2 result:v17 conditions:v18];

  return v25;
}

NSMutableArray *sub_10008040C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  objc_opt_self(a1);
  uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v35 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
  id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v7)
  {
    id v11 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v7);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  }

  else
  {
    if (![0 count])
    {
      id v24 = -[NSMutableArray copy](v10, "copy");
      id v25 = v10;
      uint64_t v26 = v9;
      uint64_t v27 = v24;
      id v28 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 450LL, v35, 0LL, 0LL, a4, v24, 1);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v28);

      uint64_t v9 = v26;
      id v10 = v25;
      -[NSMutableArray addObject:](v9, "addObject:", v12);
      goto LABEL_18;
    }

    uint64_t v12 = 0LL;
  }

  if ([v12 count])
  {
    __int16 v30 = v12;
    id v31 = v7;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    id obj = v12;
    id v36 = [obj countByEnumeratingWithState:&v37 objects:v41 count:16];
    if (v36)
    {
      id v33 = v8;
      uint64_t v34 = *(void *)v38;
      do
      {
        uint64_t v13 = 0LL;
        do
        {
          if (*(void *)v38 != v34) {
            objc_enumerationMutation(obj);
          }
          uint64_t v14 = *(void **)(*((void *)&v37 + 1) + 8LL * (void)v13);
          id v15 = -[NSMutableArray copy](v10, "copy");
          id v16 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  450LL,  v35,  v14,  0LL,  a4,  v15,  1);
          id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

          -[NSMutableArray addObject:](v9, "addObject:", v17);
          if (v8)
          {
            id v18 = -[NSMutableArray mutableCopy](v10, "mutableCopy");
            uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  v8));
            [v18 addObject:v19];

            uint64_t v20 = v9;
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
            id v22 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  400LL,  v21,  v14,  0LL,  a4,  v18,  1);
            id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);

            uint64_t v9 = v20;
            id v8 = v33;
            -[NSMutableArray addObject:](v9, "addObject:", v23);
          }

          uint64_t v13 = (char *)v13 + 1;
        }

        while (v36 != v13);
        id v36 = [obj countByEnumeratingWithState:&v37 objects:v41 count:16];
      }

      while (v36);
    }

    uint64_t v12 = v30;
    id v7 = v31;
  }

  else
  {

    uint64_t v9 = 0LL;
  }

NSMutableArray *sub_10008072C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v3)
  {
    id v7 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v3);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  }

  else
  {
    if (![0 count])
    {
      id v16 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 450LL, v5, 0LL, 80LL, 6LL, v6, 1);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v16);
      -[NSMutableArray addObject:](v4, "addObject:", v8);
      goto LABEL_16;
    }

    id v8 = 0LL;
  }

  if ([v8 count])
  {
    id v18 = v3;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    id v9 = v8;
    id v10 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v20;
      do
      {
        uint64_t v13 = 0LL;
        do
        {
          if (*(void *)v20 != v12) {
            objc_enumerationMutation(v9);
          }
          id v14 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  450LL,  v5,  *(void **)(*((void *)&v19 + 1) + 8LL * (void)v13),  80LL,  6LL,  v6,  1);
          id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
          -[NSMutableArray addObject:](v4, "addObject:", v15);

          uint64_t v13 = (char *)v13 + 1;
        }

        while (v11 != v13);
        id v11 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }

      while (v11);
    }

    id v3 = v18;
  }

  else
  {

    id v4 = 0LL;
  }

void sub_100080944(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v30 = a2;
  objc_opt_self(a1);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSPPrivacyProxyDNSAgent dnsAgentUUID](&OBJC_CLASS___NSPPrivacyProxyDNSAgent, "dnsAgentUUID"));
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  3LL));
  [v7 setNetworkAgentUUID:v6];
  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  2LL));
  [v8 setNetworkAgentUUID:v6];
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  4LL));
  [v9 setNetworkAgentUUID:v6];
  id v31 = v7;
  v32[0] = v7;
  id v29 = v8;
  v32[1] = v8;
  v32[2] = v9;
  id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v32, 3LL));
  id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:"));
  id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v12 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  -[NSMutableArray addObject:](v11, "addObject:", v13);

  id v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v15 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
  id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  -[NSMutableArray addObject:](v14, "addObject:", v16);

  id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  -[NSMutableArray addObject:](v14, "addObject:", v17);

  if (v5)
  {
    id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v5));
    -[NSMutableArray addObject:](v11, "addObject:", v18);

    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v5));
    -[NSMutableArray addObject:](v14, "addObject:", v19);
  }

  __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition fallbackTraffic](&OBJC_CLASS___NEPolicyCondition, "fallbackTraffic"));
  -[NSMutableArray addObject:](v14, "addObject:", v20);

  id v21 = objc_alloc(&OBJC_CLASS___NEPolicy);
  __int128 v22 = v5;
  id v23 = -[NSMutableArray copy](v11, "copy");
  id v24 = [v21 initWithOrder:450 result:v10 conditions:v23];

  [v30 addObject:v24];
  id v25 = objc_alloc(&OBJC_CLASS___NEPolicy);
  id v26 = -[NSMutableArray copy](v14, "copy");
  id v27 = [v25 initWithOrder:450 result:v10 conditions:v26];

  [v30 addObject:v27];
}

NSMutableArray *sub_100080C54(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  objc_opt_self(a1);
  id v46 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v45 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
  if (v5 || [0 count])
  {
    if (a3) {
      uint64_t v6 = 589824LL;
    }
    else {
      uint64_t v6 = 0x10000LL;
    }
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition clientFlags:](&OBJC_CLASS___NEPolicyCondition, "clientFlags:", v6));
    if (v5)
    {
      id v8 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v5);
      id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      id v10 = [0 countByEnumeratingWithState:&v51 objects:v64 count:16];
      if (v10)
      {
        id v11 = v10;
        id v12 = 0LL;
        uint64_t v13 = *(void *)v52;
        do
        {
          for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v52 != v13) {
              objc_enumerationMutation(0LL);
            }
            uint64_t v15 = *(void *)(*((void *)&v51 + 1) + 8LL * (void)i);
            id v16 = [v9 containsObject:v15];
            if ((v16 & 1) == 0)
            {
              uint64_t v19 = nplog_obj(v16, v17, v18);
              __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)__int128 buf = 138412546;
                id v61 = v5;
                __int16 v62 = 2112;
                uint64_t v63 = v15;
                _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Adding %@ UUID missing from cache %@",  buf,  0x16u);
              }

              if (!v12) {
                id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
              }
              -[NSMutableArray addObject:](v12, "addObject:", v15);
            }
          }

          id v11 = [0 countByEnumeratingWithState:&v51 objects:v64 count:16];
        }

        while (v11);
      }

      else
      {
        id v12 = 0LL;
      }

      if (-[NSMutableArray count](v12, "count"))
      {
        uint64_t v21 = objc_claimAutoreleasedReturnValue([v9 arrayByAddingObjectsFromArray:v12]);

        id v9 = (void *)v21;
      }
    }

    else
    {
      id v9 = 0LL;
    }

    if ([v9 count])
    {
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v22 = v9;
      id v23 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v47,  v59,  16LL);
      if (v23)
      {
        id v24 = v23;
        id v43 = v5;
        uint64_t v25 = *(void *)v48;
        do
        {
          for (j = 0LL; j != v24; j = (char *)j + 1)
          {
            if (*(void *)v48 != v25) {
              objc_enumerationMutation(v22);
            }
            id v27 = *(void **)(*((void *)&v47 + 1) + 8LL * (void)j);
            __int128 v58 = v7;
            id v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v58,  1LL));
            id v29 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  470LL,  v45,  v27,  0LL,  0LL,  v28,  1);
            id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);

            -[NSMutableArray addObject:](v46, "addObject:", v30);
          }

          id v24 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v47,  v59,  16LL);
        }

        while (v24);
        id v9 = v22;
        id v5 = v43;
      }

      else
      {
        id v9 = v22;
      }
    }

    else
    {
      __int128 v22 = v46;
      id v46 = 0LL;
    }
  }

  else
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition clientFlags:](&OBJC_CLASS___NEPolicyCondition, "clientFlags:", 0x200000LL));
    id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 480LL));
    __int128 v57 = v7;
    id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v57, 1LL));
    id v32 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 460LL, v9, 0LL, 0LL, 0LL, v31, 1);
    id v33 = (void *)objc_claimAutoreleasedReturnValue(v32);

    -[NSMutableArray addObject:](v46, "addObject:", v33);
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.WebKit.InAppBrowser"));
    [v44 setNegative:1];
    unsigned int v42 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition clientFlags:](&OBJC_CLASS___NEPolicyCondition, "clientFlags:", 0x10000LL));
    v56[0] = v44;
    v56[1] = v42;
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v56, 2LL));
    id v35 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 470LL, v45, 0LL, 0LL, 0LL, v34, 1);
    id v36 = (void *)objc_claimAutoreleasedReturnValue(v35);

    -[NSMutableArray addObject:](v46, "addObject:", v36);
    __int128 v37 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.WebKit.InAppBrowser"));
    __int128 v38 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition clientFlags:](&OBJC_CLASS___NEPolicyCondition, "clientFlags:", 589824LL));
    v55[0] = v37;
    v55[1] = v38;
    __int128 v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v55, 2LL));
    id v40 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 470LL, v45, 0LL, 0LL, 0LL, v39, 1);
    __int128 v22 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v40);

    -[NSMutableArray addObject:](v46, "addObject:", v22);
  }

  return v46;
}

NSMutableArray *sub_1000811C0(uint64_t a1, void *a2, void *a3, int a4, int a5)
{
  id v9 = a2;
  id v10 = a3;
  objc_opt_self(a1);
  id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v10)
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition accountIdentifier:](&OBJC_CLASS___NEPolicyCondition, "accountIdentifier:", v10));
    -[NSMutableArray addObject:](v12, "addObject:", v13);
  }

  if (a4)
  {
    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
    -[NSMutableArray addObject:](v12, "addObject:", v14);
  }

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
  if (v9)
  {
    id v16 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v9);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    if ([v17 count])
    {
      id v29 = v10;
      id v30 = v9;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      id v28 = v17;
      id v18 = v17;
      id v19 = [v18 countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v32;
        do
        {
          for (CFIndex i = 0LL; i != v20; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v32 != v21) {
              objc_enumerationMutation(v18);
            }
            id v23 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  450LL,  v15,  *(void **)(*((void *)&v31 + 1) + 8LL * (void)i),  0LL,  0LL,  v12,  a5);
            id v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
            -[NSMutableArray addObject:](v11, "addObject:", v24);
          }

          id v20 = [v18 countByEnumeratingWithState:&v31 objects:v35 count:16];
        }

        while (v20);
      }

      id v10 = v29;
      id v9 = v30;
      uint64_t v17 = v28;
    }

    else
    {

      id v11 = 0LL;
    }
  }

  else
  {
    id v25 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 450LL, v15, 0LL, 0LL, 0LL, v12, a5);
    id v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
    -[NSMutableArray addObject:](v11, "addObject:", v26);
  }

  return v11;
}

void sub_100081428(uint64_t a1, void *a2, void *a3, char a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = objc_opt_self(a1);
  p_superclass = &OBJC_CLASS___NSPAuxiliaryAuthInfo.superclass;
  if (v9)
  {
    id v14 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v9);
    id v15 = (id)objc_claimAutoreleasedReturnValue(v14);
    if (!v15)
    {
      uint64_t v18 = nplog_obj(0LL, v16, v17);
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v50 = v12;
        __int16 v51 = 2112;
        id v52 = v9;
LABEL_23:
        id v23 = v19;
        _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "%@ failed to get UUIDs for %@",  buf,  0x16u);
        goto LABEL_21;
      }

NSMutableArray *sub_10008174C( uint64_t a1, unsigned int a2, void *a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  id v13 = a3;
  id v14 = a5;
  id v15 = a6;
  id v273 = a7;
  id v272 = a8;
  uint64_t v264 = objc_opt_self(a1);
  uint64_t v16 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v276 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v14)
  {
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v14));
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 host]);
    if (v18) {
      -[NSMutableArray addObject:](v276, "addObject:", v18);
    }
  }

  if (v15)
  {
    id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v15));
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 host]);
    if (v20) {
      -[NSMutableArray addObject:](v276, "addObject:", v20);
    }
  }

  unsigned int v21 = a2;
  if ((a2 & 0x80) != 0)
  {
    __int128 v270 = v16;
    id v265 = v15;
    id v267 = v14;
    uint64_t v22 = v276;
    objc_opt_self(&OBJC_CLASS___NSPPrivacyProxyPolicySerialization);
    id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    sub_100080944((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v23, 0LL);
    __int128 v304 = 0u;
    __int128 v305 = 0u;
    __int128 v302 = 0u;
    __int128 v303 = 0u;
    id obj = v22;
    id v24 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v302,  buf,  16LL);
    if (v24)
    {
      id v25 = v24;
      uint64_t v26 = *(void *)v303;
      do
      {
        for (CFIndex i = 0LL; i != v25; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v303 != v26) {
            objc_enumerationMutation(obj);
          }
          uint64_t v28 = *(void *)(*((void *)&v302 + 1) + 8LL * (void)i);
          if (-[NSMutableArray count](v23, "count"))
          {
            id v29 = objc_alloc(&OBJC_CLASS___NEPolicy);
            id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 600LL));
            id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v28));
            *(void *)&__int128 v307 = v31;
            __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            *((void *)&v307 + 1) = v32;
            __int128 v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v307,  2LL));
            id v34 = [v29 initWithOrder:421 result:v30 conditions:v33];

            -[NSMutableArray addObject:](v23, "addObject:", v34);
          }
        }

        id v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v302,  buf,  16LL);
      }

      while (v25);
    }

    if (!v23)
    {
      uint64_t v169 = nplog_obj(v35, v36, v37);
      id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v169);
      id v14 = v267;
      id v15 = v265;
      uint64_t v16 = v270;
      if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        goto LABEL_140;
      }
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v264;
      uint64_t v170 = "%@ failed to create ANY DNS policies";
LABEL_98:
      _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v170, buf, 0xCu);
      goto LABEL_140;
    }

    uint64_t v16 = v270;
    -[NSMutableArray addObjectsFromArray:](v270, "addObjectsFromArray:", v23);

    id v14 = v267;
    id v15 = v265;
    unsigned int v21 = a2;
  }

  if ((v21 & 0x100) == 0) {
    goto LABEL_24;
  }
  id v38 = sub_100080C54((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 0LL, 0);
  uint64_t v39 = objc_claimAutoreleasedReturnValue(v38);
  if (!v39)
  {
    uint64_t v171 = nplog_obj(0LL, v40, v41);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v171);
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v264;
    uint64_t v170 = "%@ failed to create ANY KNOWN TRACKER policies";
    goto LABEL_98;
  }

  id v42 = (void *)v39;
  -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v39);

LABEL_24:
  if ((v21 & 0x40) == 0)
  {
    int v43 = (v21 >> 8) & 1;
    if ((v21 & 0x20000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_39;
  }

  __int128 v44 = sub_10008072C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 0LL);
  uint64_t v45 = objc_claimAutoreleasedReturnValue(v44);
  if (!v45)
  {
    uint64_t v172 = nplog_obj(0LL, v46, v47);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v172);
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v264;
    uint64_t v170 = "%@ failed to create ANY UNENCRYPTED policies";
    goto LABEL_98;
  }

  __int128 v48 = (void *)v45;
  -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v45);

  LOBYTE(v43) = 1;
  if ((v21 & 0x20000) == 0)
  {
LABEL_26:
    if ((v21 & 0x400) == 0) {
      goto LABEL_27;
    }
    goto LABEL_43;
  }

LABEL_140:
    goto LABEL_141;
  }

  id v59 = v15;
  -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v55);
  id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
  id v61 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition domain:]( &OBJC_CLASS___NEPolicyCondition,  "domain:",  @"use-application-dns.net"));
  __int128 v301 = v61;
  __int16 v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v301, 1LL));
  id v63 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 410LL, v60, 0LL, 0LL, 0LL, v62, 0);
  __int128 v64 = (void *)objc_claimAutoreleasedReturnValue(v63);

  if (!v64)
  {
    uint64_t v242 = nplog_obj(v65, v66, v67);
    __int128 v243 = (os_log_s *)objc_claimAutoreleasedReturnValue(v242);
    id v15 = v59;
    if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v264;
      _os_log_error_impl( (void *)&_mh_execute_header,  v243,  OS_LOG_TYPE_ERROR,  "%@ failed to create App policy",  buf,  0xCu);
    }

    goto LABEL_140;
  }

  -[NSMutableArray addObject:](v16, "addObject:", v64);

  LOBYTE(v43) = 1;
  id v15 = v59;
  unsigned int v21 = a2;
  if ((a2 & 0x400) == 0)
  {
LABEL_27:
    if ((v21 & 0x10000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_46;
  }

LABEL_43:
  unsigned int v68 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.news",  @"com.apple.news.urlresolution",  0,  1);
  __int16 v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
  if (v69) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v69);
  }

  if ((v21 & 0x10000) == 0)
  {
LABEL_28:
    if ((v21 & 0x800) == 0) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }

  -[NSPConfigurationStats setSafariPrivateUnencryptedEnabled:](v15, "setSafariPrivateUnencryptedEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x80000) == 0)
  {
LABEL_18:
    if ((v12 & 0x100000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }

      id v13 = v231;

      uint64_t v93 = nplog_obj(v90, v91, v92);
      id v94 = (void *)objc_claimAutoreleasedReturnValue(v93);
      if (!os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_ERROR))
      {
LABEL_44:

        uint64_t v51 = 0LL;
        goto LABEL_45;
      }

      *(_WORD *)__int128 buf = 0;
      double v96 = "Failed to parse origin name key";
      goto LABEL_49;
    }

    __int128 v54 = v42;
    if (*(_WORD *)(v42 + 1) == 0x2000)
    {
      if (*(_WORD *)(v42 + 35) == 256)
      {
        if (*(_WORD *)(v42 + 37) == 256)
        {
          *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = *v42;
          *(_WORD *)(a1 + 12) = *(_WORD *)(v42 + 1);
          *(_WORD *)(a1 + 14) = *(_WORD *)(v42 + 35);
          *(_WORD *)(a1 + 16) = *(_WORD *)(v42 + 37);
          id v55 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v42 + 3,  32LL);
          objc_setProperty_atomic((id)a1, v56, v55, 40LL);

          if (objc_getProperty((id)a1, v57, 72LL, 1)) {
            goto LABEL_29;
          }
          __int16 v99 = (__SecKey *)sub_1000ABE24((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenClientState);
          if (v99)
          {
            uint64_t v102 = SecKeyCopyPublicKey(v99);
            if (v102)
            {
              id v105 = v102;
              *(void *)&__int128 v246 = kSecAttrKeyType;
              *((void *)&v246 + 1) = kSecAttrKeySizeInBits;
              *(void *)__int128 buf = kSecAttrKeyTypeECSECPrimeRandom;
              *(void *)&uint8_t buf[8] = &off_100103980;
              uint64_t v106 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  buf,  &v246,  2LL));
              RandomKey = SecKeyCreateRandomKey(v106, 0LL);
              if (RandomKey)
              {
                id v222 = v106;
                uint64_t v108 = RandomKey;
                uint64_t v109 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
                id v241 = __rev16(*(unsigned __int16 *)(a1 + 10));
                -[NSMutableData appendBytes:length:](v109, "appendBytes:length:", &v241, 2LL);
                -[NSMutableData appendBytes:length:](v109, "appendBytes:length:", "ClientBlind", 11LL);
                v235 = 0LL;
                __src = v108;
                char v110 = +[CKPATKeyBlinding blindPublicKey:withPrivateKey:context:error:]( &OBJC_CLASS___CKPATKeyBlinding,  "blindPublicKey:withPrivateKey:context:error:",  v105,  v108,  v109,  &v235);
                v229 = v235;
                CFRelease(v105);
                if (v110)
                {
                  id v114 = (void *)objc_claimAutoreleasedReturnValue( +[CKPATKeyBlinding compressedRepresentationFromSecKey:]( &OBJC_CLASS___CKPATKeyBlinding,  "compressedRepresentationFromSecKey:",  v110));
                  objc_setProperty_atomic((id)a1, v115, v114, 72LL);

                  CFRelease(v110);
                  if (objc_getProperty((id)a1, v116, 72LL, 1))
                  {
                    *(void *)(a1 + 8_Block_object_dispose(va, 8) = __src;

LABEL_29:
                    -[NSMutableData appendData:](v38, "appendData:", objc_getProperty((id)a1, v58, 72LL, 1));
                    *(_OWORD *)__int128 buf = 0u;
                    __int128 v243 = 0u;
                    CC_SHA256([v40 bytes], (CC_LONG)objc_msgSend(v40, "length"), buf);
                    id v59 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  buf,  32LL);
                    objc_setProperty_atomic((id)a1, v60, v59, 48LL);

                    -[NSMutableData appendData:](v38, "appendData:", objc_getProperty((id)a1, v61, 48LL, 1));
                    id v63 = objc_getProperty((id)a1, v62, 40LL, 1);
                    if (!v63)
                    {
                      uint64_t v210 = nplog_obj(0LL, v64, v65);
                      id v211 = (os_log_s *)objc_claimAutoreleasedReturnValue(v210);
                      if (os_log_type_enabled(v211, OS_LOG_TYPE_FAULT))
                      {
                        LODWORD(v246) = 136315138;
                        *(void *)((char *)&v246 + 4) = "-[NSPPrivateAccessTokenRequest encryptTokenRequest]";
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_FAULT,  "%s called with null issuerEncapKey",  (uint8_t *)&v246,  0xCu);
                      }

                      uint64_t v80 = 0LL;
                      id v13 = v231;
                      goto LABEL_34;
                    }

                    uint64_t v66 = v63;
                    uint64_t v67 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
                    __srcd = (void *)cchpke_params_sizeof_kem_enc();
                    uint64_t v228 = calloc(1uLL, 0x60uLL);
                    unsigned int v68 = calloc(1uLL, (size_t)__srcd);
                    *(_DWORD *)__int128 v245 = 0;
                    __int16 v69 = ccrng(v245);
                    id v221 = v66;
                    uint64_t v70 = [v66 bytes];
                    id v71 = v68;
                    uint64_t v218 = (void *)v67;
                    uint64_t v72 = cchpke_initiator_setup(v228, v67, v69, 32LL, v70, 12LL, "TokenRequest", __srcd, v68);
                    uint64_t v73 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v71,  __srcd);
                    objc_setProperty_atomic((id)a1, v74, v73, 104LL);

                    free(v71);
                    if (v72)
                    {
                      uint64_t v78 = nplog_obj(v75, v76, v77);
                      id v79 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);
                      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                      {
                        LODWORD(v246) = 67109120;
                        DWORD1(v246) = v72;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_ERROR,  "Setup error: %d",  (uint8_t *)&v246,  8u);
                      }

                      free(v228);
                      id v13 = v231;
                      uint64_t v80 = v221;
LABEL_34:

LABEL_78:
                      uint64_t v179 = nplog_obj(v81, v82, v83);
                      id v94 = (void *)objc_claimAutoreleasedReturnValue(v179);
                      if (!os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_44;
                      }
                      LOWORD(v246) = 0;
                      double v96 = "Failed to encrypt the token request";
                      goto LABEL_80;
                    }

                    *(void *)(a1 + 96) = v228;
                    id v119 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
                    uint64_t v240 = *(_BYTE *)(a1 + 8);
                    -[NSMutableData appendBytes:length:](v119, "appendBytes:length:", &v240, 1LL);
                    LOWORD(v235) = *(_WORD *)(a1 + 12);
                    -[NSMutableData appendBytes:length:](v119, "appendBytes:length:", &v235, 2LL);
                    id v241 = *(_WORD *)(a1 + 14);
                    -[NSMutableData appendBytes:length:](v119, "appendBytes:length:", &v241, 2LL);
                    int v239 = *(_WORD *)(a1 + 16);
                    -[NSMutableData appendBytes:length:](v119, "appendBytes:length:", &v239, 2LL);
                    uint64_t v238 = __rev16(*(unsigned __int16 *)(a1 + 10));
                    id v230 = v119;
                    -[NSMutableData appendBytes:length:](v119, "appendBytes:length:", &v238, 2LL);
                    -[NSMutableData appendData:](v119, "appendData:", objc_getProperty((id)a1, v120, 72LL, 1));
                    -[NSMutableData appendData:](v119, "appendData:", objc_getProperty((id)a1, v121, 48LL, 1));
                    id v122 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
                    id v237 = *(_BYTE *)(a1 + 9);
                    -[NSMutableData appendBytes:length:](v122, "appendBytes:length:", &v237, 1LL);
                    -[NSMutableData appendData:](v122, "appendData:", objc_getProperty((id)a1, v123, 32LL, 1));
                    id v217 = objc_getProperty((id)a1, v124, 56LL, 1);
                    __srca = (const char *)[v217 UTF8String];
                    uint64_t v125 = strlen(__srca);
                    id v126 = v125;
                    uint64_t v127 = -(int)v125 & 0x1FLL;
                    if (!v125) {
                      uint64_t v127 = 32LL;
                    }
                    __int128 v128 = v127 + v125;
                    uint64_t v129 = calloc(1uLL, v127 + v125);
                    memcpy(v129, __srca, v126);
                    uint64_t v236 = bswap32(v128) >> 16;
                    -[NSMutableData appendBytes:length:](v122, "appendBytes:length:", &v236, 2LL);
                    -[NSMutableData appendBytes:length:](v122, "appendBytes:length:", v129, v128);
                    free(v129);
                    __srcb = calloc(1uLL, -[NSMutableData length](v122, "length"));
                    id v130 = cchpke_params_sizeof_aead_tag(v218);
                    uint64_t v219 = calloc(1uLL, v130);
                    uint64_t v131 = cchpke_initiator_encrypt( *(void *)(a1 + 96),  -[NSMutableData length](v230, "length"),  -[NSMutableData bytes](v230, "bytes"),  -[NSMutableData length](v122, "length"),  -[NSMutableData bytes](v122, "bytes"),  __srcb,  v130,  v219);
                    if ((_DWORD)v131)
                    {
                      id v134 = v131;
                      SCDynamicStoreRef v135 = nplog_obj(v131, v132, v133);
                      uint64_t v136 = (os_log_s *)objc_claimAutoreleasedReturnValue(v135);
                      id v13 = v231;
                      if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                      {
                        LODWORD(v246) = 67109120;
                        DWORD1(v246) = v134;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_ERROR,  "Encrypt error: %d",  (uint8_t *)&v246,  8u);
                      }

                      free(v219);
                      free(__srcb);
                      id v137 = 0;
                      __int128 v138 = &AnalyticsSendEventLazy_ptr;
                    }

                    else
                    {
                      uint64_t v142 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
                      -[NSMutableData appendData:](v142, "appendData:", objc_getProperty((id)a1, v143, 104LL, 1));
                      -[NSMutableData appendBytes:length:]( v142,  "appendBytes:length:",  __srcb,  -[NSMutableData length](v122, "length"));
                      -[NSMutableData appendBytes:length:](v142, "appendBytes:length:", v219, v130);
                      free(v219);
                      free(__srcb);
                      objc_setProperty_atomic((id)a1, v144, v142, 64LL);
                      id Property = objc_getProperty((id)a1, v145, 64LL, 1);
                      __srcc = Property != 0LL;
                      id v13 = v231;
                      if (!Property)
                      {
                        id v220 = v142;
                        uint64_t v149 = nplog_obj(0LL, v147, v148);
                        uint64_t v150 = (os_log_s *)objc_claimAutoreleasedReturnValue(v149);
                        if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(v246) = 0;
                          _os_log_error_impl( (void *)&_mh_execute_header,  v150,  OS_LOG_TYPE_ERROR,  "Error creating encrypted token request",  (uint8_t *)&v246,  2u);
                        }

                        uint64_t v142 = v220;
                      }

                      __int128 v138 = &AnalyticsSendEventLazy_ptr;
                      id v137 = __srcc;
                    }

                    if (!v137) {
                      goto LABEL_78;
                    }
                    int v239 = bswap32(objc_msgSend(objc_getProperty((id)a1, v82, 64, 1), "length")) >> 16;
                    -[NSMutableData appendBytes:length:](v38, "appendBytes:length:", &v239, 2LL);
                    -[NSMutableData appendData:](v38, "appendData:", objc_getProperty((id)a1, v151, 64LL, 1));
                    if (objc_getProperty((id)a1, v152, 72LL, 1))
                    {
                      if (objc_getProperty((id)a1, v153, 48LL, 1))
                      {
                        __int128 v157 = objc_getProperty((id)a1, v155, 64LL, 1);
                        if (v157)
                        {
                          if (*(void *)(a1 + 88))
                          {
                            uint64_t v160 = sub_1000ABE24((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenClientState);
                            if (v160)
                            {
                              __int128 v163 = v160;
                              id v164 = v138;
                              id v165 = objc_alloc_init((Class)v138[113]);
                              LOWORD(v235) = __rev16(*(unsigned __int16 *)(a1 + 10));
                              [v165 appendBytes:&v235 length:2];
                              objc_msgSend(v165, "appendData:", objc_getProperty((id)a1, v166, 72, 1));
                              objc_msgSend(v165, "appendData:", objc_getProperty((id)a1, v167, 48, 1));
                              id v241 = bswap32(objc_msgSend( objc_getProperty((id)a1, v168, 64, 1),  "length")) >> 16;
                              [v165 appendBytes:&v241 length:2];
                              objc_msgSend(v165, "appendData:", objc_getProperty((id)a1, v169, 64, 1));
                              uint64_t v170 = objc_alloc_init((Class)v164[113]);
                              [v170 appendBytes:&v235 length:2];
                              [v170 appendBytes:"ClientBlind" length:11];
                              uint64_t v171 = *(void *)(a1 + 88);
                              *(void *)__int128 v245 = 0LL;
                              uint64_t v172 = (void *)objc_claimAutoreleasedReturnValue( +[CKPATKeyBlinding blindSignMessage:blindedBy:withKey:context:error:]( &OBJC_CLASS___CKPATKeyBlinding,  "blindSignMessage:blindedBy:withKey:context:error:",  v165,  v171,  v163,  v170,  v245));
                              uint64_t v173 = *(id *)v245;
                              objc_setProperty_atomic((id)a1, v174, v172, 80LL);

                              if (objc_getProperty((id)a1, v175, 80LL, 1))
                              {

                                -[NSMutableData appendData:]( v38,  "appendData:",  objc_getProperty((id)a1, v178, 80LL, 1));
                                id v13 = v231;
                                goto LABEL_20;
                              }

                              uint64_t v198 = nplog_obj(0LL, v176, v177);
                              uint64_t v199 = (os_log_s *)objc_claimAutoreleasedReturnValue(v198);
                              if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
                              {
                                LODWORD(v246) = 138412290;
                                *(void *)((char *)&v246 + 4) = v173;
                                _os_log_error_impl( (void *)&_mh_execute_header,  v199,  OS_LOG_TYPE_ERROR,  "generate signature: SecKeyCopyExternalRepresentation failed: %@",  (uint8_t *)&v246,  0xCu);
                              }

                              id v13 = v231;
LABEL_97:
                              v200 = nplog_obj(v192, v193, v194);
                              id v94 = (void *)objc_claimAutoreleasedReturnValue(v200);
                              if (!os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_ERROR)) {
                                goto LABEL_44;
                              }
                              LOWORD(v246) = 0;
                              double v96 = "Failed to generate the request signature";
LABEL_80:
                              id v97 = (uint8_t *)&v246;
                              goto LABEL_50;
                            }

                            id v190 = nplog_obj(0LL, v161, v162);
                            uint64_t v191 = (os_log_s *)objc_claimAutoreleasedReturnValue(v190);
                            if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(v246) = 0;
                              _os_log_error_impl( (void *)&_mh_execute_header,  v191,  OS_LOG_TYPE_ERROR,  "generate signature: Failed to access stored client key",  (uint8_t *)&v246,  2u);
                            }

LABEL_49:
  uint64_t v72 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.exposurenotification.sensitive",  1,  1);
  uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
  if (v73) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v73);
  }

  if ((v21 & 0x1000) == 0)
  {
LABEL_30:
    if ((v21 & 0x4000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_55;
  }

  -[NSPConfigurationStats setDnsEnabled:](v15, "setDnsEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x100) == 0)
  {
LABEL_24:
    if ((v12 & 0x200) == 0) {
      goto LABEL_25;
    }
    goto LABEL_51;
  }

LABEL_55:
  id v76 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.dprivacyd.upload",  1,  0);
  id v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
  if (v77) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v77);
  }

  if ((v21 & 0x8000) == 0)
  {
LABEL_32:
    if ((v21 & 0x400000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_61;
  }

  return v29;
}

  -[NSPConfigurationStats setAppleCertificatesEnabled:](v15, "setAppleCertificatesEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x2000) == 0)
  {
LABEL_30:
    if ((v12 & 0x4000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_57;
  }

LABEL_64:
  __int128 v82 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.appstored.skadnetwork.crowdanonymity",  1,  0);
  __int128 v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
  if (v83) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v83);
  }

  if ((v21 & 0x1000000) == 0)
  {
LABEL_35:
    if ((v21 & 0x2000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_70;
  }

LABEL_67:
  __int128 v84 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.Passwords.PRIconFetching",  1,  0);
  __int128 v85 = (void *)objc_claimAutoreleasedReturnValue(v84);
  if (v85) {
    -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v85);
  }

  if ((v21 & 0x2000000) != 0)
  {
LABEL_70:
    __int128 v86 = sub_1000811C0( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  0LL,  @"com.apple.mis.LaunchWarningDetails",  1,  0);
    __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(v86);
    if (v87) {
      -[NSMutableArray addObjectsFromArray:](v16, "addObjectsFromArray:", v87);
    }
  }

    goto LABEL_16;
  }

  id v8 = (unint64_t)[v4 length];
  id v9 = (unsigned __int16 *)[v7 bytes];
  if (!v8)
  {
    __int128 v82 = nplog_obj(v9, v10, v11);
    uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
    if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      v115[0] = "-[NSPPrivateAccessTokenChallenge initWithData:]";
      __int128 v81 = "%s called with null remainingLength";
      goto LABEL_83;
    }

    goto LABEL_67;
  }

  uint64_t v12 = v9;
  if (!v9)
  {
    __int128 v83 = nplog_obj(0LL, v10, v11);
    uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
    if (!os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
      goto LABEL_67;
    }
    *(_DWORD *)__int128 buf = 136315138;
    v115[0] = "-[NSPPrivateAccessTokenChallenge initWithData:]";
    __int128 v81 = "%s called with null cursor";
LABEL_83:
    _os_log_fault_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_FAULT, v81, buf, 0xCu);
    goto LABEL_67;
  }

  v113.receiver = self;
  v113.super_class = (Class)&OBJC_CLASS___NSPPrivateAccessTokenChallenge;
  id v13 = -[NSPPrivateAccessTokenChallenge init](&v113, "init");
  if (!v13)
  {
    __int128 v84 = nplog_obj(0LL, v14, v15);
    self = (NSPPrivateAccessTokenChallenge *)objc_claimAutoreleasedReturnValue(v84);
    if (os_log_type_enabled((os_log_t)self, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)self, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
    }

    goto LABEL_16;
  }

  uint64_t v16 = v13;
  if (v8 <= 1)
  {
    uint64_t v17 = nplog_obj(v13, v14, v15);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      id v19 = "Invalid challenge length";
LABEL_8:
      uint64_t v20 = v18;
      unsigned int v21 = 2;
LABEL_32:
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
      goto LABEL_14;
    }

    goto LABEL_14;
  }

  v13->_tokenType = bswap32(*v12) >> 16;
  uint64_t v22 = -[NSPPrivateAccessTokenChallenge isSupportedTokenType](v13, "isSupportedTokenType");
  if (!v22)
  {
    uint64_t v26 = nplog_obj(v22, v23, v24);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    uint64_t v46 = -[NSPPrivateAccessTokenChallenge tokenType](v16, "tokenType");
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v115[0]) = v46;
    id v19 = "Unsupported token type %u";
    goto LABEL_31;
  }

  if ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    id v25 = nplog_obj(v22, v23, v24);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      id v19 = "Invalid challenge length";
      goto LABEL_8;
    }

LABEL_136:
  id v241 = v16;
LABEL_142:

  return v241;
}

uint64_t sub_1000833A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v4 = 0LL;
  if ([v3 conditionsCount])
  {
    unint64_t v5 = 0LL;
    do
    {
      switch([v3 conditionsAtIndex:v5])
      {
        case 1u:
          uint64_t v4 = v4 | 1;
          break;
        case 2u:
          uint64_t v4 = v4 | 2;
          break;
        case 3u:
          uint64_t v4 = v4 | 4;
          break;
        case 4u:
          uint64_t v4 = v4 | 8;
          break;
        case 5u:
          uint64_t v4 = v4 | 0x10;
          break;
        case 6u:
          uint64_t v4 = v4 | 0x20;
          break;
        case 7u:
          uint64_t v4 = v4 | 0x40;
          break;
        case 8u:
          uint64_t v4 = v4 | 0x80;
          break;
        case 9u:
          uint64_t v4 = v4 | 0x100;
          break;
        case 0xAu:
          uint64_t v4 = v4 | 0x200;
          break;
        case 0xBu:
          uint64_t v4 = v4 | 0x400;
          break;
        case 0xCu:
          uint64_t v4 = v4 | 0x800;
          break;
        case 0xDu:
          uint64_t v4 = v4 | 0x1000;
          break;
        case 0xEu:
          uint64_t v4 = v4 | 0x2000;
          break;
        case 0xFu:
          uint64_t v4 = v4 | 0x4000;
          break;
        case 0x10u:
          uint64_t v4 = v4 | 0x8000;
          break;
        case 0x11u:
          uint64_t v4 = v4 | 0x10000;
          break;
        case 0x12u:
          uint64_t v4 = v4 | 0x20000;
          break;
        case 0x13u:
          uint64_t v4 = v4 | 0x40000;
          break;
        case 0x14u:
          uint64_t v4 = v4 | 0x80000;
          break;
        case 0x15u:
          uint64_t v4 = v4 | 0x100000;
          break;
        case 0x16u:
          uint64_t v4 = v4 | 0x200000;
          break;
        case 0x17u:
          uint64_t v4 = v4 | 0x400000;
          break;
        case 0x18u:
          uint64_t v4 = v4 | 0x800000;
          break;
        case 0x19u:
          uint64_t v4 = v4 | 0x1000000;
          break;
        case 0x1Au:
          uint64_t v4 = v4 | 0x2000000;
          break;
        default:
          break;
      }

      ++v5;
    }

    while (v5 < (unint64_t)[v3 conditionsCount]);
  }

  return v4;
}

id sub_100083508(uint64_t a1, void *a2, void *a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  id v15 = a2;
  id v16 = a3;
  id v17 = a5;
  id v18 = a6;
  id v19 = a7;
  id v20 = a8;
  objc_opt_self(a1);
  if (v15 && [v15 conditionsCount])
  {
    unsigned int v21 = sub_1000833A8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v15);
    uint64_t v22 = sub_10008174C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v21, v16, a4, v17, v18, v19, v20);
    id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  }

  else
  {
    id v23 = 0LL;
  }

  return v23;
}

NSMutableArray *sub_1000835FC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  objc_opt_self(a1);
  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  5LL,  v7));
  [v8 setNetworkAgentUUID:v5];

  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domainFilter:](&OBJC_CLASS___NEPolicyCondition, "domainFilter:", a3));
  v24[0] = v9;
  id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  v24[1] = v10;
  id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v24, 2LL));

  id v12 = objc_alloc(&OBJC_CLASS___NEPolicy);
  id v23 = v8;
  id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v23, 1LL));
  id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v13));
  id v15 = [v12 initWithOrder:560 result:v14 conditions:v11];

  -[NSMutableArray addObject:](v6, "addObject:", v15);
  id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  6LL,  v7));
  [v16 setNetworkAgentUUID:v7];
  id v17 = objc_alloc(&OBJC_CLASS___NEPolicy);
  uint64_t v22 = v16;
  id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v22, 1LL));
  id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v18));
  id v20 = [v17 initWithOrder:561 result:v19 conditions:v11];

  -[NSMutableArray addObject:](v6, "addObject:", v20);
  return v6;
}

NSMutableArray *sub_100083840(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  id v7 = 0LL;
  if (v5 && v6)
  {
    uint64_t v8 = objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
    id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:forInterfaceName:",  5LL,  v8,  v6));
    [v24 setNetworkAgentUUID:v5];
    -[NSMutableArray addObject:](v23, "addObject:", v24);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v23));
    id v9 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    uint64_t v26 = v10;
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v26, 1LL));
    id v12 = [v9 initWithOrder:630 result:v22 conditions:v11];

    -[NSMutableArray addObject:](v7, "addObject:", v12);
    id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    unsigned int v21 = (void *)v8;
    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:forInterfaceName:",  6LL,  v8,  v6));
    [v14 setNetworkAgentUUID:v8];
    -[NSMutableArray addObject:](v13, "addObject:", v14);
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v13));
    id v16 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    id v25 = v17;
    id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v25, 1LL));
    id v19 = [v16 initWithOrder:631 result:v15 conditions:v18];

    -[NSMutableArray addObject:](v7, "addObject:", v19);
  }

  return v7;
}

NSMutableArray *sub_100083AD8(uint64_t a1, int a2, int a3, void *a4, void *a5)
{
  id v9 = a4;
  id v10 = a5;
  objc_opt_self(a1);
  if ((a2 & 1) != 0 || (a3 & 1) != 0 || [v9 count] || objc_msgSend(v10, "length"))
  {
    id v74 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
    id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (a2)
    {
      id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  3LL));
      [v13 setNetworkAgentUUID:v11];
      -[NSMutableArray addObject:](v12, "addObject:", v13);
    }

    uint64_t v73 = v10;
    int v66 = a3;
    if (a3)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  2LL));
      [v14 setNetworkAgentUUID:v11];
      -[NSMutableArray addObject:](v12, "addObject:", v14);
    }

    __int128 v81 = 0u;
    __int128 v82 = 0u;
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    id v72 = v9;
    id v15 = v9;
    id v16 = [v15 countByEnumeratingWithState:&v79 objects:v88 count:16];
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v80;
      do
      {
        for (CFIndex i = 0LL; i != v17; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v80 != v18) {
            objc_enumerationMutation(v15);
          }
          id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  6LL,  *(void *)(*((void *)&v79 + 1) + 8LL * (void)i)));
          [v20 setNetworkAgentUUID:v11];
          -[NSMutableArray addObject:](v12, "addObject:", v20);
        }

        id v17 = [v15 countByEnumeratingWithState:&v79 objects:v88 count:16];
      }

      while (v17);
    }

    uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v12));
    id v22 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v87[0] = v23;
    id v24 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
    id v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
    v87[1] = v25;
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v87, 2LL));
    uint64_t v70 = (void *)v21;
    id v27 = [v22 initWithOrder:610 result:v21 conditions:v26];

    -[NSMutableArray addObject:](v74, "addObject:", v27);
    uint64_t v28 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);

    if (a2)
    {
      id v29 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  3LL));
      id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSPPrivacyProxyDNSAgent dnsAgentUUID](&OBJC_CLASS___NSPPrivacyProxyDNSAgent, "dnsAgentUUID"));
      [v29 setNetworkAgentUUID:v30];

      -[NSMutableArray addObject:](v28, "addObject:", v29);
    }

    if (v66)
    {
      id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  2LL));
      __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSPPrivacyProxyDNSAgent dnsAgentUUID](&OBJC_CLASS___NSPPrivacyProxyDNSAgent, "dnsAgentUUID"));
      [v31 setNetworkAgentUUID:v32];

      -[NSMutableArray addObject:](v28, "addObject:", v31);
    }

    __int128 v77 = 0u;
    __int128 v78 = 0u;
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    id v33 = v15;
    id v34 = [v33 countByEnumeratingWithState:&v75 objects:v86 count:16];
    if (v34)
    {
      id v35 = v34;
      uint64_t v36 = *(void *)v76;
      do
      {
        for (j = 0LL; j != v35; j = (char *)j + 1)
        {
          if (*(void *)v76 != v36) {
            objc_enumerationMutation(v33);
          }
          id v38 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  6LL,  *(void *)(*((void *)&v75 + 1) + 8LL * (void)j)));
          uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSPPrivacyProxyDNSAgent dnsAgentUUID](&OBJC_CLASS___NSPPrivacyProxyDNSAgent, "dnsAgentUUID"));
          [v38 setNetworkAgentUUID:v39];

          -[NSMutableArray addObject:](v28, "addObject:", v38);
        }

        id v35 = [v33 countByEnumeratingWithState:&v75 objects:v86 count:16];
      }

      while (v35);
    }

    uint64_t v40 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v28));
    id v41 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v42 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v85[0] = v42;
    id v43 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
    __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
    v85[1] = v44;
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v85, 2LL));
    id v71 = (void *)v40;
    id v46 = [v41 initWithOrder:610 result:v40 conditions:v45];

    uint64_t v47 = v74;
    -[NSMutableArray addObject:](v74, "addObject:", v46);
    id v10 = v73;
    if ([v73 length])
    {
      uint64_t v65 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  3LL));
      [v67 setNetworkAgentUUID:v11];
      -[NSMutableArray addObject:](v65, "addObject:", v67);
      __int128 v48 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v65));
      id v68 = objc_alloc(&OBJC_CLASS___NEPolicy);
      __int128 v64 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v84[0] = v64;
      id v49 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
      v84[1] = v50;
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v73));
      v84[2] = v51;
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v84, 3LL));
      id v69 = [v68 initWithOrder:610 result:v48 conditions:v52];

      -[NSMutableArray addObject:](v74, "addObject:", v69);
      __int128 v53 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v54 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  3LL));
      id v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSPPrivacyProxyDNSAgent dnsAgentUUID](&OBJC_CLASS___NSPPrivacyProxyDNSAgent, "dnsAgentUUID"));
      [v54 setNetworkAgentUUID:v55];

      -[NSMutableArray addObject:](v53, "addObject:", v54);
      uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v53));
      id v57 = objc_alloc(&OBJC_CLASS___NEPolicy);
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v83[0] = v58;
      id v59 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", getuid());
      id v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
      v83[1] = v60;
      id v61 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v73));
      id v83[2] = v61;
      __int16 v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v83, 3LL));
      id v46 = [v57 initWithOrder:610 result:v56 conditions:v62];

      uint64_t v47 = v74;
      -[NSMutableArray addObject:](v74, "addObject:", v46);

      id v10 = v73;
    }

    id v9 = v72;
  }

  else
  {
    uint64_t v47 = 0LL;
  }

  return v47;
}

void sub_100084278(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v13 = objc_opt_self(a1);
  if (v12)
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v11));
    id v27 = v9;
    id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v9));
    [v17 setExactMatch:1];
    uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    -[NSMutableArray addObject:](v18, "addObject:", v17);
    id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    -[NSMutableArray addObject:](v18, "addObject:", v19);

    if (v10)
    {
      id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v10));
      -[NSMutableArray addObject:](v18, "addObject:", v20);
    }

    id v21 = [[NEPolicy alloc] initWithOrder:620 result:v16 conditions:v18];
    [v12 addObject:v21];
    id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
    id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v22));
    id v24 = [[NEPolicy alloc] initWithOrder:621 result:v23 conditions:v18];
    [v12 addObject:v24];

    id v9 = v27;
  }

  else
  {
    uint64_t v25 = nplog_obj(v13, v14, v15);
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v29 = "+[NSPPrivacyProxyPolicySerialization obliviousProxyPoliciesForHostname:processUUID:agentUUID:policyArray:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "%s called with null policies", buf, 0xCu);
    }
  }
}

NSMutableArray *sub_1000844C8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if ([v8 count])
  {
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v22 = v8;
    id obj = v8;
    id v12 = [obj countByEnumeratingWithState:&v29 objects:v34 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v24 = *(void *)v30;
      do
      {
        uint64_t v14 = 0LL;
        do
        {
          if (*(void *)v30 != v24) {
            objc_enumerationMutation(obj);
          }
          id v15 = sub_100080220( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  *(void **)(*((void *)&v29 + 1) + 8LL * (void)v14));
          id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          id v17 = [v16 countByEnumeratingWithState:&v25 objects:v33 count:16];
          if (v17)
          {
            id v18 = v17;
            uint64_t v19 = *(void *)v26;
            do
            {
              id v20 = 0LL;
              do
              {
                if (*(void *)v26 != v19) {
                  objc_enumerationMutation(v16);
                }
                sub_100084278(v10, v7, *(void **)(*((void *)&v25 + 1) + 8LL * (void)v20), v9, v11);
                id v20 = (char *)v20 + 1;
              }

              while (v18 != v20);
              id v18 = [v16 countByEnumeratingWithState:&v25 objects:v33 count:16];
            }

            while (v18);
          }

          uint64_t v14 = (char *)v14 + 1;
        }

        while (v14 != v13);
        id v13 = [obj countByEnumeratingWithState:&v29 objects:v34 count:16];
      }

      while (v13);
    }

    id v8 = v22;
  }

  else
  {
    sub_100084278(v10, v7, 0LL, v9, v11);
  }

  return v11;
}

uint64_t sub_1000846E8(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = objc_opt_self(a1);
  if (v12)
  {
    uint64_t v16 = (uint64_t)[v12 hasPrefix:@"com.apple."];
    if ((v16 & 1) == 0)
    {
      uint64_t v32 = nplog_obj(v16, v17, v18);
      id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 identifier]);
      *(_DWORD *)__int128 buf = 138412546;
      id v65 = v12;
      __int16 v66 = 2112;
      uint64_t v67 = v21;
      id v22 = "Skipping unsupported process %@ for contentMap %@";
      goto LABEL_14;
    }
  }

  if (!v13 || !v14)
  {
    if (v13)
    {
      __int128 v25 = -[NSURL initWithString:](objc_alloc(&OBJC_CLASS___NSURL), "initWithString:", v13);
      id v20 = v25;
      if (!v25
        || (__int128 v28 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s host](v25, "host")),
            char v29 = sub_100084BD4(v28),
            v28,
            (v29 & 1) == 0))
      {
        uint64_t v30 = nplog_obj(v25, v26, v27);
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          __int128 v31 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 identifier]);
          *(_DWORD *)__int128 buf = 138412546;
          id v65 = v13;
          __int16 v66 = 2112;
          uint64_t v67 = v31;
          _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Skipping unsupported URL %@ for map %@",  buf,  0x16u);
        }

        goto LABEL_16;
      }

uint64_t sub_100084BD4(void *a1)
{
  id v1 = a1;
  if (qword_1001171D8 != -1) {
    dispatch_once(&qword_1001171D8, &stru_1000FA768);
  }
  if (byte_1001171C8)
  {
    uint64_t v2 = 1LL;
  }

  else
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    id v3 = (id)qword_1001171D0;
    id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v13;
      while (2)
      {
        for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v12 + 1) + 8LL * (void)i);
          if (([v1 isEqualToString:v8] & 1) == 0)
          {
            id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @".%@", v8));
            unsigned __int8 v10 = [v1 hasSuffix:v9];

            if ((v10 & 1) == 0) {
              continue;
            }
          }

          uint64_t v2 = 1LL;
          goto LABEL_17;
        }

        id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
        uint64_t v2 = 0LL;
        if (v5) {
          continue;
        }
        break;
      }
    }

    else
    {
      uint64_t v2 = 0LL;
    }

NSMutableArray *sub_100084D78(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  uint64_t v113 = v5;
  if (!v5)
  {
    id v137 = 0LL;
    id v7 = v6;
    goto LABEL_128;
  }

  id v7 = v6;
  if (![v6 count])
  {
    id v137 = 0LL;
    goto LABEL_128;
  }

  id v137 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v141 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v5));
  SCDynamicStoreRef v135 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 680LL));
  __int128 v174 = 0u;
  __int128 v175 = 0u;
  __int128 v176 = 0u;
  __int128 v177 = 0u;
  id obj = v6;
  id v117 = [obj countByEnumeratingWithState:&v174 objects:v186 count:16];
  if (!v117) {
    goto LABEL_125;
  }
  uint64_t v115 = *(void *)v175;
  id v116 = v6;
  do
  {
    uint64_t v8 = 0LL;
    do
    {
      if (*(void *)v175 != v115)
      {
        uint64_t v9 = v8;
        objc_enumerationMutation(obj);
        uint64_t v8 = v9;
      }

      uint64_t v119 = v8;
      unsigned __int8 v10 = *(void **)(*((void *)&v174 + 1) + 8 * v8);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 hostnames]);
      id v120 = v5;
      if ([v11 count]) {
        goto LABEL_11;
      }
      __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v10 urls]);
      if ([v12 count])
      {

LABEL_11:
        goto LABEL_12;
      }

      id v49 = (void *)objc_claimAutoreleasedReturnValue([v10 processes]);
      id v50 = [v49 count];

      if (v50)
      {
        __int128 v172 = 0u;
        __int128 v173 = 0u;
        __int128 v170 = 0u;
        __int128 v171 = 0u;
        id v123 = (id)objc_claimAutoreleasedReturnValue([v10 processes]);
        id v130 = [v123 countByEnumeratingWithState:&v170 objects:v185 count:16];
        if (v130)
        {
          uint64_t v128 = *(void *)v171;
          do
          {
            for (CFIndex i = 0LL; i != v130; CFIndex i = (char *)i + 1)
            {
              if (*(void *)v171 != v128) {
                objc_enumerationMutation(v123);
              }
              uint64_t v52 = *(void **)(*((void *)&v170 + 1) + 8LL * (void)i);
              uint64_t v53 = sub_1000846E8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v141, v52, 0LL, 0LL, v10);
              if ((_DWORD)v53)
              {
                uint64_t v54 = v53;
                id v134 = i;
                id v55 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v52);
                int v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
                __int128 v166 = 0u;
                __int128 v167 = 0u;
                __int128 v168 = 0u;
                __int128 v169 = 0u;
                id v139 = v56;
                id v57 = [v56 countByEnumeratingWithState:&v166 objects:v184 count:16];
                if (v57)
                {
                  id v58 = v57;
                  uint64_t v59 = *(void *)v167;
                  do
                  {
                    for (j = 0LL; j != v58; j = (char *)j + 1)
                    {
                      if (*(void *)v167 != v59) {
                        objc_enumerationMutation(v139);
                      }
                      uint64_t v61 = *(void *)(*((void *)&v166 + 1) + 8LL * (void)j);
                      __int16 v62 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                      id v63 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                      -[NSMutableArray addObject:](v62, "addObject:", v63);

                      __int128 v64 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v61));
                      -[NSMutableArray addObject:](v62, "addObject:", v64);

                      if (([v10 isPrivacyProxy] & 1) == 0)
                      {
                        id v65 = +[NEPolicyCondition realUID:](&OBJC_CLASS___NEPolicyCondition, "realUID:", getuid());
                        __int16 v66 = (void *)objc_claimAutoreleasedReturnValue(v65);
                        -[NSMutableArray addObject:](v62, "addObject:", v66);
                      }

                      if ([v10 systemProcessOnly])
                      {
                        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition platformBinary]( &OBJC_CLASS___NEPolicyCondition,  "platformBinary"));
                        -[NSMutableArray addObject:](v62, "addObject:", v67);
                      }

                      id v68 = [[NEPolicy alloc] initWithOrder:v54 result:v136 conditions:v62];
                      -[NSMutableArray addObject:](v137, "addObject:", v68);

                      id v69 = [[NEPolicy alloc] initWithOrder:(v54 + 1) result:v135 conditions:v62];
                      -[NSMutableArray addObject:](v137, "addObject:", v69);
                    }

                    id v58 = [v139 countByEnumeratingWithState:&v166 objects:v184 count:16];
                  }

                  while (v58);
                }

                id v5 = v120;
                CFIndex i = v134;
              }
            }

            id v130 = [v123 countByEnumeratingWithState:&v170 objects:v185 count:16];
          }

          while (v130);
        }

        goto LABEL_120;
      }

LABEL_70:
      id v123 = (id)objc_claimAutoreleasedReturnValue([v133 hostnames]);
      id v70 = [v123 count];
      id v118 = v16;
      if (!v70)
      {
        id v5 = (id)objc_claimAutoreleasedReturnValue([v133 urls]);
        if (![v5 count])
        {

          goto LABEL_120;
        }

        id v120 = v5;
      }

      id v71 = (void *)objc_claimAutoreleasedReturnValue([v133 processes]);
      id v72 = [v71 count];

      uint64_t v73 = v133;
      if (!v70)
      {
        id v5 = v120;

        if (!v72) {
          goto LABEL_121;
        }
LABEL_77:
        __int128 v156 = 0u;
        __int128 v157 = 0u;
        __int128 v154 = 0u;
        __int128 v155 = 0u;
        id v123 = (id)objc_claimAutoreleasedReturnValue([v133 processes]);
        id v122 = [v123 countByEnumeratingWithState:&v154 objects:v181 count:16];
        if (v122)
        {
          uint64_t v121 = *(void *)v155;
          do
          {
            uint64_t v74 = 0LL;
            do
            {
              if (*(void *)v155 != v121) {
                objc_enumerationMutation(v123);
              }
              uint64_t v124 = v74;
              __int128 v75 = *(void **)(*((void *)&v154 + 1) + 8 * v74);
              id v76 = sub_100080220((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v75);
              __int128 v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
              __int128 v150 = 0u;
              __int128 v151 = 0u;
              __int128 v152 = 0u;
              __int128 v153 = 0u;
              id v125 = v77;
              id v127 = [v77 countByEnumeratingWithState:&v150 objects:v180 count:16];
              if (v127)
              {
                uint64_t v126 = *(void *)v151;
                do
                {
                  uint64_t v78 = 0LL;
                  do
                  {
                    if (*(void *)v151 != v126) {
                      objc_enumerationMutation(v125);
                    }
                    uint64_t v129 = v78;
                    id v140 = *(id *)(*((void *)&v150 + 1) + 8 * v78);
                    __int128 v146 = 0u;
                    __int128 v147 = 0u;
                    __int128 v148 = 0u;
                    __int128 v149 = 0u;
                    id v131 = (id)objc_claimAutoreleasedReturnValue([v73 hostnames]);
                    id v79 = [v131 countByEnumeratingWithState:&v146 objects:v179 count:16];
                    if (v79)
                    {
                      id v80 = v79;
                      uint64_t v81 = *(void *)v147;
                      do
                      {
                        for (n = 0LL; n != v80; n = (char *)n + 1)
                        {
                          if (*(void *)v147 != v81) {
                            objc_enumerationMutation(v131);
                          }
                          __int128 v83 = *(void **)(*((void *)&v146 + 1) + 8LL * (void)n);
                          uint64_t v84 = sub_1000846E8( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  v141,  v75,  0LL,  v83,  v73);
                          if ((_DWORD)v84)
                          {
                            uint64_t v85 = v84;
                            __int128 v86 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                            __int128 v87 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                            -[NSMutableArray addObject:](v86, "addObject:", v87);

                            __int128 v88 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v140));
                            -[NSMutableArray addObject:](v86, "addObject:", v88);

                            id v89 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition domain:]( &OBJC_CLASS___NEPolicyCondition,  "domain:",  v83));
                            -[NSMutableArray addObject:](v86, "addObject:", v89);
                            if (([v73 isPrivacyProxy] & 1) == 0)
                            {
                              id v90 = +[NEPolicyCondition realUID:](&OBJC_CLASS___NEPolicyCondition, "realUID:", getuid());
                              uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
                              -[NSMutableArray addObject:](v86, "addObject:", v91);
                            }

                            if ([v73 systemProcessOnly])
                            {
                              __int128 v92 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition platformBinary]( &OBJC_CLASS___NEPolicyCondition,  "platformBinary"));
                              -[NSMutableArray addObject:](v86, "addObject:", v92);
                            }

                            id v93 = [[NEPolicy alloc] initWithOrder:v85 result:v136 conditions:v86];
                            -[NSMutableArray addObject:](v137, "addObject:", v93);

                            id v94 = [[NEPolicy alloc] initWithOrder:(v85 + 1) result:v135 conditions:v86];
                            -[NSMutableArray addObject:](v137, "addObject:", v94);

                            uint64_t v73 = v133;
                          }
                        }

                        id v80 = [v131 countByEnumeratingWithState:&v146 objects:v179 count:16];
                      }

                      while (v80);
                    }

                    __int128 v144 = 0u;
                    __int128 v145 = 0u;
                    __int128 v142 = 0u;
                    __int128 v143 = 0u;
                    id v132 = (id)objc_claimAutoreleasedReturnValue([v73 urls]);
                    id v95 = [v132 countByEnumeratingWithState:&v142 objects:v178 count:16];
                    if (v95)
                    {
                      id v96 = v95;
                      uint64_t v97 = *(void *)v143;
                      do
                      {
                        for (iCFIndex i = 0LL; ii != v96; iCFIndex i = (char *)ii + 1)
                        {
                          if (*(void *)v143 != v97) {
                            objc_enumerationMutation(v132);
                          }
                          __int16 v99 = *(void **)(*((void *)&v142 + 1) + 8LL * (void)ii);
                          uint64_t v100 = sub_1000846E8( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  v141,  v75,  v99,  0LL,  v73);
                          if ((_DWORD)v100)
                          {
                            uint64_t v101 = v100;
                            uint64_t v102 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                            __int128 v103 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                            -[NSMutableArray addObject:](v102, "addObject:", v103);

                            uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v140));
                            -[NSMutableArray addObject:](v102, "addObject:", v104);

                            id v105 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition url:](&OBJC_CLASS___NEPolicyCondition, "url:", v99));
                            -[NSMutableArray addObject:](v102, "addObject:", v105);

                            if (([v73 isPrivacyProxy] & 1) == 0)
                            {
                              id v106 = +[NEPolicyCondition realUID:]( &OBJC_CLASS___NEPolicyCondition,  "realUID:",  getuid());
                              char v107 = (void *)objc_claimAutoreleasedReturnValue(v106);
                              -[NSMutableArray addObject:](v102, "addObject:", v107);
                            }

                            if ([v73 systemProcessOnly])
                            {
                              uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition platformBinary]( &OBJC_CLASS___NEPolicyCondition,  "platformBinary"));
                              -[NSMutableArray addObject:](v102, "addObject:", v108);
                            }

                            id v109 = [[NEPolicy alloc] initWithOrder:v101 result:v136 conditions:v102];
                            -[NSMutableArray addObject:](v137, "addObject:", v109);

                            id v110 = [[NEPolicy alloc] initWithOrder:(v101 + 1) result:v135 conditions:v102];
                            -[NSMutableArray addObject:](v137, "addObject:", v110);

                            uint64_t v73 = v133;
                          }
                        }

                        id v96 = [v132 countByEnumeratingWithState:&v142 objects:v178 count:16];
                      }

                      while (v96);
                    }

                    ++v78;
                  }

                  while ((id)(v129 + 1) != v127);
                  id v127 = [v125 countByEnumeratingWithState:&v150 objects:v180 count:16];
                }

                while (v127);
              }

              uint64_t v74 = v124 + 1;
            }

            while ((id)(v124 + 1) != v122);
            id v122 = [v123 countByEnumeratingWithState:&v154 objects:v181 count:16];
          }

          while (v122);
LABEL_119:
          id v5 = v120;
        }

os_log_s *sub_100085CA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  if (v3)
  {
    uint64_t v5 = v4;
    if ([v3 conditionsCount])
    {
      id v6 = sub_100080220( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview");
      id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

      if (!v7)
      {
        uint64_t v47 = nplog_obj(v8, v9, v10);
        __int128 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v70 = v5;
          __int16 v71 = 2112;
          id v72 = @"com.apple.SafariTechnologyPreview";
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "%@ unable to install policies for '%@' as it is not installed",  buf,  0x16u);
        }

        goto LABEL_49;
      }

      char v11 = sub_1000833A8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v3);
      __int128 v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      if ((v11 & 2) != 0)
      {
        id v13 = sub_100080220( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview");
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        __int128 v60 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v63 = 0u;
        id v15 = [v14 countByEnumeratingWithState:&v60 objects:v68 count:16];
        if (v15)
        {
          id v16 = v15;
          uint64_t v17 = *(void *)v61;
          do
          {
            for (CFIndex i = 0LL; i != v16; CFIndex i = (char *)i + 1)
            {
              if (*(void *)v61 != v17) {
                objc_enumerationMutation(v14);
              }
              sub_100080944( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  v12,  *(void **)(*((void *)&v60 + 1) + 8LL * (void)i));
            }

            id v16 = [v14 countByEnumeratingWithState:&v60 objects:v68 count:16];
          }

          while (v16);
        }
      }

      if ((v11 & 4) != 0)
      {
        id v19 = sub_100080C54( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview",  1);
        uint64_t v20 = objc_claimAutoreleasedReturnValue(v19);
        if (!v20)
        {
          uint64_t v48 = nplog_obj(0LL, v21, v22);
          id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
          if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            goto LABEL_48;
          }
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v70 = v5;
          id v50 = "%@ failed to create SafariTechnologyPreview KNOWN TRACKER policies";
          goto LABEL_47;
        }

        id v23 = (void *)v20;
        -[os_log_s addObjectsFromArray:](v12, "addObjectsFromArray:", v20);
      }

      if ((v11 & 1) == 0) {
        goto LABEL_19;
      }
      uint32_t v24 = sub_10008072C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview");
      uint64_t v25 = objc_claimAutoreleasedReturnValue(v24);
      if (v25)
      {
        __int128 v28 = (void *)v25;
        -[os_log_s addObjectsFromArray:](v12, "addObjectsFromArray:", v25);

LABEL_19:
        if ((v11 & 0x10) == 0)
        {
LABEL_22:
          if ((v11 & 0x20) == 0)
          {
LABEL_44:
            __int128 v12 = v12;
            uint64_t v46 = v12;
LABEL_50:

            goto LABEL_51;
          }

          id v34 = @"com.apple.SafariTechnologyPreview";
          objc_opt_self(&OBJC_CLASS___NSPPrivacyProxyPolicySerialization);
          id v35 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
          id v37 = sub_100080220( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview");
          id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
          if ([v38 count])
          {
            __int128 v66 = 0u;
            __int128 v67 = 0u;
            __int128 v64 = 0u;
            __int128 v65 = 0u;
            uint64_t v39 = v38;
            id v40 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v64,  buf,  16LL);
            if (v40)
            {
              id v41 = v40;
              id v58 = v38;
              uint64_t v59 = v5;
              uint64_t v42 = *(void *)v65;
              do
              {
                for (j = 0LL; j != v41; j = (char *)j + 1)
                {
                  if (*(void *)v65 != v42) {
                    objc_enumerationMutation(v39);
                  }
                  id v44 = sub_10008026C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  450LL,  v36,  *(void **)(*((void *)&v64 + 1) + 8LL * (void)j),  443LL,  0LL,  0LL,  1);
                  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
                  -[NSMutableArray addObject:](v35, "addObject:", v45);
                }

                id v41 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v64,  buf,  16LL);
              }

              while (v41);
              id v38 = v58;
              uint64_t v5 = v59;
            }
          }

          else
          {
            uint64_t v39 = v35;
            id v35 = 0LL;
          }

          if (v35)
          {
            -[os_log_s addObjectsFromArray:](v12, "addObjectsFromArray:", v35);

            goto LABEL_44;
          }

          uint64_t v56 = nplog_obj(v53, v54, v55);
          id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
          if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            goto LABEL_48;
          }
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v70 = v5;
          id v50 = "%@ failed to create SafariTechnologyPreview HTTP policies";
          goto LABEL_47;
        }

        char v29 = sub_10008040C( (uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization,  @"com.apple.SafariTechnologyPreview",  @"com.apple.safari.peertopeer",  0LL);
        uint64_t v30 = objc_claimAutoreleasedReturnValue(v29);
        if (v30)
        {
          id v33 = (void *)v30;
          -[os_log_s addObjectsFromArray:](v12, "addObjectsFromArray:", v30);

          goto LABEL_22;
        }

        uint64_t v52 = nplog_obj(0LL, v31, v32);
        id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v70 = v5;
          id v50 = "%@ failed to create SafariTechnologyPreview All policies";
          goto LABEL_47;
        }

LABEL_48:
LABEL_49:
        uint64_t v46 = 0LL;
        goto LABEL_50;
      }

      uint64_t v51 = nplog_obj(0LL, v26, v27);
      id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
      if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v70 = v5;
      id v50 = "%@ failed to create SafariTechnologyPreview UNENCRYPTED policies";
LABEL_47:
      _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, v50, buf, 0xCu);
      goto LABEL_48;
    }
  }

  uint64_t v46 = 0LL;
LABEL_51:

  return v46;
}

  -[NSPConfigurationStats setUnencryptedEnabled:](v15, "setUnencryptedEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x80) == 0)
  {
LABEL_23:
    if ((v12 & 0x100) == 0) {
      goto LABEL_24;
    }
    goto LABEL_50;
  }

      if (v33 != (id)++v35) {
        continue;
      }
      break;
    }

    uint64_t v45 = [v31 countByEnumeratingWithState:&v84 objects:buf count:16];
    id v33 = v45;
    if (v45) {
      continue;
    }
    break;
  }

NSMutableArray *sub_1000861B0(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v4 = +[NPUtilities machoUUIDFromPID:](&OBJC_CLASS___NPUtilities, "machoUUIDFromPID:", getpid());
  uint64_t v5 = objc_claimAutoreleasedReturnValue(v4);
  uint64_t v8 = (void *)v5;
  if (!v5) {
    goto LABEL_6;
  }
  uint64_t v9 = nplog_obj(v5, v6, v7);
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    int v27 = 138412546;
    uint64_t v28 = v1;
    __int16 v29 = 2112;
    uint64_t v30 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "%@ adding probe policy using uuid: %@",  (uint8_t *)&v27,  0x16u);
  }

  char v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", @"http://netcts.cdn-apple.com"));
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 host]);
  id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v12));
  -[NSMutableArray addObject:](v3, "addObject:", v13);

  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.nsp.proxyAgentProbe"));
  -[NSMutableArray addObject:](v3, "addObject:", v14);

  id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
  -[NSMutableArray addObject:](v3, "addObject:", v15);

  id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID]( &OBJC_CLASS___NSPPrivacyProxyAgentManager,  "multiHopProxyAgentUUID"));
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v16));
  id v18 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 350LL, v17, v8, 80LL, 6LL, v3, 0);
  id v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

  if (v19)
  {
    -[NSMutableArray addObject:](v2, "addObject:", v19);

LABEL_6:
    id v23 = v2;
    goto LABEL_10;
  }

  uint64_t v24 = nplog_obj(v20, v21, v22);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    int v27 = 138412290;
    uint64_t v28 = v1;
    _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "%@ failed to create probe policy",  (uint8_t *)&v27,  0xCu);
  }

  id v23 = 0LL;
LABEL_10:

  return v23;
}

NSMutableArray *sub_100086454(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  -[NSMutableArray addObject:](v5, "addObject:", v6);

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 6LL));
  -[NSMutableArray addObject:](v5, "addObject:", v7);

  id v8 = objc_alloc(&OBJC_CLASS___NEPolicy);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 controlUnit]);

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult divertSocketToControlUnit:]( NEPolicyResult,  "divertSocketToControlUnit:",  [v9 unsignedIntValue]));
  id v11 = [v8 initWithOrder:720 result:v10 conditions:v5];

  -[NSMutableArray addObject:](v4, "addObject:", v11);
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allowsUnsafeSocketAccess]( &OBJC_CLASS___NEPolicyCondition,  "allowsUnsafeSocketAccess"));
  [v12 setNegative:1];
  id v13 = objc_alloc(&OBJC_CLASS___NEPolicy);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 730LL));
  id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition usesModernNetworkAPI]( &OBJC_CLASS___NEPolicyCondition,  "usesModernNetworkAPI",  v15));
  v20[1] = v16;
  v20[2] = v12;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v20, 3LL));
  id v18 = [v13 initWithOrder:710 result:v14 conditions:v17];

  -[NSMutableArray addObject:](v4, "addObject:", v18);
  return v4;
}

NSMutableArray *sub_100086670(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 500LL));
  if ([v3 count]) {
    id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  }
  else {
    id v4 = 0LL;
  }
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id obj = v3;
  id v5 = [obj countByEnumeratingWithState:&v18 objects:v23 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v19;
    do
    {
      id v8 = 0LL;
      do
      {
        if (*(void *)v19 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)v8);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v22[0] = v10;
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.networkQuality.private-relay"));
        v22[1] = v11;
        __int128 v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v22, 2LL));
        id v13 = sub_10008026C((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, 450LL, v17, v9, 0LL, 0LL, v12, 1);
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);

        -[NSMutableArray addObject:](v4, "addObject:", v14);
        id v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [obj countByEnumeratingWithState:&v18 objects:v23 count:16];
    }

    while (v6);
  }

  return v4;
}

uint64_t sub_100086864(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  LODWORD(a1) = sub_1000833A8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v3);

  return (a1 >> 13) & 1;
}

void sub_1000868AC(id a1)
{
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  @"apple.com",  @"apple.news",  @"cdn-apple.com",  @"icloud.com",  @"mzstatic.com",  @".apple",  @"icloud.com.cn",  @"googleapis.com",  @"gstatic.com",  0LL));
  uint64_t v2 = (void *)qword_1001171D0;
  qword_1001171D0 = v1;

  if (os_variant_allows_internal_security_policies("com.apple.networkserviceproxy"))
  {
    CFPropertyListRef v3 = CFPreferencesCopyAppValue(@"NSPAllowAllDomains", kCFPreferencesCurrentApplication);
    id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    if (v4)
    {
      uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
      if ((objc_opt_isKindOfClass(v4, v5) & 1) != 0)
      {
        id v6 = [v4 BOOLValue];
        byte_1001171C8 = (char)v6;
        uint64_t v9 = nplog_obj(v6, v7, v8);
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 67240192;
          int v12 = byte_1001171C8;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Detected allow all domains in preferences file: %{public}d",  buf,  8u);
        }
      }
    }
  }

void sub_100086A34(uint64_t a1)
{
  if (!a1) {
    return;
  }
  id v26 = *(id *)(a1 + 32);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v26 enabled]);
  if (([v2 BOOLValue] & 1) == 0)
  {
LABEL_8:

    return;
  }

  id v3 = *(id *)(a1 + 32);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 configServerEnabled]);
  if (![v4 BOOLValue])
  {

    goto LABEL_8;
  }

  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = objc_claimAutoreleasedReturnValue([v5 resurrectionDate]);
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) resurrectionDate]);
    [v8 timeIntervalSinceNow];
    double v10 = v9;

    if (v10 >= 0.0) {
      return;
    }
  }

  else
  {
  }

  id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) etag]);

  if (v11)
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    id v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) configurationFetchDate]);
    [v15 timeIntervalSinceDate:v16];
    double v18 = v17;

    if (v18 < 86400.0) {
      return;
    }
    uint64_t v22 = nplog_obj(v19, v20, v21);
    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Refreshing stale configuration", buf, 2u);
    }

    *(void *)__int128 buf = 0LL;
    uint64_t v30 = buf;
    uint64_t v31 = 0x3032000000LL;
    uint64_t v32 = sub_100086D74;
    id v33 = sub_100086D84;
    id v34 = (id)os_transaction_create("com.apple.networkserviceproxy.configManagerRefreshStaleConfiguration");
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    v27[2] = sub_10008715C;
    _OWORD v27[3] = &unk_1000FA170;
    void v27[4] = buf;
    sub_100086DA0(a1, (void *)1, v27);
  }

  else
  {
    uint64_t v24 = nplog_obj(v12, v13, v14);
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Fetching new configuration", buf, 2u);
    }

    *(void *)__int128 buf = 0LL;
    uint64_t v30 = buf;
    uint64_t v31 = 0x3032000000LL;
    uint64_t v32 = sub_100086D74;
    id v33 = sub_100086D84;
    id v34 = (id)os_transaction_create("com.apple.networkserviceproxy.configManagerFirstFetch");
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472LL;
    v28[2] = sub_100086D8C;
    _OWORD v28[3] = &unk_1000FA170;
    v28[4] = buf;
    sub_100086DA0(a1, (void *)1, v28);
  }

  _Block_object_dispose(buf, 8);
}

void sub_100086D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_100086D74(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100086D84(uint64_t a1)
{
}

void sub_100086D8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_100086DA0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v8 = (void (**)(void, void, void))v5;
  if (a1)
  {
    double v9 = *(void **)(a1 + 32);
    if (v9)
    {
      id v10 = v9;
      uint64_t v13 = v10;
      if (*(_BYTE *)(a1 + 8))
      {
        uint64_t v14 = nplog_obj(v10, v11, v12);
        id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "privacy proxy configuration refresh is already pending",  buf,  2u);
        }

        if (!v8) {
          goto LABEL_21;
        }
      }

      else
      {
        id v16 = (void *)objc_claimAutoreleasedReturnValue([v10 configServerEnabled]);
        unsigned __int8 v17 = [v16 BOOLValue];

        if ((v17 & 1) != 0)
        {
          id v21 = [*(id *)(a1 + 64) status];
          if (v21 == (id)1)
          {
            *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
            uint64_t v24 = nplog_obj(1LL, v22, v23);
            uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              id v26 = sub_100090478(a1);
              int v27 = (char *)objc_claimAutoreleasedReturnValue(v26);
              uint64_t v28 = *(void *)(a1 + 80) + 1LL;
              *(_DWORD *)__int128 buf = 138412546;
              id v41 = v27;
              __int16 v42 = 2048;
              uint64_t v43 = v28;
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Fetching privacy proxy configuration on %@ (Attempt: %lu)",  buf,  0x16u);
            }

            objc_initWeak((id *)buf, (id)a1);
            __int16 v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472LL;
            uint8_t v36[2] = sub_100090AA8;
            v36[3] = &unk_1000FA8A8;
            objc_copyWeak(v39, (id *)buf);
            void v36[4] = a1;
            id v37 = v13;
            v39[1] = a2;
            id v38 = v8;
            [v29 refreshCountryPlusTimezone:v36];

            objc_destroyWeak(v39);
            objc_destroyWeak((id *)buf);
            goto LABEL_21;
          }

          uint64_t v32 = nplog_obj(v21, v22, v23);
          id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "deferring configuration fetch, path is not satisfied",  buf,  2u);
          }

          *(_BYTE *)(a1 + 9) = 1;
          sub_100087F50(a1);
          if (!v8) {
            goto LABEL_21;
          }
        }

        else
        {
          uint64_t v30 = nplog_obj(v18, v19, v20);
          uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "privacy proxy config fetch is disabled",  buf,  2u);
          }

          if (!v8) {
            goto LABEL_21;
          }
        }
      }

      v8[2](v8, 0LL, 0LL);
LABEL_21:

      goto LABEL_22;
    }

    uint64_t v34 = nplog_obj(v5, v6, v7);
    id v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v41 = "-[NSPConfigurationManager refreshConfigurationFetchWithReason:completionHandler:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "%s called with null self.configuration",  buf,  0xCu);
    }

    v8[2](v8, 0LL, 0LL);
  }

void sub_100087130( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_10008715C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_100087170(id *a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1[4] resurrectionDate]);

  if (v2)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([a1[4] resurrectionDate]);
    [v3 timeIntervalSinceNow];
    double v5 = v4;

    if (v5 <= 0.0)
    {
      uint64_t v24 = nplog_obj(v6, v7, v8);
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "resurrection timer value in past",  (uint8_t *)&buf,  2u);
      }

      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v32 = 0x3032000000LL;
      id v33 = sub_100086D74;
      uint64_t v34 = sub_100086D84;
      id v35 = (id)os_transaction_create("com.apple.networkserviceproxy.configManagerResurrectionTimer");
      uint64_t v26 = NPGetInternalQueue(v35);
      int v27 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v26);
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472LL;
      v28[2] = sub_1000877A8;
      _OWORD v28[3] = &unk_1000F9428;
      v28[4] = a1;
      void v28[5] = &buf;
      dispatch_async(v27, v28);

      _Block_object_dispose(&buf, 8);
    }

    else
    {
      id v9 = a1[4];
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 resurrectionDate]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v10,  1LL,  2LL));

      uint64_t v15 = nplog_obj(v12, v13, v14);
      id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Resurrection date is %@, starting timer",  (uint8_t *)&buf,  0xCu);
      }

      objc_initWeak((id *)&buf, a1);
      unsigned __int8 v17 = objc_alloc(&OBJC_CLASS___NSTimer);
      id v18 = a1[4];
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 resurrectionDate]);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = sub_1000874D4;
      v29[3] = &unk_1000FA7B8;
      objc_copyWeak(&v30, (id *)&buf);
      v29[4] = a1;
      uint64_t v20 = -[NSTimer initWithFireDate:interval:repeats:block:]( v17,  "initWithFireDate:interval:repeats:block:",  v19,  0LL,  v29,  0.0);
      id v21 = a1[5];
      a1[5] = v20;

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
      id v23 = a1[5];
      [v22 addTimer:v23 forMode:NSDefaultRunLoopMode];

      objc_destroyWeak(&v30);
      objc_destroyWeak((id *)&buf);
    }
  }

void sub_100087484( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

void sub_1000874D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v12[0] = 0LL;
  v12[1] = v12;
  v12[2] = 0x3032000000LL;
  v12[3] = sub_100086D74;
  void v12[4] = sub_100086D84;
  id v13 = (id)os_transaction_create("com.apple.networkserviceproxy.configManagerResurrectionTimer");
  uint64_t v4 = NPGetInternalQueue(v13);
  double v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_1000875FC;
  v7[3] = &unk_1000FA790;
  id v8 = v3;
  id v6 = v3;
  objc_copyWeak(&v11, (id *)(a1 + 40));
  uint64_t v9 = *(void *)(a1 + 32);
  id v10 = v12;
  dispatch_async(v5, v7);

  objc_destroyWeak(&v11);
  _Block_object_dispose(v12, 8);
}

void sub_1000875E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000875FC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) invalidate];
  uint64_t v5 = nplog_obj(v2, v3, v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Resurrection timer fired", buf, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  id v8 = WeakRetained;
  if (WeakRetained)
  {
    id v9 = WeakRetained[5];
    WeakRetained[5] = 0LL;

    [v8[4] setResurrectionDate:0];
    sub_1000876FC(*(void *)(a1 + 40), v10, v11);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_100087794;
    v14[3] = &unk_1000FA170;
    void v14[4] = *(void *)(a1 + 48);
    sub_100086DA0((uint64_t)v8, (void *)1, v14);
  }

  else
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8LL);
    id v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = 0LL;
  }
}

void sub_1000876FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "reset config fetch timer", v8, 2u);
    }

    sub_100087A2C(a1, 0x15180uLL, v6);
    *(void *)(a1 + 80) = 0LL;
    *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 0;
    uint64_t v7 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = 0LL;

    sub_100087F50(a1);
  }

void sub_100087794(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000877A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100087814;
  v5[3] = &unk_1000FA170;
  uint64_t v4 = *(void *)(a1 + 32);
  v5[4] = *(void *)(a1 + 40);
  sub_100086DA0(v4, (void *)1, v5);
}

void sub_100087814(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_100087828(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = NPGetInternalQueue(v3);
  uint64_t v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_1000878DC;
  v7[3] = &unk_1000F9478;
  id v8 = v3;
  id v6 = v3;
  objc_copyWeak(&v9, (id *)(a1 + 32));
  dispatch_async(v5, v7);

  objc_destroyWeak(&v9);
}

void sub_1000878DC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) invalidate];
  uint64_t v5 = nplog_obj(v2, v3, v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Enable check timer fired", (uint8_t *)v11, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v8 = WeakRetained;
  if (WeakRetained)
  {
    id v9 = WeakRetained[6];
    WeakRetained[6] = 0LL;

    id v10 = objc_loadWeakRetained(v8 + 3);
    [v10 enableCheckTimeout:v8];
  }
}

void sub_100087984(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resetting configuration timers", v11, 2u);
  }

  uint64_t v7 = *(void **)(a1 + 40);
  if (v7)
  {
    [v7 invalidate];
    id v8 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0LL;
  }

  sub_100087A2C(a1, 0x15180uLL, v6);
  id v9 = *(void **)(a1 + 48);
  if (v9)
  {
    [v9 invalidate];
    id v10 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  }

void sub_100087A2C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a1)
  {
    unint64_t v3 = a2;
    uint64_t v5 = *(dispatch_source_s **)(a1 + 72);
    if (v5)
    {
      dispatch_source_cancel(v5);
      uint64_t v6 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = 0LL;
    }

    if (!v3)
    {
      unint64_t v7 = *(void *)(a1 + 80);
      if (v7 < 8)
      {
        int v10 = dword_1000C39F8[v7];
        uint64_t v5 = (dispatch_source_s *)arc4random_uniform(6u);
        unint64_t v3 = ((_DWORD)v5 + v10);
      }

      else
      {
        uint64_t v8 = nplog_obj(v5, a2, a3);
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 67109120;
          LODWORD(v27) = 8;
          _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Failed to fetch configuration after %u attempts",  buf,  8u);
        }

        uint64_t v5 = (dispatch_source_s *)arc4random_uniform(6u);
        unint64_t v3 = ((_DWORD)v5 + 10800);
      }
    }

    ++*(void *)(a1 + 80);
    uint64_t v11 = nplog_obj(v5, a2, a3);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      unint64_t v27 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Retry: fetching configuration after %lu seconds",  buf,  0xCu);
    }

    id inited = objc_initWeak((id *)buf, (id)a1);
    uint64_t v14 = NPGetInternalQueue(inited);
    uint64_t v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
    dispatch_source_t v16 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v15);
    unsigned __int8 v17 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = v16;

    if (*(void *)(a1 + 72))
    {
      id v18 = (dispatch_source_s *)*(id *)(a1 + 72);
      dispatch_time_t v19 = dispatch_time(0x8000000000000000LL, 1000000000 * v3);
      dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0LL);

      uint64_t v20 = *(void **)(a1 + 72);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_1000928B0;
      handler[3] = &unk_1000F97C0;
      id v21 = v20;
      objc_copyWeak(&v25, (id *)buf);
      dispatch_source_set_event_handler(v21, handler);

      dispatch_resume(*(dispatch_object_t *)(a1 + 72));
      objc_destroyWeak(&v25);
    }

    uint64_t v22 = objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSinceNow:", (double)v3));
    id v23 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v22;

    sub_100087F50(a1);
    objc_destroyWeak((id *)buf);
  }

void sub_100087CC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_100087CDC(id *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "setting up configuration timers",  (uint8_t *)&buf,  2u);
    }

    sub_100087984((uint64_t)a1, v6, v7);
    sub_100087170(a1);
    id v8 = a1[4];
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 earliestEnableCheckDate]);

    if (v9)
    {
      uint64_t v13 = nplog_obj(v10, v11, v12);
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);

      if (v15)
      {
        dispatch_source_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDateFormatter localizedStringFromDate:dateStyle:timeStyle:]( &OBJC_CLASS___NSDateFormatter,  "localizedStringFromDate:dateStyle:timeStyle:",  v9,  1LL,  2LL));
        uint64_t v19 = nplog_obj(v16, v17, v18);
        uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Scheduling enable check date timer to fire on %@",  (uint8_t *)&buf,  0xCu);
        }
      }

      objc_initWeak(&location, a1);
      id v21 = objc_alloc(&OBJC_CLASS___NSTimer);
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      uint64_t v28 = sub_100087828;
      __int16 v29 = &unk_1000F94A0;
      objc_copyWeak(&v30, &location);
      uint64_t v22 = -[NSTimer initWithFireDate:interval:repeats:block:]( v21,  "initWithFireDate:interval:repeats:block:",  v9,  0LL,  &buf,  0.0);
      id v23 = a1[6];
      a1[6] = v22;

      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
      id v25 = a1[6];
      [v24 addTimer:v25 forMode:NSDefaultRunLoopMode];

      objc_destroyWeak(&v30);
      objc_destroyWeak(&location);
    }
  }

void sub_100087F14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_100087F50(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x3032000000LL;
  v5[3] = sub_100086D74;
  v5[4] = sub_100086D84;
  id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.setUserEventAgentConfigurationParameters");
  uint64_t v2 = NPGetInternalQueue(v6);
  unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000929F8;
  v4[3] = &unk_1000F9428;
  v4[4] = a1;
  void v4[5] = v5;
  dispatch_async(v3, v4);

  _Block_object_dispose(v5, 8);
}

void sub_100088010( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100088028(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = nplog_obj(a1, a2, a3);
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resetting configuration", v9, 2u);
    }

    id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSPConfiguration defaultConfiguration](&OBJC_CLASS___NSPConfiguration, "defaultConfiguration"));
    id v7 = [v6 copy];
    id v8 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = v7;
  }

void sub_1000883F4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) configServerHost]);
    id v2 = [*(id *)(a1 + 32) ignoreInvalidCerts];
    id v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) geohashSharingEnabledStatus]);
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) geohashOverride]);
    __int16 v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) preferredPathRoutingEnabledStatus]);
    id v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) privateAccessTokensEnabledStatus]);
    id v40 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) privateAccessTokensAllowTools]);
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) inProcessFlowDivert]);
    unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) proxyTrafficState]);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userTier]);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) proxyAccountType]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) proxyAccountUnlimited]);
    id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userPreferredTier]);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) subscriberEnabledFromNonSettingsApp]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) lastPrivateCloudComputeEnvironment]);
    v47[0] = 0LL;
    v47[1] = v47;
    v47[2] = 0x3032000000LL;
    v47[3] = sub_100086D74;
    uint8_t v47[4] = sub_100086D84;
    id v48 = (id)os_transaction_create("com.apple.networkserviceproxy.configRestart");
    sub_100087984(a1, v10, v11);
    sub_1000876FC(a1, v12, v13);
    sub_100088028(a1, v14, v15);
    sub_100088A64(a1);
    +[NSPConfigurationSignatureInfo removeFromPreferences]( &OBJC_CLASS___NSPConfigurationSignatureInfo,  "removeFromPreferences");
    id v16 = *(id *)(a1 + 32);
    [v16 setConfigServerEnabled:&__kCFBooleanTrue];

    id v17 = *(id *)(a1 + 32);
    [v17 setConfigServerHost:v45];

    id v18 = *(id *)(a1 + 32);
    [v18 setIgnoreInvalidCerts:v2];

    id v19 = *(id *)(a1 + 32);
    [v19 setGeohashSharingEnabledStatus:v44];

    id v20 = *(id *)(a1 + 32);
    [v20 setGeohashOverride:v43];

    id v21 = *(id *)(a1 + 32);
    [v21 setPreferredPathRoutingEnabledStatus:v42];

    id v22 = *(id *)(a1 + 32);
    [v22 setPrivateAccessTokensEnabledStatus:v41];

    id v23 = *(id *)(a1 + 32);
    [v23 setPrivateAccessTokensAllowTools:v40];

    id v24 = *(id *)(a1 + 32);
    [v24 setInProcessFlowDivert:v39];

    id v25 = *(id *)(a1 + 32);
    [v25 setProxyTrafficState:v3];

    id v26 = *(id *)(a1 + 32);
    [v26 setUserTier:v4];

    id v27 = *(id *)(a1 + 32);
    [v27 setProxyAccountType:v5];

    id v28 = *(id *)(a1 + 32);
    [v28 setProxyAccountUnlimited:v6];

    id v29 = *(id *)(a1 + 32);
    [v29 setUserPreferredTier:v7];

    id v30 = *(id *)(a1 + 32);
    [v30 setSubscriberEnabledFromNonSettingsApp:v8];

    id v31 = *(id *)(a1 + 32);
    [v31 setLastPrivateCloudComputeEnvironment:v9];

    id v32 = *(id *)(a1 + 32);
    id v33 = (void *)objc_claimAutoreleasedReturnValue([v32 configServerHost]);
    *(_BYTE *)(a1 + 10) = [v33 isEqualToString:@"mask-api.icloud.com"] ^ 1;

    sub_100088828(a1);
    sub_100086A34(a1);
    sub_100087CDC((id *)a1, v34, v35);
    uint64_t v37 = NPGetInternalQueue(v36);
    id v38 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v37);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100088AFC;
    block[3] = &unk_1000F9428;
    void block[4] = a1;
    void block[5] = v47;
    dispatch_async(v38, block);

    _Block_object_dispose(v47, 8);
  }

void sub_100088810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_100088828(uint64_t a1)
{
  id v15 = objc_alloc_init(&OBJC_CLASS___NSURLSessionDelegate);
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 _socketStreamProperties]);
  if (v3)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 _socketStreamProperties]);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v4));
  }

  else
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  }

  [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
  objc_msgSend(v2, "set_socketStreamProperties:", v5);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) urlRequestTimeout]);
  [v6 doubleValue];
  double v8 = v7;

  if (v8 <= 0.0)
  {
    [v2 setTimeoutIntervalForResource:30.0];
  }

  else
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) urlRequestTimeout]);
    [v9 doubleValue];
    objc_msgSend(v2, "setTimeoutIntervalForResource:");
  }

  objc_msgSend(v2, "set_loggingPrivacyLevel:", 1);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) configServerHost]);
  [v15 setValidationHostname:v10];

  objc_msgSend(v15, "setIgnoreInvalidCerts:", objc_msgSend(*(id *)(a1 + 32), "ignoreInvalidCerts"));
  uint64_t v11 = *(void **)(a1 + 88);
  if (v11) {
    [v11 invalidateAndCancel];
  }
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSOperationQueue mainQueue](&OBJC_CLASS___NSOperationQueue, "mainQueue"));
  uint64_t v13 = objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v2,  v15,  v12));
  uint64_t v14 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v13;

  [*(id *)(a1 + 88) setSessionDescription:@"PrivacyProxyConfigurationFetch"];
}

void sub_100088A08(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configEnabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088A64(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 88);
  if (v2)
  {
    [v2 invalidateAndCancel];
    unint64_t v3 = *(void **)(a1 + 88);
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  }

void sub_100088AA0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configDisabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088AFC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configurationRestart:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088B58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained cloudSubscriptionChanged:*(unsigned __int8 *)(a1 + 48) configManager:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088BB8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained suspendPrivacyProxyTemporarily:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088C14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained resumePrivacyProxy:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088C70(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configUpdated:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088CCC(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.configurationFetched");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_100088DA8;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100088D90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100088DA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configFetched:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088E04(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained proxyTokenFetchEnabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088E60(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained proxyTokenFetchDisabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088EBC(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.authenticationInfoUpdated");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_100088F98;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100088F80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100088F98(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained authInfoChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100088FF4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained userTierChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

id sub_100089050(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained userPreferredTierChanged:v4];

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_1000890E4;
  v7[3] = &unk_1000FA170;
  uint64_t v5 = *(void **)(a1 + 32);
  void v7[4] = *(void *)(a1 + 40);
  return [v5 refreshConfigurationWithReason:8 completionHandler:v7];
}

void sub_1000890E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000890F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained effectiveUserTierChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100089154(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.proxiesInfoUpdated");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_100089230;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100089218( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100089230(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained proxyInfoChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10008928C(void *a1, char a2)
{
  if (a1)
  {
    v12[0] = 0LL;
    v12[1] = v12;
    v12[2] = 0x3032000000LL;
    v12[3] = sub_100086D74;
    void v12[4] = sub_100086D84;
    id v13 = (id)os_transaction_create("com.apple.networkserviceproxy.policiesUpdated");
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a1 mergeProxyTrafficStateWithCurrentPolicy]);
    uint64_t v5 = NPGetInternalQueue(v4);
    id v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    v8[2] = sub_1000893A0;
    v8[3] = &unk_1000FA7E0;
    void v8[4] = a1;
    id v9 = v4;
    char v11 = a2;
    uint64_t v10 = v12;
    id v7 = v4;
    dispatch_async(v6, v8);

    _Block_object_dispose(v12, 8);
  }

void sub_100089388( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000893A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained policiesUpdated:v4 policy:*(void *)(a1 + 40) resolverInfoChanged:*(unsigned __int8 *)(a1 + 56)];

  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100089404(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.geohashSettingsChanged");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_1000894E0;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_1000894C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000894E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained geohashSettingsChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_10008953C(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.configEpochChanged");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_100089618;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100089600( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100089618(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained configEpochChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_100089674(uint64_t a1)
{
  if (a1)
  {
    v5[0] = 0LL;
    v5[1] = v5;
    v5[2] = 0x3032000000LL;
    v5[3] = sub_100086D74;
    v5[4] = sub_100086D84;
    id v6 = (id)os_transaction_create("com.apple.networkserviceproxy.privateAccessTokensChanged");
    uint64_t v2 = NPGetInternalQueue(v6);
    unint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_100089750;
    v4[3] = &unk_1000F9428;
    v4[4] = a1;
    void v4[5] = v5;
    dispatch_async(v3, v4);

    _Block_object_dispose(v5, 8);
  }

void sub_100089738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100089750(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  [WeakRetained privateAccessTokensEnabledChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0LL;
}

void sub_1000897AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = "failed";
    if (v3) {
      id v7 = "successfully";
    }
    int v10 = 136315138;
    char v11 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Trial configuration refresh completed %s",  (uint8_t *)&v10,  0xCu);
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;
}

NSMutableArray *sub_100089884(NSMutableArray *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount]) {
      a1 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 0LL);
    }
    else {
      a1 = 0LL;
    }
    if ([v4 conditionsCount])
    {
      unint64_t v5 = 0LL;
      do
      {
        id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  [v4 conditionsAtIndex:v5]));
        -[NSMutableArray addObject:](a1, "addObject:", v6);

        ++v5;
      }

      while (v5 < (unint64_t)[v4 conditionsCount]);
    }
  }

  return a1;
}

id *sub_100089A94(id *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    if ([a1 effectiveUserTier])
    {
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1[4], "proxyConfiguration", 0));
      unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 policyTierMaps]);

      id v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v15;
        while (2)
        {
          for (CFIndex i = 0LL; i != v7; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v15 != v8) {
              objc_enumerationMutation(v5);
            }
            int v10 = *(void **)(*((void *)&v14 + 1) + 8LL * (void)i);
            unsigned int v11 = [v10 tier];
            if (v11 == [v1 effectiveUserTier])
            {
              uint64_t v1 = (id *)objc_claimAutoreleasedReturnValue([v10 policy]);
              goto LABEL_13;
            }
          }

          id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
          if (v7) {
            continue;
          }
          break;
        }
      }
    }

    else
    {
      uint64_t v13 = nplog_obj(0LL, v2, v3);
      unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        id v20 = "-[NSPConfigurationManager configuredPrivacyProxyPolicy]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v5,  OS_LOG_TYPE_FAULT,  "%s called with null self.effectiveUserTier",  buf,  0xCu);
      }
    }

    uint64_t v1 = 0LL;
LABEL_13:
  }

  return v1;
}

uint64_t sub_10008A5B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = [v5 accessTokenTypesCount];
    if (v7 == [v6 accessTokenTypesCount])
    {
      if ([v5 accessTokenTypesCount] && objc_msgSend(v5, "accessTokenTypesCount"))
      {
        unint64_t v8 = 0LL;
        do
        {
          unsigned int v9 = [v5 accessTokenTypesAtIndex:v8];
          BOOL v10 = v9 == [v6 accessTokenTypesAtIndex:v8];
          a1 = v10;
          if (!v10) {
            break;
          }
          ++v8;
        }

        while (v8 < (unint64_t)[v5 accessTokenTypesCount]);
      }

      else
      {
        a1 = 1LL;
      }
    }

    else
    {
      a1 = 0LL;
    }
  }

  return a1;
}

LABEL_250:
LABEL_251:
  v325 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v689 = (void *)objc_claimAutoreleasedReturnValue([v325 fallbackPathWeights]);

  v326 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v705 = (id)objc_claimAutoreleasedReturnValue([v326 fallbackPathWeights]);

  v327 = [v689 count];
  __int16 v328 = [v705 count];
  if (v327 == v328)
  {
    if (![v689 count]) {
      goto LABEL_588;
    }
    v790 = 0u;
    v789 = 0u;
    v788 = 0u;
    v787 = 0u;
    v684 = v689;
    v699 = (char *)[v684 countByEnumeratingWithState:&v787 objects:v826 count:16];
    if (!v699) {
      goto LABEL_587;
    }
    v694 = *(void *)v788;
    while (1)
    {
      v331 = 0LL;
LABEL_256:
      if (*(void *)v788 != v694)
      {
        v332 = v331;
        objc_enumerationMutation(v684);
        v331 = v332;
      }

      v711 = v331;
      v333 = *(void **)(*((void *)&v787 + 1) + 8LL * (void)v331);
      v783 = 0u;
      v784 = 0u;
      v785 = 0u;
      v786 = 0u;
      v719 = v705;
      v334 = [v719 countByEnumeratingWithState:&v783 objects:v825 count:16];
      if (!v334)
      {
LABEL_584:

        v637 = nplog_obj(v634, v635, v636);
        v638 = (os_log_s *)objc_claimAutoreleasedReturnValue(v637);
        if (os_log_type_enabled(v638, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v684;
          _os_log_impl( (void *)&_mh_execute_header,  v638,  OS_LOG_TYPE_DEFAULT,  "fallback proxy path updated to %@",  (uint8_t *)&buf,  0xCu);
        }

        sub_100089154((uint64_t)v679);
        v663 = 1;
        goto LABEL_587;
      }

      objc = *(id *)v784;
LABEL_260:
      v335 = 0LL;
      while (1)
      {
        if (*(id *)v784 != objc) {
          objc_enumerationMutation(v719);
        }
        v336 = *(void **)(*((void *)&v783 + 1) + 8 * v335);
        v337 = [v333 weight];
        if (v337 == [v336 weight])
        {
          v338 = [v333 proxiesCount];
          if (v338 == [v336 proxiesCount]) {
            break;
          }
        }

LABEL_270:
        if ((id)++v335 == v334)
        {
          v334 = [v719 countByEnumeratingWithState:&v783 objects:v825 count:16];
          if (v334) {
            goto LABEL_260;
          }
          goto LABEL_584;
        }
      }

      if ([v333 proxiesCount]) {
        break;
      }
LABEL_273:

      v331 = v711 + 1;
      if (v711 + 1 != v699) {
        goto LABEL_256;
      }
      v699 = (char *)[v684 countByEnumeratingWithState:&v787 objects:v826 count:16];
      if (!v699)
      {
LABEL_587:

        goto LABEL_588;
      }
    }

    v339 = 0LL;
    while (1)
    {
      v342 = (void *)objc_claimAutoreleasedReturnValue([v340 proxyURL]);
      v343 = (void *)objc_claimAutoreleasedReturnValue([v341 proxyURL]);
      v344 = [v342 isEqualToString:v343];

      if ((v344 & 1) == 0) {
        goto LABEL_270;
      }
    }
  }

  v481 = nplog_obj(v328, v329, v330);
  v482 = (os_log_s *)objc_claimAutoreleasedReturnValue(v481);
  if (os_log_type_enabled(v482, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v689;
    _os_log_impl( (void *)&_mh_execute_header,  v482,  OS_LOG_TYPE_DEFAULT,  "fallback proxy path list updated to %@",  (uint8_t *)&buf,  0xCu);
  }

  sub_100089154((uint64_t)v679);
  v663 = 1;
LABEL_588:

LABEL_289:
  v359 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v658 = (void *)objc_claimAutoreleasedReturnValue([v359 resolvers]);

  v360 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v660 = (void *)objc_claimAutoreleasedReturnValue([v360 resolvers]);

  v361 = [v658 count];
  v362 = [v660 count];
  if (v361 == v362)
  {
    if ([v658 count])
    {
      v782 = 0u;
      v780 = 0u;
      v781 = 0u;
      v779 = 0u;
      v712 = v658;
      objd = [v712 countByEnumeratingWithState:&v779 objects:v824 count:16];
      if (objd)
      {
        v720 = *(id *)v780;
        while (2)
        {
          for (CFIndex i = 0LL; i != objd; CFIndex i = (char *)i + 1)
          {
            if (*(id *)v780 != v720) {
              objc_enumerationMutation(v712);
            }
            v366 = *(void **)(*((void *)&v779 + 1) + 8LL * (void)i);
            v775 = 0u;
            v776 = 0u;
            v777 = 0u;
            v778 = 0u;
            v367 = v660;
            v368 = [v367 countByEnumeratingWithState:&v775 objects:v823 count:16];
            if (!v368)
            {

LABEL_359:
              v416 = nplog_obj(v382, v383, v384);
              v417 = (os_log_s *)objc_claimAutoreleasedReturnValue(v416);
              if (os_log_type_enabled(v417, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v712;
                _os_log_impl( (void *)&_mh_execute_header,  v417,  OS_LOG_TYPE_DEFAULT,  "resolver info updated to %@",  (uint8_t *)&buf,  0xCu);
              }

              sub_10008928C(v679, 1);
              goto LABEL_362;
            }

            v369 = 0;
            v370 = *(void *)v776;
            do
            {
              for (j = 0LL; j != v368; j = (char *)j + 1)
              {
                if (*(void *)v776 != v370) {
                  objc_enumerationMutation(v367);
                }
                v372 = *(void **)(*((void *)&v775 + 1) + 8LL * (void)j);
                v373 = (void *)objc_claimAutoreleasedReturnValue([v366 dohURL]);
                v374 = (void *)objc_claimAutoreleasedReturnValue([v372 dohURL]);
                v375 = v373;
                v376 = v374;
                v377 = (void *)v376;

                v378 = (void *)objc_claimAutoreleasedReturnValue([v366 obliviousDoHConfig]);
                v379 = (void *)objc_claimAutoreleasedReturnValue([v372 obliviousDoHConfig]);
                v375 = v378;
                v380 = v379;
                v377 = (void *)v380;
                if (!(v375 | v380) || v375 && v380 && [(id)v375 isEqual:v380])
                {

                  v381 = [v366 weight];
                  v369 |= v381 == [v372 weight];
                }

                else
                {
LABEL_311:
                }
              }

              v368 = [v367 countByEnumeratingWithState:&v775 objects:v823 count:16];
            }

            while (v368);

            if ((v369 & 1) == 0) {
              goto LABEL_359;
            }
          }

          objd = [v712 countByEnumeratingWithState:&v779 objects:v824 count:16];
          if (objd) {
            continue;
          }
          break;
        }
      }
    }

    v773 = 0u;
    v774 = 0u;
    v771 = 0u;
    v772 = 0u;
    v385 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
    obje = (id)objc_claimAutoreleasedReturnValue([v385 policyTierMaps]);

    v721 = [obje countByEnumeratingWithState:&v771 objects:v822 count:16];
    if (v721)
    {
      v386 = 0LL;
      v387 = 0LL;
      v713 = *(id *)v772;
      while (1)
      {
        for (k = 0LL; k != v721; k = (char *)k + 1)
        {
          if (*(id *)v772 != v713) {
            objc_enumerationMutation(obje);
          }
          v389 = *(void **)(*((void *)&v771 + 1) + 8LL * (void)k);
          v767 = 0u;
          v768 = 0u;
          v769 = 0u;
          v770 = 0u;
          v390 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
          v391 = (void *)objc_claimAutoreleasedReturnValue([v390 policyTierMaps]);

          v392 = [v391 countByEnumeratingWithState:&v767 objects:v821 count:16];
          if (!v392) {
            goto LABEL_343;
          }
          v393 = *(void *)v768;
          while (2)
          {
            for (m = 0LL; m != v392; m = (char *)m + 1)
            {
              if (*(void *)v768 != v393) {
                objc_enumerationMutation(v391);
              }
              v395 = *(void **)(*((void *)&v767 + 1) + 8LL * (void)m);
              v396 = [v389 tier];
              if (v396 == [v395 tier])
              {
                v397 = (void *)objc_claimAutoreleasedReturnValue([v389 policy]);

                v398 = (void *)objc_claimAutoreleasedReturnValue([v395 policy]);
                v399 = [v397 conditionsCount];
                v400 = [v398 conditionsCount];
                if (v399 == v400)
                {
                  if (![v397 conditionsCount] || !objc_msgSend(v397, "conditionsCount"))
                  {
LABEL_342:
                    v387 = v398;
                    v386 = v397;
                    goto LABEL_343;
                  }

                  v403 = 0LL;
                  while (1)
                  {
                    v404 = *((_DWORD *)[v397 conditions] + v403);
                    v405 = [v398 conditionsCount];
                    if (!v405) {
                      break;
                    }
                    v408 = 0LL;
                    while (*((_DWORD *)[v398 conditions] + v408) != v404)
                    {
                      v405 = [v398 conditionsCount];
                    }
                  }

LABEL_349:
                  v411 = nplog_obj(v405, v406, v407);
                  v412 = (os_log_s *)objc_claimAutoreleasedReturnValue(v411);
                  if (os_log_type_enabled(v412, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf) = 138412290;
                    *(void *)((char *)&buf + 4) = v397;
                    goto LABEL_351;
                  }
                }

                else
                {
                  v639 = nplog_obj(v400, v401, v402);
                  v412 = (os_log_s *)objc_claimAutoreleasedReturnValue(v639);
                  if (os_log_type_enabled(v412, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf) = 138412290;
                    *(void *)((char *)&buf + 4) = v397;
LABEL_351:
                    _os_log_impl( (void *)&_mh_execute_header,  v412,  OS_LOG_TYPE_DEFAULT,  "policy information updated to %@",  (uint8_t *)&buf,  0xCu);
                  }
                }

                sub_10008928C(v679, 0);
                v663 = 1;
                goto LABEL_357;
              }
            }

            v392 = [v391 countByEnumeratingWithState:&v767 objects:v821 count:16];
            if (v392) {
              continue;
            }
            break;
          }

LABEL_343:
        }

        v721 = [obje countByEnumeratingWithState:&v771 objects:v822 count:16];
        if (!v721) {
          goto LABEL_354;
        }
      }
    }

    v386 = 0LL;
    v387 = 0LL;
LABEL_354:

    v413 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyTrafficState](v678, "proxyTrafficState"));
    v414 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyTrafficState]);
    v415 = sub_10008EE68(v413, v414);

    if (v415)
    {
      sub_10008928C(v679, 0);
      v663 = 1;
    }

    v398 = v387;
    v397 = v386;
LABEL_357:
  }

  else
  {
    v409 = nplog_obj(v362, v363, v364);
    v410 = (os_log_s *)objc_claimAutoreleasedReturnValue(v409);
    if (os_log_type_enabled(v410, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v658;
      _os_log_impl( (void *)&_mh_execute_header,  v410,  OS_LOG_TYPE_DEFAULT,  "resolver info updated to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_10008928C(v679, 1);
LABEL_362:
    v663 = 1;
  }

  v418 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v656 = (void *)objc_claimAutoreleasedReturnValue([v418 obliviousConfigs]);

  v419 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v654 = (void *)objc_claimAutoreleasedReturnValue([v419 obliviousConfigs]);

  v420 = [v656 count];
  v421 = [v654 count];
  if (v420 == v421)
  {
    if ([v656 count])
    {
      v765 = 0u;
      v766 = 0u;
      v763 = 0u;
      v764 = 0u;
      v646 = v656;
      v650 = [v646 countByEnumeratingWithState:&v763 objects:v820 count:16];
      if (!v650) {
        goto LABEL_454;
      }
      v648 = *(void *)v764;
LABEL_367:
      v424 = 0LL;
LABEL_368:
      if (*(void *)v764 != v648)
      {
        v425 = v424;
        objc_enumerationMutation(v646);
        v424 = v425;
      }

      v652 = v424;
      v695 = *(void **)(*((void *)&v763 + 1) + 8 * v424);
      v759 = 0u;
      v760 = 0u;
      v761 = 0u;
      v762 = 0u;
      v676 = v654;
      v685 = [v676 countByEnumeratingWithState:&v759 objects:v819 count:16];
      if (v685)
      {
        v662 = 0;
        v681 = *(void *)v760;
        while (1)
        {
          v426 = 0LL;
          do
          {
            if (*(void *)v760 != v681)
            {
              v427 = v426;
              objc_enumerationMutation(v676);
              v426 = v427;
            }

            v690 = v426;
            v700 = *(void **)(*((void *)&v759 + 1) + 8 * v426);
            v428 = (void *)objc_claimAutoreleasedReturnValue([v695 obliviousHTTPConfig]);
            v429 = (void *)objc_claimAutoreleasedReturnValue([v700 obliviousHTTPConfig]);
            v430 = v428;
            v431 = v429;
            v432 = (void *)v431;
            v706 = (id)v430;
            v714 = (id)v431;
            if (v430 | v431)
            {
              v436 = (void *)v431;
              if (!v430) {
                goto LABEL_435;
              }
              v436 = (void *)v431;
              if (!v431) {
                goto LABEL_435;
              }
              v475 = [(id)v430 isEqual:v431];
              v432 = v714;
              v436 = v714;
              if (!v475) {
                goto LABEL_435;
              }
            }

            v433 = (void *)objc_claimAutoreleasedReturnValue([v695 transparencyKeyBundle]);
            v434 = (void *)objc_claimAutoreleasedReturnValue([v700 transparencyKeyBundle]);
            v430 = v433;
            v435 = v434;
            v436 = (void *)v435;
            if (v430 | v435)
            {
              v441 = (void *)v435;
              v439 = v430;
              if (!v430) {
                goto LABEL_434;
              }
              v441 = (void *)v435;
              v439 = v430;
              if (!v435) {
                goto LABEL_434;
              }
              v441 = (void *)v435;
              v439 = v430;
            }

            v437 = (void *)objc_claimAutoreleasedReturnValue([v695 transparencyProof]);
            v438 = (void *)objc_claimAutoreleasedReturnValue([v700 transparencyProof]);
            v439 = v437;
            v440 = v438;
            v441 = (void *)v440;
            if (v439 | v440)
            {
              v446 = (void *)v440;
              v444 = v439;
              if (!v439) {
                goto LABEL_433;
              }
              v446 = (void *)v440;
              v444 = v439;
              if (!v440) {
                goto LABEL_433;
              }
              v446 = (void *)v440;
              v444 = v439;
            }

            v442 = (void *)objc_claimAutoreleasedReturnValue([v695 transparencyInternalProof]);
            v443 = (void *)objc_claimAutoreleasedReturnValue([v700 transparencyInternalProof]);
            v444 = v442;
            v445 = v443;
            v446 = (void *)v445;
            if (v444 | v445 && (!v444 || !v445 || ![(id)v444 isEqual:v445]))
            {

LABEL_433:
LABEL_434:

LABEL_435:
LABEL_436:

              goto LABEL_437;
            }

            v447 = [v695 obliviousHTTPType];
            v448 = (void *)objc_claimAutoreleasedReturnValue([v695 obliviousTargets]);
            v449 = [v448 count];
            v450 = (void *)objc_claimAutoreleasedReturnValue([v700 obliviousTargets]);
            v451 = v449 == [v450 count];

            if (!v451) {
              goto LABEL_438;
            }
            v757 = 0u;
            v758 = 0u;
            v755 = 0u;
            v756 = 0u;
            v706 = (id)objc_claimAutoreleasedReturnValue([v695 obliviousTargets]);
            v671 = [v706 countByEnumeratingWithState:&v755 objects:v818 count:16];
            if (!v671) {
              goto LABEL_416;
            }
            v669 = *(void *)v756;
            while (2)
            {
              v452 = 0LL;
              while (2)
              {
                if (*(void *)v756 != v669)
                {
                  v453 = v452;
                  objc_enumerationMutation(v706);
                  v452 = v453;
                }

                v673 = v452;
                v454 = *(void **)(*((void *)&v755 + 1) + 8 * v452);
                v751 = 0u;
                v752 = 0u;
                v753 = 0u;
                v754 = 0u;
                v714 = (id)objc_claimAutoreleasedReturnValue([v700 obliviousTargets]);
                objf = [v714 countByEnumeratingWithState:&v751 objects:v817 count:16];
                if (!objf) {
                  goto LABEL_436;
                }
                v722 = *(id *)v752;
LABEL_388:
                v455 = 0LL;
                while (1)
                {
                  if (*(id *)v752 != v722) {
                    objc_enumerationMutation(v714);
                  }
                  v456 = *(void **)(*((void *)&v751 + 1) + 8 * v455);
                  v457 = (void *)objc_claimAutoreleasedReturnValue([v454 targetHost]);
                  v458 = (void *)objc_claimAutoreleasedReturnValue([v456 targetHost]);
                  v459 = v457;
                  v460 = v458;
                  v461 = (void *)v460;
                  if (v459 | v460)
                  {
                    v466 = (void *)v460;
                    v464 = v459;
                    if (!v459) {
                      goto LABEL_410;
                    }
                    v466 = (void *)v460;
                    v464 = v459;
                    if (!v460) {
                      goto LABEL_410;
                    }
                    v466 = (void *)v460;
                    v464 = v459;
                  }

                  v462 = (void *)objc_claimAutoreleasedReturnValue([v454 proxyURLPath]);
                  v463 = (void *)objc_claimAutoreleasedReturnValue([v456 proxyURLPath]);
                  v464 = v462;
                  v465 = v463;
                  v466 = (void *)v465;
                  if (v464 | v465)
                  {
                    v471 = (void *)v465;
                    v469 = v464;
                    if (!v464) {
                      goto LABEL_409;
                    }
                    v471 = (void *)v465;
                    v469 = v464;
                    if (!v465) {
                      goto LABEL_409;
                    }
                    v471 = (void *)v465;
                    v469 = v464;
                  }

                  v467 = (void *)objc_claimAutoreleasedReturnValue([v454 processes]);
                  v468 = (void *)objc_claimAutoreleasedReturnValue([v456 processes]);
                  v469 = v467;
                  v470 = v468;
                  v471 = (void *)v470;
                  if (v469 | v470
                    && (!v469 || !v470 || ([(id)v469 isEqual:v470] & 1) == 0))
                  {

LABEL_409:
LABEL_410:

                    goto LABEL_411;
                  }

                  v472 = [v454 proxyIndex];
                  v473 = [v454 weight];
                  v474 = v473 == [v456 weight];

                  if (v474) {
                    break;
                  }
LABEL_411:
                  if (objf == (id)++v455)
                  {
                    objf = [v714 countByEnumeratingWithState:&v751 objects:v817 count:16];
                    if (objf) {
                      goto LABEL_388;
                    }
                    goto LABEL_436;
                  }
                }

                v452 = v673 + 1;
                if ((id)(v673 + 1) != v671) {
                  continue;
                }
                break;
              }

              v671 = [v706 countByEnumeratingWithState:&v755 objects:v818 count:16];
              if (v671) {
                continue;
              }
              break;
            }

LABEL_416:
            v662 = 1;
LABEL_437:

LABEL_438:
            v426 = v690 + 1;
          }

          while ((id)(v690 + 1) != v685);
          v685 = [v676 countByEnumeratingWithState:&v759 objects:v819 count:16];
          if (!v685)
          {

            if ((v662 & 1) == 0) {
              goto LABEL_451;
            }
            v424 = v652 + 1;
            if ((id)(v652 + 1) == v650)
            {
              v650 = [v646 countByEnumeratingWithState:&v763 objects:v820 count:16];
              if (!v650) {
                goto LABEL_454;
              }
              goto LABEL_367;
            }

            goto LABEL_368;
          }
        }
      }

LABEL_451:
      v483 = nplog_obj(v476, v477, v478);
      v484 = (os_log_s *)objc_claimAutoreleasedReturnValue(v483);
      if (os_log_type_enabled(v484, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v646;
        _os_log_impl( (void *)&_mh_execute_header,  v484,  OS_LOG_TYPE_DEFAULT,  "oblivious configs updated to %@",  (uint8_t *)&buf,  0xCu);
      }

      sub_100089154((uint64_t)v679);
      v663 = 1;
LABEL_454:
    }
  }

  else
  {
    v479 = nplog_obj(v421, v422, v423);
    v480 = (os_log_s *)objc_claimAutoreleasedReturnValue(v479);
    if (os_log_type_enabled(v480, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v656;
      _os_log_impl( (void *)&_mh_execute_header,  v480,  OS_LOG_TYPE_DEFAULT,  "oblivious configs updated to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089154((uint64_t)v679);
    v663 = 1;
  }

  v485 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v486 = [v485 hasPreferredPathEnabledPercentage];
  v487 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  if (v486 == [v487 hasPreferredPathEnabledPercentage])
  {
    v491 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
    v492 = [v491 preferredPathEnabledPercentage];
    v493 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
    LOBYTE(v492) = v492 == [v493 preferredPathEnabledPercentage];

    if ((v492 & 1) != 0) {
      goto LABEL_461;
    }
  }

  else
  {
  }

  v494 = nplog_obj(v488, v489, v490);
  v495 = (os_log_s *)objc_claimAutoreleasedReturnValue(v494);
  if (os_log_type_enabled(v495, OS_LOG_TYPE_DEFAULT))
  {
    v496 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
    v497 = [v496 hasPreferredPathEnabledPercentage];
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v497;
    _os_log_impl( (void *)&_mh_execute_header,  v495,  OS_LOG_TYPE_DEFAULT,  "preferred path enabled percentage changed to %u",  (uint8_t *)&buf,  8u);
  }

  v663 = 1;
LABEL_461:
  v498 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  v701 = (void *)objc_claimAutoreleasedReturnValue([v498 proxiedContentMaps]);

  v499 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v715 = (id)objc_claimAutoreleasedReturnValue([v499 proxiedContentMaps]);

  v500 = [v701 count];
  v501 = [v715 count];
  if (v500 == v501)
  {
    if ([v701 count])
    {
      v749 = 0u;
      v750 = 0u;
      v747 = 0u;
      v748 = 0u;
      v686 = v701;
      v696 = (char *)[v686 countByEnumeratingWithState:&v747 objects:v816 count:16];
      if (!v696) {
        goto LABEL_519;
      }
      v691 = *(void *)v748;
LABEL_465:
      v504 = 0LL;
LABEL_466:
      if (*(void *)v748 != v691)
      {
        v505 = v504;
        objc_enumerationMutation(v686);
        v504 = v505;
      }

      v707 = v504;
      v506 = *(void **)(*((void *)&v747 + 1) + 8LL * (void)v504);
      v743 = 0u;
      v744 = 0u;
      v745 = 0u;
      v746 = 0u;
      objg = v715;
      v507 = [objg countByEnumeratingWithState:&v743 objects:v815 count:16];
      if (v507)
      {
        v508 = 0LL;
        v509 = *(void *)v744;
        while (1)
        {
          v510 = 0LL;
          do
          {
            v511 = v508;
            if (*(void *)v744 != v509) {
              objc_enumerationMutation(objg);
            }
            v512 = *(void **)(*((void *)&v743 + 1) + 8LL * (void)v510);
            v513 = (void *)objc_claimAutoreleasedReturnValue([v506 identifier]);
            v514 = (void *)objc_claimAutoreleasedReturnValue([v512 identifier]);
            v515 = v513;
            v516 = v514;
            v517 = (void *)v516;
            if (v515 | v516 && (!v515 || !v516 || ![(id)v515 isEqual:v516]))
            {
              v529 = v517;
              v527 = v515;
LABEL_494:

LABEL_495:
              v508 = v511;
              goto LABEL_496;
            }

            v518 = [v506 enabled];
            v519 = [v506 systemProcessOnly];
            v520 = [v506 matchExactHostnames];
            v521 = [v506 isPrivacyProxy];
            v522 = [v506 proxiesCount];
            if (v522 != [v512 proxiesCount]) {
              goto LABEL_495;
            }
            v523 = [v506 hasResolver];
            v524 = [v506 resolver];
            v525 = (void *)objc_claimAutoreleasedReturnValue([v506 hostnames]);
            v526 = (void *)objc_claimAutoreleasedReturnValue([v512 hostnames]);
            v527 = v525;
            v528 = v526;
            v529 = (void *)v528;
            if (v527 | v528 && (!v527 || !v528 || ![(id)v527 isEqual:v528]))
            {
              v517 = v529;
              v515 = v527;
              goto LABEL_494;
            }

            v530 = (void *)objc_claimAutoreleasedReturnValue([v506 processes]);
            v531 = (void *)objc_claimAutoreleasedReturnValue([v512 processes]);
            v515 = v530;
            v532 = v531;
            v517 = (void *)v532;
            if (v515 | v532 && (!v515 || !v532 || ([(id)v515 isEqual:v532] & 1) == 0))
            {

              goto LABEL_494;
            }

            v723 = [v506 hasPercentEnabled];
            v724 = [v506 percentEnabled];
            v725 = v724 == [v512 percentEnabled];

            if (!v725) {
              goto LABEL_495;
            }
            if ([v506 proxiesCount])
            {
              v533 = 0LL;
              while (1)
              {
                v534 = *((_DWORD *)[v506 proxies] + v533);
                if (v534 != *((_DWORD *)[v512 proxies] + v533)) {
                  goto LABEL_495;
                }
                ++v533;
                v508 = 1LL;
              }
            }

            v508 = 1LL;
LABEL_496:
            v510 = (char *)v510 + 1;
          }

          while (v510 != v507);
          v535 = [objg countByEnumeratingWithState:&v743 objects:v815 count:16];
          v507 = v535;
          if (!v535)
          {

            if ((v508 & 1) == 0) {
              goto LABEL_516;
            }
            v504 = v707 + 1;
            if (v707 + 1 == v696)
            {
              v696 = (char *)[v686 countByEnumeratingWithState:&v747 objects:v816 count:16];
              if (!v696) {
                goto LABEL_519;
              }
              goto LABEL_465;
            }

            goto LABEL_466;
          }
        }
      }

LABEL_516:
      v541 = nplog_obj(v536, v537, v538);
      v542 = (os_log_s *)objc_claimAutoreleasedReturnValue(v541);
      if (os_log_type_enabled(v542, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v686;
        _os_log_impl( (void *)&_mh_execute_header,  v542,  OS_LOG_TYPE_DEFAULT,  "proxied content maps updated to %@",  (uint8_t *)&buf,  0xCu);
      }

      sub_100089154((uint64_t)v679);
      v663 = 1;
LABEL_519:
    }
  }

  else
  {
    v539 = nplog_obj(v501, v502, v503);
    v540 = (os_log_s *)objc_claimAutoreleasedReturnValue(v539);
    if (os_log_type_enabled(v540, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v701;
      _os_log_impl( (void *)&_mh_execute_header,  v540,  OS_LOG_TYPE_DEFAULT,  "proxied content maps updated to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089154((uint64_t)v679);
    v663 = 1;
  }

  v543 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration geohashSharingEnabledStatus](v678, "geohashSharingEnabledStatus"));
  v544 = (void *)objc_claimAutoreleasedReturnValue([v677 geohashSharingEnabledStatus]);
  v545 = sub_10008EE68(v543, v544);

  if (v545)
  {
    v549 = nplog_obj(v546, v547, v548);
    v550 = (os_log_s *)objc_claimAutoreleasedReturnValue(v549);
    if (os_log_type_enabled(v550, OS_LOG_TYPE_DEFAULT))
    {
      v551 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration geohashSharingEnabledStatus](v678, "geohashSharingEnabledStatus"));
      v552 = [v551 BOOLValue];
      v553 = "disabled";
      if (v552) {
        v553 = "enabled";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v553;
      _os_log_impl( (void *)&_mh_execute_header,  v550,  OS_LOG_TYPE_DEFAULT,  "Geohash sharing preference changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089404((uint64_t)v679);
    v663 = 1;
  }

  v554 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration geohashOverride](v678, "geohashOverride"));
  v555 = (void *)objc_claimAutoreleasedReturnValue([v677 geohashOverride]);
  if (v554 == v555)
  {
  }

  else
  {
    v556 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration geohashOverride](v678, "geohashOverride"));
    v557 = (void *)objc_claimAutoreleasedReturnValue([v677 geohashOverride]);
    v558 = [v556 isEqualToString:v557];

    if ((v558 & 1) == 0)
    {
      v562 = nplog_obj(v559, v560, v561);
      v563 = (os_log_s *)objc_claimAutoreleasedReturnValue(v562);
      if (os_log_type_enabled(v563, OS_LOG_TYPE_DEFAULT))
      {
        v564 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration geohashOverride](v678, "geohashOverride"));
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v564;
        _os_log_impl( (void *)&_mh_execute_header,  v563,  OS_LOG_TYPE_DEFAULT,  "Geohash override changed to %@",  (uint8_t *)&buf,  0xCu);
      }

      sub_100089404((uint64_t)v679);
      v663 = 1;
    }
  }

  v565 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration epoch](v678, "epoch"));
  v566 = (void *)objc_claimAutoreleasedReturnValue([v677 epoch]);
  v567 = sub_10008EE68(v565, v566);

  if (v567)
  {
    v571 = nplog_obj(v568, v569, v570);
    v572 = (os_log_s *)objc_claimAutoreleasedReturnValue(v571);
    if (os_log_type_enabled(v572, OS_LOG_TYPE_DEFAULT))
    {
      v573 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration epoch](v678, "epoch"));
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v573;
      _os_log_impl( (void *)&_mh_execute_header,  v572,  OS_LOG_TYPE_DEFAULT,  "Configuration epoch changed to %@",  (uint8_t *)&buf,  0xCu);
    }

    sub_10008953C((uint64_t)v679);
    v663 = 1;
  }

  v574 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration preferredPathRoutingEnabledStatus](v678, "preferredPathRoutingEnabledStatus"));
  v575 = (void *)objc_claimAutoreleasedReturnValue([v677 preferredPathRoutingEnabledStatus]);
  v576 = sub_10008EE68(v574, v575);

  if (v576)
  {
    v580 = nplog_obj(v577, v578, v579);
    v581 = (os_log_s *)objc_claimAutoreleasedReturnValue(v580);
    if (os_log_type_enabled(v581, OS_LOG_TYPE_DEFAULT))
    {
      v582 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration preferredPathRoutingEnabledStatus](v678, "preferredPathRoutingEnabledStatus"));
      v583 = [v582 BOOLValue];
      v584 = "disabled";
      if (v583) {
        v584 = "enabled";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v584;
      _os_log_impl( (void *)&_mh_execute_header,  v581,  OS_LOG_TYPE_DEFAULT,  "Preferred path routing enabled changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    v663 = 1;
  }

  v585 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration privateAccessTokensEnabledStatus](v678, "privateAccessTokensEnabledStatus"));
  v586 = (void *)objc_claimAutoreleasedReturnValue([v677 privateAccessTokensEnabledStatus]);
  v587 = sub_10008EE68(v585, v586);

  if (v587)
  {
    v591 = nplog_obj(v588, v589, v590);
    v592 = (os_log_s *)objc_claimAutoreleasedReturnValue(v591);
    if (os_log_type_enabled(v592, OS_LOG_TYPE_DEFAULT))
    {
      v593 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration privateAccessTokensEnabledStatus](v678, "privateAccessTokensEnabledStatus"));
      v594 = [v593 BOOLValue];
      v595 = "disabled";
      if (v594) {
        v595 = "enabled";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v595;
      _os_log_impl( (void *)&_mh_execute_header,  v592,  OS_LOG_TYPE_DEFAULT,  "Private access tokens preference changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    sub_100089674((uint64_t)v679);
    v663 = 1;
  }

  v596 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration privateAccessTokensAllowTools](v678, "privateAccessTokensAllowTools"));
  v597 = (void *)objc_claimAutoreleasedReturnValue([v677 privateAccessTokensAllowTools]);
  v598 = sub_10008EE68(v596, v597);

  if (v598)
  {
    v602 = nplog_obj(v599, v600, v601);
    v603 = (os_log_s *)objc_claimAutoreleasedReturnValue(v602);
    if (os_log_type_enabled(v603, OS_LOG_TYPE_DEFAULT))
    {
      v604 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration privateAccessTokensAllowTools](v678, "privateAccessTokensAllowTools"));
      v605 = [v604 BOOLValue];
      v606 = "disallowed";
      if (v605) {
        v606 = "allowed";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v606;
      _os_log_impl( (void *)&_mh_execute_header,  v603,  OS_LOG_TYPE_DEFAULT,  "Private access tokens allow tools changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    v663 = 1;
  }

  v607 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration inProcessFlowDivert](v678, "inProcessFlowDivert"));
  v608 = (void *)objc_claimAutoreleasedReturnValue([v677 inProcessFlowDivert]);
  v609 = sub_10008EE68(v607, v608);

  if (v609)
  {
    v613 = nplog_obj(v610, v611, v612);
    v614 = (os_log_s *)objc_claimAutoreleasedReturnValue(v613);
    if (os_log_type_enabled(v614, OS_LOG_TYPE_DEFAULT))
    {
      v615 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration inProcessFlowDivert](v678, "inProcessFlowDivert"));
      v616 = [v615 BOOLValue];
      v617 = "disabled";
      if (v616) {
        v617 = "enabled";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v617;
      _os_log_impl( (void *)&_mh_execute_header,  v614,  OS_LOG_TYPE_DEFAULT,  "In-process flow divert support changed to %s",  (uint8_t *)&buf,  0xCu);
    }

    v663 = 1;
  }

  v618 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v678, "proxyConfiguration"));
  objh = (id)objc_claimAutoreleasedReturnValue([v618 trustedNetworkDiscoveredProxies]);

  v619 = (void *)objc_claimAutoreleasedReturnValue([v677 proxyConfiguration]);
  v620 = (void *)objc_claimAutoreleasedReturnValue([v619 trustedNetworkDiscoveredProxies]);

  v621 = [objh count];
  if (v621 == [v620 count])
  {
    if ([objh count])
    {
      v741 = 0u;
      v742 = 0u;
      v739 = 0u;
      v740 = 0u;
      v622 = objh;
      v623 = [v622 countByEnumeratingWithState:&v739 objects:v814 count:16];
      if (v623)
      {
        v624 = *(void *)v740;
        while (1)
        {
          v625 = 0LL;
LABEL_565:
          if (*(void *)v740 != v624) {
            objc_enumerationMutation(v622);
          }
          v626 = *(void **)(*((void *)&v739 + 1) + 8 * v625);
          v735 = 0u;
          v736 = 0u;
          v737 = 0u;
          v738 = 0u;
          v627 = v620;
          v628 = [v627 countByEnumeratingWithState:&v735 objects:v813 count:16];
          if (!v628) {
            break;
          }
          v629 = *(void *)v736;
LABEL_569:
          v630 = 0LL;
          while (1)
          {
            if (*(void *)v736 != v629) {
              objc_enumerationMutation(v627);
            }
            if (v628 == (id)++v630)
            {
              v628 = [v627 countByEnumeratingWithState:&v735 objects:v813 count:16];
              if (v628) {
                goto LABEL_569;
              }
              goto LABEL_580;
            }
          }

          if ((id)++v625 != v623) {
            goto LABEL_565;
          }
          v623 = [v622 countByEnumeratingWithState:&v739 objects:v814 count:16];
          if (!v623) {
            goto LABEL_581;
          }
        }

LABEL_580:
        sub_100089154((uint64_t)v679);
        v663 = 1;
      }

LABEL_581:
    }
  }

  else
  {
    sub_100089154((uint64_t)v679);
    v663 = 1;
  }

  v631 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration lastPrivateCloudComputeEnvironment](v678, "lastPrivateCloudComputeEnvironment"));
  v632 = (void *)objc_claimAutoreleasedReturnValue([v677 lastPrivateCloudComputeEnvironment]);
  v633 = sub_10008EE68(v631, v632);

  if (((v633 | v663) & 1) != 0) {
    goto LABEL_128;
  }
LABEL_137:
}

void sub_10008ED90(_Unwind_Exception *a1)
{
}

uint64_t sub_10008EDDC(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (id *)result;
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(result + 32) userTier]);
    if ([v2 unsignedIntegerValue] != (id)2)
    {
LABEL_5:

      return 1LL;
    }

    id WeakRetained = objc_loadWeakRetained(v1 + 3);
    if ([WeakRetained subscriberTierIsProhibited:v1])
    {

      goto LABEL_5;
    }

    id v4 = [v1 configurationSubscriberPoliciesCount];

    if (v4) {
      return 2LL;
    }
    else {
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_10008EE68(void *a1, void *a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a2;
  id v5 = (void *)v4;

  return v6;
}

void sub_10008FED4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

uint64_t sub_1000900C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100090460( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_100090478(uint64_t a1)
{
  if (a1 && !*(_BYTE *)(a1 + 10))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) interface]);
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([v2 interfaceName]);
  }

  else
  {
    uint64_t v1 = 0LL;
  }

  return v1;
}

void sub_100090548(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    id v5 = *(void **)(v4 + 32);
  }
  else {
    id v5 = 0LL;
  }
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 enabled]);
  unsigned int v7 = [v6 BOOLValue];

  if (v7)
  {
    unsigned int v9 = *(void **)(a1 + 32);
    if (v9) {
      unsigned int v9 = (void *)v9[4];
    }
    BOOL v10 = v9;
    unsigned int v11 = (void *)objc_claimAutoreleasedReturnValue([v10 configServerHost]);
    unsigned __int8 v12 = [v11 isEqualToString:@"mask-api.icloud.com"];
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13) {
      *(_BYTE *)(v13 + 10) = v12 ^ 1;
    }

    uint64_t v15 = NPGetInternalQueue(v14);
    __int128 v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v15);
    __int128 v17 = v16;
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 3221225472LL;
    v31[2] = sub_1000906F4;
    _OWORD v31[3] = &unk_1000F9450;
    v31[4] = *(void *)(a1 + 32);
    id v18 = v31;
  }

  else
  {
    uint64_t v19 = NPGetInternalQueue(v8);
    __int128 v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v19);
    __int128 v17 = v16;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100090744;
    block[3] = &unk_1000F9450;
    void block[4] = *(void *)(a1 + 32);
    id v18 = block;
  }

  dispatch_async(v16, v18);

  if (a2)
  {
    uint64_t v23 = nplog_obj(v20, v21, v22);
    id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v29 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Private cloud compute environment changed, forcing a configuration fetch",  v29,  2u);
    }

    uint64_t v25 = *(void *)(a1 + 32);
    if (v25) {
      id v26 = *(void **)(v25 + 32);
    }
    else {
      id v26 = 0LL;
    }
    [v26 setEtag:0];
  }

  sub_100086A34(*(void *)(a1 + 32));
  sub_100087CDC(*(id **)(a1 + 32), v27, v28);
}

void sub_1000906F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  id v5 = WeakRetained;
  [WeakRetained configEnabled:v4];
}

void sub_100090744(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = 0LL;
    id WeakRetained = 0LL;
  }

  id v5 = WeakRetained;
  [WeakRetained configDisabled:v4];
}

CFStringRef sub_100090A64(uint64_t a1, uint64_t a2)
{
  else {
    return *(&off_1000FA960 + a2 - 1);
  }
}

void sub_100090AA8(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    objc_initWeak(&location, WeakRetained);
    id v3 = objc_loadWeakRetained(WeakRetained + 3);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_100090BB0;
    v7[3] = &unk_1000FA880;
    objc_copyWeak(v10, &location);
    uint64_t v4 = *(void **)(a1 + 40);
    void v7[4] = *(void *)(a1 + 32);
    id v5 = v4;
    uint64_t v6 = *(void **)(a1 + 64);
    id v8 = v5;
    v10[1] = v6;
    id v9 = *(id *)(a1 + 48);
    [v3 requestAccessTokenWithCompletionHandler:v7];

    objc_destroyWeak(v10);
    objc_destroyWeak(&location);
  }
}

void sub_100090B94(_Unwind_Exception *a1)
{
}

void sub_100090BB0(uint64_t a1, uint64_t a2, void *a3)
{
  id v99 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    objc_initWeak(&location, WeakRetained);
    id v5 = sub_100090478(*(void *)(a1 + 32));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) etag]);
    uint64_t v8 = *(void *)(a1 + 64);
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472LL;
    uint64_t v101 = sub_100091698;
    uint64_t v102 = &unk_1000FA858;
    objc_copyWeak(&v104, &location);
    id v103 = *(id *)(a1 + 48);
    id v97 = v6;
    id v98 = v7;
    id v91 = v99;
    __int128 v92 = v100;
    id v9 = WeakRetained[4];
    id v89 = v9;
    if (v9)
    {
      id v96 = (void *)objc_claimAutoreleasedReturnValue([v9 createConfigFetchURLWithPath:0 timestamp:0]);
      if (v96)
      {
        if (qword_1001171E0 != -1) {
          dispatch_once(&qword_1001171E0, &stru_1000FA8C8);
        }
        uint64_t v14 = mach_absolute_time();
        id v15 = WeakRetained[11];
        *(void *)&__int128 v106 = _NSConcreteStackBlock;
        *((void *)&v106 + 1) = 3221225472LL;
        char v107 = sub_100091EFC;
        uint64_t v108 = &unk_1000FA8F0;
        id v109 = WeakRetained;
        id v16 = v96;
        id v110 = v16;
        id v111 = v92;
        uint64_t v112 = v8;
        uint64_t v113 = v14;
        id v17 = v16;
        id v95 = v97;
        id v94 = v98;
        id v18 = v15;
        id v93 = v91;
        id v90 = &v106;
        uint64_t v19 = NPGetInternalQueue(v90);
        uint64_t v20 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v19);
        dispatch_assert_queue_V2(v20);

        if (v18)
        {
          if (os_variant_has_internal_content("com.apple.networkserviceproxy"))
          {
            char v24 = sub_100092554((uint64_t)WeakRetained);
            uint64_t v25 = copyProductTypeString();
            id v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
            uint64_t v27 = copyOSNameString();
            uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
            uint64_t v29 = copyOSVersionString();
            id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
            uint64_t v31 = copyOSBuildString();
            uint64_t v32 = objc_claimAutoreleasedReturnValue(v31);
            id v33 = (void *)v32;
            if ((v24 & 5) == 1) {
              uint64_t v34 = @"<%@> <%@;%@;%@>";
            }
            else {
              uint64_t v34 = @"<%@> <%@;%@;%@;internal>";
            }
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  v34,  v26,  v28,  v30,  v32));

            if ((v24 - 3) <= 3u)
            {
              uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v17 host]);
              unsigned int v37 = [v36 isEqualToString:@"mask-api.icloud.com"];

              if (v37)
              {
                id v38 = (void *)objc_claimAutoreleasedReturnValue([v17 absoluteString]);
                id v39 = [v38 mutableCopy];

                objc_msgSend( v39,  "replaceOccurrencesOfString:withString:options:range:",  @"mask-api.icloud.com",  @"api-mask.us-west-1a.app.apple.com",  0,  0,  objc_msgSend(v39, "length"));
                id v40 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[11] delegate]);
                [v40 setValidationHostname:@"api-mask.us-west-1a.app.apple.com"];

                uint64_t v41 = objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v39));
                id v95 = 0LL;
                id v17 = (id)v41;
              }
            }

            __int16 v42 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[4] configServerHost]);
            *((_BYTE *)WeakRetained + 10) = [v42 isEqualToString:@"mask-api.icloud.com"] ^ 1;
          }

          else
          {
            uint64_t v43 = copyProductTypeString();
            __int16 v42 = (void *)objc_claimAutoreleasedReturnValue(v43);
            uint64_t v44 = copyOSNameString();
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
            uint64_t v46 = copyOSVersionString();
            uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
            uint64_t v48 = copyOSBuildString();
            id v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"<%@> <%@;%@;%@>",
                              v42,
                              v45,
                              v47,
                              v49));
          }

          if (!sub_100092554((uint64_t)WeakRetained) && (v8 == 10 || v8 == 5))
          {
            __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([v17 host]);
            unsigned int v65 = [v64 isEqualToString:@"mask-api.icloud.com"];

            if (v65)
            {
              __int128 v66 = (void *)objc_claimAutoreleasedReturnValue([v17 absoluteString]);
              id v67 = [v66 mutableCopy];

              objc_msgSend( v67,  "replaceOccurrencesOfString:withString:options:range:",  @"mask-api.icloud.com/",  @"gateway.icloud.com/mask-api/",  0,  0,  objc_msgSend(v67, "length"));
              uint64_t v68 = objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v67));

              uint64_t v72 = nplog_obj(v69, v70, v71);
              uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);
              if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
              {
                LOWORD(buf) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_INFO,  "Fetching configuration from backup location",  (uint8_t *)&buf,  2u);
              }

              id v17 = (id)v68;
            }
          }

          id v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableURLRequest requestWithURL:]( &OBJC_CLASS___NSMutableURLRequest,  "requestWithURL:",  v17));
          uint64_t v51 = v50;
          if (v94) {
            [v50 setValue:v94 forHTTPHeaderField:@"If-None-Match"];
          }
          if (v95) {
            [v51 setBoundInterfaceIdentifier:v95];
          }
          if (v35) {
            [v51 setValue:v35 forHTTPHeaderField:@"X-Mask-Client-Info"];
          }
          if (v93) {
            [v51 setValue:v93 forHTTPHeaderField:@"X-Mask-Subscription-Token"];
          }
          id v52 = WeakRetained[15];
          if (v52) {
            [v51 setValue:v52 forHTTPHeaderField:@"True-Client-Ip"];
          }
          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v53 currentCountryPlusTimezone]);

          if (v54) {
            [v51 setValue:v54 forHTTPHeaderField:@"Client-Region"];
          }
          if (v8)
          {
            uint64_t v55 = sub_100090A64((uint64_t)&OBJC_CLASS___NSPConfigurationManager, v8);
            uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
            [v51 setValue:v56 forHTTPHeaderField:@"X-Mask-Fetch-Reason"];
          }

          if ([WeakRetained effectiveUserTier] == (id)2
            && (id v57 = [WeakRetained policyIncludesUnlimited], (_DWORD)v57))
          {
            uint64_t v60 = nplog_obj(v57, v58, v59);
            __int128 v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
            {
              LOWORD(buf) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_INFO,  "Setting user tier in configuration request to SUBSCRIBER_UNLIMITED",  (uint8_t *)&buf,  2u);
            }

            __int128 v62 = @"SUBSCRIBER_UNLIMITED";
          }

          else
          {
            id v63 = [WeakRetained effectiveUserTier];
            if (v63 >= 3) {
              __int128 v62 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  v63));
            }
            else {
              __int128 v62 = *(&off_1000FA9C0 + (int)v63);
            }
          }

          uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[4] subscriberEnabledFromNonSettingsApp]);

          if (v74)
          {
            uint64_t v75 = objc_claimAutoreleasedReturnValue(-[__CFString stringByAppendingString:](v62, "stringByAppendingString:", @"; non-settings"));

            __int128 v62 = (__CFString *)v75;
          }

          [v51 setValue:v62 forHTTPHeaderField:@"X-Mask-User-Tier"];
          id v76 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%lu",  WeakRetained[10]));
          id v79 = v76;
          if (v76) {
            id v76 = [v51 setValue:v76 forHTTPHeaderField:@"Retry-Attempt"];
          }
          *(void *)&__int128 buf = 0LL;
          *((void *)&buf + 1) = &buf;
          uint64_t v120 = 0x3032000000LL;
          uint64_t v121 = sub_100086D74;
          id v122 = sub_100086D84;
          id v123 = 0LL;
          uint64_t v80 = nplog_obj(v76, v77, v78);
          uint64_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);
          if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v114) = 138412290;
            *(void *)((char *)&v114 + 4) = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Sending request for %@",  (uint8_t *)&v114,  0xCu);
          }

          *(void *)&__int128 v114 = _NSConcreteStackBlock;
          *((void *)&v114 + 1) = 3221225472LL;
          uint64_t v115 = sub_100092774;
          id v116 = &unk_1000FA940;
          p___int128 buf = &buf;
          id v117 = v90;
          __int128 v82 = (void *)objc_claimAutoreleasedReturnValue([v18 dataTaskWithRequest:v51 completionHandler:&v114]);
          objc_storeStrong((id *)(*((void *)&buf + 1) + 40LL), v82);
          [*(id *)(*((void *)&buf + 1) + 40) resume];

          _Block_object_dispose(&buf, 8);
        }

        else
        {
          uint64_t v87 = nplog_obj(v21, v22, v23);
          __int128 v88 = (os_log_s *)objc_claimAutoreleasedReturnValue(v87);
          if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[NSPConfigurationManager fetchURL:interface:eTag:requestType:session:access"
                                            "Token:reason:completionHandler:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_FAULT,  "%s called with null session",  (uint8_t *)&buf,  0xCu);
          }

          v107((uint64_t)v90, 0LL, 0LL, 0LL);
        }
      }

      else
      {
        uint64_t v85 = nplog_obj(0LL, v12, v13);
        __int128 v86 = (os_log_s *)objc_claimAutoreleasedReturnValue(v85);
        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
        {
          LODWORD(v106) = 136315138;
          *(void *)((char *)&v106 + 4) = "-[NSPConfigurationManager fetchPrivacyProxyConfigurationFile:interface:eTag:a"
                                           "ccessToken:reason:completionHandler:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_FAULT,  "%s called with null configFetchURL",  (uint8_t *)&v106,  0xCu);
        }

        v101((uint64_t)v92, 0, 0LL, 0LL, 0LL, 0LL);
      }
    }

    else
    {
      uint64_t v83 = nplog_obj(0LL, v10, v11);
      uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
      {
        LODWORD(v106) = 136315138;
        *(void *)((char *)&v106 + 4) = "-[NSPConfigurationManager fetchPrivacyProxyConfigurationFile:interface:eTag:acc"
                                         "essToken:reason:completionHandler:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "%s called with null currentConfiguration",  (uint8_t *)&v106,  0xCu);
      }

      v101((uint64_t)v92, 0, 0LL, 0LL, 0LL, 0LL);
    }

    objc_destroyWeak(&v104);
    objc_destroyWeak(&location);
  }
}

void sub_100091654( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id a32)
{
}

void sub_100091698(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v16 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[8] = 0;
    if (a2)
    {
      if (v11)
      {
        id v17 = objc_alloc_init(&OBJC_CLASS___NSData);
        id v67 = v17;
        NSPPrivacyProxyConfigurationRawConfig(v11, &v67);
        id v18 = v67;

        id v19 = objc_alloc(&OBJC_CLASS___NSPPrivacyProxySignedConfiguration);
        id v20 = [v11 copy];
        id v21 = [v19 initWithData:v20];

        id v57 = v21;
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 configuration]);
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 data]);
        id v24 = [v23 length];
        uint64_t v56 = v18;
        id v25 = -[NSData length](v18, "length");

        if (v24 != v25)
        {
          uint64_t v29 = nplog_obj(v26, v27, v28);
          id v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v57 configuration]);
            id v52 = (void *)objc_claimAutoreleasedReturnValue([v51 data]);
            id v53 = [v52 length];
            id v54 = -[NSData length](v56, "length");
            *(_DWORD *)__int128 buf = 134218240;
            id v69 = v53;
            __int16 v70 = 2048;
            id v71 = v54;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "Unmarshalled configuration length is different from received length (%lu != %lu)",  buf,  0x16u);
          }
        }

        uint64_t v31 = v56;
        if (v57 && v56)
        {
          id v32 = objc_alloc_init(&OBJC_CLASS___NSPConfigurationSignatureInfo);
          id v33 = (void *)objc_claimAutoreleasedReturnValue([v57 certificates]);
          [v32 setCertificates:v33];

          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v57 signature]);
          [v32 setSignature:v34];

          objc_msgSend(v32, "setSignatureAlgorithm:", (int)objc_msgSend(v57, "algorithm"));
          else {
            unsigned int v35 = 1;
          }
          unsigned int v55 = v35;
          id v46 = *(id *)(v16 + 32);
          uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v46 configServerHost]);
          v58[0] = _NSConcreteStackBlock;
          v58[1] = 3221225472LL;
          v58[2] = sub_100091B84;
          v58[3] = &unk_1000FA830;
          id v59 = v57;
          uint64_t v60 = v56;
          id v61 = v12;
          id v62 = v13;
          id v63 = (id)v16;
          id v64 = v32;
          id v66 = *(id *)(a1 + 32);
          id v65 = v14;
          id v48 = v32;
          uint64_t v31 = v56;
          +[NSPConfiguration verifyConfigurationSignature:configuration:host:validateCert:completionHandler:]( &OBJC_CLASS___NSPConfiguration,  "verifyConfigurationSignature:configuration:host:validateCert:completionHandler:",  v48,  v60,  v47,  v55,  v58);

LABEL_25:
          goto LABEL_26;
        }

        uint64_t v42 = nplog_obj(v26, v27, v28);
        uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
        BOOL v44 = os_log_type_enabled(v43, OS_LOG_TYPE_ERROR);
        if (v56)
        {
          if (!v44) {
            goto LABEL_23;
          }
          *(_DWORD *)__int128 buf = 138412290;
          id v69 = v12;
          uint64_t v45 = "failed to allocate signed configuration object from configuration data (new etag %@)";
        }

        else
        {
          if (!v44) {
            goto LABEL_23;
          }
          *(_DWORD *)__int128 buf = 138412290;
          id v69 = v12;
          uint64_t v45 = "unable to extract wire format of configuration from signed configuration message (new etag %@)";
        }

        _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, v45, buf, 0xCu);
LABEL_23:

        ++*(void *)(v16 + 112);
        sub_100087A2C(v16, 0LL, v49);
        uint64_t v50 = *(void *)(a1 + 32);
        if (v50) {
          (*(void (**)(uint64_t, void, id))(v50 + 16))(v50, 0LL, v14);
        }
        goto LABEL_25;
      }

      ++*((void *)WeakRetained + 13);
      id v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      [*(id *)(v16 + 32) setConfigurationFetchDate:v38];

      sub_1000876FC(v16, v39, v40);
      sub_100088CCC(v16);
      uint64_t v41 = *(void *)(a1 + 32);
      if (v41)
      {
        unsigned int v37 = *(void (**)(void))(v41 + 16);
        goto LABEL_16;
      }
    }

    else
    {
      ++*((void *)WeakRetained + 14);
      uint64_t v36 = *(void *)(a1 + 32);
      if (v36)
      {
        unsigned int v37 = *(void (**)(void))(v36 + 16);
LABEL_16:
        v37();
      }
    }
  }

void sub_100091B84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!(_DWORD)a2)
  {
    uint64_t v26 = nplog_obj(a1, a2, a3);
    uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    uint64_t v28 = *(void *)(a1 + 48);
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v38 = v28;
    uint64_t v29 = "Failed to validate configuration signature (new etag %@)";
    goto LABEL_27;
  }

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) configuration]);
  unsigned int v5 = +[NSPConfiguration validatePrivacyProxyConfiguration:]( &OBJC_CLASS___NSPConfiguration,  "validatePrivacyProxyConfiguration:",  v4);

  if (v5)
  {
    uint64_t v36 = objc_alloc_init(&OBJC_CLASS___NSPConfiguration);
    if (v36)
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) configuration]);
      -[NSPConfiguration setProxyConfiguration:](v36, "setProxyConfiguration:", v9);

      -[NSPConfiguration setProxyConfigurationData:](v36, "setProxyConfigurationData:", *(void *)(a1 + 40));
      -[NSPConfiguration setEtag:](v36, "setEtag:", *(void *)(a1 + 48));
      -[NSPConfiguration setEpoch:](v36, "setEpoch:", *(void *)(a1 + 56));
      uint64_t v10 = *(void *)(a1 + 64);
      if (v10) {
        id v11 = *(void **)(v10 + 32);
      }
      else {
        id v11 = 0LL;
      }
      -[NSPConfiguration setIgnoreInvalidCerts:](v36, "setIgnoreInvalidCerts:", [v11 ignoreInvalidCerts]);
      uint64_t v12 = *(void *)(a1 + 64);
      if (v12) {
        id v13 = *(void **)(v12 + 32);
      }
      else {
        id v13 = 0LL;
      }
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 geohashOverride]);
      -[NSPConfiguration setGeohashOverride:](v36, "setGeohashOverride:", v14);

      id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      -[NSPConfiguration setConfigurationFetchDate:](v36, "setConfigurationFetchDate:", v15);

      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v36, "proxyConfiguration"));
      id v17 = [v16 disableUntil];

      if (v17)
      {
        id v18 = objc_alloc(&OBJC_CLASS___NSDate);
        id v19 = (void *)objc_claimAutoreleasedReturnValue(-[NSPConfiguration proxyConfiguration](v36, "proxyConfiguration"));
        id v20 = -[NSDate initWithTimeIntervalSince1970:]( v18,  "initWithTimeIntervalSince1970:",  (double)(unint64_t)[v19 disableUntil]);

        -[NSDate timeIntervalSinceNow](v20, "timeIntervalSinceNow");
        if (v21 > 0.0) {
          -[NSPConfiguration setResurrectionDate:](v36, "setResurrectionDate:", v20);
        }
      }

      [*(id *)(a1 + 64) updateConfiguration:v36];
      [*(id *)(a1 + 72) saveToPreferences];
      sub_1000876FC(*(void *)(a1 + 64), v22, v23);
    }

    sub_100088CCC(*(void *)(a1 + 64));
    uint64_t v24 = *(void *)(a1 + 64);
    if (v24) {
      ++*(void *)(v24 + 104);
    }
    uint64_t v25 = *(void *)(a1 + 88);
    if (v25) {
      (*(void (**)(uint64_t, uint64_t, void))(v25 + 16))(v25, 1LL, 0LL);
    }

    return;
  }

  uint64_t v30 = nplog_obj(v6, v7, v8);
  uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    uint64_t v35 = *(void *)(a1 + 48);
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v38 = v35;
    uint64_t v29 = "Failed to validate configuration (new etag %@)";
LABEL_27:
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
  }

void sub_100091EA8(id a1)
{
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    LODWORD(v2) = info.denom;
    *(double *)&qword_1001171E8 = (double)v1 / (double)v2 / 1000.0 / 1000000.0;
  }

void sub_100091EFC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1 + 32);
  id v11 = v8;
  id v12 = v7;
  id v13 = &AnalyticsSendEventLazy_ptr;
  if (v10)
  {
    uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
    if ((objc_opt_isKindOfClass(v11, v14) & 1) != 0)
    {
      id v16 = v11;
      id v17 = (char *)[v16 statusCode];
      if ((unint64_t)(v17 - 503) < 2)
      {
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v16 allHeaderFields]);
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:@"Retry-After"]);

        if (v25)
        {
          uint64_t v26 = objc_alloc_init(&OBJC_CLASS___NSNumberFormatter);
          id v27 = v9;
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[NSNumberFormatter numberFromString:](v26, "numberFromString:", v25));
          id v23 = [v28 unsignedIntegerValue];

          id v9 = v27;
          id v13 = &AnalyticsSendEventLazy_ptr;
        }

        else
        {
          id v23 = 0LL;
        }
      }

      else
      {
        if (v17 == (char *)200 || v17 == (char *)304)
        {

          goto LABEL_19;
        }

        id v23 = 0LL;
      }
    }

    else
    {
      if (v12)
      {
        id v18 = (void *)objc_claimAutoreleasedReturnValue([v12 domain]);
        unsigned int v19 = [v18 isEqualToString:NSURLErrorDomain];

        if (v19)
        {
          if ([v12 code] == (id)-999)
          {

            goto LABEL_20;
          }
        }
      }

      id v23 = 0LL;
    }

    *(_BYTE *)(v10 + 9) = v23 == 0LL;
    sub_100087A2C(v10, (unint64_t)v23, v15);
  }

uint64_t sub_100092554(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 24));
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained getSavedPrivateCloudComputeEnvironment]);

  if (!v2) {
    unint64_t v2 = (void *)CFPreferencesCopyAppValue(@"environment", @"com.apple.privateCloudCompute");
  }
  id v3 = v2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSString);
  if (!v3) {
    goto LABEL_21;
  }
  char isKindOfClass = objc_opt_isKindOfClass(v3, v4);

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_21;
  }
  uint64_t v9 = nplog_obj(v6, v7, v8);
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412290;
    id v14 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Read com.apple.privateCloudCompute environment: %@",  (uint8_t *)&v13,  0xCu);
  }

  if (([v3 isEqualToString:@"dev"] & 1) == 0)
  {
    if ([v3 isEqualToString:@"perf"])
    {
      uint64_t v11 = 4LL;
      goto LABEL_22;
    }

    if ([v3 isEqualToString:@"staging"])
    {
      uint64_t v11 = 3LL;
      goto LABEL_22;
    }

    if ([v3 isEqualToString:@"carry"])
    {
      uint64_t v11 = 2LL;
      goto LABEL_22;
    }

    if ([v3 isEqualToString:@"production"])
    {
      uint64_t v11 = 1LL;
      goto LABEL_22;
    }

    if ([v3 isEqualToString:@"ephemeral"])
    {
LABEL_11:
      uint64_t v11 = 6LL;
      goto LABEL_22;
    }

void sub_100092774(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue(v9);
  uint64_t v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v10);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100092874;
  block[3] = &unk_1000FA918;
  __int128 v16 = *(_OWORD *)(a1 + 32);
  id v12 = (id)v16;
  __int128 v21 = v16;
  id v18 = v9;
  id v19 = v8;
  id v20 = v7;
  id v13 = v7;
  id v14 = v8;
  id v15 = v9;
  dispatch_async(v11, block);
}

uint64_t sub_100092874(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 64) + 8LL);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;

  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16LL))();
}

void sub_1000928B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  unsigned int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Config Fetch retry timer fired", buf, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 9));
    id v8 = (void *)v7[9];
    v7[9] = 0LL;

    *(void *)__int128 buf = 0LL;
    uint64_t v11 = buf;
    uint64_t v12 = 0x3032000000LL;
    id v13 = sub_100086D74;
    id v14 = sub_100086D84;
    id v15 = (id)os_transaction_create("com.apple.networkserviceproxy.configManagerConfigFetchRetry");
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    _DWORD v9[2] = sub_1000929E4;
    v9[3] = &unk_1000FA170;
    v9[4] = buf;
    sub_100086DA0(v7, 10LL, v9);
    _Block_object_dispose(buf, 8);
  }
}

void sub_1000929CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000929E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0LL;
}

void sub_1000929F8(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (id v3 = *(void **)(v2 + 96)) != 0LL)
  {
    [v3 timeIntervalSinceReferenceDate];
    int64_t v5 = (uint64_t)v4;
  }

  else
  {
    int64_t v5 = -1LL;
  }

  xpc_dictionary_set_int64(xdict, "ConfigFetchDate", v5);
  if ((deviceClassIsHomepod(v6) & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7 && *(_BYTE *)(v7 + 9)) {
      int64_t v8 = 1LL;
    }
    else {
      int64_t v8 = -1LL;
    }
    xpc_dictionary_set_int64(xdict, "ConfigFetchOnNetworkChange", v8);
  }

  xpc_set_event("com.apple.networkserviceproxy", "MessageResponse", xdict);
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = 0LL;
}

LABEL_50:
  -[NSPConfigurationStats setKnownTrackersEnabled:](v15, "setKnownTrackersEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x200) == 0)
  {
LABEL_25:
    if ((v12 & 0x400) == 0) {
      goto LABEL_26;
    }
    goto LABEL_52;
  }

LABEL_57:
  -[NSPConfigurationStats setMetricsUploadEnabled:](v15, "setMetricsUploadEnabled:", 1LL);
  id v13 = v15;
  if ((v12 & 0x8000) == 0)
  {
LABEL_32:
    if ((v12 & 0x20000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_59;
  }

id sub_100093304(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v29 = 0LL;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x3032000000LL;
  uint64_t v32 = sub_10009363C;
  id v33 = sub_10009364C;
  id v34 = 0LL;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NEFileHandleMaintainer sharedMaintainer](&OBJC_CLASS___NEFileHandleMaintainer, "sharedMaintainer"));
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472LL;
  v26[2] = sub_100093654;
  _OWORD v26[3] = &unk_1000F92F8;
  id v7 = v5;
  id v27 = v7;
  uint64_t v28 = &v29;
  [v6 iterateFileHandlesWithBlock:v26];

  if (v30[5])
  {
    uint64_t v11 = nplog_obj(v8, v9, v10);
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v36 = a1;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%@ Re-using existing policy session",  buf,  0xCu);
    }

void sub_1000935A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_100093614(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyPolicyHandler);
  uint64_t v2 = (void *)qword_1001171F0;
  qword_1001171F0 = (uint64_t)v1;
}

uint64_t sub_10009363C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10009364C(uint64_t a1)
{
}

uint64_t sub_100093654(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NEPolicySessionFileHandle);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0
    && (id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 name]),
        unsigned int v6 = [v5 isEqualToString:*(void *)(a1 + 32)],
        v5,
        v6))
  {
    id v7 = objc_alloc(&OBJC_CLASS___NEPolicySession);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 handle]);
    uint64_t v9 = -[NEPolicySession initWithSocket:](v7, "initWithSocket:", dup((int)[v8 fileDescriptor]));
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) removeAllPolicies];
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) removeAllDomainFilters];
    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v12 = 1LL;
  }

  return v12;
}

BOOL sub_100093740(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NEPolicySessionFileHandle);
  BOOL v7 = 0;
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 name]);
    unsigned __int8 v6 = [v5 isEqualToString:*(void *)(a1 + 32)];

    if ((v6 & 1) != 0) {
      BOOL v7 = 1;
    }
  }

  return v7;
}

id *sub_1000937C0(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    id v2 = result[10];
    id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v10;
      do
      {
        unsigned __int8 v6 = 0LL;
        do
        {
          if (*(void *)v10 != v5) {
            objc_enumerationMutation(v2);
          }
          BOOL v7 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)v6);
          id v8 = v1[3];
          objc_msgSend(v8, "removePolicyWithID:", objc_msgSend(v7, "unsignedIntegerValue", (void)v9));

          unsigned __int8 v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }

      while (v4);
    }

    return (id *)[v1[10] removeAllObjects];
  }

  return result;
}

void sub_1000940BC(_Unwind_Exception *a1)
{
}

id *sub_1000940EC(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id result = (id *)[result[14] count];
    if (result)
    {
      __int128 v11 = 0u;
      __int128 v12 = 0u;
      __int128 v9 = 0u;
      __int128 v10 = 0u;
      id v2 = v1[14];
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          unsigned __int8 v6 = 0LL;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            BOOL v7 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)v6);
            id v8 = v1[3];
            objc_msgSend(v8, "removePolicyWithID:", objc_msgSend(v7, "unsignedIntegerValue", (void)v9));

            unsigned __int8 v6 = (char *)v6 + 1;
          }

          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }

        while (v4);
      }

      return (id *)[v1[14] removeAllObjects];
    }
  }

  return result;
}

id *sub_100094218(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id result = (id *)[result[15] count];
    if (result)
    {
      __int128 v11 = 0u;
      __int128 v12 = 0u;
      __int128 v9 = 0u;
      __int128 v10 = 0u;
      id v2 = v1[15];
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          unsigned __int8 v6 = 0LL;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            BOOL v7 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)v6);
            id v8 = v1[3];
            objc_msgSend(v8, "removePolicyWithID:", objc_msgSend(v7, "unsignedIntegerValue", (void)v9));

            unsigned __int8 v6 = (char *)v6 + 1;
          }

          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }

        while (v4);
      }

      return (id *)[v1[15] removeAllObjects];
    }
  }

  return result;
}

id *sub_100094344(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id result = (id *)[result[16] count];
    if (result)
    {
      __int128 v11 = 0u;
      __int128 v12 = 0u;
      __int128 v9 = 0u;
      __int128 v10 = 0u;
      id v2 = v1[16];
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          unsigned __int8 v6 = 0LL;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            BOOL v7 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)v6);
            id v8 = v1[3];
            objc_msgSend(v8, "removePolicyWithID:", objc_msgSend(v7, "unsignedIntegerValue", (void)v9));

            unsigned __int8 v6 = (char *)v6 + 1;
          }

          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }

        while (v4);
      }

      return (id *)[v1[16] removeAllObjects];
    }
  }

  return result;
}

id *sub_100094470(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    id v2 = result[25];
    id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v10;
      do
      {
        unsigned __int8 v6 = 0LL;
        do
        {
          if (*(void *)v10 != v5) {
            objc_enumerationMutation(v2);
          }
          BOOL v7 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)v6);
          id v8 = v1[3];
          objc_msgSend(v8, "removePolicyWithID:", objc_msgSend(v7, "unsignedIntegerValue", (void)v9));

          unsigned __int8 v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }

      while (v4);
    }

    return (id *)[v1[25] removeAllObjects];
  }

  return result;
}

void sub_100094C40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t sub_100094C9C(void **a1)
{
  uint64_t v1 = (uint64_t)a1;
  if (a1)
  {
    id v2 = @"com.apple.SafariTechnologyPreview";
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](&OBJC_CLASS___LSApplicationWorkspace, "defaultWorkspace"));
    unsigned int v4 = [v3 applicationIsInstalled:@"com.apple.SafariTechnologyPreview"];

    if (v4)
    {
      uint64_t v5 = sub_100085CA0((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, *(void **)(v1 + 16));
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
      id v7 = [v6 countByEnumeratingWithState:&v25 objects:v33 count:16];
      if (v7)
      {
        id v10 = v7;
        uint64_t v11 = *(void *)v26;
        while (2)
        {
          __int128 v12 = 0LL;
          do
          {
            if (*(void *)v26 != v11) {
              objc_enumerationMutation(v6);
            }
            id v13 = *(void **)(*((void *)&v25 + 1) + 8LL * (void)v12);
            uint64_t v14 = nplog_obj(v7, v8, v9);
            id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v30 = (void **)v1;
              __int16 v31 = 2112;
              id v32 = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "%@ adding SafariTechnologyPreview policy %@",  buf,  0x16u);
            }

            id v16 = [*(id *)(v1 + 24) addPolicy:v13];
            uint64_t v19 = nplog_obj(v16, v17, v18);
            id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
            uint64_t v21 = v20;
            if (!v16)
            {
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 138412290;
                uint64_t v30 = (void **)v1;
                _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "%@ failed to add SafariTechnologyPreview policy",  buf,  0xCu);
              }

              uint64_t v1 = 0LL;
              goto LABEL_20;
            }

            if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v30 = (void **)v1;
              __int16 v31 = 2048;
              id v32 = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "%@ added SafariTechnologyPreview policy %lu",  buf,  0x16u);
            }

            id v22 = *(id *)(v1 + 112);
            id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v16));
            [v22 addObject:v23];

            __int128 v12 = (char *)v12 + 1;
          }

          while (v10 != v12);
          id v7 = [v6 countByEnumeratingWithState:&v25 objects:v33 count:16];
          id v10 = v7;
          if (v7) {
            continue;
          }
          break;
        }
      }

      uint64_t v1 = 1LL;
LABEL_20:
    }

    else
    {
      return 1LL;
    }
  }

  return v1;
}

void sub_100094FBC(_Unwind_Exception *a1)
{
}

void sub_1000954F8(_Unwind_Exception *a1)
{
}

void sub_10009581C(_Unwind_Exception *a1)
{
}

void sub_100095848(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    objc_sync_enter(v1);
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    id v2 = v1[13];
    id v3 = [v2 countByEnumeratingWithState:&v45 objects:v54 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v46;
      do
      {
        for (CFIndex i = 0LL; i != v3; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v46 != v4) {
            objc_enumerationMutation(v2);
          }
          id v6 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)i);
          id v7 = v1[3];
          objc_msgSend(v7, "removePolicyWithID:", objc_msgSend(v6, "unsignedIntegerValue"));
        }

        id v3 = [v2 countByEnumeratingWithState:&v45 objects:v54 count:16];
      }

      while (v3);
    }

    id v8 = v1[13];
    [v8 removeAllObjects];

    if (!*((_BYTE *)v1 + 9) && !*((_BYTE *)v1 + 10))
    {
      id v9 = v1[11];
      if ([v9 count])
      {
      }

      else
      {
        id v10 = v1[12];
        BOOL v11 = [v10 length] == 0;

        if (v11)
        {
          id v20 = v1[3];
          [v20 apply];
LABEL_30:

          objc_sync_exit(v1);
          return;
        }
      }
    }

    int v12 = *((unsigned __int8 *)v1 + 9);
    int v13 = *((unsigned __int8 *)v1 + 10);
    id v14 = v1[11];
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 allObjects]);
    BOOL v16 = v12 != 0;
    id v17 = v1[12];
    uint64_t v18 = sub_100083AD8((uint64_t)&OBJC_CLASS___NSPPrivacyProxyPolicySerialization, v16, v13 != 0, v15, v17);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    id v20 = v19;
    id v21 = [v20 countByEnumeratingWithState:&v41 objects:v53 count:16];
    id v24 = v21;
    if (v21)
    {
      uint64_t v25 = *(void *)v42;
      do
      {
        __int128 v26 = 0LL;
        do
        {
          if (*(void *)v42 != v25) {
            objc_enumerationMutation(v20);
          }
          __int128 v27 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)v26);
          uint64_t v28 = nplog_obj(v21, v22, v23);
          uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v50 = v1;
            __int16 v51 = 2112;
            id v52 = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "%@ adding interface exception policy %@",  buf,  0x16u);
          }

          id v30 = v1[3];
          id v31 = [v30 addPolicy:v27];

          if (v31)
          {
            uint64_t v35 = nplog_obj(v32, v33, v34);
            uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v50 = v1;
              __int16 v51 = 2048;
              id v52 = v31;
              _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "%@ added interface exception policy %lu",  buf,  0x16u);
            }

            id v37 = v1[13];
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v31));
            [v37 addObject:v38];
          }

          else
          {
            uint64_t v39 = nplog_obj(v32, v33, v34);
            id v37 = (id)objc_claimAutoreleasedReturnValue(v39);
            if (os_log_type_enabled((os_log_t)v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v50 = v1;
              _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)v37,  OS_LOG_TYPE_ERROR,  "%@ failed to add interface exception policy",  buf,  0xCu);
            }
          }

          __int128 v26 = (char *)v26 + 1;
        }

        while (v24 != v26);
        id v21 = [v20 countByEnumeratingWithState:&v41 objects:v53 count:16];
        id v24 = v21;
      }

      while (v21);
    }

    id v40 = v1[3];
    [v40 apply];

    goto LABEL_30;
  }

void sub_100095C74(_Unwind_Exception *a1)
{
}

void sub_100095D2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_100095DB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_100095EEC(_Unwind_Exception *a1)
{
}

void sub_100096090(_Unwind_Exception *a1)
{
}

void sub_100096188(_Unwind_Exception *a1)
{
}

void sub_1000965C0(_Unwind_Exception *a1)
{
}

void sub_1000968E0(_Unwind_Exception *a1)
{
}

id *sub_100096910(id *result)
{
  if (result)
  {
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(result[23], "allValues", 0));
    id v2 = [v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
    if (v2)
    {
      id v3 = v2;
      uint64_t v4 = 0LL;
      uint64_t v5 = *(void *)v8;
      do
      {
        for (CFIndex i = 0LL; i != v3; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v8 != v5) {
            objc_enumerationMutation(v1);
          }
          v4 |= (unint64_t)[*(id *)(*((void *)&v7 + 1) + 8 * (void)i) unsignedLongLongValue];
        }

        id v3 = [v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
      }

      while (v3);
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    return (id *)+[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"networkserviceproxy-reverse-proxy",  v4);
  }

  return result;
}

void sub_100096F20(_Unwind_Exception *a1)
{
}

void sub_100097508(_Unwind_Exception *a1)
{
}

void sub_1000977F8(_Unwind_Exception *a1)
{
}

void sub_100097CC8(_Unwind_Exception *a1)
{
}

void sub_100097E08(_Unwind_Exception *a1)
{
}

void sub_100099170(void *a1, id a2)
{
  if (a1)
  {
    id v25 = (id)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 lastObject]);

    if ([v5 serviceStatus] != a2)
    {
      if (v5) {
        [v5 setServiceStatusEndTime:v25];
      }
      id v6 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
      __int128 v7 = (char *)[v6 count];

      for (; v7; --v7)
      {
        __int128 v8 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
        __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v8 firstObject]);

        uint64_t v10 = objc_claimAutoreleasedReturnValue([v9 serviceStatusEndTime]);
        if (v10)
        {
          BOOL v11 = (void *)v10;
          int v12 = (void *)objc_claimAutoreleasedReturnValue([v9 serviceStatusEndTime]);
          [v25 timeIntervalSinceDate:v12];
          double v14 = v13;

          if (v14 >= 604800.0)
          {
            id v15 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
            [v15 removeObject:v9];
          }
        }
      }

      BOOL v16 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
      id v17 = [v16 count];

      if ((unint64_t)v17 > 0xA)
      {
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
        uint64_t v19 = (char *)[v18 count] - 10;

        for (; v19; --v19)
        {
          id v20 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
          id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 firstObject]);

          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
          [v22 removeObject:v21];
        }
      }

      id v23 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyServiceStatusTime);
      [v23 setServiceStatus:a2];
      [v23 setServiceStatusStartTime:v25];
      id v24 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatusTimeline]);
      [v24 addObject:v23];

      sub_100099658(a1);
    }
  }

void sub_100099658(void *a1)
{
  uint64_t v4 = -[NSKeyedArchiver initRequiringSecureCoding:]( objc_alloc(&OBJC_CLASS___NSKeyedArchiver),  "initRequiringSecureCoding:",  1LL);
  if (!v4)
  {
    uint64_t v12 = nplog_obj(0LL, v2, v3);
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    __int16 v17 = 0;
    double v13 = "NSKeyedArchiver initialize failed";
    double v14 = (uint8_t *)&v17;
LABEL_10:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v13, v14, 2u);
    goto LABEL_8;
  }

  [a1 encodeWithCoder:v4];
  _CFPreferencesSetFileProtectionClass( kCFPreferencesCurrentApplication,  kCFPreferencesCurrentUser,  kCFPreferencesCurrentHost,  0LL,  3LL);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(-[NSKeyedArchiver encodedData](v4, "encodedData"));
  CFPreferencesSetAppValue(@"NSPServiceStatusManagerInfo", v5, kCFPreferencesCurrentApplication);

  uint64_t v6 = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
  LODWORD(v5) = v6;
  uint64_t v9 = nplog_obj(v6, v7, v8);
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  BOOL v11 = v10;
  if (!(_DWORD)v5)
  {
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    *(_WORD *)__int128 buf = 0;
    double v13 = "Failed to write nsp service status manager info to preference file";
    double v14 = buf;
    goto LABEL_10;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v15 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Saved status manager info to preference file",  v15,  2u);
  }

void sub_100099F9C(void *a1, id a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  double v14 = v11;
  if (a1)
  {
    uint64_t v15 = nplog_obj(v11, v12, v13);
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v17 = (void *)objc_claimAutoreleasedReturnValue( +[PrivacyProxyServiceStatus serviceStatusString:]( &OBJC_CLASS___PrivacyProxyServiceStatus,  "serviceStatusString:",  a2));
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[PrivacyProxyServiceStatus serviceStatusString:]( PrivacyProxyServiceStatus,  "serviceStatusString:",  [v18 serviceStatus]));
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v32 = v17;
      __int16 v33 = 2112;
      uint64_t v34 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Setting service status %@, previous service status %@",  buf,  0x16u);
    }

    id v20 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
    if ([v20 serviceStatus] == a2)
    {
      id v21 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
      unint64_t v22 = (unint64_t)(id)objc_claimAutoreleasedReturnValue([v21 details]);
      unint64_t v23 = v14;
      id v24 = (void *)v23;
      if (!(v23 | v22) || v23 && v22 && [(id)v22 isEqual:v23])
      {

LABEL_12:
        goto LABEL_13;
      }
    }

    id v25 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
    [v25 setServiceStatus:a2];

    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
    [v26 setDetails:v14];

    sub_100099170(a1, a2);
    ++a1[6];
    +[NPUtilities postNotification:value:]( &OBJC_CLASS___NPUtilities,  "postNotification:value:",  @"com.apple.networkserviceproxy.privacy-proxy-service-status-changed");
    id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"prefs:root=APPLE_ACCOUNT&path=ICLOUD_SERVICE/INTERNET_PRIVACY"));
    uint64_t v27 = NPGetInternalQueue(v20);
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472LL;
    v29[2] = sub_10009A268;
    v29[3] = &unk_1000FAA20;
    id v30 = v9;
    sub_1000A6A98((uint64_t)&OBJC_CLASS___NSPUserNotification, v30, v10, v20, (uint64_t)v28, v29);

    id v21 = v30;
    goto LABEL_12;
  }

void sub_10009A268(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v6 = nplog_obj(v3, v4, v5);
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  uint64_t v8 = v7;
  if (v3)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      int v11 = 138412546;
      uint64_t v12 = v9;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Failed to post notification %@: %@",  (uint8_t *)&v11,  0x16u);
    }
  }

  else if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = 138412290;
    uint64_t v12 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Posted notification %@", (uint8_t *)&v11, 0xCu);
  }
}

uint64_t sub_10009AE8C(void *a1, id a2, uint64_t a3, void *a4)
{
  id v74 = a4;
  if (!a1)
  {
    uint64_t v65 = 0LL;
    goto LABEL_75;
  }

  uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  self = a1;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([a1 serviceStatus]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 networkStatuses]);

  id v10 = [v9 countByEnumeratingWithState:&v75 objects:v88 count:16];
  uint64_t v73 = v7;
  if (!v10)
  {
    char v12 = 0;
    __int16 v13 = 0LL;
    char v71 = 1;
    goto LABEL_26;
  }

  id v11 = v10;
  char v12 = 0;
  __int16 v13 = 0LL;
  uint64_t v14 = *(void *)v76;
  char v71 = 1;
  do
  {
    for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v76 != v14) {
        objc_enumerationMutation(v9);
      }
      BOOL v16 = *(PrivacyProxyNetworkStatus **)(*((void *)&v75 + 1) + 8LL * (void)i);
      if (-[PrivacyProxyNetworkStatus networkType](v16, "networkType") == (_DWORD)a3)
      {
        if ((v12 & 1) != 0)
        {
          char v12 = 1;
          continue;
        }

        id v17 = -[PrivacyProxyNetworkStatus networkStatus](v16, "networkStatus");
        BOOL v19 = a2 != (id)2 || v17 != 0LL;
        if ((v17 == a2 || !v19)
          && (id v20 = (void *)objc_claimAutoreleasedReturnValue(-[PrivacyProxyNetworkStatus networkName](v16, "networkName")),
              unsigned __int8 v21 = [v20 isEqualToString:v74],
              v20,
              uint64_t v7 = v73,
              (v21 & 1) != 0))
        {
          char v12 = 0;
          char v71 = 0;
        }

        else
        {
          BOOL v16 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyNetworkStatus);

          -[PrivacyProxyNetworkStatus setNetworkStatus:](v16, "setNetworkStatus:", a2);
          -[PrivacyProxyNetworkStatus setNetworkType:](v16, "setNetworkType:", a3);
          -[PrivacyProxyNetworkStatus setNetworkName:](v16, "setNetworkName:", v74);
          char v12 = 1;
          __int16 v13 = v16;
        }
      }

      -[NSMutableArray addObject:](v7, "addObject:", v16);
    }

    id v11 = [v9 countByEnumeratingWithState:&v75 objects:v88 count:16];
  }

  while (v11);
LABEL_26:

  if ((v12 & 1) != 0)
  {
    unint64_t v22 = self;
  }

  else
  {
    unint64_t v22 = self;
    if ((v71 & 1) != 0)
    {
      unint64_t v23 = objc_alloc_init(&OBJC_CLASS___PrivacyProxyNetworkStatus);

      -[PrivacyProxyNetworkStatus setNetworkStatus:](v23, "setNetworkStatus:", a2);
      -[PrivacyProxyNetworkStatus setNetworkType:](v23, "setNetworkType:", a3);
      -[PrivacyProxyNetworkStatus setNetworkName:](v23, "setNetworkName:", v74);
      -[NSMutableArray addObject:](v7, "addObject:", v23);
      char v12 = 1;
      __int16 v13 = v23;
    }
  }

  id v24 = (void *)objc_claimAutoreleasedReturnValue([v22 serviceStatus]);
  [v24 setNetworkStatuses:v7];

  if ((v12 & 1) == 0) {
    goto LABEL_74;
  }
  uint64_t v27 = v13;
  if (!v27)
  {
    uint64_t v67 = nplog_obj(0LL, v25, v26);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v91 = "-[NSPServiceStatusManager setNetworkStatusOnTimeline:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "%s called with null networkStatus",  buf,  0xCu);
    }

    goto LABEL_73;
  }

  char v69 = v12;
  __int16 v68 = v13;
  uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
  uint64_t v29 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v84 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  id v31 = objc_getProperty(v22, v30, 64LL, 1);
  id v32 = [v31 countByEnumeratingWithState:&v84 objects:buf count:16];
  if (!v32) {
    goto LABEL_53;
  }
  id v33 = v32;
  uint64_t v34 = *(void *)v85;
  while (2)
  {
    uint64_t v35 = 0LL;
    while (2)
    {
      if (*(void *)v85 != v34) {
        objc_enumerationMutation(v31);
      }
      uint64_t v36 = *(void *)(*((void *)&v84 + 1) + 8 * v35);
      if (v36) {
        id v37 = *(void **)(v36 + 8);
      }
      else {
        id v37 = 0LL;
      }
      id v38 = v37;
      unsigned int v39 = [v38 networkType];
      if (v39 != -[PrivacyProxyNetworkStatus networkType](v27, "networkType"))
      {

        goto LABEL_44;
      }

      if (!v36)
      {

LABEL_42:
        sub_10000E01C(v36, v28);
LABEL_44:
        if (v36) {
          goto LABEL_45;
        }
        goto LABEL_48;
      }

      uint64_t v40 = *(void *)(v36 + 24);

      if (!v40) {
        goto LABEL_42;
      }
LABEL_45:
      id v41 = *(id *)(v36 + 24);
      if (v41)
      {
        __int128 v42 = v41;
        -[os_log_s timeIntervalSinceDate:](v28, "timeIntervalSinceDate:", *(void *)(v36 + 24));
        double v44 = v43;

        if (v44 >= 172800.0) {
          -[NSMutableArray addObject:](v29, "addObject:", v36);
        }
      }

void sub_10009BABC(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", @"prefs:root=WIFI"));
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](&OBJC_CLASS___LSApplicationWorkspace, "defaultWorkspace"));
    unsigned __int8 v4 = [v3 openSensitiveURL:v2 withOptions:0];

    if ((v4 & 1) == 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v15 = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to open %@", buf, 0xCu);
      }
    }
  }

  else
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11) {
      id WeakRetained = objc_loadWeakRetained((id *)(v11 + 32));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v13 = WeakRetained;
    [WeakRetained disableWiFiNetwork:*(void *)(a1 + 40)];
  }

void sub_10009BFA4(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"prefs:root=MOBILE_DATA_SETTINGS_ID&path=CELLULAR_DATA_OPTIONS"));
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](&OBJC_CLASS___LSApplicationWorkspace, "defaultWorkspace"));
    unsigned __int8 v4 = [v3 openSensitiveURL:v2 withOptions:0];

    if ((v4 & 1) == 0)
    {
      uint64_t v8 = nplog_obj(v5, v6, v7);
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v15 = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to open %@", buf, 0xCu);
      }
    }
  }

  else
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11) {
      id WeakRetained = objc_loadWeakRetained((id *)(v11 + 32));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v13 = WeakRetained;
    [WeakRetained disableCellularNetwork:*(void *)(a1 + 40)];
  }

void sub_10009C548(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      id WeakRetained = objc_loadWeakRetained((id *)(v3 + 32));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v5 = WeakRetained;
    [WeakRetained disableInterface:*(void *)(a1 + 40) displayName:*(void *)(a1 + 48) type:*(unsigned int *)(a1 + 56)];
  }

void sub_10009C5A0(void *a1, void *a2, void *a3)
{
  id v6 = a3;
  if (a1)
  {
    objc_setProperty_atomic(a1, v5, a2, 24LL);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([a1 appStatuses]);
    [v7 sortUsingComparator:&stru_1000FAA88];

    uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    unint64_t v22 = a1;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([a1 appStatuses]);
    id v10 = [v9 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v10)
    {
      id v11 = v10;
      unint64_t v12 = 0LL;
      uint64_t v13 = *(void *)v24;
      do
      {
        for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v24 != v13) {
            objc_enumerationMutation(v9);
          }
          uint64_t v15 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
          if ([v15 appStatus] == (id)1)
          {
            if (v12 <= 0x14
              && (uint64_t v16 = objc_claimAutoreleasedReturnValue([v15 activeDate])) != 0
              && (id v17 = (void *)v16,
                  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v15 activeDate]),
                  [v6 timeIntervalSinceDate:v18],
                  double v20 = v19,
                  v18,
                  v17,
                  v20 < 86400.0))
            {
              ++v12;
            }

            else
            {
              -[NSMutableArray addObject:](v8, "addObject:", v15);
            }
          }
        }

        id v11 = [v9 countByEnumeratingWithState:&v23 objects:v27 count:16];
      }

      while (v11);
    }

    unsigned __int8 v21 = (void *)objc_claimAutoreleasedReturnValue([v22 appStatuses]);
    [v21 removeObjectsInArray:v8];

    sub_100099658(v22);
  }
}

int64_t sub_10009C7A4(id a1, id a2, id a3)
{
  id v4 = a2;
  id v5 = a3;
  id v6 = v4;
  id v7 = v5;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 activeDate]);
  if (v8)
  {
  }

  else
  {
    int64_t v9 = objc_claimAutoreleasedReturnValue([v7 activeDate]);

    if (!v9) {
      goto LABEL_9;
    }
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v6 activeDate]);

  if (v10)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v7 activeDate]);

    if (v11)
    {
      unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v7 activeDate]);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v6 activeDate]);
      int64_t v9 = (int64_t)[v12 compare:v13];
    }

    else
    {
      int64_t v9 = -1LL;
    }
  }

  else
  {
    int64_t v9 = 1LL;
  }

void sub_10009D528(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a2;
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = "active";
    if (v3) {
      id v7 = "idle";
    }
    int v23 = 136315138;
    __int128 v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "network context is %s", (uint8_t *)&v23, 0xCu);
  }

  *(_BYTE *)(*(void *)(a1 + 32) + 9LL) = v3;
  uint64_t v8 = *(void *)(a1 + 32);
  int64_t v9 = *(void **)(v8 + 40);
  if ((v3 & 1) != 0)
  {
    if (!v9) {
      return;
    }
    *(void *)(v8 + 40) = 0LL;

    uint64_t v13 = nplog_obj(v10, v11, v12);
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_INFO)) {
      goto LABEL_13;
    }
    LOWORD(v23) = 0;
    uint64_t v15 = "shared network transaction released";
    goto LABEL_12;
  }

  if (v9) {
    return;
  }
  uint64_t v16 = os_transaction_create("com.apple.networkserviceproxy.shared-network-transaction");
  uint64_t v17 = *(void *)(a1 + 32);
  uint64_t v18 = *(void **)(v17 + 40);
  *(void *)(v17 + 40) = v16;

  uint64_t v22 = nplog_obj(v19, v20, v21);
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    LOWORD(v23) = 0;
    uint64_t v15 = "shared network transaction acquired";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, v15, (uint8_t *)&v23, 2u);
  }

void sub_10009D6E8(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4)
    {
      NEFlowDirectorDestroy(v4, &stru_1000FAAC0);
      *(void *)(a1 + 24) = 0LL;
    }

    if (a2)
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v5 removeFileHandleMatchingPredicate:&stru_1000FAAE0];

      id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      [v6 commit];
    }

    id v7 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0LL;
  }

void sub_10009D77C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    {
      uint64_t v16 = nplog_obj(a1, a2, a3);
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "%@ Bridged flow divert is already started, ignoring start request",  (uint8_t *)&buf,  0xCu);
      }
    }

    else
    {
      sub_10009D6E8(a1, 0);
      uint64_t v7 = nplog_obj(v4, v5, v6);
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "%@: Bridged flow divert starting",  (uint8_t *)&buf,  0xCu);
      }

      *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
      int64_t v9 = *(void **)(a1 + 16);
      if (v9) {
        goto LABEL_19;
      }
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v47 = 0x3032000000LL;
      __int128 v48 = sub_10009DCDC;
      uint64_t v49 = sub_10009DCEC;
      id v50 = 0LL;
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
      v43[0] = _NSConcreteStackBlock;
      v43[1] = 3221225472LL;
      v43[2] = sub_10009DCF4;
      v43[3] = &unk_1000FAB08;
      v43[4] = &buf;
      [v10 iterateFileHandlesWithBlock:v43];

      if (*(void *)(*((void *)&buf + 1) + 40LL))
      {
        uint64_t v14 = nplog_obj(v11, v12, v13);
        uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)double v44 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Re-using existing flow divert control socket",  v44,  2u);
        }
      }

      else
      {
        uint64_t v18 = nplog_obj(v11, v12, v13);
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)double v44 = 138412290;
          uint64_t v45 = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "%@ Creating a new flow divert control socket",  v44,  0xCu);
        }

        id v20 = -[NEFlowDivertFileHandle initFlowDivertControlSocketDisableAppMap:]( objc_alloc(&OBJC_CLASS___NEFlowDivertFileHandle),  "initFlowDivertControlSocketDisableAppMap:",  1LL);
        uint64_t v21 = *(void **)(*((void *)&buf + 1) + 40LL);
        *(void *)(*((void *)&buf + 1) + 4kdebug_trace(732954628LL, 0LL, 0LL, 0LL, 0LL) = v20;

        if (*(void *)(*((void *)&buf + 1) + 40LL))
        {
          __int128 v25 = (void *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          [v25 setFileHandle:*(void *)(*((void *)&buf + 1) + 40) matchingPredicate:&stru_1000FAB28];

          uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NEFileHandleMaintainer sharedMaintainer]( &OBJC_CLASS___NEFileHandleMaintainer,  "sharedMaintainer"));
          -[os_log_s commit](v15, "commit");
        }

        else
        {
          uint64_t v26 = nplog_obj(v22, v23, v24);
          uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)double v44 = 138412290;
            uint64_t v45 = a1;
            _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "%@: Failed to create a flow divert control socket",  v44,  0xCu);
          }
        }
      }

      id v27 = *(id *)(*((void *)&buf + 1) + 40LL);
      _Block_object_dispose(&buf, 8);

      uint64_t v28 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v27;

      int64_t v9 = *(void **)(a1 + 16);
      if (v9)
      {
LABEL_19:
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v9 handle]);
        uint64_t v30 = dup((int)[v29 fileDescriptor]);

        uint64_t v34 = nplog_obj(v31, v32, v33);
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
        uint64_t v36 = v35;
        if ((int)v30 < 1)
        {
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
          {
            id v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) handle]);
            unsigned int v42 = [v41 fileDescriptor];
            LODWORD(buf) = 67109376;
            DWORD1(buf) = v42;
            WORD4(buf) = 1024;
            *(_DWORD *)((char *)&buf + 10) = v30;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "Unable to dup flow divert handle %d (%d)",  (uint8_t *)&buf,  0xEu);
          }
        }

        else
        {
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) handle]);
            unsigned int v40 = [v39 fileDescriptor];
            LODWORD(buf) = 67109376;
            DWORD1(buf) = v30;
            WORD4(buf) = 1024;
            *(_DWORD *)((char *)&buf + 10) = v40;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "Created fd %d from %d for flow divert",  (uint8_t *)&buf,  0xEu);
          }

          id Property = objc_getProperty((id)a1, v37, 32LL, 1);
          *(void *)(a1 + 24) = NEFlowDirectorCreateBridge(v30, Property);
          NEFlowDirectorAllowProcessDelegation();
          NEFlowDirectorStart(*(void *)(a1 + 24));
        }
      }
    }
  }

void sub_10009DC04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10009DC30(id a1)
{
  uint64_t v3 = nplog_obj(a1, v1, v2);
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Bridged flow director destroyed", v5, 2u);
  }
}

BOOL sub_10009DC94(id a1, NEFileHandle *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NEFlowDivertFileHandle);
  char isKindOfClass = objc_opt_isKindOfClass(v2, v3);

  return isKindOfClass & 1;
}

uint64_t sub_10009DCDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10009DCEC(uint64_t a1)
{
}

BOOL sub_10009DCF4(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NEFlowDivertFileHandle);
  char isKindOfClass = objc_opt_isKindOfClass(v4, v5);
  if ((isKindOfClass & 1) != 0) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }

  return (isKindOfClass & 1) == 0;
}

BOOL sub_10009DD64(id a1, NEFileHandle *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NEFlowDivertFileHandle);
  char isKindOfClass = objc_opt_isKindOfClass(v2, v3);

  return isKindOfClass & 1;
}

uint64_t start()
{
  error__int128 buf = 0LL;
  uint64_t v0 = sandbox_init("com.apple.networkserviceproxy", 2uLL, &errorbuf);
  if ((v0 & 0x80000000) != 0)
  {
    uint64_t v3 = nplog_obj(v0, v1, v2);
    id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v16 = errorbuf;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "sandbox_init failed: %s", buf, 0xCu);
    }

    sandbox_free_error(errorbuf);
  }

  uint64_t v5 = objc_autoreleasePoolPush();
  uint64_t v8 = nplog_obj(v5, v6, v7);
  int64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Starting NSPServer", buf, 2u);
  }

  id v10 = sub_10005725C();
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  sub_100064AE0((uint64_t)v11);

  objc_autoreleasePoolPop(v5);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
  [v12 run];

  return 0LL;
}

void sub_10009E17C(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyTokenManager);
  uint64_t v2 = (void *)qword_100117200;
  qword_100117200 = (uint64_t)v1;

  id v3 = +[NPUtilities copyTrueClientIPAddressFromPreferences]( &OBJC_CLASS___NPUtilities,  "copyTrueClientIPAddressFromPreferences");
  if (qword_100117200)
  {
    id v4 = v3;
    objc_storeStrong((id *)(qword_100117200 + 96), v3);
    id v3 = v4;
  }
}

NSMutableArray *sub_10009E51C(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v57 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  char v60 = 1;
  if (!v10) {
    goto LABEL_4;
  }
  id v14 = [v11 count];
  id v15 = [v9 count];
  if (v14 != v15)
  {
    uint64_t v50 = nplog_obj(v15, v16, v17);
    id v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
    if (!os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_FAULT))
    {
LABEL_29:

      __int128 v48 = 0LL;
      goto LABEL_25;
    }

    *(_DWORD *)__int128 buf = 136315138;
    id v62 = "-[NSPPrivacyTokenManager activateTokens:challenge:tokenIssuancePublicKey:clientNonceArray:unactivatedListFromServer:]";
    id v52 = "%s called with null (clientNonceArray.count == tokenWaitingActivationList.count)";
LABEL_31:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v51, OS_LOG_TYPE_FAULT, v52, buf, 0xCu);
    goto LABEL_29;
  }

  id v18 = [v11 count];
  id v19 = [v12 count];
  if (v18 < v19)
  {
    uint64_t v53 = nplog_obj(v19, v20, v21);
    id v51 = (void *)objc_claimAutoreleasedReturnValue(v53);
    if (!os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_FAULT)) {
      goto LABEL_29;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v62 = "-[NSPPrivacyTokenManager activateTokens:challenge:tokenIssuancePublicKey:clientNonceArray:unactivatedListFromServer:]";
    id v52 = "%s called with null (clientNonceArray.count >= unactivatedListFromServer.count)";
    goto LABEL_31;
  }

id sub_10009E990(uint64_t a1, void *a2, void *a3, char a4, char a5, int a6)
{
  id v11 = a2;
  if (a1)
  {
    id v12 = a3;
    uint64_t v13 = -[NSURL initWithString:](objc_alloc(&OBJC_CLASS___NSURL), "initWithString:", v11);
    id v14 = v13;
    if (a6)
    {
      id v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSURL host](v13, "host"));
      unsigned int v16 = [v15 isEqualToString:@"mask-api.icloud.com"];

      if (v16)
      {
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v14 absoluteString]);
        id v18 = [v17 mutableCopy];

        objc_msgSend( v18,  "replaceOccurrencesOfString:withString:options:range:",  @"mask-api.icloud.com/",  @"gateway.icloud.com/mask-api/",  0,  0,  objc_msgSend(v11, "length"));
        uint64_t v19 = objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v18));

        uint64_t v23 = nplog_obj(v20, v21, v22);
        id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "Fetching tokens from backup location",  buf,  2u);
        }

        id v14 = (void *)v19;
      }
    }

    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableURLRequest requestWithURL:](&OBJC_CLASS___NSMutableURLRequest, "requestWithURL:", v14));
    [v25 setHTTPMethod:@"POST"];
    [v25 setBoundInterfaceIdentifier:v12];

    if ((a5 & 1) == 0)
    {
      uint64_t v43 = a1;
      char v26 = a4;
      int has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.networkserviceproxy");
      uint64_t v28 = copyProductTypeString();
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      uint64_t v30 = copyOSNameString();
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
      uint64_t v32 = copyOSVersionString();
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
      uint64_t v34 = copyOSBuildString();
      uint64_t v35 = objc_claimAutoreleasedReturnValue(v34);
      uint64_t v36 = (void *)v35;
      else {
        SEL v37 = @"<%@> <%@;%@;%@>";
      }
      id v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  v37,  v29,  v31,  v33,  v35));

      if (v38) {
        [v25 setValue:v38 forHTTPHeaderField:@"X-Mask-Client-Info"];
      }
      if ((v26 & 1) == 0)
      {
        uint64_t v39 = *(void *)(v43 + 96);
        if (v39) {
          [v25 setValue:v39 forHTTPHeaderField:@"True-Client-Ip"];
        }
        id v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSPPrivacyProxyLocationMonitor sharedMonitor]( &OBJC_CLASS___NSPPrivacyProxyLocationMonitor,  "sharedMonitor"));
        id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 currentCountryPlusTimezone]);

        if (v41) {
          [v25 setValue:v41 forHTTPHeaderField:@"Client-Region"];
        }
      }
    }
  }

  else
  {
    uint64_t v25 = 0LL;
  }

  return v25;
}

LABEL_82:
LABEL_83:
    goto LABEL_84;
  }

  id v24 = -[NSPPrivateAccessTokenChallenge initWithData:]( objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge),  "initWithData:",  v130);
  uint64_t v25 = self;
  if (v24) {
    goto LABEL_10;
  }
  char v26 = nplog_obj(0LL, v22, v23);
  id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    __int128 v163 = (const char *)v132;
    _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "Failed to parse token challenge for %@",  buf,  0xCu);
  }

  (*((void (**)(id, void, void, void, void, void, uint64_t))v131 + 2))( v131,  0LL,  0LL,  0LL,  0LL,  0LL,  1LL);
LABEL_85:
}

void sub_10009FCE0(_Unwind_Exception *a1)
{
}

void sub_10009FD04(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  uint64_t v12 = NPGetInternalQueue(v11);
  uint64_t v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009FEE0;
  block[3] = &unk_1000FAB70;
  objc_copyWeak(&v31, (id *)(a1 + 112));
  id v18 = *(id *)(a1 + 32);
  id v19 = v11;
  id v20 = v9;
  id v21 = *(id *)(a1 + 40);
  id v30 = *(id *)(a1 + 104);
  id v22 = v10;
  id v23 = *(id *)(a1 + 48);
  id v24 = *(id *)(a1 + 56);
  id v25 = *(id *)(a1 + 64);
  id v26 = *(id *)(a1 + 72);
  id v27 = *(id *)(a1 + 80);
  id v28 = *(id *)(a1 + 88);
  id v29 = *(id *)(a1 + 96);
  int v33 = a2;
  __int128 v32 = *(_OWORD *)(a1 + 120);
  id v14 = v10;
  id v15 = v9;
  id v16 = v11;
  dispatch_async(v13, block);

  objc_destroyWeak(&v31);
}

void sub_10009FEE0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 136));
  id v5 = WeakRetained;
  if (!WeakRetained)
  {
    [*(id *)(a1 + 32) invalidateAndCancel];
    goto LABEL_22;
  }

  if (*(void *)(a1 + 40) || !*(void *)(a1 + 48))
  {
    uint64_t v6 = nplog_obj(WeakRetained, v3, v4);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void **)(a1 + 40);
      id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) URL]);
      *(_DWORD *)__int128 buf = 138412546;
      id v49 = v8;
      __int16 v50 = 2112;
      id v51 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Received token fetch error %@ for %@",  buf,  0x16u);
    }

    id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) domain]);
    if ([v10 isEqualToString:NSURLErrorDomain])
    {
      id v11 = [*(id *)(a1 + 40) code];

      if (v11 == (id)-999LL)
      {
        uint64_t v12 = *(void (**)(void))(*(void *)(a1 + 128) + 16LL);
LABEL_11:
        v12();
LABEL_12:
        id v13 = 0LL;
        id v14 = 0LL;
        goto LABEL_13;
      }
    }

    else
    {
    }

    uint64_t v12 = *(void (**)(void))(*(void *)(a1 + 128) + 16LL);
    goto LABEL_11;
  }

  uint64_t v23 = *(void *)(a1 + 64);
  uint64_t v24 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
  if ((objc_opt_isKindOfClass(v23, v24) & 1) == 0) {
    goto LABEL_12;
  }
  id v13 = *(id *)(a1 + 64);
  uint64_t has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.networkserviceproxy");
  if ((_DWORD)has_internal_diagnostics)
  {
    id v28 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v28 objectForKeyedSubscript:@"x-apple-request-uuid"]);
  }

  else
  {
    id v14 = 0LL;
  }

  uint64_t v29 = nplog_obj(has_internal_diagnostics, v26, v27);
  id v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    id v31 = [v13 statusCode];
    __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) URL]);
    *(_DWORD *)__int128 buf = 134218498;
    id v49 = v31;
    __int16 v50 = 2112;
    id v51 = v32;
    __int16 v52 = 2112;
    uint64_t v53 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Received HTTP response code %ld for %@ with request UUID %@",  buf,  0x20u);
  }

  if ([v13 statusCode] == (id)200)
  {
    id v33 = [[NSPPrivacyProxyTokenActivationResponse alloc] initWithData:*(void *)(a1 + 48)];
    uint64_t v34 = *(void **)(a1 + 72);
    uint64_t v35 = *(void **)(a1 + 80);
    uint64_t v36 = *(void **)(a1 + 88);
    SEL v37 = *(void **)(a1 + 96);
    id v38 = (void *)objc_claimAutoreleasedReturnValue([v33 activatedTokenLists]);
    uint64_t v39 = sub_10009E51C(v34, v35, v36, v37, v38);
    id v15 = (void *)objc_claimAutoreleasedReturnValue(v39);

    id v40 = [v33 tokenExpiryTimestamp];
    if (v40)
    {
      id v40 = (id)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( NSDate,  "dateWithTimeIntervalSince1970:",  (double)((unint64_t)[v33 tokenExpiryTimestamp] / 0x3E8)));
      uint64_t v43 = v40;
    }

    else
    {
      uint64_t v43 = 0LL;
    }

    uint64_t v44 = nplog_obj(v40, v41, v42);
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      id v46 = [v15 count];
      id v47 = *(void **)(a1 + 104);
      *(_DWORD *)__int128 buf = 134218242;
      id v49 = v46;
      __int16 v50 = 2112;
      id v51 = v47;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "activated %lu tokens for %@", buf, 0x16u);
    }

    *((void *)v5 + 11) += [v15 count];
    (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();

    goto LABEL_14;
  }

  if ([v13 statusCode] == (id)401) {
    [*((id *)v5 + 2) authenticationFailure];
  }
  (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();
LABEL_13:
  id v15 = 0LL;
LABEL_14:
  [*(id *)(a1 + 32) invalidateAndCancel];
  uint64_t v16 = mach_absolute_time();
  uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NSPTokenFetchAnalytics);
  -[NSPTokenFetchAnalytics setProxyURL:](v17, "setProxyURL:", *(void *)(a1 + 112));
  -[NSPTokenFetchAnalytics setProxyVendor:](v17, "setProxyVendor:", *(void *)(a1 + 104));
  -[NSPTokenFetchAnalytics setTierType:](v17, "setTierType:", *(void *)(a1 + 120));
  uint64_t v18 = *(int *)(a1 + 160);
  if (v18 >= 5) {
    id v19 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  *(int *)(a1 + 160)));
  }
  else {
    id v19 = off_1000FAE28[v18];
  }
  -[NSPTokenFetchAnalytics setAuthenticationType:](v17, "setAuthenticationType:", v19);

  -[NSPTokenFetchAnalytics setRequestedServerUUID:](v17, "setRequestedServerUUID:", v14);
  -[NSPTokenFetchAnalytics setRequestedTokenCount:](v17, "setRequestedTokenCount:", *(void *)(a1 + 144));
  -[NSPTokenFetchAnalytics setActivatedCount:](v17, "setActivatedCount:", [v15 count]);
  -[NSPTokenFetchAnalytics setHttpCode:](v17, "setHttpCode:", [v13 statusCode]);
  id v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) domain]);
  unsigned int v21 = [v20 isEqualToString:NSURLErrorDomain];

  if (v21) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v17, "setNsurlErrorCode:", [*(id *)(a1 + 40) code]);
  }
  double v22 = (double)(v16 - *(void *)(a1 + 152));
  if (qword_100117210 != -1) {
    dispatch_once(&qword_100117210, &stru_1000FADE8);
  }
  -[NSPTokenFetchAnalytics setLatency:](v17, "setLatency:", *(double *)&qword_100117218 * v22);
  -[NSPProxyAnalytics sendAnalytics](v17, "sendAnalytics");

LABEL_22:
}

void sub_1000A047C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!a1) {
    goto LABEL_38;
  }
  if (!v8) {
    goto LABEL_28;
  }
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 associatedIssuers]);
  id v11 = [v10 countByEnumeratingWithState:&v68 objects:v80 count:16];
  if (!v11) {
    goto LABEL_14;
  }
  id v12 = v11;
  uint64_t v13 = *(void *)v69;
  while (2)
  {
    for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v69 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(void **)(*((void *)&v68 + 1) + 8LL * (void)i);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 tokenKeys]);
      if ([v16 containsObject:v7])
      {
        unsigned __int8 v17 = [v15 hasTransparencyKeyBundle];

        if ((v17 & 1) != 0)
        {
          id v18 = v15;

          if (!v18) {
            goto LABEL_24;
          }
          id v19 = objc_alloc(&OBJC_CLASS___NSPPrivacyProxyTransparencyTokenEntry);
          id v20 = (void *)objc_claimAutoreleasedReturnValue([v18 transparencyKeyBundle]);
          id v21 = [v19 initWithData:v20];

          if (v21)
          {
            id v25 = (void *)objc_claimAutoreleasedReturnValue([v21 issuerName]);
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v18 issuerName]);
            unsigned __int8 v27 = [v25 isEqualToString:v26];

            if ((v27 & 1) != 0)
            {
              id v31 = (void *)objc_claimAutoreleasedReturnValue([v21 tokenKeys]);
              __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v18 tokenKeys]);
              unsigned __int8 v33 = [v31 isEqualToArray:v32];

              if ((v33 & 1) != 0)
              {
                SEL v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( NSDate,  "dateWithTimeIntervalSince1970:",  (double)(unint64_t)[v21 configurationDeliveryStart]));
                id v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( NSDate,  "dateWithTimeIntervalSince1970:",  (double)(unint64_t)[v21 configurationDeliveryEnd]));
                id v39 = sub_10005725C();
                uint64_t v40 = objc_claimAutoreleasedReturnValue(v39);
                uint64_t v41 = (void *)v40;
                if (v40) {
                  uint64_t v42 = *(void **)(v40 + 40);
                }
                else {
                  uint64_t v42 = 0LL;
                }
                id v43 = v42;

                id v44 = [v43 fetchDateIsWithinStart:v37 end:v38];
                if ((v44 & 1) != 0)
                {
                  id v47 = [[SoftwareTransparency alloc] initWithApplication:0];
                  if (v47)
                  {
                    __int128 v48 = (void *)objc_claimAutoreleasedReturnValue([v18 transparencyProof]);
                    id v64 = v37;
                    id v49 = (void *)objc_claimAutoreleasedReturnValue([v18 transparencyKeyBundle]);
                    v66[0] = _NSConcreteStackBlock;
                    v66[1] = 3221225472LL;
                    v66[2] = sub_1000A09E8;
                    v66[3] = &unk_1000F9888;
                    id v67 = v9;
                    [v47 verifyExpiringProofs:v48 for:v49 completion:v66];

                    SEL v37 = v64;
                  }

                  else
                  {
                    (*((void (**)(id, void))v9 + 2))(v9, 0LL);
                  }
                }

                else
                {
                  uint64_t v60 = nplog_obj(v44, v45, v46);
                  uint64_t v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v43 configurationFetchDate]);
                    uint64_t v62 = objc_claimAutoreleasedReturnValue([v43 etag]);
                    *(_DWORD *)__int128 buf = 138413058;
                    uint64_t v73 = v37;
                    __int16 v74 = 2112;
                    __int128 v75 = v38;
                    __int16 v76 = 2112;
                    __int128 v77 = v65;
                    __int16 v78 = 2112;
                    uint64_t v79 = v62;
                    __int16 v63 = (void *)v62;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_ERROR,  "Configuration start time (%@) and end time (%@) are not valid for configuration fetched at %@ (eta g %@), blocking fetching token keys",  buf,  0x2Au);
                  }

                  (*((void (**)(id, void))v9 + 2))(v9, 0LL);
                }

                goto LABEL_37;
              }

              uint64_t v59 = nplog_obj(v34, v35, v36);
              id v56 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)__int128 buf = 0;
                id v57 = "Failed to match token keys in transparency blob for token keys, blocking";
                goto LABEL_35;
              }

void sub_1000A09E8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if ([a2 result])
  {
    uint64_t v8 = _os_feature_enabled_impl("NetworkServiceProxy", "TransparencyValidation");
    char v9 = v8;
    uint64_t v12 = nplog_obj(v8, v10, v11);
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if ((v9 & 1) != 0)
    {
      if (v14)
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v24 = v5;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Keys not validated by transparency (error %@), blocking",  buf,  0xCu);
      }

      char v15 = 0;
    }

    else
    {
      if (v14)
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v24 = v5;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Keys not validated by transparency (error %@), allowing since feature flag is not enabled",  buf,  0xCu);
      }

      char v15 = 1;
    }
  }

  else
  {
    uint64_t v16 = nplog_obj(0LL, v6, v7);
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    char v15 = 1;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Keys validated by transparency, allowing",  buf,  2u);
    }
  }

  uint64_t v18 = NPGetInternalQueue(v17);
  id v19 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v18);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_1000A0BBC;
  void v20[3] = &unk_1000F9860;
  id v21 = *(id *)(a1 + 32);
  char v22 = v15;
  dispatch_async(v19, v20);
}

uint64_t sub_1000A0BBC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

void sub_1000A0BD0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  char v9 = v6;
  if (!a1) {
    goto LABEL_10;
  }
  if (!v5)
  {
    uint64_t v20 = nplog_obj(v6, v7, v8);
    id v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    if (!os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_FAULT))
    {
LABEL_14:

      goto LABEL_10;
    }

    int v24 = 136315138;
    id v25 = "-[NSPPrivacyTokenManager saveRetryIntervalFromHTTPResponse:issuerName:]";
    char v22 = "%s called with null httpResponse";
LABEL_16:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v21, OS_LOG_TYPE_FAULT, v22, (uint8_t *)&v24, 0xCu);
    goto LABEL_14;
  }

  if (!v6)
  {
    uint64_t v23 = nplog_obj(0LL, v7, v8);
    id v21 = (void *)objc_claimAutoreleasedReturnValue(v23);
    if (!os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_FAULT)) {
      goto LABEL_14;
    }
    int v24 = 136315138;
    id v25 = "-[NSPPrivacyTokenManager saveRetryIntervalFromHTTPResponse:issuerName:]";
    char v22 = "%s called with null issuerName";
    goto LABEL_16;
  }

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 allHeaderFields]);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"Retry-After"]);

  if (v11)
  {
    uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSNumberFormatter);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSNumberFormatter numberFromString:](v12, "numberFromString:", v11));
    [v13 doubleValue];
    double v15 = v14;

    if (v15 != 0.0)
    {
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceNow:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceNow:",  v15));
      uint64_t v17 = *(void **)(a1 + 56);
      if (!v17)
      {
        uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v19 = *(void **)(a1 + 56);
        *(void *)(a1 + 56) = v18;

        uint64_t v17 = *(void **)(a1 + 56);
      }

      [v17 setObject:v16 forKeyedSubscript:v9];
    }
  }

LABEL_10:
}

void sub_1000A0DB8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    id v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    if (v4)
    {
      uint64_t v10 = *(void **)(a1 + 64);
      if (!v10)
      {
        uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        uint64_t v12 = *(void **)(a1 + 64);
        *(void *)(a1 + 64) = v11;

        uint64_t v10 = *(void **)(a1 + 64);
      }

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v4]);
      if (!v13)
      {
        uint64_t v14 = NPGetInternalQueue(0LL);
        double v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
        dispatch_queue_t v16 = dispatch_queue_create_with_target_V2("Blocked token request queue", 0LL, v15);

        dispatch_suspend(v16);
        [*(id *)(a1 + 64) setObject:v16 forKeyedSubscript:v4];
      }
    }

    else
    {
      uint64_t v17 = nplog_obj(v7, v8, v9);
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        int v19 = 136315138;
        uint64_t v20 = "-[NSPPrivacyTokenManager blockNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "%s called with null issuerName",  (uint8_t *)&v19,  0xCu);
      }
    }
  }
}

void sub_1000A0F20(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    id v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    if (v4)
    {
      uint64_t v10 = *(void **)(a1 + 64);
      if (v10)
      {
        uint64_t v11 = (dispatch_object_s *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v4]);
        [*(id *)(a1 + 64) setObject:0 forKeyedSubscript:v4];
        if (v11) {
          dispatch_resume(v11);
        }
      }
    }

    else
    {
      uint64_t v12 = nplog_obj(v7, v8, v9);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        int v14 = 136315138;
        double v15 = "-[NSPPrivacyTokenManager unblockNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "%s called with null issuerName",  (uint8_t *)&v14,  0xCu);
      }
    }
  }
}

uint64_t sub_1000A1038(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = NPGetInternalQueue(v3);
    id v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
    dispatch_assert_queue_V2(v6);

    if (v4)
    {
      uint64_t v10 = *(void **)(a1 + 64);
      if (v10)
      {
        a1 = objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v4]);
        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v11 = nplog_obj(v7, v8, v9);
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        int v14 = 136315138;
        double v15 = "-[NSPPrivacyTokenManager copyQueueToWaitForNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "%s called with null issuerName",  (uint8_t *)&v14,  0xCu);
      }
    }

    a1 = 0LL;
  }

void sub_1000A1138( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, unsigned int a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15)
{
  id v154 = a2;
  unint64_t v153 = a3;
  unint64_t v151 = a4;
  id v142 = a5;
  id v152 = a6;
  id v138 = a8;
  id v139 = a9;
  id v143 = a10;
  id v133 = a11;
  id v141 = a12;
  id v145 = a13;
  id v137 = a14;
  id v21 = a15;
  id v140 = (void (**)(void, void, void, void, void, void, void))v21;
  if (a1)
  {
    uint64_t v22 = NPGetInternalQueue(v21);
    uint64_t v23 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v22);
    dispatch_assert_queue_V2(v23);

    uint64_t v27 = nplog_obj(v24, v25, v26);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
      *(_DWORD *)__int128 buf = 67109378;
      *(_DWORD *)uint64_t v198 = a7;
      *(_WORD *)&v198[4] = 2112;
      *(void *)&v198[6] = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "Requesting %u tokens from %@", buf, 0x12u);
    }

    id v30 = *(id *)(a1 + 56);
    if (v30)
    {
      id v31 = v30;
      __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
      BOOL v33 = v32 == 0LL;

      if (!v33)
      {
        id v34 = *(id *)(a1 + 56);
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
        __int128 v150 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:v35]);

        if (v150)
        {
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
          [v36 timeIntervalSinceDate:v150];
          double v38 = v37;

          if (v38 < 0.0)
          {
            ((void (**)(void, void, void, void, void, uint64_t, const __CFString *))v140)[2]( v140,  0LL,  0LL,  0LL,  0LL,  1009LL,  @"Rate-limited for token issuer based on retry-after header");
LABEL_92:

            goto LABEL_93;
          }

          id v39 = *(id *)(a1 + 56);
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
          [v39 setObject:0 forKeyedSubscript:v40];
        }
      }
    }

    if (v153) {
      uint64_t v41 = a7;
    }
    else {
      uint64_t v41 = 1LL;
    }
    uint64_t v134 = v41;
    __int128 v150 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (v145) {
      uint64_t v42 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    }
    else {
      uint64_t v42 = 0LL;
    }
    SCDynamicStoreRef v135 = v42;
    id v43 = sub_1000AF854((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenFetcher, v154, v152, v145, v150, v42, v134);
    __int128 v148 = (void *)objc_claimAutoreleasedReturnValue(v43);
    if ([v148 count])
    {
      id v132 = (void *)mach_absolute_time();
      if (v153)
      {
        id v144 = (id)objc_claimAutoreleasedReturnValue([(id)v153 attesterURL]);
      }

      else
      {
        uint64_t v46 = (void *)v151;
        if (!v151) {
          uint64_t v46 = *(void **)(a1 + 32);
        }
        id v144 = v46;
      }

      __int128 v146 = -[NSURLComponents initWithString:](objc_alloc(&OBJC_CLASS___NSURLComponents), "initWithString:", v144);
      if (v146)
      {
        if (!(v153 | v151))
        {
          id v49 = objc_alloc(&OBJC_CLASS___NSURLQueryItem);
          uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
          uint64_t v51 = -[NSURLQueryItem initWithName:value:](v49, "initWithName:value:", @"issuer", v50);

          uint64_t v196 = v51;
          uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v196,  1LL));
          -[NSURLComponents setQueryItems:](v146, "setQueryItems:", v52);
        }

        unsigned int v136 = [(id)v153 authType];
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSURLComponents string](v146, "string"));
        id v54 = sub_10009E990(a1, v53, 0LL, v136 == 4, v151 != 0, 0);
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);

        if (v55)
        {
          uint64_t v59 = sub_1000AFE94((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenFetcher, v154, v152, v138, v139, v148);
          __int128 v149 = (void *)objc_claimAutoreleasedReturnValue(v59);
          if ([v149 count])
          {
            uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v149 firstObject]);
            sub_1000AE390((uint64_t)v62, v55);

            BOOL v63 = v151 == 0;
            if (!v142) {
              BOOL v63 = 1;
            }
            if (!v63)
            {
              __int128 v191 = 0u;
              __int128 v192 = 0u;
              __int128 v189 = 0u;
              __int128 v190 = 0u;
              id v64 = v142;
              id v65 = [v64 countByEnumeratingWithState:&v189 objects:v195 count:16];
              if (v65)
              {
                uint64_t v66 = *(void *)v190;
                do
                {
                  for (CFIndex i = 0LL; i != v65; CFIndex i = (char *)i + 1)
                  {
                    if (*(void *)v190 != v66) {
                      objc_enumerationMutation(v64);
                    }
                    __int128 v68 = *(void **)(*((void *)&v189 + 1) + 8LL * (void)i);
                    __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v64 objectForKeyedSubscript:v68]);
                    id v70 = v68;
                    uint64_t v71 = objc_opt_class(&OBJC_CLASS___NSString);
                    if (v70)
                    {
                      char isKindOfClass = objc_opt_isKindOfClass(v70, v71);

                      if ((isKindOfClass & 1) != 0)
                      {
                        id v73 = v69;
                        uint64_t v74 = objc_opt_class(&OBJC_CLASS___NSString);
                        if (v73)
                        {
                          char v75 = objc_opt_isKindOfClass(v73, v74);

                          if ((v75 & 1) != 0) {
                            [v55 addValue:v73 forHTTPHeaderField:v70];
                          }
                        }
                      }
                    }
                  }

                  id v65 = [v64 countByEnumeratingWithState:&v189 objects:v195 count:16];
                }

                while (v65);
              }
            }

            __int128 v187 = 0u;
            __int128 v188 = 0u;
            __int128 v185 = 0u;
            __int128 v186 = 0u;
            id v76 = [0 countByEnumeratingWithState:&v185 objects:v194 count:16];
            if (v76)
            {
              uint64_t v77 = *(void *)v186;
              do
              {
                for (j = 0LL; j != v76; j = (char *)j + 1)
                {
                  if (*(void *)v186 != v77) {
                    objc_enumerationMutation(0LL);
                  }
                  uint64_t v79 = *(void *)(*((void *)&v185 + 1) + 8LL * (void)j);
                  __int128 v80 = (void *)objc_claimAutoreleasedReturnValue([0 objectForKeyedSubscript:v79]);
                  [v55 addValue:v80 forHTTPHeaderField:v79];
                }

                id v76 = [0 countByEnumeratingWithState:&v185 objects:v194 count:16];
              }

              while (v76);
            }

            if (v141) {
              BOOL v81 = v136 == 4;
            }
            else {
              BOOL v81 = 1;
            }
            if (!v81) {
              [v55 setValue:v141 forHTTPHeaderField:@"X-Mask-Subscription-Token"];
            }
            if (v153)
            {
              id v82 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenInfo);
              __int128 v170 = 0u;
              __int128 v171 = 0u;
              __int128 v168 = 0u;
              __int128 v169 = 0u;
              id v83 = v149;
              id v85 = [v83 countByEnumeratingWithState:&v168 objects:v193 count:16];
              if (v85)
              {
                uint64_t v86 = *(void *)v169;
                do
                {
                  for (k = 0LL; k != v85; k = (char *)k + 1)
                  {
                    if (*(void *)v169 != v86) {
                      objc_enumerationMutation(v83);
                    }
                    id Property = *(id *)(*((void *)&v168 + 1) + 8LL * (void)k);
                    if (Property) {
                      id Property = objc_getProperty(Property, v84, 24LL, 1);
                    }
                    id v89 = Property;
                    [v82 addTokenRequestList:v89];
                  }

                  id v85 = [v83 countByEnumeratingWithState:&v168 objects:v193 count:16];
                }

                while (v85);
              }

              id v90 = (void *)objc_claimAutoreleasedReturnValue([v152 key]);
              id v91 = sub_1000ACDF4((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenRequest, v90);
              __int128 v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
              [v82 setTokenKeyID:v92];

              id v93 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
              [v82 setProxyURL:v93];

              id v94 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
              [v82 setVendor:v94];

              id v95 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenActivationQuery);
              [v95 setTokenInfo:v82];
              if (v143)
              {
                id v96 = sub_10004055C((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v143, 0);
                id v97 = -[NSMutableArray count](v96, "count");
                if (v97)
                {
                  uint64_t v100 = nplog_obj(v97, v98, v99);
                  uint64_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue(v100);
                  if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v154 issuerName]);
                    *(_DWORD *)__int128 buf = 138412290;
                    *(void *)uint64_t v198 = v102;
                    _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_INFO,  "Sending auxiliary data with for %@",  buf,  0xCu);
                  }

                  id v103 = -[NSMutableArray mutableCopy](v96, "mutableCopy");
                  [v95 setAuxiliaryAuthArrays:v103];
                }
              }

              id v104 = [(id)v153 authType];
              switch((int)v104)
              {
                case 1:
                  goto LABEL_73;
                case 2:
                  uint64_t v107 = objc_opt_class(&OBJC_CLASS___NSPAnisette);
                  goto LABEL_86;
                case 3:
                  if (sub_10004C498()) {
LABEL_73:
                  }
                    uint64_t v107 = objc_opt_class(&OBJC_CLASS___NSPBAA);
                  else {
                    uint64_t v107 = objc_opt_class(&OBJC_CLASS___NSPBAA_Anisette);
                  }
LABEL_86:
                  uint64_t v119 = (void *)v107;
                  goto LABEL_87;
                case 4:
                  uint64_t v119 = (void *)objc_opt_class(&OBJC_CLASS___NSPAnonymousToken);
                  [v95 setAuthInfo:v145];
LABEL_87:
                  objc_initWeak((id *)buf, (id)a1);
                  v155[0] = _NSConcreteStackBlock;
                  v155[1] = 3221225472LL;
                  v155[2] = sub_1000A2C30;
                  v155[3] = &unk_1000FAC38;
                  objc_copyWeak(v166, (id *)buf);
                  id v156 = v55;
                  __int128 v165 = v140;
                  id v157 = v143;
                  id v158 = v148;
                  id v159 = v154;
                  id v160 = v152;
                  __int128 v161 = v150;
                  int v167 = v134;
                  uint64_t v120 = v135;
                  v166[1] = v119;
                  __int128 v162 = v120;
                  uint64_t v163 = a1;
                  id v164 = v144;
                  v166[2] = v132;
                  [v119 sendRequestForTokens:v156 tokenFetchURLSession:v137 tokenActivationQuery:v95 completionHandler:v155];

                  objc_destroyWeak(v166);
                  objc_destroyWeak((id *)buf);

                  break;
                default:
                  uint64_t v117 = nplog_obj(v104, v105, v106);
                  id v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);
                  if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
                  {
                    unsigned int v121 = [(id)v153 authType];
                    *(_DWORD *)__int128 buf = 67109120;
                    *(_DWORD *)uint64_t v198 = v121;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_ERROR,  "invalid override attester authentication type %d",  buf,  8u);
                  }

                  v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1005LL, 0LL);
                  break;
              }
            }

            else
            {
              uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v149 firstObject]);
              id v109 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v150, "firstObject"));
              id v110 = (id)objc_claimAutoreleasedReturnValue([v148 firstObject]);
              uint64_t v113 = v110;
              if (v108 && (id v110 = objc_getProperty(v108, v111, 24LL, 1)) != 0LL)
              {
                __int128 v114 = v110;
                objc_initWeak((id *)buf, (id)a1);
                uint64_t v115 = *(void **)(a1 + 16);
                v172[0] = _NSConcreteStackBlock;
                v172[1] = 3221225472LL;
                v172[2] = sub_1000A21AC;
                v172[3] = &unk_1000FABE8;
                objc_copyWeak(v183, (id *)buf);
                id v173 = v55;
                id v182 = v140;
                id v174 = v108;
                id v175 = v113;
                id v176 = v154;
                id v177 = v109;
                id v178 = v152;
                uint64_t v179 = v135;
                uint64_t v180 = a1;
                id v116 = v144;
                int v184 = 1;
                id v181 = v116;
                v183[1] = v132;
                [v115 sendRequestForTokens:v173 tokenFetchURLSession:v137 messageBody:v114 completionHandler:v172];

                objc_destroyWeak(v183);
                objc_destroyWeak((id *)buf);
              }

              else
              {
                uint64_t v130 = nplog_obj(v110, v111, v112);
                id v131 = (os_log_s *)objc_claimAutoreleasedReturnValue(v130);
                if (os_log_type_enabled(v131, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)__int128 buf = 136315138;
                  *(void *)uint64_t v198 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:c"
                                    "ustomAttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin"
                                    ":auxiliaryAuthInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraReque"
                                    "stHeaders:completionHandler:]";
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v131,  OS_LOG_TYPE_FAULT,  "%s called with null messageBody",  buf,  0xCu);
                }

                v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1004LL, 0LL);
                __int128 v114 = 0LL;
              }
            }
          }

          else
          {
            uint64_t v128 = nplog_obj(0LL, v60, v61);
            uint64_t v129 = (os_log_s *)objc_claimAutoreleasedReturnValue(v128);
            if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              *(void *)uint64_t v198 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:custo"
                                "mAttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxilia"
                                "ryAuthInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:co"
                                "mpletionHandler:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  v129,  OS_LOG_TYPE_FAULT,  "%s called with null (tokenRequests.count > 0)",  buf,  0xCu);
            }

            v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1004LL, 0LL);
          }
        }

        else
        {
          uint64_t v126 = nplog_obj(v56, v57, v58);
          id v127 = (os_log_s *)objc_claimAutoreleasedReturnValue(v126);
          if (os_log_type_enabled(v127, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 136315138;
            *(void *)uint64_t v198 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customA"
                              "ttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAu"
                              "thInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%s called with null urlRequest",  buf,  0xCu);
          }

          v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1004LL, 0LL);
        }
      }

      else
      {
        uint64_t v124 = nplog_obj(0LL, v47, v48);
        id v125 = (os_log_s *)objc_claimAutoreleasedReturnValue(v124);
        if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)uint64_t v198 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customAtt"
                            "ester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAuthIn"
                            "foCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_FAULT,  "%s called with null attesterURLComponents",  buf,  0xCu);
        }

        v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1004LL, 0LL);
      }
    }

    else
    {
      uint64_t v122 = nplog_obj(0LL, v44, v45);
      id v123 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
      if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)uint64_t v198 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customAttes"
                          "ter:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAuthInfoCa"
                          "cheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_FAULT,  "%s called with null (waitingTokens.count > 0)",  buf,  0xCu);
      }

      v140[2](v140, 0LL, 0LL, 0LL, 0LL, 1004LL, 0LL);
    }

    goto LABEL_92;
  }

LABEL_93:
}

void sub_1000A2160(_Unwind_Exception *a1)
{
}

void sub_1000A21AC(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  uint64_t v12 = NPGetInternalQueue(v11);
  uint64_t v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = sub_1000A2374;
  _OWORD v23[3] = &unk_1000FABC0;
  objc_copyWeak(v37, (id *)(a1 + 112));
  id v24 = v11;
  id v25 = v9;
  id v26 = *(id *)(a1 + 32);
  id v27 = v10;
  id v36 = *(id *)(a1 + 104);
  id v28 = *(id *)(a1 + 40);
  id v29 = *(id *)(a1 + 48);
  id v30 = *(id *)(a1 + 56);
  id v31 = *(id *)(a1 + 64);
  id v32 = *(id *)(a1 + 72);
  id v14 = *(id *)(a1 + 80);
  uint64_t v15 = *(void *)(a1 + 88);
  dispatch_queue_t v16 = *(void **)(a1 + 96);
  id v33 = v14;
  uint64_t v34 = v15;
  id v17 = v16;
  int v18 = *(_DWORD *)(a1 + 128);
  int v38 = a2;
  int v39 = v18;
  int v19 = *(void **)(a1 + 120);
  id v35 = v17;
  v37[1] = v19;
  id v20 = v10;
  id v21 = v9;
  id v22 = v11;
  dispatch_async(v13, v23);

  objc_destroyWeak(v37);
}

void sub_1000A2374(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 136));
  uint64_t v5 = WeakRetained;
  if (!WeakRetained) {
    goto LABEL_34;
  }
  if (*(void *)(a1 + 32) || !*(void *)(a1 + 40))
  {
    uint64_t v6 = nplog_obj(WeakRetained, v3, v4);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void **)(a1 + 32);
      id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) URL]);
      *(_DWORD *)__int128 buf = 138412546;
      id v80 = v8;
      __int16 v81 = 2112;
      id v82 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Received token fetch error %@ for %@",  buf,  0x16u);
    }

    id v10 = *(void **)(a1 + 32);
    if (*(void *)(a1 + 56))
    {
      if (!v10) {
        goto LABEL_17;
      }
    }

    else if (!v10)
    {
      id v22 = *(void (**)(void))(*(void *)(a1 + 128) + 16LL);
      goto LABEL_23;
    }

    NSErrorDomain v19 = (NSErrorDomain)objc_claimAutoreleasedReturnValue([v10 domain]);
    if (v19 != NSPOSIXErrorDomain || [*(id *)(a1 + 32) code] != (id)50)
    {
      NSErrorDomain v20 = (NSErrorDomain)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) domain]);
      NSErrorDomain v21 = v20;
      if (v20 != NSURLErrorDomain)
      {

LABEL_17:
        id v22 = *(void (**)(void))(*(void *)(a1 + 128) + 16LL);
LABEL_23:
        v22();
        goto LABEL_24;
      }

      if ([*(id *)(a1 + 32) code] != (id)-1009)
      {
        id v32 = [*(id *)(a1 + 32) code];

        if (v32 != (id)-1005LL) {
          goto LABEL_17;
        }
LABEL_21:
        id v22 = *(void (**)(void))(*(void *)(a1 + 128) + 16LL);
        goto LABEL_23;
      }
    }

    goto LABEL_21;
  }

  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
  if ((objc_opt_isKindOfClass(v11, v12) & 1) == 0)
  {
LABEL_24:
    id v13 = 0LL;
    int v18 = 0LL;
    goto LABEL_25;
  }

  id v13 = *(id *)(a1 + 56);
  uint64_t has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.networkserviceproxy");
  if ((_DWORD)has_internal_diagnostics)
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
    int v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:@"x-apple-request-uuid"]);
  }

  else
  {
    int v18 = 0LL;
  }

  uint64_t v33 = nplog_obj(has_internal_diagnostics, v15, v16);
  uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    id v35 = [v13 statusCode];
    id v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) URL]);
    *(_DWORD *)__int128 buf = 134218498;
    id v80 = v35;
    __int16 v81 = 2112;
    id v82 = v36;
    __int16 v83 = 2112;
    __int128 v84 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received HTTP response code %ld for %@ with request UUID %@",  buf,  0x20u);
  }

  if ([v13 statusCode] == (id)200)
  {
    double v37 = sub_1000AC388(*(void *)(a1 + 64), *(void **)(a1 + 40));
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v37);
    if (v40)
    {
      uint64_t v41 = *(void **)(a1 + 72);
      id v77 = 0LL;
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 activateTokenWithServerResponse:v40 error:&v77]);
      id v43 = v77;
      uint64_t v46 = v43;
      if (v43 || !v42)
      {
        uint64_t v61 = nplog_obj(v43, v44, v45);
        uint64_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v80 = v46;
          _os_log_error_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_ERROR,  "activateTokenWithServerResponse failed with error %@",  buf,  0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();
        id v23 = 0LL;
      }

      else
      {
        id v76 = v40;
        uint64_t v47 = objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenResponse);
        uint64_t v48 = *(void **)(a1 + 80);
        id v49 = *(void **)(a1 + 88);
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 96) key]);
        char v75 = v42;
        uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v42 signature]);
        uint64_t v52 = sub_1000AB5D4(v47, v48, v49, v50, v51);

        if (v52 && (id v53 = objc_getProperty(v52, v54, 8LL, 1)) != 0LL)
        {
          uint64_t v74 = v52;
          id v23 = v53;
          if ([*(id *)(a1 + 96) expiration]) {
            uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( NSDate,  "dateWithTimeIntervalSince1970:",  (double)(unint64_t)[*(id *)(a1 + 96) expiration]));
          }
          else {
            uint64_t v56 = 0LL;
          }
          uint64_t v70 = *(void *)(a1 + 128);
          id v78 = v23;
          uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v78,  1LL));
          (*(void (**)(uint64_t, void *, void, void *, void, void, void))(v70 + 16))( v70,  v71,  *(void *)(a1 + 104),  v56,  0LL,  0LL,  0LL);

          uint64_t v42 = v75;
          uint64_t v40 = v76;
          uint64_t v52 = v74;
          uint64_t v46 = 0LL;
        }

        else
        {
          uint64_t v72 = nplog_obj(v53, v54, v55);
          id v73 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);
          uint64_t v42 = v75;
          uint64_t v40 = v76;
          uint64_t v46 = 0LL;
          if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "Challenge response creation failed",  buf,  2u);
          }

          (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();
          id v23 = 0LL;
        }
      }
    }

    else
    {
      uint64_t v59 = nplog_obj(0LL, v38, v39);
      uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_ERROR,  "Failed to decrypt token response",  buf,  2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();
      id v23 = 0LL;
    }

    goto LABEL_26;
  }

  if ([v13 statusCode] == (id)401)
  {
    [v5[2] authenticationFailure];
  }

  else if ([v13 statusCode] == (id)429)
  {
    uint64_t v57 = *(void *)(a1 + 112);
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 80) issuerName]);
    sub_1000A0BD0(v57, v13, v58);
  }

  else if ((uint64_t)[v13 statusCode] >= 400)
  {
    [v13 statusCode];
  }

  BOOL v63 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
  id v64 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"Error-Reason"]);

  (*(void (**)(void))(*(void *)(a1 + 128) + 16LL))();
  id v65 = sub_10005725C();
  uint64_t v66 = (id *)objc_claimAutoreleasedReturnValue(v65);
  uint64_t v67 = *(void *)(a1 + 120);
  __int128 v68 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 80) issuerName]);
  id v69 = [v13 statusCode];
  if (v66) {
    [v66[8] sendRTCReportWithFailureType:1003 errorCode:v69 url:v67 ingressProxy:0 egressProxy:0 tokenServer:v68];
  }

LABEL_25:
  id v23 = 0LL;
LABEL_26:
  uint64_t v24 = mach_absolute_time();
  id v25 = objc_alloc_init(&OBJC_CLASS___NSPTokenFetchAnalytics);
  -[NSPTokenFetchAnalytics setProxyURL:](v25, "setProxyURL:", *(void *)(a1 + 120));
  id v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 80) issuerName]);
  -[NSPTokenFetchAnalytics setProxyVendor:](v25, "setProxyVendor:", v26);

  uint64_t v27 = *(int *)(a1 + 152);
  if (v27 >= 5) {
    id v28 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  *(int *)(a1 + 152)));
  }
  else {
    id v28 = off_1000FAE28[v27];
  }
  -[NSPTokenFetchAnalytics setAuthenticationType:](v25, "setAuthenticationType:", v28);

  -[NSPTokenFetchAnalytics setRequestedServerUUID:](v25, "setRequestedServerUUID:", v18);
  -[NSPTokenFetchAnalytics setRequestedTokenCount:](v25, "setRequestedTokenCount:", *(unsigned int *)(a1 + 156));
  -[NSPTokenFetchAnalytics setActivatedCount:](v25, "setActivatedCount:", v23 != 0LL);
  -[NSPTokenFetchAnalytics setHttpCode:](v25, "setHttpCode:", [v13 statusCode]);
  id v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) domain]);
  unsigned int v30 = [v29 isEqualToString:NSURLErrorDomain];

  if (v30) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v25, "setNsurlErrorCode:", [*(id *)(a1 + 32) code]);
  }
  double v31 = (double)(v24 - *(void *)(a1 + 144));
  if (qword_100117210 != -1) {
    dispatch_once(&qword_100117210, &stru_1000FADE8);
  }
  -[NSPTokenFetchAnalytics setLatency:](v25, "setLatency:", *(double *)&qword_100117218 * v31);
  -[NSPProxyAnalytics sendAnalytics](v25, "sendAnalytics");

LABEL_34:
}

void sub_1000A2C30(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  uint64_t v12 = NPGetInternalQueue(v11);
  id v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000A2E04;
  block[3] = &unk_1000FAC10;
  objc_copyWeak(v36, (id *)(a1 + 112));
  id v23 = v11;
  id v24 = v9;
  id v25 = *(id *)(a1 + 32);
  id v26 = v10;
  id v35 = *(id *)(a1 + 104);
  id v27 = *(id *)(a1 + 40);
  id v28 = *(id *)(a1 + 48);
  id v29 = *(id *)(a1 + 56);
  id v30 = *(id *)(a1 + 64);
  id v31 = *(id *)(a1 + 72);
  int v37 = *(_DWORD *)(a1 + 136);
  id v14 = *(id *)(a1 + 80);
  v36[1] = *(id *)(a1 + 120);
  uint64_t v15 = *(void *)(a1 + 88);
  uint64_t v16 = *(void **)(a1 + 96);
  id v32 = v14;
  uint64_t v33 = v15;
  id v17 = v16;
  int v38 = a2;
  int v18 = *(void **)(a1 + 128);
  id v34 = v17;
  uint8_t v36[2] = v18;
  id v19 = v10;
  id v20 = v9;
  id v21 = v11;
  dispatch_async(v13, block);

  objc_destroyWeak(v36);
}

void sub_1000A2E04(uint64_t a1)
{
  uint64_t v1 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 136));
  uint64_t v5 = WeakRetained;
  if (!WeakRetained) {
    goto LABEL_34;
  }
  uint64_t v96 = v1;
  if (*(void *)(v1 + 32) || !*(void *)(v1 + 40))
  {
    uint64_t v6 = nplog_obj(WeakRetained, v3, v4);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(v1 + 32);
      id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 48) URL]);
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)uint64_t v108 = v8;
      *(_WORD *)&v108[8] = 2112;
      id v109 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Received token fetch error %@ for %@",  buf,  0x16u);
    }

    id v10 = *(void **)(v1 + 32);
    if (*(void *)(v1 + 56))
    {
      if (!v10) {
        goto LABEL_17;
      }
    }

    else if (!v10)
    {
      id v22 = *(void (**)(void))(*(void *)(v1 + 128) + 16LL);
      goto LABEL_23;
    }

    NSErrorDomain v19 = (NSErrorDomain)objc_claimAutoreleasedReturnValue([v10 domain]);
    if (v19 != NSPOSIXErrorDomain || [*(id *)(v1 + 32) code] != (id)50)
    {
      NSErrorDomain v20 = (NSErrorDomain)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) domain]);
      NSErrorDomain v21 = v20;
      if (v20 != NSURLErrorDomain)
      {

LABEL_17:
        id v22 = *(void (**)(void))(*(void *)(v1 + 128) + 16LL);
LABEL_23:
        v22();
        goto LABEL_24;
      }

      if ([*(id *)(v1 + 32) code] != (id)-1009)
      {
        id v34 = [*(id *)(v1 + 32) code];

        if (v34 != (id)-1005LL) {
          goto LABEL_17;
        }
LABEL_21:
        id v22 = *(void (**)(void))(*(void *)(v1 + 128) + 16LL);
        goto LABEL_23;
      }
    }

    goto LABEL_21;
  }

  uint64_t v11 = *(void *)(v1 + 56);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
  if ((objc_opt_isKindOfClass(v11, v12) & 1) != 0)
  {
    id v13 = *(id *)(v1 + 56);
    uint64_t has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.networkserviceproxy");
    if ((_DWORD)has_internal_diagnostics)
    {
      id v17 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
      uint64_t v18 = objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:@"x-apple-request-uuid"]);
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    uint64_t v35 = nplog_obj(has_internal_diagnostics, v15, v16);
    id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      id v37 = [v13 statusCode];
      int v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 48) URL]);
      *(_DWORD *)__int128 buf = 134218498;
      *(void *)uint64_t v108 = v37;
      *(_WORD *)&v108[8] = 2112;
      id v109 = v38;
      *(_WORD *)id v110 = 2112;
      *(void *)&v110[2] = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Received HTTP response code %ld for %@ with request UUID %@",  buf,  0x20u);
    }

    uint64_t v39 = *(void **)(v1 + 64);
    if (v39) {
      sub_100040830((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v39, 0);
    }
    id v89 = (void *)v18;
    if ([v13 statusCode] != (id)200)
    {
      if ([v13 statusCode] == (id)401)
      {
        [*(id *)(v1 + 144) authenticationFailure];
      }

      else if ([v13 statusCode] == (id)429)
      {
        uint64_t v49 = *(void *)(v1 + 112);
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 80) issuerName]);
        sub_1000A0BD0(v49, v13, v50);
      }

      else if ((uint64_t)[v13 statusCode] >= 400)
      {
        [v13 statusCode];
      }

      id v77 = (void *)objc_claimAutoreleasedReturnValue([v13 allHeaderFields]);
      id v78 = (void *)objc_claimAutoreleasedReturnValue([v77 objectForKeyedSubscript:@"Error-Reason"]);

      (*(void (**)(void))(*(void *)(v1 + 128) + 16LL))();
      id v79 = sub_10005725C();
      id v80 = (id *)objc_claimAutoreleasedReturnValue(v79);
      uint64_t v81 = *(void *)(v1 + 120);
      id v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 80) issuerName]);
      id v83 = [v13 statusCode];
      if (v80) {
        [v80[8] sendRTCReportWithFailureType:1003 errorCode:v83 url:v81 ingressProxy:0 egressProxy:0 tokenServer:v82];
      }

      id v23 = 0LL;
      uint64_t v25 = v1;
      id v24 = v89;
      goto LABEL_26;
    }

    id v40 = [[NSPPrivacyProxyTokenActivationResponse alloc] initWithData:*(void *)(v1 + 40)];
    uint64_t v41 = *(void **)(v1 + 72);
    uint64_t v42 = *(void **)(v1 + 80);
    id v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 88) key]);
    uint64_t v44 = *(void **)(v1 + 96);
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v40 activatedTokenLists]);
    uint64_t v46 = sub_10009E51C(v41, v42, v43, v44, v45);
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(v46);

    uint64_t v1 = v96;
    if ([*(id *)(v96 + 88) expiration])
    {
      unint64_t v48 = (unint64_t)[*(id *)(v96 + 88) expiration];
    }

    else
    {
      if (![v40 tokenExpiryTimestamp])
      {
        id v95 = 0LL;
        id v24 = v89;
        goto LABEL_52;
      }

      unint64_t v48 = (unint64_t)[v40 tokenExpiryTimestamp] / 0x3E8;
    }

    id v24 = v89;
    id v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSince1970:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSince1970:",  (double)v48));
LABEL_52:
    id v23 = [v47 count];
    uint64_t v53 = nplog_obj(v23, v51, v52);
    id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
    __int128 v88 = v47;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      id v94 = (void *)objc_claimAutoreleasedReturnValue([v40 activatedTokenLists]);
      id v55 = v23;
      unsigned int v56 = [v94 count];
      id v57 = v40;
      int v58 = *(_DWORD *)(v96 + 160);
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v96 + 80) issuerName]);
      *(_DWORD *)__int128 buf = 67109890;
      *(_DWORD *)uint64_t v108 = (_DWORD)v55;
      *(_WORD *)&v108[4] = 1024;
      *(_DWORD *)&v108[6] = v56;
      id v23 = v55;
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v58;
      id v40 = v57;
      uint64_t v47 = v88;
      HIWORD(v109) = 2112;
      *(void *)id v110 = v59;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_INFO, "Received %u/%u/%u tokens from %@", buf, 0x1Eu);

      id v24 = v89;
    }

    if (*(void *)(v96 + 64))
    {
      id v85 = v23;
      id v86 = v13;
      __int128 v87 = v5;
      __int128 v103 = 0u;
      __int128 v104 = 0u;
      __int128 v101 = 0u;
      __int128 v102 = 0u;
      id v84 = v40;
      id obj = (id)objc_claimAutoreleasedReturnValue([v40 auxiliaryAuthArrays]);
      id v92 = [obj countByEnumeratingWithState:&v101 objects:v106 count:16];
      if (v92)
      {
        uint64_t v91 = *(void *)v102;
        do
        {
          uint64_t v60 = 0LL;
          do
          {
            if (*(void *)v102 != v91) {
              objc_enumerationMutation(obj);
            }
            uint64_t v93 = v60;
            uint64_t v61 = *(void **)(*((void *)&v101 + 1) + 8 * v60);
            __int128 v97 = 0u;
            __int128 v98 = 0u;
            __int128 v99 = 0u;
            __int128 v100 = 0u;
            uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v61 contentLists]);
            id v63 = [v62 countByEnumeratingWithState:&v97 objects:v105 count:16];
            if (v63)
            {
              id v66 = v63;
              uint64_t v67 = *(void *)v98;
              do
              {
                __int128 v68 = 0LL;
                do
                {
                  if (*(void *)v98 != v67) {
                    objc_enumerationMutation(v62);
                  }
                  id v69 = *(void **)(*((void *)&v97 + 1) + 8LL * (void)v68);
                  uint64_t v70 = nplog_obj(v63, v64, v65);
                  uint64_t v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue([v61 label]);
                    id v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v96 + 80) issuerName]);
                    *(_DWORD *)__int128 buf = 138412546;
                    *(void *)uint64_t v108 = v72;
                    *(_WORD *)&v108[8] = 2112;
                    id v109 = v73;
                    _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_INFO,  "Received auxiliary data with label %@ for %@",  buf,  0x16u);
                  }

                  unsigned int v74 = [v61 authType];
                  char v75 = *(void **)(v96 + 64);
                  id v76 = (void *)objc_claimAutoreleasedReturnValue([v61 label]);
                  sub_100040F68((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, v69, v74, v75, v76, v95, 1);

                  __int128 v68 = (char *)v68 + 1;
                }

                while (v66 != v68);
                id v63 = [v62 countByEnumeratingWithState:&v97 objects:v105 count:16];
                id v66 = v63;
              }

              while (v63);
            }

            uint64_t v60 = v93 + 1;
          }

          while ((id)(v93 + 1) != v92);
          id v92 = [obj countByEnumeratingWithState:&v101 objects:v106 count:16];
        }

        while (v92);
      }

      id v13 = v86;
      uint64_t v5 = v87;
      uint64_t v1 = v96;
      uint64_t v47 = v88;
      id v24 = v89;
      id v40 = v84;
      id v23 = v85;
    }

    (*(void (**)(void))(*(void *)(v1 + 128) + 16LL))();

    goto LABEL_25;
  }

uint64_t sub_1000A3830(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  if (!a1)
  {
LABEL_14:
    a5 = 0LL;
    goto LABEL_28;
  }

  if (v10 && [v10 tokenType] == 3)
  {
    if (v9)
    {
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 originNames]);
      id v13 = [v12 count];

      if (v11 && (unint64_t)v13 >= 2)
      {
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v10 originNames]);
        unsigned __int8 v15 = [v14 containsObject:v11];

        if ((v15 & 1) == 0)
        {
          uint64_t v24 = nplog_obj(v16, v17, v18);
          NSErrorDomain v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            id v43 = (void *)objc_claimAutoreleasedReturnValue([v10 originNames]);
            *(_DWORD *)__int128 buf = 138412546;
            *(void *)&uint8_t buf[4] = v11;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v43;
            _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "Failed to find origin name %@ in %@",  buf,  0x16u);
          }

          a5 = 0LL;
          goto LABEL_27;
        }

        NSErrorDomain v19 = (os_log_s *)v11;
LABEL_11:
        NSErrorDomain v20 = [v9 bytes];
        id v45 = 0LL;
        __int128 v21 = v20[1];
        *(_OWORD *)__int128 buf = *v20;
        *(_OWORD *)&uint8_t buf[16] = v21;
        id v22 = (void *)objc_claimAutoreleasedReturnValue( +[LSBundleRecord bundleRecordForAuditToken:error:]( &OBJC_CLASS___LSBundleRecord,  "bundleRecordForAuditToken:error:",  buf,  &v45));
        id v23 = v45;
        if (!v22)
        {
LABEL_26:

LABEL_27:
          goto LABEL_28;
        }

        if ([v22 developerType] == 1)
        {
          a5 = 1LL;
          goto LABEL_26;
        }

        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v22 infoDictionary]);
        id v26 = [v25 objectForKey:@"NSPrivateAccessTokenOrigins" ofClass:objc_opt_class(NSArray)];
        uint64_t isKindOfClass = objc_claimAutoreleasedReturnValue(v26);
        id v30 = (void *)isKindOfClass;
        if (isKindOfClass
          && (uint64_t v31 = objc_opt_class(&OBJC_CLASS___NSArray),
              uint64_t isKindOfClass = objc_opt_isKindOfClass(v30, v31),
              (isKindOfClass & 1) != 0))
        {
          id v32 = [v30 count];
          if ((unint64_t)v32 < 6)
          {
            id v40 = [v30 containsObject:v19];
            if ((v40 & 1) != 0)
            {
              a5 = 1LL;
              goto LABEL_25;
            }

            uint64_t v44 = nplog_obj(v40, v41, v42);
            id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__int128 buf = 0;
              id v37 = "Not allowed to request token, not in list";
              goto LABEL_34;
            }
          }

          else
          {
            uint64_t v35 = nplog_obj(v32, v33, v34);
            id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__int128 buf = 0;
              id v37 = "Not allowed to request token, too many origins in list";
LABEL_34:
              _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v37, buf, 2u);
            }
          }
        }

        else
        {
          uint64_t v38 = nplog_obj(isKindOfClass, v28, v29);
          id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int128 buf = 0;
            id v37 = "Not allowed to request token, no listed origins under NSPrivateAccessTokenOrigins";
            goto LABEL_34;
          }
        }

        a5 = 0LL;
LABEL_25:

        goto LABEL_26;
      }

      NSErrorDomain v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v10 originName]);
      if (v19) {
        goto LABEL_11;
      }
    }

    goto LABEL_14;
  }

  a5 = 1LL;
LABEL_28:

  return a5;
}

LABEL_83:
}

              int v184 = nplog_obj(v181, v182, v183);
              id v94 = (void *)objc_claimAutoreleasedReturnValue(v184);
              if (!os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_ERROR)) {
                goto LABEL_44;
              }
              *(_WORD *)__int128 buf = 0;
              uint64_t v96 = "Failed to generate the request key";
LABEL_49:
              __int128 v97 = buf;
LABEL_50:
              _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v94, OS_LOG_TYPE_ERROR, v96, v97, 2u);
              goto LABEL_44;
            }

            uint64_t v180 = nplog_obj(0LL, v103, v104);
            id v140 = (void *)objc_claimAutoreleasedReturnValue(v180);
            if (!os_log_type_enabled((os_log_t)v140, OS_LOG_TYPE_ERROR))
            {
LABEL_82:
              id v13 = v231;

              goto LABEL_83;
            }

            *(_WORD *)__int128 v245 = 0;
            id v141 = "generate key: SecKeyCopyPublicKey failed";
          }

          else
          {
            id v139 = nplog_obj(0LL, v100, v101);
            id v140 = (void *)objc_claimAutoreleasedReturnValue(v139);
            if (!os_log_type_enabled((os_log_t)v140, OS_LOG_TYPE_ERROR)) {
              goto LABEL_82;
            }
            *(_WORD *)__int128 v245 = 0;
            id v141 = "generate key: Failed to access stored client key";
          }

          _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v140, OS_LOG_TYPE_ERROR, v141, v245, 2u);
          goto LABEL_82;
        }

        __int128 v88 = nplog_obj(v42, v43, v44);
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v88);
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          goto LABEL_43;
        }
        id v89 = bswap32(*(unsigned __int16 *)(v54 + 37)) >> 16;
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v89;
        uint64_t v47 = "AEAD %u is not supported";
      }

      else
      {
        id v86 = nplog_obj(v42, v43, v44);
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v86);
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          goto LABEL_43;
        }
        __int128 v87 = bswap32(*(unsigned __int16 *)(v54 + 35)) >> 16;
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v87;
        uint64_t v47 = "KDF %u is not supported";
      }
    }

    else
    {
      id v84 = nplog_obj(v42, v43, v44);
      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v84);
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
        goto LABEL_43;
      }
      id v85 = bswap32(*(unsigned __int16 *)(v54 + 1)) >> 16;
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v85;
      uint64_t v47 = "KEM %u is not supported";
    }

    unint64_t v48 = v46;
    uint64_t v49 = 8;
    goto LABEL_42;
  }

  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v11 originNames]);
  id v32 = [v31 containsObject:v14];

  if ((v32 & 1) != 0)
  {
    objc_setProperty_atomic((id)a1, v34, v14, 56LL);
    goto LABEL_15;
  }

  uint64_t v52 = nplog_obj(v33, v34, v35);
  uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    __int128 v98 = (void *)objc_claimAutoreleasedReturnValue([v11 originNames]);
    *(_DWORD *)md = 138412546;
    *(void *)&md[4] = v14;
    *(_WORD *)&md[12] = 2112;
    *(void *)&md[14] = v98;
    _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "Failed to find origin name %@ in %@",  md,  0x16u);
  }

void sub_1000A4788( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

uint64_t sub_1000A47BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000A47CC(uint64_t a1)
{
}

void sub_1000A47D4(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v11 = a2;
  id v12 = a4;
  id v13 = a7;
  uint64_t v14 = *(void *)(a1 + 48);
  unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([v11 firstObject]);
  (*(void (**)(uint64_t, void *, uint64_t, id))(v14 + 16))(v14, v15, a6, v13);

  if ((unint64_t)[v11 count] >= 2)
  {
    id v16 = [v11 mutableCopy];
    [v16 removeObjectAtIndex:0];
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id v17 = v16;
    id v18 = [v17 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v23;
      do
      {
        __int128 v21 = 0LL;
        do
        {
          if (*(void *)v23 != v20) {
            objc_enumerationMutation(v17);
          }
          sub_10004013C( (uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache,  *(void **)(a1 + 32),  *(void **)(*((void *)&v22 + 1) + 8LL * (void)v21),  v12);
          __int128 v21 = (char *)v21 + 1;
        }

        while (v19 != v21);
        id v19 = [v17 countByEnumeratingWithState:&v22 objects:v26 count:16];
      }

      while (v19);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000A496C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v13;
    do
    {
      id v11 = 0LL;
      do
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(v6);
        }
        sub_10004013C( (uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache,  *(void **)(a1 + 32),  *(void **)(*((void *)&v12 + 1) + 8LL * (void)v11),  v7);
        id v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v9 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }

    while (v9);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000A4A88(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v13;
    do
    {
      id v11 = 0LL;
      do
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(v6);
        }
        sub_10004013C( (uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache,  *(void **)(a1 + 32),  *(void **)(*((void *)&v12 + 1) + 8LL * (void)v11),  v7);
        id v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v9 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }

    while (v9);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000A4BA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;
}

void sub_1000A5A5C(_Unwind_Exception *a1)
{
}

id sub_1000A5AC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) issuerName]);
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v10 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Resuming token pair fetch, received notification on long-lived token for %@",  buf,  0xCu);
  }

  LOWORD(v_Block_object_dispose((const void *)(v1 - 176), 8) = *(_WORD *)(a1 + 136);
  return objc_msgSend( *(id *)(a1 + 40),  "fetchPairedPrivateAccessTokensForChallenge:overrideAttester:tokenKey:originNameKey:selectedOrigin:pairedChall enge:overridePairedAttester:pairedTokenKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:",  *(void *)(a1 + 32),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 88),  *(void *)(a1 + 96),  *(void *)(a1 + 104),  *(void *)(a1 + 112),  v8,  *(void *)(a1 + 120),  *(void *)(a1 + 128));
}

id sub_1000A5BB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = nplog_obj(a1, a2, a3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) issuerName]);
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v10 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Resuming token pair fetch, received notification on one-time token for %@",  buf,  0xCu);
  }

  LOWORD(v_Block_object_dispose((const void *)(v1 - 176), 8) = *(_WORD *)(a1 + 136);
  return objc_msgSend( *(id *)(a1 + 40),  "fetchPairedPrivateAccessTokensForChallenge:overrideAttester:tokenKey:originNameKey:selectedOrigin:pairedChall enge:overridePairedAttester:pairedTokenKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:",  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 32),  *(void *)(a1 + 88),  *(void *)(a1 + 96),  *(void *)(a1 + 104),  *(void *)(a1 + 112),  v8,  *(void *)(a1 + 120),  *(void *)(a1 + 128));
}

void sub_1000A5CA0(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 48);
    uint64_t v5 = *(void **)(a1 + 56);
    id v6 = *(void **)(a1 + 64);
    id v7 = *(void **)(a1 + 72);
    uint64_t v8 = *(void **)(a1 + 80);
    id v9 = *(void **)(a1 + 88);
    uint64_t v10 = *(void **)(a1 + 96);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_1000A5DE0;
    v14[3] = &unk_1000FACD8;
    id v11 = *(void **)(a1 + 104);
    id v12 = *(id *)(a1 + 112);
    uint64_t v13 = *(void *)(a1 + 120);
    id v17 = v12;
    uint64_t v18 = v13;
    id v15 = *(id *)(a1 + 48);
    id v16 = *(id *)(a1 + 32);
    sub_1000A1138(v3, v4, v5, 0LL, 0LL, v6, 1u, v7, v8, 0LL, v9, v10, 0LL, v11, v14);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 112) + 16LL))();
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  }

void sub_1000A5DE0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7)
{
  id v18 = a2;
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  id v16 = a7;
  if (a6 || ![v18 count]) {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }
  id v17 = (void *)objc_claimAutoreleasedReturnValue([v18 firstObject]);
  if (v17)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL), v17);
    sub_100041A88((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache, *(void **)(a1 + 32), v17);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000A5EDC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) issuerName]);
  uint64_t v3 = dispatch_group_create();
  uint64_t v4 = v3;
  if (*(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL) && (*(_BYTE *)(a1 + 132) || *(_DWORD *)(a1 + 128)))
  {
    dispatch_group_enter(v3);
    sub_1000A0DB8(*(void *)(a1 + 32), v2);
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(a1 + 56);
    id v7 = *(void **)(a1 + 64);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = sub_1000A6104;
    v21[3] = &unk_1000FAD50;
    id v31 = *(id *)(a1 + 104);
    uint64_t v8 = v4;
    char v34 = *(_BYTE *)(a1 + 132);
    int v33 = *(_DWORD *)(a1 + 128);
    uint64_t v9 = *(void *)(a1 + 32);
    __int128 v22 = v8;
    uint64_t v23 = v9;
    id v24 = *(id *)(a1 + 48);
    id v25 = *(id *)(a1 + 64);
    id v26 = *(id *)(a1 + 56);
    id v27 = *(id *)(a1 + 72);
    id v10 = *(id *)(a1 + 80);
    uint64_t v11 = *(void *)(a1 + 112);
    id v28 = v10;
    uint64_t v32 = v11;
    id v29 = *(id *)(a1 + 88);
    id v30 = *(id *)(a1 + 96);
    sub_1000A047C(v5, v6, v7, v21);
  }

  uint64_t v12 = NPGetInternalQueue(v3);
  id v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v12);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_1000A64A0;
  v17[3] = &unk_1000FAD78;
  void v17[4] = *(void *)(a1 + 32);
  id v18 = v2;
  id v14 = *(id *)(a1 + 88);
  uint64_t v15 = *(void *)(a1 + 120);
  id v19 = v14;
  uint64_t v20 = v15;
  id v16 = v2;
  dispatch_group_notify(v4, v13, v17);
}

void sub_1000A6104(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    int v3 = *(unsigned __int8 *)(a1 + 124);
    unsigned int v4 = *(_DWORD *)(a1 + 120) + v3;
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = *(void **)(a1 + 48);
    uint64_t v8 = *(void **)(a1 + 56);
    id v7 = *(void **)(a1 + 64);
    uint64_t v9 = *(void **)(a1 + 72);
    id v10 = *(void **)(a1 + 80);
    uint64_t v11 = *(void **)(a1 + 104);
    uint64_t v12 = *(void *)(*(void *)(a1 + 112) + 8LL);
    v17[0] = _NSConcreteStackBlock;
    id v13 = *(void **)(v12 + 40);
    v17[2] = sub_1000A6284;
    v17[3] = &unk_1000FAD28;
    id v14 = *(void **)(a1 + 88);
    v17[1] = 3221225472LL;
    char v24 = v3;
    id v15 = v11;
    uint64_t v16 = *(void *)(a1 + 112);
    id v22 = v15;
    uint64_t v23 = v16;
    id v18 = *(id *)(a1 + 48);
    id v19 = *(id *)(a1 + 64);
    id v20 = *(id *)(a1 + 96);
    id v21 = *(id *)(a1 + 32);
    sub_1000A1138(v5, v6, v8, 0LL, 0LL, v7, v4, 0LL, 0LL, 0LL, v9, v10, v13, v14, v17);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 104) + 16LL))();
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  }

void sub_1000A6284(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7)
{
  id v26 = a2;
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  id v16 = a7;
  if (*(_BYTE *)(a1 + 80))
  {
    if (a6 || ![v26 count])
    {
      (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
    }

    else
    {
      uint64_t v19 = *(void *)(a1 + 64);
      uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v26 firstObject]);
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v13 firstObject]);
      (*(void (**)(uint64_t, uint64_t, void *, void *, void, void))(v19 + 16))( v19,  v20,  v21,  v22,  0LL,  0LL);
    }

    if ((unint64_t)[v26 count] >= 2)
    {
      id v18 = [v26 mutableCopy];
      [v18 removeObjectAtIndex:0];
      id v23 = 0LL;
      if ((unint64_t)[v13 count] >= 2)
      {
        id v23 = [v13 mutableCopy];
        [v23 removeObjectAtIndex:0];
      }

      char v24 = *(void **)(a1 + 32);
      id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) key]);
      sub_100042298( (uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache,  v24,  v18,  v23,  v14,  v25,  *(void **)(a1 + 48),  *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL));

      goto LABEL_12;
    }
  }

  else if ([v26 count])
  {
    id v17 = *(void **)(a1 + 32);
    id v18 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) key]);
    sub_100042298( (uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenCache,  v17,  v26,  v13,  v14,  v18,  *(void **)(a1 + 48),  *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL));
LABEL_12:
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

void sub_1000A64A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 56) + 8LL);
  int v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0LL;
}

void sub_1000A6904( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_1000A6930(uint64_t a1, int a2, void *a3)
{
  id v9 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v6 = WeakRetained;
  if (a2 == 2 && WeakRetained)
  {
    if (v9 && nw_array_get_count()) {
      id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
    }
    else {
      id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
    }
    v7();
    nw_resolver_cancel(v6[13]);
    uint64_t v8 = (void *)v6[13];
    v6[13] = 0LL;
  }
}

void sub_1000A6A44(id a1)
{
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    LODWORD(v2) = info.denom;
    *(double *)&qword_100117218 = (double)v1 / (double)v2 / 1000.0 / 1000000.0;
  }

void sub_1000A6A98(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v10 = a6;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  objc_opt_self(a1);
  id v18 = -[UNUserNotificationCenter initWithBundleIdentifier:]( objc_alloc(&OBJC_CLASS___UNUserNotificationCenter),  "initWithBundleIdentifier:",  @"com.apple.iCloud.FollowUp");
  -[UNUserNotificationCenter removeAllDeliveredNotifications](v18, "removeAllDeliveredNotifications");
  id v14 = objc_alloc_init(&OBJC_CLASS___UNMutableNotificationContent);
  -[UNMutableNotificationContent setTitle:](v14, "setTitle:", v13);

  -[UNMutableNotificationContent setBody:](v14, "setBody:", v12);
  -[UNMutableNotificationContent setShouldIgnoreDoNotDisturb:](v14, "setShouldIgnoreDoNotDisturb:", 1LL);
  -[UNMutableNotificationContent setShouldIgnoreDowntime:](v14, "setShouldIgnoreDowntime:", 1LL);
  -[UNMutableNotificationContent setShouldSuppressScreenLightUp:](v14, "setShouldSuppressScreenLightUp:", 1LL);
  -[UNMutableNotificationContent setDefaultActionURL:](v14, "setDefaultActionURL:", v11);

  id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
  id v17 = (void *)objc_claimAutoreleasedReturnValue( +[UNNotificationRequest requestWithIdentifier:content:trigger:destinations:]( &OBJC_CLASS___UNNotificationRequest,  "requestWithIdentifier:content:trigger:destinations:",  v16,  v14,  0LL,  3LL));

  -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]( v18,  "addNotificationRequest:withCompletionHandler:",  v17,  v10);
}

id sub_1000A6BF0(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, int a7, void *a8, void *a9)
{
  id value = a2;
  id v54 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a8;
  id v20 = a9;
  if (!a1) {
    goto LABEL_33;
  }
  v56.receiver = a1;
  v56.super_class = (Class)&OBJC_CLASS___NSPUserNotification;
  id v21 = objc_msgSendSuper2(&v56, "init");
  if (v21)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_100117220);
    BOOL v22 = qword_100117228 == 0;
    uint64_t v26 = nplog_obj(v23, v24, v25);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    id v28 = v27;
    if (!v22)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v62) = 138412290;
        *(void *)((char *)&v62 + 4) = qword_100117228;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Already have outstanding notification %@, cannot show an additional one",  (uint8_t *)&v62,  0xCu);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
      goto LABEL_33;
    }

    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v62) = 138412290;
      *(void *)((char *)&v62 + 4) = v21;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "No outstanding notification, we are now the current notification %@",  (uint8_t *)&v62,  0xCu);
    }

    objc_storeStrong((id *)&qword_100117228, v21);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
    SInt32 error = 0;
    objc_setProperty_atomic(v21, v29, 0LL, 8LL);
    Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v32 = Mutable;
    if (Mutable)
    {
      CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, value);
      CFDictionarySetValue(v32, kCFUserNotificationAlertMessageKey, v54);
      if (v18)
      {
        int v33 = (void *)sub_10003DCCC(v18);
        if (v33) {
          CFDictionarySetValue(v32, kCFUserNotificationIconURLKey, v33);
        }
      }

      if (v16) {
        CFDictionarySetValue(v32, kCFUserNotificationAlternateButtonTitleKey, v16);
      }
      if (v17)
      {
        char v34 = (const void **)&kCFUserNotificationOtherButtonTitleKey;
        if (!a7) {
          char v34 = (const void **)&kCFUserNotificationDefaultButtonTitleKey;
        }
        CFDictionarySetValue(v32, *v34, v17);
      }

      if (a7) {
        CFOptionFlags v35 = 35LL;
      }
      else {
        CFOptionFlags v35 = 1LL;
      }
      CFUserNotificationRef v36 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, v35, &error, v32);
      CFRelease(v32);
      if (!v36 || error)
      {
        uint64_t v46 = nplog_obj(v37, v38, v39);
        uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v62) = 67109120;
          DWORD1(v62) = error;
          _os_log_error_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "CFUserNotificationCreate failed with error %d, cancelling",  (uint8_t *)&v62,  8u);
        }

LABEL_32:
        sub_1000A7110((uint64_t)v21);

LABEL_33:
        id v21 = 0LL;
        goto LABEL_34;
      }

      objc_setProperty_atomic(v21, v38, v36, 8LL);
    }

    if (!objc_getProperty(v21, v31, 8LL, 1)) {
      goto LABEL_32;
    }
    id v40 = v19;
    id v41 = v20;
    uint64_t v58 = 0LL;
    uint64_t v59 = &v58;
    uint64_t v60 = 0x2020000000LL;
    char v61 = 0;
    *(void *)&__int128 v62 = _NSConcreteStackBlock;
    *((void *)&v62 + 1) = 3221225472LL;
    id v63 = sub_1000A7228;
    uint64_t v64 = &unk_1000FAE80;
    id v65 = v21;
    id v42 = v41;
    id v67 = v42;
    id v52 = v40;
    id v66 = v52;
    __int128 v68 = &v58;
    sub_1000A7170((uint64_t)&OBJC_CLASS___NSPUserNotification, &v62);
    if (*((_BYTE *)v59 + 24))
    {

      _Block_object_dispose(&v58, 8);
      goto LABEL_34;
    }

    uint64_t v49 = nplog_obj(v43, v44, v45);
    uint64_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue(v49);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_INFO,  "Failed to post new user notification: current notification in progress",  buf,  2u);
    }

    BOOL v51 = *((_BYTE *)v59 + 24) != 0;
    _Block_object_dispose(&v58, 8);

    if (!v51) {
      goto LABEL_32;
    }
  }

void sub_1000A70EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000A7110(uint64_t a1)
{
  if (a1)
  {
    v1[0] = _NSConcreteStackBlock;
    v1[1] = 3221225472LL;
    v1[2] = sub_1000A74E8;
    v1[3] = &unk_1000F9450;
    void v1[4] = a1;
    sub_1000A7170((uint64_t)&OBJC_CLASS___NSPUserNotification, v1);
  }

void sub_1000A7170(uint64_t a1, void *a2)
{
  unsigned int v4 = a2;
  objc_opt_self(a1);
  Current = CFRunLoopGetCurrent();
  if (Current == CFRunLoopGetMain())
  {
    v4[2]();
  }

  else
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1000A721C;
    block[3] = &unk_1000FAE58;
    id v6 = v4;
    dispatch_sync(&_dispatch_main_q, block);
  }
}

uint64_t sub_1000A721C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A7228(uint64_t a1)
{
  int v3 = *(void **)(a1 + 32);
  if (!v3) {
    goto LABEL_6;
  }
  id v4 = objc_getProperty(v3, v2, 8LL, 1);
  if (!v4) {
    goto LABEL_6;
  }
  id v6 = v4;
  id v7 = *(void **)(a1 + 32);
  if (v7)
  {
    id v8 = objc_getProperty(v7, v5, 16LL, 1);
    if (v8)
    {

LABEL_6:
      os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
      return;
    }

    uint64_t v9 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  uint64_t v10 = qword_100117228;

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
  if (v10 == v9)
  {
    id Property = *(id *)(a1 + 32);
    if (Property) {
      id Property = objc_getProperty(Property, v11, 8LL, 1);
    }
    id v13 = (__CFUserNotification *)Property;
    RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  v13,  (CFUserNotificationCallBack)sub_1000A73B4,  0LL);
    id v16 = *(void **)(a1 + 32);
    if (v16) {
      objc_setProperty_atomic(v16, v14, v13, 8LL);
    }

    if (RunLoopSource)
    {
      id v18 = *(void **)(a1 + 32);
      if (v18)
      {
        objc_setProperty_nonatomic_copy(v18, v17, *(id *)(a1 + 48), 32LL);
        id v20 = *(void **)(a1 + 32);
        if (v20) {
          objc_setProperty_atomic(v20, v19, *(id *)(a1 + 40), 24LL);
        }
      }

      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopDefaultMode);
      uint64_t v23 = *(void **)(a1 + 32);
      if (v23) {
        objc_setProperty_atomic(v23, v22, RunLoopSource, 16LL);
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
    }
  }

void sub_1000A73B4(id a1, char a2)
{
  if (qword_100117228 && objc_getProperty((id)qword_100117228, v4, 8LL, 1) == a1)
  {
    uint64_t v5 = (id)qword_100117228;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
    if (v5)
    {
      id v7 = (dispatch_queue_s *)objc_getProperty(v5, v6, 24LL, 1);
      id v8 = (void *)v5[4];
    }

    else
    {
      id v7 = 0LL;
      id v8 = 0LL;
    }

    id v9 = v8;
    sub_1000A7110((uint64_t)v5);
    if (v7)
    {
      if (v9)
      {
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472LL;
        id v10[2] = sub_1000A7684;
        v10[3] = &unk_1000F9860;
        id v11 = v9;
        BOOL v12 = (a2 & 1) == 0LL;
        dispatch_async(v7, v10);
      }
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
  }

void sub_1000A74E8(uint64_t a1)
{
  unint64_t v2 = (void *)qword_100117228;
  if (!qword_100117228 || qword_100117228 != *(void *)(a1 + 32))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
    return;
  }

  qword_100117228 = 0LL;

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100117220);
  id v4 = *(void **)(a1 + 32);
  if (v4)
  {
    if (objc_getProperty(v4, v3, 16LL, 1))
    {
      id Property = *(id *)(a1 + 32);
      if (Property) {
        id Property = objc_getProperty(Property, v5, 16LL, 1);
      }
      id v7 = (__CFRunLoopSource *)Property;
      Current = CFRunLoopGetCurrent();
      CFRunLoopRemoveSource(Current, v7, kCFRunLoopDefaultMode);
      CFRelease(v7);
      uint64_t v10 = *(void **)(a1 + 32);
      if (!v10) {
        return;
      }
      objc_setProperty_atomic(v10, v9, 0LL, 16LL);
    }

    id v11 = *(void **)(a1 + 32);
    if (!v11) {
      return;
    }
    id v13 = objc_getProperty(v11, v5, 8LL, 1);
    id v14 = *(id *)(a1 + 32);
    if (!v13) {
      goto LABEL_16;
    }
    if (v14) {
      id v14 = objc_getProperty(v14, v12, 8LL, 1);
    }
    id v15 = (__CFUserNotification *)v14;
    CFUserNotificationCancel(v15);
    CFRelease(v15);
    id v17 = *(void **)(a1 + 32);
    if (v17)
    {
      objc_setProperty_atomic(v17, v16, 0LL, 8LL);
      id v14 = *(id *)(a1 + 32);
LABEL_16:
      if (v14)
      {
        objc_setProperty_nonatomic_copy(v14, v12, 0LL, 32LL);
        id v19 = *(void **)(a1 + 32);
        if (v19) {
          objc_setProperty_atomic(v19, v18, 0LL, 24LL);
        }
      }
    }
  }

uint64_t sub_1000A7684(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_1000A7924(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1000A7BC8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A7BF0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  if (!v5)
  {
    uint64_t v16 = nplog_obj(v7, v8, v9);
    id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      id v20 = "+[NSPBAA signData:completionHandler:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "%s called with null dataToSign",  buf,  0xCu);
    }

    goto LABEL_6;
  }

  BOOL v10 = +[NSPDeviceIdentityCertificate deviceSupportsDeviceIdentityWithSerialNumber]( &OBJC_CLASS___NSPDeviceIdentityCertificate,  "deviceSupportsDeviceIdentityWithSerialNumber");
  if (!v10)
  {
    uint64_t v14 = nplog_obj(v10, v11, v12);
    id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Device does not support BAA", buf, 2u);
    }

void sub_1000A7D94(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = NPGetInternalQueue(v6);
  uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
  dispatch_assert_queue_V2(v8);

  if (v5)
  {
    id v9 = [v6 count];
    if (v9)
    {
      uint64_t v12 = nplog_obj(v9, v10, v11);
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Fetched device identity certificate successfully",  buf,  2u);
      }

      id v14 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyBAAValidation);
      id v15 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:0]);

      CFDataRef v16 = SecCertificateCopyData((SecCertificateRef)v15);
      [v14 setLeafCertificate:v16];

      id v17 = (void *)objc_claimAutoreleasedReturnValue([v14 leafCertificate]);
      if (v17)
      {
        if ((unint64_t)[v6 count] < 2)
        {
          CFOptionFlags v35 = (void *)objc_claimAutoreleasedReturnValue([v14 leafCertificate]);
          [v14 setIntermediateCertificate:v35];
        }

        else
        {
          id v21 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:1]);

          CFDataRef v22 = SecCertificateCopyData((SecCertificateRef)v21);
          [v14 setIntermediateCertificate:v22];

          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v14 intermediateCertificate]);
          if (!v23)
          {
            uint64_t v27 = nplog_obj(v24, v25, v26);
            id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              __int16 v37 = 0;
              SEL v29 = "failed to fetch intermediate certificate data";
              id v30 = (uint8_t *)&v37;
LABEL_20:
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, v30, 2u);
              goto LABEL_14;
            }

            goto LABEL_14;
          }
        }

        [v14 setBaaSignature:v5];
        char v34 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
        goto LABEL_17;
      }

      uint64_t v33 = nplog_obj(v18, v19, v20);
      id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v38 = 0;
        SEL v29 = "failed to fetch leaf certificate data";
        id v30 = v38;
        goto LABEL_20;
      }

void sub_1000A8060(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  if (!v7)
  {
    uint64_t v18 = nplog_obj(v10, v11, v12);
    id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA fetchRequest:session:completionHandler:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "%s called with null request",  (uint8_t *)&buf,  0xCu);
    }

    goto LABEL_9;
  }

  uint64_t v13 = nplog_obj(v10, v11, v12);
  id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  id v15 = v14;
  if (!v8)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA fetchRequest:session:completionHandler:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "%s called with null session",  (uint8_t *)&buf,  0xCu);
    }

void sub_1000A8308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000A8328(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000A8338(uint64_t a1)
{
}

void sub_1000A8340(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0LL;
  id v9 = a4;
  id v10 = a3;
  id v11 = a2;

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A8630(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setBaaParameters:a2];
    int v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) data]);
    [*(id *)(a1 + 40) setHTTPBody:v3];

    ++dword_100117254;
    id v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    v6[2] = sub_1000A8728;
    v6[3] = &unk_1000FAEA8;
    id v7 = *(id *)(a1 + 56);
    sub_1000A8060((uint64_t)&OBJC_CLASS___NSPBAA, v4, v5, v6);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }

uint64_t sub_1000A8728(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A8744(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setBaaParameters:a2];
    int v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) data]);
    [*(id *)(a1 + 40) setHTTPBody:v3];

    ++dword_100117254;
    id v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    v6[2] = sub_1000A8840;
    v6[3] = &unk_1000FAEA8;
    id v7 = *(id *)(a1 + 56);
    sub_1000A8060((uint64_t)&OBJC_CLASS___NSPBAA, v4, v5, v6);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }

uint64_t sub_1000A8840(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A8860(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  BOOL v11 = +[NSPDeviceIdentityCertificate deviceSupportsDeviceIdentityWithSerialNumber]( &OBJC_CLASS___NSPDeviceIdentityCertificate,  "deviceSupportsDeviceIdentityWithSerialNumber");
  if (v11)
  {
    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSPDeviceIdentityCertificate sharedDeviceIdentity]( &OBJC_CLASS___NSPDeviceIdentityCertificate,  "sharedDeviceIdentity"));
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_1000A89AC;
    v18[3] = &unk_1000FAF20;
    id v19 = v8;
    uint64_t v21 = v10;
    id v20 = v9;
    [v14 signData:v7 andFetchDeviceIdentityCertificate:v18];
  }

  else
  {
    uint64_t v15 = nplog_obj(v11, v12, v13);
    CFDataRef v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v17 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Device does not support BAA", v17, 2u);
    }

    (*((void (**)(id, void))v9 + 2))(v9, 0LL);
  }
}

void sub_1000A89AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = NPGetInternalQueue(v6);
  id v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
  dispatch_assert_queue_V2(v8);

  if (v5)
  {
    id v9 = [v6 count];
    if (v9)
    {
      uint64_t v12 = nplog_obj(v9, v10, v11);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Fetched device identity certificate successfully",  buf,  2u);
      }

      id v14 = *(void **)(a1 + 32);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) description]);
      [v14 addValue:v15 forHTTPHeaderField:@"Client-Auth-Type"];

      CFDataRef v16 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:0]);
      CFDataRef v19 = SecCertificateCopyData((SecCertificateRef)v16);
      if (v19)
      {
        id v20 = *(void **)(a1 + 32);
        id v21 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v19);
        [v20 addValue:v21 forHTTPHeaderField:@"Client-BAA-Leaf-Cert"];

        if ((unint64_t)[v6 count] < 2)
        {
LABEL_9:
          id v29 = *(void **)(a1 + 32);
          id v30 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v5);
          [v29 addValue:v30 forHTTPHeaderField:@"Client-BAA-Signature"];

          uint64_t v31 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
LABEL_19:
          v31();

          goto LABEL_20;
        }

        CFDataRef v22 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:1]);

        CFDataRef v23 = SecCertificateCopyData((SecCertificateRef)v22);
        if (v23)
        {
          CFDataRef v26 = v23;
          uint64_t v27 = *(void **)(a1 + 32);
          id v28 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v23);
          [v27 addValue:v28 forHTTPHeaderField:@"Client-BAA-Cert"];

          goto LABEL_9;
        }

        uint64_t v38 = nplog_obj(0LL, v24, v25);
        CFOptionFlags v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)id v40 = 0;
          CFUserNotificationRef v36 = "failed to fetch intermediate certificate data";
          __int16 v37 = v40;
          goto LABEL_17;
        }
      }

      else
      {
        uint64_t v34 = nplog_obj(0LL, v17, v18);
        CFOptionFlags v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          __int16 v41 = 0;
          CFUserNotificationRef v36 = "failed to fetch leaf certificate data";
          __int16 v37 = (uint8_t *)&v41;
LABEL_17:
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v36, v37, 2u);
        }
      }

      uint64_t v31 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
      goto LABEL_19;
    }
  }

  uint64_t v32 = nplog_obj(v9, v10, v11);
  uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v39 = 0;
    _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "Failed to fetch device identity certificate",  v39,  2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
LABEL_20:
}

void sub_1000A8EBC(uint64_t a1, int a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setHTTPBody:*(void *)(a1 + 40)];
    ++dword_100117254;
    int v3 = *(void **)(a1 + 32);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_1000A8F90;
    v5[3] = &unk_1000FAEA8;
    id v4 = *(void **)(a1 + 48);
    id v6 = *(id *)(a1 + 56);
    sub_1000A8060((uint64_t)&OBJC_CLASS___NSPBAA, v3, v4, v5);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }

uint64_t sub_1000A8F90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000A8FAC(uint64_t a1, int a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setHTTPBody:*(void *)(a1 + 40)];
    ++dword_100117254;
    int v3 = *(void **)(a1 + 32);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_1000A9084;
    v5[3] = &unk_1000FAEA8;
    id v4 = *(void **)(a1 + 48);
    id v6 = *(id *)(a1 + 56);
    sub_1000A8060((uint64_t)&OBJC_CLASS___NSPBAA, v3, v4, v5);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }

uint64_t sub_1000A9084(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

id sub_1000A9418(void *a1, uint64_t a2, uint64_t a3)
{
  if ((a3 & 1) != 0) {
    return (id)(*(uint64_t (**)(void))(a1[7] + 16LL))();
  }
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Authentication fallback", v7, 2u);
  }

  return +[NSPAnisette sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:]( &OBJC_CLASS___NSPAnisette,  "sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:",  a1[4],  a1[5],  a1[6],  a1[7]);
}

id sub_1000A97E8(void *a1, uint64_t a2, uint64_t a3)
{
  if ((a3 & 1) != 0) {
    return (id)(*(uint64_t (**)(void))(a1[7] + 16LL))();
  }
  uint64_t v5 = nplog_obj(a1, a2, a3);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Authentication fallback", v7, 2u);
  }

  return +[NSPAnisette sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:]( &OBJC_CLASS___NSPAnisette,  "sendRequestForTokens:tokenFetchURLSession:messageBody:completionHandler:",  a1[4],  a1[5],  a1[6],  a1[7]);
}

void sub_1000A9C34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000A9C54(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0LL;
  id v9 = a4;
  id v10 = a3;
  id v11 = a2;

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

NSMutableData *sub_1000AA3D0(unsigned int a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  __int16 v21 = __rev16(a1);
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v21, 2LL);
  id v11 = (const char *)[v7 UTF8String];
  __int16 v20 = bswap32(strlen(v11)) >> 16;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v20, 2LL);
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", v11, strlen(v11));
  char v19 = 32 * (v8 != 0LL);
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v19, 1LL);
  if (v8) {
    -[NSMutableData appendData:](v10, "appendData:", v8);
  }
  if (v9)
  {
    uint64_t v12 = (const char *)[v9 UTF8String];
    __int16 v18 = bswap32(strlen(v12)) >> 16;
    -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v18, 2LL);
    size_t v13 = strlen(v12);
    id v14 = v10;
    uint64_t v15 = v12;
  }

  else
  {
    __int16 v17 = 0;
    uint64_t v15 = (const char *)&v17;
    id v14 = v10;
    size_t v13 = 2LL;
  }

  -[NSMutableData appendBytes:length:](v14, "appendBytes:length:", v15, v13);

  return v10;
}

id sub_1000AAE68(id a1, unsigned int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (!a1)
  {
    id v37 = 0LL;
    goto LABEL_19;
  }

  if (v10 && (id v12 = [v10 length], v12 != (id)32))
  {
    uint64_t v40 = nplog_obj(v12, v13, v14);
    __int16 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      BOOL v51 = "-[NSPPrivateAccessTokenChallenge initWithType:issuerName:redemptionNonce:originNames:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "%s called with null (redemptionNonce.length == 32)",  buf,  0xCu);
    }
  }

  else
  {
    v48.receiver = a1;
    v48.super_class = (Class)&OBJC_CLASS___NSPPrivateAccessTokenChallenge;
    uint64_t v15 = objc_msgSendSuper2(&v48, "init");
    if (v15)
    {
      __int16 v18 = v15;
      void v15[4] = a2;
      objc_setProperty_atomic(v15, v16, v9, 24LL);
      objc_setProperty_atomic(v18, v19, v10, 32LL);
      objc_setProperty_atomic(v18, v20, v11, 48LL);
      __int16 v21 = (void *)objc_claimAutoreleasedReturnValue([v18 originNames]);
      CFDataRef v22 = (void *)objc_claimAutoreleasedReturnValue([v21 firstObject]);
      objc_setProperty_atomic(v18, v23, v22, 40LL);

      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v18 originNames]);
      id v25 = [v24 count];

      if (v25)
      {
        id v42 = v11;
        id v43 = v9;
        CFDataRef v26 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v18 originNames]);
        id v28 = [v27 countByEnumeratingWithState:&v44 objects:v49 count:16];
        if (v28)
        {
          id v29 = v28;
          uint64_t v30 = *(void *)v45;
          do
          {
            uint64_t v31 = 0LL;
            do
            {
              if (*(void *)v45 != v30) {
                objc_enumerationMutation(v27);
              }
              uint64_t v32 = *(void *)(*((void *)&v44 + 1) + 8LL * (void)v31);
              if (-[NSMutableString length](v26, "length", v42, v43)) {
                -[NSMutableString appendString:](v26, "appendString:", @",");
              }
              -[NSMutableString appendString:](v26, "appendString:", v32);
              uint64_t v31 = (char *)v31 + 1;
            }

            while (v29 != v31);
            id v29 = [v27 countByEnumeratingWithState:&v44 objects:v49 count:16];
          }

          while (v29);
        }

        objc_setProperty_atomic(v18, v33, v26, 56LL);
        id v11 = v42;
        id v9 = v43;
      }

      else
      {
        CFDataRef v26 = 0LL;
      }

      uint64_t v34 = sub_1000AA3D0(a2, v9, v10, v26);
      CFOptionFlags v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
      objc_setProperty_atomic(v18, v36, v35, 16LL);

      a1 = v18;
      id v37 = a1;
      goto LABEL_18;
    }

    uint64_t v39 = nplog_obj(0LL, v16, v17);
    a1 = (id)objc_claimAutoreleasedReturnValue(v39);
    if (os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)a1, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
    }
  }

  id v37 = 0LL;
LABEL_18:

LABEL_19:
  return v37;
}

BOOL sub_1000AB4CC(void *a1, int a2)
{
  BOOL v2 = (BOOL)a1;
  if (a1)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([a1 redemptionNonce]);
    BOOL v2 = (!v4 || a2) && [(id)v2 tokenType] == 2;
  }

  return v2;
}

os_log_s *sub_1000AB5D4(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v15 = v12;
  if (!a1)
  {
    uint64_t v30 = 0LL;
    goto LABEL_11;
  }

  if (!v9)
  {
    uint64_t v32 = nplog_obj(v12, v13, v14);
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    SEL v33 = "%s called with null challenge";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, v33, md, 0xCu);
    goto LABEL_23;
  }

  if (!v10)
  {
    uint64_t v34 = nplog_obj(v12, v13, v14);
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    SEL v33 = "%s called with null clientNonce";
    goto LABEL_22;
  }

  id v16 = [v10 length];
  if (v16 != (id)32)
  {
    uint64_t v35 = nplog_obj(v16, v17, v18);
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    SEL v33 = "%s called with null (clientNonce.length == 32)";
    goto LABEL_22;
  }

  if (!v11)
  {
    uint64_t v36 = nplog_obj(32LL, v17, v18);
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    SEL v33 = "%s called with null tokenKey";
    goto LABEL_22;
  }

  if (v15)
  {
    uint64_t v19 = objc_claimAutoreleasedReturnValue([v9 challengeData]);
    if (v19)
    {
      CFDataRef v22 = (void *)v19;
      v42.receiver = a1;
      v42.super_class = (Class)&OBJC_CLASS___NSPPrivateAccessTokenResponse;
      id v23 = objc_msgSendSuper2(&v42, "init");
      if (v23)
      {
        CFDataRef v26 = v23;
        uint64_t v27 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
        __int16 v41 = __rev16([v9 tokenType]);
        -[NSMutableData appendBytes:length:](v27, "appendBytes:length:", &v41, 2LL);
        -[NSMutableData appendData:](v27, "appendData:", v10);
        *(_OWORD *)md = 0u;
        __int128 v46 = 0u;
        CC_SHA256([v22 bytes], (CC_LONG)objc_msgSend(v22, "length"), md);
        -[NSMutableData appendBytes:length:](v27, "appendBytes:length:", md, 32LL);
        *(_OWORD *)id v43 = 0u;
        __int128 v44 = 0u;
        CC_SHA256([v11 bytes], (CC_LONG)objc_msgSend(v11, "length"), v43);
        -[NSMutableData appendBytes:length:](v27, "appendBytes:length:", v43, 32LL);
        -[NSMutableData appendData:](v27, "appendData:", v15);
        objc_setProperty_atomic(v26, v28, v27, 8LL);
        id v29 = v26;

        a1 = v22;
        uint64_t v30 = v29;
      }

      else
      {
        uint64_t v40 = nplog_obj(0LL, v24, v25);
        id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)md = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "[super init] failed", md, 2u);
        }

        uint64_t v30 = 0LL;
        a1 = v22;
      }
    }

    else
    {
      uint64_t v38 = nplog_obj(0LL, v20, v21);
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)md = 136315138;
        *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "%s called with null challengeData",  md,  0xCu);
      }

      uint64_t v30 = 0LL;
      id v29 = (os_log_s *)a1;
      a1 = 0LL;
    }

    goto LABEL_10;
  }

  uint64_t v37 = nplog_obj(32LL, v17, v18);
  id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    SEL v33 = "%s called with null blindSignature";
    goto LABEL_22;
  }

BOOL sub_1000AB9F4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  if (!v5)
  {
    uint64_t v15 = nplog_obj(v7, v8, v9);
    id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    if (!os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_FAULT))
    {
LABEL_20:

LABEL_21:
      BOOL v14 = 0LL;
      goto LABEL_22;
    }

    LODWORD(v20) = 136315138;
    *(void *)((char *)&v20 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesTokenKey:]";
    uint64_t v17 = "%s called with null responseData";
LABEL_24:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v16, OS_LOG_TYPE_FAULT, v17, (uint8_t *)&v20, 0xCu);
    goto LABEL_20;
  }

  if (!v6)
  {
    uint64_t v18 = nplog_obj(v7, v8, v9);
    id v16 = (void *)objc_claimAutoreleasedReturnValue(v18);
    if (!os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    LODWORD(v20) = 136315138;
    *(void *)((char *)&v20 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesTokenKey:]";
    uint64_t v17 = "%s called with null tokenKey";
    goto LABEL_24;
  }

  __int128 v20 = 0u;
  __int128 v21 = 0u;
  CC_SHA256([v6 bytes], (CC_LONG)objc_msgSend(v6, "length"), (unsigned __int8 *)&v20);
  id v10 = (char *)[v5 bytes];
  if (!v10) {
    goto LABEL_21;
  }
  BOOL v14 = *(void *)(v10 + 66) == (void)v20
     && *(void *)(v10 + 74) == *((void *)&v20 + 1)
     && *(void *)(v10 + 82) == (void)v21
     && *(void *)(v10 + 90) == *((void *)&v21 + 1);
LABEL_22:

  return v14;
}

BOOL sub_1000ABB98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  if (!v5)
  {
    uint64_t v19 = nplog_obj(v7, v8, v9);
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      goto LABEL_26;
    }
    LODWORD(v25) = 136315138;
    *(void *)((char *)&v25 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
    __int128 v20 = "%s called with null responseData";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v25, 0xCu);
    goto LABEL_26;
  }

  if (!v6)
  {
    uint64_t v21 = nplog_obj(v7, v8, v9);
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      goto LABEL_26;
    }
    LODWORD(v25) = 136315138;
    *(void *)((char *)&v25 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
    __int128 v20 = "%s called with null challenge";
    goto LABEL_22;
  }

  id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue([v6 challengeData]);
  if (!v10)
  {
    uint64_t v22 = nplog_obj(0LL, v11, v12);
    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v25) = 136315138;
      *(void *)((char *)&v25 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
      _os_log_fault_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "%s called with null challengeData",  (uint8_t *)&v25,  0xCu);
    }

    uint64_t v13 = 0LL;
    goto LABEL_26;
  }

  uint64_t v13 = v10;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  CC_SHA256(-[os_log_s bytes](v10, "bytes"), (CC_LONG)-[os_log_s length](v10, "length"), (unsigned __int8 *)&v25);
  if ((unint64_t)[v5 length] < 0x42 || (BOOL v14 = (char *)objc_msgSend(v5, "bytes")) == 0)
  {
LABEL_26:
    BOOL v18 = 0LL;
    goto LABEL_27;
  }

  BOOL v18 = *(void *)(v14 + 34) == (void)v25
     && *(void *)(v14 + 42) == *((void *)&v25 + 1)
     && *(void *)(v14 + 50) == (void)v26
     && *(void *)(v14 + 58) == *((void *)&v26 + 1);
LABEL_27:

  return v18;
}

id sub_1000ABDB8()
{
  if (qword_100117238 != -1) {
    dispatch_once(&qword_100117238, &stru_1000FAF90);
  }
  return (id)qword_100117230;
}

void sub_1000ABDFC(id a1)
{
  unint64_t v1 = objc_alloc_init(&OBJC_CLASS___NSPPrivateAccessTokenClientState);
  BOOL v2 = (void *)qword_100117230;
  qword_100117230 = (uint64_t)v1;
}

uint64_t sub_1000ABE24(uint64_t a1)
{
  id v1 = sub_1000ABDB8();
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  if (v2) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = 0LL;
  }

  return v3;
}

NSData *sub_1000AC388(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (!a1) {
    goto LABEL_18;
  }
  if (!v3)
  {
    uint64_t v69 = nplog_obj(0LL, v4, v5);
    uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v69);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)__int128 buf = 136315138;
    id v80 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
    uint64_t v70 = "%s called with null responseData";
    goto LABEL_45;
  }

  if (*(_WORD *)(a1 + 10) == 3)
  {
    if (*(void *)(a1 + 96))
    {
      if (objc_getProperty((id)a1, v4, 104LL, 1))
      {
        uint64_t v9 = *(void *)(a1 + 96);
        uint64_t v10 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
        size_t v11 = cchpke_params_sizeof_aead_key();
        unint64_t v12 = cchpke_params_sizeof_aead_nonce(v10);
        uint64_t v13 = cchpke_params_sizeof_aead_tag(v10);
        BOOL v14 = (char *)[v6 bytes];
        uint64_t v15 = (const char *)[v6 length];
        if (v11 <= v12) {
          unint64_t v18 = v12;
        }
        else {
          unint64_t v18 = v11;
        }
        if ((unint64_t)v15 > v18 + v13)
        {
          size_t __size = v12;
          uint64_t v19 = (char *)&v15[-v18 - v13];
          __int128 v20 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v14, v18);
          uint64_t v21 = &v14[v18];
          id v76 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v21, v19);
          id v78 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &v19[(void)v21],  v13);
          uint64_t v22 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
          -[NSMutableData appendData:](v22, "appendData:", objc_getProperty((id)a1, v23, 104LL, 1));
          -[NSMutableData appendData:](v22, "appendData:", v20);
          uint64_t v24 = calloc(1uLL, v11);
          uint64_t v25 = cchpke_initiator_export(v9, 13LL, "TokenResponse", v11, v24);
          if ((_DWORD)v25)
          {
            int v28 = v25;
            uint64_t v29 = nplog_obj(v25, v26, v27);
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 67109120;
              LODWORD(v80) = v28;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Export error: %d", buf, 8u);
            }

            free(v24);
            uint64_t v31 = 0LL;
            uint64_t v32 = v76;
            SEL v33 = v20;
            goto LABEL_36;
          }

          size_t v74 = (size_t)v19;
          id v77 = v20;
          size_t v37 = cchpke_params_sizeof_kdf_hash(v10);
          uint64_t v38 = calloc(1uLL, v37);
          uint64_t v39 = ccsha256_di();
          int v40 = cchkdf_extract( v39,  -[NSMutableData length](v22, "length"),  -[NSMutableData bytes](v22, "bytes"),  v11,  v24,  v38);
          free(v24);
          if (v40)
          {
            uint64_t v44 = nplog_obj(v41, v42, v43);
            __int128 v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 67109120;
              LODWORD(v80) = v40;
              _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Extract error: %d", buf, 8u);
            }

            free(v38);
            uint64_t v31 = 0LL;
            uint64_t v32 = v76;
            SEL v33 = v20;
            goto LABEL_36;
          }

          __int128 v46 = calloc(1uLL, v11);
          uint64_t v47 = cchkdf_expand(v39, v37, v38, 3LL, "key", v11, v46);
          if ((_DWORD)v47)
          {
            int v50 = v47;
            uint64_t v51 = nplog_obj(v47, v48, v49);
            id v52 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
            SEL v33 = v77;
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 67109120;
              LODWORD(v80) = v50;
              _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Key expand error: %d", buf, 8u);
            }

            free(v38);
            free(v46);
            uint64_t v31 = 0LL;
            uint64_t v32 = v76;
            goto LABEL_36;
          }

          uint64_t v53 = calloc(1uLL, __size);
          int v54 = cchkdf_expand(v39, v37, v38, 5LL, "nonce", __size, v53);
          free(v38);
          SEL v33 = v77;
          if (v54)
          {
            uint64_t v58 = nplog_obj(v55, v56, v57);
            uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
            uint64_t v32 = v76;
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 67109120;
              LODWORD(v80) = v54;
              _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "Nonce expand error: %d", buf, 8u);
            }

            free(v46);
            uint64_t v60 = v53;
          }

          else
          {
            id v73 = calloc(1uLL, v74);
            uint64_t v61 = ccaes_gcm_decrypt_mode();
            uint64_t v32 = v76;
            int v62 = ccgcm_one_shot( v61,  v11,  v46,  __size,  v53,  0LL,  "",  v74,  -[NSData bytes](v76, "bytes"),  v73,  v13,  -[NSData bytes](v78, "bytes"));
            free(v46);
            free(v53);
            if (!v62)
            {
              uint64_t v31 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v73, v74);
              free(v73);
              SEL v33 = v77;
              goto LABEL_36;
            }

            uint64_t v66 = nplog_obj(v63, v64, v65);
            id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
            SEL v33 = v77;
            if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 67109120;
              LODWORD(v80) = v62;
              _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "Decrypt error: %d", buf, 8u);
            }

            uint64_t v60 = v73;
          }

          free(v60);
          uint64_t v31 = 0LL;
LABEL_36:

          goto LABEL_37;
        }

        uint64_t v34 = v15;
        uint64_t v35 = nplog_obj(v15, v16, v17);
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 134217984;
          id v80 = v34;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Invalid length %zu", buf, 0xCu);
        }

        goto LABEL_17;
      }

      uint64_t v72 = nplog_obj(0LL, v7, v8);
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        id v80 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
        uint64_t v70 = "%s called with null self.hpkeEnc";
        goto LABEL_45;
      }

id sub_1000ACA74(uint64_t a1)
{
  uint64_t v1 = SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes);
  if ((v1 & 0x80000000) != 0)
  {
    uint64_t v5 = nplog_obj(v1, v2, v3);
    id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "generate tokens: SecRandomCopyBytes failed",  v8,  2u);
    }

    id v4 = 0LL;
  }

  else
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", bytes, 32LL));
  }

  return v4;
}

NSMutableData *sub_1000ACB50(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  if (!v7)
  {
    uint64_t v19 = nplog_obj(v10, v11, v12);
    __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    uint64_t v21 = "%s called with null challenge";
LABEL_15:
    _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, v21, md, 0xCu);
    goto LABEL_16;
  }

  if (!v8)
  {
    uint64_t v22 = nplog_obj(v10, v11, v12);
    __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    uint64_t v21 = "%s called with null clientNonce";
    goto LABEL_15;
  }

  id v13 = [v8 length];
  if (v13 != (id)32)
  {
    uint64_t v23 = nplog_obj(v13, v14, v15);
    __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    uint64_t v21 = "%s called with null (clientNonce.length == 32)";
    goto LABEL_15;
  }

  if (!v9)
  {
    uint64_t v24 = nplog_obj(32LL, v14, v15);
    __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)md = 136315138;
      *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
      uint64_t v21 = "%s called with null tokenKey";
      goto LABEL_15;
    }

NSData *sub_1000ACDF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = v3;
  id v5 = objc_msgSend(v4, "bytes", 0, 0, 0, 0);
  CC_LONG v6 = [v4 length];

  CC_SHA256(v5, v6, (unsigned __int8 *)&v8);
  return -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v8, 32LL);
}

id sub_1000ACEB0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  unint64_t v18 = v15;
  if (!a1)
  {
    id v51 = 0LL;
    goto LABEL_47;
  }

  if (!v11)
  {
    uint64_t v202 = nplog_obj(v15, v16, v17);
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v202);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v203 = "%s called with null challenge";
    goto LABEL_116;
  }

  if (!v12)
  {
    uint64_t v204 = nplog_obj(v15, v16, v17);
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v204);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v203 = "%s called with null tokenKey";
    goto LABEL_116;
  }

  if (!v15)
  {
    uint64_t v205 = nplog_obj(0LL, v16, v17);
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v205);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v203 = "%s called with null blindedMessage";
    goto LABEL_116;
  }

  id v19 = [v11 isSupportedTokenType];
  if ((v19 & 1) == 0)
  {
    uint64_t v206 = nplog_obj(v19, v20, v21);
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v206);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v203 = "%s called with null challenge.isSupportedTokenType";
    goto LABEL_116;
  }

  if ([v11 tokenType] == 3)
  {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v11 originName]);

    if (v22)
    {
      if (v13) {
        goto LABEL_9;
      }
      uint64_t v209 = nplog_obj(v23, v24, v25);
      uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v209);
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)md = 136315138;
      *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
      id v203 = "%s called with null issuerEncapKey";
    }

    else
    {
      uint64_t v208 = nplog_obj(v23, v24, v25);
      uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v208);
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)md = 136315138;
      *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
      id v203 = "%s called with null challenge.originName";
    }

LABEL_116:
    _os_log_fault_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, v203, md, 0xCu);
    goto LABEL_23;
  }

LABEL_90:
                            goto LABEL_97;
                          }

                          uint64_t v216 = nplog_obj(v157, v158, v159);
                          __int128 v191 = (os_log_s *)objc_claimAutoreleasedReturnValue(v216);
                          if (os_log_type_enabled(v191, OS_LOG_TYPE_FAULT))
                          {
                            LODWORD(v246) = 136315138;
                            *(void *)((char *)&v246 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                            uint64_t v213 = "%s called with null self.ephemeralPrivateKey";
                            goto LABEL_130;
                          }

LABEL_131:
                          id v13 = v231;
                          goto LABEL_90;
                        }

                        uint64_t v215 = nplog_obj(0LL, v158, v159);
                        __int128 v191 = (os_log_s *)objc_claimAutoreleasedReturnValue(v215);
                        if (!os_log_type_enabled(v191, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_131;
                        }
                        LODWORD(v246) = 136315138;
                        *(void *)((char *)&v246 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                        uint64_t v213 = "%s called with null self.encryptedTokenRequest";
                      }

                      else
                      {
                        uint64_t v214 = nplog_obj(0LL, v155, v156);
                        __int128 v191 = (os_log_s *)objc_claimAutoreleasedReturnValue(v214);
                        if (!os_log_type_enabled(v191, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_131;
                        }
                        LODWORD(v246) = 136315138;
                        *(void *)((char *)&v246 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                        uint64_t v213 = "%s called with null self.issuerEncapKeyID";
                      }
                    }

                    else
                    {
                      uint64_t v212 = nplog_obj(0LL, v153, v154);
                      __int128 v191 = (os_log_s *)objc_claimAutoreleasedReturnValue(v212);
                      if (!os_log_type_enabled(v191, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_131;
                      }
                      LODWORD(v246) = 136315138;
                      *(void *)((char *)&v246 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                      uint64_t v213 = "%s called with null self.requestKey";
                    }

LABEL_130:
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v191,  OS_LOG_TYPE_FAULT,  v213,  (uint8_t *)&v246,  0xCu);
                    goto LABEL_131;
                  }

                  uint64_t v201 = nplog_obj(0LL, v117, v118);
                  uint64_t v196 = (os_log_s *)objc_claimAutoreleasedReturnValue(v201);
                  id v13 = v231;
                  uint64_t v197 = v222;
                  if (os_log_type_enabled(v196, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)__int128 v245 = 0;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v196,  OS_LOG_TYPE_ERROR,  "generate key: compressedRepresentationFromSecKey failed",  v245,  2u);
                  }
                }

                else
                {
                  uint64_t v195 = nplog_obj(v111, v112, v113);
                  uint64_t v196 = (os_log_s *)objc_claimAutoreleasedReturnValue(v195);
                  if (os_log_type_enabled(v196, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)__int128 v245 = 138412290;
                    *(void *)&v245[4] = v229;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v196,  OS_LOG_TYPE_ERROR,  "generate key: blindPublicKey failed: %@",  v245,  0xCu);
                  }

                  id v13 = v231;
                  uint64_t v197 = v222;
                }

                CFRelease(__src);
              }

              else
              {
                CFRelease(v105);
                uint64_t v188 = nplog_obj(v185, v186, v187);
                __int128 v189 = (os_log_s *)objc_claimAutoreleasedReturnValue(v188);
                if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)__int128 v245 = 0;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v189,  OS_LOG_TYPE_ERROR,  "generate key: SecKeyCreateRandomKey failed",  v245,  2u);
                }

                id v13 = v231;
              }

void sub_1000AE390(uint64_t a1, void *a2)
{
  id v3 = a2;
  CC_LONG v6 = v3;
  if (a1)
  {
    if (!v3)
    {
      uint64_t v38 = nplog_obj(0LL, v4, v5);
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t v44 = 136315138;
        *(void *)&uint8_t v44[4] = "-[NSPPrivateAccessTokenRequest addHeadersToRequest:]";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "%s called with null urlRequest",  v44,  0xCu);
      }

      goto LABEL_22;
    }

    [v3 addValue:@"application/private-token-response" forHTTPHeaderField:@"Accept"];
    [v6 addValue:@"application/private-token-request" forHTTPHeaderField:@"Content-Type"];
    objc_msgSend(v6, "addValue:forHTTPHeaderField:", @"no-cache, no-store", @"Cache-Control");
    if (*(_WORD *)(a1 + 10) == 3)
    {
      id v8 = objc_getProperty((id)a1, v7, 56LL, 1);
      uint64_t v9 = objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenClientState);
      if (v8)
      {
        objc_opt_self(&OBJC_CLASS___NSPPrivateAccessTokenClientState);
        id v12 = sub_1000ABDB8();
        id Property = (id)objc_claimAutoreleasedReturnValue(v12);
        id v15 = Property;
        if (Property) {
          id Property = objc_getProperty(Property, v14, 16LL, 1);
        }
        id v16 = Property;

        if (v16)
        {
          *(_OWORD *)uint64_t v44 = 0u;
          __int128 v45 = 0u;
          uint64_t v20 = (const char *)[v8 UTF8String];
          size_t v21 = strlen(v20);
          uint64_t v22 = ccsha256_di();
          uint64_t v23 = cchkdf(v22, [v16 length], objc_msgSend(v16, "bytes"), 8, "", v21, v20, 32, v44);
          if (!(_DWORD)v23)
          {
            __int128 v29 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v44, 32LL);
            goto LABEL_14;
          }

          int v26 = v23;
          uint64_t v27 = nplog_obj(v23, v24, v25);
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 67109120;
            int v43 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "HKDF error: %d", buf, 8u);
          }
        }

        else
        {
          uint64_t v40 = nplog_obj(v17, v18, v19);
          id v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)uint64_t v44 = 136315138;
            *(void *)&uint8_t v44[4] = "+[NSPPrivateAccessTokenClientState anonymousIDForOrigin:]";
            _os_log_fault_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "%s called with null clientSecret",  v44,  0xCu);
          }

          id v16 = 0LL;
        }
      }

      else
      {
        uint64_t v39 = nplog_obj(v9, v10, v11);
        id v16 = (id)objc_claimAutoreleasedReturnValue(v39);
        if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)uint64_t v44 = 136315138;
          *(void *)&uint8_t v44[4] = "+[NSPPrivateAccessTokenClientState anonymousIDForOrigin:]";
          _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)v16,  OS_LOG_TYPE_FAULT,  "%s called with null origin",  v44,  0xCu);
        }
      }

      __int128 v29 = 0LL;
LABEL_14:

      id v30 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v29);
      [v6 addValue:v30 forHTTPHeaderField:@"Sec-Token-Origin"];

      uint64_t v31 = (__SecKey *)sub_1000ABE24((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenClientState);
      if (v31)
      {
        SecKeyRef v32 = SecKeyCopyPublicKey(v31);
        if (v32)
        {
          SecKeyRef v33 = v32;
          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[CKPATKeyBlinding compressedRepresentationFromSecKey:]( &OBJC_CLASS___CKPATKeyBlinding,  "compressedRepresentationFromSecKey:",  v32));
          if (v34)
          {
            id v35 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v34);
            [v6 addValue:v35 forHTTPHeaderField:@"Sec-Token-Client"];
          }

          CFRelease(v33);
        }
      }

      if (*(void *)(a1 + 88))
      {
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[CKPATKeyBlinding privateScalarFromSecKey:]( &OBJC_CLASS___CKPATKeyBlinding,  "privateScalarFromSecKey:"));
        if (v36)
        {
          id v37 = +[NPUtilities copyBase64HeaderValueFromData:]( &OBJC_CLASS___NPUtilities,  "copyBase64HeaderValueFromData:",  v36);
          [v6 addValue:v37 forHTTPHeaderField:@"Sec-Token-Request-Blind"];
        }

void sub_1000AEFFC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v9 = v6;
  if (v6)
  {
    uint64_t v10 = nplog_obj(v6, v7, v8);
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      size_t v21 = v9;
      _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "Failed to fetch private access token: %@",  buf,  0xCu);
    }
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000AF138;
  block[3] = &unk_1000FAFB8;
  id v12 = *(dispatch_queue_s **)(a1 + 32);
  id v13 = *(id *)(a1 + 40);
  id v18 = v9;
  id v19 = v13;
  id v17 = v5;
  id v14 = v9;
  id v15 = v5;
  dispatch_async(v12, block);
}

uint64_t sub_1000AF138(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16LL))(a1[6], a1[4], a1[5]);
}

void sub_1000AF2D0(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  id v13 = v10;
  if (v10)
  {
    uint64_t v14 = nplog_obj(v10, v11, v12);
    id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v27 = v13;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to fetch private access token pair: %@",  buf,  0xCu);
    }
  }

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  v21[2] = sub_1000AF434;
  v21[3] = &unk_1000FB008;
  id v16 = *(dispatch_queue_s **)(a1 + 32);
  id v17 = *(id *)(a1 + 40);
  id v22 = v8;
  id v23 = v9;
  id v24 = v13;
  id v25 = v17;
  id v18 = v13;
  id v19 = v9;
  id v20 = v8;
  dispatch_async(v16, v21);
}

uint64_t sub_1000AF434(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void))(a1[7] + 16LL))(a1[7], a1[4], a1[5], a1[6]);
}

void sub_1000AF5CC(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v15 = v12;
  if (v12)
  {
    uint64_t v16 = nplog_obj(v12, v13, v14);
    id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v31 = v15;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Failed to fetch linked private access token pair: %@",  buf,  0xCu);
    }
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000AF754;
  block[3] = &unk_1000FB058;
  id v18 = *(dispatch_queue_s **)(a1 + 32);
  id v19 = *(id *)(a1 + 40);
  id v28 = v15;
  id v29 = v19;
  id v25 = v9;
  id v26 = v10;
  id v27 = v11;
  id v20 = v15;
  id v21 = v11;
  id v22 = v10;
  id v23 = v9;
  dispatch_async(v18, block);
}

uint64_t sub_1000AF754(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(a1[8] + 16LL))( a1[8],  a1[4],  a1[5],  a1[6],  a1[7]);
}

NSMutableArray *sub_1000AF854(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  id v69 = a2;
  id v13 = a3;
  id v14 = a4;
  id v67 = a5;
  id v66 = a6;
  objc_opt_self(a1);
  id v15 = objc_alloc(&OBJC_CLASS___RSABSSATokenBlinder);
  __int128 v68 = v13;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v13 key]);
  id v71 = 0LL;
  id v17 = [v15 initWithPublicKey:v16 error:&v71];
  id v18 = v71;

  if (v18)
  {
    uint64_t v22 = nplog_obj(v19, v20, v21);
    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      SEL v56 = (void *)objc_claimAutoreleasedReturnValue([v69 issuerName]);
      LODWORD(bytes[0]) = 138412546;
      *(void *)((char *)bytes + 4) = v18;
      WORD6(bytes[0]) = 2112;
      *(void *)((char *)bytes + 14) = v56;
      _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "RSABSSATokenBlinder initWithPublicKey failed with error %@ for %@",  (uint8_t *)bytes,  0x16u);
    }

NSMutableArray *sub_1000AFE94(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v35 = a2;
  id v34 = a3;
  id v33 = a4;
  id v32 = a5;
  id v11 = a6;
  objc_opt_self(a1);
  id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  id v13 = v11;
  id v14 = [v13 countByEnumeratingWithState:&v36 objects:v42 count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = *(void *)v37;
    while (2)
    {
      id v17 = 0LL;
      do
      {
        if (*(void *)v37 != v16) {
          objc_enumerationMutation(v13);
        }
        id v18 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)v17);
        uint64_t v19 = objc_opt_class(&OBJC_CLASS___RSABSSATokenWaitingActivation);
        if ((objc_opt_isKindOfClass(v18, v19) & 1) != 0)
        {
          id v20 = v18;
          uint64_t v21 = objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenRequest);
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v34 key]);
          id v23 = (void *)objc_claimAutoreleasedReturnValue([v20 blindedMessage]);
          id v24 = sub_1000ACEB0((uint64_t)v21, v35, v22, v33, v32, v23);

          if (!v24)
          {
            uint64_t v30 = nplog_obj(v25, v26, v27);
            uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              id v41 = "+[NSPPrivateAccessTokenFetcher createTokenRequestsForChallenge:tokenKey:originNameKey:selectedOrigin"
                    ":waitingTokens:]";
              _os_log_fault_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_FAULT,  "%s called with null tokenRequest",  buf,  0xCu);
            }

            uint64_t v28 = 0LL;
            goto LABEL_12;
          }

          -[NSMutableArray addObject:](v12, "addObject:", v24);
        }

        id v17 = (char *)v17 + 1;
      }

      while (v15 != v17);
      id v15 = [v13 countByEnumeratingWithState:&v36 objects:v42 count:16];
      if (v15) {
        continue;
      }
      break;
    }
  }

  uint64_t v28 = v12;
LABEL_12:

  return v28;
}

void sub_1000B0108(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = a3;
  id v8 = a4;
  if (a1)
  {
    id v9 = a2;
    id v10 = objc_alloc_init(&OBJC_CLASS___NSPPrivacyProxyTokenKey);
    -[NSPPrivacyProxyTokenKey setKey:](v10, "setKey:", v9);

    id v11 = objc_alloc(&OBJC_CLASS___NSPPrivateAccessTokenChallenge);
    id v13 = -[NSPPrivateAccessTokenChallenge initWithData:](v11, "initWithData:", objc_getProperty(a1, v12, 56LL, 1));
    BOOL v14 = -[NSPPrivateAccessTokenChallenge isSupportedTokenType](v13, "isSupportedTokenType");
    if (v14)
    {
      id v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      id v18 = sub_1000AF854((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenFetcher, v13, v10, 0LL, v17, 0LL, 1LL);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      if ([v19 count])
      {
        id v22 = objc_getProperty(a1, v20, 80LL, 1);
        id v23 = (void *)objc_claimAutoreleasedReturnValue([a1 selectedOrigin]);
        id v24 = sub_1000AFE94((uint64_t)&OBJC_CLASS___NSPPrivateAccessTokenFetcher, v13, v10, v22, v23, v19);
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);

        if ([v25 count])
        {
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v19 firstObject]);
          objc_setProperty_atomic(a1, v29, v28, 96LL);

          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v25 firstObject]);
          objc_setProperty_atomic(a1, v31, v30, 104LL);

          id v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v17, "firstObject"));
          objc_setProperty_atomic(a1, v33, v32, 112LL);

          objc_setProperty_atomic(a1, v34, v10, 120LL);
          uint64_t v38 = nplog_obj(v35, v36, v37);
          __int128 v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "Generated token request", buf, 2u);
          }

          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_1000B07EC;
          block[3] = &unk_1000FB080;
          uint64_t v40 = &v49;
          id v49 = v8;
          id v48 = v25;
          dispatch_async(v7, block);
        }

        else
        {
          uint64_t v45 = nplog_obj(0LL, v26, v27);
          uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_error_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "Failed to generate token request",  buf,  2u);
          }

          v50[0] = _NSConcreteStackBlock;
          v50[1] = 3221225472LL;
          void v50[2] = sub_1000B0714;
          _OWORD v50[3] = &unk_1000FAE58;
          uint64_t v40 = &v51;
          id v51 = v8;
          dispatch_async(v7, v50);
        }
      }

      else
      {
        uint64_t v43 = nplog_obj(0LL, v20, v21);
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_ERROR,  "Failed to generate waiting tokens, cannot generate token request",  buf,  2u);
        }

        v52[0] = _NSConcreteStackBlock;
        v52[1] = 3221225472LL;
        v52[2] = sub_1000B063C;
        v52[3] = &unk_1000FAE58;
        id v53 = v8;
        dispatch_async(v7, v52);
        uint64_t v25 = v53;
      }
    }

    else
    {
      uint64_t v41 = nplog_obj(v14, v15, v16);
      uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "Unsupported token type, cannot generate token request",  buf,  2u);
      }

      v54[0] = _NSConcreteStackBlock;
      v54[1] = 3221225472LL;
      v54[2] = sub_1000B0564;
      _OWORD v54[3] = &unk_1000FAE58;
      uint64_t v55 = (NSMutableArray *)v8;
      dispatch_async(v7, v54);
      id v17 = v55;
    }
  }
}

void sub_1000B0564(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Unsupported token type";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1008LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000B063C(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Could not create waiting tokens";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1004LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000B0714(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Could not create token requests";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1004LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000B07EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) firstObject]);
  id v5 = v2;
  if (v2) {
    id Property = objc_getProperty(v2, v3, 24LL, 1);
  }
  else {
    id Property = 0LL;
  }
  (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, Property, 0LL);
}

void sub_1000B09E4(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Cannot fetch multiple local tokens with a single token fetcher";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1004LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000B0ABC(void **a1, void *a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id v6 = (dispatch_queue_s *)a1[4];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_1000B0B70;
    v7[3] = &unk_1000FB080;
    id v9 = a1[6];
    id v8 = v5;
    dispatch_async(v6, v7);
  }

  else
  {
    sub_1000B0108(a1[5], a2, a1[4], a1[6]);
  }
}

uint64_t sub_1000B0B70(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0LL,  *(void *)(a1 + 32));
}

void sub_1000B105C(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Invalid parameters";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1004LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1000B1134(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0LL,  *(void *)(a1 + 32));
}

void sub_1000B1148(uint64_t a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  id v6 = @"Failed to process token response";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
  uint64_t v4 = -[NSError initWithDomain:code:userInfo:]( v2,  "initWithDomain:code:userInfo:",  @"privacyProxyErrorDomain",  1007LL,  v3);

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1000B1220(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32),  0LL);
}

void sub_1000B17B0(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NSPCaptiveWiFiHandler);
  uint64_t v2 = (void *)qword_100117240;
  qword_100117240 = (uint64_t)v1;
}

void sub_1000B1A30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1000B1A6C(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    uint64_t v2 = objc_sync_enter(v1);
    if (*((_BYTE *)v1 + 8))
    {
      uint64_t v5 = nplog_obj(v2, v3, v4);
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        int v11 = 138412290;
        id v12 = v1;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "%@ reporting captive probe result",  (uint8_t *)&v11,  0xCu);
      }

      (*(void (**)(void))(*((void *)v1 + 6) + 16LL))();
    }

    uint64_t v7 = (void *)*((void *)v1 + 3);
    if (v7)
    {
      [v7 invalidateAndCancel];
      id v8 = (void *)*((void *)v1 + 3);
      *((void *)v1 + 3) = 0LL;
    }

    id v9 = (void *)*((void *)v1 + 4);
    *((void *)v1 + 4) = 0LL;

    id v10 = (void *)*((void *)v1 + 5);
    *((void *)v1 + 5) = 0LL;

    *((_BYTE *)v1 + _Block_object_dispose(va, 8) = 0;
    objc_sync_exit(v1);
  }

void sub_1000B1B7C(_Unwind_Exception *a1)
{
}

void sub_1000B1B9C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t WeakRetained = (uint64_t)objc_loadWeakRetained((id *)(a1 + 40));
  id v13 = (void *)WeakRetained;
  if (WeakRetained)
  {
    if (v9)
    {
      uint64_t v14 = nplog_obj(WeakRetained, v11, v12);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v45 = *(void **)(a1 + 32);
        int v50 = 138412546;
        id v51 = v45;
        __int16 v52 = 2112;
        id v53 = v9;
        _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "%@ failed to perform captive probe, error: %@",  (uint8_t *)&v50,  0x16u);
      }

      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v9 domain]);
      if ([v16 isEqualToString:NSURLErrorDomain])
      {
        id v17 = [v9 code];

        if (v17 == (id)-1001LL)
        {
          id v18 = v13;
LABEL_17:
          sub_1000B1A6C(v18);
          goto LABEL_18;
        }

id objc_msgSend_checkPrivacyProxyConnectivityOnInterface_proxyConnectivityCheckType_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "checkPrivacyProxyConnectivityOnInterface:proxyConnectivityCheckType:completionHandler:");
}

id objc_msgSend_fetchAuxiliaryAuthenticationDataFromCacheForType_label_cacheKey_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fetchAuxiliaryAuthenticationDataFromCacheForType:label:cacheKey:completionHandler:");
}

id objc_msgSend_fetchPairedPrivateAccessTokensForChallenge_overrideAttester_tokenKey_originNameKey_selectedOrigin_pairedChallenge_overridePairedAttester_pairedTokenKey_auditToken_bundleID_allowTools_systemTokenClient_accessToken_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "fetchPairedPrivateAccessTokensForChallenge:overrideAttester:tokenKey:originNameKey:selectedOrigin:pairedChall enge:overridePairedAttester:pairedTokenKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:");
}

id objc_msgSend_fetchPrivacyTokensOnInterface_tierType_proxyURL_tokenVendor_tokenIssuancePublicKey_tokenChallenge_tokenCount_accessToken_retryAttempt_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "fetchPrivacyTokensOnInterface:tierType:proxyURL:tokenVendor:tokenIssuancePublicKey:tokenChallenge:tokenCount: accessToken:retryAttempt:completionHandler:");
}

id objc_msgSend_fetchPrivateAccessTokenForChallenge_overrideAttester_customAttester_customAttesterHeaders_tokenKey_originNameKey_selectedOrigin_auxiliaryAuthInfoCacheKey_auditToken_bundleID_allowTools_systemTokenClient_accessToken_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "fetchPrivateAccessTokenForChallenge:overrideAttester:customAttester:customAttesterHeaders:tokenKey:originName Key:selectedOrigin:auxiliaryAuthInfoCacheKey:auditToken:bundleID:allowTools:systemTokenClient:accessToken:completionHandler:");
}

id objc_msgSend_getNSPEventStatsForSingleWindow_eventType_startDate_endDate_windowStartTime_windowDuration_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:");
}

id objc_msgSend_getNSPTokenStatsForSingleWindow_startDate_endDate_windowStartTime_windowDuration_statsCategory_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "getNSPTokenStatsForSingleWindow:startDate:endDate:windowStartTime:windowDuration:statsCategory:");
}

id objc_msgSend_initWithCoordinate_altitude_horizontalAccuracy_verticalAccuracy_timestamp_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:");
}

id objc_msgSend_initWithDelegate_ingressProxy_egressProxy_proxyPathWeight_allowFallback_fallbackToQUIC_forceFallback_allowFailOpen_geohashSharingEnabled_configEpoch_networkCharacteristics_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFai lOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:");
}

id objc_msgSend_initWithDelegate_obliviousConfig_obliviousHTTPType_transparencyKeyBundle_transparencyProof_obliviousTarget_proxyInfo_allowFailOpen_networkCharacteristics_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDelegate:obliviousConfig:obliviousHTTPType:transparencyKeyBundle:transparencyProof:obliviousTarget:pr oxyInfo:allowFailOpen:networkCharacteristics:");
}

id objc_msgSend_initWithIngressProxy_egressProxy_proxyPathWeight_preferredPathConfigURI_preferredPathPatterns_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:");
}

id objc_msgSend_initWithNetworkAgentRegistration_sessionType_configurationIdentifier_agentUUID_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithNetworkAgentRegistration:sessionType:configurationIdentifier:agentUUID:");
}

id objc_msgSend_initWithNetworkAgentRegistration_sessionType_configurationIdentifier_agentUUID_name_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithNetworkAgentRegistration:sessionType:configurationIdentifier:agentUUID:name:");
}

id objc_msgSend_proxiesMatch_proxyPathList_ingressProxy_egressProxy_pathWeight_supportsFallback_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "proxiesMatch:proxyPathList:ingressProxy:egressProxy:pathWeight:supportsFallback:");
}

id objc_msgSend_sendRTCReportWithFailureType_errorCode_url_ingressProxy_egressProxy_tokenServer_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sendRTCReportWithFailureType:errorCode:url:ingressProxy:egressProxy:tokenServer:");
}

id objc_msgSend_sendRequestForTokens_tokenFetchURLSession_tokenActivationQuery_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sendRequestForTokens:tokenFetchURLSession:tokenActivationQuery:completionHandler:");
}

id objc_msgSend_set_flowDivertHandle_inProcessFlowDivert_ingressProxyURL_ingressFallbackProxyURL_exceptionBundleIDs_exceptionProcessPaths_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "set:flowDivertHandle:inProcessFlowDivert:ingressProxyURL:ingressFallbackProxyURL:exceptionBundleIDs:exceptionProcessPaths:");
}

id objc_msgSend_setupWithPath_subscriber_unlimited_geohashSharingEnabled_geohashOverride_configEpoch_linkQuality_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "setupWithPath:subscriber:unlimited:geohashSharingEnabled:geohashOverride:configEpoch:linkQuality:");
}

id objc_msgSend_startConnectionForSessionTicketsWithEndpoint_parameters_dohQueryType_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startConnectionForSessionTicketsWithEndpoint:parameters:dohQueryType:completionHandler:");
}

id objc_msgSend_updateProactiveTokenFetchConfiguration_statsDuration_lowerTokenCountThreshold_lowerTokenCountProbability_upperLWMCountThreshold_upperLWMCountProbabilityOffset_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "updateProactiveTokenFetchConfiguration:statsDuration:lowerTokenCountThreshold:lowerTokenCountProbability:uppe rLWMCountThreshold:upperLWMCountProbabilityOffset:");
}

id objc_msgSend_updateProxyInfo_resolverInfo_proxyPathList_fallbackProxyPathList_obliviousConfigs_proxiedContentMaps_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "updateProxyInfo:resolverInfo:proxyPathList:fallbackProxyPathList:obliviousConfigs:proxiedContentMaps:");
}

id objc_msgSend_updateTokenFetchURL_accessTokenURL_accessTokenTypes_accessTokenBlockedIssuers_authenticationType_ignoreInvalidCerts_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "updateTokenFetchURL:accessTokenURL:accessTokenTypes:accessTokenBlockedIssuers:authenticationType:ignoreInvalidCerts:");
}

id objc_msgSend_verifyConfigurationSignature_configuration_host_validateCert_completionHandler_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "verifyConfigurationSignature:configuration:host:validateCert:completionHandler:");
}

id objc_msgSend_wiredStatusDisabledCount(void *a1, const char *a2, ...)
{
  return [a1 wiredStatusDisabledCount];
}